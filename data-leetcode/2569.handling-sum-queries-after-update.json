[
    {
        "title": "Handling Sum Queries After Update",
        "question_content": "You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries:\n\n\tFor a query of type 1, queries[i]&nbsp;= [1, l, r]. Flip the values from 0 to 1 and from 1 to 0 in nums1&nbsp;from index l to index r. Both l and r are 0-indexed.\n\tFor a query of type 2, queries[i]&nbsp;= [2, p, 0]. For every index 0 <= i < n, set&nbsp;nums2[i] =&nbsp;nums2[i]&nbsp;+ nums1[i]&nbsp;* p.\n\tFor a query of type 3, queries[i]&nbsp;= [3, 0, 0]. Find the sum of the elements in nums2.\n\nReturn an array containing all the answers to the third type&nbsp;queries.\n&nbsp;\nExample 1:\n\nInput: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]\nOutput: [3]\nExplanation: After the first query nums1 becomes [1,1,1]. After the second query, nums2 becomes [1,1,1], so the answer to the third query is 3. Thus, [3] is returned.\n\nExample 2:\n\nInput: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]\nOutput: [5]\nExplanation: After the first query, nums2 remains [5], so the answer to the second query is 5. Thus, [5] is returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums1.length,nums2.length <= 105\n\tnums1.length = nums2.length\n\t1 <= queries.length <= 105\n\tqueries[i].length = 3\n\t0 <= l <= r <= nums1.length - 1\n\t0 <= p <= 106\n\t0 <= nums1[i] <= 1\n\t0 <= nums2[i] <= 109",
        "solutions": [
            {
                "id": 3201936,
                "title": "python-convert-to-binary-and-use-xor",
                "content": "UP vote if you like the solution !!!\\n\\nApproach:\\n\\nThe problem involves implementing three types of queries on two arrays nums1 and nums2. The second and third query types are relatively straightforward to implement.\\n\\nFor a query of type 2, we need to add the product of p and the number of 1s in nums1. We can compute the number of set bits in nums1 using the bit_count() function.\\n\\nFor a query of type 3, we simply need to return the sum of all elements in nums2.\\n\\nQuery type 1 involves flipping the values in nums1 from index l to index r. We can achieve this using a bitwise XOR operation with a binary number that has ones in positions l to r and zeros elsewhere.\\n\\nTo construct this binary number, we can start with a binary number that has all ones, i.e., init = 111...1, where the number of ones is equal to the length of nums1. We can then right-shift init by l bits and subtract 1 to obtain a binary number with l ones in the least significant bits and zeros elsewhere. Similarly, we can right-shift init by r+1 bits and subtract 1 to obtain a binary number with r-l+1 ones in the least significant bits and zeros elsewhere.\\n\\nWe can then XOR nums1 with these two binary numbers to flip the bits in positions l to r. Finally, we can count the number of set bits in the resulting nums1 using the bit_count() function.\\n\\nHere\\'s the solution \\n\\n```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        l = len(nums1)\\n        init = 1<<l\\n        nums1 = int(\"\".join(map(str, nums1)), 2)\\n        cur= sum(nums2)\\n        ans =[]\\n        for f,s,t in queries:\\n            if f==1:\\n                a = (init>>s)-1\\n                b = (init>>(t+1))-1\\n                nums1 = nums1^a^b\\n            elif f==2:\\n                cnt =nums1.bit_count()\\n                cur+=s*cnt\\n            else:\\n                ans.append(cur)\\n        return ans\\n                \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        l = len(nums1)\\n        init = 1<<l\\n        nums1 = int(\"\".join(map(str, nums1)), 2)\\n        cur= sum(nums2)\\n        ans =[]\\n        for f,s,t in queries:\\n            if f==1:\\n                a = (init>>s)-1\\n                b = (init>>(t+1))-1\\n                nums1 = nums1^a^b\\n            elif f==2:\\n                cnt =nums1.bit_count()\\n                cur+=s*cnt\\n            else:\\n                ans.append(cur)\\n        return ans\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201909,
                "title": "lazy-propagation-segment-tree",
                "content": "We maintain the current `sum` of all elements in the second array.\\n\\nFor the type 2 query, we add `p` multiplied by the number of `1` in the first array to the `sum`.\\n\\nThe trick is to update and query the first array efficiently. We use lazy-propagation segment tree for that (you can find implementations onlne).\\n\\n> Java developers are in luck, since `BitSet` implements range flip and count bits efficiently.\\n> Python developers can use large integers; this approach is accepted now but could TLE with stonger test cases.\\n\\n**C++**\\n```cpp\\nint tree[400000] = {}, lazy[400000] = {};\\nint build(vector<int> &arr, int n, int a, int b)\\n{\\n    if (a == b)\\n        return tree[n] = arr[a];\\n    return tree[n] = build(arr, 2 * n, a, (a + b) / 2) + \\n\\t\\tbuild(arr, 2 * n + 1, (a + b) / 2 + 1, b);\\n}\\nint update_tree(int n, int a, int b, int i, int j)\\n{   \\n    if (b < i || a > j) // outside\\n        return lazy[n] ? b - a + 1 - tree[n] : tree[n];\\n    if (lazy[n]) {\\n        tree[n] = b - a + 1 - tree[n];\\n        if (a != b) {\\n            lazy[n * 2] = !lazy[n * 2];\\n            lazy[n * 2 + 1] = !lazy[n * 2 + 1];\\n        }\\n        lazy[n] = 0;\\n    }\\n    if (a >= i && b <= j) { // inside\\n        if (a != b) {\\n            lazy[n * 2] = !lazy[n * 2];\\n            lazy[n * 2 + 1] = !lazy[n * 2 + 1];\\n        }\\n        return tree[n] = b - a + 1 - tree[n];\\n    }\\n    return tree[n] = update_tree(n * 2, a, (a + b) / 2, i, j) +\\n        update_tree(n * 2 + 1, (a + b) / 2 + 1, b, i, j);\\n}  \\nvector<long long> handleQuery(vector<int>& n1, vector<int>& n2, vector<vector<int>>& queries) {\\n    long long sum = accumulate(begin(n2), end(n2), 0LL), sz = n1.size();\\n    build(n1, 1, 0, sz - 1);\\n    vector<long long> res;\\n    for (auto &q : queries) {\\n        if (q[0] == 1)\\n            update_tree(1, 0, sz - 1, q[1], q[2]);\\n        else if (q[0] == 2)\\n            sum += (long long)tree[1] * q[1];\\n        else\\n            res.push_back(sum);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint tree[400000] = {}, lazy[400000] = {};\\nint build(vector<int> &arr, int n, int a, int b)\\n{\\n    if (a == b)\\n        return tree[n] = arr[a];\\n    return tree[n] = build(arr, 2 * n, a, (a + b) / 2) + \\n\\t\\tbuild(arr, 2 * n + 1, (a + b) / 2 + 1, b);\\n}\\nint update_tree(int n, int a, int b, int i, int j)\\n{   \\n    if (b < i || a > j) // outside\\n        return lazy[n] ? b - a + 1 - tree[n] : tree[n];\\n    if (lazy[n]) {\\n        tree[n] = b - a + 1 - tree[n];\\n        if (a != b) {\\n            lazy[n * 2] = !lazy[n * 2];\\n            lazy[n * 2 + 1] = !lazy[n * 2 + 1];\\n        }\\n        lazy[n] = 0;\\n    }\\n    if (a >= i && b <= j) { // inside\\n        if (a != b) {\\n            lazy[n * 2] = !lazy[n * 2];\\n            lazy[n * 2 + 1] = !lazy[n * 2 + 1];\\n        }\\n        return tree[n] = b - a + 1 - tree[n];\\n    }\\n    return tree[n] = update_tree(n * 2, a, (a + b) / 2, i, j) +\\n        update_tree(n * 2 + 1, (a + b) / 2 + 1, b, i, j);\\n}  \\nvector<long long> handleQuery(vector<int>& n1, vector<int>& n2, vector<vector<int>>& queries) {\\n    long long sum = accumulate(begin(n2), end(n2), 0LL), sz = n1.size();\\n    build(n1, 1, 0, sz - 1);\\n    vector<long long> res;\\n    for (auto &q : queries) {\\n        if (q[0] == 1)\\n            update_tree(1, 0, sz - 1, q[1], q[2]);\\n        else if (q[0] == 2)\\n            sum += (long long)tree[1] * q[1];\\n        else\\n            res.push_back(sum);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3201961,
                "title": "bitset-class-approach-no-lazy-propagation-java-simple-solution-clean-code",
                "content": "# Code\\n```java\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> ls = new ArrayList<>();\\n        int n = nums1.length;\\n        BitSet bs = new BitSet(n);\\n        long sum = 0;\\n        for(int i = 0;i < n;i++){\\n            sum += 1L * nums2[i];\\n            if(nums1[i] == 1) bs.set(i);\\n        }\\n        for(var q:queries){\\n            if(q[0] == 1){\\n                bs.flip(q[1],q[2] + 1);\\n            }\\n            else if(q[0] == 2){\\n                sum += 1L * q[1] * bs.cardinality();\\n            }\\n            else ls.add(sum);\\n        }\\n        long ans[] = new long[ls.size()];\\n        for(int i = 0;i < ans.length;i++){\\n            ans[i] = ls.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Upvote if you like it \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> ls = new ArrayList<>();\\n        int n = nums1.length;\\n        BitSet bs = new BitSet(n);\\n        long sum = 0;\\n        for(int i = 0;i < n;i++){\\n            sum += 1L * nums2[i];\\n            if(nums1[i] == 1) bs.set(i);\\n        }\\n        for(var q:queries){\\n            if(q[0] == 1){\\n                bs.flip(q[1],q[2] + 1);\\n            }\\n            else if(q[0] == 2){\\n                sum += 1L * q[1] * bs.cardinality();\\n            }\\n            else ls.add(sum);\\n        }\\n        long ans[] = new long[ls.size()];\\n        for(int i = 0;i < ans.length;i++){\\n            ans[i] = ls.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203087,
                "title": "video-solution-convert-to-binary-python-bitset-java-c",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=rqM0IRhjHkQ\\n\\n# Code in C++\\n```\\n#define ll long long int\\n#define N 100005\\n\\nclass Solution {\\npublic:\\n     \\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        vector<ll> ans;\\n        \\n        bitset<N> bset(0);\\n        ll sum = 0;\\n        bitset<N> binit(0);\\n        binit.flip();\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums2[i];\\n            if(nums1[i]==1) \\n                bset[i] = 1;\\n        }\\n        \\n        for(auto q : queries){\\n            if(q[0] == 1){\\n                int sz = q[2] - q[1] + 1;\\n                bitset<N> btemp(binit<<sz);\\n                btemp = ~btemp;\\n                btemp <<= q[1];\\n                bset ^= btemp;\\n            }else if(q[0] == 2){\\n                sum += q[1] * bset.count();\\n            }else{\\n                ans.push_back(sum);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Code in Java [Got from one of the solutions on Discuss page]\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> ls = new ArrayList<>();\\n        int n = nums1.length;\\n        BitSet bs = new BitSet(n);\\n        long sum = 0;\\n        for(int i = 0;i < n;i++){\\n            sum += 1L * nums2[i];\\n            if(nums1[i] == 1) bs.set(i);\\n        }\\n        for(var q:queries){\\n            if(q[0] == 1){\\n                bs.flip(q[1],q[2] + 1);\\n            }\\n            else if(q[0] == 2){\\n                sum += 1L * q[1] * bs.cardinality();\\n            }\\n            else ls.add(sum);\\n        }\\n        long ans[] = new long[ls.size()];\\n        for(int i = 0;i < ans.length;i++){\\n            ans[i] = ls.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Code in Python [Got from one of the solutions on Discuss page]\\n```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        l = len(nums1)\\n        init = 1<<l\\n        nums1 = int(\"\".join(map(str, nums1)), 2)\\n        cur= sum(nums2)\\n        ans =[]\\n        for f,s,t in queries:\\n            if f==1:\\n                a = (init>>s)-1\\n                b = (init>>(t+1))-1\\n                nums1 = nums1^a^b\\n            elif f==2:\\n                cnt =nums1.bit_count()\\n                cur+=s*cnt\\n            else:\\n                ans.append(cur)\\n        return ans\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n#define N 100005\\n\\nclass Solution {\\npublic:\\n     \\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        vector<ll> ans;\\n        \\n        bitset<N> bset(0);\\n        ll sum = 0;\\n        bitset<N> binit(0);\\n        binit.flip();\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums2[i];\\n            if(nums1[i]==1) \\n                bset[i] = 1;\\n        }\\n        \\n        for(auto q : queries){\\n            if(q[0] == 1){\\n                int sz = q[2] - q[1] + 1;\\n                bitset<N> btemp(binit<<sz);\\n                btemp = ~btemp;\\n                btemp <<= q[1];\\n                bset ^= btemp;\\n            }else if(q[0] == 2){\\n                sum += q[1] * bset.count();\\n            }else{\\n                ans.push_back(sum);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> ls = new ArrayList<>();\\n        int n = nums1.length;\\n        BitSet bs = new BitSet(n);\\n        long sum = 0;\\n        for(int i = 0;i < n;i++){\\n            sum += 1L * nums2[i];\\n            if(nums1[i] == 1) bs.set(i);\\n        }\\n        for(var q:queries){\\n            if(q[0] == 1){\\n                bs.flip(q[1],q[2] + 1);\\n            }\\n            else if(q[0] == 2){\\n                sum += 1L * q[1] * bs.cardinality();\\n            }\\n            else ls.add(sum);\\n        }\\n        long ans[] = new long[ls.size()];\\n        for(int i = 0;i < ans.length;i++){\\n            ans[i] = ls.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        l = len(nums1)\\n        init = 1<<l\\n        nums1 = int(\"\".join(map(str, nums1)), 2)\\n        cur= sum(nums2)\\n        ans =[]\\n        for f,s,t in queries:\\n            if f==1:\\n                a = (init>>s)-1\\n                b = (init>>(t+1))-1\\n                nums1 = nums1^a^b\\n            elif f==2:\\n                cnt =nums1.bit_count()\\n                cur+=s*cnt\\n            else:\\n                ans.append(cur)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201913,
                "title": "python-segmentation-tree-with-lazy-propogation-explanation",
                "content": "We can find from the question:\\n* We only need to answer `sum(nums2)` every time encounters a query of type 3.\\n* Every time we can update `sum(nums2)` by a query of type 2 with `sum(nums2) += sum(nums1) * p`.\\n\\nSo, we should keep update the `sum(nums1)` for every query of type 1.\\nWe use Segmentation tree with Lazy Propogation to solve the problem.\\nFor Segmentation tree with Lazy Propogation, we should write three functions, Propogation(`proplazy`), Update and Query.\\nIn addition to the three functions, we know if we are going to flip all the value in the interval, the sum of the interval will the `sum(interval) = len(interval) - sum(interval)`.\\nSo, we need to record the length `self.len` and the initial summation `self.tree` of each node in the first time(i.e. the `__init__` function).\\nFor Propogation function, if the parent node has the mark to flip, then we update all summation of children nodes.\\nThis function will work every time we need to access to the children nodes when invoking the following functions.\\nFor Update function, we mark the flipping operation and update the summation, or just iterate with children nodes with lazy propogation.\\nFor Query function, we collect the summation from children nodes with lazy propogation.\\n\\n```python []\\nclass segtree():\\n    def __init__(self, n, nums):\\n        self.lazy = defaultdict(int)\\n        self.len = defaultdict(int)\\n        self.tree = defaultdict(int)\\n        # initial length and summation\\n        self.init_len(1, 0, n, 0, n, nums)\\n        self.init_num(1, 0, n, 0, n, nums)\\n        \\n    def init_len(self, ind, ul, ur, cl, cr, num):\\n        if cr < cl or cl >= len(num):\\n            return 0\\n        if cr == cl:\\n            self.len[ind] = 1\\n            return 1\\n        mid = (cl + cr) // 2\\n        if cl != cr:\\n            self.init_len(ind*2, ul, ur, cl, mid, num)\\n        self.init_len(ind*2+1, ul, ur, mid+1, cr, num)\\n        self.len[ind] = self.len[ind*2] + self.len[ind*2+1]\\n    \\n    def init_num(self, ind, ul, ur, cl, cr, num):\\n        if cr < cl or cl >= len(num):\\n            return\\n        if cl == cr:\\n            self.tree[ind] = num[cl]\\n            return\\n        mid = (cl + cr) // 2\\n        if cl != cr:\\n            self.init_num(ind*2, ul, ur, cl, mid, num)\\n        self.init_num(ind*2+1, ul, ur, mid+1, cr, num)\\n        \\n        self.tree[ind] = self.tree[ind*2] + self.tree[ind*2+1]\\n        \\n    \\n    def proplazy(self, ind):\\n        # if the parent node has the notation to flip, then we update all summation of children nodes.\\n        if self.lazy[ind]:\\n            self.lazy[ind*2] ^= self.lazy[ind]\\n            self.tree[ind*2] = self.len[ind*2] - self.tree[ind*2]\\n            self.lazy[ind*2 + 1] ^= self.lazy[ind]\\n            self.tree[ind*2 + 1] = self.len[ind*2+1] - self.tree[ind*2 + 1]\\n            self.tree[ind] = self.tree[ind*2] + self.tree[ind*2+1]\\n            self.lazy[ind] = 0\\n        \\n    def update(self, ind, ul, ur, cl, cr):\\n        if cl > ur or cr < ul:\\n            return \\n        if ul <= cl and cr <= ur:\\n            # mark to flip\\n            self.lazy[ind] ^= 1\\n            self.tree[ind] = self.len[ind] - self.tree[ind]\\n        else:\\n            mid = (cl + cr) // 2\\n            self.proplazy(ind)\\n            self.update(ind*2, ul, ur, cl, mid)\\n            self.update(ind*2+1, ul, ur, mid+1, cr)\\n            self.tree[ind] = self.tree[ind*2] + self.tree[ind*2+1]\\n           \\n    def query(self, ind, ul, ur, cl, cr):\\n        if cl > ur or cr < ul:\\n            return 0\\n        if ul <= cl and cr <= ur:\\n            return self.tree[ind]\\n        else:\\n            mid = (cl + cr) // 2\\n            self.proplazy(ind)\\n            return self.query(ind*2, ul, ur, cl, mid) + self.query(ind*2+1, ul, ur, mid+1, cr)\\n         \\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        seg = segtree(len(nums1) + 10, nums1)\\n        anss = []\\n        ans = sum(nums2)\\n        n = len(nums1) + 10\\n        for i, j, k in queries:\\n            if i == 1:\\n                seg.update(1, j, k, 0, n)\\n            if i == 2:\\n                ans += seg.tree[1] * j\\n            if i == 3:\\n                anss.append(ans)\\n        return anss\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass segtree():\\n    def __init__(self, n, nums):\\n        self.lazy = defaultdict(int)\\n        self.len = defaultdict(int)\\n        self.tree = defaultdict(int)\\n        # initial length and summation\\n        self.init_len(1, 0, n, 0, n, nums)\\n        self.init_num(1, 0, n, 0, n, nums)\\n        \\n    def init_len(self, ind, ul, ur, cl, cr, num):\\n        if cr < cl or cl >= len(num):\\n            return 0\\n        if cr == cl:\\n            self.len[ind] = 1\\n            return 1\\n        mid = (cl + cr) // 2\\n        if cl != cr:\\n            self.init_len(ind*2, ul, ur, cl, mid, num)\\n        self.init_len(ind*2+1, ul, ur, mid+1, cr, num)\\n        self.len[ind] = self.len[ind*2] + self.len[ind*2+1]\\n    \\n    def init_num(self, ind, ul, ur, cl, cr, num):\\n        if cr < cl or cl >= len(num):\\n            return\\n        if cl == cr:\\n            self.tree[ind] = num[cl]\\n            return\\n        mid = (cl + cr) // 2\\n        if cl != cr:\\n            self.init_num(ind*2, ul, ur, cl, mid, num)\\n        self.init_num(ind*2+1, ul, ur, mid+1, cr, num)\\n        \\n        self.tree[ind] = self.tree[ind*2] + self.tree[ind*2+1]\\n        \\n    \\n    def proplazy(self, ind):\\n        # if the parent node has the notation to flip, then we update all summation of children nodes.\\n        if self.lazy[ind]:\\n            self.lazy[ind*2] ^= self.lazy[ind]\\n            self.tree[ind*2] = self.len[ind*2] - self.tree[ind*2]\\n            self.lazy[ind*2 + 1] ^= self.lazy[ind]\\n            self.tree[ind*2 + 1] = self.len[ind*2+1] - self.tree[ind*2 + 1]\\n            self.tree[ind] = self.tree[ind*2] + self.tree[ind*2+1]\\n            self.lazy[ind] = 0\\n        \\n    def update(self, ind, ul, ur, cl, cr):\\n        if cl > ur or cr < ul:\\n            return \\n        if ul <= cl and cr <= ur:\\n            # mark to flip\\n            self.lazy[ind] ^= 1\\n            self.tree[ind] = self.len[ind] - self.tree[ind]\\n        else:\\n            mid = (cl + cr) // 2\\n            self.proplazy(ind)\\n            self.update(ind*2, ul, ur, cl, mid)\\n            self.update(ind*2+1, ul, ur, mid+1, cr)\\n            self.tree[ind] = self.tree[ind*2] + self.tree[ind*2+1]\\n           \\n    def query(self, ind, ul, ur, cl, cr):\\n        if cl > ur or cr < ul:\\n            return 0\\n        if ul <= cl and cr <= ur:\\n            return self.tree[ind]\\n        else:\\n            mid = (cl + cr) // 2\\n            self.proplazy(ind)\\n            return self.query(ind*2, ul, ur, cl, mid) + self.query(ind*2+1, ul, ur, mid+1, cr)\\n         \\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        seg = segtree(len(nums1) + 10, nums1)\\n        anss = []\\n        ans = sum(nums2)\\n        n = len(nums1) + 10\\n        for i, j, k in queries:\\n            if i == 1:\\n                seg.update(1, j, k, 0, n)\\n            if i == 2:\\n                ans += seg.tree[1] * j\\n            if i == 3:\\n                anss.append(ans)\\n        return anss\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203321,
                "title": "python3-lazy-segment-tree",
                "content": "\\n```\\nclass SegTreeLazy: \\n    \\n    def __init__(self, arr: List[int]): \\n        \"\"\"Build the segmentation tree.\"\"\"\\n        self.n = n = len(arr)\\n        self.tree = [0]*(4*n)\\n        self.lazy = [0]*(4*n)\\n        \\n        def build(k: int, lo: int, hi: int) -> None: \\n            \"\"\"Build segment tree from array.\"\"\"\\n            if lo+1 == hi: self.tree[k] = arr[lo]\\n            else: \\n                mid = lo + hi >> 1\\n                build(2*k+1, lo, mid)\\n                build(2*k+2, mid, hi)\\n                self.tree[k] = self.tree[2*k+1] + self.tree[2*k+2]\\n        \\n        build(0, 0, n)\\n\\n\\n    def update(self, qlo: int, qhi: int, k: int = 0, lo: int = 0, hi: int = 0) -> None:\\n        \"\"\"Update segment tree when value in [qlo, qhi) is flipped.\"\"\"\\n        if not hi: hi = self.n\\n        if self.lazy[k]: \\n            self.tree[k] = (hi - lo) - self.tree[k]\\n            if lo+1 < hi: \\n                self.lazy[2*k+1] ^= 1\\n                self.lazy[2*k+2] ^= 1 \\n            self.lazy[k] = 0\\n        if lo < hi and qlo < hi and lo < qhi: \\n            if qlo <= lo and hi <= qhi: # total overlap\\n                self.tree[k] = (hi - lo) - self.tree[k]\\n                if lo+1 < hi: \\n                    self.lazy[2*k+1] ^= 1\\n                    self.lazy[2*k+2] ^= 1\\n                return \\n            mid = lo + hi >> 1\\n            self.update(qlo, qhi, 2*k+1, lo, mid) \\n            self.update(qlo, qhi, 2*k+2, mid, hi)\\n            self.tree[k] = self.tree[2*k+1] + self.tree[2*k+2]\\n            \\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        tree = SegTreeLazy(nums1)\\n        ans = []\\n        val = sum(nums2)\\n        for x, y, z in queries: \\n            if x == 1: tree.update(y, z+1)\\n            elif x == 2: val += y * tree.tree[0]\\n            else: ans.append(val)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SegTreeLazy: \\n    \\n    def __init__(self, arr: List[int]): \\n        \"\"\"Build the segmentation tree.\"\"\"\\n        self.n = n = len(arr)\\n        self.tree = [0]*(4*n)\\n        self.lazy = [0]*(4*n)\\n        \\n        def build(k: int, lo: int, hi: int) -> None: \\n            \"\"\"Build segment tree from array.\"\"\"\\n            if lo+1 == hi: self.tree[k] = arr[lo]\\n            else: \\n                mid = lo + hi >> 1\\n                build(2*k+1, lo, mid)\\n                build(2*k+2, mid, hi)\\n                self.tree[k] = self.tree[2*k+1] + self.tree[2*k+2]\\n        \\n        build(0, 0, n)\\n\\n\\n    def update(self, qlo: int, qhi: int, k: int = 0, lo: int = 0, hi: int = 0) -> None:\\n        \"\"\"Update segment tree when value in [qlo, qhi) is flipped.\"\"\"\\n        if not hi: hi = self.n\\n        if self.lazy[k]: \\n            self.tree[k] = (hi - lo) - self.tree[k]\\n            if lo+1 < hi: \\n                self.lazy[2*k+1] ^= 1\\n                self.lazy[2*k+2] ^= 1 \\n            self.lazy[k] = 0\\n        if lo < hi and qlo < hi and lo < qhi: \\n            if qlo <= lo and hi <= qhi: # total overlap\\n                self.tree[k] = (hi - lo) - self.tree[k]\\n                if lo+1 < hi: \\n                    self.lazy[2*k+1] ^= 1\\n                    self.lazy[2*k+2] ^= 1\\n                return \\n            mid = lo + hi >> 1\\n            self.update(qlo, qhi, 2*k+1, lo, mid) \\n            self.update(qlo, qhi, 2*k+2, mid, hi)\\n            self.tree[k] = self.tree[2*k+1] + self.tree[2*k+2]\\n            \\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        tree = SegTreeLazy(nums1)\\n        ans = []\\n        val = sum(nums2)\\n        for x, y, z in queries: \\n            if x == 1: tree.update(y, z+1)\\n            elif x == 2: val += y * tree.tree[0]\\n            else: ans.append(val)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201874,
                "title": "segment-tree-o-n-log-n-c",
                "content": "# Intuition\\nSegment tree and observation\\n\\n# Approach\\nFirst notice that the 3 ask for the sum of the whole $nums2$ and the operation 2 adds a multiple of $p$ and this is equal to the $kp$ with $k$ equal to the number of ones of the $nums1$ so the indices doesn\\'t matter and we only take care of how many ones are in $nums1$ \\n\\nThe only complex operations is the first and here the indices matters , but with a simple lazy segment tree is easy to deal with them , for each node we save the sum of the elements that cover and a swap operations change the value of the node in the next way $value[node_x] = len -value[node_x]$\\n\\nIs need to know how lazy segment tree works here are a good reference https://cp-algorithms.com/data_structures/segment_tree.html\\n\\n# Complexity\\n- Time complexity:\\n$O(n log(n))$\\n\\n- Space complexity:\\n$O(4\\\\times n)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> st;\\n    vector<long long> lazy;\\n    \\n    void propagate(int v,int l ,int r){\\n        if(!lazy[v])return ;\\n        long long len = (r-l)+1;\\n        \\n        if(lazy[v]&1)\\n            st[v] = len-st[v];\\n\\n        if(l!= r){\\n            lazy[v<<1] += lazy[v];\\n            lazy[v<<1|1]+= lazy[v];\\n        }\\n        \\n        lazy[v] = 0;\\n    }\\n    void update(int l,int r,int v,int sl,int sr ){\\n        propagate(v,sl,sr);\\n        if(r<sl || l>sr || sl>sr)return ;\\n        if(sl>= l && sr<=r){\\n            lazy[v] ++;\\n            propagate(v,sl,sr);\\n            return;\\n        }\\n        int m = (sl+sr)>>1;\\n        update(l,r,v<<1,sl,m);\\n        update(l,r,v<<1|1,m+1,sr);\\n        st[v] = st[v<<1]+st[v<<1|1];\\n    }\\n\\n    long long query(int l,int r,int v,int sl,int sr){\\n        propagate(v,sl,sr);\\n        if(r<sl || l>sr || sl>sr)return 0; \\n        if(sl>= l && sr<=r)return st[v];\\n        int m = (sl+sr)>>1;\\n        return query(l,r,v<<1,sl,m)+query(l,r,v<<1|1,m+1,sr);\\n    }\\n    \\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        st.resize(4*n);\\n        lazy.resize(4*n);\\n        \\n        long long sum = 0;\\n        for(int i = 0;i<n;i++)\\n            sum+=nums2[i];\\n        \\n        vector<long long> ans;\\n        for(int i = 0;i<n;i++){\\n            if(nums1[i]== 1)\\n                update(i,i,1,0,n-1);\\n        }\\n        for(auto q:queries){\\n            if(q[0]==1)\\n                update(q[1],q[2],1,0,n-1);\\n            else if(q[0] == 2){\\n                long long c = query(0,n-1,1,0,n-1);\\n                sum+=c*(long long)q[1];\\n            }\\n            else\\n                ans.push_back(sum);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> st;\\n    vector<long long> lazy;\\n    \\n    void propagate(int v,int l ,int r){\\n        if(!lazy[v])return ;\\n        long long len = (r-l)+1;\\n        \\n        if(lazy[v]&1)\\n            st[v] = len-st[v];\\n\\n        if(l!= r){\\n            lazy[v<<1] += lazy[v];\\n            lazy[v<<1|1]+= lazy[v];\\n        }\\n        \\n        lazy[v] = 0;\\n    }\\n    void update(int l,int r,int v,int sl,int sr ){\\n        propagate(v,sl,sr);\\n        if(r<sl || l>sr || sl>sr)return ;\\n        if(sl>= l && sr<=r){\\n            lazy[v] ++;\\n            propagate(v,sl,sr);\\n            return;\\n        }\\n        int m = (sl+sr)>>1;\\n        update(l,r,v<<1,sl,m);\\n        update(l,r,v<<1|1,m+1,sr);\\n        st[v] = st[v<<1]+st[v<<1|1];\\n    }\\n\\n    long long query(int l,int r,int v,int sl,int sr){\\n        propagate(v,sl,sr);\\n        if(r<sl || l>sr || sl>sr)return 0; \\n        if(sl>= l && sr<=r)return st[v];\\n        int m = (sl+sr)>>1;\\n        return query(l,r,v<<1,sl,m)+query(l,r,v<<1|1,m+1,sr);\\n    }\\n    \\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        st.resize(4*n);\\n        lazy.resize(4*n);\\n        \\n        long long sum = 0;\\n        for(int i = 0;i<n;i++)\\n            sum+=nums2[i];\\n        \\n        vector<long long> ans;\\n        for(int i = 0;i<n;i++){\\n            if(nums1[i]== 1)\\n                update(i,i,1,0,n-1);\\n        }\\n        for(auto q:queries){\\n            if(q[0]==1)\\n                update(q[1],q[2],1,0,n-1);\\n            else if(q[0] == 2){\\n                long long c = query(0,n-1,1,0,n-1);\\n                sum+=c*(long long)q[1];\\n            }\\n            else\\n                ans.push_back(sum);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202646,
                "title": "easy-c-code-lazy-propagation-segment-tree-fast",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<ll> a, tree, lazy;\\n\\n    void build(int node,int start,int end)\\n    {\\n        if(start == end)\\n        {\\n            tree[node] = a[start];\\n            return;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        build(2*node,start,mid);\\n        build(2*node+1,mid+1,end);\\n\\n        tree[node] = tree[2*node] + tree[2*node+1];\\n    }\\n\\n    ll query(int node,int start,int end,int l,int r)\\n    {\\n        if(lazy[node]%2==1)\\n        {\\n            int k = lazy[node];\\n          \\n            lazy[node] = 0;               \\n            tree[node] =  (end - start + 1) - tree[node]; \\n\\n            if(start!=end) \\n            {\\n                lazy[2*node] += k ;\\n                lazy[2*node+1] += k;\\n            }\\n        }\\n\\n        if(start>r || end<l)\\n        return 0;\\n\\n        if(start>=l && end<=r)\\n        return tree[node];\\n\\n        ll mid = (start + end) / 2;\\n\\n        ll left = query(2*node,start,mid,l,r);\\n        ll right = query(2*node+1,mid+1,end,l,r);\\n        return left + right;\\n    }\\n\\n    void update(int node,int start,int end,int l,int r,int val)\\n    {\\n        if(lazy[node]%2==1)\\n        {\\n            int k = lazy[node];\\n            lazy[node] = 0;\\n            tree[node]  =(end - start + 1)  - tree[node] ;\\n\\n            if(start!=end)\\n            {\\n                lazy[2*node] += k ;\\n                lazy[2*node+1] += k;\\n            }\\n        }\\n        \\n\\n        if(start>r || end<l)\\n        return;\\n\\n        if(start>=l && end<=r)\\n        {\\n            int k = (end - start + 1)  - tree[node];\\n            tree[node] = k;\\n\\n            if(start!=end)  \\n            {\\n                lazy[2*node] += val;\\n                lazy[2*node+1] += val;\\n            }\\n\\n            return;\\n        }\\n\\n        int mid = (start + end) / 2;\\n\\n        update(2*node,start,mid,l,r,val);\\n        update(2*node+1,mid+1,end,l,r,val);\\n\\n        tree[node] = tree[2*node+1] + tree[2*node];\\n    }\\n\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        ll sum2 = 0;\\n        int nn = 100005;\\n        a.resize(nn,0);\\n        tree.resize(4*nn,0);\\n        lazy.resize(4*nn,0);\\n        \\n        int n = nums1.size();\\n        for(auto &i:nums2){\\n            sum2+=i;\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            a[i+1] = nums1[i];\\n        }\\n        vector<ll>ans;\\n        build(1,1,n);\\n        for(auto &i:queries){\\n            if(i[0]==1){\\n                update(1,1,n,i[1]+1,i[2]+1,1);\\n            }\\n            else if(i[0]==2){\\n                ll p = i[1];\\n                sum2+= p*query(1,1,n,1,n);\\n            }\\n            else if(i[0]==3){\\n                ans.push_back(sum2);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<ll> a, tree, lazy;\\n\\n    void build(int node,int start,int end)\\n    {\\n        if(start == end)\\n        {\\n            tree[node] = a[start];\\n            return;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        build(2*node,start,mid);\\n        build(2*node+1,mid+1,end);\\n\\n        tree[node] = tree[2*node] + tree[2*node+1];\\n    }\\n\\n    ll query(int node,int start,int end,int l,int r)\\n    {\\n        if(lazy[node]%2==1)\\n        {\\n            int k = lazy[node];\\n          \\n            lazy[node] = 0;               \\n            tree[node] =  (end - start + 1) - tree[node]; \\n\\n            if(start!=end) \\n            {\\n                lazy[2*node] += k ;\\n                lazy[2*node+1] += k;\\n            }\\n        }\\n\\n        if(start>r || end<l)\\n        return 0;\\n\\n        if(start>=l && end<=r)\\n        return tree[node];\\n\\n        ll mid = (start + end) / 2;\\n\\n        ll left = query(2*node,start,mid,l,r);\\n        ll right = query(2*node+1,mid+1,end,l,r);\\n        return left + right;\\n    }\\n\\n    void update(int node,int start,int end,int l,int r,int val)\\n    {\\n        if(lazy[node]%2==1)\\n        {\\n            int k = lazy[node];\\n            lazy[node] = 0;\\n            tree[node]  =(end - start + 1)  - tree[node] ;\\n\\n            if(start!=end)\\n            {\\n                lazy[2*node] += k ;\\n                lazy[2*node+1] += k;\\n            }\\n        }\\n        \\n\\n        if(start>r || end<l)\\n        return;\\n\\n        if(start>=l && end<=r)\\n        {\\n            int k = (end - start + 1)  - tree[node];\\n            tree[node] = k;\\n\\n            if(start!=end)  \\n            {\\n                lazy[2*node] += val;\\n                lazy[2*node+1] += val;\\n            }\\n\\n            return;\\n        }\\n\\n        int mid = (start + end) / 2;\\n\\n        update(2*node,start,mid,l,r,val);\\n        update(2*node+1,mid+1,end,l,r,val);\\n\\n        tree[node] = tree[2*node+1] + tree[2*node];\\n    }\\n\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        ll sum2 = 0;\\n        int nn = 100005;\\n        a.resize(nn,0);\\n        tree.resize(4*nn,0);\\n        lazy.resize(4*nn,0);\\n        \\n        int n = nums1.size();\\n        for(auto &i:nums2){\\n            sum2+=i;\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            a[i+1] = nums1[i];\\n        }\\n        vector<ll>ans;\\n        build(1,1,n);\\n        for(auto &i:queries){\\n            if(i[0]==1){\\n                update(1,1,n,i[1]+1,i[2]+1,1);\\n            }\\n            else if(i[0]==2){\\n                ll p = i[1];\\n                sum2+= p*query(1,1,n,1,n);\\n            }\\n            else if(i[0]==3){\\n                ans.push_back(sum2);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202216,
                "title": "lazy-propogation-on-segment-tree-easy-c",
                "content": "# Intuition\\nEverytime there\\'s a range query, you gotta give segment tree a try.\\n\\n# Approach\\nThere are no range queries on nums2 so we can store its initial sum in a variable and modify it on every query of `TYPE 2` .\\n\\nNow for nums1 instead of storing storing number of 1s in a range is same as storing the sum of a range (since all other elements are zero)\\nSo we maintain a bool array that tells us if we\\'ve to update a node. Now if l=0 and r=8 and number of 1s=2 then new value of sum will be `length of range(r-l+1) - sum of range(number of 1s)=7`.  \\n\\nUpdating a node twice results in no modification at all hence.\\n\\n# Complexity\\n- Time complexity:\\nNlogN (N queries and logN for every update query)\\n\\n- Space complexity:\\nO(4N(seg tree)+N(ans array)) = O(N)\\n\\n# Code\\n```\\nusing ll=long long;\\nclass segmentTree {\\nprivate:\\n\\tvector<ll> segTree;\\n\\tvector<bool> lazy;\\n    void propogateDown(ll ind,ll low,ll high){\\n\\t\\tif (lazy[ind]) {\\n\\t\\t\\tsegTree[ind] = (high-low+1)-segTree[ind];\\n\\t\\t\\tif (low != high) {\\n\\t\\t\\t\\t//propogate the lazy update downwards\\n\\t\\t\\t\\t//for the remaining nodes to get updated\\n\\t\\t\\t\\tlazy[2 * ind + 1] = !lazy[2 * ind + 1];\\n\\t\\t\\t\\tlazy[2 * ind + 2] = !lazy[2 * ind + 2];\\n\\t\\t\\t}\\n\\t\\t\\tlazy[ind] = 0;\\n\\t\\t}\\n    }\\npublic:\\n\\tsegmentTree(vector<int> &arr) {\\n\\t\\tll n = arr.size();\\n\\t\\tsegTree.resize(4 * n + 1);\\n\\t\\tlazy.resize(4* n + 1);\\n\\t\\tbuild(0,0,n-1,arr);\\n\\t}\\n\\tvoid build(ll ind, ll low, ll high, vector<int> &arr) {\\n\\t\\tif (low == high) {\\n\\t\\t\\tsegTree[ind] = arr[low];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tll mid = low + (high - low) / 2;\\n\\t\\tbuild(2 * ind + 1, low, mid, arr);\\n\\t\\tbuild(2 * ind + 2, mid + 1, high, arr);\\n\\t\\tsegTree[ind] = segTree[2 * ind + 1] + segTree[2 * ind + 2];\\n\\t}\\n\\n\\tvoid rangeUpdate(ll ind, ll low, ll high, ll l, ll r) {\\n\\t\\tif (low > high) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// apply any pending lazy updates\\n        propogateDown(ind,low,high);\\n\\t\\t// no overlap\\n\\t\\tif (low > r || high < l) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// complete overlap\\n\\t\\tif (low >= l && high <= r) {\\n\\t\\t\\tsegTree[ind] = (high-low+1)-segTree[ind];\\n\\t\\t\\tif (low != high) {\\n\\t\\t\\t\\t//propogate the lazy update downwards\\n\\t\\t\\t\\t//for the remaining nodes to get updated\\n\\t\\t\\t\\tlazy[2 * ind + 1] = !lazy[2 * ind + 1];\\n\\t\\t\\t\\tlazy[2 * ind + 2] = !lazy[2 * ind + 2];\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// partial overlap\\n\\t\\tll mid = (low + high) >> 1;\\n\\t\\trangeUpdate(2 * ind + 1, low, mid, l, r);\\n\\t\\trangeUpdate(2 * ind + 2, mid + 1, high, l, r);\\n\\t\\tsegTree[ind] = segTree[2 * ind + 1] + segTree[2 * ind + 2];\\n\\t}\\n\\n\\tll query(ll ind, ll low, ll high, ll l, ll r) {\\n\\t\\tif (low > r || high < l) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n        // apply any pending lazy updates\\n\\t\\tpropogateDown(ind,low,high);\\n\\t\\tif (low >= l && high <= r) {\\n\\t\\t\\treturn segTree[ind];\\n\\t\\t}\\n\\t\\t\\n\\t\\tll mid = (low + high) >> 1;\\n\\t\\tll left = query(2 * ind + 1, low, mid, l, r);\\n\\t\\tll right = query(2 * ind + 2, mid + 1, high, l, r);\\n\\t\\treturn left + right;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        segmentTree st(nums1);\\n        ll sum=accumulate(begin(nums2),end(nums2),0LL);\\n        vector <ll> ans;\\n        for(auto query:queries){\\n            ll q=query[0];\\n            ll l=query[1];\\n            ll r=query[2];\\n            if(q==1){\\n                st.rangeUpdate(0,0,nums1.size()-1,l,r);\\n            }\\n            else if(q==2){\\n                ll temp=st.query(0,0,nums1.size()-1,0,nums1.size()-1);\\n                sum+=(1LL*l*temp);\\n            }\\n            else ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nusing ll=long long;\\nclass segmentTree {\\nprivate:\\n\\tvector<ll> segTree;\\n\\tvector<bool> lazy;\\n    void propogateDown(ll ind,ll low,ll high){\\n\\t\\tif (lazy[ind]) {\\n\\t\\t\\tsegTree[ind] = (high-low+1)-segTree[ind];\\n\\t\\t\\tif (low != high) {\\n\\t\\t\\t\\t//propogate the lazy update downwards\\n\\t\\t\\t\\t//for the remaining nodes to get updated\\n\\t\\t\\t\\tlazy[2 * ind + 1] = !lazy[2 * ind + 1];\\n\\t\\t\\t\\tlazy[2 * ind + 2] = !lazy[2 * ind + 2];\\n\\t\\t\\t}\\n\\t\\t\\tlazy[ind] = 0;\\n\\t\\t}\\n    }\\npublic:\\n\\tsegmentTree(vector<int> &arr) {\\n\\t\\tll n = arr.size();\\n\\t\\tsegTree.resize(4 * n + 1);\\n\\t\\tlazy.resize(4* n + 1);\\n\\t\\tbuild(0,0,n-1,arr);\\n\\t}\\n\\tvoid build(ll ind, ll low, ll high, vector<int> &arr) {\\n\\t\\tif (low == high) {\\n\\t\\t\\tsegTree[ind] = arr[low];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tll mid = low + (high - low) / 2;\\n\\t\\tbuild(2 * ind + 1, low, mid, arr);\\n\\t\\tbuild(2 * ind + 2, mid + 1, high, arr);\\n\\t\\tsegTree[ind] = segTree[2 * ind + 1] + segTree[2 * ind + 2];\\n\\t}\\n\\n\\tvoid rangeUpdate(ll ind, ll low, ll high, ll l, ll r) {\\n\\t\\tif (low > high) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// apply any pending lazy updates\\n        propogateDown(ind,low,high);\\n\\t\\t// no overlap\\n\\t\\tif (low > r || high < l) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// complete overlap\\n\\t\\tif (low >= l && high <= r) {\\n\\t\\t\\tsegTree[ind] = (high-low+1)-segTree[ind];\\n\\t\\t\\tif (low != high) {\\n\\t\\t\\t\\t//propogate the lazy update downwards\\n\\t\\t\\t\\t//for the remaining nodes to get updated\\n\\t\\t\\t\\tlazy[2 * ind + 1] = !lazy[2 * ind + 1];\\n\\t\\t\\t\\tlazy[2 * ind + 2] = !lazy[2 * ind + 2];\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// partial overlap\\n\\t\\tll mid = (low + high) >> 1;\\n\\t\\trangeUpdate(2 * ind + 1, low, mid, l, r);\\n\\t\\trangeUpdate(2 * ind + 2, mid + 1, high, l, r);\\n\\t\\tsegTree[ind] = segTree[2 * ind + 1] + segTree[2 * ind + 2];\\n\\t}\\n\\n\\tll query(ll ind, ll low, ll high, ll l, ll r) {\\n\\t\\tif (low > r || high < l) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n        // apply any pending lazy updates\\n\\t\\tpropogateDown(ind,low,high);\\n\\t\\tif (low >= l && high <= r) {\\n\\t\\t\\treturn segTree[ind];\\n\\t\\t}\\n\\t\\t\\n\\t\\tll mid = (low + high) >> 1;\\n\\t\\tll left = query(2 * ind + 1, low, mid, l, r);\\n\\t\\tll right = query(2 * ind + 2, mid + 1, high, l, r);\\n\\t\\treturn left + right;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        segmentTree st(nums1);\\n        ll sum=accumulate(begin(nums2),end(nums2),0LL);\\n        vector <ll> ans;\\n        for(auto query:queries){\\n            ll q=query[0];\\n            ll l=query[1];\\n            ll r=query[2];\\n            if(q==1){\\n                st.rangeUpdate(0,0,nums1.size()-1,l,r);\\n            }\\n            else if(q==2){\\n                ll temp=st.query(0,0,nums1.size()-1,0,nums1.size()-1);\\n                sum+=(1LL*l*temp);\\n            }\\n            else ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201859,
                "title": "lazy-propagation-on-segment-tree",
                "content": "**Prerequisite**: Lazy progragation on a segment tree.\\n\\nObservation=> We need to know the sum of nums1 array at every number 3 query. \\n\\nThere is range update on  query of type 1 and range update kind of always smells lazy propagation. \\nSo how can we progagate xor? \\nans: sry, i couldn\\'t find a way to propagate xor. So replaced every 0 in nums1 array with -1. And at every query of type 1 propagate multiplication of -1 to the given range.\\n\\nquery of type 2 is just the number of ones in our array. \\n`ones = (sum(nums1)+n)/2` Because we have replaced 0 with -1.\\n\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> list = new ArrayList<>();\\n        long answer = 0L;\\n        int n = nums1.length;\\n        for(int i=0;i<n;i++) if(nums1[i] == 0) nums1[i] = -1;\\n        SegmentTree sg = new SegmentTree(nums1);\\n        for(int a: nums2) answer += a;\\n        for(int[] q: queries){\\n            if(q[0] == 1) sg.multiplyToRange(q[1],q[2],-1);\\n            else if(q[0] == 2) answer += q[1]*((sg.getSumInRange(0,n-1)+n)/2);\\n            else list.add(answer);\\n        }\\n        long[] ans = new long[list.size()];\\n        for(int i=0;i<ans.length;i++) ans[i] = list.get(i);\\n        return ans;\\n    }\\n\\n}\\nclass SegmentTree{\\n    long[] segmentArray;\\n    long[] lazy;\\n    int length;\\n\\n    public SegmentTree(int[] nums){\\n        this.length = nums.length;\\n        int height = (int)Math.ceil(Math.log(length)/Math.log(2));\\n        int lengthOfSegmentTree = 2*(1<<height)-1;\\n        this.segmentArray = new long[lengthOfSegmentTree];\\n        this.lazy = new long[lengthOfSegmentTree];\\n        Arrays.fill(lazy,1L);\\n        constructor(0,length-1,0,nums);\\n    }\\n    private long constructor(int ss, int se, int si,int[] nums){\\n        if(ss == se) return segmentArray[si] = nums[ss];\\n        int mid = (ss+se)/2;\\n        return segmentArray[si] = constructor(ss,mid,2*si+1,nums)+constructor(mid+1,se,2*si+2,nums);\\n    }\\n    public void multiplyToRange(int left, int right, long value){\\n        mul(0,length-1,0,left,right,value);\\n    }\\n    private long mul(int ss, int se, int si, int qs, int qe, long value){\\n        if(se<qs || qe<ss) return segmentArray[si];\\n        if(ss != se) propagate(si);\\n        if(qs<=ss && se<=qe){\\n            lazy[si] = value;\\n            return segmentArray[si] = (segmentArray[si]*value);\\n        }\\n        int mid = (ss+se)>>1;\\n        return segmentArray[si] = (mul(ss,mid,2*si+1,qs,qe,value)+mul(mid+1,se,2*si+2,qs,qe,value));\\n    }\\n\\n    public long getSumInRange(int left, int right){\\n        return getSum(0,length-1,0,left,right);\\n    }\\n\\n    private long getSum(int ss, int se, int si, int qs, int qe){\\n        if(se<qs || qe<ss) return 0L;\\n        if(ss != se) propagate(si);\\n        if(qs<=ss && se<=qe) return segmentArray[si];\\n        int mid = (ss+se)>>1;\\n        return (getSum(ss,mid,2*si+1,qs,qe)+ getSum(mid+1,se,2*si+2,qs,qe));\\n    }\\n\\n\\n    private void propagate(int si){\\n        if(lazy[si]!=1){\\n            segmentArray[2*si+1] = (segmentArray[2*si+1]*lazy[si]);\\n            segmentArray[2*si+2] = (segmentArray[2*si+2]*lazy[si]);\\n            lazy[2*si+1] = (lazy[2*si+1]*lazy[si]);\\n            lazy[2*si+2] = (lazy[2*si+2]*lazy[si]);\\n            lazy[si] = 1;\\n        }\\n    }\\n}\\n\\n\\n```\\nI had written this segment tree for this question [Multiplication and Sum](https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/B)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> list = new ArrayList<>();\\n        long answer = 0L;\\n        int n = nums1.length;\\n        for(int i=0;i<n;i++) if(nums1[i] == 0) nums1[i] = -1;\\n        SegmentTree sg = new SegmentTree(nums1);\\n        for(int a: nums2) answer += a;\\n        for(int[] q: queries){\\n            if(q[0] == 1) sg.multiplyToRange(q[1],q[2],-1);\\n            else if(q[0] == 2) answer += q[1]*((sg.getSumInRange(0,n-1)+n)/2);\\n            else list.add(answer);\\n        }\\n        long[] ans = new long[list.size()];\\n        for(int i=0;i<ans.length;i++) ans[i] = list.get(i);\\n        return ans;\\n    }\\n\\n}\\nclass SegmentTree{\\n    long[] segmentArray;\\n    long[] lazy;\\n    int length;\\n\\n    public SegmentTree(int[] nums){\\n        this.length = nums.length;\\n        int height = (int)Math.ceil(Math.log(length)/Math.log(2));\\n        int lengthOfSegmentTree = 2*(1<<height)-1;\\n        this.segmentArray = new long[lengthOfSegmentTree];\\n        this.lazy = new long[lengthOfSegmentTree];\\n        Arrays.fill(lazy,1L);\\n        constructor(0,length-1,0,nums);\\n    }\\n    private long constructor(int ss, int se, int si,int[] nums){\\n        if(ss == se) return segmentArray[si] = nums[ss];\\n        int mid = (ss+se)/2;\\n        return segmentArray[si] = constructor(ss,mid,2*si+1,nums)+constructor(mid+1,se,2*si+2,nums);\\n    }\\n    public void multiplyToRange(int left, int right, long value){\\n        mul(0,length-1,0,left,right,value);\\n    }\\n    private long mul(int ss, int se, int si, int qs, int qe, long value){\\n        if(se<qs || qe<ss) return segmentArray[si];\\n        if(ss != se) propagate(si);\\n        if(qs<=ss && se<=qe){\\n            lazy[si] = value;\\n            return segmentArray[si] = (segmentArray[si]*value);\\n        }\\n        int mid = (ss+se)>>1;\\n        return segmentArray[si] = (mul(ss,mid,2*si+1,qs,qe,value)+mul(mid+1,se,2*si+2,qs,qe,value));\\n    }\\n\\n    public long getSumInRange(int left, int right){\\n        return getSum(0,length-1,0,left,right);\\n    }\\n\\n    private long getSum(int ss, int se, int si, int qs, int qe){\\n        if(se<qs || qe<ss) return 0L;\\n        if(ss != se) propagate(si);\\n        if(qs<=ss && se<=qe) return segmentArray[si];\\n        int mid = (ss+se)>>1;\\n        return (getSum(ss,mid,2*si+1,qs,qe)+ getSum(mid+1,se,2*si+2,qs,qe));\\n    }\\n\\n\\n    private void propagate(int si){\\n        if(lazy[si]!=1){\\n            segmentArray[2*si+1] = (segmentArray[2*si+1]*lazy[si]);\\n            segmentArray[2*si+2] = (segmentArray[2*si+2]*lazy[si]);\\n            lazy[2*si+1] = (lazy[2*si+1]*lazy[si]);\\n            lazy[2*si+2] = (lazy[2*si+2]*lazy[si]);\\n            lazy[si] = 1;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228170,
                "title": "lazy-segment-tree-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void propriogate(int i,int j,int n,vector<long long int> &tree,vector<long long int> &lazy){\\n        if(!lazy[n])return;\\n        int len = j-i+1;\\n        if(lazy[n]&1){\\n            tree[n] = len-tree[n];\\n        }\\n        if(i!=j){\\n        lazy[2*n+1] += lazy[n];\\n        lazy[2*n+2] += lazy[n];}\\n        lazy[n] = 0;\\n    }\\n    void update(int s,int e,int i,int j,vector<long long int> &tree,int n,vector<long long int> &lazy){\\n        propriogate(i,j,n,tree,lazy);\\n        if(s>j||e<i||i>j)return;\\n        if(s<=i&&e>=j){\\n            lazy[n]++;\\n            propriogate(i,j,n,tree,lazy);\\n            return;\\n        }\\n        int mid = (j-i)/2+i;\\n        update(s,e,i,mid,tree,2*n+1,lazy);\\n        update(s,e,mid+1,j,tree,2*n+2,lazy);\\n        tree[n] = tree[n*2+1]+tree[2*n+2];\\n    }\\n    long long query(int l,int r,int i,int j,vector<long long int> &tree,int n,vector<long long int> &lazy){\\n        propriogate(i,j,n,tree,lazy);\\n        if(r<i||l>j)return 0;\\n        if(l>=i&&j<=r)return tree[n];\\n        int mid = (j-i)/2+i;\\n        return query(l,r,i,mid,tree,2*n+1,lazy)+query(l,r,mid+1,j,tree,2*n+2,lazy);\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long> v;\\n        long long sum = 0;\\n        int n = nums1.size(),i;\\n        for(auto &i: nums2){\\n            sum += i;\\n        }\\n        vector<long long int> tree(5*n),lazy(5*n);\\n        for(i = 0; i < n; i++){\\n            if(nums1[i]){\\n                update(i,i,0,n-1,tree,0,lazy);\\n            }\\n        }\\n        for(auto &i: queries){\\n            if(i[0]==1){\\n                update(i[1],i[2],0,n-1,tree,0,lazy);\\n            }else if(i[0]==2){\\n                sum += query(0,n-1,0,n-1,tree,0,lazy)*i[1];\\n                // sum += tree[0]*i[1];\\n            }else{\\n                v.push_back(sum);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void propriogate(int i,int j,int n,vector<long long int> &tree,vector<long long int> &lazy){\\n        if(!lazy[n])return;\\n        int len = j-i+1;\\n        if(lazy[n]&1){\\n            tree[n] = len-tree[n];\\n        }\\n        if(i!=j){\\n        lazy[2*n+1] += lazy[n];\\n        lazy[2*n+2] += lazy[n];}\\n        lazy[n] = 0;\\n    }\\n    void update(int s,int e,int i,int j,vector<long long int> &tree,int n,vector<long long int> &lazy){\\n        propriogate(i,j,n,tree,lazy);\\n        if(s>j||e<i||i>j)return;\\n        if(s<=i&&e>=j){\\n            lazy[n]++;\\n            propriogate(i,j,n,tree,lazy);\\n            return;\\n        }\\n        int mid = (j-i)/2+i;\\n        update(s,e,i,mid,tree,2*n+1,lazy);\\n        update(s,e,mid+1,j,tree,2*n+2,lazy);\\n        tree[n] = tree[n*2+1]+tree[2*n+2];\\n    }\\n    long long query(int l,int r,int i,int j,vector<long long int> &tree,int n,vector<long long int> &lazy){\\n        propriogate(i,j,n,tree,lazy);\\n        if(r<i||l>j)return 0;\\n        if(l>=i&&j<=r)return tree[n];\\n        int mid = (j-i)/2+i;\\n        return query(l,r,i,mid,tree,2*n+1,lazy)+query(l,r,mid+1,j,tree,2*n+2,lazy);\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long> v;\\n        long long sum = 0;\\n        int n = nums1.size(),i;\\n        for(auto &i: nums2){\\n            sum += i;\\n        }\\n        vector<long long int> tree(5*n),lazy(5*n);\\n        for(i = 0; i < n; i++){\\n            if(nums1[i]){\\n                update(i,i,0,n-1,tree,0,lazy);\\n            }\\n        }\\n        for(auto &i: queries){\\n            if(i[0]==1){\\n                update(i[1],i[2],0,n-1,tree,0,lazy);\\n            }else if(i[0]==2){\\n                sum += query(0,n-1,0,n-1,tree,0,lazy)*i[1];\\n                // sum += tree[0]*i[1];\\n            }else{\\n                v.push_back(sum);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223323,
                "title": "bit-manipulation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n=nums1.size();\\n        const int m=1e5+4;\\n        bitset<m>b;\\n        bitset<m>a;\\n        bitset<m>c;\\n        vector<long long>ans;\\n        long long res=0;\\n        for(auto i:nums2)res+=i;\\n        for(int i=0;i<n;i++){\\n            if(nums1[i])b[i]=1;\\n        }\\n        for(auto i:queries){\\n            if(i[0]==1){\\n                a.set();\\n                c.set();\\n                a<<=i[1];\\n                c<<=(i[2]+1);\\n                a^=c;\\n                b^=a;\\n            }else if(i[0]==2){\\n                res+=((long long)i[1]*b.count());\\n            }else{\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n=nums1.size();\\n        const int m=1e5+4;\\n        bitset<m>b;\\n        bitset<m>a;\\n        bitset<m>c;\\n        vector<long long>ans;\\n        long long res=0;\\n        for(auto i:nums2)res+=i;\\n        for(int i=0;i<n;i++){\\n            if(nums1[i])b[i]=1;\\n        }\\n        for(auto i:queries){\\n            if(i[0]==1){\\n                a.set();\\n                c.set();\\n                a<<=i[1];\\n                c<<=(i[2]+1);\\n                a^=c;\\n                b^=a;\\n            }else if(i[0]==2){\\n                res+=((long long)i[1]*b.count());\\n            }else{\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202338,
                "title": "solution-using-xor-and-bit-count",
                "content": "# Intuition and Description of Algorithm\\nBecause of the size of the input, we need a solution with runtime complexity like $$\\\\mathcal{O}(n)$$. Therefore, we are considering `nums1` as the binary representation of some number. Each time having a query of 1st type we make XOR of `nums1` and $$x=\\\\underbrace{11...11}_{r - l + 1}\\\\underbrace{0...0}_{k}$$, where $$k=$$`len(nums1)-r-1`(i.e. $x$ has ones in the range where we want to flip bits of `nums1`).\\n\\nBesides, a crucial ingredient is the efficient counting of non-zero bits via `bit_count()`.\\n\\nSee details in the code snippet below.\\n\\n---\\n\\n**Please upvote \\u2B06\\uFE0F**\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$\\\\mathcal{O}(n)$$\\n\\n- Space complexity: $$\\\\mathcal{O}(n)$$\\n\\n---\\n\\n# Code\\n```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        # get nums1 as the binary representation of some number\\n        n1 = int(\\'\\'.join([str(d) for d in nums1]), 2)\\n        res = []\\n        key = False\\n        # calculate sum of nums1 and nums2\\n        sum1, sum2 = n1.bit_count(), sum(nums2)\\n        for t, left, right in queries:\\n            if t == 1:\\n                # make xor of nums1 to flip corresponding bits\\n                temp = \\'1\\'*(right - left + 1) + \\'0\\'*(len(nums1) - right - 1)\\n                n1 ^= int(temp, 2)\\n                key = True\\n            if t == 2:\\n                # we don\\'t recalculate sum1 when it isn\\'t necessary\\n                if key:\\n                    sum1 = n1.bit_count()\\n                    key = False\\n\\n                sum2 += left*sum1      \\n            if t == 3:\\n                res.append(sum2)\\n        \\n        return res                   \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        # get nums1 as the binary representation of some number\\n        n1 = int(\\'\\'.join([str(d) for d in nums1]), 2)\\n        res = []\\n        key = False\\n        # calculate sum of nums1 and nums2\\n        sum1, sum2 = n1.bit_count(), sum(nums2)\\n        for t, left, right in queries:\\n            if t == 1:\\n                # make xor of nums1 to flip corresponding bits\\n                temp = \\'1\\'*(right - left + 1) + \\'0\\'*(len(nums1) - right - 1)\\n                n1 ^= int(temp, 2)\\n                key = True\\n            if t == 2:\\n                # we don\\'t recalculate sum1 when it isn\\'t necessary\\n                if key:\\n                    sum1 = n1.bit_count()\\n                    key = False\\n\\n                sum2 += left*sum1      \\n            if t == 3:\\n                res.append(sum2)\\n        \\n        return res                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202069,
                "title": "java-segment-tree-with-lazy-propagation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI need a data structure that helps me handle the range update. The initial thought is the binary index tree.\\nHowever, I can\\'t use it to handle the flip operation.\\nThen I consider the Segment Tree with the lazy propagation.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n# Code\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        Deque<Long> dq = new LinkedList();\\n        long sum = 0;\\n        for (int i : nums2) sum += i;\\n        Segment root = build(nums1, 0, nums1.length - 1);\\n        for (int[] q : queries) {\\n            if (1 == q[0]) root.flip(q[1], q[2]);\\n            else if (2 == q[0]) sum += root.sum * q[1];\\n            else dq.add(sum);\\n        }\\n        int n = dq.size(), i = 0;\\n        long[] res = new long[n];\\n        while (!dq.isEmpty()) res[i++] = dq.poll();\\n        return res;\\n    }\\n    class Segment {\\n        long sum;\\n        int f, lo, hi;\\n        Segment left, right;\\n        public Segment(int l, int r) {\\n            lo = l;\\n            hi = r;\\n        }\\n        public long flip(int l, int r) {\\n            if (hi < l || r < lo) return sum;            \\n            if (l <= lo && hi <= r) {        \\n                f ^= 1;\\n                return sum = hi - lo + 1 - sum;                \\n            }                      \\n            if (1 == f) {\\n                left.flip(lo, hi);\\n                right.flip(lo, hi);                                \\n                f ^= 1;\\n            }\\n            left.flip(l, r);\\n            right.flip(l, r);                \\n            return sum = left.sum + right.sum;\\n        }        \\n    }\\n    private Segment build(int[] nums, int l, int r) {\\n        if (l == r) {\\n            Segment node = new Segment(l, r);\\n            node.sum = nums[l];\\n            return node;\\n        }\\n        int mid = l + ((r - l) >> 1);\\n        Segment left = build(nums, l, mid), right = build(nums, mid + 1, r);\\n        Segment root = new Segment(l, r);\\n        root.left = left;\\n        root.right = right;\\n        root.sum = left.sum + right.sum;\\n        return root;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        Deque<Long> dq = new LinkedList();\\n        long sum = 0;\\n        for (int i : nums2) sum += i;\\n        Segment root = build(nums1, 0, nums1.length - 1);\\n        for (int[] q : queries) {\\n            if (1 == q[0]) root.flip(q[1], q[2]);\\n            else if (2 == q[0]) sum += root.sum * q[1];\\n            else dq.add(sum);\\n        }\\n        int n = dq.size(), i = 0;\\n        long[] res = new long[n];\\n        while (!dq.isEmpty()) res[i++] = dq.poll();\\n        return res;\\n    }\\n    class Segment {\\n        long sum;\\n        int f, lo, hi;\\n        Segment left, right;\\n        public Segment(int l, int r) {\\n            lo = l;\\n            hi = r;\\n        }\\n        public long flip(int l, int r) {\\n            if (hi < l || r < lo) return sum;            \\n            if (l <= lo && hi <= r) {        \\n                f ^= 1;\\n                return sum = hi - lo + 1 - sum;                \\n            }                      \\n            if (1 == f) {\\n                left.flip(lo, hi);\\n                right.flip(lo, hi);                                \\n                f ^= 1;\\n            }\\n            left.flip(l, r);\\n            right.flip(l, r);                \\n            return sum = left.sum + right.sum;\\n        }        \\n    }\\n    private Segment build(int[] nums, int l, int r) {\\n        if (l == r) {\\n            Segment node = new Segment(l, r);\\n            node.sum = nums[l];\\n            return node;\\n        }\\n        int mid = l + ((r - l) >> 1);\\n        Segment left = build(nums, l, mid), right = build(nums, mid + 1, r);\\n        Segment root = new Segment(l, r);\\n        root.left = left;\\n        root.right = right;\\n        root.sum = left.sum + right.sum;\\n        return root;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202012,
                "title": "lazy-segment-trees",
                "content": "\\n\\n# Intution and Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild a lazy segment tree to handle type1 queries and in both type2 and type3 queries we dont need any updates to be actually done on nums2 instead just maintaining overall sum is enough.So finally for every type2 query getting the no of 1s in the overall nums1 array is enough.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLOGN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(NLOGN)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct segmentTreeLazy\\n{\\n    int n;\\n    vector<long long> st, lazy;\\n\\n    void build(int start, int ending, int node, vector<int> &v)\\n    {\\n        if (start == ending)\\n        {\\n            st[node] = v[start];\\n            return;\\n        }\\n\\n        int mid = (start+ending) / 2;\\n        // left subtree is (start, mid)\\n\\n        build(start, mid, 2 * node + 1, v);\\n\\n        // right subtree is (mid+1, ending)\\n\\n        build(mid + 1, ending, 2 * node + 2, v);\\n\\n        st[node] = st[node * 2 + 1] + st[node * 2 + 2];\\n    }\\n\\n    void init(int _n)\\n    {\\n        this->n = _n;\\n        st.resize(4 * n, 0);\\n        lazy.resize(4 * n, 0);\\n    }\\n\\n    long long query(int start, int ending, int l, int r, int node)\\n    {\\n        // lazy propagation\\n\\n        if (lazy[node] != 0)\\n        {\\n            if (lazy[node] % 2 == 1)\\n            {\\n                int a = st[node];\\n                st[node] = ending - start + 1 - a;\\n            }\\n\\n            if (start != ending)\\n            {\\n                lazy[2 * node + 1] += lazy[node];\\n                lazy[2 * node + 2] += lazy[node];\\n            }\\n\\n            lazy[node] = 0;\\n        }\\n\\n        // non overlapping case\\n        if (start > r || ending < l)\\n        {\\n            return 0;\\n        }\\n\\n        // complete overlap\\n       else  if (start >= l && ending <= r)\\n        {\\n            return st[node];\\n        }\\n        else\\n        {\\n            int mid = (start+ending) / 2;\\n\\n            long long q1 = query(start, mid, l, r, 2 * node + 1);\\n            long long q2 = query(mid + 1, ending, l, r, 2 * node + 2);\\n\\n            return q1 + q2;\\n        }\\n    }\\n\\n    void update(int start, int ending, int node, int l, int r)\\n    {\\n        // lazy propagation\\n\\n        if (lazy[node] != 0)\\n        {\\n            if (lazy[node] % 2 == 1)\\n            {\\n                int a = st[node];\\n                st[node] = ending - start + 1 - a;\\n            }\\n\\n            if (start != ending)\\n            {\\n                lazy[2 * node + 1] += lazy[node];\\n                lazy[2 * node + 2] += lazy[node];\\n            }\\n\\n            lazy[node] = 0;\\n        }\\n\\n        // non overlapping\\n        if (start > r || ending < l)\\n        {\\n            return;\\n        }\\n\\n        // complete overlap\\n        else if (start >= l && ending <= r)\\n        {\\n            long long a = st[node];\\n            st[node] = ending - start + 1 - a;\\n            if (start != ending)\\n            {\\n                lazy[2 * node + 1] += 1;\\n                lazy[2 * node + 2] += 1;\\n            }\\n        }\\n        else\\n        {\\n            int mid = (start+ending) / 2;\\n            update(start, mid, 2 * node + 1, l, r);\\n            update(mid + 1, ending, 2 * node + 2, l, r);\\n\\n            st[node] = st[2 * node + 1] + st[2 * node + 2];\\n        }\\n    }\\n    long long query(int l, int r)\\n    {\\n        return query(0, n - 1, l, r, 0);\\n    }\\n\\n    void build(vector<int> &v)\\n    {\\n        build(0, v.size() - 1, 0, v);\\n    }\\n    // add x in range l to r\\n    void update(int l, int r)\\n    {\\n        update(0, n - 1, 0, l, r);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        segmentTreeLazy tree;\\n        int n=nums1.size();\\n    tree.init(n);\\n    tree.build(nums1);\\n        vector<long long> ans;\\n        long long rsum=0;\\n        for(int i=0;i<nums2.size();i++){\\n            rsum+=nums2[i];\\n        }\\n        for(auto q:queries){\\n            if(q[0]==1){\\n                tree.update(q[1],q[2]);\\n                \\n            }else if(q[0]==2){\\n                rsum+=(tree.query(0,n-1)*q[1]);\\n            }else {\\n                ans.push_back(rsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct segmentTreeLazy\\n{\\n    int n;\\n    vector<long long> st, lazy;\\n\\n    void build(int start, int ending, int node, vector<int> &v)\\n    {\\n        if (start == ending)\\n        {\\n            st[node] = v[start];\\n            return;\\n        }\\n\\n        int mid = (start+ending) / 2;\\n        // left subtree is (start, mid)\\n\\n        build(start, mid, 2 * node + 1, v);\\n\\n        // right subtree is (mid+1, ending)\\n\\n        build(mid + 1, ending, 2 * node + 2, v);\\n\\n        st[node] = st[node * 2 + 1] + st[node * 2 + 2];\\n    }\\n\\n    void init(int _n)\\n    {\\n        this->n = _n;\\n        st.resize(4 * n, 0);\\n        lazy.resize(4 * n, 0);\\n    }\\n\\n    long long query(int start, int ending, int l, int r, int node)\\n    {\\n        // lazy propagation\\n\\n        if (lazy[node] != 0)\\n        {\\n            if (lazy[node] % 2 == 1)\\n            {\\n                int a = st[node];\\n                st[node] = ending - start + 1 - a;\\n            }\\n\\n            if (start != ending)\\n            {\\n                lazy[2 * node + 1] += lazy[node];\\n                lazy[2 * node + 2] += lazy[node];\\n            }\\n\\n            lazy[node] = 0;\\n        }\\n\\n        // non overlapping case\\n        if (start > r || ending < l)\\n        {\\n            return 0;\\n        }\\n\\n        // complete overlap\\n       else  if (start >= l && ending <= r)\\n        {\\n            return st[node];\\n        }\\n        else\\n        {\\n            int mid = (start+ending) / 2;\\n\\n            long long q1 = query(start, mid, l, r, 2 * node + 1);\\n            long long q2 = query(mid + 1, ending, l, r, 2 * node + 2);\\n\\n            return q1 + q2;\\n        }\\n    }\\n\\n    void update(int start, int ending, int node, int l, int r)\\n    {\\n        // lazy propagation\\n\\n        if (lazy[node] != 0)\\n        {\\n            if (lazy[node] % 2 == 1)\\n            {\\n                int a = st[node];\\n                st[node] = ending - start + 1 - a;\\n            }\\n\\n            if (start != ending)\\n            {\\n                lazy[2 * node + 1] += lazy[node];\\n                lazy[2 * node + 2] += lazy[node];\\n            }\\n\\n            lazy[node] = 0;\\n        }\\n\\n        // non overlapping\\n        if (start > r || ending < l)\\n        {\\n            return;\\n        }\\n\\n        // complete overlap\\n        else if (start >= l && ending <= r)\\n        {\\n            long long a = st[node];\\n            st[node] = ending - start + 1 - a;\\n            if (start != ending)\\n            {\\n                lazy[2 * node + 1] += 1;\\n                lazy[2 * node + 2] += 1;\\n            }\\n        }\\n        else\\n        {\\n            int mid = (start+ending) / 2;\\n            update(start, mid, 2 * node + 1, l, r);\\n            update(mid + 1, ending, 2 * node + 2, l, r);\\n\\n            st[node] = st[2 * node + 1] + st[2 * node + 2];\\n        }\\n    }\\n    long long query(int l, int r)\\n    {\\n        return query(0, n - 1, l, r, 0);\\n    }\\n\\n    void build(vector<int> &v)\\n    {\\n        build(0, v.size() - 1, 0, v);\\n    }\\n    // add x in range l to r\\n    void update(int l, int r)\\n    {\\n        update(0, n - 1, 0, l, r);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        segmentTreeLazy tree;\\n        int n=nums1.size();\\n    tree.init(n);\\n    tree.build(nums1);\\n        vector<long long> ans;\\n        long long rsum=0;\\n        for(int i=0;i<nums2.size();i++){\\n            rsum+=nums2[i];\\n        }\\n        for(auto q:queries){\\n            if(q[0]==1){\\n                tree.update(q[1],q[2]);\\n                \\n            }else if(q[0]==2){\\n                rsum+=(tree.query(0,n-1)*q[1]);\\n            }else {\\n                ans.push_back(rsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3201921,
                "title": "sqrt-decomposition-c-o-n-sqrt-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe value in nums2 is not important.\\nThe important thing is the total number of 1, and maintain the value of nums1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCut the entire array of nums1 into sqrt(n) \"seq\" of size sqrt(n).\\n\"sn\" represents how many 1s are in this seq.\\n\"tag\" indicates whether this seq has been turned over by the whole block.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWhen q = 1, it can be divided into two case discussions...\\n\\n    Case A: updating range is small, then directly change the value in seq -> O(sqrt(n))\\n    Case B: updating range is large, then you can know the total number of modified 1 by changing the tag and querying sn for each seq -> O(sqrt(n))\\n\\nWhen q = 2 or 3, since we always know what the total number of 1\\'s is, p*|1\\'s| is the value added to the answer -> O(1)\\n\\nQuery at most n times ->O(n*sqrt(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(n)) * O(sqrt(n)) = O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    long long sum=0,num=0;//answer & the total number of 1 \\n    struct seq{\\n        int sn=0;\\n        bool tag=0,a[320];\\n    };seq A[320];\\n    vector<long long> handleQuery(vector<int>& n1, vector<int>& n2, vector<vector<int>>& q) {\\n        n=n1.size();\\n        m=sqrt(n);\\n        vector <long long> ans;\\n        for(int i=0;i<n;++i){\\n            num+=n1[i];\\n            A[i/m].sn+=n1[i];\\n            A[i/m].a[i%m]=n1[i];\\n            sum+=n2[i];\\n        }  \\n        for(int i=0;i<q.size();++i){\\n            if(q[i][0]==1){\\n                int l=q[i][1],r=q[i][2];\\n                int ln=l/m,lm=l%m,rn=r/m,rm=r%m;\\n                if(ln==rn){//Case A\\n                    for(int i=lm;i<=rm;++i){\\n                        if(A[ln].tag==0){\\n                            if(A[ln].a[i]){\\n                                --num;\\n                                --A[ln].sn;\\n                            }\\n                            else{\\n                                ++num;\\n                                ++A[ln].sn;\\n                            }\\n                        }\\n                        else{\\n                            if(A[ln].a[i]){\\n                                ++num;\\n                                ++A[ln].sn;\\n                            }\\n                            else{\\n                                --num;\\n                                --A[ln].sn;\\n                            }\\n                        }\\n                        A[ln].a[i]^=1;\\n                    }\\n                }\\n                else{//Case B\\n                    for(int i=lm;i<m;++i){\\n                        if(A[ln].tag==0){\\n                            if(A[ln].a[i]){\\n                                --num;\\n                                --A[ln].sn;\\n                            }\\n                            else{\\n                                ++num;\\n                                ++A[ln].sn;\\n                            }\\n                        }\\n                        else{\\n                            if(A[ln].a[i]){\\n                                ++num;\\n                                ++A[ln].sn;\\n                            }\\n                            else{\\n                                --num;\\n                                --A[ln].sn;\\n                            }\\n                        }\\n                        A[ln].a[i]^=1;\\n                    }\\n                    for(int i=ln+1;i<=rn-1;++i){\\n                        int la=A[i].sn;\\n                        A[i].tag^=1;\\n                        A[i].sn=m-la;\\n                        num-=(la-A[i].sn);\\n                    }\\n                    for(int i=0;i<=rm;++i){\\n                        if(A[rn].tag==0){\\n                            if(A[rn].a[i]){\\n                                --num;\\n                                --A[rn].sn;\\n                            }\\n                            else{\\n                                ++num;\\n                                ++A[rn].sn;\\n                            }\\n                        }\\n                        else{\\n                            if(A[rn].a[i]){\\n                                ++num;\\n                                ++A[rn].sn;\\n                            }\\n                            else{\\n                                --num;\\n                                --A[rn].sn;\\n                            }\\n                        }\\n                        A[rn].a[i]^=1;\\n                    }\\n                }\\n            }\\n            else if(q[i][0]==2){\\n                sum+=(long long)(q[i][1])*num;\\n            }\\n            else{//q = 3\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    long long sum=0,num=0;//answer & the total number of 1 \\n    struct seq{\\n        int sn=0;\\n        bool tag=0,a[320];\\n    };seq A[320];\\n    vector<long long> handleQuery(vector<int>& n1, vector<int>& n2, vector<vector<int>>& q) {\\n        n=n1.size();\\n        m=sqrt(n);\\n        vector <long long> ans;\\n        for(int i=0;i<n;++i){\\n            num+=n1[i];\\n            A[i/m].sn+=n1[i];\\n            A[i/m].a[i%m]=n1[i];\\n            sum+=n2[i];\\n        }  \\n        for(int i=0;i<q.size();++i){\\n            if(q[i][0]==1){\\n                int l=q[i][1],r=q[i][2];\\n                int ln=l/m,lm=l%m,rn=r/m,rm=r%m;\\n                if(ln==rn){//Case A\\n                    for(int i=lm;i<=rm;++i){\\n                        if(A[ln].tag==0){\\n                            if(A[ln].a[i]){\\n                                --num;\\n                                --A[ln].sn;\\n                            }\\n                            else{\\n                                ++num;\\n                                ++A[ln].sn;\\n                            }\\n                        }\\n                        else{\\n                            if(A[ln].a[i]){\\n                                ++num;\\n                                ++A[ln].sn;\\n                            }\\n                            else{\\n                                --num;\\n                                --A[ln].sn;\\n                            }\\n                        }\\n                        A[ln].a[i]^=1;\\n                    }\\n                }\\n                else{//Case B\\n                    for(int i=lm;i<m;++i){\\n                        if(A[ln].tag==0){\\n                            if(A[ln].a[i]){\\n                                --num;\\n                                --A[ln].sn;\\n                            }\\n                            else{\\n                                ++num;\\n                                ++A[ln].sn;\\n                            }\\n                        }\\n                        else{\\n                            if(A[ln].a[i]){\\n                                ++num;\\n                                ++A[ln].sn;\\n                            }\\n                            else{\\n                                --num;\\n                                --A[ln].sn;\\n                            }\\n                        }\\n                        A[ln].a[i]^=1;\\n                    }\\n                    for(int i=ln+1;i<=rn-1;++i){\\n                        int la=A[i].sn;\\n                        A[i].tag^=1;\\n                        A[i].sn=m-la;\\n                        num-=(la-A[i].sn);\\n                    }\\n                    for(int i=0;i<=rm;++i){\\n                        if(A[rn].tag==0){\\n                            if(A[rn].a[i]){\\n                                --num;\\n                                --A[rn].sn;\\n                            }\\n                            else{\\n                                ++num;\\n                                ++A[rn].sn;\\n                            }\\n                        }\\n                        else{\\n                            if(A[rn].a[i]){\\n                                ++num;\\n                                ++A[rn].sn;\\n                            }\\n                            else{\\n                                --num;\\n                                --A[rn].sn;\\n                            }\\n                        }\\n                        A[rn].a[i]^=1;\\n                    }\\n                }\\n            }\\n            else if(q[i][0]==2){\\n                sum+=(long long)(q[i][1])*num;\\n            }\\n            else{//q = 3\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201873,
                "title": "c-lazy-segment-tree",
                "content": "# Handling Sum Queries After Update\\n\\nThis problem is a Range Query DS problem. Love seeing this category of problems - please have more of these LeetCode!\\n\\n- First query can be handled by a `n.log(n)` RQDS like Segment Tree, etc.\\n- Since the third query asks us the sum of the entire array, we can just maintain a variable that accumulates the sum.\\n- Second query is essentially \"Sum up `p` times the number of ones in `nums1`\" in the context of the third query.\\n\\n**Solution Idea**\\n\\n- Maintain a segment tree that can answer the queries \"Count number of 1s in an array where we have flip operations\". This is a standard problem for RQDS and can be easily found online. The segment tree implementation I\\'ve uses the lazy propagation technique.\\n- For every query of type `1`, update the segment tree range to flip the values (this step uses lazy prop. in my code). Essentially, the value a node holds will become `[length of range] - [number of set 1s in range]`.\\n- For every query of type `2`, update the cumulative sum by adding `p` multiplied by the number of set bits in range `[0, n - 1]`.\\n- For every query of type `3`, add the cumulative sum to a results array.\\n\\nTime Complexity: **O(n.log(n))**\\n\\nSpace Complexity: **O(n)**\\n\\n**Code**\\n\\n```cpp\\nclass Solution {\\n  public:\\n    vector <long long> handleQuery (vector <int>& nums1, vector <int>& nums2, vector <vector <int>>& queries) {\\n      int n = nums1.size();\\n      int64_t answer = std::accumulate(nums2.begin(), nums2.end(), int64_t(0));\\n      std::vector <long long> results;\\n      \\n      struct node {\\n        int value = 0;\\n        bool lazy = false;\\n      };\\n      \\n      std::vector <node> tree (4 * n);\\n      \\n      auto build = [&] (auto self, int v, int tl, int tr) -> void {\\n        if (tl == tr)\\n          tree[v].value = nums1[tl] == 1;\\n        else {\\n          int tm = (tl + tr) / 2;\\n          self(self, 2 * v + 1, tl, tm);\\n          self(self, 2 * v + 2, tm + 1, tr);\\n          tree[v].value = tree[2 * v + 1].value + tree[2 * v + 2].value;\\n        }\\n      };\\n      \\n      auto push = [&] (int v, int tl, int tr) {\\n        if (not tree[v].lazy)\\n          return;\\n        int tm = (tl + tr) / 2;\\n        tree[2 * v + 1].value = tm - tl + 1 - tree[2 * v + 1].value;\\n        tree[2 * v + 2].value = tr - tm - tree[2 * v + 2].value;\\n        tree[2 * v + 1].lazy ^= true;\\n        tree[2 * v + 2].lazy ^= true;\\n        tree[v].lazy = false;\\n      };\\n      \\n      auto update = [&] (auto self, int v, int tl, int tr, int l, int r) -> void {\\n        if (l > r)\\n          return;\\n        if (tl == l and tr == r) {\\n          tree[v].value = tr - tl + 1 - tree[v].value;\\n          tree[v].lazy ^= true;\\n          return;\\n        }\\n        push(v, tl, tr);\\n        int tm = (tl + tr) / 2;\\n        self(self, 2 * v + 1, tl, tm, l, std::min(r, tm));\\n        self(self, 2 * v + 2, tm + 1, tr, std::max(l, tm + 1), r);\\n        tree[v].value = tree[2 * v + 1].value + tree[2 * v + 2].value;\\n      };\\n      \\n      build(build, 0, 0, n - 1);\\n      \\n      for (auto &v: queries) {\\n        if (v[0] == 1)\\n          update(update, 0, 0, n - 1, v[1], v[2]);\\n        else if (v[0] == 2)\\n          answer += (int64_t)tree[0].value * v[1];\\n        else\\n          results.push_back(answer);\\n      }\\n      \\n      return results;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```cpp\\nclass Solution {\\n  public:\\n    vector <long long> handleQuery (vector <int>& nums1, vector <int>& nums2, vector <vector <int>>& queries) {\\n      int n = nums1.size();\\n      int64_t answer = std::accumulate(nums2.begin(), nums2.end(), int64_t(0));\\n      std::vector <long long> results;\\n      \\n      struct node {\\n        int value = 0;\\n        bool lazy = false;\\n      };\\n      \\n      std::vector <node> tree (4 * n);\\n      \\n      auto build = [&] (auto self, int v, int tl, int tr) -> void {\\n        if (tl == tr)\\n          tree[v].value = nums1[tl] == 1;\\n        else {\\n          int tm = (tl + tr) / 2;\\n          self(self, 2 * v + 1, tl, tm);\\n          self(self, 2 * v + 2, tm + 1, tr);\\n          tree[v].value = tree[2 * v + 1].value + tree[2 * v + 2].value;\\n        }\\n      };\\n      \\n      auto push = [&] (int v, int tl, int tr) {\\n        if (not tree[v].lazy)\\n          return;\\n        int tm = (tl + tr) / 2;\\n        tree[2 * v + 1].value = tm - tl + 1 - tree[2 * v + 1].value;\\n        tree[2 * v + 2].value = tr - tm - tree[2 * v + 2].value;\\n        tree[2 * v + 1].lazy ^= true;\\n        tree[2 * v + 2].lazy ^= true;\\n        tree[v].lazy = false;\\n      };\\n      \\n      auto update = [&] (auto self, int v, int tl, int tr, int l, int r) -> void {\\n        if (l > r)\\n          return;\\n        if (tl == l and tr == r) {\\n          tree[v].value = tr - tl + 1 - tree[v].value;\\n          tree[v].lazy ^= true;\\n          return;\\n        }\\n        push(v, tl, tr);\\n        int tm = (tl + tr) / 2;\\n        self(self, 2 * v + 1, tl, tm, l, std::min(r, tm));\\n        self(self, 2 * v + 2, tm + 1, tr, std::max(l, tm + 1), r);\\n        tree[v].value = tree[2 * v + 1].value + tree[2 * v + 2].value;\\n      };\\n      \\n      build(build, 0, 0, n - 1);\\n      \\n      for (auto &v: queries) {\\n        if (v[0] == 1)\\n          update(update, 0, 0, n - 1, v[1], v[2]);\\n        else if (v[0] == 2)\\n          answer += (int64_t)tree[0].value * v[1];\\n        else\\n          results.push_back(answer);\\n      }\\n      \\n      return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247547,
                "title": "lazy-segement-tree-tle-solved",
                "content": "\\nSOLVED: I was getting TLE in my code [Link to Submission](https://leetcode.com/submissions/detail/907710752/)\\n[Solution for tle](https://leetcode.com/problems/handling-sum-queries-after-update/discuss/3247547/Lazy-Segement-Tree-or-TLE-(SOLVED)/1819793)\\n\\nThanks to [PROFILE](https://leetcode.com/n124345679976/)\\n\\n**CODE:**\\n\\nSegement tree class:\\n```\\nclass ST {\\npublic: \\n\\tvector<long long> seg, lazy; \\n\\tST(long long n) {\\n\\t\\tseg.resize(4 * n); \\n\\t\\tlazy.resize(4 * n); \\n\\t}\\n\\tvoid build(int ind, int low, int high, vector<int> arr) {\\n\\t\\tif(low == high) {\\n\\t\\t\\tseg[ind] = arr[low];\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tlong long mid = (low + high) >> 1; \\n\\t\\tbuild(2*ind+1, low, mid, arr); \\n\\t\\tbuild(2*ind+2, mid+1, high, arr); \\n\\t\\tseg[ind] = seg[2*ind+1] + seg[2*ind+2];\\n\\t}\\n\\tvoid update(int ind, int low, int high, int l, int r, \\n\\t\\tint val) {\\n\\t\\t// update the previous remaining updates \\n\\t\\t// and propogate downwards \\n\\t\\tif(lazy[ind] != 0) {\\n\\t\\t\\tseg[ind] = (high - low + 1) - seg[ind]; \\n\\t\\t\\t// propogate the lazy update downwards\\n\\t\\t\\t// for the remaining nodes to get updated \\n\\t\\t\\tif(low != high) {\\n\\t\\t\\t\\tlazy[2*ind+1] = !lazy[2*ind + 1]; \\n\\t\\t\\t\\tlazy[2*ind+2] = !lazy[2*ind + 2]; \\n\\t\\t\\t}\\n \\n\\t\\t\\tlazy[ind] = 0; \\n\\t\\t}\\n \\n\\t\\t// no overlap \\n\\t\\t// we don\\'t do anything and return \\n\\t\\t// low high l r or l r low high \\n\\t\\tif(high < l or r < low) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n \\n\\t\\t// complete overlap \\n\\t\\t// l low high r \\n\\t\\tif(low>=l && high <= r) {\\n\\t\\t\\tseg[ind] = (high - low + 1) - seg[ind]; \\n\\t\\t\\t// if a leaf node, it will have childrens\\n\\t\\t\\tif(low != high) {\\n\\t\\t\\t\\tlazy[2*ind+1] = !lazy[2*ind + 1]; \\n\\t\\t\\t\\tlazy[2*ind+2] = !lazy[2*ind + 2]; \\n\\t\\t\\t}\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\t// last case has to be no overlap case\\n\\t\\tlong long mid = (low + high) >> 1; \\n\\t\\tupdate(2*ind+1, low, mid, l, r, val);\\n\\t\\tupdate(2*ind+2, mid+1, high, l, r, val); \\n\\t\\tseg[ind] = seg[2*ind+1] + seg[2*ind+2]; \\n\\t}\\n};\\n\\n```\\n\\n\\nHandling Sum Queries function:\\n```\\nvector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        long long n=nums1.size();\\n        ST st(n+1);\\n        st.build(0,0,n-1,nums1);\\n        vector<long long> ans;\\n        long long sm=0;\\n        for(auto i: nums2)sm+=i;\\n        for(auto q: queries){\\n            // cout<<sm<<\" \";\\n            if(q[0]==1){\\n                st.update(0,0,n-1,q[1],q[2],0);\\n            }\\n            else if(q[0]==2){\\n                sm+=st.seg[0]*q[1];\\n            }\\n            else {\\n                ans.push_back(sm);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass ST {\\npublic: \\n\\tvector<long long> seg, lazy; \\n\\tST(long long n) {\\n\\t\\tseg.resize(4 * n); \\n\\t\\tlazy.resize(4 * n); \\n\\t}\\n\\tvoid build(int ind, int low, int high, vector<int> arr) {\\n\\t\\tif(low == high) {\\n\\t\\t\\tseg[ind] = arr[low];\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tlong long mid = (low + high) >> 1; \\n\\t\\tbuild(2*ind+1, low, mid, arr); \\n\\t\\tbuild(2*ind+2, mid+1, high, arr); \\n\\t\\tseg[ind] = seg[2*ind+1] + seg[2*ind+2];\\n\\t}\\n\\tvoid update(int ind, int low, int high, int l, int r, \\n\\t\\tint val) {\\n\\t\\t// update the previous remaining updates \\n\\t\\t// and propogate downwards \\n\\t\\tif(lazy[ind] != 0) {\\n\\t\\t\\tseg[ind] = (high - low + 1) - seg[ind]; \\n\\t\\t\\t// propogate the lazy update downwards\\n\\t\\t\\t// for the remaining nodes to get updated \\n\\t\\t\\tif(low != high) {\\n\\t\\t\\t\\tlazy[2*ind+1] = !lazy[2*ind + 1]; \\n\\t\\t\\t\\tlazy[2*ind+2] = !lazy[2*ind + 2]; \\n\\t\\t\\t}\\n \\n\\t\\t\\tlazy[ind] = 0; \\n\\t\\t}\\n \\n\\t\\t// no overlap \\n\\t\\t// we don\\'t do anything and return \\n\\t\\t// low high l r or l r low high \\n\\t\\tif(high < l or r < low) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n \\n\\t\\t// complete overlap \\n\\t\\t// l low high r \\n\\t\\tif(low>=l && high <= r) {\\n\\t\\t\\tseg[ind] = (high - low + 1) - seg[ind]; \\n\\t\\t\\t// if a leaf node, it will have childrens\\n\\t\\t\\tif(low != high) {\\n\\t\\t\\t\\tlazy[2*ind+1] = !lazy[2*ind + 1]; \\n\\t\\t\\t\\tlazy[2*ind+2] = !lazy[2*ind + 2]; \\n\\t\\t\\t}\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\t// last case has to be no overlap case\\n\\t\\tlong long mid = (low + high) >> 1; \\n\\t\\tupdate(2*ind+1, low, mid, l, r, val);\\n\\t\\tupdate(2*ind+2, mid+1, high, l, r, val); \\n\\t\\tseg[ind] = seg[2*ind+1] + seg[2*ind+2]; \\n\\t}\\n};\\n\\n```\n```\\nvector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        long long n=nums1.size();\\n        ST st(n+1);\\n        st.build(0,0,n-1,nums1);\\n        vector<long long> ans;\\n        long long sm=0;\\n        for(auto i: nums2)sm+=i;\\n        for(auto q: queries){\\n            // cout<<sm<<\" \";\\n            if(q[0]==1){\\n                st.update(0,0,n-1,q[1],q[2],0);\\n            }\\n            else if(q[0]==2){\\n                sm+=st.seg[0]*q[1];\\n            }\\n            else {\\n                ans.push_back(sm);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3208032,
                "title": "c-non-recursive-segment-tree-solution",
                "content": "You can read this article to know more about non-recursive segment tree.\\n [Efficient and easy segment trees - Codeforces](https://codeforces.com/blog/entry/18051)\\n```cpp\\nconst int N = 1e5 + 10;\\nint n, h, d[N], cnt[N << 1];\\n\\nvoid init(const vector<int> &nums) {\\n    n = int(nums.size());\\n    h = int(sizeof(n)) * 8 - __builtin_clz(n);\\n\\n    memset(d, 0, n * sizeof(d[0]));\\n\\n    copy(nums.begin(), nums.end(), cnt + n);\\n    for (int i = n - 1; i > 0; --i) cnt[i] = cnt[i << 1] + cnt[i << 1 | 1];\\n}\\n\\nvoid calc(int p, int k) {\\n    int t = cnt[p << 1] + cnt[p << 1 | 1];\\n    cnt[p] = d[p] ? k - t : t;\\n}\\n\\nvoid apply(int id, int k) {\\n    cnt[id] = k - cnt[id];\\n    if (id < n) d[id] ^= 1;\\n}\\n\\nvoid push(int p) {\\n    int s = h, k = 1 << (h - 1);\\n    for (p += n; s > 0; --s, k >>= 1) {\\n        int i = p >> s;\\n        if (d[i]) apply(i << 1, k), apply(i << 1 | 1, k), d[i] = 0;\\n    }\\n}\\n\\nint count_flip(int id, int k) {\\n    int old = cnt[id];\\n    int new_val = k - old;\\n    cnt[id] = new_val;\\n    if (id < n) d[id] ^= 1;\\n    return new_val - old;\\n}\\n\\nint flip(int l, int r) {\\n    push(l);\\n    push(r - 1);\\n    int ans = 0, k = 1;\\n    bool cl = false, cr = false;\\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1, k <<= 1) {\\n        if (cl) calc(l - 1, k);\\n        if (cr) calc(r, k);\\n        if (l & 1) ans += count_flip(l++, k), cl = true;\\n        if (r & 1) ans += count_flip(--r, k), cr = true;\\n    }\\n    for (--l; r > 0; l >>= 1, r >>= 1, k <<= 1) {\\n        if (cl) calc(l, k);\\n        if (cr && !(cl && l == r)) calc(r, k);\\n    }\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    static vector<long long> handleQuery(\\n            const vector<int> &nums1, const vector<int> &nums2,\\n            const vector<vector<int> > &queries) {\\n        init(nums1);\\n\\n        int64_t sum = reduce(nums2.begin(), nums2.end(), INT64_C(0));\\n        int ones = reduce(nums1.begin(), nums1.end());\\n\\n        vector<long long> ans;\\n\\n        for (auto &&query: queries) {\\n            int type = query[0], l = query[1], r = query[2] + 1;\\n            switch (type) {\\n                case 1:\\n                    ones += flip(l, r);\\n                    break;\\n                case 2:\\n                    sum += ones * int64_t(l);\\n                    break;\\n                case 3:\\n                    ans.push_back(sum);\\n                    break;\\n                default:\\n                    abort();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```cpp\\nconst int N = 1e5 + 10;\\nint n, h, d[N], cnt[N << 1];\\n\\nvoid init(const vector<int> &nums) {\\n    n = int(nums.size());\\n    h = int(sizeof(n)) * 8 - __builtin_clz(n);\\n\\n    memset(d, 0, n * sizeof(d[0]));\\n\\n    copy(nums.begin(), nums.end(), cnt + n);\\n    for (int i = n - 1; i > 0; --i) cnt[i] = cnt[i << 1] + cnt[i << 1 | 1];\\n}\\n\\nvoid calc(int p, int k) {\\n    int t = cnt[p << 1] + cnt[p << 1 | 1];\\n    cnt[p] = d[p] ? k - t : t;\\n}\\n\\nvoid apply(int id, int k) {\\n    cnt[id] = k - cnt[id];\\n    if (id < n) d[id] ^= 1;\\n}\\n\\nvoid push(int p) {\\n    int s = h, k = 1 << (h - 1);\\n    for (p += n; s > 0; --s, k >>= 1) {\\n        int i = p >> s;\\n        if (d[i]) apply(i << 1, k), apply(i << 1 | 1, k), d[i] = 0;\\n    }\\n}\\n\\nint count_flip(int id, int k) {\\n    int old = cnt[id];\\n    int new_val = k - old;\\n    cnt[id] = new_val;\\n    if (id < n) d[id] ^= 1;\\n    return new_val - old;\\n}\\n\\nint flip(int l, int r) {\\n    push(l);\\n    push(r - 1);\\n    int ans = 0, k = 1;\\n    bool cl = false, cr = false;\\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1, k <<= 1) {\\n        if (cl) calc(l - 1, k);\\n        if (cr) calc(r, k);\\n        if (l & 1) ans += count_flip(l++, k), cl = true;\\n        if (r & 1) ans += count_flip(--r, k), cr = true;\\n    }\\n    for (--l; r > 0; l >>= 1, r >>= 1, k <<= 1) {\\n        if (cl) calc(l, k);\\n        if (cr && !(cl && l == r)) calc(r, k);\\n    }\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    static vector<long long> handleQuery(\\n            const vector<int> &nums1, const vector<int> &nums2,\\n            const vector<vector<int> > &queries) {\\n        init(nums1);\\n\\n        int64_t sum = reduce(nums2.begin(), nums2.end(), INT64_C(0));\\n        int ones = reduce(nums1.begin(), nums1.end());\\n\\n        vector<long long> ans;\\n\\n        for (auto &&query: queries) {\\n            int type = query[0], l = query[1], r = query[2] + 1;\\n            switch (type) {\\n                case 1:\\n                    ones += flip(l, r);\\n                    break;\\n                case 2:\\n                    sum += ones * int64_t(l);\\n                    break;\\n                case 3:\\n                    ans.push_back(sum);\\n                    break;\\n                default:\\n                    abort();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206323,
                "title": "python-segment-tree-with-lazy-propagation-o-nlogn-qlogn-simple-code",
                "content": "# Code\\n```\\n\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        n = len(nums1)\\n        #root of the tree is at the index 0\\n        tree = [0]*(4*n)\\n        lazy = [0]*(4*n)\\n\\n        def update(v, lo, hi, i, j):\\n            if lazy[v]:\\n                tree[v] = (hi - lo + 1) - tree[v]\\n                if lo < hi:\\n                    lazy[2*v + 1] ^= lazy[v]\\n                    lazy[2*v + 2] ^= lazy[v]\\n                lazy[v] = 0\\n            if lo > j or hi < i: \\n                return \\n            if i <= lo and hi <= j:\\n                tree[v] = (hi - lo + 1) - tree[v]\\n                if lo < hi:\\n                    lazy[2*v + 1] ^= 1 \\n                    lazy[2*v + 2] ^= 1\\n                return\\n            m = (lo + hi)//2\\n            update(2*v + 1, lo, m, i, j) \\n            update(2*v + 2, m+1, hi, i, j)\\n            tree[v] = tree[2*v + 1] + tree[2*v + 2]\\n\\n        for i, b in enumerate(nums1):\\n            if b: update(0,0,n-1,i,i)\\n        sum2 = sum(nums2)\\n        res = []\\n        for t, l, r in queries:\\n            if t == 1:\\n                update(0, 0, n-1, l, r)\\n            elif t == 2:\\n                sum2 += l*tree[0]\\n            else:\\n                res.append(sum2)\\n        return res\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Code\\n```\\n\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        n = len(nums1)\\n        #root of the tree is at the index 0\\n        tree = [0]*(4*n)\\n        lazy = [0]*(4*n)\\n\\n        def update(v, lo, hi, i, j):\\n            if lazy[v]:\\n                tree[v] = (hi - lo + 1) - tree[v]\\n                if lo < hi:\\n                    lazy[2*v + 1] ^= lazy[v]\\n                    lazy[2*v + 2] ^= lazy[v]\\n                lazy[v] = 0\\n            if lo > j or hi < i: \\n                return \\n            if i <= lo and hi <= j:\\n                tree[v] = (hi - lo + 1) - tree[v]\\n                if lo < hi:\\n                    lazy[2*v + 1] ^= 1 \\n                    lazy[2*v + 2] ^= 1\\n                return\\n            m = (lo + hi)//2\\n            update(2*v + 1, lo, m, i, j) \\n            update(2*v + 2, m+1, hi, i, j)\\n            tree[v] = tree[2*v + 1] + tree[2*v + 2]\\n\\n        for i, b in enumerate(nums1):\\n            if b: update(0,0,n-1,i,i)\\n        sum2 = sum(nums2)\\n        res = []\\n        for t, l, r in queries:\\n            if t == 1:\\n                update(0, 0, n-1, l, r)\\n            elif t == 2:\\n                sum2 += l*tree[0]\\n            else:\\n                res.append(sum2)\\n        return res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3203378,
                "title": "no-segment-trees-win-in-batches-o-n-n-w-batch-processing",
                "content": "This problem illustrates that we can sometimes combine two inefficient strategies into one efficient one. Let\\'s see how!\\n\\nThere are two approaches that are slow on their own but rather easy to come up with:\\n\\n#### Strategy #1\\n* Maintain a total number of 1s in `nums1`.\\n* When we see a type 1 query, go through `nums1` and update every element within the request range and renew the 1-count. This is O(N).\\n* When we see a type 2 query, just take the 1-count * P and add it to the sum. This is O(1).\\n\\n#### Strategy #2\\n* Maintain a sorted list of \"change points.\"\\n* When we see a type 1 query, add a pair of change points, one +1 and one -1, at the start and end of the requested range. This can be done in O(log N) with a binary search tree.\\n* When we see a type 2 query, go through the change points with a running total of changes, and if the sum is currently odd then add the number of zeros to the sum in the previous interval instead. This is O(change list size) = O(number of type 1 queries seen so far), which can be up to O(N).\\n\\nAs we can see, if there are lots of type 1 queries a only a few type 2s, strategy 2 is better. And conversely if there are many type 2 queries and few type 1s, strategy 1 is better.\\n\\nSo why don\\'t we combine the two? Turns out we can!\\n\\nLet\\'s say we use strategy #2. Keep using it until the list of change points reaches some threshold `T`. Then we go through `nums1` and \"push the changes in,\" which would allow us to clear our change list!\\n\\nSo what\\'s the best choice for `T`?\\n\\nWell, every time we push the changes in and update `nums1`, that takes O(N) time. Also in the worst case, there are O(N) type 1 queries. This means we\\'ll need to run the update roughly O(N / T) times, resulting in O(N * N/T) running time overall. On the other hand, every type 2 query now takes O(T) because that\\'s the maximum size of our change list, and there are O(N) type 2 queries in the worst case.\\n\\nThis means we want to balance O(N * T) with O(N * N/T), so boom, set T=sqrt(N).\\n\\n## Code\\n(Sorry, not the most readable ever)\\n```\\nusing ll = long long;\\n#define len(a) int(size(a))\\n\\nmap<int, int> b;\\nint pre[100009];\\n\\nclass Solution {\\n  public:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2,\\n                                  vector<vector<int>>& queries) {\\n        vector<ll> ans;\\n        ll s = reduce(all(nums2), 0LL);\\n        int n = len(nums1), t = (int)sqrt(n);\\n        b.clear();\\n        auto calc = [&]() {\\n            for (int i = 0; i < n; i++) pre[i + 1] = pre[i] + nums1[i];\\n        };\\n        calc();\\n        for (auto& q : queries) {\\n            if (q[0] == 1) {\\n                b[q[1]]++, b[q[2] + 1]--;\\n                if (!b[q[1]]) b.erase(q[1]);\\n                if (!b[q[2] + 1]) b.erase(q[2] + 1);\\n                if (len(b) > t) {\\n                    int a = 0, p = 0;\\n                    b.insert({n, 0});\\n                    for (auto [i, d] : b) {\\n                        for (int k = p; k < i; k++) {\\n                            nums1[k] ^= a & 1;\\n                        }\\n                        a += d;\\n                        p = i;\\n                    }\\n                    b.clear();\\n                    calc();\\n                }\\n            } else if (q[0] == 2) {\\n                ll c = 0;\\n                int a = 0, p = 0;\\n                b.insert({n, 0});\\n                for (auto [i, d] : b) {\\n                    if (a & 1)\\n                        c += (i - p) - (pre[i] - pre[p]);\\n                    else\\n                        c += pre[i] - pre[p];\\n                    p = i;\\n                    a += d;\\n                }\\n                s += q[1] * c;\\n            } else {\\n                ans.push_back(s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ll = long long;\\n#define len(a) int(size(a))\\n\\nmap<int, int> b;\\nint pre[100009];\\n\\nclass Solution {\\n  public:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2,\\n                                  vector<vector<int>>& queries) {\\n        vector<ll> ans;\\n        ll s = reduce(all(nums2), 0LL);\\n        int n = len(nums1), t = (int)sqrt(n);\\n        b.clear();\\n        auto calc = [&]() {\\n            for (int i = 0; i < n; i++) pre[i + 1] = pre[i] + nums1[i];\\n        };\\n        calc();\\n        for (auto& q : queries) {\\n            if (q[0] == 1) {\\n                b[q[1]]++, b[q[2] + 1]--;\\n                if (!b[q[1]]) b.erase(q[1]);\\n                if (!b[q[2] + 1]) b.erase(q[2] + 1);\\n                if (len(b) > t) {\\n                    int a = 0, p = 0;\\n                    b.insert({n, 0});\\n                    for (auto [i, d] : b) {\\n                        for (int k = p; k < i; k++) {\\n                            nums1[k] ^= a & 1;\\n                        }\\n                        a += d;\\n                        p = i;\\n                    }\\n                    b.clear();\\n                    calc();\\n                }\\n            } else if (q[0] == 2) {\\n                ll c = 0;\\n                int a = 0, p = 0;\\n                b.insert({n, 0});\\n                for (auto [i, d] : b) {\\n                    if (a & 1)\\n                        c += (i - p) - (pre[i] - pre[p]);\\n                    else\\n                        c += pre[i] - pre[p];\\n                    p = i;\\n                    a += d;\\n                }\\n                s += q[1] * c;\\n            } else {\\n                ans.push_back(s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203199,
                "title": "java-lazy-propagation-easy-solution-with-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReference - \\nWatch striver Lazy Propagation - https://www.youtube.com/watch?v=rwXVCELcrqU\\n# Approach\\nLazy Propagation Segment tree technique\\nseg[ind] = no. of 1\\'s between low - high\\n\\ntherefore no. of zeros = (high - low + 1) - seg[ind]\\ni.e: zero = range - (no. of 1\\'s)\\nso, in lazy, we are are just storing the parity \\nif lazy[ind] = 1, reverse the no. of 1\\'s to no. of zero\\nswap(no. of ones, no. of zeros)\\n\\nquery 2:\\nnums2[i] += nums1[i]*p\\nlet sum = sum of all elements in nums2\\nthis basically means:\\nnewSum = sum + (no. of 1\\'s)*p[ let say it \" s \"]\\nevery time query 2 is called\\ns += (no of 1\\'s)*p\\nquery 3:\\nsum of num2 element + (sum of no. of time query 2 is done, that is store it in some variable \" s \")\\n# Complexity\\n- For every rangeUpadate and rangeQuery -> O(logN)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        SegmentTreeLazy st = new SegmentTreeLazy(nums1);\\n        int n = nums1.length;\\n        \\n        long sum = 0;\\n        for(int i: nums2) sum += i;\\n        \\n        int ones = st.query(0, n - 1);\\n        // System.out.println(\" ones \" + ones);\\n        long s = 0;\\n        int q = queries.length;\\n        List<Long> ll = new ArrayList<>();\\n        for(int i = 0; i < q; i++){\\n            int[] v = queries[i];\\n            if(v[0] == 1){\\n                int l = v[1], r = v[2];\\n                st.rangeUpdate(l, r);\\n            }else if(v[0] == 2){\\n                s += (long)v[1]*st.query(0, n - 1);\\n            }else{\\n                ll.add((sum + s));\\n            }\\n        }\\n        \\n        long[] arr = new long[ll.size()];\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i] = ll.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n\\n        class SegmentTreeLazy{\\n        int[] seg, lazy;\\n        int n;\\n        int[] givenArr;\\n        int MAXN = 400000;\\n        SegmentTreeLazy(int[] nums){\\n            this.seg = new int[MAXN];\\n            this.lazy = new int[MAXN];\\n            this.givenArr = nums;\\n            this.n = givenArr.length;\\n            build(0, 0, n - 1);\\n        }\\n        \\n        void build(int index, int l, int r) {\\n            if (l == r) {\\n                seg[index] = givenArr[l];\\n                return;\\n            }\\n            int mid = (l + r) / 2;\\n            build(2*index + 1, l, mid);\\n            build(2*index + 2, mid + 1, r);\\n            seg[index] = seg[2*index + 1] + seg[2*index + 2];\\n        }\\n        \\n        // HINT: here we are adding.., can be changed acc. to question\\n        void rangeUpdate(int ind, int low, int high, int l, int r){\\n            if(lazy[ind] != 0){\\n                seg[ind] = (high - low + 1 - seg[ind]);\\n                if(low != high){\\n                    lazy[2*ind + 1] = 1 - lazy[2*ind + 1];\\n                    lazy[2*ind + 2] = 1 - lazy[2*ind + 2];\\n                }\\n                \\n                lazy[ind] = 0;\\n            }\\n            \\n            if(r < low || l > high) return ;\\n            if(low >= l && high <= r){\\n                seg[ind] = (high - low + 1 - seg[ind]);\\n                // if this is not leaf node\\n                if(low != high){\\n                    lazy[2*ind + 1] = 1 - lazy[2*ind + 1];\\n                    lazy[2*ind + 2] = 1 - lazy[2*ind + 2];\\n                }\\n                return;\\n            }\\n            \\n            \\n            int mid = (low + high)/2;\\n            rangeUpdate(2*ind + 1, low, mid, l, r);\\n            rangeUpdate(2*ind + 2, mid + 1, high, l, r);\\n            seg[ind] = seg[2*ind + 1] + seg[2*ind + 2];\\n            return;\\n        }\\n        // range update\\n        void rangeUpdate(int l, int r){\\n            // NOTE: this \" val \" can be added, subtracted, xor etc.\\n            // val = adding val to range [l, r]\\n            rangeUpdate(0, 0, n - 1, l, r);\\n        }\\n        \\n        int query(int ind, int low, int high, int l, int r){\\n            if(lazy[ind] != 0){\\n                seg[ind] = (high - low + 1 - seg[ind]);\\n                if(low != high){\\n                    lazy[2*ind + 1] = 1 - lazy[2*ind + 1];\\n                    lazy[2*ind + 2] = 1 - lazy[2*ind + 2];\\n                }\\n                lazy[ind] = 0;\\n            }\\n            \\n            if(r < low || high < l) return 0;\\n            \\n            // total - overlapping\\n            if(low >= l && high <= r){\\n                return seg[ind];\\n            }\\n            \\n            int mid = (low + high)/2;\\n            int le = query(2*ind + 1, low, mid, l, r);\\n            int re = query(2*ind + 2, mid + 1, high, l, r);\\n            return le + re;\\n        }\\n        int query(int l, int r){\\n            return query(0, 0, n - 1, l, r);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        SegmentTreeLazy st = new SegmentTreeLazy(nums1);\\n        int n = nums1.length;\\n        \\n        long sum = 0;\\n        for(int i: nums2) sum += i;\\n        \\n        int ones = st.query(0, n - 1);\\n        // System.out.println(\" ones \" + ones);\\n        long s = 0;\\n        int q = queries.length;\\n        List<Long> ll = new ArrayList<>();\\n        for(int i = 0; i < q; i++){\\n            int[] v = queries[i];\\n            if(v[0] == 1){\\n                int l = v[1], r = v[2];\\n                st.rangeUpdate(l, r);\\n            }else if(v[0] == 2){\\n                s += (long)v[1]*st.query(0, n - 1);\\n            }else{\\n                ll.add((sum + s));\\n            }\\n        }\\n        \\n        long[] arr = new long[ll.size()];\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i] = ll.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n\\n        class SegmentTreeLazy{\\n        int[] seg, lazy;\\n        int n;\\n        int[] givenArr;\\n        int MAXN = 400000;\\n        SegmentTreeLazy(int[] nums){\\n            this.seg = new int[MAXN];\\n            this.lazy = new int[MAXN];\\n            this.givenArr = nums;\\n            this.n = givenArr.length;\\n            build(0, 0, n - 1);\\n        }\\n        \\n        void build(int index, int l, int r) {\\n            if (l == r) {\\n                seg[index] = givenArr[l];\\n                return;\\n            }\\n            int mid = (l + r) / 2;\\n            build(2*index + 1, l, mid);\\n            build(2*index + 2, mid + 1, r);\\n            seg[index] = seg[2*index + 1] + seg[2*index + 2];\\n        }\\n        \\n        // HINT: here we are adding.., can be changed acc. to question\\n        void rangeUpdate(int ind, int low, int high, int l, int r){\\n            if(lazy[ind] != 0){\\n                seg[ind] = (high - low + 1 - seg[ind]);\\n                if(low != high){\\n                    lazy[2*ind + 1] = 1 - lazy[2*ind + 1];\\n                    lazy[2*ind + 2] = 1 - lazy[2*ind + 2];\\n                }\\n                \\n                lazy[ind] = 0;\\n            }\\n            \\n            if(r < low || l > high) return ;\\n            if(low >= l && high <= r){\\n                seg[ind] = (high - low + 1 - seg[ind]);\\n                // if this is not leaf node\\n                if(low != high){\\n                    lazy[2*ind + 1] = 1 - lazy[2*ind + 1];\\n                    lazy[2*ind + 2] = 1 - lazy[2*ind + 2];\\n                }\\n                return;\\n            }\\n            \\n            \\n            int mid = (low + high)/2;\\n            rangeUpdate(2*ind + 1, low, mid, l, r);\\n            rangeUpdate(2*ind + 2, mid + 1, high, l, r);\\n            seg[ind] = seg[2*ind + 1] + seg[2*ind + 2];\\n            return;\\n        }\\n        // range update\\n        void rangeUpdate(int l, int r){\\n            // NOTE: this \" val \" can be added, subtracted, xor etc.\\n            // val = adding val to range [l, r]\\n            rangeUpdate(0, 0, n - 1, l, r);\\n        }\\n        \\n        int query(int ind, int low, int high, int l, int r){\\n            if(lazy[ind] != 0){\\n                seg[ind] = (high - low + 1 - seg[ind]);\\n                if(low != high){\\n                    lazy[2*ind + 1] = 1 - lazy[2*ind + 1];\\n                    lazy[2*ind + 2] = 1 - lazy[2*ind + 2];\\n                }\\n                lazy[ind] = 0;\\n            }\\n            \\n            if(r < low || high < l) return 0;\\n            \\n            // total - overlapping\\n            if(low >= l && high <= r){\\n                return seg[ind];\\n            }\\n            \\n            int mid = (low + high)/2;\\n            int le = query(2*ind + 1, low, mid, l, r);\\n            int re = query(2*ind + 2, mid + 1, high, l, r);\\n            return le + re;\\n        }\\n        int query(int l, int r){\\n            return query(0, 0, n - 1, l, r);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202684,
                "title": "o-n-sqrt-n-solution-by-buffering-type-1-queries",
                "content": "# Intuition\\nSince I can\\'t quickly find a clever O(n * Log(n)) solution, I will settle for an O(n * sqrt(n)) solution.\\n\\n# Approach\\nCollect a buffer of type-1 queries. Every time a type-2 query is requested, determine the sum of nums1 using the type-1 queries. When\\nthe number of type-1 queries exceeds the square root of the length\\nof num1, apply the type-1 queries to nums1.\\n* Each type-1 query adds two `flipIdxs` representing the indices of the subarray for which the bits are flipped on and off.\\n\\n# Complexity\\n- Time complexity: $$O(n * sqrt(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n \\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:    \\n        sum3 = []\\n        sum2 = sum(nums2)\\n        n = len(nums1)\\n        psums1 = self.getPsums(nums1)\\n        flipIdxs = []\\n        for i1, i2, i3 in queries:\\n            if i1 == 1:\\n                for flipIdx in i2, i3 + 1:\\n                    flipIdxs.insert(\\n                        bisect.bisect_left(flipIdxs, flipIdx),\\n                        flipIdx)\\n                if len(flipIdxs) * len(flipIdxs) > n * 4:\\n                    self.flushFlipIdxs(nums1, flipIdxs)\\n                    psums1 = self.getPsums(nums1)\\n                    flipIdxs = []\\n            elif i1 == 2:\\n                sum2 += self.getSum(psums1, flipIdxs) * i2\\n            else:\\n                sum3.append(sum2)\\n        return sum3\\n    \\n    @classmethod    \\n    def getPsums(cls, nums):\\n        psums = [0] + nums\\n        for i in range(len(nums)):\\n            psums[i + 1] += psums[i]\\n        return psums\\n    \\n    @classmethod\\n    def getSum(cls, psums, flipIdxs):\\n        sum1 = psums[-1]\\n        for i, flipIdx in enumerate(flipIdxs):\\n            isLo = i % 2 == 0\\n            if isLo:\\n                sum1 += psums[flipIdx] * 2 - flipIdx\\n            else:\\n                sum1 -= psums[flipIdx] * 2 - flipIdx\\n        return sum1    \\n    \\n    @classmethod\\n    def flushFlipIdxs(cls, nums, flipIdxs):\\n        for i in range(0, len(flipIdxs), 2):\\n            flipOnIdx = flipIdxs[i]\\n            flipOffIdx = flipIdxs[i + 1]\\n            for j in range(flipOnIdx, flipOffIdx):\\n                nums[j] = 1 - nums[j]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n \\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:    \\n        sum3 = []\\n        sum2 = sum(nums2)\\n        n = len(nums1)\\n        psums1 = self.getPsums(nums1)\\n        flipIdxs = []\\n        for i1, i2, i3 in queries:\\n            if i1 == 1:\\n                for flipIdx in i2, i3 + 1:\\n                    flipIdxs.insert(\\n                        bisect.bisect_left(flipIdxs, flipIdx),\\n                        flipIdx)\\n                if len(flipIdxs) * len(flipIdxs) > n * 4:\\n                    self.flushFlipIdxs(nums1, flipIdxs)\\n                    psums1 = self.getPsums(nums1)\\n                    flipIdxs = []\\n            elif i1 == 2:\\n                sum2 += self.getSum(psums1, flipIdxs) * i2\\n            else:\\n                sum3.append(sum2)\\n        return sum3\\n    \\n    @classmethod    \\n    def getPsums(cls, nums):\\n        psums = [0] + nums\\n        for i in range(len(nums)):\\n            psums[i + 1] += psums[i]\\n        return psums\\n    \\n    @classmethod\\n    def getSum(cls, psums, flipIdxs):\\n        sum1 = psums[-1]\\n        for i, flipIdx in enumerate(flipIdxs):\\n            isLo = i % 2 == 0\\n            if isLo:\\n                sum1 += psums[flipIdx] * 2 - flipIdx\\n            else:\\n                sum1 -= psums[flipIdx] * 2 - flipIdx\\n        return sum1    \\n    \\n    @classmethod\\n    def flushFlipIdxs(cls, nums, flipIdxs):\\n        for i in range(0, len(flipIdxs), 2):\\n            flipOnIdx = flipIdxs[i]\\n            flipOffIdx = flipIdxs[i + 1]\\n            for j in range(flipOnIdx, flipOffIdx):\\n                nums[j] = 1 - nums[j]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202165,
                "title": "easy-segment-tree-solution-with-lazy-prop",
                "content": "# Intuition\\n Flipping bits in a range suggests segment tree?? Isn\\'t it? But, see we have to do range update. How do we do that?\\n\\n# Approach\\n  We use segment tree with lazy propagation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n    O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n# Code\\n```\\n#define ll long long \\nclass SegmentTree{\\n  ll *val, *lazy;\\n  ll n;\\npublic:\\n\\nSegmentTree(){\\n\\n}\\n  SegmentTree(ll size){\\n      n=size;\\n      val=new ll[4*size+1];\\n      lazy=new ll[4*size+1];\\n      for(ll i=0;i<4*size+1;i++)\\n      lazy[i]=val[i]=0;\\n  }\\n\\n  void build(vector<int>&a,ll si,ll l,ll r){\\n     if(l>r)\\n     return;\\n\\n     if(l==r){\\n         val[si]=a[l];\\n         return;\\n     }\\n\\n     ll mid=(l+r)/2;\\n     build(a,2*si+1,l,mid);\\n     build(a,2*si+2,mid+1,r);\\n     val[si]=val[2*si+1] + val[2*si+2];\\n  }\\n\\n  void apply(ll si,ll ss,ll se){\\n    //    update the value of si\\n      val[si]=se-ss+1-val[si];\\n      lazy[si]^=1;\\n  }\\n\\n  void push(ll si,ll ss,ll se){\\n      if(lazy[si]&&ss!=se){\\n          lazy[si]^=1;\\n          ll mid=(ss+se)/2;\\n          apply(2*si+1,ss,mid);\\n          apply(2*si+2,mid+1,se);\\n      }\\n  }\\n\\n  void update(ll si,ll ss,ll se,ll l,ll r){\\n     if(l>se||r<ss)\\n     return;\\n\\n     if(ss>=l&&se<=r){\\n         apply(si,ss,se);\\n         return;\\n     }\\n\\n     push(si,ss,se);\\n     ll mid=(ss+se)/2;\\n     update(2*si+1,ss,mid,l,r);\\n     update(2*si+2,mid+1,se,l,r);\\n     val[si]=val[2*si+1] + val[2*si+2];\\n  }\\n\\n  ll get(ll si,ll ss,ll se,ll l,ll r){\\n     if(l>se||r<ss)\\n     return 0;\\n\\n     if(ss>=l&&se<=r){\\n       return val[si];\\n     }\\n\\n     push(si,ss,se);\\n     ll mid=(ss+se)/2;\\n     return get(2*si+1,ss,mid,l,r) + get(2*si+2,mid+1,se,l,r); \\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long>ans;\\n        int n=nums1.size();\\n        \\n        SegmentTree sg(n+1);\\n        \\n        sg.build(nums1,0,0,n-1);\\n        ll sum=0;\\n        for(auto e:nums2){\\n            sum+=e;\\n        }\\n        \\n        for(auto e:queries){\\n            if(e[0]==1){\\n                sg.update(0,0,n-1,e[1],e[2]);\\n            }\\n            else if(e[0]==2){\\n                sum+=e[1]*1LL*sg.get(0,0,n-1,0,n-1);\\n            }\\n            else\\n            {\\n                ans.push_back(sum);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass SegmentTree{\\n  ll *val, *lazy;\\n  ll n;\\npublic:\\n\\nSegmentTree(){\\n\\n}\\n  SegmentTree(ll size){\\n      n=size;\\n      val=new ll[4*size+1];\\n      lazy=new ll[4*size+1];\\n      for(ll i=0;i<4*size+1;i++)\\n      lazy[i]=val[i]=0;\\n  }\\n\\n  void build(vector<int>&a,ll si,ll l,ll r){\\n     if(l>r)\\n     return;\\n\\n     if(l==r){\\n         val[si]=a[l];\\n         return;\\n     }\\n\\n     ll mid=(l+r)/2;\\n     build(a,2*si+1,l,mid);\\n     build(a,2*si+2,mid+1,r);\\n     val[si]=val[2*si+1] + val[2*si+2];\\n  }\\n\\n  void apply(ll si,ll ss,ll se){\\n    //    update the value of si\\n      val[si]=se-ss+1-val[si];\\n      lazy[si]^=1;\\n  }\\n\\n  void push(ll si,ll ss,ll se){\\n      if(lazy[si]&&ss!=se){\\n          lazy[si]^=1;\\n          ll mid=(ss+se)/2;\\n          apply(2*si+1,ss,mid);\\n          apply(2*si+2,mid+1,se);\\n      }\\n  }\\n\\n  void update(ll si,ll ss,ll se,ll l,ll r){\\n     if(l>se||r<ss)\\n     return;\\n\\n     if(ss>=l&&se<=r){\\n         apply(si,ss,se);\\n         return;\\n     }\\n\\n     push(si,ss,se);\\n     ll mid=(ss+se)/2;\\n     update(2*si+1,ss,mid,l,r);\\n     update(2*si+2,mid+1,se,l,r);\\n     val[si]=val[2*si+1] + val[2*si+2];\\n  }\\n\\n  ll get(ll si,ll ss,ll se,ll l,ll r){\\n     if(l>se||r<ss)\\n     return 0;\\n\\n     if(ss>=l&&se<=r){\\n       return val[si];\\n     }\\n\\n     push(si,ss,se);\\n     ll mid=(ss+se)/2;\\n     return get(2*si+1,ss,mid,l,r) + get(2*si+2,mid+1,se,l,r); \\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long>ans;\\n        int n=nums1.size();\\n        \\n        SegmentTree sg(n+1);\\n        \\n        sg.build(nums1,0,0,n-1);\\n        ll sum=0;\\n        for(auto e:nums2){\\n            sum+=e;\\n        }\\n        \\n        for(auto e:queries){\\n            if(e[0]==1){\\n                sg.update(0,0,n-1,e[1],e[2]);\\n            }\\n            else if(e[0]==2){\\n                sum+=e[1]*1LL*sg.get(0,0,n-1,0,n-1);\\n            }\\n            else\\n            {\\n                ans.push_back(sum);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202128,
                "title": "split-n-into-sqrt-n-blocks",
                "content": "# Intuition\\nSplit nums1 into sqrt(n) blocks. For each block, count the number of 1s in it. And also whether the whole block is reversed or not.\\n\\n\\n\\n# Approach\\nFor each type-1 query,\\nWe can update the whole blocks together by setting rev[block_id] = !rev[block_id] and update the total number of 1s in that block.\\n\\n# Complexity\\n- Time complexity:\\nO(n ^ 1.5) per type-1 query\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        const int n = nums1.size(), size = sqrt(n + 1.), m = (n + size - 1) / size;\\n        vector<int> s(m);\\n        vector<bool> rev(m);\\n        vector<long long> r;\\n        long long total = 0, v = 0;\\n        for (int i = 0; i < n; ++i) {\\n            s[i / size] += nums1[i];\\n            total += nums1[i];\\n            v += nums2[i];\\n        }\\n        for (const auto & q : queries) {\\n            if (q[0] == 1) {\\n                int x = q[1], y = q[2];\\n                while (x % size && x <= y) {\\n                    const int id = x / size;\\n                    if (nums1[x] == 1) {\\n                        --s[id];\\n                        if (rev[id]) {\\n                            ++total;\\n                        } else {\\n                            --total;\\n                        }\\n                    } else {\\n                        ++s[id];\\n                        if (rev[id]) {\\n                            --total;\\n                        } else {\\n                            ++total;\\n                        }\\n                    }\\n                    nums1[x++] ^= 1;  \\n                }\\n                while (y - x >= size - 1) {\\n                    const int id = x / size;\\n                    total -= rev[id] ? (size - s[id]) : s[id];\\n                    x += size;\\n                    rev[id] = !rev[id];\\n                    total += rev[id] ? (size - s[id]) : s[id];\\n                }\\n                while (x <= y) {\\n                    const int id = x / size;\\n                    if (nums1[x] == 1) {\\n                        --s[id];\\n                        if (rev[id]) {\\n                            ++total;\\n                        } else {\\n                            --total;\\n                        }\\n                    } else {\\n                        ++s[id];\\n                        if (rev[id]) {\\n                            --total;\\n                        } else {\\n                            ++total;\\n                        }\\n                    }\\n                    nums1[x++] ^= 1;  \\n                    \\n                }\\n                \\n            } else if (q[0] == 2) {\\n                v += total * q[1];\\n                \\n            } else {\\n                r.push_back(v);\\n            }\\n            \\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        const int n = nums1.size(), size = sqrt(n + 1.), m = (n + size - 1) / size;\\n        vector<int> s(m);\\n        vector<bool> rev(m);\\n        vector<long long> r;\\n        long long total = 0, v = 0;\\n        for (int i = 0; i < n; ++i) {\\n            s[i / size] += nums1[i];\\n            total += nums1[i];\\n            v += nums2[i];\\n        }\\n        for (const auto & q : queries) {\\n            if (q[0] == 1) {\\n                int x = q[1], y = q[2];\\n                while (x % size && x <= y) {\\n                    const int id = x / size;\\n                    if (nums1[x] == 1) {\\n                        --s[id];\\n                        if (rev[id]) {\\n                            ++total;\\n                        } else {\\n                            --total;\\n                        }\\n                    } else {\\n                        ++s[id];\\n                        if (rev[id]) {\\n                            --total;\\n                        } else {\\n                            ++total;\\n                        }\\n                    }\\n                    nums1[x++] ^= 1;  \\n                }\\n                while (y - x >= size - 1) {\\n                    const int id = x / size;\\n                    total -= rev[id] ? (size - s[id]) : s[id];\\n                    x += size;\\n                    rev[id] = !rev[id];\\n                    total += rev[id] ? (size - s[id]) : s[id];\\n                }\\n                while (x <= y) {\\n                    const int id = x / size;\\n                    if (nums1[x] == 1) {\\n                        --s[id];\\n                        if (rev[id]) {\\n                            ++total;\\n                        } else {\\n                            --total;\\n                        }\\n                    } else {\\n                        ++s[id];\\n                        if (rev[id]) {\\n                            --total;\\n                        } else {\\n                            ++total;\\n                        }\\n                    }\\n                    nums1[x++] ^= 1;  \\n                    \\n                }\\n                \\n            } else if (q[0] == 2) {\\n                v += total * q[1];\\n                \\n            } else {\\n                r.push_back(v);\\n            }\\n            \\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081189,
                "title": "lazy-sum-with-sqrt-decomposition",
                "content": "# Intuition\\nThe sum is for the entire array, so the only problem is queries of type 1 and 2, 1 updates the range, 2 asks for the sum of all 1s in the array. We can maintain the sum using blocks of size sqrt(n). \\n\\n# Approach\\nupdate(l, r) = update(r) & update(l-1), the elements at the beginning get flipped twice.\\n\\n# Complexity\\n- Time complexity:\\nO(n*sqrt(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    static const int BLK = 320;\\n    static const int LIM = 1e5+1;\\n    int blk_sum[BLK], is_flip[BLK], orig[LIM], n;\\n    void compute_block_sum(int blk_no) {\\n        int sum = 0;\\n        for(int i=blk_no*BLK;i<min(blk_no*BLK+BLK, n);i++) {\\n            sum += orig[i];\\n        }\\n        blk_sum[blk_no] = sum;\\n    }\\n    void apply_flip(int blk_no) {\\n        if(!is_flip[blk_no]) {\\n            return;\\n        }\\n        for(int i=blk_no*BLK;i<min(blk_no*BLK+BLK, n);i++) {\\n            orig[i] ^= 1;\\n        }\\n        compute_block_sum(blk_no);\\n        is_flip[blk_no] = 0;\\n    }\\n    void update(int r) {\\n        int rb = r/BLK;\\n        apply_flip(rb);\\n        for(int i=0;i<rb;i++) {\\n            is_flip[i] ^= 1;\\n        }\\n        for(int i=rb*BLK;i<=r;i++) {\\n            orig[i] ^= 1;\\n        }\\n        compute_block_sum(rb);\\n    }\\n    int query_full() {\\n        int rb = (n-1)/BLK, sum = 0;\\n        apply_flip(rb);\\n        for(int i=0;i<rb;i++) {\\n            if(is_flip[i]) {\\n                sum += BLK - blk_sum[i];\\n            } else {\\n                sum += blk_sum[i];\\n            }\\n        }\\n        for(int i=rb*BLK;i<n;i++) {\\n            sum += orig[i];\\n        }\\n        return sum;\\n    }\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        n = nums2.size();\\n        memset(is_flip, 0, sizeof(is_flip));\\n        memset(blk_sum, 0, sizeof(blk_sum));\\n        vector<long long> ans_vec;\\n        for(int i=0;i<n;i++) {\\n            orig[i] = nums1[i];\\n        }\\n        for(int i=0;i<n/BLK;i++) {\\n            compute_block_sum(i);\\n        }\\n\\n        long long ans = accumulate(nums2.begin(), nums2.end(), 0LL);\\n        for(vector<int>& query:queries) {\\n            int type = query[0], l = query[1], r = query[2];\\n            if(type==1) {\\n                if(l!=0) {\\n                    update(l-1);\\n                }\\n                update(r);\\n            } else if(type==2) {\\n                ans += 1LL*query_full()*l;\\n            } else if(type==3) {\\n                ans_vec.push_back(ans);\\n            }\\n        }\\n        return ans_vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    static const int BLK = 320;\\n    static const int LIM = 1e5+1;\\n    int blk_sum[BLK], is_flip[BLK], orig[LIM], n;\\n    void compute_block_sum(int blk_no) {\\n        int sum = 0;\\n        for(int i=blk_no*BLK;i<min(blk_no*BLK+BLK, n);i++) {\\n            sum += orig[i];\\n        }\\n        blk_sum[blk_no] = sum;\\n    }\\n    void apply_flip(int blk_no) {\\n        if(!is_flip[blk_no]) {\\n            return;\\n        }\\n        for(int i=blk_no*BLK;i<min(blk_no*BLK+BLK, n);i++) {\\n            orig[i] ^= 1;\\n        }\\n        compute_block_sum(blk_no);\\n        is_flip[blk_no] = 0;\\n    }\\n    void update(int r) {\\n        int rb = r/BLK;\\n        apply_flip(rb);\\n        for(int i=0;i<rb;i++) {\\n            is_flip[i] ^= 1;\\n        }\\n        for(int i=rb*BLK;i<=r;i++) {\\n            orig[i] ^= 1;\\n        }\\n        compute_block_sum(rb);\\n    }\\n    int query_full() {\\n        int rb = (n-1)/BLK, sum = 0;\\n        apply_flip(rb);\\n        for(int i=0;i<rb;i++) {\\n            if(is_flip[i]) {\\n                sum += BLK - blk_sum[i];\\n            } else {\\n                sum += blk_sum[i];\\n            }\\n        }\\n        for(int i=rb*BLK;i<n;i++) {\\n            sum += orig[i];\\n        }\\n        return sum;\\n    }\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        n = nums2.size();\\n        memset(is_flip, 0, sizeof(is_flip));\\n        memset(blk_sum, 0, sizeof(blk_sum));\\n        vector<long long> ans_vec;\\n        for(int i=0;i<n;i++) {\\n            orig[i] = nums1[i];\\n        }\\n        for(int i=0;i<n/BLK;i++) {\\n            compute_block_sum(i);\\n        }\\n\\n        long long ans = accumulate(nums2.begin(), nums2.end(), 0LL);\\n        for(vector<int>& query:queries) {\\n            int type = query[0], l = query[1], r = query[2];\\n            if(type==1) {\\n                if(l!=0) {\\n                    update(l-1);\\n                }\\n                update(r);\\n            } else if(type==2) {\\n                ans += 1LL*query_full()*l;\\n            } else if(type==3) {\\n                ans_vec.push_back(ans);\\n            }\\n        }\\n        return ans_vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001719,
                "title": "segment-tree-lazy-propagation-easy-and-clean-code-beats-90-of-all-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void build(int ind,int low,int high,vector<int>& nums1,vector<pair<int,int>> &seg)\\n    {\\n        if(low==high)\\n        {\\n            if(nums1[low]==0)\\n            seg[ind]={1,0};\\n            else\\n                seg[ind]={0,1};\\n            \\n            return;\\n        }\\n        \\n        int mid=(low+high)/2;\\n        \\n        build(2*ind+1,low,mid,nums1,seg);\\n        build(2*ind+2,mid+1,high,nums1,seg);\\n        \\n        int a=seg[2*ind+1].first+seg[2*ind+2].first;\\n        int b=seg[2*ind+1].second+seg[2*ind+2].second;\\n        \\n        seg[ind]={a,b};\\n        \\n    }\\n    \\n    void update(int ind, int low,int high,int l,int r,vector<pair<int,int>> &seg,vector<int> &lazy)\\n    {\\n         if(low>=l && high<=r)\\n            {\\n                auto tem=seg[ind];\\n                seg[ind]={tem.second,tem.first};\\n             if(low!=high)\\n                lazy[ind]=1-lazy[ind];\\n                return;\\n            } \\n         else if(high<l || r<low)\\n        {\\n            return;\\n        }\\n        else\\n        { \\n            if(lazy[ind]==1)\\n            {\\n                lazy[ind]=0;\\n                \\n                lazy[2*ind+1]=1-lazy[2*ind+1];\\n                lazy[2*ind+2]=1-lazy[2*ind+2];\\n                \\n                 auto tem1=seg[2*ind+1];\\n                seg[2*ind+1]={tem1.second,tem1.first};\\n                \\n                 auto tem2=seg[2*ind+2];\\n                seg[2*ind+2]={tem2.second,tem2.first};\\n            }\\n            \\n            int mid=(low+high)/2;\\n            \\n            update(2*ind+1,low,mid,l,r,seg,lazy);\\n            update(2*ind+2,mid+1,high,l,r,seg,lazy);\\n            \\n             int a=seg[2*ind+1].first+seg[2*ind+2].first;\\n        int b=seg[2*ind+1].second+seg[2*ind+2].second;\\n            seg[ind]={a,b};\\n        }\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long> ans;\\n        \\n        long long sum2=0;\\n        \\n        for(auto i:nums2)\\n        {\\n            long long tem=i;\\n            sum2+=tem;\\n        }\\n        int n=nums1.size();\\n        \\n        vector<pair<int,int>> seg(4*n);\\n        vector<int> lazy(4*n,0);\\n        \\n        build(0,0,n-1,nums1,seg);\\n        \\n        for(auto q:queries)\\n        {\\n            if(q[0]==1)\\n            {\\n                int l=q[1];\\n                int r=q[2];\\n                \\n                update(0,0,n-1,l,r,seg,lazy);\\n             \\n            }\\n            else if(q[0]==2)\\n            {\\n                long long b1=seg[0].second;\\n                long long b2=q[1];\\n                sum2=sum2+b1*b2;\\n                \\n                \\n            }\\n            else\\n            {\\n                ans.push_back(sum2);\\n                \\n               \\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void build(int ind,int low,int high,vector<int>& nums1,vector<pair<int,int>> &seg)\\n    {\\n        if(low==high)\\n        {\\n            if(nums1[low]==0)\\n            seg[ind]={1,0};\\n            else\\n                seg[ind]={0,1};\\n            \\n            return;\\n        }\\n        \\n        int mid=(low+high)/2;\\n        \\n        build(2*ind+1,low,mid,nums1,seg);\\n        build(2*ind+2,mid+1,high,nums1,seg);\\n        \\n        int a=seg[2*ind+1].first+seg[2*ind+2].first;\\n        int b=seg[2*ind+1].second+seg[2*ind+2].second;\\n        \\n        seg[ind]={a,b};\\n        \\n    }\\n    \\n    void update(int ind, int low,int high,int l,int r,vector<pair<int,int>> &seg,vector<int> &lazy)\\n    {\\n         if(low>=l && high<=r)\\n            {\\n                auto tem=seg[ind];\\n                seg[ind]={tem.second,tem.first};\\n             if(low!=high)\\n                lazy[ind]=1-lazy[ind];\\n                return;\\n            } \\n         else if(high<l || r<low)\\n        {\\n            return;\\n        }\\n        else\\n        { \\n            if(lazy[ind]==1)\\n            {\\n                lazy[ind]=0;\\n                \\n                lazy[2*ind+1]=1-lazy[2*ind+1];\\n                lazy[2*ind+2]=1-lazy[2*ind+2];\\n                \\n                 auto tem1=seg[2*ind+1];\\n                seg[2*ind+1]={tem1.second,tem1.first};\\n                \\n                 auto tem2=seg[2*ind+2];\\n                seg[2*ind+2]={tem2.second,tem2.first};\\n            }\\n            \\n            int mid=(low+high)/2;\\n            \\n            update(2*ind+1,low,mid,l,r,seg,lazy);\\n            update(2*ind+2,mid+1,high,l,r,seg,lazy);\\n            \\n             int a=seg[2*ind+1].first+seg[2*ind+2].first;\\n        int b=seg[2*ind+1].second+seg[2*ind+2].second;\\n            seg[ind]={a,b};\\n        }\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long> ans;\\n        \\n        long long sum2=0;\\n        \\n        for(auto i:nums2)\\n        {\\n            long long tem=i;\\n            sum2+=tem;\\n        }\\n        int n=nums1.size();\\n        \\n        vector<pair<int,int>> seg(4*n);\\n        vector<int> lazy(4*n,0);\\n        \\n        build(0,0,n-1,nums1,seg);\\n        \\n        for(auto q:queries)\\n        {\\n            if(q[0]==1)\\n            {\\n                int l=q[1];\\n                int r=q[2];\\n                \\n                update(0,0,n-1,l,r,seg,lazy);\\n             \\n            }\\n            else if(q[0]==2)\\n            {\\n                long long b1=seg[0].second;\\n                long long b2=q[1];\\n                sum2=sum2+b1*b2;\\n                \\n                \\n            }\\n            else\\n            {\\n                ans.push_back(sum2);\\n                \\n               \\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983403,
                "title": "sqrt-decomposition",
                "content": "```\\nclass SQRT:\\n    def __init__(self, arr):\\n        n = len(arr)\\n        B = int(pow(n, 0.5) + 1)\\n        blocks = [[set(), set()] for _ in range(B)]\\n        self.total = 0\\n        for i in range(n):\\n            blocks[i // B][arr[i]].add(i % B)\\n            self.total += arr[i]\\n        self.B = B\\n        self.blocks = blocks\\n        \\n    def flip(self, l, r):\\n        i = l\\n        while i <= r:\\n            if i % self.B == 0 and i + self.B - 1 <= r:\\n                self.total -= len(self.blocks[i // self.B][1])\\n                self.blocks[i // self.B].reverse()\\n                self.total += len(self.blocks[i // self.B][1])\\n                i += self.B\\n            else:\\n                if i % self.B in self.blocks[i // self.B][0]:\\n                    self.blocks[i // self.B][0].remove(i % self.B)\\n                    self.blocks[i // self.B][1].add(i % self.B)\\n                    self.total += 1\\n                else:\\n                    self.blocks[i // self.B][1].remove(i % self.B)\\n                    self.blocks[i // self.B][0].add(i % self.B)\\n                    self.total -= 1\\n                i += 1\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        curr = sum(nums2)\\n        res = []\\n        sq = SQRT(nums1)\\n        for t, x, y in queries:\\n            if t == 1:\\n                sq.flip(x, y)\\n            if t == 2:\\n                curr += x * sq.total\\n            if t == 3:\\n                res.append(curr)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass SQRT:\\n    def __init__(self, arr):\\n        n = len(arr)\\n        B = int(pow(n, 0.5) + 1)\\n        blocks = [[set(), set()] for _ in range(B)]\\n        self.total = 0\\n        for i in range(n):\\n            blocks[i // B][arr[i]].add(i % B)\\n            self.total += arr[i]\\n        self.B = B\\n        self.blocks = blocks\\n        \\n    def flip(self, l, r):\\n        i = l\\n        while i <= r:\\n            if i % self.B == 0 and i + self.B - 1 <= r:\\n                self.total -= len(self.blocks[i // self.B][1])\\n                self.blocks[i // self.B].reverse()\\n                self.total += len(self.blocks[i // self.B][1])\\n                i += self.B\\n            else:\\n                if i % self.B in self.blocks[i // self.B][0]:\\n                    self.blocks[i // self.B][0].remove(i % self.B)\\n                    self.blocks[i // self.B][1].add(i % self.B)\\n                    self.total += 1\\n                else:\\n                    self.blocks[i // self.B][1].remove(i % self.B)\\n                    self.blocks[i // self.B][0].add(i % self.B)\\n                    self.total -= 1\\n                i += 1\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        curr = sum(nums2)\\n        res = []\\n        sq = SQRT(nums1)\\n        for t, x, y in queries:\\n            if t == 1:\\n                sq.flip(x, y)\\n            if t == 2:\\n                curr += x * sq.total\\n            if t == 3:\\n                res.append(curr)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950804,
                "title": "segment-tree-w-lazy-updates-java",
                "content": "```java\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        int n = 0;\\n        for (int [] query : queries) if (query[0] == 3) n++;\\n        long sum = 0;\\n        for (int num : nums2) sum += num;\\n        for (int i = 0; i < nums1.length; i++) if (nums1[i] == 0) nums1[i] = -1;\\n        long[] ans = new long[n];\\n        SegmentTree tree = new SegmentTree(nums1);\\n        int k = 0;\\n        for (int[] q : queries) {\\n            if (q[0] == 1) tree.flip(query[1], query[2]);\\n            else if (q[1] == 2) sum = sum + query[1] * ((tree.query(0, tree.n-1) + tree.n)/2);\\n            else ans[k++] = sum;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    class SegmentTree {\\n        long[] tree;\\n        long[] lazy;\\n        int n;\\n\\n        public SegmentTree(int[] nums) {\\n            n = nums.length;\\n            tree = new long[4 * n];\\n            lazy = new long[4 * n];\\n            Arrays.fill(lazy, 1L);\\n            build(0, 0, n-1, nums);\\n        }\\n        \\n        // build the segment tree, looks fine\\n        public void build(int node, int l, int r, int[] nums) {\\n            if (l == r) {\\n                tree[node] = (long)nums[l];\\n                return;\\n            }\\n\\n            int mid = (l + r)/2;\\n\\n            build(node * 2 + 1, l, mid, nums);\\n            build(node * 2 + 2, mid+1, r, nums);\\n\\n            tree[node] = tree[node*2+1] + tree[node*2+2];\\n        }\\n\\n        public void flip(int l, int r) {\\n            flip(0, 0, n-1, l, r);\\n        }\\n        \\n        public void flip(int node, int start, int end, int l, int r) {\\n            // IMPORTANT: Before ANYTHING, update the node if its not up to date\\n            // For some reason I got WA when checking if out of bounds before updating\\n            if (lazy[node] != 1) {\\n\\n                tree[node] *= lazy[node];\\n                // step 2: merge changes down to children if its not a leaf node\\n                if (start != end) {\\n                    lazy[node * 2 + 1] *= lazy[node];\\n                    lazy[node * 2 + 2] *= lazy[node];\\n                }\\n\\n                // step 3: set the lazy update of this node to 1\\n                lazy[node] = 1;\\n            }\\n            \\n            if (end < l || start > r) return;\\n            if (end <= r && start >= l) {\\n                \\n                tree[node] *= -1;\\n                if (start != end) {\\n                    lazy[node * 2 + 1] *= -1;\\n                    lazy[node * 2 + 2] *= -1;\\n                }\\n\\n                lazy[node] = 1;\\n                return;\\n            }\\n\\n            int mid = (end + start)/2;\\n            flip(node * 2 + 1, start, mid, l, r);\\n            flip(node * 2 + 2, mid + 1, end, l, r);\\n            tree[node] = tree[node * 2 + 1] + tree[node * 2 + 2];\\n        }\\n\\n        public long query(int l, int r) {\\n            return query(0, 0, n-1, l, r);\\n        }\\n\\n        public long query(int node, int start, int end, int l, int r) {\\n            // step 1: if this node is not updated, update this node\\n            if (lazy[node] != 1) {\\n\\n                tree[node] *= lazy[node];\\n                // step 2: merge changes down to children if its not a leaf node\\n                if (start != end) {\\n                    lazy[node * 2 + 1] *= -1;\\n                    lazy[node * 2 + 2] *= -1;\\n                }\\n\\n                // step 3: set the lazy update of this node to 1\\n                lazy[node] = 1;\\n            }\\n            \\n            if (end < l || start > r) return 0;\\n            if (end <= r && start >= l) return tree[node];\\n            int mid = (end + start) / 2;\\n            return query(node * 2 + 1, start, mid, l, r) + query(node * 2 + 2, mid + 1, end, l, r);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        int n = 0;\\n        for (int [] query : queries) if (query[0] == 3) n++;\\n        long sum = 0;\\n        for (int num : nums2) sum += num;\\n        for (int i = 0; i < nums1.length; i++) if (nums1[i] == 0) nums1[i] = -1;\\n        long[] ans = new long[n];\\n        SegmentTree tree = new SegmentTree(nums1);\\n        int k = 0;\\n        for (int[] q : queries) {\\n            if (q[0] == 1) tree.flip(query[1], query[2]);\\n            else if (q[1] == 2) sum = sum + query[1] * ((tree.query(0, tree.n-1) + tree.n)/2);\\n            else ans[k++] = sum;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    class SegmentTree {\\n        long[] tree;\\n        long[] lazy;\\n        int n;\\n\\n        public SegmentTree(int[] nums) {\\n            n = nums.length;\\n            tree = new long[4 * n];\\n            lazy = new long[4 * n];\\n            Arrays.fill(lazy, 1L);\\n            build(0, 0, n-1, nums);\\n        }\\n        \\n        // build the segment tree, looks fine\\n        public void build(int node, int l, int r, int[] nums) {\\n            if (l == r) {\\n                tree[node] = (long)nums[l];\\n                return;\\n            }\\n\\n            int mid = (l + r)/2;\\n\\n            build(node * 2 + 1, l, mid, nums);\\n            build(node * 2 + 2, mid+1, r, nums);\\n\\n            tree[node] = tree[node*2+1] + tree[node*2+2];\\n        }\\n\\n        public void flip(int l, int r) {\\n            flip(0, 0, n-1, l, r);\\n        }\\n        \\n        public void flip(int node, int start, int end, int l, int r) {\\n            // IMPORTANT: Before ANYTHING, update the node if its not up to date\\n            // For some reason I got WA when checking if out of bounds before updating\\n            if (lazy[node] != 1) {\\n\\n                tree[node] *= lazy[node];\\n                // step 2: merge changes down to children if its not a leaf node\\n                if (start != end) {\\n                    lazy[node * 2 + 1] *= lazy[node];\\n                    lazy[node * 2 + 2] *= lazy[node];\\n                }\\n\\n                // step 3: set the lazy update of this node to 1\\n                lazy[node] = 1;\\n            }\\n            \\n            if (end < l || start > r) return;\\n            if (end <= r && start >= l) {\\n                \\n                tree[node] *= -1;\\n                if (start != end) {\\n                    lazy[node * 2 + 1] *= -1;\\n                    lazy[node * 2 + 2] *= -1;\\n                }\\n\\n                lazy[node] = 1;\\n                return;\\n            }\\n\\n            int mid = (end + start)/2;\\n            flip(node * 2 + 1, start, mid, l, r);\\n            flip(node * 2 + 2, mid + 1, end, l, r);\\n            tree[node] = tree[node * 2 + 1] + tree[node * 2 + 2];\\n        }\\n\\n        public long query(int l, int r) {\\n            return query(0, 0, n-1, l, r);\\n        }\\n\\n        public long query(int node, int start, int end, int l, int r) {\\n            // step 1: if this node is not updated, update this node\\n            if (lazy[node] != 1) {\\n\\n                tree[node] *= lazy[node];\\n                // step 2: merge changes down to children if its not a leaf node\\n                if (start != end) {\\n                    lazy[node * 2 + 1] *= -1;\\n                    lazy[node * 2 + 2] *= -1;\\n                }\\n\\n                // step 3: set the lazy update of this node to 1\\n                lazy[node] = 1;\\n            }\\n            \\n            if (end < l || start > r) return 0;\\n            if (end <= r && start >= l) return tree[node];\\n            int mid = (end + start) / 2;\\n            return query(node * 2 + 1, start, mid, l, r) + query(node * 2 + 2, mid + 1, end, l, r);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765870,
                "title": "c-solution-lazy-segment-tree-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass STree{\\npublic:\\n    vector<long long>seg;\\n    vector<long long>lazy;\\n    STree(int n){\\n        seg.resize(4*n+1);\\n        lazy.resize(4*n+1,0);\\n        return;\\n    }\\n\\n    void build(vector<int>&nums,int ind,int low,int high){\\n        if(low==high){\\n            seg[ind]=nums[low];\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(nums,2*ind+1,low,mid);\\n        build(nums,2*ind+2,mid+1,high);\\n        seg[ind]=seg[2*ind+1]+seg[2*ind+2];\\n    }\\n\\n    void update(int ind,int low,int high,int l,int r){\\n        if(lazy[ind]!=0){\\n            seg[ind]=(high-low+1)-seg[ind];\\n            if(low!=high){\\n                lazy[2*ind+1]=!lazy[2*ind+1];\\n                lazy[2*ind+2]=!lazy[2*ind+2];\\n            }\\n            lazy[ind]=0;\\n        }\\n        if(low>r or high<l){ return;}\\n        if(l<=low and high<=r){\\n            seg[ind]=(high-low+1)-seg[ind];\\n            if(low!=high){\\n                lazy[2*ind+1]=!lazy[2*ind+1];\\n                lazy[2*ind+2]=!lazy[2*ind+2];\\n            }\\n            return;\\n        }  \\n        int mid=(low+high)>>1;\\n        update(2*ind+1,low,mid,l,r);\\n        update(2*ind+2,mid+1,high,l,r);\\n        seg[ind]=seg[2*ind+1]+seg[2*ind+2];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        long long sum=0;\\n        int n=nums1.size();\\n        STree st(n+1);\\n        st.build(nums1,0,0,n-1);\\n        for(int i=0;i<nums2.size();i++){\\n            sum+=nums2[i];\\n        }\\n        vector<long long>res;\\n        for(auto query:queries){\\n            int type=query[0];\\n            if(type==1){\\n                st.update(0,0,n-1,query[1],query[2]);\\n            }\\n            else if(type==2){\\n                sum+=st.seg[0]*query[1];\\n            }\\n            else{\\n                res.push_back(sum);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass STree{\\npublic:\\n    vector<long long>seg;\\n    vector<long long>lazy;\\n    STree(int n){\\n        seg.resize(4*n+1);\\n        lazy.resize(4*n+1,0);\\n        return;\\n    }\\n\\n    void build(vector<int>&nums,int ind,int low,int high){\\n        if(low==high){\\n            seg[ind]=nums[low];\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(nums,2*ind+1,low,mid);\\n        build(nums,2*ind+2,mid+1,high);\\n        seg[ind]=seg[2*ind+1]+seg[2*ind+2];\\n    }\\n\\n    void update(int ind,int low,int high,int l,int r){\\n        if(lazy[ind]!=0){\\n            seg[ind]=(high-low+1)-seg[ind];\\n            if(low!=high){\\n                lazy[2*ind+1]=!lazy[2*ind+1];\\n                lazy[2*ind+2]=!lazy[2*ind+2];\\n            }\\n            lazy[ind]=0;\\n        }\\n        if(low>r or high<l){ return;}\\n        if(l<=low and high<=r){\\n            seg[ind]=(high-low+1)-seg[ind];\\n            if(low!=high){\\n                lazy[2*ind+1]=!lazy[2*ind+1];\\n                lazy[2*ind+2]=!lazy[2*ind+2];\\n            }\\n            return;\\n        }  \\n        int mid=(low+high)>>1;\\n        update(2*ind+1,low,mid,l,r);\\n        update(2*ind+2,mid+1,high,l,r);\\n        seg[ind]=seg[2*ind+1]+seg[2*ind+2];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        long long sum=0;\\n        int n=nums1.size();\\n        STree st(n+1);\\n        st.build(nums1,0,0,n-1);\\n        for(int i=0;i<nums2.size();i++){\\n            sum+=nums2[i];\\n        }\\n        vector<long long>res;\\n        for(auto query:queries){\\n            int type=query[0];\\n            if(type==1){\\n                st.update(0,0,n-1,query[1],query[2]);\\n            }\\n            else if(type==2){\\n                sum+=st.seg[0]*query[1];\\n            }\\n            else{\\n                res.push_back(sum);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657343,
                "title": "c-lazy-segment-tree-easy-to-understand",
                "content": "# Intuition\\nAll we need to do is manage the count of ones after any number of flips\\n\\n# Approach\\nFirst lets look at query of type 2 : \\nSince our goal is to get sum of all elements nums2. query of type2 is only increasing the sum by p * number of ones in nums1\\n\\nSo if we somehow know the number of ones in nums1, we can simply increase the sum of nums2 by p * number of ones in nums1\\n\\nGoing to the query of type 3:\\nSince we would always have the updated sum of nums2, we can simply store the sum whenever we encounter query 3\\n\\nNow coming to query of type 1:\\nWe need a data structure which can apply flip operation for range l to r and also return the total number of ones across the array.\\n\\nWe can use lazy segment tree for this.\\n\\n# Complexity\\n- Time complexity:\\nfor query 1 : $$O(logN)$$\\nfor query 2 : $$O(1)$$\\nfor query 3 : $$O(1)$$\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass LazySegmentTree {\\n\\tvector<int> tree;\\t\\n\\tvector<bool> inverted;\\n\\tint n;\\n\\n\\tvoid buildTree(int node, int l, int r, vector<int> &nums) {\\n\\t\\tif(l == r) {\\n\\t\\t\\tinverted[node] = false;\\n\\t\\t\\ttree[node] = nums[l];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = (r - l)/2 + l;\\n\\t\\tbuildTree(2*node,l, mid, nums);\\n\\t\\tbuildTree(2*node + 1, mid + 1, r, nums);\\n\\t\\ttree[node] = tree[2 * node] + tree[2 * node + 1];\\n\\t\\tinverted[node] = false;\\n\\t}\\n\\n\\tvoid flipHelper(int node, int l, int r, int ql, int qr) {\\n        if(inverted[node]) {\\n            inverted[node] = false;\\n            tree[node] = r - l + 1 - tree[node];\\n            if(l != r) {\\n                int mid = (r - l)/2 + l;\\n                inverted[2*node] = !inverted[2*node];\\n                inverted[2 * node + 1] = !inverted[2*node + 1];\\n            }\\n        }\\n        if(l > qr || r < ql) {\\n            return;\\n        }\\n        if(ql <= l && r <= qr) {\\n            tree[node] = r - l + 1 - tree[node];\\n            if(l != r) {\\n                inverted[2 *node] = !inverted[2*node];\\n                inverted[2*node + 1] = !inverted[2 * node + 1];\\n            }\\n            return;\\n        }\\n        int mid = (r - l)/2 + l;\\n        flipHelper(2*node, l, mid, ql, qr);\\n        flipHelper(2 * node + 1, mid + 1, r, ql, qr);\\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\\n    }\\n\\n\\n\\tpublic:\\n\\tLazySegmentTree(vector<int> &nums):tree(4*nums.size()),inverted(4*nums.size()), n(nums.size()) {\\n\\t\\tbuildTree(1, 0, nums.size() - 1, nums);\\n\\t}\\n\\n\\tvoid flip(int l, int r) {\\n\\t\\tflipHelper(1, 0, n - 1, l, r);\\n\\t}\\n\\tint getOnes() {\\n\\t\\treturn tree[1];\\n\\t}\\n};\\n\\nclass Solution {\\n\\npublic:\\n\\tlong long getSum(vector<int> &nums2) {\\n\\t\\tlong long sum = 0;\\n\\t\\tfor(int a : nums2) {\\n\\t\\t\\tsum += a;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tvector<long long> handleQuery(vector<int> &nums1, vector<int> &nums2, vector<vector<int>> &queries) {\\n\\t\\tLazySegmentTree oneManager(nums1);\\n\\t\\tlong long sum = getSum(nums2);\\n\\t\\tvector<long long> ans;\\n\\n\\t\\tfor(vector<int> &query : queries) {\\n\\t\\t\\tswitch(query[0]) {\\n\\t\\t\\t\\tcase 1: oneManager.flip(query[1], query[2]);break;\\n\\t\\t\\t\\tcase 2 : sum += query[1] * 1ll*oneManager.getOnes();break;\\n\\t\\t\\t\\tcase 3 : ans.push_back(sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LazySegmentTree {\\n\\tvector<int> tree;\\t\\n\\tvector<bool> inverted;\\n\\tint n;\\n\\n\\tvoid buildTree(int node, int l, int r, vector<int> &nums) {\\n\\t\\tif(l == r) {\\n\\t\\t\\tinverted[node] = false;\\n\\t\\t\\ttree[node] = nums[l];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = (r - l)/2 + l;\\n\\t\\tbuildTree(2*node,l, mid, nums);\\n\\t\\tbuildTree(2*node + 1, mid + 1, r, nums);\\n\\t\\ttree[node] = tree[2 * node] + tree[2 * node + 1];\\n\\t\\tinverted[node] = false;\\n\\t}\\n\\n\\tvoid flipHelper(int node, int l, int r, int ql, int qr) {\\n        if(inverted[node]) {\\n            inverted[node] = false;\\n            tree[node] = r - l + 1 - tree[node];\\n            if(l != r) {\\n                int mid = (r - l)/2 + l;\\n                inverted[2*node] = !inverted[2*node];\\n                inverted[2 * node + 1] = !inverted[2*node + 1];\\n            }\\n        }\\n        if(l > qr || r < ql) {\\n            return;\\n        }\\n        if(ql <= l && r <= qr) {\\n            tree[node] = r - l + 1 - tree[node];\\n            if(l != r) {\\n                inverted[2 *node] = !inverted[2*node];\\n                inverted[2*node + 1] = !inverted[2 * node + 1];\\n            }\\n            return;\\n        }\\n        int mid = (r - l)/2 + l;\\n        flipHelper(2*node, l, mid, ql, qr);\\n        flipHelper(2 * node + 1, mid + 1, r, ql, qr);\\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\\n    }\\n\\n\\n\\tpublic:\\n\\tLazySegmentTree(vector<int> &nums):tree(4*nums.size()),inverted(4*nums.size()), n(nums.size()) {\\n\\t\\tbuildTree(1, 0, nums.size() - 1, nums);\\n\\t}\\n\\n\\tvoid flip(int l, int r) {\\n\\t\\tflipHelper(1, 0, n - 1, l, r);\\n\\t}\\n\\tint getOnes() {\\n\\t\\treturn tree[1];\\n\\t}\\n};\\n\\nclass Solution {\\n\\npublic:\\n\\tlong long getSum(vector<int> &nums2) {\\n\\t\\tlong long sum = 0;\\n\\t\\tfor(int a : nums2) {\\n\\t\\t\\tsum += a;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tvector<long long> handleQuery(vector<int> &nums1, vector<int> &nums2, vector<vector<int>> &queries) {\\n\\t\\tLazySegmentTree oneManager(nums1);\\n\\t\\tlong long sum = getSum(nums2);\\n\\t\\tvector<long long> ans;\\n\\n\\t\\tfor(vector<int> &query : queries) {\\n\\t\\t\\tswitch(query[0]) {\\n\\t\\t\\t\\tcase 1: oneManager.flip(query[1], query[2]);break;\\n\\t\\t\\t\\tcase 2 : sum += query[1] * 1ll*oneManager.getOnes();break;\\n\\t\\t\\t\\tcase 3 : ans.push_back(sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620126,
                "title": "golang-segment-tree-with-lazy-propagation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(qlog(n) + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(max(q,n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype segmentTree struct {\\n    tree []int\\n    lazy []int\\n}\\n\\nfunc NewSegmentTree(n int) *segmentTree {\\n    return &segmentTree{\\n        tree: make([]int, 4*n),\\n        lazy: make([]int, 4*n),\\n    }\\n}\\n\\nfunc (s *segmentTree) Build(treeIndex int, treeLo int, treeHi int, arr []int) {\\n    if treeLo == treeHi {\\n        s.tree[treeIndex] = arr[treeLo]\\n        return\\n    }\\n    mid := (treeHi-treeLo)/2+treeLo\\n    s.Build(treeIndex*2, treeLo, mid, arr)\\n    s.Build(treeIndex*2+1, mid+1, treeHi, arr)\\n    s.tree[treeIndex] = s.tree[treeIndex*2] + s.tree[treeIndex*2+1]\\n}\\n\\nfunc (s *segmentTree) Update(treeIndex int, treeLo int, treeHi int, updateLo int, updateHi int) {\\n    if s.lazy[treeIndex] > 0 {\\n        s.tree[treeIndex] = treeHi-treeLo+1-s.tree[treeIndex]\\n        if treeLo != treeHi {\\n            s.lazy[treeIndex*2] ^= 1\\n            s.lazy[treeIndex*2+1] ^= 1\\n        }\\n        s.lazy[treeIndex] = 0\\n    }\\n    if treeLo > updateHi || treeHi < updateLo {\\n        return\\n    }\\n    if updateLo <= treeLo && treeHi <= updateHi {\\n        s.tree[treeIndex] = treeHi-treeLo+1-s.tree[treeIndex]\\n        if treeLo != treeHi {\\n            s.lazy[treeIndex*2] ^= 1\\n            s.lazy[treeIndex*2+1] ^= 1\\n        }\\n        return\\n    }\\n    mid := (treeHi-treeLo)/2+treeLo\\n    s.Update(treeIndex*2, treeLo, mid, updateLo, updateHi)\\n    s.Update(treeIndex*2+1, mid+1, treeHi, updateLo, updateHi)\\n    s.tree[treeIndex] = s.tree[treeIndex*2] + s.tree[treeIndex*2+1]\\n}\\n\\n\\nfunc handleQuery(nums1 []int, nums2 []int, queries [][]int) []int64 {\\n    l := len(nums1)\\n    var sum int64\\n    for _, num := range nums2 {\\n        sum += int64(num)\\n    }\\n    segmentTree := NewSegmentTree(l)\\n    segmentTree.Build(1, 0, l-1, nums1)\\n    var ans []int64\\n    for _, q := range queries {\\n        switch q[0] {\\n            case 1:\\n                segmentTree.Update(1, 0, l-1, q[1], q[2])\\n            case 2:\\n                sum += int64(segmentTree.tree[1] * q[1])\\n            case 3:\\n                ans = append(ans, sum)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype segmentTree struct {\\n    tree []int\\n    lazy []int\\n}\\n\\nfunc NewSegmentTree(n int) *segmentTree {\\n    return &segmentTree{\\n        tree: make([]int, 4*n),\\n        lazy: make([]int, 4*n),\\n    }\\n}\\n\\nfunc (s *segmentTree) Build(treeIndex int, treeLo int, treeHi int, arr []int) {\\n    if treeLo == treeHi {\\n        s.tree[treeIndex] = arr[treeLo]\\n        return\\n    }\\n    mid := (treeHi-treeLo)/2+treeLo\\n    s.Build(treeIndex*2, treeLo, mid, arr)\\n    s.Build(treeIndex*2+1, mid+1, treeHi, arr)\\n    s.tree[treeIndex] = s.tree[treeIndex*2] + s.tree[treeIndex*2+1]\\n}\\n\\nfunc (s *segmentTree) Update(treeIndex int, treeLo int, treeHi int, updateLo int, updateHi int) {\\n    if s.lazy[treeIndex] > 0 {\\n        s.tree[treeIndex] = treeHi-treeLo+1-s.tree[treeIndex]\\n        if treeLo != treeHi {\\n            s.lazy[treeIndex*2] ^= 1\\n            s.lazy[treeIndex*2+1] ^= 1\\n        }\\n        s.lazy[treeIndex] = 0\\n    }\\n    if treeLo > updateHi || treeHi < updateLo {\\n        return\\n    }\\n    if updateLo <= treeLo && treeHi <= updateHi {\\n        s.tree[treeIndex] = treeHi-treeLo+1-s.tree[treeIndex]\\n        if treeLo != treeHi {\\n            s.lazy[treeIndex*2] ^= 1\\n            s.lazy[treeIndex*2+1] ^= 1\\n        }\\n        return\\n    }\\n    mid := (treeHi-treeLo)/2+treeLo\\n    s.Update(treeIndex*2, treeLo, mid, updateLo, updateHi)\\n    s.Update(treeIndex*2+1, mid+1, treeHi, updateLo, updateHi)\\n    s.tree[treeIndex] = s.tree[treeIndex*2] + s.tree[treeIndex*2+1]\\n}\\n\\n\\nfunc handleQuery(nums1 []int, nums2 []int, queries [][]int) []int64 {\\n    l := len(nums1)\\n    var sum int64\\n    for _, num := range nums2 {\\n        sum += int64(num)\\n    }\\n    segmentTree := NewSegmentTree(l)\\n    segmentTree.Build(1, 0, l-1, nums1)\\n    var ans []int64\\n    for _, q := range queries {\\n        switch q[0] {\\n            case 1:\\n                segmentTree.Update(1, 0, l-1, q[1], q[2])\\n            case 2:\\n                sum += int64(segmentTree.tree[1] * q[1])\\n            case 3:\\n                ans = append(ans, sum)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443766,
                "title": "segtree-marking-flips-on-the-way",
                "content": "segTree solution where any node cantains 4 values in order: {range start of node, range end of node, number of 1s/0s, if subtree need to be flipped when going down the tree(0: no, 1: yes)}.\\n\\nsegTree solution where 3rd entry of any node keeps the count of number of 1s in the subtree at that node only if 4th entry is 0(subtree unflipped) else,\\nthe 3rd entry keeps the count of number of 0s in the subtree if 4th entry is 1(subtree flipped) (easy for flipping the \\'entire\\' subtree as well as propogating the flip down the subtree. If the subtree is also flipped at this node then number of 1s in subtree becomes the number of 0s, and the 4th key automatically represents that):\\nflip method only returns number of 1s in a subtree at c after doing all flipping operations.\\n```\\nclass Solution {\\n    int flip(vector<vector<int> > &segTree, int i, int j, int c){\\n        if(j >= i) {\\n            if(segTree[c][0] == i && segTree[c][1] == j){\\n                segTree[c][3] ^= 1;\\n            }\\n            else{\\n                int l = flip(segTree, i, min(j, segTree[2*c + 1][1]), 2*c + 1);\\n                int r = flip(segTree, max(i, segTree[2*c + 2][0]), j, 2*c + 2);\\n                segTree[c][2] = l + r;\\n            }\\n        }\\n        if(segTree[c][3] == 1){\\n            return segTree[c][1] - segTree[c][0] + 1 - segTree[c][2];\\n        }\\n        return segTree[c][2];\\n    }\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long> ans;\\n        long long sum = 0;\\n        for(int x: nums2) sum += x;\\n        int t = 1;\\n        while(t < nums1.size()) t *= 2;\\n        int s = t-1;\\n        t += s;\\n        vector<vector<int> > segTree(t, vector<int>());\\n        for(int i = 0; i < nums1.size(); i++){\\n            segTree[s + i] = {i, i, nums1[i], 0};\\n        }\\n        for(int i = nums1.size(); i <= s; i++){\\n            segTree[i + s] = {i, i, 0, 0};\\n        }\\n        for(int i = s - 1; i >= 0; i--){\\n            segTree[i] = {segTree[2*i + 1][0], segTree[2*i + 2][1], segTree[2*i + 1][2] + segTree[2*i + 2][2], 0};\\n        }\\n        for(vector<int> x: queries){\\n            if(x[0] == 3) ans.push_back(sum);\\n            else if(x[0] == 2) {\\n                if(segTree[0][3] == 1){\\n                    sum += (long)x[1] * (nums1.size() - segTree[0][2]);\\n                }\\n                else{\\n                    sum += (long)x[1] * segTree[0][2];\\n                }\\n            }\\n            else {\\n                flip(segTree, x[1], x[2], 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nAlternatively, segTree solution where 3rd entry of any node keeps only the count of number of 1s in the subtree at that node(need to be careful, as it requires updation after every propogated flip to the subtree):\\nflip method again returns the same.\\n```\\nclass Solution {\\n    int flip(vector<vector<int> > &segTree, int i, int j, int c){\\n        if(j >= i) {\\n            if(segTree[c][0] == i && segTree[c][1] == j){\\n                segTree[c][3] ^= 1;\\n                segTree[c][2] = segTree[c][2] = segTree[c][1] - segTree[c][0] + 1 - segTree[c][2];\\n            }\\n            else{\\n                int l = flip(segTree, i, min(j, segTree[2*c + 1][1]), 2*c + 1);\\n                int r = flip(segTree, max(i, segTree[2*c + 2][0]), j, 2*c + 2);\\n                if(segTree[c][3] == 1) segTree[c][2] = segTree[c][1] - segTree[c][0] + 1 - (l + r);\\n                else segTree[c][2] = l + r;\\n            }\\n        }\\n        return segTree[c][2];\\n    }\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long> ans;\\n        long long sum = 0;\\n        for(int x: nums2) sum += x;\\n        int t = 1;\\n        while(t < nums1.size()) t *= 2;\\n        int s = t-1;\\n        t += s;\\n        vector<vector<int> > segTree(t, vector<int>());\\n        for(int i = 0; i < nums1.size(); i++){\\n            segTree[s + i] = {i, i, nums1[i], 0};\\n        }\\n        for(int i = nums1.size(); i <= s; i++){\\n            segTree[i + s] = {i, i, 0, 0};\\n        }\\n        for(int i = s - 1; i >= 0; i--){\\n            segTree[i] = {segTree[2*i + 1][0], segTree[2*i + 2][1], segTree[2*i + 1][2] + segTree[2*i + 2][2], 0};\\n        }\\n        for(vector<int> x: queries){\\n            if(x[0] == 3) ans.push_back(sum);\\n            else if(x[0] == 2) {\\n                sum += (long)x[1] * segTree[0][2];\\n            }\\n            else {\\n                flip(segTree, x[1], x[2], 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int flip(vector<vector<int> > &segTree, int i, int j, int c){\\n        if(j >= i) {\\n            if(segTree[c][0] == i && segTree[c][1] == j){\\n                segTree[c][3] ^= 1;\\n            }\\n            else{\\n                int l = flip(segTree, i, min(j, segTree[2*c + 1][1]), 2*c + 1);\\n                int r = flip(segTree, max(i, segTree[2*c + 2][0]), j, 2*c + 2);\\n                segTree[c][2] = l + r;\\n            }\\n        }\\n        if(segTree[c][3] == 1){\\n            return segTree[c][1] - segTree[c][0] + 1 - segTree[c][2];\\n        }\\n        return segTree[c][2];\\n    }\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long> ans;\\n        long long sum = 0;\\n        for(int x: nums2) sum += x;\\n        int t = 1;\\n        while(t < nums1.size()) t *= 2;\\n        int s = t-1;\\n        t += s;\\n        vector<vector<int> > segTree(t, vector<int>());\\n        for(int i = 0; i < nums1.size(); i++){\\n            segTree[s + i] = {i, i, nums1[i], 0};\\n        }\\n        for(int i = nums1.size(); i <= s; i++){\\n            segTree[i + s] = {i, i, 0, 0};\\n        }\\n        for(int i = s - 1; i >= 0; i--){\\n            segTree[i] = {segTree[2*i + 1][0], segTree[2*i + 2][1], segTree[2*i + 1][2] + segTree[2*i + 2][2], 0};\\n        }\\n        for(vector<int> x: queries){\\n            if(x[0] == 3) ans.push_back(sum);\\n            else if(x[0] == 2) {\\n                if(segTree[0][3] == 1){\\n                    sum += (long)x[1] * (nums1.size() - segTree[0][2]);\\n                }\\n                else{\\n                    sum += (long)x[1] * segTree[0][2];\\n                }\\n            }\\n            else {\\n                flip(segTree, x[1], x[2], 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int flip(vector<vector<int> > &segTree, int i, int j, int c){\\n        if(j >= i) {\\n            if(segTree[c][0] == i && segTree[c][1] == j){\\n                segTree[c][3] ^= 1;\\n                segTree[c][2] = segTree[c][2] = segTree[c][1] - segTree[c][0] + 1 - segTree[c][2];\\n            }\\n            else{\\n                int l = flip(segTree, i, min(j, segTree[2*c + 1][1]), 2*c + 1);\\n                int r = flip(segTree, max(i, segTree[2*c + 2][0]), j, 2*c + 2);\\n                if(segTree[c][3] == 1) segTree[c][2] = segTree[c][1] - segTree[c][0] + 1 - (l + r);\\n                else segTree[c][2] = l + r;\\n            }\\n        }\\n        return segTree[c][2];\\n    }\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<long long> ans;\\n        long long sum = 0;\\n        for(int x: nums2) sum += x;\\n        int t = 1;\\n        while(t < nums1.size()) t *= 2;\\n        int s = t-1;\\n        t += s;\\n        vector<vector<int> > segTree(t, vector<int>());\\n        for(int i = 0; i < nums1.size(); i++){\\n            segTree[s + i] = {i, i, nums1[i], 0};\\n        }\\n        for(int i = nums1.size(); i <= s; i++){\\n            segTree[i + s] = {i, i, 0, 0};\\n        }\\n        for(int i = s - 1; i >= 0; i--){\\n            segTree[i] = {segTree[2*i + 1][0], segTree[2*i + 2][1], segTree[2*i + 1][2] + segTree[2*i + 2][2], 0};\\n        }\\n        for(vector<int> x: queries){\\n            if(x[0] == 3) ans.push_back(sum);\\n            else if(x[0] == 2) {\\n                sum += (long)x[1] * segTree[0][2];\\n            }\\n            else {\\n                flip(segTree, x[1], x[2], 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327643,
                "title": "segment-tree-with-lazy-propagation",
                "content": "# Intuition\\r\\nWe do not need to maintain the array nums2 we can only maintain its sume beforehand and update its sum on each query. Nums2 update only when query of type 2 occurs. We can calculate the updated sum of nums2 if we know how much 1s are present in array nums1 as 2nd operation is $$nums2[i]=nums2[i]+nums1[i]*p$$. So we just need to add the number of 1s*p to the sum of nums2 to get the updated sum.\\r\\n# Approach\\r\\nOur Updated problem is to maintain the number of 1s in nums1 we can use segment tree with lazy propagation as with this the update in given range can be done optimally .\\r\\nIf want to read more about lazy propagation on segment tree - https://www.geeksforgeeks.org/queries-to-calculate-sum-of-squares-of-array-elements-over-range-of-indices-l-r-with-updates\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(nlogn)$$\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\n#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\ntypedef long long ll;\\r\\ntypedef long double lld;\\r\\ntypedef pair<int, int> pii;\\r\\ntypedef vector<int> vi;\\r\\ntypedef vector<ll> vll;\\r\\ntypedef pair<ll, ll> pll;\\r\\n#define mod 1000000007\\r\\n#define inf LLONG_MAX\\r\\n#define neg_inf LLONG_MIN\\r\\n#define all(x) x.begin(), x.end()\\r\\n#define allrev(x) x.rbegin(), x.rend()\\r\\n#define loop(i, x, n) for (long long i = x; i <= n; i++)\\r\\n#define rloop(i, n, x) for (long long i = n; i >= x; i--)\\r\\n#define sz(x) (ll) x.size()\\r\\n#define pb push_back\\r\\n#define ppb pop_back\\r\\n#define mkp make_pair\\r\\n#define ff first\\r\\n#define ss second\\r\\n#define set_bits __builtin_popcountll\\r\\n// vector<vector<int>>vec(n ,vector<int>(n, 0));\\r\\nclass Solution {\\r\\npublic:\\r\\n    void createtree(vi&nums,ll*tree,ll left,ll right,ll treeind){\\r\\n        if(left==right){\\r\\n            tree[treeind]=nums[left];\\r\\n            return ;\\r\\n        }\\r\\n        ll mid=(left+right)/2ll;\\r\\n        createtree(nums,tree,left,mid,2ll*treeind+1);\\r\\n        createtree(nums,tree,mid+1,right,2ll*treeind+2);\\r\\n        tree[treeind]=tree[2ll*treeind+1]+tree[2ll*treeind+2];\\r\\n    }\\r\\n    void updatetree(ll*tree,ll*lazytree,ll left,ll right,ll low,ll high,ll treeind){\\r\\n        // first check if any lazytree update is pendin\\r\\n        if((lazytree[treeind]%2!=0)){\\r\\n            ll times=tree[treeind];\\r\\n            ll ele=right-left+1;\\r\\n            tree[treeind]=ele-times;\\r\\n            lazytree[2ll*treeind+1]++;\\r\\n            lazytree[2ll*treeind+2]++;\\r\\n        }\\r\\n        lazytree[treeind]=0;\\r\\n        // if come outside\\r\\n        if(right<low || left>high){\\r\\n            return;\\r\\n        }\\r\\n        // if comp cover\\r\\n        if(left>=low && right<=high){\\r\\n            ll times=tree[treeind];\\r\\n            ll ele=right-left+1;\\r\\n            tree[treeind]=ele-times;\\r\\n            lazytree[2ll*treeind+1]++;\\r\\n            lazytree[2ll*treeind+2]++;\\r\\n            return;\\r\\n        }\\r\\n        ll mid=(left+right)/2ll;\\r\\n        updatetree(tree,lazytree,left,mid,low,high,2ll*treeind+1);\\r\\n        updatetree(tree,lazytree,mid+1,right,low,high,2ll*treeind+2);\\r\\n        tree[treeind]=tree[2ll*treeind+1]+tree[2ll*treeind+2];\\r\\n    }\\r\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\r\\n        vll ans;\\r\\n        ll sum=0;\\r\\n        for(auto it:nums2){\\r\\n            sum+=it;\\r\\n        }\\r\\n        ll sz=sz(nums1);\\r\\n        ll treesz=10ll*sz;\\r\\n        ll *tree=new ll[treesz+1];\\r\\n        ll *lazytree=new ll[treesz+1];\\r\\n        loop(i,0,treesz){\\r\\n            lazytree[i]=tree[i]=0;\\r\\n        }\\r\\n        createtree(nums1,tree,0,sz-1,0);\\r\\n        for(auto query:queries){\\r\\n            ll type=query[0];\\r\\n            ll l=query[1];\\r\\n            ll r=query[2];\\r\\n            if(type==1){\\r\\n                updatetree(tree,lazytree,0,sz-1,l,r,0);\\r\\n            }else if(type==2){\\r\\n                ll times=tree[0];\\r\\n                times*=l;\\r\\n                sum+=times;\\r\\n            }else{\\r\\n                ans.pb(sum);\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\r\\n#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\ntypedef long long ll;\\r\\ntypedef long double lld;\\r\\ntypedef pair<int, int> pii;\\r\\ntypedef vector<int> vi;\\r\\ntypedef vector<ll> vll;\\r\\ntypedef pair<ll, ll> pll;\\r\\n#define mod 1000000007\\r\\n#define inf LLONG_MAX\\r\\n#define neg_inf LLONG_MIN\\r\\n#define all(x) x.begin(), x.end()\\r\\n#define allrev(x) x.rbegin(), x.rend()\\r\\n#define loop(i, x, n) for (long long i = x; i <= n; i++)\\r\\n#define rloop(i, n, x) for (long long i = n; i >= x; i--)\\r\\n#define sz(x) (ll) x.size()\\r\\n#define pb push_back\\r\\n#define ppb pop_back\\r\\n#define mkp make_pair\\r\\n#define ff first\\r\\n#define ss second\\r\\n#define set_bits __builtin_popcountll\\r\\n// vector<vector<int>>vec(n ,vector<int>(n, 0));\\r\\nclass Solution {\\r\\npublic:\\r\\n    void createtree(vi&nums,ll*tree,ll left,ll right,ll treeind){\\r\\n        if(left==right){\\r\\n            tree[treeind]=nums[left];\\r\\n            return ;\\r\\n        }\\r\\n        ll mid=(left+right)/2ll;\\r\\n        createtree(nums,tree,left,mid,2ll*treeind+1);\\r\\n        createtree(nums,tree,mid+1,right,2ll*treeind+2);\\r\\n        tree[treeind]=tree[2ll*treeind+1]+tree[2ll*treeind+2];\\r\\n    }\\r\\n    void updatetree(ll*tree,ll*lazytree,ll left,ll right,ll low,ll high,ll treeind){\\r\\n        // first check if any lazytree update is pendin\\r\\n        if((lazytree[treeind]%2!=0)){\\r\\n            ll times=tree[treeind];\\r\\n            ll ele=right-left+1;\\r\\n            tree[treeind]=ele-times;\\r\\n            lazytree[2ll*treeind+1]++;\\r\\n            lazytree[2ll*treeind+2]++;\\r\\n        }\\r\\n        lazytree[treeind]=0;\\r\\n        // if come outside\\r\\n        if(right<low || left>high){\\r\\n            return;\\r\\n        }\\r\\n        // if comp cover\\r\\n        if(left>=low && right<=high){\\r\\n            ll times=tree[treeind];\\r\\n            ll ele=right-left+1;\\r\\n            tree[treeind]=ele-times;\\r\\n            lazytree[2ll*treeind+1]++;\\r\\n            lazytree[2ll*treeind+2]++;\\r\\n            return;\\r\\n        }\\r\\n        ll mid=(left+right)/2ll;\\r\\n        updatetree(tree,lazytree,left,mid,low,high,2ll*treeind+1);\\r\\n        updatetree(tree,lazytree,mid+1,right,low,high,2ll*treeind+2);\\r\\n        tree[treeind]=tree[2ll*treeind+1]+tree[2ll*treeind+2];\\r\\n    }\\r\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\r\\n        vll ans;\\r\\n        ll sum=0;\\r\\n        for(auto it:nums2){\\r\\n            sum+=it;\\r\\n        }\\r\\n        ll sz=sz(nums1);\\r\\n        ll treesz=10ll*sz;\\r\\n        ll *tree=new ll[treesz+1];\\r\\n        ll *lazytree=new ll[treesz+1];\\r\\n        loop(i,0,treesz){\\r\\n            lazytree[i]=tree[i]=0;\\r\\n        }\\r\\n        createtree(nums1,tree,0,sz-1,0);\\r\\n        for(auto query:queries){\\r\\n            ll type=query[0];\\r\\n            ll l=query[1];\\r\\n            ll r=query[2];\\r\\n            if(type==1){\\r\\n                updatetree(tree,lazytree,0,sz-1,l,r,0);\\r\\n            }else if(type==2){\\r\\n                ll times=tree[0];\\r\\n                times*=l;\\r\\n                sum+=times;\\r\\n            }else{\\r\\n                ans.pb(sum);\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3275245,
                "title": "c-lazy-propagation-segment-tree-o-nlogn-handling-sum-queries-after-update",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nstruct Node{\\n\\tint sum,lazy;\\n\\tNode(){\\n\\t\\tsum = 0, lazy =0;\\n\\t}\\n};\\n\\nNode t[4*100100];\\nint arr[100100];\\n\\nNode merge(Node a, Node b){\\n\\tNode ans;\\n\\tans.sum = a.sum+b.sum;\\n\\treturn ans;\\n}\\n\\nvoid push(int id, int l, int r){\\n\\tif(!t[id].lazy) return;\\n\\tif(t[id].lazy){\\n\\t\\tt[id].sum = (r-l+1)-t[id].sum;\\n\\t\\tif(l!=r){\\n\\t\\t\\tt[id<<1].lazy = 1-t[id<<1].lazy;\\n\\t\\t\\tt[id<<1|1].lazy=1-t[id<<1|1].lazy;\\n\\t\\t}\\n\\t\\tt[id].lazy = 0;\\n\\t}\\n}\\n\\nvoid updateP(int id, int l, int r, int idx, int val){\\n\\tif(l>r || l>idx || r<idx) return;\\n\\tif(l==r){\\n\\t\\tt[id].sum=val;\\n\\t\\tt[id].lazy=0;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l+r)>>1;\\n\\tupdateP(id<<1,l,mid,idx,val);\\n\\tupdateP(id<<1|1,mid+1,r,idx,val);\\n\\tt[id]=merge(t[id<<1],t[id<<1|1]);\\n}\\n\\nvoid updateR(int id, int l, int r, int lq, int rq){\\n\\tpush(id,l,r);\\n\\tif(lq>r || rq<l){\\n\\t\\treturn;\\n\\t}\\n\\tif(lq<=l && r<=rq){\\n\\t\\tt[id].lazy = 1;\\n\\t\\tpush(id,l,r);\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l+r)>>1;\\n\\tupdateR(id<<1,l,mid,lq,rq);\\n\\tupdateR(id<<1|1,mid+1,r,lq,rq);\\n\\tt[id]=merge(t[id<<1],t[id<<1|1]);\\n\\n}\\n\\nNode query(int id, int l, int r, int lq, int rq){\\n\\tpush(id,l,r);\\n\\tif(lq>r || rq<l) return Node();\\n\\tif(lq<=l && r<=rq){\\n\\t\\treturn t[id];\\n\\t}\\n\\tint mid = (l+r)>>1;\\n\\treturn merge(query(id<<1,l,mid,lq,rq),query(id<<1|1,mid+1,r,lq,rq));\\n}\\n\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        long long sum = 0;\\n        for(auto x: nums2){\\n            sum += x;\\n        }\\n        for(int i=0; i<n; i++){\\n            updateP(1,0,n-1,i,nums1[i]);\\n        }\\n        vector<long long> ans;\\n        for(auto x: queries){\\n            if(x[0]==1){\\n                updateR(1,0,n-1,x[1],x[2]);\\n            }else if(x[0]==2){\\n                Node t = query(1,0,n-1,0,n-1);\\n                sum += (1LL*t.sum*x[1]);\\n            }else{\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nstruct Node{\\n\\tint sum,lazy;\\n\\tNode(){\\n\\t\\tsum = 0, lazy =0;\\n\\t}\\n};\\n\\nNode t[4*100100];\\nint arr[100100];\\n\\nNode merge(Node a, Node b){\\n\\tNode ans;\\n\\tans.sum = a.sum+b.sum;\\n\\treturn ans;\\n}\\n\\nvoid push(int id, int l, int r){\\n\\tif(!t[id].lazy) return;\\n\\tif(t[id].lazy){\\n\\t\\tt[id].sum = (r-l+1)-t[id].sum;\\n\\t\\tif(l!=r){\\n\\t\\t\\tt[id<<1].lazy = 1-t[id<<1].lazy;\\n\\t\\t\\tt[id<<1|1].lazy=1-t[id<<1|1].lazy;\\n\\t\\t}\\n\\t\\tt[id].lazy = 0;\\n\\t}\\n}\\n\\nvoid updateP(int id, int l, int r, int idx, int val){\\n\\tif(l>r || l>idx || r<idx) return;\\n\\tif(l==r){\\n\\t\\tt[id].sum=val;\\n\\t\\tt[id].lazy=0;\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l+r)>>1;\\n\\tupdateP(id<<1,l,mid,idx,val);\\n\\tupdateP(id<<1|1,mid+1,r,idx,val);\\n\\tt[id]=merge(t[id<<1],t[id<<1|1]);\\n}\\n\\nvoid updateR(int id, int l, int r, int lq, int rq){\\n\\tpush(id,l,r);\\n\\tif(lq>r || rq<l){\\n\\t\\treturn;\\n\\t}\\n\\tif(lq<=l && r<=rq){\\n\\t\\tt[id].lazy = 1;\\n\\t\\tpush(id,l,r);\\n\\t\\treturn;\\n\\t}\\n\\tint mid = (l+r)>>1;\\n\\tupdateR(id<<1,l,mid,lq,rq);\\n\\tupdateR(id<<1|1,mid+1,r,lq,rq);\\n\\tt[id]=merge(t[id<<1],t[id<<1|1]);\\n\\n}\\n\\nNode query(int id, int l, int r, int lq, int rq){\\n\\tpush(id,l,r);\\n\\tif(lq>r || rq<l) return Node();\\n\\tif(lq<=l && r<=rq){\\n\\t\\treturn t[id];\\n\\t}\\n\\tint mid = (l+r)>>1;\\n\\treturn merge(query(id<<1,l,mid,lq,rq),query(id<<1|1,mid+1,r,lq,rq));\\n}\\n\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        long long sum = 0;\\n        for(auto x: nums2){\\n            sum += x;\\n        }\\n        for(int i=0; i<n; i++){\\n            updateP(1,0,n-1,i,nums1[i]);\\n        }\\n        vector<long long> ans;\\n        for(auto x: queries){\\n            if(x[0]==1){\\n                updateR(1,0,n-1,x[1],x[2]);\\n            }else if(x[0]==2){\\n                Node t = query(1,0,n-1,0,n-1);\\n                sum += (1LL*t.sum*x[1]);\\n            }else{\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254110,
                "title": "c-segment-tree-lazytag",
                "content": "```\\nusing ll = long long;\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\n#define pb push_back\\n#define ve vector\\n\\nvector<int> a, b;\\n\\nconst int N = 2e5 + 10;\\nstruct Node {\\n    int l, r;\\n    int sum = 0;\\n    int setTo = 0; \\n} tr[N * 4];\\n\\nvoid build(int id) {\\n    int l = tr[id].l, r = tr[id].r;\\n    if(l == r) {\\n        tr[id].sum = a[l];\\n        return;\\n    }\\n    int mid = l + (r - l) / 2;\\n    int left = id * 2 + 1, right = id * 2 + 2;\\n    tr[left] = {l, mid, 0, 0};\\n    tr[right] = {mid + 1, r, 0, 0};\\n    build(left);\\n    build(right);\\n    tr[id].sum = tr[left].sum + tr[right].sum;\\n}\\n\\nvoid update(int id, int s, int e, int val) { \\n    int l = tr[id].l, r = tr[id].r;\\n    if(l == s && r == e) {\\n        tr[id].setTo ^= val;\\n        tr[id].sum = (r - l + 1) - tr[id].sum;\\n        return;\\n    }\\n\\n    int mid = l + (r - l) / 2;\\n    int left = id * 2 + 1, right = id * 2 + 2;\\n\\n    if(tr[id].setTo != 0) {\\n        update(left, tr[left].l, tr[left].r, tr[id].setTo);\\n        update(right, tr[right].l, tr[right].r, tr[id].setTo);\\n        tr[id].setTo = 0;\\n    }\\n\\n    if(e <= mid) {\\n        update(left, s, e, val);\\n    } else if(s >= mid + 1) {\\n        update(right, s, e, val);\\n    } else {\\n        update(left, s, mid, val);\\n        update(right, mid + 1, e, val);\\n    }\\n    tr[id].sum = tr[left].sum + tr[right].sum;\\n}\\n\\nint query(int id, int s, int e) {\\n    int l = tr[id].l, r = tr[id].r;\\n    if(l == s && r == e){\\n        return tr[id].sum;\\n    }\\n    int mid = l + (r - l) / 2;\\n    int left = id * 2 + 1, right = id * 2 + 2;\\n    if(tr[id].setTo != 0) {\\n        update(left, tr[left].l, tr[left].r, tr[id].setTo);\\n        update(right, tr[right].l, tr[right].r, tr[id].setTo);\\n        tr[id].setTo = 0;\\n    }\\n    if(e <= mid){\\n        return query(left, s, e);\\n    } else if(s >= mid + 1) {\\n        return query(right, s, e);\\n    } else {\\n        return query(left, s, mid) + query(right, mid + 1, e);\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<ll> res;\\n        a = nums1;\\n        b = nums2;\\n        int n = a.size();\\n\\n        tr[0] = {0, n - 1, 0, 0};\\n        build(0);\\n        \\n        ll tot = 0;\\n        for(int i : b) {\\n            tot += i;\\n        }\\n        \\n        for(vector<int>& q : queries) {\\n            int ty = q[0];\\n            if(ty == 1) {\\n                int l = q[1], r = q[2];\\n                update(0, l, r, 1);\\n            } else if(ty == 2) {\\n                int p = q[1];\\n                int all = query(0, 0, n - 1);\\n                tot = tot + (all + 0ll) * p;\\n            } else {\\n                res.push_back(tot);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = long long;\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\n#define pb push_back\\n#define ve vector\\n\\nvector<int> a, b;\\n\\nconst int N = 2e5 + 10;\\nstruct Node {\\n    int l, r;\\n    int sum = 0;\\n    int setTo = 0; \\n} tr[N * 4];\\n\\nvoid build(int id) {\\n    int l = tr[id].l, r = tr[id].r;\\n    if(l == r) {\\n        tr[id].sum = a[l];\\n        return;\\n    }\\n    int mid = l + (r - l) / 2;\\n    int left = id * 2 + 1, right = id * 2 + 2;\\n    tr[left] = {l, mid, 0, 0};\\n    tr[right] = {mid + 1, r, 0, 0};\\n    build(left);\\n    build(right);\\n    tr[id].sum = tr[left].sum + tr[right].sum;\\n}\\n\\nvoid update(int id, int s, int e, int val) { \\n    int l = tr[id].l, r = tr[id].r;\\n    if(l == s && r == e) {\\n        tr[id].setTo ^= val;\\n        tr[id].sum = (r - l + 1) - tr[id].sum;\\n        return;\\n    }\\n\\n    int mid = l + (r - l) / 2;\\n    int left = id * 2 + 1, right = id * 2 + 2;\\n\\n    if(tr[id].setTo != 0) {\\n        update(left, tr[left].l, tr[left].r, tr[id].setTo);\\n        update(right, tr[right].l, tr[right].r, tr[id].setTo);\\n        tr[id].setTo = 0;\\n    }\\n\\n    if(e <= mid) {\\n        update(left, s, e, val);\\n    } else if(s >= mid + 1) {\\n        update(right, s, e, val);\\n    } else {\\n        update(left, s, mid, val);\\n        update(right, mid + 1, e, val);\\n    }\\n    tr[id].sum = tr[left].sum + tr[right].sum;\\n}\\n\\nint query(int id, int s, int e) {\\n    int l = tr[id].l, r = tr[id].r;\\n    if(l == s && r == e){\\n        return tr[id].sum;\\n    }\\n    int mid = l + (r - l) / 2;\\n    int left = id * 2 + 1, right = id * 2 + 2;\\n    if(tr[id].setTo != 0) {\\n        update(left, tr[left].l, tr[left].r, tr[id].setTo);\\n        update(right, tr[right].l, tr[right].r, tr[id].setTo);\\n        tr[id].setTo = 0;\\n    }\\n    if(e <= mid){\\n        return query(left, s, e);\\n    } else if(s >= mid + 1) {\\n        return query(right, s, e);\\n    } else {\\n        return query(left, s, mid) + query(right, mid + 1, e);\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<ll> res;\\n        a = nums1;\\n        b = nums2;\\n        int n = a.size();\\n\\n        tr[0] = {0, n - 1, 0, 0};\\n        build(0);\\n        \\n        ll tot = 0;\\n        for(int i : b) {\\n            tot += i;\\n        }\\n        \\n        for(vector<int>& q : queries) {\\n            int ty = q[0];\\n            if(ty == 1) {\\n                int l = q[1], r = q[2];\\n                update(0, l, r, 1);\\n            } else if(ty == 2) {\\n                int p = q[1];\\n                int all = query(0, 0, n - 1);\\n                tot = tot + (all + 0ll) * p;\\n            } else {\\n                res.push_back(tot);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248323,
                "title": "one-of-the-most-understandable-solution",
                "content": "```\\nclass segTree\\n{\\n    vector<int> lazy, tree;\\n\\npublic:\\n    segTree(int n)\\n    {\\n\\n        lazy.assign(4 * n + 1, 0);\\n        tree.assign(4 * n + 1, 0);\\n    }\\n    int buildTree(vector<int> &arr, int node, int l, int r)\\n    {\\n        if (l == r)\\n        {\\n            return tree[node] = arr[l-1];\\n        }\\nreturn tree[node] = buildTree(arr, 2 * node, l, (l + r) / 2) + buildTree(arr, 2 * node + 1, (l + r) / 2 +1, r); \\n    }\\n    void update(int node, int st, int end, int l, int r)\\n    {\\n        if(lazy[node]){\\n            tree[node]=(end-st+1)-tree[node];\\n            if(st!=end){\\n                lazy[2*node]^=1;\\n                lazy[2*node+1]^=1;\\n            }\\n            lazy[node]=0;\\n        }\\n        if (st > r || end < l)return;\\n        if (st >= l && end <= r){\\n             tree[node]=(end-st+1)-tree[node];\\n            if(st!=end){\\n            lazy[2*node]^=1;\\n            lazy[2*node+1]^=1;\\n            }\\n             return;\\n        }\\n        update(2*node,st,(st+end)/2,l,r);\\n        update(2*node+1,(st+end)/2+1,end,l,r);\\n        tree[node]=tree[2*node]+tree[2*node+1];\\n    }\\n    int query(int node, int st, int end, int l, int r)\\n    {\\n        if (lazy[node] != 0)\\n        {\\n            tree[node] = (end - st + 1)-tree[node];\\n            if (st != end)\\n            {\\n                lazy[2 * node]^=1;\\n                lazy[2 * node + 1]^=1;\\n            }\\n            lazy[node] = 0;\\n        }\\n        if (st > r || end < l)\\n            return 0;\\n        if (st >= l && end <= r)\\n        {\\n\\n            return tree[node];\\n        }\\n        int mid = (l + r) >> 1;\\n        return query(2 * node, st, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);\\n    }\\n};\\n#define ll long long int\\nclass Solution {\\n   \\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        ll sum=0;\\n        vector<ll> ans;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++ )sum+=nums2[i];\\n        segTree lp(n);\\n       \\n         lp.buildTree(nums1,1,1,n);\\n        \\n         int q=queries.size();\\n         for(int i=0;i<q;i++){\\n            int a=queries[i][0];\\n            if(a==1){\\n                \\n                lp.update(1,1,n,queries[i][1]+1,queries[i][2]+1);\\n            }\\n            if(a==2){\\n                \\n               sum+=lp.query(1,1,n,1,n)*1LL*queries[i][1]; \\n            }\\n            if(a==3){\\n                ans.push_back(sum);\\n            }\\n        }\\n\\n      \\n        return ans;\\n    }\\n};********\\n```",
                "solutionTags": [
                    "Array",
                    "Tree"
                ],
                "code": "```\\nclass segTree\\n{\\n    vector<int> lazy, tree;\\n\\npublic:\\n    segTree(int n)\\n    {\\n\\n        lazy.assign(4 * n + 1, 0);\\n        tree.assign(4 * n + 1, 0);\\n    }\\n    int buildTree(vector<int> &arr, int node, int l, int r)\\n    {\\n        if (l == r)\\n        {\\n            return tree[node] = arr[l-1];\\n        }\\nreturn tree[node] = buildTree(arr, 2 * node, l, (l + r) / 2) + buildTree(arr, 2 * node + 1, (l + r) / 2 +1, r); \\n    }\\n    void update(int node, int st, int end, int l, int r)\\n    {\\n        if(lazy[node]){\\n            tree[node]=(end-st+1)-tree[node];\\n            if(st!=end){\\n                lazy[2*node]^=1;\\n                lazy[2*node+1]^=1;\\n            }\\n            lazy[node]=0;\\n        }\\n        if (st > r || end < l)return;\\n        if (st >= l && end <= r){\\n             tree[node]=(end-st+1)-tree[node];\\n            if(st!=end){\\n            lazy[2*node]^=1;\\n            lazy[2*node+1]^=1;\\n            }\\n             return;\\n        }\\n        update(2*node,st,(st+end)/2,l,r);\\n        update(2*node+1,(st+end)/2+1,end,l,r);\\n        tree[node]=tree[2*node]+tree[2*node+1];\\n    }\\n    int query(int node, int st, int end, int l, int r)\\n    {\\n        if (lazy[node] != 0)\\n        {\\n            tree[node] = (end - st + 1)-tree[node];\\n            if (st != end)\\n            {\\n                lazy[2 * node]^=1;\\n                lazy[2 * node + 1]^=1;\\n            }\\n            lazy[node] = 0;\\n        }\\n        if (st > r || end < l)\\n            return 0;\\n        if (st >= l && end <= r)\\n        {\\n\\n            return tree[node];\\n        }\\n        int mid = (l + r) >> 1;\\n        return query(2 * node, st, mid, l, r) + query(2 * node + 1, mid + 1, end, l, r);\\n    }\\n};\\n#define ll long long int\\nclass Solution {\\n   \\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        ll sum=0;\\n        vector<ll> ans;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++ )sum+=nums2[i];\\n        segTree lp(n);\\n       \\n         lp.buildTree(nums1,1,1,n);\\n        \\n         int q=queries.size();\\n         for(int i=0;i<q;i++){\\n            int a=queries[i][0];\\n            if(a==1){\\n                \\n                lp.update(1,1,n,queries[i][1]+1,queries[i][2]+1);\\n            }\\n            if(a==2){\\n                \\n               sum+=lp.query(1,1,n,1,n)*1LL*queries[i][1]; \\n            }\\n            if(a==3){\\n                ans.push_back(sum);\\n            }\\n        }\\n\\n      \\n        return ans;\\n    }\\n};********\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246830,
                "title": "python3-58-67-with-numpy",
                "content": "```python\\nimport numpy as np\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:            \\n        answers = []\\n        nums1 = np.array(nums1)\\n        total = np.sum(nums2)\\n        ones = np.sum(nums1)\\n        for query in queries:\\n            match query:\\n                case [1, l, r]:\\n                    ones += r-l+1-2*np.sum(nums1[l:r+1])\\n                    nums1[l:r+1] ^= 1\\n                case [2, p, 0]:\\n                    total += p * ones\\n                case [3, 0, 0]:\\n                    answers.append(total)\\n        return answers\\n```\\n\\nNumpy is fast enough to defeat the spirit of the question :)",
                "solutionTags": [],
                "code": "```python\\nimport numpy as np\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:            \\n        answers = []\\n        nums1 = np.array(nums1)\\n        total = np.sum(nums2)\\n        ones = np.sum(nums1)\\n        for query in queries:\\n            match query:\\n                case [1, l, r]:\\n                    ones += r-l+1-2*np.sum(nums1[l:r+1])\\n                    nums1[l:r+1] ^= 1\\n                case [2, p, 0]:\\n                    total += p * ones\\n                case [3, 0, 0]:\\n                    answers.append(total)\\n        return answers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245445,
                "title": "segmented-tree-lazy-propagation",
                "content": "```\\nstruct seg_tree {\\n    int n;\\n    vector<int> lazy;\\n    vector<int> tree;\\n    seg_tree(vector<int>& input) {\\n        this->n = input.size();\\n        this->tree = vector<int>(4 * n, 0);\\n        this->lazy = vector<int>(4 * n, 0);\\n        build(1, 0, n - 1, input);\\n    }\\n    \\n    void push(int index, int left, int right) {\\n        tree[index] = right - left + 1 - tree[index];\\n        if (left != right) {\\n            lazy[index * 2] = lazy[index * 2] == 1 ? 0 : 1;\\n            lazy[index * 2 + 1] = lazy[index * 2 + 1] == 1 ? 0 : 1;\\n        }\\n        lazy[index] = 0;\\n    }\\n    \\n    void build(int index, int left, int right, vector<int>& input) {\\n        if (left == right) {\\n            tree[index] = input[left];\\n        } else {\\n            int mid = (right - left) / 2 + left;\\n            build(index * 2, left, mid, input);\\n            build(index * 2 + 1, mid + 1, right, input);\\n            tree[index] = tree[index * 2] + tree[index * 2 + 1];\\n        }\\n    }\\n    \\n    void update(int index, int left, int right, int l, int r) {\\n        if (lazy[index]) push(index, left, right);\\n        if (l > r) return;\\n        if (left >= l && right <= r) {\\n            tree[index] = right - left + 1 - tree[index];\\n            if (left != right) { // not leaf node\\n                lazy[index * 2] = lazy[index * 2] == 1 ? 0 : 1;\\n                lazy[index * 2 + 1] = lazy[index * 2 + 1] == 1 ? 0 : 1;\\n            }\\n            return;\\n        }\\n        int mid = (right - left) / 2 + left;\\n        update(index * 2, left, mid, l, min(r, mid));\\n        update(index * 2 + 1, mid + 1, right, max(l, mid + 1), r);\\n        tree[index] = tree[index * 2] + tree[index * 2 + 1];\\n        \\n    }\\n    \\n    int query(int index, int left, int right, int l, int r) {\\n        if (lazy[index]) push(index, left, right);\\n        if (l > r) return 0;\\n        if (left == l && right == r) return tree[index];\\n        int mid = (right - left) / 2 + left;\\n        int a = query(index * 2, left, mid, l, min(r, mid)), b = query(index * 2 + 1, mid + 1, right, max(l, mid + 1), r);\\n        tree[index] = a + b;\\n        return tree[index];\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums2.size();\\n        ll a = accumulate(nums2.begin(), nums2.end(), 0LL);\\n        seg_tree st(nums1);\\n        vector<ll> ans;\\n        for (auto& q : queries) {\\n            if (q[0] == 1) {\\n                st.update(1, 0, n - 1, q[1], q[2]);\\n            } else if (q[0] == 2) {\\n                a += (0LL + st.query(1, 0, n - 1, 0, n - 1)) * q[1];\\n            } else {\\n                ans.push_back(a);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nstruct seg_tree {\\n    int n;\\n    vector<int> lazy;\\n    vector<int> tree;\\n    seg_tree(vector<int>& input) {\\n        this->n = input.size();\\n        this->tree = vector<int>(4 * n, 0);\\n        this->lazy = vector<int>(4 * n, 0);\\n        build(1, 0, n - 1, input);\\n    }\\n    \\n    void push(int index, int left, int right) {\\n        tree[index] = right - left + 1 - tree[index];\\n        if (left != right) {\\n            lazy[index * 2] = lazy[index * 2] == 1 ? 0 : 1;\\n            lazy[index * 2 + 1] = lazy[index * 2 + 1] == 1 ? 0 : 1;\\n        }\\n        lazy[index] = 0;\\n    }\\n    \\n    void build(int index, int left, int right, vector<int>& input) {\\n        if (left == right) {\\n            tree[index] = input[left];\\n        } else {\\n            int mid = (right - left) / 2 + left;\\n            build(index * 2, left, mid, input);\\n            build(index * 2 + 1, mid + 1, right, input);\\n            tree[index] = tree[index * 2] + tree[index * 2 + 1];\\n        }\\n    }\\n    \\n    void update(int index, int left, int right, int l, int r) {\\n        if (lazy[index]) push(index, left, right);\\n        if (l > r) return;\\n        if (left >= l && right <= r) {\\n            tree[index] = right - left + 1 - tree[index];\\n            if (left != right) { // not leaf node\\n                lazy[index * 2] = lazy[index * 2] == 1 ? 0 : 1;\\n                lazy[index * 2 + 1] = lazy[index * 2 + 1] == 1 ? 0 : 1;\\n            }\\n            return;\\n        }\\n        int mid = (right - left) / 2 + left;\\n        update(index * 2, left, mid, l, min(r, mid));\\n        update(index * 2 + 1, mid + 1, right, max(l, mid + 1), r);\\n        tree[index] = tree[index * 2] + tree[index * 2 + 1];\\n        \\n    }\\n    \\n    int query(int index, int left, int right, int l, int r) {\\n        if (lazy[index]) push(index, left, right);\\n        if (l > r) return 0;\\n        if (left == l && right == r) return tree[index];\\n        int mid = (right - left) / 2 + left;\\n        int a = query(index * 2, left, mid, l, min(r, mid)), b = query(index * 2 + 1, mid + 1, right, max(l, mid + 1), r);\\n        tree[index] = a + b;\\n        return tree[index];\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums2.size();\\n        ll a = accumulate(nums2.begin(), nums2.end(), 0LL);\\n        seg_tree st(nums1);\\n        vector<ll> ans;\\n        for (auto& q : queries) {\\n            if (q[0] == 1) {\\n                st.update(1, 0, n - 1, q[1], q[2]);\\n            } else if (q[0] == 2) {\\n                a += (0LL + st.query(1, 0, n - 1, 0, n - 1)) * q[1];\\n            } else {\\n                ans.push_back(a);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228881,
                "title": "bit-manipulation-bitset",
                "content": "```\\nconst int N = 1e5;\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<ll> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries)\\n    {\\n        vector<ll> ans;\\n        bitset<N> bset(0);\\n        ll sum = 0;\\n        bitset<N> binit(0);\\n        binit.flip();\\n        \\n        int n = nums2.size();\\n        for(int i=0; i<n;i++)\\n        {\\n            sum += nums2[i];\\n            if(nums1[i]==1)\\n                bset[i] = 1;\\n        }\\n        \\n        for(auto q : queries)\\n        {\\n            if(q[0]==1)\\n            {\\n                int size = q[2]-q[1]+1; //1\\n                bitset<N> btemp(binit<<size); //1 1 1<<1 --> 1 1 0\\n                btemp = ~btemp; // 0 0 1\\n                btemp <<= q[1]; // 0 1 0\\n                bset ^= btemp; // 101^010 = 1 1 1\\n            }\\n            else if(q[0]==2)\\n            {\\n                sum += q[1]*bset.count();// it will count number of ones present multiply by p ;\\n            }\\n            else\\n            {\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst int N = 1e5;\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<ll> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries)\\n    {\\n        vector<ll> ans;\\n        bitset<N> bset(0);\\n        ll sum = 0;\\n        bitset<N> binit(0);\\n        binit.flip();\\n        \\n        int n = nums2.size();\\n        for(int i=0; i<n;i++)\\n        {\\n            sum += nums2[i];\\n            if(nums1[i]==1)\\n                bset[i] = 1;\\n        }\\n        \\n        for(auto q : queries)\\n        {\\n            if(q[0]==1)\\n            {\\n                int size = q[2]-q[1]+1; //1\\n                bitset<N> btemp(binit<<size); //1 1 1<<1 --> 1 1 0\\n                btemp = ~btemp; // 0 0 1\\n                btemp <<= q[1]; // 0 1 0\\n                bset ^= btemp; // 101^010 = 1 1 1\\n            }\\n            else if(q[0]==2)\\n            {\\n                sum += q[1]*bset.count();// it will count number of ones present multiply by p ;\\n            }\\n            else\\n            {\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228410,
                "title": "c-lazy-segment-tree",
                "content": "# Observation\\n- This question is asking for `range-update` query this type of question get easily solved using `Lazy segment tree` if we go with normal segment tree it cost more time and we get *TLE* \\n- Reffer this video from **striver** (Nicely explained)\\n[https://youtu.be/rwXVCELcrqU]()\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(4*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<long long> seg;\\n    vector<long long> lazy;\\npublic:\\n    void update(int ind, int low, int high, int l, int r){\\n       if(lazy[ind]&1){\\n           seg[ind]=(high-low+1)-seg[ind];\\n            if(low!=high){\\n                lazy[2*ind+1]+=lazy[ind];\\n                lazy[2*ind+2]+=lazy[ind];\\n            }\\n            lazy[ind]=0;\\n       }\\n\\n        if(low>r || high<l || low>high){\\n            return;\\n        }\\n\\n        //fully overlapped\\n        if(low>=l && high<=r){\\n            seg[ind]=(high-low+1)-seg[ind];\\n            if(low!=high){\\n                lazy[2*ind+1]++;\\n                lazy[2*ind+2]++;\\n            }\\n            return;\\n        }\\n\\n        //partially overlapped\\n\\n        int mid=(low+high)>>1;\\n        update(2*ind+1,low,mid,l,r);\\n        update(2*ind+2,mid+1,high,l,r);\\n        seg[ind]=seg[2*ind+1]+seg[2*ind+2];\\n    }\\n\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n=nums1.size();\\n        seg.resize(4*n,0);\\n        lazy.resize(4*n,0);\\n        long long sum=0;\\n        vector<long long> ans;\\n\\n        for(int i=0;i<n;i++){\\n            sum+=nums2[i];\\n            if(nums1[i]==1){\\n                update(0,0,n-1,i,i);    //index, low, high, l, r\\n            }\\n        }\\n\\n        for(auto x:queries){\\n            int q=x[0];\\n            if(q==1){\\n                update(0,0,n-1,x[1],x[2]);\\n            }\\n            else if(q==2){\\n                sum=sum+seg[0]*x[1];\\n            }\\n            else{\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<long long> seg;\\n    vector<long long> lazy;\\npublic:\\n    void update(int ind, int low, int high, int l, int r){\\n       if(lazy[ind]&1){\\n           seg[ind]=(high-low+1)-seg[ind];\\n            if(low!=high){\\n                lazy[2*ind+1]+=lazy[ind];\\n                lazy[2*ind+2]+=lazy[ind];\\n            }\\n            lazy[ind]=0;\\n       }\\n\\n        if(low>r || high<l || low>high){\\n            return;\\n        }\\n\\n        //fully overlapped\\n        if(low>=l && high<=r){\\n            seg[ind]=(high-low+1)-seg[ind];\\n            if(low!=high){\\n                lazy[2*ind+1]++;\\n                lazy[2*ind+2]++;\\n            }\\n            return;\\n        }\\n\\n        //partially overlapped\\n\\n        int mid=(low+high)>>1;\\n        update(2*ind+1,low,mid,l,r);\\n        update(2*ind+2,mid+1,high,l,r);\\n        seg[ind]=seg[2*ind+1]+seg[2*ind+2];\\n    }\\n\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n=nums1.size();\\n        seg.resize(4*n,0);\\n        lazy.resize(4*n,0);\\n        long long sum=0;\\n        vector<long long> ans;\\n\\n        for(int i=0;i<n;i++){\\n            sum+=nums2[i];\\n            if(nums1[i]==1){\\n                update(0,0,n-1,i,i);    //index, low, high, l, r\\n            }\\n        }\\n\\n        for(auto x:queries){\\n            int q=x[0];\\n            if(q==1){\\n                update(0,0,n-1,x[1],x[2]);\\n            }\\n            else if(q==2){\\n                sum=sum+seg[0]*x[1];\\n            }\\n            else{\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228138,
                "title": "c-java",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        const int n = nums1.size(), size = sqrt(n + 1.), m = (n + size - 1) / size;\\n        vector<int> s(m);\\n        vector<bool> rev(m);\\n        vector<long long> r;\\n        long long total = 0, v = 0;\\n        for (int i = 0; i < n; ++i) {\\n            s[i / size] += nums1[i];\\n            total += nums1[i];\\n            v += nums2[i];\\n        }\\n        for (const auto & q : queries) {\\n            if (q[0] == 1) {\\n                int x = q[1], y = q[2];\\n                while (x % size && x <= y) {\\n                    const int id = x / size;\\n                    if (nums1[x] == 1) {\\n                        --s[id];\\n                        if (rev[id]) {\\n                            ++total;\\n                        } else {\\n                            --total;\\n                        }\\n                    } else {\\n                        ++s[id];\\n                        if (rev[id]) {\\n                            --total;\\n                        } else {\\n                            ++total;\\n                        }\\n                    }\\n                    nums1[x++] ^= 1;  \\n                }\\n                while (y - x >= size - 1) {\\n                    const int id = x / size;\\n                    total -= rev[id] ? (size - s[id]) : s[id];\\n                    x += size;\\n                    rev[id] = !rev[id];\\n                    total += rev[id] ? (size - s[id]) : s[id];\\n                }\\n                while (x <= y) {\\n                    const int id = x / size;\\n                    if (nums1[x] == 1) {\\n                        --s[id];\\n                        if (rev[id]) {\\n                            ++total;\\n                        } else {\\n                            --total;\\n                        }\\n                    } else {\\n                        ++s[id];\\n                        if (rev[id]) {\\n                            --total;\\n                        } else {\\n                            ++total;\\n                        }\\n                    }\\n                    nums1[x++] ^= 1;  \\n                    \\n                }\\n                \\n            } else if (q[0] == 2) {\\n                v += total * q[1];\\n                \\n            } else {\\n                r.push_back(v);\\n            }\\n            \\n        }\\n        return r;\\n        \\n    }\\n}; \\n```\\n# Java\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> results = new ArrayList<>();\\n        int n = nums1.length;\\n        BitSet bs = new BitSet(n);\\n        long sum = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            sum += 1L * nums2[i];\\n            if (nums1[i] == 1) {\\n                bs.set(i);\\n            }\\n        }\\n\\n        for (int[] query : queries) {\\n            int type = query[0];\\n\\n            if (type == 1) {\\n                bs.flip(query[1], query[2] + 1);\\n            } else if (type == 2) {\\n                sum += 1L * query[1] * bs.cardinality();\\n            } else {\\n                results.add(sum);\\n            }\\n        }\\n\\n        long[] ans = new long[results.size()];\\n        for (int i = 0; i < ans.length; i++) {\\n            ans[i] = results.get(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        const int n = nums1.size(), size = sqrt(n + 1.), m = (n + size - 1) / size;\\n        vector<int> s(m);\\n        vector<bool> rev(m);\\n        vector<long long> r;\\n        long long total = 0, v = 0;\\n        for (int i = 0; i < n; ++i) {\\n            s[i / size] += nums1[i];\\n            total += nums1[i];\\n            v += nums2[i];\\n        }\\n        for (const auto & q : queries) {\\n            if (q[0] == 1) {\\n                int x = q[1], y = q[2];\\n                while (x % size && x <= y) {\\n                    const int id = x / size;\\n                    if (nums1[x] == 1) {\\n                        --s[id];\\n                        if (rev[id]) {\\n                            ++total;\\n                        } else {\\n                            --total;\\n                        }\\n                    } else {\\n                        ++s[id];\\n                        if (rev[id]) {\\n                            --total;\\n                        } else {\\n                            ++total;\\n                        }\\n                    }\\n                    nums1[x++] ^= 1;  \\n                }\\n                while (y - x >= size - 1) {\\n                    const int id = x / size;\\n                    total -= rev[id] ? (size - s[id]) : s[id];\\n                    x += size;\\n                    rev[id] = !rev[id];\\n                    total += rev[id] ? (size - s[id]) : s[id];\\n                }\\n                while (x <= y) {\\n                    const int id = x / size;\\n                    if (nums1[x] == 1) {\\n                        --s[id];\\n                        if (rev[id]) {\\n                            ++total;\\n                        } else {\\n                            --total;\\n                        }\\n                    } else {\\n                        ++s[id];\\n                        if (rev[id]) {\\n                            --total;\\n                        } else {\\n                            ++total;\\n                        }\\n                    }\\n                    nums1[x++] ^= 1;  \\n                    \\n                }\\n                \\n            } else if (q[0] == 2) {\\n                v += total * q[1];\\n                \\n            } else {\\n                r.push_back(v);\\n            }\\n            \\n        }\\n        return r;\\n        \\n    }\\n}; \\n```\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> results = new ArrayList<>();\\n        int n = nums1.length;\\n        BitSet bs = new BitSet(n);\\n        long sum = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            sum += 1L * nums2[i];\\n            if (nums1[i] == 1) {\\n                bs.set(i);\\n            }\\n        }\\n\\n        for (int[] query : queries) {\\n            int type = query[0];\\n\\n            if (type == 1) {\\n                bs.flip(query[1], query[2] + 1);\\n            } else if (type == 2) {\\n                sum += 1L * query[1] * bs.cardinality();\\n            } else {\\n                results.add(sum);\\n            }\\n        }\\n\\n        long[] ans = new long[results.size()];\\n        for (int i = 0; i < ans.length; i++) {\\n            ans[i] = results.get(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227273,
                "title": "antarnab-easy-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        Deque<Long> dq = new LinkedList();\\n        long sum = 0;\\n        for (int i : nums2) sum += i;\\n        Segment root = build(nums1, 0, nums1.length - 1);\\n        for (int[] q : queries) {\\n            if (1 == q[0]) root.flip(q[1], q[2]);\\n            else if (2 == q[0]) sum += root.sum * q[1];\\n            else dq.add(sum);\\n        }\\n        int n = dq.size(), i = 0;\\n        long[] res = new long[n];\\n        while (!dq.isEmpty()) res[i++] = dq.poll();\\n        return res;\\n    }\\n    class Segment {\\n        long sum;\\n        int f, lo, hi;\\n        Segment left, right;\\n        public Segment(int l, int r) {\\n            lo = l;\\n            hi = r;\\n        }\\n        public long flip(int l, int r) {\\n            if (hi < l || r < lo) return sum;            \\n            if (l <= lo && hi <= r) {        \\n                f ^= 1;\\n                return sum = hi - lo + 1 - sum;                \\n            }                      \\n            if (1 == f) {\\n                left.flip(lo, hi);\\n                right.flip(lo, hi);                                \\n                f ^= 1;\\n            }\\n            left.flip(l, r);\\n            right.flip(l, r);                \\n            return sum = left.sum + right.sum;\\n        }        \\n    }\\n    private Segment build(int[] nums, int l, int r) {\\n        if (l == r) {\\n            Segment node = new Segment(l, r);\\n            node.sum = nums[l];\\n            return node;\\n        }\\n        int mid = l + ((r - l) >> 1);\\n        Segment left = build(nums, l, mid), right = build(nums, mid + 1, r);\\n        Segment root = new Segment(l, r);\\n        root.left = left;\\n        root.right = right;\\n        root.sum = left.sum + right.sum;\\n        return root;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        Deque<Long> dq = new LinkedList();\\n        long sum = 0;\\n        for (int i : nums2) sum += i;\\n        Segment root = build(nums1, 0, nums1.length - 1);\\n        for (int[] q : queries) {\\n            if (1 == q[0]) root.flip(q[1], q[2]);\\n            else if (2 == q[0]) sum += root.sum * q[1];\\n            else dq.add(sum);\\n        }\\n        int n = dq.size(), i = 0;\\n        long[] res = new long[n];\\n        while (!dq.isEmpty()) res[i++] = dq.poll();\\n        return res;\\n    }\\n    class Segment {\\n        long sum;\\n        int f, lo, hi;\\n        Segment left, right;\\n        public Segment(int l, int r) {\\n            lo = l;\\n            hi = r;\\n        }\\n        public long flip(int l, int r) {\\n            if (hi < l || r < lo) return sum;            \\n            if (l <= lo && hi <= r) {        \\n                f ^= 1;\\n                return sum = hi - lo + 1 - sum;                \\n            }                      \\n            if (1 == f) {\\n                left.flip(lo, hi);\\n                right.flip(lo, hi);                                \\n                f ^= 1;\\n            }\\n            left.flip(l, r);\\n            right.flip(l, r);                \\n            return sum = left.sum + right.sum;\\n        }        \\n    }\\n    private Segment build(int[] nums, int l, int r) {\\n        if (l == r) {\\n            Segment node = new Segment(l, r);\\n            node.sum = nums[l];\\n            return node;\\n        }\\n        int mid = l + ((r - l) >> 1);\\n        Segment left = build(nums, l, mid), right = build(nums, mid + 1, r);\\n        Segment root = new Segment(l, r);\\n        root.left = left;\\n        root.right = right;\\n        root.sum = left.sum + right.sum;\\n        return root;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222974,
                "title": "a-generic-segment-tree-solution-good-for-practice",
                "content": "\\n\\n# Code\\n```\\nclass SegmentTree {\\nprivate:\\n    struct Node {\\n        int zerosCnt;\\n        int onesCnt;\\n\\n        Node operator + (Node& that) {\\n            return {zerosCnt + that.zerosCnt, onesCnt + that.onesCnt};\\n        }\\n\\n        void swapITimes(int i) {\\n            if (i % 2) swap(zerosCnt, onesCnt);\\n        }\\n    };\\n    vector<Node> tree;\\n    vector<int> lazy;\\n\\n    int maxSegmentSz;\\n\\n    void printTree() {\\n        cout << \"\\\\n\";\\n        for (Node& node : tree) cout<<\"{\"<<node.zerosCnt << \",\" << node.onesCnt << \"} \";\\n        cout << \"\\\\n\";\\n    }\\n\\n    int querySegment(int treeIdx, int treeLeft, int treeRight, int qLeft, int qRight) {\\n        // make it un-lazy\\n        if (lazy[treeIdx] != 0) {\\n            tree[treeIdx].swapITimes(lazy[treeIdx]);\\n\\n            if (treeLeft != treeRight) {\\n                lazy[2 * treeIdx + 1] += lazy[treeIdx];\\n                lazy[2 * treeIdx + 2] += lazy[treeIdx];\\n            }\\n\\n            lazy[treeIdx] = 0;\\n        }\\n\\n        // check if segment don\\'t overlap\\n        if (treeLeft > qRight || treeRight < qLeft) return 0;\\n\\n        // if segment completely overlap\\n        if (qLeft <= treeLeft && treeRight <= qRight) {\\n            return tree[treeIdx].onesCnt;\\n        }\\n\\n        int mid = treeLeft + (treeRight - treeLeft) / 2;\\n\\n        int QLeftResult = querySegment(2 * treeIdx + 1, treeLeft, mid, qLeft, qRight);\\n        int QRightResult = querySegment(2 * treeIdx + 2, mid + 1, treeRight, qLeft, qRight);\\n\\n        return QLeftResult + QRightResult;\\n    }\\n\\n    void updateSegment(int treeIdx, int treeLeft, int treeRight, int qLeft, int qRight) {\\n        // make it un-lazy\\n        if (lazy[treeIdx] != 0) {\\n            tree[treeIdx].swapITimes(lazy[treeIdx]);\\n\\n            if (treeLeft != treeRight) {\\n                lazy[2 * treeIdx + 1] += lazy[treeIdx];\\n                lazy[2 * treeIdx + 2] += lazy[treeIdx];\\n            }\\n\\n            lazy[treeIdx] = 0;\\n        }\\n\\n        // check if segment don\\'t overlap\\n        if (treeLeft > qRight || treeRight < qLeft) return;\\n\\n        // if segment completely overlap\\n        if (qLeft <= treeLeft && treeRight <= qRight) {\\n            tree[treeIdx].swapITimes(1);\\n\\n            if (treeLeft != treeRight) {\\n                lazy[2 * treeIdx + 1]++;\\n                lazy[2 * treeIdx + 2]++;\\n            }\\n\\n            return;\\n        }\\n\\n        int mid = treeLeft + (treeRight - treeLeft) / 2;\\n\\n        updateSegment(2 * treeIdx + 1, treeLeft, mid, qLeft, qRight);\\n        updateSegment(2 * treeIdx + 2, mid + 1, treeRight, qLeft, qRight);\\n\\n        tree[treeIdx] = tree[2 * treeIdx + 1] + tree[2 * treeIdx + 2];\\n    }\\n\\n    void buildTree(int treeIdx, int left, int right, vector<int>& nums) {\\n        if (left == right) {\\n            if (nums[left])\\n                tree[treeIdx] = {0, 1};\\n            else\\n                tree[treeIdx] = {1, 0};\\n\\n            return;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n\\n        buildTree(2 * treeIdx + 1, left, mid, nums);\\n        buildTree(2 * treeIdx + 2, mid + 1, right, nums);\\n\\n        tree[treeIdx] = tree[2 * treeIdx + 1] + tree[2 * treeIdx + 2];\\n    }\\npublic:\\n    SegmentTree (vector<int>& nums) {\\n        maxSegmentSz = nums.size();\\n\\n        tree.resize(maxSegmentSz * 4);\\n        lazy.resize(maxSegmentSz * 4);\\n\\n        buildTree(0, 0, maxSegmentSz - 1, nums);\\n\\n        // cout << \"\\\\nBuildFinish\"; printTree();\\n    }\\n\\n    void updateSegment(int qLeft, int qRight) {\\n        updateSegment(0, 0, maxSegmentSz - 1, qLeft, qRight);\\n        // cout << \"\\\\nupdateFinish\"; printTree();\\n    }\\n\\n    int querySegment(int qLeft, int qRight) {\\n        return querySegment(0, 0, maxSegmentSz - 1, qLeft, qRight);\\n        // cout << \"\\\\nQeuryFinish\"; printTree();\\n    }\\n};\\nclass Solution {\\nprivate:\\n    SegmentTree* segmentTree;\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        segmentTree = new SegmentTree(nums1);\\n\\n        int sz = nums1.size();\\n\\n        vector<long long> queryResults;\\n        long long currResult = 0;\\n\\n        for (int& num : nums2) currResult += num;\\n\\n        for (vector<int>& query : queries) {\\n            if (query[0] == 1) {\\n                segmentTree->updateSegment(query[1], query[2]);\\n            } else if (query[0] == 2) {\\n                currResult += ((long long)query[1]) * segmentTree->querySegment(0, sz-1);\\n            } else {\\n                queryResults.push_back(currResult);\\n            }\\n        }\\n\\n        return queryResults;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SegmentTree {\\nprivate:\\n    struct Node {\\n        int zerosCnt;\\n        int onesCnt;\\n\\n        Node operator + (Node& that) {\\n            return {zerosCnt + that.zerosCnt, onesCnt + that.onesCnt};\\n        }\\n\\n        void swapITimes(int i) {\\n            if (i % 2) swap(zerosCnt, onesCnt);\\n        }\\n    };\\n    vector<Node> tree;\\n    vector<int> lazy;\\n\\n    int maxSegmentSz;\\n\\n    void printTree() {\\n        cout << \"\\\\n\";\\n        for (Node& node : tree) cout<<\"{\"<<node.zerosCnt << \",\" << node.onesCnt << \"} \";\\n        cout << \"\\\\n\";\\n    }\\n\\n    int querySegment(int treeIdx, int treeLeft, int treeRight, int qLeft, int qRight) {\\n        // make it un-lazy\\n        if (lazy[treeIdx] != 0) {\\n            tree[treeIdx].swapITimes(lazy[treeIdx]);\\n\\n            if (treeLeft != treeRight) {\\n                lazy[2 * treeIdx + 1] += lazy[treeIdx];\\n                lazy[2 * treeIdx + 2] += lazy[treeIdx];\\n            }\\n\\n            lazy[treeIdx] = 0;\\n        }\\n\\n        // check if segment don\\'t overlap\\n        if (treeLeft > qRight || treeRight < qLeft) return 0;\\n\\n        // if segment completely overlap\\n        if (qLeft <= treeLeft && treeRight <= qRight) {\\n            return tree[treeIdx].onesCnt;\\n        }\\n\\n        int mid = treeLeft + (treeRight - treeLeft) / 2;\\n\\n        int QLeftResult = querySegment(2 * treeIdx + 1, treeLeft, mid, qLeft, qRight);\\n        int QRightResult = querySegment(2 * treeIdx + 2, mid + 1, treeRight, qLeft, qRight);\\n\\n        return QLeftResult + QRightResult;\\n    }\\n\\n    void updateSegment(int treeIdx, int treeLeft, int treeRight, int qLeft, int qRight) {\\n        // make it un-lazy\\n        if (lazy[treeIdx] != 0) {\\n            tree[treeIdx].swapITimes(lazy[treeIdx]);\\n\\n            if (treeLeft != treeRight) {\\n                lazy[2 * treeIdx + 1] += lazy[treeIdx];\\n                lazy[2 * treeIdx + 2] += lazy[treeIdx];\\n            }\\n\\n            lazy[treeIdx] = 0;\\n        }\\n\\n        // check if segment don\\'t overlap\\n        if (treeLeft > qRight || treeRight < qLeft) return;\\n\\n        // if segment completely overlap\\n        if (qLeft <= treeLeft && treeRight <= qRight) {\\n            tree[treeIdx].swapITimes(1);\\n\\n            if (treeLeft != treeRight) {\\n                lazy[2 * treeIdx + 1]++;\\n                lazy[2 * treeIdx + 2]++;\\n            }\\n\\n            return;\\n        }\\n\\n        int mid = treeLeft + (treeRight - treeLeft) / 2;\\n\\n        updateSegment(2 * treeIdx + 1, treeLeft, mid, qLeft, qRight);\\n        updateSegment(2 * treeIdx + 2, mid + 1, treeRight, qLeft, qRight);\\n\\n        tree[treeIdx] = tree[2 * treeIdx + 1] + tree[2 * treeIdx + 2];\\n    }\\n\\n    void buildTree(int treeIdx, int left, int right, vector<int>& nums) {\\n        if (left == right) {\\n            if (nums[left])\\n                tree[treeIdx] = {0, 1};\\n            else\\n                tree[treeIdx] = {1, 0};\\n\\n            return;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n\\n        buildTree(2 * treeIdx + 1, left, mid, nums);\\n        buildTree(2 * treeIdx + 2, mid + 1, right, nums);\\n\\n        tree[treeIdx] = tree[2 * treeIdx + 1] + tree[2 * treeIdx + 2];\\n    }\\npublic:\\n    SegmentTree (vector<int>& nums) {\\n        maxSegmentSz = nums.size();\\n\\n        tree.resize(maxSegmentSz * 4);\\n        lazy.resize(maxSegmentSz * 4);\\n\\n        buildTree(0, 0, maxSegmentSz - 1, nums);\\n\\n        // cout << \"\\\\nBuildFinish\"; printTree();\\n    }\\n\\n    void updateSegment(int qLeft, int qRight) {\\n        updateSegment(0, 0, maxSegmentSz - 1, qLeft, qRight);\\n        // cout << \"\\\\nupdateFinish\"; printTree();\\n    }\\n\\n    int querySegment(int qLeft, int qRight) {\\n        return querySegment(0, 0, maxSegmentSz - 1, qLeft, qRight);\\n        // cout << \"\\\\nQeuryFinish\"; printTree();\\n    }\\n};\\nclass Solution {\\nprivate:\\n    SegmentTree* segmentTree;\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        segmentTree = new SegmentTree(nums1);\\n\\n        int sz = nums1.size();\\n\\n        vector<long long> queryResults;\\n        long long currResult = 0;\\n\\n        for (int& num : nums2) currResult += num;\\n\\n        for (vector<int>& query : queries) {\\n            if (query[0] == 1) {\\n                segmentTree->updateSegment(query[1], query[2]);\\n            } else if (query[0] == 2) {\\n                currResult += ((long long)query[1]) * segmentTree->querySegment(0, sz-1);\\n            } else {\\n                queryResults.push_back(currResult);\\n            }\\n        }\\n\\n        return queryResults;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3222427,
                "title": "question-to-test-your-ability-in-writing-segment-tree-template",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen encountering a problem with range operations, we need to analyze the scope of each modification and query. We find that for num1, we need to perform range modification and sum query. For num2, we only need to return its sum. In this case, we can use a segment tree to maintain num1. As for num2, since it will not be modified in a range, only globally modified, we only need to record its sum. For each operation, we simply add the sum of num1 to the sum of num2. Because:\\n\\n\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u2211num1[i]+num2[i] = \\u2211num1[i]+\\u2211num2[i]\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTherefore, we only need to use a segment tree to maintain the range modification and sum query of num1[i], which is the range query. We can use a lazyTag segment tree to achieve this. However, there are some details to be handled: 1. The sum of the current node must be the number of \"1\"s in the represented range, and the number of \"0\"s in the range is naturally the range length minus the number of \"1\"s. When an update is required after a reversal, we only need to let tree.sum = tree.length - tree.sum, because the original 0s have become 1s, and the sum is naturally the number of 1s; 2. When updating lazyTag, if it is already equal to 1, there is no need to change it to 2, but rather change it to 0, because reversing twice is equivalent to no reversal at all.\\n\\n# Complexity\\n- Time complexity:O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n\\tvector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n\\t\\tbuild(0, nums1.size() - 1, 0, nums1);\\n\\t\\tvector<long long> ans;\\n\\n\\t\\tlong long sum = 0;\\n\\t\\tfor (int i : nums2) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\t\\tfor (vector<int> query : queries) {\\n\\t\\t\\tint a, b, c;\\n\\t\\t\\ta = query[0];\\n\\t\\t\\tb = query[1];\\n\\t\\t\\tc = query[2];\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tadd(0, b, c);\\n\\t\\t\\t}\\n\\t\\t\\telse if (a == 2) {\\n\\t\\t\\t\\tsum += (long long)find() * b;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans.push_back(sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\nprivate:\\n\\n\\tconst int N = 1e5 + 5;\\n\\tstruct node {\\n\\t\\tint leftRange, rightRange;\\n\\t\\tint sum, lazyTag;\\n\\t}tree[400010];\\n\\n\\tint left(int index) {\\n\\t\\treturn index * 2 + 1;\\n\\t}\\n\\n\\tint right(int index) {\\n\\t\\treturn index * 2 + 2;\\n\\t}\\n\\n\\tvoid build(int leftRange, int rightRange, int index, vector<int>& input) {\\n\\t\\ttree[index].sum = 0;\\n\\t\\ttree[index].leftRange = leftRange;\\n\\t\\ttree[index].rightRange = rightRange;\\n\\t\\tif (leftRange == rightRange) {\\n\\t\\t\\ttree[index].sum = input[leftRange];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = (leftRange + rightRange) >> 1;\\n\\t\\tbuild(leftRange, mid, left(index), input);\\n\\t\\tbuild(mid + 1, rightRange, right(index), input);\\n\\t\\ttree[index].sum = tree[left(index)].sum + tree[right(index)].sum;\\n\\t}\\n\\n\\tvoid pushDown(int index) {\\n\\t\\tif (!tree[index].lazyTag) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttree[left(index)].lazyTag = !tree[left(index)].lazyTag;\\n\\t\\ttree[right(index)].lazyTag = !tree[right(index)].lazyTag;\\n\\t\\ttree[left(index)].sum = (tree[left(index)].rightRange - tree[left(index)].leftRange + 1) - tree[left(index)].sum;\\n\\t\\ttree[right(index)].sum = (tree[right(index)].rightRange - tree[right(index)].leftRange + 1) - tree[right(index)].sum;\\n\\t\\ttree[index].lazyTag = 0;\\n\\t}\\n\\n\\tvoid add(int index, int leftRange, int rightRange) {\\n\\t\\tif (tree[index].leftRange >= leftRange && tree[index].rightRange <= rightRange) {\\n\\t\\t\\ttree[index].sum = tree[index].rightRange - tree[index].leftRange + 1 - tree[index].sum;\\n\\t\\t\\ttree[index].lazyTag = tree[index].lazyTag ? 0 : 1;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpushDown(index);\\n\\t\\tif (tree[left(index)].rightRange >= leftRange) {\\n\\t\\t\\tadd(left(index), leftRange, rightRange);\\n\\t\\t}\\n\\t\\tif (tree[right(index)].leftRange <= rightRange) {\\n\\t\\t\\tadd(right(index), leftRange, rightRange);\\n\\t\\t}\\n\\n\\t\\ttree[index].sum = tree[left(index)].sum + tree[right(index)].sum;\\n\\t}\\n\\n\\tint find() {\\n\\t\\treturn tree[0].sum;\\n\\t}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n\\tvector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n\\t\\tbuild(0, nums1.size() - 1, 0, nums1);\\n\\t\\tvector<long long> ans;\\n\\n\\t\\tlong long sum = 0;\\n\\t\\tfor (int i : nums2) {\\n\\t\\t\\tsum += i;\\n\\t\\t}\\n\\t\\tfor (vector<int> query : queries) {\\n\\t\\t\\tint a, b, c;\\n\\t\\t\\ta = query[0];\\n\\t\\t\\tb = query[1];\\n\\t\\t\\tc = query[2];\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tadd(0, b, c);\\n\\t\\t\\t}\\n\\t\\t\\telse if (a == 2) {\\n\\t\\t\\t\\tsum += (long long)find() * b;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans.push_back(sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\nprivate:\\n\\n\\tconst int N = 1e5 + 5;\\n\\tstruct node {\\n\\t\\tint leftRange, rightRange;\\n\\t\\tint sum, lazyTag;\\n\\t}tree[400010];\\n\\n\\tint left(int index) {\\n\\t\\treturn index * 2 + 1;\\n\\t}\\n\\n\\tint right(int index) {\\n\\t\\treturn index * 2 + 2;\\n\\t}\\n\\n\\tvoid build(int leftRange, int rightRange, int index, vector<int>& input) {\\n\\t\\ttree[index].sum = 0;\\n\\t\\ttree[index].leftRange = leftRange;\\n\\t\\ttree[index].rightRange = rightRange;\\n\\t\\tif (leftRange == rightRange) {\\n\\t\\t\\ttree[index].sum = input[leftRange];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = (leftRange + rightRange) >> 1;\\n\\t\\tbuild(leftRange, mid, left(index), input);\\n\\t\\tbuild(mid + 1, rightRange, right(index), input);\\n\\t\\ttree[index].sum = tree[left(index)].sum + tree[right(index)].sum;\\n\\t}\\n\\n\\tvoid pushDown(int index) {\\n\\t\\tif (!tree[index].lazyTag) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ttree[left(index)].lazyTag = !tree[left(index)].lazyTag;\\n\\t\\ttree[right(index)].lazyTag = !tree[right(index)].lazyTag;\\n\\t\\ttree[left(index)].sum = (tree[left(index)].rightRange - tree[left(index)].leftRange + 1) - tree[left(index)].sum;\\n\\t\\ttree[right(index)].sum = (tree[right(index)].rightRange - tree[right(index)].leftRange + 1) - tree[right(index)].sum;\\n\\t\\ttree[index].lazyTag = 0;\\n\\t}\\n\\n\\tvoid add(int index, int leftRange, int rightRange) {\\n\\t\\tif (tree[index].leftRange >= leftRange && tree[index].rightRange <= rightRange) {\\n\\t\\t\\ttree[index].sum = tree[index].rightRange - tree[index].leftRange + 1 - tree[index].sum;\\n\\t\\t\\ttree[index].lazyTag = tree[index].lazyTag ? 0 : 1;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpushDown(index);\\n\\t\\tif (tree[left(index)].rightRange >= leftRange) {\\n\\t\\t\\tadd(left(index), leftRange, rightRange);\\n\\t\\t}\\n\\t\\tif (tree[right(index)].leftRange <= rightRange) {\\n\\t\\t\\tadd(right(index), leftRange, rightRange);\\n\\t\\t}\\n\\n\\t\\ttree[index].sum = tree[left(index)].sum + tree[right(index)].sum;\\n\\t}\\n\\n\\tint find() {\\n\\t\\treturn tree[0].sum;\\n\\t}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222191,
                "title": "2569-handling-sum-queries-after-update-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain prevsum to calculate next sum. Use BitSet (as mask won\\'t be able to fit 2^10^5 this large number). \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulation \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn: length of nums1/nums2 array\\nq: number of queries\\nO(n)+O(q)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nx:number of times query type 3 is called.\\nO(x)+O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        int n=nums1.length;\\n        ArrayList<Long> list=new ArrayList<>();\\n        Long sum=0L;\\n        BitSet bs=new BitSet(n);\\n        for(int i=0;i<n;i++){\\n            sum+=1L*nums2[i];\\n            if(nums1[i]==1)bs.set(i);\\n        }\\n        for(int[] q:queries){\\n            if(q[0]==1){\\n                bs.flip(q[1],q[2]+1);\\n            }else if(q[0]==2){\\n                sum+=1L*q[1]*bs.cardinality();\\n            }else{\\n                list.add(sum);\\n            }\\n        }\\n        long[] ans=new long[list.size()];\\n        int i=0;\\n        for(long l:list){\\n            ans[i]=list.get(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        int n=nums1.length;\\n        ArrayList<Long> list=new ArrayList<>();\\n        Long sum=0L;\\n        BitSet bs=new BitSet(n);\\n        for(int i=0;i<n;i++){\\n            sum+=1L*nums2[i];\\n            if(nums1[i]==1)bs.set(i);\\n        }\\n        for(int[] q:queries){\\n            if(q[0]==1){\\n                bs.flip(q[1],q[2]+1);\\n            }else if(q[0]==2){\\n                sum+=1L*q[1]*bs.cardinality();\\n            }else{\\n                list.add(sum);\\n            }\\n        }\\n        long[] ans=new long[list.size()];\\n        int i=0;\\n        for(long l:list){\\n            ans[i]=list.get(i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221689,
                "title": "c-segment-tree-solution",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    static const ll maxn=1e5+6;\\n    ll seg[maxn<<2];\\n    bool lzy[maxn<<2];\\n    void seg_init(int cur,int l,int r,vector<int> &nums)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=nums[l];\\n            lzy[cur]=0;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        seg_init(cur<<1,l,mid,nums);\\n        seg_init(cur<<1|1,mid,r,nums);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n        lzy[cur]=0;\\n        return;\\n    }\\n    void pushdown(int cur,int l,int r)\\n    {\\n        if(lzy[cur])\\n        {\\n            lzy[cur]^=1;\\n            int mid=(l+r)>>1;\\n            lzy[cur<<1]^=1;\\n            lzy[cur<<1|1]^=1;\\n            seg[cur<<1]=mid-l-seg[cur<<1];\\n            seg[cur<<1|1]=r-mid-seg[cur<<1|1];\\n        }\\n        return;\\n    }\\n    void update(int cur,int l,int r,int tl,int tr)\\n    {\\n        if(tl>=r||tr<=l)return;\\n        if(tl<=l&&r<=tr)\\n        {\\n            seg[cur]=r-l-seg[cur];\\n            lzy[cur]^=1;\\n            return;\\n        }\\n        pushdown(cur,l,r);\\n        int mid=(l+r)>>1;\\n        update(cur<<1,l,mid,tl,tr);\\n        update(cur<<1|1,mid,r,tl,tr);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n        return;\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) \\n    {\\n        int n=nums1.size();\\n        seg_init(1,0,n,nums1);\\n        ll val=0;\\n        for(auto &x:nums2)val+=x;\\n        vector<ll>res;\\n        for(auto &x:queries)\\n        {\\n            if(x[0]==1)\\n            {\\n                update(1,0,n,x[1],x[2]+1);\\n            }else if(x[0]==2)\\n            {\\n                val+=seg[1]*x[1];\\n            }else res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    static const ll maxn=1e5+6;\\n    ll seg[maxn<<2];\\n    bool lzy[maxn<<2];\\n    void seg_init(int cur,int l,int r,vector<int> &nums)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=nums[l];\\n            lzy[cur]=0;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        seg_init(cur<<1,l,mid,nums);\\n        seg_init(cur<<1|1,mid,r,nums);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n        lzy[cur]=0;\\n        return;\\n    }\\n    void pushdown(int cur,int l,int r)\\n    {\\n        if(lzy[cur])\\n        {\\n            lzy[cur]^=1;\\n            int mid=(l+r)>>1;\\n            lzy[cur<<1]^=1;\\n            lzy[cur<<1|1]^=1;\\n            seg[cur<<1]=mid-l-seg[cur<<1];\\n            seg[cur<<1|1]=r-mid-seg[cur<<1|1];\\n        }\\n        return;\\n    }\\n    void update(int cur,int l,int r,int tl,int tr)\\n    {\\n        if(tl>=r||tr<=l)return;\\n        if(tl<=l&&r<=tr)\\n        {\\n            seg[cur]=r-l-seg[cur];\\n            lzy[cur]^=1;\\n            return;\\n        }\\n        pushdown(cur,l,r);\\n        int mid=(l+r)>>1;\\n        update(cur<<1,l,mid,tl,tr);\\n        update(cur<<1|1,mid,r,tl,tr);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n        return;\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) \\n    {\\n        int n=nums1.size();\\n        seg_init(1,0,n,nums1);\\n        ll val=0;\\n        for(auto &x:nums2)val+=x;\\n        vector<ll>res;\\n        for(auto &x:queries)\\n        {\\n            if(x[0]==1)\\n            {\\n                update(1,0,n,x[1],x[2]+1);\\n            }else if(x[0]==2)\\n            {\\n                val+=seg[1]*x[1];\\n            }else res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214077,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar handleQuery = function(nums1, nums2, queries) {\\n  const segmentTree = new SegmentTree(nums1, nums2);\\n\\n  return queries.reduce((answers, [type, a, b]) => {\\n    switch (type) {\\n      case 1:\\n        segmentTree.query1(a, b);\\n        return answers;\\n      case 2:\\n        segmentTree.query2(a);\\n        return answers;\\n      default:\\n        answers.push(segmentTree.query3());\\n        return answers;\\n    }\\n  }, []);\\n};\\n\\nclass SegmentTree {\\n  flipped = [];\\n  counts = [];\\n  max = 0;\\n  total = 0;\\n\\n  constructor(nums1, nums2) {\\n    this.max = nums1.length - 1;\\n    this.flipped = [...nums1, ...nums1].map(() => 0);\\n    this.counts = [...this.flipped];\\n    this.total = nums2.reduce((total, num) => total + num, 0);\\n    \\n    this.build(0, 0, nums1.length - 1, nums1);\\n  }\\n\\n  build(idx, min, max, nums) {\\n    if (min === max) {\\n\\t  // leaf\\n      this.counts[idx] = nums[min];\\n      return this.counts[idx];\\n    }\\n    \\n    const mid = min + max >> 1;\\n    \\n    const leftCount = this.build(idx * 2 + 1, min, mid, nums);\\n    const rightCount = this.build(idx * 2 + 2, mid + 1, max, nums);\\n    \\n    this.counts[idx] = leftCount + rightCount;\\n    return this.counts[idx];\\n  }\\n\\n  query1(l, r, idx = 0, min = 0, max = this.max) {\\n    // outside of range, do nothing\\n    if (min > r || max < l) return this.counts[idx];\\n    if (min === max) {\\n\\t  // leaf\\n      this.counts[idx] = 1 - this.counts[idx];\\n      return this.counts[idx];\\n    }\\n    \\n\\t// use the size to get the inverse of our child sums if we\\'re flipped\\n    const size = max - min + 1;\\n    \\n    if (l <= min && r >= max) {\\n\\t  // range is covered, just update the flipped state\\n      this.flipped[idx] = 1 - this.flipped[idx];\\n      const leftCount = this.counts[idx * 2 + 1];\\n      const rightCount = this.counts[idx * 2 + 2];\\n      this.counts[idx] = this.flipped[idx]\\n        ? size - leftCount - rightCount\\n        : leftCount + rightCount;\\n      return this.counts[idx];\\n    }\\n    \\n\\t// range is partially covered, so we gotta update our children\\n    const mid = min + max >> 1;\\n    const leftCount = this.query1(l, r, idx * 2 + 1, min, mid);\\n    const rightCount = this.query1(l, r, idx * 2 + 2, mid + 1, max);\\n    this.counts[idx] = this.flipped[idx]\\n      ? size - leftCount - rightCount\\n      : leftCount + rightCount;\\n    return this.counts[idx];\\n  }\\n\\n  query2(p) {\\n    this.total += this.counts[0] * p;\\n  }\\n\\n  query3() {\\n    return this.total;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar handleQuery = function(nums1, nums2, queries) {\\n  const segmentTree = new SegmentTree(nums1, nums2);\\n\\n  return queries.reduce((answers, [type, a, b]) => {\\n    switch (type) {\\n      case 1:\\n        segmentTree.query1(a, b);\\n        return answers;\\n      case 2:\\n        segmentTree.query2(a);\\n        return answers;\\n      default:\\n        answers.push(segmentTree.query3());\\n        return answers;\\n    }\\n  }, []);\\n};\\n\\nclass SegmentTree {\\n  flipped = [];\\n  counts = [];\\n  max = 0;\\n  total = 0;\\n\\n  constructor(nums1, nums2) {\\n    this.max = nums1.length - 1;\\n    this.flipped = [...nums1, ...nums1].map(() => 0);\\n    this.counts = [...this.flipped];\\n    this.total = nums2.reduce((total, num) => total + num, 0);\\n    \\n    this.build(0, 0, nums1.length - 1, nums1);\\n  }\\n\\n  build(idx, min, max, nums) {\\n    if (min === max) {\\n\\t  // leaf\\n      this.counts[idx] = nums[min];\\n      return this.counts[idx];\\n    }\\n    \\n    const mid = min + max >> 1;\\n    \\n    const leftCount = this.build(idx * 2 + 1, min, mid, nums);\\n    const rightCount = this.build(idx * 2 + 2, mid + 1, max, nums);\\n    \\n    this.counts[idx] = leftCount + rightCount;\\n    return this.counts[idx];\\n  }\\n\\n  query1(l, r, idx = 0, min = 0, max = this.max) {\\n    // outside of range, do nothing\\n    if (min > r || max < l) return this.counts[idx];\\n    if (min === max) {\\n\\t  // leaf\\n      this.counts[idx] = 1 - this.counts[idx];\\n      return this.counts[idx];\\n    }\\n    \\n\\t// use the size to get the inverse of our child sums if we\\'re flipped\\n    const size = max - min + 1;\\n    \\n    if (l <= min && r >= max) {\\n\\t  // range is covered, just update the flipped state\\n      this.flipped[idx] = 1 - this.flipped[idx];\\n      const leftCount = this.counts[idx * 2 + 1];\\n      const rightCount = this.counts[idx * 2 + 2];\\n      this.counts[idx] = this.flipped[idx]\\n        ? size - leftCount - rightCount\\n        : leftCount + rightCount;\\n      return this.counts[idx];\\n    }\\n    \\n\\t// range is partially covered, so we gotta update our children\\n    const mid = min + max >> 1;\\n    const leftCount = this.query1(l, r, idx * 2 + 1, min, mid);\\n    const rightCount = this.query1(l, r, idx * 2 + 2, mid + 1, max);\\n    this.counts[idx] = this.flipped[idx]\\n      ? size - leftCount - rightCount\\n      : leftCount + rightCount;\\n    return this.counts[idx];\\n  }\\n\\n  query2(p) {\\n    this.total += this.counts[0] * p;\\n  }\\n\\n  query3() {\\n    return this.total;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213840,
                "title": "segment-tree-with-lazy-propagation",
                "content": "# Intuition\\nThe most easy and obvious solution would be to use segment tree with lazy propagation. We need to build a segment tree which can flip values (0 to 1 or 1 to 0) between a range (l,r) and also give us the sum elements from a range (here 0 to n-1).\\nlet\\'s say the total sum of elements from nums2 be sum, then if we want to get new sum (after some update operation 2) we can find the total number of ones from nums1 and do the following:\\nsum+=(cnt*p);\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(Q*log(N))$$\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class segment_tree{\\n    public:\\n        vector<long long> tree;\\n        vector<long long> lazy;\\n\\n        segment_tree(int n){\\n            tree.resize(4*n+1);\\n            lazy.resize(4*n+1);\\n        }\\n\\n        void build(vector<int>& arr,int Node,int tl,int tr){\\n            if(tl==tr){\\n                tree[Node] = arr[tl];\\n                return;\\n            }\\n\\n            int mid = (tl+tr)>>1;\\n\\n            build(arr,2*Node+1,tl,mid);\\n            build(arr,2*Node+2,mid+1,tr);\\n            tree[Node] = tree[2*Node+1]+tree[2*Node+2];\\n        }\\n\\n        void range_update(int Node,int tl,int tr,int l,int r){\\n            if(lazy[Node]!=0){\\n                tree[Node] = (tr-tl+1)-tree[Node];\\n                if(tl!=tr){\\n                    lazy[2*Node+1] ^=1;\\n                    lazy[2*Node+2] ^=1; \\n                }\\n                lazy[Node] ^=1;\\n            }\\n\\n            if(tr<l || tl>r || tl>tr)\\n                return;\\n            \\n            if(tl>=l && tr<=r){\\n                tree[Node] = (tr-tl+1)-tree[Node];\\n                if(tl!=tr){\\n                    lazy[2*Node+1] ^=1;\\n                    lazy[2*Node+2] ^=1; \\n                }\\n                return;\\n            }\\n\\n            int mid = (tl+tr)>>1;\\n\\n            range_update(2*Node+1,tl,mid,l,r);\\n            range_update(2*Node+2,mid+1,tr,l,r);  \\n            tree[Node] = tree[2*Node+1]+tree[2*Node+2];          \\n        }\\n        long long query(int Node,int tl,int tr,int l,int r){\\n            if(lazy[Node]!=0){\\n                tree[Node] = (tr-tl+1)-tree[Node];\\n                if(tl!=tr){\\n                    lazy[2*Node+1] ^=1;\\n                    lazy[2*Node+2] ^=1;\\n                }\\n                lazy[Node]^=1;\\n            }\\n\\n            if(tr<l || tl>r || tl>tr)\\n                return 0;\\n            \\n            if(tl>=l && tr<=r)\\n                return tree[Node];\\n            \\n            \\n            int mid = (tl+tr)>>1;\\n\\n            return query(2*Node+1,tl,mid,l,r)+query(2*Node+2,mid+1,tr,l,r);    \\n        }\\n    };\\n\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        segment_tree seg(n);\\n        seg.build(nums1,0,0,n-1);\\n        vector<long long> ans;\\n        long long sum = 0;\\n        for(auto it:nums2){\\n            sum+=it;\\n        }\\n\\n        for(auto it:queries){\\n            int a,b,c;\\n            a = it[0];\\n            b = it[1];\\n            c = it[2];\\n\\n            if(a==1){\\n                seg.range_update(0,0,n-1,b,c);\\n            }else if(a==2){\\n                long long cnt = seg.query(0,0,n-1,0,n-1);\\n                sum+=cnt*b;\\n            }else\\n                ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    class segment_tree{\\n    public:\\n        vector<long long> tree;\\n        vector<long long> lazy;\\n\\n        segment_tree(int n){\\n            tree.resize(4*n+1);\\n            lazy.resize(4*n+1);\\n        }\\n\\n        void build(vector<int>& arr,int Node,int tl,int tr){\\n            if(tl==tr){\\n                tree[Node] = arr[tl];\\n                return;\\n            }\\n\\n            int mid = (tl+tr)>>1;\\n\\n            build(arr,2*Node+1,tl,mid);\\n            build(arr,2*Node+2,mid+1,tr);\\n            tree[Node] = tree[2*Node+1]+tree[2*Node+2];\\n        }\\n\\n        void range_update(int Node,int tl,int tr,int l,int r){\\n            if(lazy[Node]!=0){\\n                tree[Node] = (tr-tl+1)-tree[Node];\\n                if(tl!=tr){\\n                    lazy[2*Node+1] ^=1;\\n                    lazy[2*Node+2] ^=1; \\n                }\\n                lazy[Node] ^=1;\\n            }\\n\\n            if(tr<l || tl>r || tl>tr)\\n                return;\\n            \\n            if(tl>=l && tr<=r){\\n                tree[Node] = (tr-tl+1)-tree[Node];\\n                if(tl!=tr){\\n                    lazy[2*Node+1] ^=1;\\n                    lazy[2*Node+2] ^=1; \\n                }\\n                return;\\n            }\\n\\n            int mid = (tl+tr)>>1;\\n\\n            range_update(2*Node+1,tl,mid,l,r);\\n            range_update(2*Node+2,mid+1,tr,l,r);  \\n            tree[Node] = tree[2*Node+1]+tree[2*Node+2];          \\n        }\\n        long long query(int Node,int tl,int tr,int l,int r){\\n            if(lazy[Node]!=0){\\n                tree[Node] = (tr-tl+1)-tree[Node];\\n                if(tl!=tr){\\n                    lazy[2*Node+1] ^=1;\\n                    lazy[2*Node+2] ^=1;\\n                }\\n                lazy[Node]^=1;\\n            }\\n\\n            if(tr<l || tl>r || tl>tr)\\n                return 0;\\n            \\n            if(tl>=l && tr<=r)\\n                return tree[Node];\\n            \\n            \\n            int mid = (tl+tr)>>1;\\n\\n            return query(2*Node+1,tl,mid,l,r)+query(2*Node+2,mid+1,tr,l,r);    \\n        }\\n    };\\n\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        segment_tree seg(n);\\n        seg.build(nums1,0,0,n-1);\\n        vector<long long> ans;\\n        long long sum = 0;\\n        for(auto it:nums2){\\n            sum+=it;\\n        }\\n\\n        for(auto it:queries){\\n            int a,b,c;\\n            a = it[0];\\n            b = it[1];\\n            c = it[2];\\n\\n            if(a==1){\\n                seg.range_update(0,0,n-1,b,c);\\n            }else if(a==2){\\n                long long cnt = seg.query(0,0,n-1,0,n-1);\\n                sum+=cnt*b;\\n            }else\\n                ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212751,
                "title": "based-on-great-idea-from-dilshodbek-made-some-changes-since-js-doesn-t-have-some-python-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar handleQuery = function (nums1, nums2, queries) {\\n  let ans = [];\\n  let nums1Ones = 0;\\n  for (let val of nums1) \\n    if (val === 1) nums1Ones++;\\n  let type3Result = nums2.reduce((a, g) => a + g);\\n\\n  for (let query of queries) {\\n    let type = query[0];\\n    switch (type) {\\n      case 1:\\n        let [_, l, r] = query;\\n        let oldOnes = 0;\\n        let bitSum = r - l + 1;\\n        for (let i = l; i <= r; i++) {\\n          if (nums1[i] === 1) oldOnes++;\\n          nums1[i] = Math.abs(nums1[i] - 1);\\n        }\\n\\n        // update value of nums1Ones, code in case 2 will use it\\n        nums1Ones = nums1Ones + (bitSum - oldOnes - oldOnes);\\n        break;\\n      case 2:\\n        let [x, p, y] = query;\\n        // we don\\'t really care each item value of nums2\\n        type3Result += p * nums1Ones;\\n        break;\\n      case 3:\\n        ans.push(type3Result);\\n        break;\\n      default:\\n        break;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar handleQuery = function (nums1, nums2, queries) {\\n  let ans = [];\\n  let nums1Ones = 0;\\n  for (let val of nums1) \\n    if (val === 1) nums1Ones++;\\n  let type3Result = nums2.reduce((a, g) => a + g);\\n\\n  for (let query of queries) {\\n    let type = query[0];\\n    switch (type) {\\n      case 1:\\n        let [_, l, r] = query;\\n        let oldOnes = 0;\\n        let bitSum = r - l + 1;\\n        for (let i = l; i <= r; i++) {\\n          if (nums1[i] === 1) oldOnes++;\\n          nums1[i] = Math.abs(nums1[i] - 1);\\n        }\\n\\n        // update value of nums1Ones, code in case 2 will use it\\n        nums1Ones = nums1Ones + (bitSum - oldOnes - oldOnes);\\n        break;\\n      case 2:\\n        let [x, p, y] = query;\\n        // we don\\'t really care each item value of nums2\\n        type3Result += p * nums1Ones;\\n        break;\\n      case 3:\\n        ans.push(type3Result);\\n        break;\\n      default:\\n        break;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209337,
                "title": "my-solution",
                "content": "**1. Static Segment Tree**\\n```\\nclass Solution {\\n private:\\n  class SegmentTree {\\n   public:\\n    SegmentTree(const vector<int> &nums)\\n      : n_(static_cast<int>(nums.size())),\\n        tree_(tree_size(), 0),\\n        lazy_(tree_.size(), false) {\\n      build_tree_impl(nums, 0, 0, n_);\\n    }\\n    \\n    void update(const int left, const int right) {\\n      update_impl(0, 0, n_, left, right);\\n    }\\n    \\n    int read() {\\n      return read_impl(0, 0, n_, 0, n_);\\n    }\\n    \\n   private:\\n    int tree_size() const {\\n      return (1 << static_cast<int>(ceil(log2(n_)) + 1)) - 1;\\n    }\\n    \\n    void build_tree_impl(const vector<int> &nums, const int node, const int begin, const int end) {\\n      if (end - begin == 1) {\\n        tree_[node] = nums[begin];\\n        return;\\n      }\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + (end - begin) / 2;\\n      build_tree_impl(nums, left_node, begin, mid);\\n      build_tree_impl(nums, right_node, mid, end);\\n      tree_[node] = tree_[left_node] + tree_[right_node];\\n    }\\n    \\n    void update_impl(const int node, const int begin, const int end, const int left, const int right) {\\n      if (left >= end || right <= begin) {\\n        return;\\n      }\\n      \\n      if (begin >= left && end <= right) {\\n        const int ones = tree_[node];\\n        const int zeros = end - begin - ones;\\n        tree_[node] = zeros;\\n        lazy_[node] = !lazy_[node];\\n        return;\\n      }\\n      \\n      push_down(node, begin, end);\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + (end - begin) / 2;\\n      \\n      update_impl(left_node, begin, mid, left, right);\\n      update_impl(right_node, mid, end, left, right);\\n      tree_[node] = tree_[left_node] + tree_[right_node];\\n    }\\n    \\n    int read_impl(const int node, const int begin, const int end, const int left, const int right) {\\n      if (left >= end || right <= begin) {\\n        return 0;\\n      }\\n      \\n      if (begin >= left && end <= right) {\\n        return tree_[node];\\n      }\\n      \\n      push_down(node, begin, end);\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + (end - begin) / 2;\\n      \\n      return read_impl(left_node, begin, mid, left, right) + read_impl(right_node, mid, end, left, right);\\n    }\\n    \\n    void push_down(const int node, const int begin, const int end) {\\n      if (!lazy_[node]) {\\n        return;\\n      }\\n\\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + (end - begin) / 2;\\n      \\n      const int left_ones = tree_[left_node];\\n      const int left_zeros = mid - begin - left_ones;\\n      tree_[left_node] = left_zeros;\\n      lazy_[left_node] = !lazy_[left_node];\\n      \\n      const int right_ones = tree_[right_node];\\n      const int right_zeros = end - mid - right_ones;\\n      tree_[right_node] = right_zeros;\\n      lazy_[right_node] = !lazy_[right_node];\\n      \\n      lazy_[node] = false;\\n    }\\n    \\n    const int n_;\\n    vector<int> tree_;\\n    vector<bool> lazy_;\\n  };\\n  \\n public:\\n  vector<long long> handleQuery(const vector<int> &nums1,\\n                                const vector<int> &nums2,\\n                                const vector<vector<int>> &queries) {\\n    constexpr int type_i = 0;\\n    constexpr int left_i = 1;\\n    constexpr int right_i = 2;\\n    constexpr int p_i = 1;\\n    constexpr int type_1 = 1;\\n    constexpr int type_2 = 2;\\n    SegmentTree segment_tree(nums1);\\n    vector<long long> ret;\\n    long long sum = accumulate(nums2.begin(), nums2.end(), 0LL);\\n    for (const vector<int> &query : queries) {\\n      const int type = query[type_i];\\n      if (type == type_1) {\\n        segment_tree.update(query[left_i], query[right_i] + 1);\\n      } else if (type == type_2) {\\n        sum += static_cast<long long>(segment_tree.read()) * query[p_i];\\n      } else {\\n        // type == 3\\n        ret.emplace_back(sum);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Dynamic Segment Tree**\\n```\\nclass Solution {\\n private:\\n  class TreeNode {\\n   public:\\n    TreeNode(const int value) : left_(nullptr), right_(nullptr), value_(value), lazy_(false) {\\n    }\\n    \\n    TreeNode(TreeNode * const left,\\n             TreeNode * const right,\\n             const int value) : left_(left), right_(right), value_(value), lazy_(false) {\\n    }\\n    \\n    ~TreeNode() {\\n      delete left_;\\n      delete right_;\\n    }\\n    \\n    void set_left(TreeNode * const left) {\\n      left_ = left;\\n    }\\n    \\n    TreeNode* left() const {\\n      return left_;\\n    }\\n    \\n    void set_right(TreeNode * const right) {\\n      right_ = right;\\n    }\\n    \\n    TreeNode* right() const {\\n      return right_;\\n    }\\n    \\n    void set_value(const int value) {\\n      value_ = value;\\n    }\\n    \\n    int value() const {\\n      return value_;\\n    }\\n    \\n    void flip_lazy() {\\n      lazy_ = !lazy_;\\n    }\\n    \\n    bool lazy() const {\\n      return lazy_;\\n    }\\n    \\n   private:\\n    TreeNode *left_;\\n    TreeNode *right_;\\n    int value_;\\n    bool lazy_;\\n  };\\n  \\n  class SegmentTree {\\n   public:\\n    SegmentTree(const vector<int> &nums)\\n      : n_(static_cast<int>(nums.size())),\\n        root_(build_tree(nums)) {\\n    }\\n    \\n    ~SegmentTree() {\\n      delete root_;\\n    }\\n    \\n    void update(const int left, const int right) {\\n      update_impl(root_, 0, n_, left, right);\\n    }\\n    \\n    int read() {\\n      return read_impl(root_, 0, n_, 0, n_);\\n    }\\n    \\n   private:\\n    int tree_size() const {\\n      return (1 << static_cast<int>(ceil(log2(n_)) + 1)) - 1;\\n    }\\n    \\n    TreeNode* build_tree(const vector<int> &nums) {\\n      const int n = static_cast<int>(nums.size());\\n      return build_tree_impl(nums, 0, n);\\n    }\\n    \\n    TreeNode* build_tree_impl(const vector<int> &nums, const int begin, const int end) {\\n      if (end - begin == 1) {\\n        return new TreeNode(nums[begin]);\\n      }\\n      \\n      const int mid = begin + (end - begin) / 2;\\n      TreeNode * const left = build_tree_impl(nums, begin, mid);\\n      TreeNode * const right = build_tree_impl(nums, mid, end);\\n      return new TreeNode(left, right, left->value() + right->value());\\n    }\\n    \\n    void update_impl(TreeNode * const node, const int begin, const int end, const int left, const int right) {\\n      if (left >= end || right <= begin) {\\n        return;\\n      }\\n      \\n      if (begin >= left && end <= right) {\\n        const int ones = node->value();\\n        const int zeros = end - begin - ones;\\n        node->set_value(zeros);\\n        node->flip_lazy();\\n        return;\\n      }\\n      \\n      push_down(node, begin, end);\\n      \\n      const int mid = begin + (end - begin) / 2;\\n      update_impl(node->left(), begin, mid, left, right);\\n      update_impl(node->right(), mid, end, left, right);\\n      node->set_value(node->left()->value() + node->right()->value());\\n    }\\n    \\n    int read_impl(TreeNode * const node, const int begin, const int end, const int left, const int right) {\\n      if (left >= end || right <= begin) {\\n        return 0;\\n      }\\n      \\n      if (begin >= left && end <= right) {\\n        return node->value();\\n      }\\n      \\n      push_down(node, begin, end);\\n      \\n      const int mid = begin + (end - begin) / 2;\\n      return read_impl(node->left(), begin, mid, left, right) + read_impl(node->right(), mid, end, left, right);\\n    }\\n    \\n    void push_down(TreeNode * const node, const int begin, const int end) {\\n      if (!node->lazy()) {\\n        return;\\n      }\\n\\n      const int mid = begin + (end - begin) / 2;\\n      \\n      const int left_ones = node->left()->value();\\n      const int left_zeros = mid - begin - left_ones;\\n      node->left()->set_value(left_zeros);\\n      node->left()->flip_lazy();\\n      \\n      const int right_ones = node->right()->value();\\n      const int right_zeros = end - mid - right_ones;\\n      node->right()->set_value(right_zeros);\\n      node->right()->flip_lazy();\\n      \\n      node->flip_lazy();\\n    }\\n    \\n    const int n_;\\n    TreeNode * const root_;\\n  };\\n  \\n public:\\n  vector<long long> handleQuery(const vector<int> &nums1,\\n                                const vector<int> &nums2,\\n                                const vector<vector<int>> &queries) {\\n    constexpr int type_i = 0;\\n    constexpr int left_i = 1;\\n    constexpr int right_i = 2;\\n    constexpr int p_i = 1;\\n    constexpr int type_1 = 1;\\n    constexpr int type_2 = 2;\\n    SegmentTree segment_tree(nums1);\\n    vector<long long> ret;\\n    long long sum = accumulate(nums2.begin(), nums2.end(), 0LL);\\n    for (const vector<int> &query : queries) {\\n      const int type = query[type_i];\\n      if (type == type_1) {\\n        segment_tree.update(query[left_i], query[right_i] + 1);\\n      } else if (type == type_2) {\\n        sum += static_cast<long long>(segment_tree.read()) * query[p_i];\\n      } else {\\n        // type == 3\\n        ret.emplace_back(sum);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  class SegmentTree {\\n   public:\\n    SegmentTree(const vector<int> &nums)\\n      : n_(static_cast<int>(nums.size())),\\n        tree_(tree_size(), 0),\\n        lazy_(tree_.size(), false) {\\n      build_tree_impl(nums, 0, 0, n_);\\n    }\\n    \\n    void update(const int left, const int right) {\\n      update_impl(0, 0, n_, left, right);\\n    }\\n    \\n    int read() {\\n      return read_impl(0, 0, n_, 0, n_);\\n    }\\n    \\n   private:\\n    int tree_size() const {\\n      return (1 << static_cast<int>(ceil(log2(n_)) + 1)) - 1;\\n    }\\n    \\n    void build_tree_impl(const vector<int> &nums, const int node, const int begin, const int end) {\\n      if (end - begin == 1) {\\n        tree_[node] = nums[begin];\\n        return;\\n      }\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + (end - begin) / 2;\\n      build_tree_impl(nums, left_node, begin, mid);\\n      build_tree_impl(nums, right_node, mid, end);\\n      tree_[node] = tree_[left_node] + tree_[right_node];\\n    }\\n    \\n    void update_impl(const int node, const int begin, const int end, const int left, const int right) {\\n      if (left >= end || right <= begin) {\\n        return;\\n      }\\n      \\n      if (begin >= left && end <= right) {\\n        const int ones = tree_[node];\\n        const int zeros = end - begin - ones;\\n        tree_[node] = zeros;\\n        lazy_[node] = !lazy_[node];\\n        return;\\n      }\\n      \\n      push_down(node, begin, end);\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + (end - begin) / 2;\\n      \\n      update_impl(left_node, begin, mid, left, right);\\n      update_impl(right_node, mid, end, left, right);\\n      tree_[node] = tree_[left_node] + tree_[right_node];\\n    }\\n    \\n    int read_impl(const int node, const int begin, const int end, const int left, const int right) {\\n      if (left >= end || right <= begin) {\\n        return 0;\\n      }\\n      \\n      if (begin >= left && end <= right) {\\n        return tree_[node];\\n      }\\n      \\n      push_down(node, begin, end);\\n      \\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + (end - begin) / 2;\\n      \\n      return read_impl(left_node, begin, mid, left, right) + read_impl(right_node, mid, end, left, right);\\n    }\\n    \\n    void push_down(const int node, const int begin, const int end) {\\n      if (!lazy_[node]) {\\n        return;\\n      }\\n\\n      const int left_node = 2 * node + 1;\\n      const int right_node = 2 * node + 2;\\n      const int mid = begin + (end - begin) / 2;\\n      \\n      const int left_ones = tree_[left_node];\\n      const int left_zeros = mid - begin - left_ones;\\n      tree_[left_node] = left_zeros;\\n      lazy_[left_node] = !lazy_[left_node];\\n      \\n      const int right_ones = tree_[right_node];\\n      const int right_zeros = end - mid - right_ones;\\n      tree_[right_node] = right_zeros;\\n      lazy_[right_node] = !lazy_[right_node];\\n      \\n      lazy_[node] = false;\\n    }\\n    \\n    const int n_;\\n    vector<int> tree_;\\n    vector<bool> lazy_;\\n  };\\n  \\n public:\\n  vector<long long> handleQuery(const vector<int> &nums1,\\n                                const vector<int> &nums2,\\n                                const vector<vector<int>> &queries) {\\n    constexpr int type_i = 0;\\n    constexpr int left_i = 1;\\n    constexpr int right_i = 2;\\n    constexpr int p_i = 1;\\n    constexpr int type_1 = 1;\\n    constexpr int type_2 = 2;\\n    SegmentTree segment_tree(nums1);\\n    vector<long long> ret;\\n    long long sum = accumulate(nums2.begin(), nums2.end(), 0LL);\\n    for (const vector<int> &query : queries) {\\n      const int type = query[type_i];\\n      if (type == type_1) {\\n        segment_tree.update(query[left_i], query[right_i] + 1);\\n      } else if (type == type_2) {\\n        sum += static_cast<long long>(segment_tree.read()) * query[p_i];\\n      } else {\\n        // type == 3\\n        ret.emplace_back(sum);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\nclass Solution {\\n private:\\n  class TreeNode {\\n   public:\\n    TreeNode(const int value) : left_(nullptr), right_(nullptr), value_(value), lazy_(false) {\\n    }\\n    \\n    TreeNode(TreeNode * const left,\\n             TreeNode * const right,\\n             const int value) : left_(left), right_(right), value_(value), lazy_(false) {\\n    }\\n    \\n    ~TreeNode() {\\n      delete left_;\\n      delete right_;\\n    }\\n    \\n    void set_left(TreeNode * const left) {\\n      left_ = left;\\n    }\\n    \\n    TreeNode* left() const {\\n      return left_;\\n    }\\n    \\n    void set_right(TreeNode * const right) {\\n      right_ = right;\\n    }\\n    \\n    TreeNode* right() const {\\n      return right_;\\n    }\\n    \\n    void set_value(const int value) {\\n      value_ = value;\\n    }\\n    \\n    int value() const {\\n      return value_;\\n    }\\n    \\n    void flip_lazy() {\\n      lazy_ = !lazy_;\\n    }\\n    \\n    bool lazy() const {\\n      return lazy_;\\n    }\\n    \\n   private:\\n    TreeNode *left_;\\n    TreeNode *right_;\\n    int value_;\\n    bool lazy_;\\n  };\\n  \\n  class SegmentTree {\\n   public:\\n    SegmentTree(const vector<int> &nums)\\n      : n_(static_cast<int>(nums.size())),\\n        root_(build_tree(nums)) {\\n    }\\n    \\n    ~SegmentTree() {\\n      delete root_;\\n    }\\n    \\n    void update(const int left, const int right) {\\n      update_impl(root_, 0, n_, left, right);\\n    }\\n    \\n    int read() {\\n      return read_impl(root_, 0, n_, 0, n_);\\n    }\\n    \\n   private:\\n    int tree_size() const {\\n      return (1 << static_cast<int>(ceil(log2(n_)) + 1)) - 1;\\n    }\\n    \\n    TreeNode* build_tree(const vector<int> &nums) {\\n      const int n = static_cast<int>(nums.size());\\n      return build_tree_impl(nums, 0, n);\\n    }\\n    \\n    TreeNode* build_tree_impl(const vector<int> &nums, const int begin, const int end) {\\n      if (end - begin == 1) {\\n        return new TreeNode(nums[begin]);\\n      }\\n      \\n      const int mid = begin + (end - begin) / 2;\\n      TreeNode * const left = build_tree_impl(nums, begin, mid);\\n      TreeNode * const right = build_tree_impl(nums, mid, end);\\n      return new TreeNode(left, right, left->value() + right->value());\\n    }\\n    \\n    void update_impl(TreeNode * const node, const int begin, const int end, const int left, const int right) {\\n      if (left >= end || right <= begin) {\\n        return;\\n      }\\n      \\n      if (begin >= left && end <= right) {\\n        const int ones = node->value();\\n        const int zeros = end - begin - ones;\\n        node->set_value(zeros);\\n        node->flip_lazy();\\n        return;\\n      }\\n      \\n      push_down(node, begin, end);\\n      \\n      const int mid = begin + (end - begin) / 2;\\n      update_impl(node->left(), begin, mid, left, right);\\n      update_impl(node->right(), mid, end, left, right);\\n      node->set_value(node->left()->value() + node->right()->value());\\n    }\\n    \\n    int read_impl(TreeNode * const node, const int begin, const int end, const int left, const int right) {\\n      if (left >= end || right <= begin) {\\n        return 0;\\n      }\\n      \\n      if (begin >= left && end <= right) {\\n        return node->value();\\n      }\\n      \\n      push_down(node, begin, end);\\n      \\n      const int mid = begin + (end - begin) / 2;\\n      return read_impl(node->left(), begin, mid, left, right) + read_impl(node->right(), mid, end, left, right);\\n    }\\n    \\n    void push_down(TreeNode * const node, const int begin, const int end) {\\n      if (!node->lazy()) {\\n        return;\\n      }\\n\\n      const int mid = begin + (end - begin) / 2;\\n      \\n      const int left_ones = node->left()->value();\\n      const int left_zeros = mid - begin - left_ones;\\n      node->left()->set_value(left_zeros);\\n      node->left()->flip_lazy();\\n      \\n      const int right_ones = node->right()->value();\\n      const int right_zeros = end - mid - right_ones;\\n      node->right()->set_value(right_zeros);\\n      node->right()->flip_lazy();\\n      \\n      node->flip_lazy();\\n    }\\n    \\n    const int n_;\\n    TreeNode * const root_;\\n  };\\n  \\n public:\\n  vector<long long> handleQuery(const vector<int> &nums1,\\n                                const vector<int> &nums2,\\n                                const vector<vector<int>> &queries) {\\n    constexpr int type_i = 0;\\n    constexpr int left_i = 1;\\n    constexpr int right_i = 2;\\n    constexpr int p_i = 1;\\n    constexpr int type_1 = 1;\\n    constexpr int type_2 = 2;\\n    SegmentTree segment_tree(nums1);\\n    vector<long long> ret;\\n    long long sum = accumulate(nums2.begin(), nums2.end(), 0LL);\\n    for (const vector<int> &query : queries) {\\n      const int type = query[type_i];\\n      if (type == type_1) {\\n        segment_tree.update(query[left_i], query[right_i] + 1);\\n      } else if (type == type_2) {\\n        sum += static_cast<long long>(segment_tree.read()) * query[p_i];\\n      } else {\\n        // type == 3\\n        ret.emplace_back(sum);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209016,
                "title": "no-template-segtree-solution-lazy-propagation",
                "content": "This solution is based on my own understanding of segtree and cater specifically for this problem.\\n\\n# Code\\n```\\nclass segtree:\\n    # assume n is a power of 2\\n    def __init__(self, values, n): \\n        self.tree = [0] * (2 * n)\\n        self.tree[n:n+len(values)] = values\\n        self.lazy = [0] * (2 * n)\\n        self.len = [0] * n + [1] * n\\n        # build the tree using values\\n        for i in range(n-1, 0, -1):\\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\\n            self.len[i] = self.len[i*2] + self.len[i*2+1]\\n        self.size = n\\n\\n    def update(self, node, l, low, r, high): # the range to update from l->r inclusive\\n        if l > high or r < low:\\n            return\\n        left, right = node * 2, node * 2 + 1\\n        if l == low and r == high: # update this full range\\n            self.tree[node] = self.len[node] - self.tree[node] # flip the count zeros and ones\\n            if self.len[node] > 1: # not the single node, we can mark it\\'s children\\n                self.lazy[left] ^= True\\n                self.lazy[right] ^= True\\n            return\\n\\n        # make sure to apply all the previous update on this node if needed\\n        self.propagate(left)\\n        self.propagate(right)\\n\\n        half = self.len[node] // 2\\n        self.update(left, l, low, min(r, high - half), high - half)\\n        self.update(right, max(l, low+half), low + half, r, high)\\n        self.tree[node] = self.tree[left] + self.tree[right]\\n\\n    def propagate(self, node):\\n        if self.lazy[node]:\\n            # calculate the correct answer for this node and mark the children to be propagated\\n            self.tree[node] = self.len[node] - self.tree[node]\\n            self.lazy[node] = False # done with this node\\n            if self.len[node] > 1: # will have children\\n                self.lazy[node * 2] ^= True\\n                self.lazy[node * 2 + 1] ^= True\\n\\n    def sum(self):\\n        return self.tree[1]\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        # generate the full binary tree with leaf layer of size n\\n        n = 2 ** (ceil(log(len(nums1), 2)))\\n        seg = segtree(nums1, n)\\n        ans = []\\n        S = sum(nums2)\\n\\n        for i, j, k in queries:\\n            if i == 1:\\n                seg.update(1, j, 0, k, n-1)\\n            if i == 2:\\n                S += seg.tree[1] * j\\n            if i == 3:\\n                ans.append(S)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass segtree:\\n    # assume n is a power of 2\\n    def __init__(self, values, n): \\n        self.tree = [0] * (2 * n)\\n        self.tree[n:n+len(values)] = values\\n        self.lazy = [0] * (2 * n)\\n        self.len = [0] * n + [1] * n\\n        # build the tree using values\\n        for i in range(n-1, 0, -1):\\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\\n            self.len[i] = self.len[i*2] + self.len[i*2+1]\\n        self.size = n\\n\\n    def update(self, node, l, low, r, high): # the range to update from l->r inclusive\\n        if l > high or r < low:\\n            return\\n        left, right = node * 2, node * 2 + 1\\n        if l == low and r == high: # update this full range\\n            self.tree[node] = self.len[node] - self.tree[node] # flip the count zeros and ones\\n            if self.len[node] > 1: # not the single node, we can mark it\\'s children\\n                self.lazy[left] ^= True\\n                self.lazy[right] ^= True\\n            return\\n\\n        # make sure to apply all the previous update on this node if needed\\n        self.propagate(left)\\n        self.propagate(right)\\n\\n        half = self.len[node] // 2\\n        self.update(left, l, low, min(r, high - half), high - half)\\n        self.update(right, max(l, low+half), low + half, r, high)\\n        self.tree[node] = self.tree[left] + self.tree[right]\\n\\n    def propagate(self, node):\\n        if self.lazy[node]:\\n            # calculate the correct answer for this node and mark the children to be propagated\\n            self.tree[node] = self.len[node] - self.tree[node]\\n            self.lazy[node] = False # done with this node\\n            if self.len[node] > 1: # will have children\\n                self.lazy[node * 2] ^= True\\n                self.lazy[node * 2 + 1] ^= True\\n\\n    def sum(self):\\n        return self.tree[1]\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        # generate the full binary tree with leaf layer of size n\\n        n = 2 ** (ceil(log(len(nums1), 2)))\\n        seg = segtree(nums1, n)\\n        ans = []\\n        S = sum(nums2)\\n\\n        for i, j, k in queries:\\n            if i == 1:\\n                seg.update(1, j, 0, k, n-1)\\n            if i == 2:\\n                S += seg.tree[1] * j\\n            if i == 3:\\n                ans.append(S)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208971,
                "title": "c-segment-tree-lazy-propagation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// #include<bits/stdc++.h>\\n// using namespace std;\\n\\nclass Solution {\\n    struct Node {\\n        int lazy, sum;\\n        Node() {\\n            lazy = sum = 0;\\n        }\\n    };\\n\\n    vector<Node> tree;\\n    int buildST(int i, int l, int r, vector<int> &a) {\\n        if(l == r) \\n            return tree[i].sum = a[l];\\n        int mid = (l + r) / 2;\\n        return tree[i].sum = buildST(2*i+1, l, mid, a) + buildST(2*i+2, mid+1, r, a);\\n    }\\n\\n    void pending_update(int i, int sl, int sr) {\\n        if(tree[i].lazy%2 != 0) {\\n            tree[i].sum = (sr-sl+1) - tree[i].sum;\\n        }\\n        \\n        if(sl != sr) {             //update child nodes and reset parent (i)\\n            tree[2*i+1].lazy += tree[i].lazy;\\n            tree[2*i+2].lazy += tree[i].lazy;\\n        }\\n            \\n        tree[i].lazy = 0;\\n    }\\n\\n    void range_update(int i, int sl, int sr, int l, int r, int val) {\\n        pending_update(i, sl, sr);\\n\\n        if(sr < l || r < sl)          // no overlap;\\n            return;\\n\\n        if(sl >= l && sr <= r)  {     // total overlap\\n            tree[i].lazy += val;\\n            pending_update(i, sl, sr);\\n            return;\\n        }\\n\\n        int mid = (sl + sr) / 2;\\n        range_update(2*i+1, sl, mid, l, r, val);\\n        range_update(2*i+2, mid+1, sr, l, r, val);\\n        \\n        //update intermediate nodes after returning the value of the leaf node\\n        tree[i].sum = tree[2*i+1].sum + tree[2*i+2].sum;  \\n    }\\n\\n    int query(int i, int sl, int sr, int l, int r) {\\n        pending_update(i, sl, sr);\\n        \\n        if(sl >= l && sr <= r)          // total overlap\\n            return tree[i].sum;\\n        else if(sr < l || r < sl)       // no overlap;\\n            return 0;\\n\\n        int mid = (sl + sr) / 2;\\n        return query(2*i+1, sl, mid, l, r) + query(2*i+2, mid+1, sr, l, r);\\n        \\n    }\\n\\npublic:\\n    vector<long long> handleQuery(vector<int>& a, vector<int>& b, vector<vector<int>>& queries) {\\n        int n = a.size();\\n        tree.resize(4*n);\\n\\n        buildST(0, 0, n-1, a);\\n\\n        vector<long long> ans;\\n        long long sum2 = 0;\\n        for (int i: b)\\n            sum2 += i;\\n\\n        for(auto it: queries) {\\n            if(it[0] == 1) {\\n                range_update(0, 0, n-1, it[1], it[2], 1);\\n            } else if(it[0] == 2) {\\n                sum2 += (query(0, 0, n-1, 0, n-1) * (long long)it[1]);\\n            } else {\\n                ans.push_back(sum2);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\n// #include<bits/stdc++.h>\\n// using namespace std;\\n\\nclass Solution {\\n    struct Node {\\n        int lazy, sum;\\n        Node() {\\n            lazy = sum = 0;\\n        }\\n    };\\n\\n    vector<Node> tree;\\n    int buildST(int i, int l, int r, vector<int> &a) {\\n        if(l == r) \\n            return tree[i].sum = a[l];\\n        int mid = (l + r) / 2;\\n        return tree[i].sum = buildST(2*i+1, l, mid, a) + buildST(2*i+2, mid+1, r, a);\\n    }\\n\\n    void pending_update(int i, int sl, int sr) {\\n        if(tree[i].lazy%2 != 0) {\\n            tree[i].sum = (sr-sl+1) - tree[i].sum;\\n        }\\n        \\n        if(sl != sr) {             //update child nodes and reset parent (i)\\n            tree[2*i+1].lazy += tree[i].lazy;\\n            tree[2*i+2].lazy += tree[i].lazy;\\n        }\\n            \\n        tree[i].lazy = 0;\\n    }\\n\\n    void range_update(int i, int sl, int sr, int l, int r, int val) {\\n        pending_update(i, sl, sr);\\n\\n        if(sr < l || r < sl)          // no overlap;\\n            return;\\n\\n        if(sl >= l && sr <= r)  {     // total overlap\\n            tree[i].lazy += val;\\n            pending_update(i, sl, sr);\\n            return;\\n        }\\n\\n        int mid = (sl + sr) / 2;\\n        range_update(2*i+1, sl, mid, l, r, val);\\n        range_update(2*i+2, mid+1, sr, l, r, val);\\n        \\n        //update intermediate nodes after returning the value of the leaf node\\n        tree[i].sum = tree[2*i+1].sum + tree[2*i+2].sum;  \\n    }\\n\\n    int query(int i, int sl, int sr, int l, int r) {\\n        pending_update(i, sl, sr);\\n        \\n        if(sl >= l && sr <= r)          // total overlap\\n            return tree[i].sum;\\n        else if(sr < l || r < sl)       // no overlap;\\n            return 0;\\n\\n        int mid = (sl + sr) / 2;\\n        return query(2*i+1, sl, mid, l, r) + query(2*i+2, mid+1, sr, l, r);\\n        \\n    }\\n\\npublic:\\n    vector<long long> handleQuery(vector<int>& a, vector<int>& b, vector<vector<int>>& queries) {\\n        int n = a.size();\\n        tree.resize(4*n);\\n\\n        buildST(0, 0, n-1, a);\\n\\n        vector<long long> ans;\\n        long long sum2 = 0;\\n        for (int i: b)\\n            sum2 += i;\\n\\n        for(auto it: queries) {\\n            if(it[0] == 1) {\\n                range_update(0, 0, n-1, it[1], it[2], 1);\\n            } else if(it[0] == 2) {\\n                sum2 += (query(0, 0, n-1, 0, n-1) * (long long)it[1]);\\n            } else {\\n                ans.push_back(sum2);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3208597,
                "title": "c-o-nlogn-qlogn-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOperation 1: \\nWe should flip the bit of range `[l..r]` and keep the sum of `nums1` for operation 2 and 3.\\n\\nOperation 2:\\nThe second array nums2 is actually unrelated to the maintenance of the data strucutre. Since we are only adding `kp`, where `k` is the sum of `num1` to the current sum of `num2` when doing operation 2.\\n\\nOperation 3:\\nWe can simply append the current sum to the answer list.\\n\\nSo the requirements of the data structure are \\n1. it can efficiently update the sum of a consecutive range of element when we flip a consecutive range of elements of an array, and\\n2. it can rapidly query the sum of a consecutive range of elements.\\n\\nIt turns out that segment tree is a data structure that can handle such a \"range\" of updates and queries in $O(\\\\log n)$, where `n` is the length of the array. \\n\\nThe benefit to use segment tree is that we only have to update at most `O(\\\\log n)` segments for flip operation on any arbitrary interval `[x, y]`. It can be shown that each range `[L, R]` can be separated into $O(\\\\log (R-L+1))$ disjoint segments represented by halfing the root `[0,n-1]`. For example, if the maximal range is `[0..8]`, then an arbitrary interval `[3..6]` can be separated into `[3,4],[5,6],[7]`. \\n```\\n                 [0,8]\\n        [0,4]            [5,8]\\n    [0,2]    [3,4]   [5,6]   [7,8]\\n [0,1]  [2] [3] [4] [5] [6] [7] [8] \\n[0] [1]\\n```\\n\\nIn addition, each segment `[L, R]` can be further separated into `[L, (L+R)/2]` and `[(L+R)/2+1, R]`. Due to the hierarchical relations between these segments, we can represent the segments by a tree. The root of the tree represents the segment `[0, n-1]`. \\n\\nWe can represent the segments of the segment tree by an index `o` and keep the hierarchical structure in an array like heap(i.e. index of left child is `o*2`, right child is `o*2+1`). In addition, I keep the sum/flip status of each segment in `sumv`, `flipv`. The detailed maintenance/query/flip implementations are written in the comments or can be found at https://en.wikipedia.org/wiki/Segment_tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n\\\\log n)$ for preprocessing num1\\n$O(\\\\log n)$ for operation 1: fliping the range \\n$O(\\\\log n)$ for operation 2: get the sum of `num1[0..n-1]` and update sum by `p*sum(num1[0..n-1])`\\n$O(1)$ for operation 3: querying the sum of `num2[0..n-1]`\\nTotal: $O((n+q)\\\\log n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\n\\nbool flipv[400001]; // tell the range o[L, R] is flipped or not\\nint  sumv[400001];  // tell the sum of o[L, R]\\n\\nclass SegmentTree {\\npublic:\\n    SegmentTree() {\\n        memset(flipv, 0, sizeof(flipv));\\n        memset(sumv, 0, sizeof(sumv));\\n    }\\n\\n    void flip(int o, int L, int R, int x, int y) {\\n        // Flip all the elements in [x, y] on\\n        // node o with a range of [L, R]\\n\\n        // left  child(l): id = o*2,   range = [L, mid]\\n        // right child(r): id = o*2+1, range = [mid+1, R]\\n        int l = o<<1, r = (o<<1)+1;\\n        int mid = (L+R)/2;\\n\\n        if (x <= L && R <= y) {\\n            // case 1: [x, y] covers [L, R]\\n            // 1. directly flip node o[L, R]\\n            // 2. update sumv[o] by maintain\\n            flipv[o] = !flipv[o];\\n        } else {\\n            // case 2: partially overlap\\n            // 1. pushdown the flipv at o first\\n            // 2. update the overlapping segments [L, mid] or/and [mid+1, R]\\n            pushdown(o, L, R);\\n            if (x <= mid) {flip(l, L, mid, x, y);}\\n            if (mid+1<=y) {flip(r, mid+1, R, x, y);}\\n        }\\n        // keep flipv[o], sumv[o] correct\\n        maintain(o, L, R);\\n    }\\n\\n    int query(int o, int L, int R, int x, int y) {\\n        // Query the sum in [x, y] on\\n        // node o with a range of [L, R]\\n\\n        // left  child(l): id = o*2,   range = [L, mid]\\n        // right child(r): id = o*2+1, range = [mid+1, R]\\n        int l = o<<1, r = (o<<1) + 1;\\n        int mid = (L+R)/2, res = 0;\\n        if (x <= L && R <= y) {\\n            res = sumv[o];\\n        } else {\\n            if (x <= mid) {res += query(l, L, mid, x, y);}\\n            if (mid+1<=y) {res += query(r, mid+1, R, x, y);}\\n        }\\n        return res;\\n    }\\nprivate:\\n    void pushdown(int o, int L, int R) {\\n        // If the flip flag for range [L, R] is set \\n        // flip the flags of the two children, and \\n        // maintain the sumv, flipv of them.\\n        // The range o[L,R] is maintained at the end of \\n        // function \"flip\".\\n        if (!flipv[o]) return;\\n        int l = o << 1, r = (o<<1) + 1, mid = (L+R)/2;\\n        flipv[l] = !flipv[l];\\n        flipv[r] = !flipv[r];\\n        maintain(l, L, mid);\\n        maintain(r, mid+1, R);\\n        flipv[o] = 0;\\n    }\\n\\n    void maintain(int o, int L, int R) {\\n        // Make the sum value of the range [L, R] correct\\n        // considering the flip flag of the range [L, R].\\n        // It can be done by summing the left/right child\\n        // of the interval and \\n        // 1. sumv[o] = sumv[l] + sumv[r] if flipv[o] is false\\n        // 2. sumv[o] = len(L, R) - (sumv[l] + sumv[r]) if flipv[o] is true\\n        int len = R-L+1;\\n        if (L == R) {\\n            sumv[o] = flipv[o]?1:0;\\n        } else {\\n            int sum = sumv[o<<1] + sumv[(o<<1)+1];\\n            sumv[o] = flipv[o]?len-sum:sum;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        SegmentTree t;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == 0) { continue; }\\n            // j is the first non-1 element after i\\n            // flip the segment [i, j-1] of the segment tree \\n            int j = i;\\n            while (j < n && nums1[j] == 1) {++j;}\\n            t.flip(1, 0, n-1, i, j-1);\\n            i = j;\\n        }\\n\\n        vector<long long> ans;\\n        long long sum = accumulate(begin(nums2), end(nums2), 0LL);\\n        for (auto & q: queries) {\\n            int op = q[0];\\n            if      (op == 3) ans.push_back(sum);\\n            else if (op == 2) sum += 1LL*t.query(1, 0, n-1, 0, n-1)*q[1];\\n            else              t.flip(1, 0, n-1, q[1], q[2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\n                 [0,8]\\n        [0,4]            [5,8]\\n    [0,2]    [3,4]   [5,6]   [7,8]\\n [0,1]  [2] [3] [4] [5] [6] [7] [8] \\n[0] [1]\\n```\n```\\n\\nbool flipv[400001]; // tell the range o[L, R] is flipped or not\\nint  sumv[400001];  // tell the sum of o[L, R]\\n\\nclass SegmentTree {\\npublic:\\n    SegmentTree() {\\n        memset(flipv, 0, sizeof(flipv));\\n        memset(sumv, 0, sizeof(sumv));\\n    }\\n\\n    void flip(int o, int L, int R, int x, int y) {\\n        // Flip all the elements in [x, y] on\\n        // node o with a range of [L, R]\\n\\n        // left  child(l): id = o*2,   range = [L, mid]\\n        // right child(r): id = o*2+1, range = [mid+1, R]\\n        int l = o<<1, r = (o<<1)+1;\\n        int mid = (L+R)/2;\\n\\n        if (x <= L && R <= y) {\\n            // case 1: [x, y] covers [L, R]\\n            // 1. directly flip node o[L, R]\\n            // 2. update sumv[o] by maintain\\n            flipv[o] = !flipv[o];\\n        } else {\\n            // case 2: partially overlap\\n            // 1. pushdown the flipv at o first\\n            // 2. update the overlapping segments [L, mid] or/and [mid+1, R]\\n            pushdown(o, L, R);\\n            if (x <= mid) {flip(l, L, mid, x, y);}\\n            if (mid+1<=y) {flip(r, mid+1, R, x, y);}\\n        }\\n        // keep flipv[o], sumv[o] correct\\n        maintain(o, L, R);\\n    }\\n\\n    int query(int o, int L, int R, int x, int y) {\\n        // Query the sum in [x, y] on\\n        // node o with a range of [L, R]\\n\\n        // left  child(l): id = o*2,   range = [L, mid]\\n        // right child(r): id = o*2+1, range = [mid+1, R]\\n        int l = o<<1, r = (o<<1) + 1;\\n        int mid = (L+R)/2, res = 0;\\n        if (x <= L && R <= y) {\\n            res = sumv[o];\\n        } else {\\n            if (x <= mid) {res += query(l, L, mid, x, y);}\\n            if (mid+1<=y) {res += query(r, mid+1, R, x, y);}\\n        }\\n        return res;\\n    }\\nprivate:\\n    void pushdown(int o, int L, int R) {\\n        // If the flip flag for range [L, R] is set \\n        // flip the flags of the two children, and \\n        // maintain the sumv, flipv of them.\\n        // The range o[L,R] is maintained at the end of \\n        // function \"flip\".\\n        if (!flipv[o]) return;\\n        int l = o << 1, r = (o<<1) + 1, mid = (L+R)/2;\\n        flipv[l] = !flipv[l];\\n        flipv[r] = !flipv[r];\\n        maintain(l, L, mid);\\n        maintain(r, mid+1, R);\\n        flipv[o] = 0;\\n    }\\n\\n    void maintain(int o, int L, int R) {\\n        // Make the sum value of the range [L, R] correct\\n        // considering the flip flag of the range [L, R].\\n        // It can be done by summing the left/right child\\n        // of the interval and \\n        // 1. sumv[o] = sumv[l] + sumv[r] if flipv[o] is false\\n        // 2. sumv[o] = len(L, R) - (sumv[l] + sumv[r]) if flipv[o] is true\\n        int len = R-L+1;\\n        if (L == R) {\\n            sumv[o] = flipv[o]?1:0;\\n        } else {\\n            int sum = sumv[o<<1] + sumv[(o<<1)+1];\\n            sumv[o] = flipv[o]?len-sum:sum;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        SegmentTree t;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == 0) { continue; }\\n            // j is the first non-1 element after i\\n            // flip the segment [i, j-1] of the segment tree \\n            int j = i;\\n            while (j < n && nums1[j] == 1) {++j;}\\n            t.flip(1, 0, n-1, i, j-1);\\n            i = j;\\n        }\\n\\n        vector<long long> ans;\\n        long long sum = accumulate(begin(nums2), end(nums2), 0LL);\\n        for (auto & q: queries) {\\n            int op = q[0];\\n            if      (op == 3) ans.push_back(sum);\\n            else if (op == 2) sum += 1LL*t.query(1, 0, n-1, 0, n-1)*q[1];\\n            else              t.flip(1, 0, n-1, q[1], q[2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208331,
                "title": "rust-segment-tree-and-lazy-propagation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) nums2 only contrinutes the the initial sum.\\n2) Let count be the # of 1\\'s in nums1.\\n3) Let cnt be the # of 1 after fliping in the range (inclusively) [l, r], the # of 1\\'s before the fliping is: r - l + 1 - cnt. Therefore, the net change of the count with the flip is - (r - l + 1 - 2 * cnt).\\n4) Type 2 update: sum += count * q[1]  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe most critical step is 3). We use a segment tree Vec<(flag, count)> of lenth 4 * n with lazy propagation to manage the flips. flag: 0 -> even # of flips; 1: odd # of flips. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn handle_query(nums1: Vec<i32>, nums2: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i64> {\\n        let n = nums1.len();\\n        let mut count = nums1.iter().map(|a| *a as i64).sum::<i64>();\\n        let mut sum = nums2.iter().map(|a| *a as i64).sum::<i64>();\\n        let mut tree = vec![(0, 0); n * 4];\\n\\n        for i in 0 .. n { \\n            if nums1[i] == 1 { Self::add(1, 0, n - 1, i, &mut tree); }\\n        }\\n\\n        let mut ret = vec![];\\n        for q in queries {\\n            if q[0] == 1 { \\n                let cnt = Self::update(1, 0, n - 1, q[1] as usize, q[2] as usize, &mut tree);\\n                count -= q[2] as i64 - q[1] as i64 + 1 - 2 * cnt as i64;\\n                continue;\\n            }\\n            if q[0] == 2 { sum += count * q[1] as i64; }\\n            else { ret.push(sum); }\\n        }\\n\\n        ret\\n    }\\n\\n    // for setting up the tree with data from nums1\\n    fn add(u: usize, left: usize, right: usize, i: usize, tree: &mut Vec<(i32, usize)>) {\\n        if left == right {\\n            tree[u].1 = 1;\\n            return \\n        }\\n\\n        let mid = left + (right - left) / 2;\\n        if i <= mid { Self::add(2 * u, left, mid, i, tree); }\\n        else        { Self::add(2 * u + 1, mid + 1, right, i, tree); }\\n        \\n        tree[u].1 = tree[2 * u].1 + tree[2 * u + 1].1; \\n    }\\n\\n    // performing the flip in range [l, r] & \\n    // return the # of 1\\'s after the flip \\n    fn update(u: usize, left: usize, right: usize, l: usize, r: usize, tree: &mut Vec<(i32, usize)>) -> i32 {\\n        if left >= l && right <= r {\\n            // no need tp progagate as all leaf nodes share the same flip info\\n            tree[u].0 = 1 - tree[u].0;\\n            if tree[u].0 == 0 { return tree[u].1 as i32 }\\n            return right as i32 - left as i32 + 1 - tree[u].1 as i32\\n        }\\n\\n        if left > r || right < l { return 0 }\\n        \\n        // Need to propagate as flip info only applies to \\n        // a subrange of [left, right].\\n        // need to push down the existing flip info for caculating \\n        // the right # of 1\\'s in the targeted range [l, r].\\n        if tree[u].0 == 1 {\\n            tree[2 * u].0 = 1 - tree[2 * u].0;\\n            tree[2 * u + 1].0 = 1 - tree[2 * u + 1].0;\\n            tree[u].0 = 0;\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n        let ret1 = Self::update(2 * u, left, mid, l, r, tree);\\n        let ret2 = Self::update(2 * u + 1, mid + 1, right, l, r, tree);\\n    \\n        tree[u].1 = if tree[2 * u].0 == 0 { tree[2 * u].1 } \\n                    else { mid - left + 1 - tree[2 * u].1 };\\n        tree[u].1 += if tree[2 * u + 1].0 == 0 { tree[2 * u + 1].1 }\\n                     else { right - mid - tree[2 * u + 1].1 };\\n\\n        ret1 + ret2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn handle_query(nums1: Vec<i32>, nums2: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i64> {\\n        let n = nums1.len();\\n        let mut count = nums1.iter().map(|a| *a as i64).sum::<i64>();\\n        let mut sum = nums2.iter().map(|a| *a as i64).sum::<i64>();\\n        let mut tree = vec![(0, 0); n * 4];\\n\\n        for i in 0 .. n { \\n            if nums1[i] == 1 { Self::add(1, 0, n - 1, i, &mut tree); }\\n        }\\n\\n        let mut ret = vec![];\\n        for q in queries {\\n            if q[0] == 1 { \\n                let cnt = Self::update(1, 0, n - 1, q[1] as usize, q[2] as usize, &mut tree);\\n                count -= q[2] as i64 - q[1] as i64 + 1 - 2 * cnt as i64;\\n                continue;\\n            }\\n            if q[0] == 2 { sum += count * q[1] as i64; }\\n            else { ret.push(sum); }\\n        }\\n\\n        ret\\n    }\\n\\n    // for setting up the tree with data from nums1\\n    fn add(u: usize, left: usize, right: usize, i: usize, tree: &mut Vec<(i32, usize)>) {\\n        if left == right {\\n            tree[u].1 = 1;\\n            return \\n        }\\n\\n        let mid = left + (right - left) / 2;\\n        if i <= mid { Self::add(2 * u, left, mid, i, tree); }\\n        else        { Self::add(2 * u + 1, mid + 1, right, i, tree); }\\n        \\n        tree[u].1 = tree[2 * u].1 + tree[2 * u + 1].1; \\n    }\\n\\n    // performing the flip in range [l, r] & \\n    // return the # of 1\\'s after the flip \\n    fn update(u: usize, left: usize, right: usize, l: usize, r: usize, tree: &mut Vec<(i32, usize)>) -> i32 {\\n        if left >= l && right <= r {\\n            // no need tp progagate as all leaf nodes share the same flip info\\n            tree[u].0 = 1 - tree[u].0;\\n            if tree[u].0 == 0 { return tree[u].1 as i32 }\\n            return right as i32 - left as i32 + 1 - tree[u].1 as i32\\n        }\\n\\n        if left > r || right < l { return 0 }\\n        \\n        // Need to propagate as flip info only applies to \\n        // a subrange of [left, right].\\n        // need to push down the existing flip info for caculating \\n        // the right # of 1\\'s in the targeted range [l, r].\\n        if tree[u].0 == 1 {\\n            tree[2 * u].0 = 1 - tree[2 * u].0;\\n            tree[2 * u + 1].0 = 1 - tree[2 * u + 1].0;\\n            tree[u].0 = 0;\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n        let ret1 = Self::update(2 * u, left, mid, l, r, tree);\\n        let ret2 = Self::update(2 * u + 1, mid + 1, right, l, r, tree);\\n    \\n        tree[u].1 = if tree[2 * u].0 == 0 { tree[2 * u].1 } \\n                    else { mid - left + 1 - tree[2 * u].1 };\\n        tree[u].1 += if tree[2 * u + 1].0 == 0 { tree[2 * u + 1].1 }\\n                     else { right - mid - tree[2 * u + 1].1 };\\n\\n        ret1 + ret2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3207730,
                "title": "c-clean-implementation-of-lazysegmenttree-no-hack-code",
                "content": "```\\nclass LazySegmentTree {\\n public:\\n  explicit LazySegmentTree(const vector<int>& nums) {\\n    const int n = nums.size();\\n    tree.resize(4 * n);\\n    lazy.resize(4 * n);\\n    build(nums, 0, 0, n - 1);\\n  }\\n\\n  //            i := index of the current node.\\n  // [start, end] := range of the current node.\\n  //       [l, r] := range of the query.\\n  void updateRange(int i, int start, int end, int l, int r) {\\n    if (lazy[i])\\n      propogate(i, start, end);\\n    if (start > r || end < l)\\n      return;\\n    if (start >= l && end <= r) {\\n      flip(i, start, end);\\n      return;\\n    }\\n    const int mid = (start + end) / 2;\\n    updateRange(i * 2 + 1, start, mid, l, r);\\n    updateRange(i * 2 + 2, mid + 1, end, l, r);\\n    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n  }\\n\\n  int getTreeSum() const {\\n    return tree[0];\\n  }\\n\\n private:\\n  vector<int> tree;\\n  vector<bool> lazy;\\n\\n  void build(const vector<int>& nums, int i, int start, int end) {\\n    if (start == end) {\\n      tree[i] = nums[start];\\n      return;\\n    }\\n    const int mid = (start + end) / 2;\\n    build(nums, 2 * i + 1, start, mid);\\n    build(nums, 2 * i + 2, mid + 1, end);\\n    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n  }\\n\\n  void propogate(int i, int start, int end) {\\n    flip(i, start, end);\\n    lazy[i] = false;\\n  }\\n\\n  void flip(int i, int start, int end) {\\n    tree[i] = (end - start + 1) - tree[i];  // Flip 0/1.\\n    if (start != end) {\\n      lazy[2 * i + 1] = !lazy[2 * i + 1];\\n      lazy[2 * i + 2] = !lazy[2 * i + 2];\\n    }\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2,\\n                                vector<vector<int>>& queries) {\\n    vector<long long> ans;\\n    LazySegmentTree tree(nums1);\\n    long long sumNums2 = accumulate(begin(nums2), end(nums2), 0LL);\\n\\n    for (const vector<int>& query : queries) {\\n      const int type = query[0];\\n      const int l = query[1];\\n      const int r = query[2];\\n      if (type == 1) {\\n        tree.updateRange(0, 0, nums1.size() - 1, l, r);\\n      } else if (type == 2) {\\n        sumNums2 += static_cast<long long>(l) * tree.getTreeSum();\\n      } else {  // type == 3\\n        ans.push_back(sumNums2);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass LazySegmentTree {\\n public:\\n  explicit LazySegmentTree(const vector<int>& nums) {\\n    const int n = nums.size();\\n    tree.resize(4 * n);\\n    lazy.resize(4 * n);\\n    build(nums, 0, 0, n - 1);\\n  }\\n\\n  //            i := index of the current node.\\n  // [start, end] := range of the current node.\\n  //       [l, r] := range of the query.\\n  void updateRange(int i, int start, int end, int l, int r) {\\n    if (lazy[i])\\n      propogate(i, start, end);\\n    if (start > r || end < l)\\n      return;\\n    if (start >= l && end <= r) {\\n      flip(i, start, end);\\n      return;\\n    }\\n    const int mid = (start + end) / 2;\\n    updateRange(i * 2 + 1, start, mid, l, r);\\n    updateRange(i * 2 + 2, mid + 1, end, l, r);\\n    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n  }\\n\\n  int getTreeSum() const {\\n    return tree[0];\\n  }\\n\\n private:\\n  vector<int> tree;\\n  vector<bool> lazy;\\n\\n  void build(const vector<int>& nums, int i, int start, int end) {\\n    if (start == end) {\\n      tree[i] = nums[start];\\n      return;\\n    }\\n    const int mid = (start + end) / 2;\\n    build(nums, 2 * i + 1, start, mid);\\n    build(nums, 2 * i + 2, mid + 1, end);\\n    tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n  }\\n\\n  void propogate(int i, int start, int end) {\\n    flip(i, start, end);\\n    lazy[i] = false;\\n  }\\n\\n  void flip(int i, int start, int end) {\\n    tree[i] = (end - start + 1) - tree[i];  // Flip 0/1.\\n    if (start != end) {\\n      lazy[2 * i + 1] = !lazy[2 * i + 1];\\n      lazy[2 * i + 2] = !lazy[2 * i + 2];\\n    }\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2,\\n                                vector<vector<int>>& queries) {\\n    vector<long long> ans;\\n    LazySegmentTree tree(nums1);\\n    long long sumNums2 = accumulate(begin(nums2), end(nums2), 0LL);\\n\\n    for (const vector<int>& query : queries) {\\n      const int type = query[0];\\n      const int l = query[1];\\n      const int r = query[2];\\n      if (type == 1) {\\n        tree.updateRange(0, 0, nums1.size() - 1, l, r);\\n      } else if (type == 2) {\\n        sumNums2 += static_cast<long long>(l) * tree.getTreeSum();\\n      } else {  // type == 3\\n        ans.push_back(sumNums2);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206458,
                "title": "segment-tree-to-get-number-of-ones-in-range-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfirstly bulid segmenttree with 0,1 \\n, get sumOfNumbers in nums2\\n,fisrt query flip all 1 to 0, all 0 to 1 , \\nhow to make this?\\nupdate range query with lazy propagation \\nif we have this array {0,1,1,1,0}\\nnumber of ones in range from 1 to a.length \\n3,if we flip this range that\\'s mean number of ones became (r-l+1)-currnetnumber of ones \\nlets make this and now we can get numberOfOnesInRange and multiply it by P and add it to sumOfNumbers in nums2\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static long seg[], lazy[];\\n\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        seg = new long[nums1.length * 4];\\n        lazy = new long[nums1.length * 4];\\n        int n = nums1.length;\\n        long a[] = new long[nums1.length + 1];\\n        ArrayList<Long> res = new ArrayList<>();\\n        for (int i = 1; i <= nums1.length; i++) {\\n            a[i] = nums1[i - 1];\\n        }\\n        build(1, 1, n, a);\\n        long sum = 0;\\n        for (int i = 0; i < nums2.length; i++) {\\n            sum += (long) nums2[i];\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            if (queries[i][0] == 1) {\\n                updateRange(1, 1, n, queries[i][1] + 1, queries[i][2] + 1, 1);\\n            } else if (queries[i][0] == 2) {\\n                long s = sumInRange(1, 1, n, 1, n);\\n                \\n                sum += s * (long) queries[i][1];\\n            } else {\\n                res.add(sum);\\n            }\\n        }\\n        long ans[] = new long[res.size()];\\n        for (int i = 0; i < res.size(); i++) {\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n\\n    static void build(int idx, int s, int e, long a[]) {\\n        if (s == e) {\\n            seg[idx] = a[s];\\n            return;\\n        }\\n        build(idx * 2, s, (s + e) / 2, a);\\n        build(idx * 2 + 1, (s + e) / 2 + 1, e, a);\\n        seg[idx] = seg[idx * 2] + seg[idx * 2 + 1];\\n\\n    }\\n\\n    static void process(int idx, int s, int e) {\\n        if (lazy[idx] % 2 == 1) {\\n            seg[idx] = (e - s + 1) - (seg[idx]);\\n        }\\n        if (s < e) {\\n            lazy[idx * 2] += lazy[idx];\\n            lazy[idx * 2 + 1] += lazy[idx];\\n        }\\n        lazy[idx] = 0;\\n    }\\n\\n    static void updateRange(int idx, int s, int e, int l, int r, long val) {\\n        process(idx, s, e);\\n        if ((l > e) || s > r) {\\n            return;\\n        }\\n        if (s >= l && e <= r) {\\n            lazy[idx] += val;\\n            process(idx, s, e);\\n            return;\\n        }\\n        updateRange(idx * 2, s, (s + e) / 2, l, r, val);\\n        updateRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r, val);\\n        seg[idx] = (seg[idx * 2] + seg[idx * 2 + 1]);\\n    }\\n\\n    static long sumInRange(int idx, int s, int e, int l, int r) {\\n        process(idx, s, e);\\n        if ((l > e) || s > r) {\\n            return 0;\\n        }\\n        if (s >= l && e <= r) {\\n            return seg[idx];\\n        }\\n        return (sumInRange(idx * 2, s, (s + e) / 2, l, r) + sumInRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r));\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static long seg[], lazy[];\\n\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        seg = new long[nums1.length * 4];\\n        lazy = new long[nums1.length * 4];\\n        int n = nums1.length;\\n        long a[] = new long[nums1.length + 1];\\n        ArrayList<Long> res = new ArrayList<>();\\n        for (int i = 1; i <= nums1.length; i++) {\\n            a[i] = nums1[i - 1];\\n        }\\n        build(1, 1, n, a);\\n        long sum = 0;\\n        for (int i = 0; i < nums2.length; i++) {\\n            sum += (long) nums2[i];\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            if (queries[i][0] == 1) {\\n                updateRange(1, 1, n, queries[i][1] + 1, queries[i][2] + 1, 1);\\n            } else if (queries[i][0] == 2) {\\n                long s = sumInRange(1, 1, n, 1, n);\\n                \\n                sum += s * (long) queries[i][1];\\n            } else {\\n                res.add(sum);\\n            }\\n        }\\n        long ans[] = new long[res.size()];\\n        for (int i = 0; i < res.size(); i++) {\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n\\n    static void build(int idx, int s, int e, long a[]) {\\n        if (s == e) {\\n            seg[idx] = a[s];\\n            return;\\n        }\\n        build(idx * 2, s, (s + e) / 2, a);\\n        build(idx * 2 + 1, (s + e) / 2 + 1, e, a);\\n        seg[idx] = seg[idx * 2] + seg[idx * 2 + 1];\\n\\n    }\\n\\n    static void process(int idx, int s, int e) {\\n        if (lazy[idx] % 2 == 1) {\\n            seg[idx] = (e - s + 1) - (seg[idx]);\\n        }\\n        if (s < e) {\\n            lazy[idx * 2] += lazy[idx];\\n            lazy[idx * 2 + 1] += lazy[idx];\\n        }\\n        lazy[idx] = 0;\\n    }\\n\\n    static void updateRange(int idx, int s, int e, int l, int r, long val) {\\n        process(idx, s, e);\\n        if ((l > e) || s > r) {\\n            return;\\n        }\\n        if (s >= l && e <= r) {\\n            lazy[idx] += val;\\n            process(idx, s, e);\\n            return;\\n        }\\n        updateRange(idx * 2, s, (s + e) / 2, l, r, val);\\n        updateRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r, val);\\n        seg[idx] = (seg[idx * 2] + seg[idx * 2 + 1]);\\n    }\\n\\n    static long sumInRange(int idx, int s, int e, int l, int r) {\\n        process(idx, s, e);\\n        if ((l > e) || s > r) {\\n            return 0;\\n        }\\n        if (s >= l && e <= r) {\\n            return seg[idx];\\n        }\\n        return (sumInRange(idx * 2, s, (s + e) / 2, l, r) + sumInRange(idx * 2 + 1, (s + e) / 2 + 1, e, l, r));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205230,
                "title": "sqrt-root-decomposition-with-lazy-updates-java-easy-to-undertand",
                "content": "# Intuition\\nMy first intution was we need to solve only for query 1, because query2 and query3 are simply just calculation and returning the sum of the entire array\\n\\n# Approach\\nSquare Root Decomposition with lazy updates\\n\\n# Complexity\\n- Time complexity:\\nO(q * sqrt(n))\\n\\n- Space complexity:\\nO(sqrt(n))\\n\\n# Code\\n```\\nclass Solution {\\n    static class Structure {\\n        int n;\\n        int ones;\\n        int zeroes;\\n        int numberOfBlocks;\\n        List<Block> blocks;\\n        int[] a;\\n\\n        public Structure(int n, int[] a) {\\n            this.n = n;\\n            this.a = a;\\n            this.ones = 0;\\n            this.zeroes = 0;\\n            this.numberOfBlocks = (int)Math.ceil(Math.sqrt((double)n));\\n\\n            blocks = new ArrayList<>();\\n\\n            buildBlocks();\\n        }\\n\\n        private void buildBlocks() {\\n            for (int itr = 0; itr < numberOfBlocks; ++itr) {\\n                blocks.add(new Block(itr, n, a, numberOfBlocks));\\n\\n                updateOnesAndZeroes(blocks.get(itr), 1);\\n            }\\n        }\\n\\n        public void update(int l, int r) {\\n            int index = l / numberOfBlocks;\\n            int current = l;\\n\\n            while (current <= r) {\\n                Block block = blocks.get(index);\\n\\n                updateOnesAndZeroes(block, -1);\\n\\n                if (block.start == current && block.end <= r) {\\n                    block.lazyUpdate();\\n                }\\n                else {\\n                    block.realUpdate(current, Math.min(block.end, r));\\n                }\\n\\n                updateOnesAndZeroes(block, 1);\\n\\n                index++;\\n                current = index * numberOfBlocks;\\n            }\\n        }\\n\\n        private void updateOnesAndZeroes(Block block, int mul) {\\n                ones = ones + block.ones * mul;\\n                zeroes = zeroes + block.zeroes * mul;\\n        }\\n    }\\n\\n    static class Block {\\n        int index;\\n        int n;\\n        int size;\\n        int start;\\n        int end;\\n        int ones;\\n        int zeroes;\\n        boolean lazy;\\n        int[] a;\\n\\n        public Block(int index, int n, int[] a, int size) {\\n            this.index = index;\\n            this.n = n;\\n            this.a = a;\\n            this.size = Math.min(size, n - (index * size));\\n\\n            start = index * size;\\n            end = start + this.size - 1;\\n            lazy = false;\\n\\n            buildBlock();\\n        }\\n\\n        public void lazyUpdate() {\\n            swapOnesAndZeroes();\\n            lazy = !lazy;\\n        }\\n\\n        public void realUpdate(int l, int r) {\\n            if (lazy) {\\n                lazy = !lazy;\\n                flipBits(start, end);\\n            }\\n            \\n            flipBits(l ,r);\\n\\n            buildBlock();\\n        }\\n\\n        private void flipBits(int l, int r) {\\n            for (int itr = l; itr <= r; ++itr) {\\n                a[itr] = a[itr] ^ 1;\\n            }\\n        }\\n\\n        private void buildBlock() {\\n            ones = 0;\\n            zeroes = 0;\\n\\n            for (int itr = start; itr <= end; itr++) {\\n                if (a[itr] == 0) {\\n                    zeroes++;\\n                }\\n                else {\\n                    ones++;\\n                }\\n            }\\n        }\\n\\n        private void swapOnesAndZeroes() {\\n            int temp = ones;\\n            ones = zeroes;\\n            zeroes = temp;\\n        }\\n    }\\n\\n    public long[] handleQuery(int[] a, int[] b, int[][] queries) {\\n        List<Long> ans = new ArrayList<>();\\n        Structure structure = new Structure(a.length, a);\\n        long sum = (long)0;\\n\\n        for (int num : b) {\\n            sum = sum + num;\\n        }\\n\\n        for (int[] query : queries) {\\n            switch (query[0]) {\\n                case 1 : structure.update(query[1], query[2]); break;\\n                case 2 : sum = sum + (long)query[1] * (structure.ones); break;\\n                case 3 : ans.add(sum);\\n            }\\n        }\\n\\n        return convertToArray(ans);\\n    }\\n\\n    private long[] convertToArray(List<Long> al) {\\n        long result[] = new long[al.size()];\\n\\n        for (int itr = 0; itr < al.size(); ++itr) {\\n            result[itr] = al.get(itr);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static class Structure {\\n        int n;\\n        int ones;\\n        int zeroes;\\n        int numberOfBlocks;\\n        List<Block> blocks;\\n        int[] a;\\n\\n        public Structure(int n, int[] a) {\\n            this.n = n;\\n            this.a = a;\\n            this.ones = 0;\\n            this.zeroes = 0;\\n            this.numberOfBlocks = (int)Math.ceil(Math.sqrt((double)n));\\n\\n            blocks = new ArrayList<>();\\n\\n            buildBlocks();\\n        }\\n\\n        private void buildBlocks() {\\n            for (int itr = 0; itr < numberOfBlocks; ++itr) {\\n                blocks.add(new Block(itr, n, a, numberOfBlocks));\\n\\n                updateOnesAndZeroes(blocks.get(itr), 1);\\n            }\\n        }\\n\\n        public void update(int l, int r) {\\n            int index = l / numberOfBlocks;\\n            int current = l;\\n\\n            while (current <= r) {\\n                Block block = blocks.get(index);\\n\\n                updateOnesAndZeroes(block, -1);\\n\\n                if (block.start == current && block.end <= r) {\\n                    block.lazyUpdate();\\n                }\\n                else {\\n                    block.realUpdate(current, Math.min(block.end, r));\\n                }\\n\\n                updateOnesAndZeroes(block, 1);\\n\\n                index++;\\n                current = index * numberOfBlocks;\\n            }\\n        }\\n\\n        private void updateOnesAndZeroes(Block block, int mul) {\\n                ones = ones + block.ones * mul;\\n                zeroes = zeroes + block.zeroes * mul;\\n        }\\n    }\\n\\n    static class Block {\\n        int index;\\n        int n;\\n        int size;\\n        int start;\\n        int end;\\n        int ones;\\n        int zeroes;\\n        boolean lazy;\\n        int[] a;\\n\\n        public Block(int index, int n, int[] a, int size) {\\n            this.index = index;\\n            this.n = n;\\n            this.a = a;\\n            this.size = Math.min(size, n - (index * size));\\n\\n            start = index * size;\\n            end = start + this.size - 1;\\n            lazy = false;\\n\\n            buildBlock();\\n        }\\n\\n        public void lazyUpdate() {\\n            swapOnesAndZeroes();\\n            lazy = !lazy;\\n        }\\n\\n        public void realUpdate(int l, int r) {\\n            if (lazy) {\\n                lazy = !lazy;\\n                flipBits(start, end);\\n            }\\n            \\n            flipBits(l ,r);\\n\\n            buildBlock();\\n        }\\n\\n        private void flipBits(int l, int r) {\\n            for (int itr = l; itr <= r; ++itr) {\\n                a[itr] = a[itr] ^ 1;\\n            }\\n        }\\n\\n        private void buildBlock() {\\n            ones = 0;\\n            zeroes = 0;\\n\\n            for (int itr = start; itr <= end; itr++) {\\n                if (a[itr] == 0) {\\n                    zeroes++;\\n                }\\n                else {\\n                    ones++;\\n                }\\n            }\\n        }\\n\\n        private void swapOnesAndZeroes() {\\n            int temp = ones;\\n            ones = zeroes;\\n            zeroes = temp;\\n        }\\n    }\\n\\n    public long[] handleQuery(int[] a, int[] b, int[][] queries) {\\n        List<Long> ans = new ArrayList<>();\\n        Structure structure = new Structure(a.length, a);\\n        long sum = (long)0;\\n\\n        for (int num : b) {\\n            sum = sum + num;\\n        }\\n\\n        for (int[] query : queries) {\\n            switch (query[0]) {\\n                case 1 : structure.update(query[1], query[2]); break;\\n                case 2 : sum = sum + (long)query[1] * (structure.ones); break;\\n                case 3 : ans.add(sum);\\n            }\\n        }\\n\\n        return convertToArray(ans);\\n    }\\n\\n    private long[] convertToArray(List<Long> al) {\\n        long result[] = new long[al.size()];\\n\\n        for (int itr = 0; itr < al.size(); ++itr) {\\n            result[itr] = al.get(itr);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205043,
                "title": "c-lazy-propagation-segment-trees",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<long long> tree;\\n    vector<bool> lazy;\\npublic:\\n    void build(vector<int> &bits, long long start, long long end, long long parent){\\n        if(start==end){\\n            tree[parent]=bits[start];\\n            return;\\n        }\\n        long long mid=(start+end)/2;\\n        build(bits,start,mid,2*parent+1);\\n        build(bits,mid+1,end,2*parent+2);\\n        tree[parent]=tree[2*parent+1]+tree[2*parent+2];\\n    }\\n    \\n    void querySolver(long long start, long long end, long long qstart, long long qend, long long parent){\\n        if(start>end){\\n            return;\\n        }\\n\\n        if(lazy[parent]==true){ // lazy happened\\n            long long totalBits=end-start+1;\\n            tree[parent]=totalBits-tree[parent];\\n            if(start!=end){\\n                lazy[2*parent+1]=!lazy[2*parent+1];\\n                lazy[2*parent+2]=!lazy[2*parent+2];\\n            }\\n            lazy[parent]=false;\\n        }\\n        \\n        if(qstart>end || qend<start){ // no overlapping\\n            return;\\n        }\\n        \\n        if(qstart<=start && qend>=end){  // lazy work\\n            long long totalBits=end-start+1;\\n            tree[parent]=totalBits-tree[parent];\\n            if(start!=end){\\n                lazy[2*parent+1]=!lazy[2*parent+1];\\n                lazy[2*parent+2]=!lazy[2*parent+2];\\n            }\\n            return;\\n        }\\n        \\n        long long mid=(start+end)/2;\\n        querySolver(start,mid,qstart,qend,2*parent+1);\\n        querySolver(mid+1,end,qstart,qend,2*parent+2);\\n        tree[parent]=tree[2*parent+1]+tree[2*parent+2];\\n    }\\n    \\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        /*\\n\\t\\tThe second query says:-\\n\\t\\tnums2[i]=nums2[i]+nums1[i]*p\\n\\t\\t\\n\\t\\tElaborating...\\n\\t\\t        (nums2[0] + nums1[0]*p) + (nums2[1] + nums1[1]*p) + ........\\n\\t\\t\\t\\tCollecting nums2 and nums1 together..\\n                (nums2[0]+nums2[1]+...) + (nums1[0]+nums1[1]+...) *p\\n                summation(nums2) + summation(nums1)*p\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSo the answer for queries can be given if you can efficiently count the sum of\\n\\t\\t\\t\\tnums1 after each update (l,r). nums2 sum is just updated by the new sum.\\n        */\\n        long long n=nums1.size();\\n        lazy.resize(4*n+1);\\n        tree.resize(4*n+1,false);\\n\\n        build(nums1,0,n-1,0);\\n        \\n        long long sum_nums2=accumulate(nums2.begin(),nums2.end(),0LL);\\n        \\n        vector<long long> res;\\n        \\n        for(auto query: queries){\\n            long long type=query[0];\\n            if(type==1){\\n                long long l=query[1];\\n                long long r=query[2];\\n                querySolver(0,n-1,l,r,0);               \\n            }\\n            if(type==2){\\n                long long p=query[1];\\n                long long newSum=sum_nums2+tree[0]*p;\\n                sum_nums2=newSum;\\n            }\\n            if(type==3){\\n                res.push_back(sum_nums2);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<long long> tree;\\n    vector<bool> lazy;\\npublic:\\n    void build(vector<int> &bits, long long start, long long end, long long parent){\\n        if(start==end){\\n            tree[parent]=bits[start];\\n            return;\\n        }\\n        long long mid=(start+end)/2;\\n        build(bits,start,mid,2*parent+1);\\n        build(bits,mid+1,end,2*parent+2);\\n        tree[parent]=tree[2*parent+1]+tree[2*parent+2];\\n    }\\n    \\n    void querySolver(long long start, long long end, long long qstart, long long qend, long long parent){\\n        if(start>end){\\n            return;\\n        }\\n\\n        if(lazy[parent]==true){ // lazy happened\\n            long long totalBits=end-start+1;\\n            tree[parent]=totalBits-tree[parent];\\n            if(start!=end){\\n                lazy[2*parent+1]=!lazy[2*parent+1];\\n                lazy[2*parent+2]=!lazy[2*parent+2];\\n            }\\n            lazy[parent]=false;\\n        }\\n        \\n        if(qstart>end || qend<start){ // no overlapping\\n            return;\\n        }\\n        \\n        if(qstart<=start && qend>=end){  // lazy work\\n            long long totalBits=end-start+1;\\n            tree[parent]=totalBits-tree[parent];\\n            if(start!=end){\\n                lazy[2*parent+1]=!lazy[2*parent+1];\\n                lazy[2*parent+2]=!lazy[2*parent+2];\\n            }\\n            return;\\n        }\\n        \\n        long long mid=(start+end)/2;\\n        querySolver(start,mid,qstart,qend,2*parent+1);\\n        querySolver(mid+1,end,qstart,qend,2*parent+2);\\n        tree[parent]=tree[2*parent+1]+tree[2*parent+2];\\n    }\\n    \\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        /*\\n\\t\\tThe second query says:-\\n\\t\\tnums2[i]=nums2[i]+nums1[i]*p\\n\\t\\t\\n\\t\\tElaborating...\\n\\t\\t        (nums2[0] + nums1[0]*p) + (nums2[1] + nums1[1]*p) + ........\\n\\t\\t\\t\\tCollecting nums2 and nums1 together..\\n                (nums2[0]+nums2[1]+...) + (nums1[0]+nums1[1]+...) *p\\n                summation(nums2) + summation(nums1)*p\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSo the answer for queries can be given if you can efficiently count the sum of\\n\\t\\t\\t\\tnums1 after each update (l,r). nums2 sum is just updated by the new sum.\\n        */\\n        long long n=nums1.size();\\n        lazy.resize(4*n+1);\\n        tree.resize(4*n+1,false);\\n\\n        build(nums1,0,n-1,0);\\n        \\n        long long sum_nums2=accumulate(nums2.begin(),nums2.end(),0LL);\\n        \\n        vector<long long> res;\\n        \\n        for(auto query: queries){\\n            long long type=query[0];\\n            if(type==1){\\n                long long l=query[1];\\n                long long r=query[2];\\n                querySolver(0,n-1,l,r,0);               \\n            }\\n            if(type==2){\\n                long long p=query[1];\\n                long long newSum=sum_nums2+tree[0]*p;\\n                sum_nums2=newSum;\\n            }\\n            if(type==3){\\n                res.push_back(sum_nums2);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204943,
                "title": "segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSegment tree \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTop down Segment tree\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct node {\\n    int sum = 0;\\n    int flip = 0;\\n    int getsum(int len) {\\n        if (flip) return len - sum;\\n        return sum;\\n    }\\n};\\nclass tree {\\n    public:\\n    int n;\\n    int c;\\n    vector<node> dp;\\n    int base = 1;\\n    int init(vector<int>& nums1) {\\n        n = nums1.size();\\n        c = n * 4 + 1;\\n        int l = 0;\\n        int r = n - 1;\\n        dp.resize(c);\\n        return build(nums1, l, r, 1);\\n    }\\n\\n    int build(vector<int>& nums, int l, int r, int p) {\\n        if (l == r) {\\n            dp[p].sum = nums[l];\\n            dp[p].flip = 0;\\n            return dp[p].sum;\\n        }\\n        int m = (l + r) / 2;\\n        int ls = build(nums, l, m, p * 2);\\n        int rs = build(nums, m + 1, r, p * 2 + 1);\\n        dp[p].sum = ls + rs;\\n        dp[p].flip = 0;\\n        return dp[p].sum;\\n    }\\n    int getsum() {\\n        return dp[base].getsum(n);\\n    }\\n\\n    int flip(int l, int r, int x, int y, int p, int f) {\\n        int sum = 0;\\n        int len = r - l + 1;\\n        if (x > r || y < l) {\\n            dp[p].flip = dp[p].flip ^ f;\\n            return dp[p].getsum(len);\\n        }\\n        else if (x <= l && r <= y) {\\n            dp[p].flip = dp[p].flip ^ f ^ 1;\\n            return dp[p].getsum(len);\\n        }\\n        int m = (l + r) / 2; \\n\\n        int ls = flip(l, m, x, y, p * 2, f ^ dp[p].flip);\\n        int rs = flip(m + 1, r, x, y, p * 2 + 1, f ^ dp[p].flip);\\n        dp[p].flip = 0;\\n        dp[p].sum = ls + rs;\\n        return dp[p].sum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& qs) {\\n        n = nums1.size();\\n        vector<long long> ans;\\n        tree seg;\\n        seg.init(nums1);\\n        long long sum = 0;\\n        for (auto v : nums2) sum += v;\\n        for (auto& q : qs) {\\n            if (q[0] == 1) {\\n                seg.flip(0, n -1, q[1], q[2], 1, 0);\\n            } else if (q[0] == 2) {\\n                sum = (long long)seg.getsum() * (long long)q[1] + sum;\\n            } else if (q[0] == 3) {\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n        \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct node {\\n    int sum = 0;\\n    int flip = 0;\\n    int getsum(int len) {\\n        if (flip) return len - sum;\\n        return sum;\\n    }\\n};\\nclass tree {\\n    public:\\n    int n;\\n    int c;\\n    vector<node> dp;\\n    int base = 1;\\n    int init(vector<int>& nums1) {\\n        n = nums1.size();\\n        c = n * 4 + 1;\\n        int l = 0;\\n        int r = n - 1;\\n        dp.resize(c);\\n        return build(nums1, l, r, 1);\\n    }\\n\\n    int build(vector<int>& nums, int l, int r, int p) {\\n        if (l == r) {\\n            dp[p].sum = nums[l];\\n            dp[p].flip = 0;\\n            return dp[p].sum;\\n        }\\n        int m = (l + r) / 2;\\n        int ls = build(nums, l, m, p * 2);\\n        int rs = build(nums, m + 1, r, p * 2 + 1);\\n        dp[p].sum = ls + rs;\\n        dp[p].flip = 0;\\n        return dp[p].sum;\\n    }\\n    int getsum() {\\n        return dp[base].getsum(n);\\n    }\\n\\n    int flip(int l, int r, int x, int y, int p, int f) {\\n        int sum = 0;\\n        int len = r - l + 1;\\n        if (x > r || y < l) {\\n            dp[p].flip = dp[p].flip ^ f;\\n            return dp[p].getsum(len);\\n        }\\n        else if (x <= l && r <= y) {\\n            dp[p].flip = dp[p].flip ^ f ^ 1;\\n            return dp[p].getsum(len);\\n        }\\n        int m = (l + r) / 2; \\n\\n        int ls = flip(l, m, x, y, p * 2, f ^ dp[p].flip);\\n        int rs = flip(m + 1, r, x, y, p * 2 + 1, f ^ dp[p].flip);\\n        dp[p].flip = 0;\\n        dp[p].sum = ls + rs;\\n        return dp[p].sum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& qs) {\\n        n = nums1.size();\\n        vector<long long> ans;\\n        tree seg;\\n        seg.init(nums1);\\n        long long sum = 0;\\n        for (auto v : nums2) sum += v;\\n        for (auto& q : qs) {\\n            if (q[0] == 1) {\\n                seg.flip(0, n -1, q[1], q[2], 1, 0);\\n            } else if (q[0] == 2) {\\n                sum = (long long)seg.getsum() * (long long)q[1] + sum;\\n            } else if (q[0] == 3) {\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n        \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204357,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn handle_query(nums1: Vec<i32>, nums2: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i64> {\\n        fn build(arr: &Vec<i64>, n: usize, a: usize, b: usize, tree: &mut Vec<i64>) -> i64 {\\n            if a == b {\\n                tree[n] = arr[a];\\n                return tree[n];\\n            }\\n            tree[n] = build(arr, 2 * n, a, (a + b) / 2, tree) + build(arr, 2 * n + 1, (a + b) / 2 + 1, b, tree);\\n            tree[n]\\n        }\\n\\n        fn update_tree(n: usize, a: i64, b: i64, i: i64, j: i64, tree: &mut Vec<i64>, lazy: &mut Vec<i64>) -> i64 {\\n            if b < i || a > j {\\n                return if lazy[n] == 1 { b - a + 1 - tree[n] } else { tree[n] };\\n            }\\n            if lazy[n] == 1 {\\n                tree[n] = b - a + 1 - tree[n];\\n                if a != b {\\n                    lazy[2 * n] = 1 - lazy[2 * n];\\n                    lazy[2 * n + 1] = 1 - lazy[2 * n + 1];\\n                }\\n                lazy[n] = 0;\\n            }\\n            if a >= i && b <= j {\\n                if a != b {\\n                    lazy[2 * n] = 1 - lazy[2 * n];\\n                    lazy[2 * n + 1] = 1 - lazy[2 * n + 1];\\n                }\\n                tree[n] = b - a + 1 - tree[n];\\n                return tree[n];\\n            }\\n            tree[n] = update_tree(2 * n, a, (a + b) / 2, i, j, tree, lazy)\\n                + update_tree(2 * n + 1, (a + b) / 2 + 1, b, i, j, tree, lazy);\\n            tree[n]\\n        }\\n\\n        let nums1 = nums1.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let nums2 = nums2.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let f = |x: &Vec<i32>| x.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let queries = queries.iter().map(f).collect::<Vec<_>>();\\n\\n        let mut tree = vec![0; 400000];\\n        let mut lazy = vec![0; 400000];\\n        let mut sum = nums2.iter().sum::<_>();\\n        let sz = nums1.len();\\n        build(&nums1, 1, 0, sz - 1, &mut tree);\\n        let mut res = vec![];\\n        for q in queries {\\n            if q[0] == 1 {\\n                update_tree(1, 0, sz as i64 - 1, q[1], q[2], &mut tree, &mut lazy);\\n            } else if q[0] == 2 {\\n                sum += tree[1] * q[1];\\n            } else {\\n                res.push(sum);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn handle_query(nums1: Vec<i32>, nums2: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i64> {\\n        fn build(arr: &Vec<i64>, n: usize, a: usize, b: usize, tree: &mut Vec<i64>) -> i64 {\\n            if a == b {\\n                tree[n] = arr[a];\\n                return tree[n];\\n            }\\n            tree[n] = build(arr, 2 * n, a, (a + b) / 2, tree) + build(arr, 2 * n + 1, (a + b) / 2 + 1, b, tree);\\n            tree[n]\\n        }\\n\\n        fn update_tree(n: usize, a: i64, b: i64, i: i64, j: i64, tree: &mut Vec<i64>, lazy: &mut Vec<i64>) -> i64 {\\n            if b < i || a > j {\\n                return if lazy[n] == 1 { b - a + 1 - tree[n] } else { tree[n] };\\n            }\\n            if lazy[n] == 1 {\\n                tree[n] = b - a + 1 - tree[n];\\n                if a != b {\\n                    lazy[2 * n] = 1 - lazy[2 * n];\\n                    lazy[2 * n + 1] = 1 - lazy[2 * n + 1];\\n                }\\n                lazy[n] = 0;\\n            }\\n            if a >= i && b <= j {\\n                if a != b {\\n                    lazy[2 * n] = 1 - lazy[2 * n];\\n                    lazy[2 * n + 1] = 1 - lazy[2 * n + 1];\\n                }\\n                tree[n] = b - a + 1 - tree[n];\\n                return tree[n];\\n            }\\n            tree[n] = update_tree(2 * n, a, (a + b) / 2, i, j, tree, lazy)\\n                + update_tree(2 * n + 1, (a + b) / 2 + 1, b, i, j, tree, lazy);\\n            tree[n]\\n        }\\n\\n        let nums1 = nums1.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let nums2 = nums2.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let f = |x: &Vec<i32>| x.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let queries = queries.iter().map(f).collect::<Vec<_>>();\\n\\n        let mut tree = vec![0; 400000];\\n        let mut lazy = vec![0; 400000];\\n        let mut sum = nums2.iter().sum::<_>();\\n        let sz = nums1.len();\\n        build(&nums1, 1, 0, sz - 1, &mut tree);\\n        let mut res = vec![];\\n        for q in queries {\\n            if q[0] == 1 {\\n                update_tree(1, 0, sz as i64 - 1, q[1], q[2], &mut tree, &mut lazy);\\n            } else if q[0] == 2 {\\n                sum += tree[1] * q[1];\\n            } else {\\n                res.push(sum);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203524,
                "title": "explaination-on-bitset-class-flip-from-to",
                "content": "# Source Code\\n[source code](https://developer.classpath.org/doc/java/util/BitSet-source.html)\\n\\ntime complexity: should be O(N). But actually it is O(N/64)\\n\\n```java\\npublic void flip(int from, int to)\\n 314:   {\\n 315:     if (from < 0 || from > to)\\n 316:       throw new IndexOutOfBoundsException();\\n 317:     if (from == to)\\n 318:       return;\\n 319:     int lo_offset = from >>> 6;\\n 320:     int hi_offset = to >>> 6;\\n 321:     ensure(hi_offset);\\n 322:     if (lo_offset == hi_offset)\\n 323:       {\\n 324:         bits[hi_offset] ^= (-1L << from) & ((1L << to) - 1);\\n 325:         return;\\n 326:       }\\n 327: \\n 328:     bits[lo_offset] ^= -1L << from;\\n 329:     bits[hi_offset] ^= (1L << to) - 1;\\n 330:     for (int i = lo_offset + 1; i < hi_offset; i++)\\n 331:       bits[i] ^= -1;\\n 332:   }\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/cd0fcb88-2e9c-4ab5-ac81-8714ca83fcde_1676773736.4265623.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic void flip(int from, int to)\\n 314:   {\\n 315:     if (from < 0 || from > to)\\n 316:       throw new IndexOutOfBoundsException();\\n 317:     if (from == to)\\n 318:       return;\\n 319:     int lo_offset = from >>> 6;\\n 320:     int hi_offset = to >>> 6;\\n 321:     ensure(hi_offset);\\n 322:     if (lo_offset == hi_offset)\\n 323:       {\\n 324:         bits[hi_offset] ^= (-1L << from) & ((1L << to) - 1);\\n 325:         return;\\n 326:       }\\n 327: \\n 328:     bits[lo_offset] ^= -1L << from;\\n 329:     bits[hi_offset] ^= (1L << to) - 1;\\n 330:     for (int i = lo_offset + 1; i < hi_offset; i++)\\n 331:       bits[i] ^= -1;\\n 332:   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203190,
                "title": "javascript-segment-tree",
                "content": "Wish they confirmed this in the description, but I had to figure it out with a test - the max possible return value fits in a ```float64``` (e.g. <= ```Number.MAX_SAFE_INTEGER```), they don\\'t accept ```BigInt``` and don\\'t state anything about possible return values.\\n\\nAs it\\'s a range update problem, I\\'ll go with a SegmentTree since I\\'m not really sure how to implement a Fenwick Tree (I assume that\\'s the other option).\\n\\nThere are a couple key insights for this problem\\n- The values of ```nums2``` don\\'t really matter except to get the initial sum for the tree. They don\\'t need to be incremented directly - any time we get a type 2 query, the only thing we care about is increasing the total sum of all values, which is the same as saying the count of ```nums1``` which are flipped on multiplied by ```p```.\\n- Flipping values between child and parent nodes is commutative. If we\\'re flipping a range that covers a node and all its children, flipping the value of the parent is the same as flipping all of its children. Given that, we\\'ll just hold some state for each node saying whether it\\'s flipped or not. When we sum up counts in a range, we\\'re free to flip the result of our child nodes if the current node we\\'re looking at is flipped instead of evaluating child nodes.\\n\\n```javascript\\nvar handleQuery = function(nums1, nums2, queries) {\\n  const segmentTree = new SegmentTree(nums1, nums2);\\n\\n  return queries.reduce((answers, [type, a, b]) => {\\n    switch (type) {\\n      case 1:\\n        segmentTree.query1(a, b);\\n        return answers;\\n      case 2:\\n        segmentTree.query2(a);\\n        return answers;\\n      default:\\n        answers.push(segmentTree.query3());\\n        return answers;\\n    }\\n  }, []);\\n};\\n\\nclass SegmentTree {\\n  flipped = [];\\n  counts = [];\\n  max = 0;\\n  total = 0;\\n\\n  constructor(nums1, nums2) {\\n    this.max = nums1.length - 1;\\n    this.flipped = [...nums1, ...nums1].map(() => 0);\\n    this.counts = [...this.flipped];\\n    this.total = nums2.reduce((total, num) => total + num, 0);\\n    \\n    this.build(0, 0, nums1.length - 1, nums1);\\n  }\\n\\n  build(idx, min, max, nums) {\\n    if (min === max) {\\n\\t  // leaf\\n      this.counts[idx] = nums[min];\\n      return this.counts[idx];\\n    }\\n    \\n    const mid = min + max >> 1;\\n    \\n    const leftCount = this.build(idx * 2 + 1, min, mid, nums);\\n    const rightCount = this.build(idx * 2 + 2, mid + 1, max, nums);\\n    \\n    this.counts[idx] = leftCount + rightCount;\\n    return this.counts[idx];\\n  }\\n\\n  query1(l, r, idx = 0, min = 0, max = this.max) {\\n    // outside of range, do nothing\\n    if (min > r || max < l) return this.counts[idx];\\n    if (min === max) {\\n\\t  // leaf\\n      this.counts[idx] = 1 - this.counts[idx];\\n      return this.counts[idx];\\n    }\\n    \\n\\t// use the size to get the inverse of our child sums if we\\'re flipped\\n    const size = max - min + 1;\\n    \\n    if (l <= min && r >= max) {\\n\\t  // range is covered, just update the flipped state\\n      this.flipped[idx] = 1 - this.flipped[idx];\\n      const leftCount = this.counts[idx * 2 + 1];\\n      const rightCount = this.counts[idx * 2 + 2];\\n      this.counts[idx] = this.flipped[idx]\\n        ? size - leftCount - rightCount\\n        : leftCount + rightCount;\\n      return this.counts[idx];\\n    }\\n    \\n\\t// range is partially covered, so we gotta update our children\\n    const mid = min + max >> 1;\\n    const leftCount = this.query1(l, r, idx * 2 + 1, min, mid);\\n    const rightCount = this.query1(l, r, idx * 2 + 2, mid + 1, max);\\n    this.counts[idx] = this.flipped[idx]\\n      ? size - leftCount - rightCount\\n      : leftCount + rightCount;\\n    return this.counts[idx];\\n  }\\n\\n  query2(p) {\\n    this.total += this.counts[0] * p;\\n  }\\n\\n  query3() {\\n    return this.total;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```float64```\n```Number.MAX_SAFE_INTEGER```\n```BigInt```\n```nums2```\n```nums1```\n```p```\n```javascript\\nvar handleQuery = function(nums1, nums2, queries) {\\n  const segmentTree = new SegmentTree(nums1, nums2);\\n\\n  return queries.reduce((answers, [type, a, b]) => {\\n    switch (type) {\\n      case 1:\\n        segmentTree.query1(a, b);\\n        return answers;\\n      case 2:\\n        segmentTree.query2(a);\\n        return answers;\\n      default:\\n        answers.push(segmentTree.query3());\\n        return answers;\\n    }\\n  }, []);\\n};\\n\\nclass SegmentTree {\\n  flipped = [];\\n  counts = [];\\n  max = 0;\\n  total = 0;\\n\\n  constructor(nums1, nums2) {\\n    this.max = nums1.length - 1;\\n    this.flipped = [...nums1, ...nums1].map(() => 0);\\n    this.counts = [...this.flipped];\\n    this.total = nums2.reduce((total, num) => total + num, 0);\\n    \\n    this.build(0, 0, nums1.length - 1, nums1);\\n  }\\n\\n  build(idx, min, max, nums) {\\n    if (min === max) {\\n\\t  // leaf\\n      this.counts[idx] = nums[min];\\n      return this.counts[idx];\\n    }\\n    \\n    const mid = min + max >> 1;\\n    \\n    const leftCount = this.build(idx * 2 + 1, min, mid, nums);\\n    const rightCount = this.build(idx * 2 + 2, mid + 1, max, nums);\\n    \\n    this.counts[idx] = leftCount + rightCount;\\n    return this.counts[idx];\\n  }\\n\\n  query1(l, r, idx = 0, min = 0, max = this.max) {\\n    // outside of range, do nothing\\n    if (min > r || max < l) return this.counts[idx];\\n    if (min === max) {\\n\\t  // leaf\\n      this.counts[idx] = 1 - this.counts[idx];\\n      return this.counts[idx];\\n    }\\n    \\n\\t// use the size to get the inverse of our child sums if we\\'re flipped\\n    const size = max - min + 1;\\n    \\n    if (l <= min && r >= max) {\\n\\t  // range is covered, just update the flipped state\\n      this.flipped[idx] = 1 - this.flipped[idx];\\n      const leftCount = this.counts[idx * 2 + 1];\\n      const rightCount = this.counts[idx * 2 + 2];\\n      this.counts[idx] = this.flipped[idx]\\n        ? size - leftCount - rightCount\\n        : leftCount + rightCount;\\n      return this.counts[idx];\\n    }\\n    \\n\\t// range is partially covered, so we gotta update our children\\n    const mid = min + max >> 1;\\n    const leftCount = this.query1(l, r, idx * 2 + 1, min, mid);\\n    const rightCount = this.query1(l, r, idx * 2 + 2, mid + 1, max);\\n    this.counts[idx] = this.flipped[idx]\\n      ? size - leftCount - rightCount\\n      : leftCount + rightCount;\\n    return this.counts[idx];\\n  }\\n\\n  query2(p) {\\n    this.total += this.counts[0] * p;\\n  }\\n\\n  query3() {\\n    return this.total;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203172,
                "title": "python-clear-bit-manipulation-solution",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Code\\n```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        n = len(nums1)\\n        bitmap = int(\\'\\'.join([str(num) for num in nums1]), 2)\\n        bitcount = bitmap.bit_count()\\n        runningSum = sum(nums2)\\n        for query in queries:\\n            if query[0] == 1:\\n                l, r = query[1], query[2]\\n                bit_xor = int(\"1\"*(r+1-l) + \"0\"*(n-(r+1)),2)\\n                bitmap = bitmap ^ bit_xor\\n                bitcount = bitmap.bit_count()\\n            elif query[0] == 2:\\n                p = query[1]\\n                runningSum += p*bitcount\\n            else:\\n                ans.append(runningSum)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        n = len(nums1)\\n        bitmap = int(\\'\\'.join([str(num) for num in nums1]), 2)\\n        bitcount = bitmap.bit_count()\\n        runningSum = sum(nums2)\\n        for query in queries:\\n            if query[0] == 1:\\n                l, r = query[1], query[2]\\n                bit_xor = int(\"1\"*(r+1-l) + \"0\"*(n-(r+1)),2)\\n                bitmap = bitmap ^ bit_xor\\n                bitcount = bitmap.bit_count()\\n            elif query[0] == 2:\\n                p = query[1]\\n                runningSum += p*bitcount\\n            else:\\n                ans.append(runningSum)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202945,
                "title": "adjusted-segment-tree",
                "content": "# Intuition\\nUpdate segment tree using the range query.\\n\\n# Approach\\nNote if a node is flipped, before updating it\\'s children, flip them if they are inconsistent with parent.\\n\\n# Complexity\\n- Time complexity:\\nn Log(n)\\n\\n- Space complexity:\\nn\\n\\n# Code\\n```\\nclass MyNode:\\n    def __init__(self, stt, end, ct=0, left: \\'MyNode\\' = None, right: \\'MyNode\\' = None):\\n        self.stt = stt\\n        self.end = end\\n        self.ct = 0\\n        self.left = left\\n        self.right = right\\n        self.child_same_sign = 1\\n    \\n    def flip(self, stt=None, end=None):\\n        #print(f\\'stt is {stt}, end is {end} ({self.stt}, {self.end})\\')\\n        stt = self.stt if stt is None else stt\\n        end = self.end if end is None else end\\n\\n        if stt == self.stt and end == self.end:\\n            self.ct = end - stt + 1 - self.ct\\n            if self.stt < self.end:\\n                self.child_same_sign *= -1\\n            return\\n        \\n        if self.child_same_sign < 0:\\n            self.left.flip()\\n            self.right.flip()\\n            self.child_same_sign *= -1\\n        \\n        if stt <= self.left.end:\\n            self.left.flip(max(stt, self.stt), min(self.left.end, end))\\n        if end >= self.right.stt:\\n            self.right.flip(max(self.right.stt, stt), min(end, self.end))\\n        self.ct = self.left.ct + self.right.ct\\n\\nclass Solution:\\n    def build_tree(self, nd):\\n        if nd.stt == nd.end:\\n            nd.ct = self.nums1[nd.stt]\\n            return\\n        \\n        mid = (nd.stt + nd.end) // 2\\n        nd.left = MyNode(nd.stt, mid)\\n        nd.right = MyNode(mid+1, nd.end)\\n        self.build_tree(nd.left)\\n        self.build_tree(nd.right)\\n        nd.ct = nd.left.ct + nd.right.ct\\n\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        self.nums1 = nums1\\n        self.root = MyNode(0, len(nums1)-1)\\n        self.build_tree(self.root)\\n        #print(self.root.ct)\\n\\n        sm2 = sum(nums2)\\n        add1 = 0\\n        rst = []\\n        for tp, l, r in queries:\\n            if tp == 1:\\n                self.root.flip(l, r)\\n            elif tp == 2:\\n                add1 += l * self.root.ct\\n            else:\\n                rst.append(sm2 + add1)\\n        return rst\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MyNode:\\n    def __init__(self, stt, end, ct=0, left: \\'MyNode\\' = None, right: \\'MyNode\\' = None):\\n        self.stt = stt\\n        self.end = end\\n        self.ct = 0\\n        self.left = left\\n        self.right = right\\n        self.child_same_sign = 1\\n    \\n    def flip(self, stt=None, end=None):\\n        #print(f\\'stt is {stt}, end is {end} ({self.stt}, {self.end})\\')\\n        stt = self.stt if stt is None else stt\\n        end = self.end if end is None else end\\n\\n        if stt == self.stt and end == self.end:\\n            self.ct = end - stt + 1 - self.ct\\n            if self.stt < self.end:\\n                self.child_same_sign *= -1\\n            return\\n        \\n        if self.child_same_sign < 0:\\n            self.left.flip()\\n            self.right.flip()\\n            self.child_same_sign *= -1\\n        \\n        if stt <= self.left.end:\\n            self.left.flip(max(stt, self.stt), min(self.left.end, end))\\n        if end >= self.right.stt:\\n            self.right.flip(max(self.right.stt, stt), min(end, self.end))\\n        self.ct = self.left.ct + self.right.ct\\n\\nclass Solution:\\n    def build_tree(self, nd):\\n        if nd.stt == nd.end:\\n            nd.ct = self.nums1[nd.stt]\\n            return\\n        \\n        mid = (nd.stt + nd.end) // 2\\n        nd.left = MyNode(nd.stt, mid)\\n        nd.right = MyNode(mid+1, nd.end)\\n        self.build_tree(nd.left)\\n        self.build_tree(nd.right)\\n        nd.ct = nd.left.ct + nd.right.ct\\n\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        self.nums1 = nums1\\n        self.root = MyNode(0, len(nums1)-1)\\n        self.build_tree(self.root)\\n        #print(self.root.ct)\\n\\n        sm2 = sum(nums2)\\n        add1 = 0\\n        rst = []\\n        for tp, l, r in queries:\\n            if tp == 1:\\n                self.root.flip(l, r)\\n            elif tp == 2:\\n                add1 += l * self.root.ct\\n            else:\\n                rst.append(sm2 + add1)\\n        return rst\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202905,
                "title": "why-using-brute-force-way-causes-72-75",
                "content": "Using the brute force way to traverse the queries, but just pass 72/75. \\n\\nHere is my code. And obviously, this would not allow me to pass the question easily with my naive code. And it just passed 72/75 test cases and reported wrong answer, but not TLE. I am not sure what cases or points I missed that time.\\n\\nAny your advice and comments are welcome. Thank you!\\n\\n\\n\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> list = new ArrayList<>();\\n        \\n        for(int [] query : queries){\\n            if(query[0] == 1){\\n                for(int i = query[1]; i<= query[2]; i++){\\n                    if(nums1[i] == 1){\\n                        nums1[i] = 0;\\n                    }else{\\n                        nums1[i] = 1;\\n                    }\\n                    System.out.print(nums1[i]);\\n                }\\n            }else if(query[0] == 2){\\n                for(int i = 0; i< nums2.length; i++){\\n                    nums2[i] += nums1[i]*query[1];\\n                }\\n            }else{\\n                long sum = 0;\\n                for(int i : nums2){\\n                    sum+= i;\\n                }\\n                list.add(sum);\\n            }\\n        }\\n        long[] res = new long[list.size()];\\n        for(int i = 0; i<list.size();i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        List<Long> list = new ArrayList<>();\\n        \\n        for(int [] query : queries){\\n            if(query[0] == 1){\\n                for(int i = query[1]; i<= query[2]; i++){\\n                    if(nums1[i] == 1){\\n                        nums1[i] = 0;\\n                    }else{\\n                        nums1[i] = 1;\\n                    }\\n                    System.out.print(nums1[i]);\\n                }\\n            }else if(query[0] == 2){\\n                for(int i = 0; i< nums2.length; i++){\\n                    nums2[i] += nums1[i]*query[1];\\n                }\\n            }else{\\n                long sum = 0;\\n                for(int i : nums2){\\n                    sum+= i;\\n                }\\n                list.add(sum);\\n            }\\n        }\\n        long[] res = new long[list.size()];\\n        for(int i = 0; i<list.size();i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202741,
                "title": "c-solution-with-lazy-propagation-segment-tree",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    private readonly int[] _tree = new int[400000];\\n    private readonly int[] _lazy = new int[400000];\\n\\n    public long[] HandleQuery(int[] nums1, int[] nums2, int[][] queries)\\n    {\\n        var sum = 0L;\\n        \\n        for (var i = 0; i < nums1.Length; i++)\\n            sum += 1L * nums2[i];\\n        \\n        Build(nums1, 1, 0, nums1.Length - 1);\\n        var res = new List<long>();\\n        \\n        foreach (var q in queries)\\n            if (q[0] == 1)\\n                UpdateTree(1, 0, nums1.Length - 1, q[1], q[2]);\\n            else if (q[0] == 2)\\n                sum += (long)_tree[1] * q[1];\\n            else\\n                res.Add(sum);\\n        \\n        return res.ToArray();\\n    }\\n\\n    private int Build(int[] arr, int n, int a, int b)\\n    {\\n        if (a == b)\\n            return _tree[n] = arr[a];\\n        \\n        return _tree[n] = Build(arr, 2 * n, a, (a + b) / 2) + Build(arr, 2 * n + 1, (a + b) / 2 + 1, b);\\n    }\\n\\n    private int UpdateTree(int n, int a, int b, int i, int j)\\n    {\\n        // outside\\n        if (b < i || a > j) \\n            return _lazy[n] != 0 ? b - a + 1 - _tree[n] : _tree[n];\\n\\n        if (_lazy[n] != 0)\\n        {\\n            _tree[n] = b - a + 1 - _tree[n];\\n\\n            if (a != b)\\n            {\\n                _lazy[n * 2] = _lazy[n * 2] == 0 ? 1 : 0;\\n                _lazy[n * 2 + 1] = _lazy[n * 2 + 1] == 0 ? 1 : 0;\\n            }\\n\\n            _lazy[n] = 0;\\n        }\\n\\n        if (a < i || b > j)\\n            return _tree[n] = UpdateTree(n * 2, a, (a + b) / 2, i, j) + UpdateTree(n * 2 + 1, (a + b) / 2 + 1, b, i, j);\\n        \\n        // inside\\n        _tree[n] = b - a + 1 - _tree[n];\\n            \\n        if (a == b)\\n            return _tree[n];\\n            \\n        _lazy[n * 2] = _lazy[n * 2] == 0 ? 1 : 0;\\n        _lazy[n * 2 + 1] = _lazy[n * 2 + 1] == 0 ? 1 : 0;\\n\\n        return _tree[n];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private readonly int[] _tree = new int[400000];\\n    private readonly int[] _lazy = new int[400000];\\n\\n    public long[] HandleQuery(int[] nums1, int[] nums2, int[][] queries)\\n    {\\n        var sum = 0L;\\n        \\n        for (var i = 0; i < nums1.Length; i++)\\n            sum += 1L * nums2[i];\\n        \\n        Build(nums1, 1, 0, nums1.Length - 1);\\n        var res = new List<long>();\\n        \\n        foreach (var q in queries)\\n            if (q[0] == 1)\\n                UpdateTree(1, 0, nums1.Length - 1, q[1], q[2]);\\n            else if (q[0] == 2)\\n                sum += (long)_tree[1] * q[1];\\n            else\\n                res.Add(sum);\\n        \\n        return res.ToArray();\\n    }\\n\\n    private int Build(int[] arr, int n, int a, int b)\\n    {\\n        if (a == b)\\n            return _tree[n] = arr[a];\\n        \\n        return _tree[n] = Build(arr, 2 * n, a, (a + b) / 2) + Build(arr, 2 * n + 1, (a + b) / 2 + 1, b);\\n    }\\n\\n    private int UpdateTree(int n, int a, int b, int i, int j)\\n    {\\n        // outside\\n        if (b < i || a > j) \\n            return _lazy[n] != 0 ? b - a + 1 - _tree[n] : _tree[n];\\n\\n        if (_lazy[n] != 0)\\n        {\\n            _tree[n] = b - a + 1 - _tree[n];\\n\\n            if (a != b)\\n            {\\n                _lazy[n * 2] = _lazy[n * 2] == 0 ? 1 : 0;\\n                _lazy[n * 2 + 1] = _lazy[n * 2 + 1] == 0 ? 1 : 0;\\n            }\\n\\n            _lazy[n] = 0;\\n        }\\n\\n        if (a < i || b > j)\\n            return _tree[n] = UpdateTree(n * 2, a, (a + b) / 2, i, j) + UpdateTree(n * 2 + 1, (a + b) / 2 + 1, b, i, j);\\n        \\n        // inside\\n        _tree[n] = b - a + 1 - _tree[n];\\n            \\n        if (a == b)\\n            return _tree[n];\\n            \\n        _lazy[n * 2] = _lazy[n * 2] == 0 ? 1 : 0;\\n        _lazy[n * 2 + 1] = _lazy[n * 2 + 1] == 0 ? 1 : 0;\\n\\n        return _tree[n];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202550,
                "title": "easy-way-to-understand-use-of-lazy-propagation-segment-tree-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of Calculating actual XOR (because I couldn\\'t). I calculated number of odds and evens. \\n\\nTo calculate these evens and odds I used Lazy segment tree\\n\\nFor Eg. [0,1,0] if we flip the whole array it would become [1,0,1] \\nwhich is equivalent to [1,2,1] both the arrays have same odds and evens\\n\\nWe then count the number of odds as we know they are the only ones which are one, and then add it to our answer. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially, to check the evens and odds while building the tree \\nwe can do \\n```\\nif (a[start] % 2)seg[ind].odd = 1;\\nelse seg[ind].even = 1;\\n```\\nlater while updating \\n```\\nif (lazy[ind] % 2) {\\n    swap(seg[ind].odd, seg[ind].even);\\n}\\n```\\nbecause lazy[ind] is odd means we have fipped odd times so \\nwe have to swap 0\\'s and 1\\'s which would swap evens and odds too. \\n```\\nif (k % 2) {\\n    swap(seg[ind].odd, seg[ind].even);\\n}\\n```\\nthis is at the root level, here k is incremented by 1.\\n\\nIf you have any doubt\\'s please comment down below. It will try to help. \\n\\n# Code\\n```\\n#define INF (ll)2e18\\n#define ll long long\\nstruct T {\\n   ll sm = 0; // sum\\n   ll mx = 0; // max\\n   ll mn = 0; // min\\n   ll odd = 0; \\n   ll even = 0;\\n};\\n\\nclass SegTree {\\npublic:\\n   vector<T> seg; // use ds according to question, for eg. pair\\n   vector<int> a;\\n   vector<int> lazy;\\n   int n;\\n   SegTree(vector<int> v) {\\n      a = v;\\n      n = v.size();\\n      seg.resize(4 * n);\\n      lazy.resize(4 * n);\\n      build(0, 0, n - 1);\\n   }\\n   void build(int ind, int start, int end) {\\n      if (start == end) {\\n         seg[ind].sm = seg[ind].mx = seg[ind].mn = a[start];\\n         if (a[start] % 2)seg[ind].odd = 1;\\n         else seg[ind].even = 1;\\n         return;\\n      }\\n      int mid = (start + end) >> 1;\\n      build(2 * ind + 1, start, mid);\\n      build(2 * ind + 2, mid + 1, end);\\n      seg[ind].sm = seg[2 * ind + 1].sm + seg[2 * ind + 2].sm; // operation may change to min,max,add,xor\\n      seg[ind].mx = max(seg[2 * ind + 1].mx, seg[2 * ind + 2].mx);\\n      seg[ind].mn = min(seg[2 * ind + 1].mn, seg[2 * ind + 2].mn);\\n      seg[ind].odd = seg[2 * ind + 1].odd + seg[2 * ind + 2].odd;\\n      seg[ind].even = seg[2 * ind + 1].even + seg[2 * ind + 2].even;\\n\\n   }\\n   T query(ll left, ll right) {\\n      return query(0, left, right, 0, n - 1);\\n   }\\n   T query(ll ind, ll left, ll right, ll start, ll end) {\\n      if (lazy[ind] != 0) {\\n         seg[ind].sm += (end - start + 1) * lazy[ind]; // when min or max remove (end-start+1)\\n         seg[ind].mx += lazy[ind];\\n         seg[ind].mn += lazy[ind];\\n         if (lazy[ind] % 2) {\\n            swap(seg[ind].odd, seg[ind].even);\\n         }\\n         if (start != end) {\\n            lazy[2 * ind + 1] += lazy[ind];\\n            lazy[2 * ind + 2] += lazy[ind];\\n         }\\n         lazy[ind] = 0;\\n      }\\n      if (left <= start && right >= end) {\\n         return seg[ind];\\n      }\\n      else if (left > end || right < start) {\\n         T t;\\n         t.sm = 0;\\n         t.mx = -INF;\\n         t.mn = INF;\\n         t.odd = 0;\\n         t.even = 0;\\n         return t;\\n      }\\n      else {\\n         ll mid = (start + end) >> 1;\\n         T p1 = query(2 * ind + 1, left, right, start, mid);\\n         T p2 = query(2 * ind + 2, left, right, mid + 1, end);\\n         T t;\\n         t.sm = p1.sm + p2.sm;\\n         t.mx = max(p1.mx, p2.mx);\\n         t.mn = min(p1.mn, p2.mn);\\n         t.odd = p1.odd + p2.odd;\\n         t.even = p1.even + p2.even;\\n         return t;\\n         // operation may change to min,max,add,xor\\n\\n      }\\n   }\\n   void update(ll i, ll j, ll k) {\\n      update(0, i, j, k, 0, n - 1);\\n   }\\n   void update(int ind, ll i, ll j, ll k, int start, int end) {\\n      if (lazy[ind] != 0) {\\n         seg[ind].sm += (end - start + 1) * lazy[ind]; // when min or max remove (end-start+1)\\n         seg[ind].mx += lazy[ind];\\n         seg[ind].mn += lazy[ind];\\n         if (lazy[ind] % 2) {\\n            swap(seg[ind].odd, seg[ind].even);\\n         }\\n         if (start != end) {\\n            lazy[2 * ind + 1] += lazy[ind];\\n            lazy[2 * ind + 2] += lazy[ind];\\n         }\\n         lazy[ind] = 0;\\n      }\\n      if (start > j || i > end )return;\\n      if (start >= i && end <= j) {\\n         seg[ind].sm += (end - start + 1) * k; // when min or max remove (end-start+1)\\n         seg[ind].mx += k;\\n         seg[ind].mn += k;\\n         if (k % 2) {\\n            swap(seg[ind].odd, seg[ind].even);\\n         }\\n         if (start != end) {\\n            lazy[2 * ind + 1] += k;\\n            lazy[2 * ind + 2] += k;\\n         }\\n         return ;\\n      }\\n      int mid = (start + end) >> 1;\\n      update(2 * ind + 1, i, j, k, start, mid);\\n      update(2 * ind + 2, i, j, k, mid + 1, end);\\n      seg[ind].sm = seg[2 * ind + 1].sm + seg[2 * ind + 2].sm;\\n      seg[ind].mx = max(seg[2 * ind + 1].mx, seg[2 * ind + 2].mx);\\n      seg[ind].mn = min(seg[2 * ind + 1].mn, seg[2 * ind + 2].mn);\\n      seg[ind].odd = seg[2 * ind + 1].odd + seg[2 * ind + 2].odd;\\n      seg[ind].even = seg[2 * ind + 1].even + seg[2 * ind + 2].even; // operation may change to min,max,add,xor\\n   }\\n};\\n\\nclass Solution {\\npublic:\\n   vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n      SegTree st(nums1);\\n      vector<long long> ans;\\n      long long sum = accumulate(nums2.begin(), nums2.end(), 0ll);\\n      int n = nums1.size();\\n      for (auto x : queries) {\\n         if (x[0] == 1) {\\n            st.update(x[1], x[2], 1);\\n         } else if (x[0] == 2) {\\n            T val = st.query(0, n - 1);\\n            sum += x[1] * val.odd;\\n         } else {\\n            ans.push_back(sum);\\n         }\\n      }\\n      return ans;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nif (a[start] % 2)seg[ind].odd = 1;\\nelse seg[ind].even = 1;\\n```\n```\\nif (lazy[ind] % 2) {\\n    swap(seg[ind].odd, seg[ind].even);\\n}\\n```\n```\\nif (k % 2) {\\n    swap(seg[ind].odd, seg[ind].even);\\n}\\n```\n```\\n#define INF (ll)2e18\\n#define ll long long\\nstruct T {\\n   ll sm = 0; // sum\\n   ll mx = 0; // max\\n   ll mn = 0; // min\\n   ll odd = 0; \\n   ll even = 0;\\n};\\n\\nclass SegTree {\\npublic:\\n   vector<T> seg; // use ds according to question, for eg. pair\\n   vector<int> a;\\n   vector<int> lazy;\\n   int n;\\n   SegTree(vector<int> v) {\\n      a = v;\\n      n = v.size();\\n      seg.resize(4 * n);\\n      lazy.resize(4 * n);\\n      build(0, 0, n - 1);\\n   }\\n   void build(int ind, int start, int end) {\\n      if (start == end) {\\n         seg[ind].sm = seg[ind].mx = seg[ind].mn = a[start];\\n         if (a[start] % 2)seg[ind].odd = 1;\\n         else seg[ind].even = 1;\\n         return;\\n      }\\n      int mid = (start + end) >> 1;\\n      build(2 * ind + 1, start, mid);\\n      build(2 * ind + 2, mid + 1, end);\\n      seg[ind].sm = seg[2 * ind + 1].sm + seg[2 * ind + 2].sm; // operation may change to min,max,add,xor\\n      seg[ind].mx = max(seg[2 * ind + 1].mx, seg[2 * ind + 2].mx);\\n      seg[ind].mn = min(seg[2 * ind + 1].mn, seg[2 * ind + 2].mn);\\n      seg[ind].odd = seg[2 * ind + 1].odd + seg[2 * ind + 2].odd;\\n      seg[ind].even = seg[2 * ind + 1].even + seg[2 * ind + 2].even;\\n\\n   }\\n   T query(ll left, ll right) {\\n      return query(0, left, right, 0, n - 1);\\n   }\\n   T query(ll ind, ll left, ll right, ll start, ll end) {\\n      if (lazy[ind] != 0) {\\n         seg[ind].sm += (end - start + 1) * lazy[ind]; // when min or max remove (end-start+1)\\n         seg[ind].mx += lazy[ind];\\n         seg[ind].mn += lazy[ind];\\n         if (lazy[ind] % 2) {\\n            swap(seg[ind].odd, seg[ind].even);\\n         }\\n         if (start != end) {\\n            lazy[2 * ind + 1] += lazy[ind];\\n            lazy[2 * ind + 2] += lazy[ind];\\n         }\\n         lazy[ind] = 0;\\n      }\\n      if (left <= start && right >= end) {\\n         return seg[ind];\\n      }\\n      else if (left > end || right < start) {\\n         T t;\\n         t.sm = 0;\\n         t.mx = -INF;\\n         t.mn = INF;\\n         t.odd = 0;\\n         t.even = 0;\\n         return t;\\n      }\\n      else {\\n         ll mid = (start + end) >> 1;\\n         T p1 = query(2 * ind + 1, left, right, start, mid);\\n         T p2 = query(2 * ind + 2, left, right, mid + 1, end);\\n         T t;\\n         t.sm = p1.sm + p2.sm;\\n         t.mx = max(p1.mx, p2.mx);\\n         t.mn = min(p1.mn, p2.mn);\\n         t.odd = p1.odd + p2.odd;\\n         t.even = p1.even + p2.even;\\n         return t;\\n         // operation may change to min,max,add,xor\\n\\n      }\\n   }\\n   void update(ll i, ll j, ll k) {\\n      update(0, i, j, k, 0, n - 1);\\n   }\\n   void update(int ind, ll i, ll j, ll k, int start, int end) {\\n      if (lazy[ind] != 0) {\\n         seg[ind].sm += (end - start + 1) * lazy[ind]; // when min or max remove (end-start+1)\\n         seg[ind].mx += lazy[ind];\\n         seg[ind].mn += lazy[ind];\\n         if (lazy[ind] % 2) {\\n            swap(seg[ind].odd, seg[ind].even);\\n         }\\n         if (start != end) {\\n            lazy[2 * ind + 1] += lazy[ind];\\n            lazy[2 * ind + 2] += lazy[ind];\\n         }\\n         lazy[ind] = 0;\\n      }\\n      if (start > j || i > end )return;\\n      if (start >= i && end <= j) {\\n         seg[ind].sm += (end - start + 1) * k; // when min or max remove (end-start+1)\\n         seg[ind].mx += k;\\n         seg[ind].mn += k;\\n         if (k % 2) {\\n            swap(seg[ind].odd, seg[ind].even);\\n         }\\n         if (start != end) {\\n            lazy[2 * ind + 1] += k;\\n            lazy[2 * ind + 2] += k;\\n         }\\n         return ;\\n      }\\n      int mid = (start + end) >> 1;\\n      update(2 * ind + 1, i, j, k, start, mid);\\n      update(2 * ind + 2, i, j, k, mid + 1, end);\\n      seg[ind].sm = seg[2 * ind + 1].sm + seg[2 * ind + 2].sm;\\n      seg[ind].mx = max(seg[2 * ind + 1].mx, seg[2 * ind + 2].mx);\\n      seg[ind].mn = min(seg[2 * ind + 1].mn, seg[2 * ind + 2].mn);\\n      seg[ind].odd = seg[2 * ind + 1].odd + seg[2 * ind + 2].odd;\\n      seg[ind].even = seg[2 * ind + 1].even + seg[2 * ind + 2].even; // operation may change to min,max,add,xor\\n   }\\n};\\n\\nclass Solution {\\npublic:\\n   vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n      SegTree st(nums1);\\n      vector<long long> ans;\\n      long long sum = accumulate(nums2.begin(), nums2.end(), 0ll);\\n      int n = nums1.size();\\n      for (auto x : queries) {\\n         if (x[0] == 1) {\\n            st.update(x[1], x[2], 1);\\n         } else if (x[0] == 2) {\\n            T val = st.query(0, n - 1);\\n            sum += x[1] * val.odd;\\n         } else {\\n            ans.push_back(sum);\\n         }\\n      }\\n      return ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202507,
                "title": "c-lazy-segment-tree",
                "content": "\\t#define ll long long\\n\\tclass LST {\\n\\tpublic:\\n\\t vector<ll>seg, lazy;\\n\\t LST(ll n) {\\n\\t  seg.resize(4 * n + 1);\\n\\t  lazy.resize(4 * n + 1);\\n\\t }\\n\\n\\t void build(ll ind, ll low, ll high, vector<ll>&arr) {\\n\\t  if (low == high) {\\n\\t   seg[ind] = arr[low];\\n\\t   return;\\n\\t  }\\n\\t  ll mid = (low + high) / 2;\\n\\t  build(2 * ind + 1, low, mid, arr);\\n\\t  build(2 * ind + 2, mid + 1, high, arr);\\n\\t  seg[ind] = seg[2 * ind + 1] + seg[2 * ind + 2];\\n\\t }\\n\\n\\t ll query(ll ind, ll low, ll high, ll l, ll r) {\\n\\t  //update if there are any update remaining\\n\\t  // as the node will stay fresh and updated\\n\\n\\t  if (lazy[ind] != 0) {\\n\\t   seg[ind] = (high - low + 1) - seg[ind];\\n\\t   //propogate the lazy updates downwards\\n\\t   // for the remaining elements\\n\\t   if (low != high)\\n\\t   {\\n\\t\\tlazy[2 * ind + 1] += lazy[ind];\\n\\t\\tlazy[2 * ind + 2] += lazy[ind];\\n\\t   }\\n\\t   lazy[ind] = 0;\\n\\t  }\\n\\n\\t  //no overlap\\n\\t  // l r low high or low high l r\\n\\t  if (r < low || high < l) {\\n\\t   return 0;\\n\\t  }\\n\\t  //complete overlap\\n\\t  // l low high r\\n\\t  if (low >= l && high <= r) {\\n\\t   return seg[ind];\\n\\t  }\\n\\t  ll mid = (low + high) >> 1;\\n\\t  ll left = query(2 * ind + 1, low, mid, l, r);\\n\\t  ll right = query(2 * ind + 2, mid + 1, high, l, r);\\n\\t  return left + right;\\n\\t }\\n\\t void update(ll ind, ll low, ll high, ll l, ll r) {\\n\\t  //update the previous remaining updates\\n\\t  // and propogate downwards\\n\\t  if (lazy[ind] != 0) {\\n\\t   seg[ind] = (high - low + 1) - seg[ind];\\n\\t   //propogate the lazy updates downwards\\n\\t   // for the remaining elements\\n\\t   if (low != high)\\n\\t   {\\n\\t\\tlazy[2 * ind + 1] = !lazy[2 * ind + 1];\\n\\t\\tlazy[2 * ind + 2] = !lazy[2 * ind + 2];\\n\\t   }\\n\\t   lazy[ind] = 0;\\n\\t  }\\n\\t  //no overllap\\n\\t  // we dont do anything and return\\n\\t  // low high l r or l r low high\\n\\t  if (high < l or r < low) {\\n\\t   return;\\n\\t  }\\n\\t  // complete overralp\\n\\t  //l low high r\\n\\t  if (low >= l && high <= r) {\\n\\t   seg[ind] = (high - low + 1) - seg[ind];\\n\\t   if (low != high) {\\n\\t\\tlazy[2 * ind + 1] = !lazy[2 * ind + 1];\\n\\t\\tlazy[2 * ind + 2] = !lazy[2 * ind + 2];\\n\\t   }\\n\\t   return;\\n\\t  }\\n\\n\\t  //last case has to be partial overlap\\n\\t  ll mid = (low + high) / 2;\\n\\t  update(2 * ind + 1, low, mid, l, r);\\n\\t  update(2 * ind + 2, mid + 1, high, l, r);\\n\\t  seg[ind] = (seg[2 * ind + 1] + seg[2 * ind + 2]);\\n\\n\\n\\n\\t }\\n\\t};\\n\\tclass Solution {\\n\\t public:\\n\\t  vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n\\t   vector<long long> res;\\n\\t\\t\\t\\tint n= nums1.size();\\n\\t   long long ans=0;\\n\\t   for(int i:nums2) ans+=i;\\n\\t\\t\\t\\tLST sg1(n);\\n\\t\\t\\t\\tvector<ll>arr;\\n\\t\\t\\t\\t// arr.push_back(0);\\n\\t\\t\\t\\tfor(auto it:nums1)\\n\\t\\t\\t\\t\\tarr.push_back(it);\\n\\t\\t\\t sg1.build(0, 0, n-1, arr);\\n\\t\\t\\t\\tfor(auto it:queries){\\n\\t\\t\\t\\t\\tif(it[0]==3)\\n\\t\\t\\t\\t\\t\\tres.push_back(ans);\\n\\t\\t\\t\\t\\telse if(it[0]==1){\\n\\t\\t\\t\\t\\t\\tsg1.update(0, 0, n-1, it[1], it[2]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tans+=sg1.query(0, 0, n-1, 0, n-1)*it[1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\n\\t  }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Bit Manipulation",
                    "Tree"
                ],
                "code": "class Solution {\\n\\t public:\\n\\t  vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n\\t   vector<long long> res;\\n\\t\\t\\t\\tint n= nums1.size();\\n\\t   long long ans=0;\\n\\t   for(int i:nums2) ans+=i;\\n\\t\\t\\t\\tLST sg1(n);\\n\\t\\t\\t\\tvector<ll>arr;\\n\\t\\t\\t\\t// arr.push_back(0);\\n\\t\\t\\t\\tfor(auto it:nums1)\\n\\t\\t\\t\\t\\tarr.push_back(it);\\n\\t\\t\\t sg1.build(0, 0, n-1, arr);\\n\\t\\t\\t\\tfor(auto it:queries){\\n\\t\\t\\t\\t\\tif(it[0]==3)\\n\\t\\t\\t\\t\\t\\tres.push_back(ans);\\n\\t\\t\\t\\t\\telse if(it[0]==1){\\n\\t\\t\\t\\t\\t\\tsg1.update(0, 0, n-1, it[1], it[2]);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3202371,
                "title": "72-75-test-cases-passed-can-someone-help-me",
                "content": "# class Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        ArrayList<Long> a=new ArrayList<>();\\n        for(int i=0;i<queries.length;i++)\\n        {\\n        if(queries[i][0]==1)\\n        {\\n        int l=queries[i][1];\\n        int r=queries[i][2];\\n        for(int j=l;j<=r;j++)\\n        {\\n            if(nums1[j]==1)\\n            {\\n                nums1[j]=0;\\n            }else if(nums1[j]==0){\\n                nums1[j]=1;\\n            }\\n        }\\n        }\\n        if(queries[i][0]==2)\\n        {\\n        int p=queries[i][1];\\n            for(int j=0;j<nums2.length;j++)\\n            {\\n                nums2[j]=nums2[j]+(nums1[j]*p);\\n            }\\n        }\\n            if(queries[i][0]==3)\\n            {\\n                long sum=0;\\n                for(int j:nums2)\\n                {\\n                   sum+=j; \\n                }\\n                a.add(sum);\\n            }\\n    }\\n        long arr[]=new long[a.size()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            arr[i]=a.get(i);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        ArrayList<Long> a=new ArrayList<>();\\n        for(int i=0;i<queries.length;i++)\\n        {\\n        if(queries[i][0]==1)\\n        {\\n        int l=queries[i][1];\\n        int r=queries[i][2];\\n        for(int j=l;j<=r;j++)\\n        {\\n            if(nums1[j]==1)\\n            {\\n                nums1[j]=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3202341,
                "title": "c-segment-tree-lazy-tag",
                "content": "# Intuition\\nC# Segmen Tree\\n\\n# Code\\n```\\npublic class Solution {\\n    const int N = (int)1e5 + 1;\\n    public class Node{\\n        public int l, r;\\n        public long cnt, add;\\n        public Node(int l, int r){\\n            this.l = l;\\n            this.r = r;\\n            this.add = 0;\\n        }\\n    }\\n    Node[] tr = new Node[N * 4];\\n    \\n    public long[] HandleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        Build(1, 1, N);\\n        for(int i = 0; i < nums1.Length; i++){\\n            if(nums1[i] == 1)\\n                Upd(1, i + 1, i + 1);\\n        }\\n        List<long> list = new();\\n        long ans = 0;\\n        foreach(var n in nums2) ans += n;\\n        foreach(var q in queries){\\n            int n = q[0], l = q[1], r = q[2];\\n            if(n == 1)\\n                Upd(1, l + 1, r + 1);\\n            else if(n == 2)\\n                ans += Qr(1, 1, nums2.Length) * (long)l;\\n            else\\n                list.Add(ans);\\n        }\\n        return list.ToArray();\\n    }\\n    \\n    public void Build(int u, int l, int r){\\n        tr[u] = new Node(l, r);\\n        if(l == r) return;\\n        int mid = l + r >> 1;\\n        Build(u << 1, l, mid);\\n        Build(u << 1 | 1, mid + 1, r);\\n    }\\n    \\n    public void PushUp(int u){\\n        tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;\\n    }\\n\\n    public void PushDown(int u, int l, int r){\\n        if (tr[u].add == 0) return;\\n        tr[u << 1].add ^= 1; tr[u << 1 | 1].add ^= 1;\\n        int mid = (l + r) >> 1;\\n        tr[u << 1].cnt = (mid - l + 1) - tr[u << 1].cnt;\\n        tr[u << 1 | 1].cnt = (r - mid) - tr[u << 1 | 1].cnt;\\n        tr[u].add = 0;\\n    }\\n    \\n    public void Upd(int u, int l, int r){\\n        if(tr[u].l >= l && tr[u].r <= r){\\n            tr[u].cnt = tr[u].r - tr[u].l + 1 - tr[u].cnt;\\n            tr[u].add ^= 1;\\n        }\\n        else{\\n            PushDown(u, tr[u].l, tr[u].r);\\n            int mid = tr[u].l + tr[u].r >> 1;\\n            if(mid >= l) Upd(u << 1, l, r);\\n            if(mid < r) Upd(u << 1 | 1, l, r);\\n            PushUp(u);\\n        }\\n    }\\n    \\n    public long Qr(int u, int l, int r){\\n        if(tr[u].l >= l && tr[u].r <= r)\\n            return tr[u].cnt;\\n        int mid = tr[u].l + tr[u].r >> 1;\\n        long ans = 0;\\n        if(mid >= l) ans = Qr(u << 1, l, r);\\n        if(mid < r) ans += Qr(u << 1 | 1, l, r);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int N = (int)1e5 + 1;\\n    public class Node{\\n        public int l, r;\\n        public long cnt, add;\\n        public Node(int l, int r){\\n            this.l = l;\\n            this.r = r;\\n            this.add = 0;\\n        }\\n    }\\n    Node[] tr = new Node[N * 4];\\n    \\n    public long[] HandleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        Build(1, 1, N);\\n        for(int i = 0; i < nums1.Length; i++){\\n            if(nums1[i] == 1)\\n                Upd(1, i + 1, i + 1);\\n        }\\n        List<long> list = new();\\n        long ans = 0;\\n        foreach(var n in nums2) ans += n;\\n        foreach(var q in queries){\\n            int n = q[0], l = q[1], r = q[2];\\n            if(n == 1)\\n                Upd(1, l + 1, r + 1);\\n            else if(n == 2)\\n                ans += Qr(1, 1, nums2.Length) * (long)l;\\n            else\\n                list.Add(ans);\\n        }\\n        return list.ToArray();\\n    }\\n    \\n    public void Build(int u, int l, int r){\\n        tr[u] = new Node(l, r);\\n        if(l == r) return;\\n        int mid = l + r >> 1;\\n        Build(u << 1, l, mid);\\n        Build(u << 1 | 1, mid + 1, r);\\n    }\\n    \\n    public void PushUp(int u){\\n        tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;\\n    }\\n\\n    public void PushDown(int u, int l, int r){\\n        if (tr[u].add == 0) return;\\n        tr[u << 1].add ^= 1; tr[u << 1 | 1].add ^= 1;\\n        int mid = (l + r) >> 1;\\n        tr[u << 1].cnt = (mid - l + 1) - tr[u << 1].cnt;\\n        tr[u << 1 | 1].cnt = (r - mid) - tr[u << 1 | 1].cnt;\\n        tr[u].add = 0;\\n    }\\n    \\n    public void Upd(int u, int l, int r){\\n        if(tr[u].l >= l && tr[u].r <= r){\\n            tr[u].cnt = tr[u].r - tr[u].l + 1 - tr[u].cnt;\\n            tr[u].add ^= 1;\\n        }\\n        else{\\n            PushDown(u, tr[u].l, tr[u].r);\\n            int mid = tr[u].l + tr[u].r >> 1;\\n            if(mid >= l) Upd(u << 1, l, r);\\n            if(mid < r) Upd(u << 1 | 1, l, r);\\n            PushUp(u);\\n        }\\n    }\\n    \\n    public long Qr(int u, int l, int r){\\n        if(tr[u].l >= l && tr[u].r <= r)\\n            return tr[u].cnt;\\n        int mid = tr[u].l + tr[u].r >> 1;\\n        long ans = 0;\\n        if(mid >= l) ans = Qr(u << 1, l, r);\\n        if(mid < r) ans += Qr(u << 1 | 1, l, r);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202281,
                "title": "lazy-propagation-segment-tree-100-on-runtime-and-memory-both",
                "content": "# Intuition\\nThe Intuition is simple, we need to toggle bits of nums1 in range [l, r] and count number of active bits in range [1, n]. This is a standard problem of Segment Tree with lazy propagation. I have implemented the code using gfg library.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log_2 n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int MAX = 500005;\\n    int tree[MAX] = {0};\\n    bool lazy[MAX] = {false};\\n    void toggle(int node, int st, int en, int us, int ue)\\n    {\\n        if (lazy[node])\\n        {\\n            lazy[node] = false;\\n            tree[node] = en - st + 1 - tree[node];\\n            if (st < en)\\n            {\\n                lazy[node<<1] = !lazy[node<<1];\\n                lazy[1+(node<<1)] = !lazy[1+(node<<1)];\\n            }\\n        }\\n        if (st>en || us > en || ue < st)\\n            return ;\\n        if (us<=st && en<=ue)\\n        {\\n            tree[node] = en-st+1 - tree[node];\\n            if (st < en)\\n            {\\n                lazy[node<<1] = !lazy[node<<1];\\n                lazy[1+(node<<1)] = !lazy[1+(node<<1)];\\n            }\\n            return;\\n        }\\n        int mid = (st+en)/2;\\n        toggle((node<<1), st, mid, us, ue);\\n        toggle((node<<1)+1, mid+1,en, us, ue);\\n        if (st < en)\\n            tree[node] = tree[node<<1] + tree[(node<<1)+1];\\n    }\\n    int countQuery(int node, int st, int en, int qs, int qe)\\n    {\\n        if (st>en || qs > en || qe < st)\\n            return 0;\\n        if (lazy[node])\\n        {\\n            lazy[node] = false;\\n            tree[node] = en-st+1-tree[node];\\n            if (st<en)\\n            {\\n                lazy[node<<1] = !lazy[node<<1];\\n                lazy[(node<<1)+1] = !lazy[(node<<1)+1];\\n            }\\n        }\\n        if (qs<=st && en<=qe)\\n            return tree[node];\\n        int mid = (st+en)/2;\\n        return countQuery((node<<1), st, mid, qs, qe) +\\n               countQuery((node<<1)+1, mid+1, en, qs, qe);\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& q) {\\n        int n=nums1.size();\\n        int m=q.size();\\n        vector<long long> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i])\\n                toggle(1, 0, n-1, i, i);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n            ans+=nums2[i];\\n        // cout << countQuery(1, 0, n-1, 0, n-1) << endl;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(q[i][0]==1)\\n            {\\n                int l=q[i][1];\\n                int r=q[i][2];\\n                toggle(1, 0, n-1, l, r);\\n            }\\n            else if(q[i][0]==2)\\n            {\\n                int val=countQuery(1, 0, n-1, 0, n-1);\\n                long long imp=(1ll*q[i][1])*val;\\n                ans+=imp;\\n            }\\n            else\\n                res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int MAX = 500005;\\n    int tree[MAX] = {0};\\n    bool lazy[MAX] = {false};\\n    void toggle(int node, int st, int en, int us, int ue)\\n    {\\n        if (lazy[node])\\n        {\\n            lazy[node] = false;\\n            tree[node] = en - st + 1 - tree[node];\\n            if (st < en)\\n            {\\n                lazy[node<<1] = !lazy[node<<1];\\n                lazy[1+(node<<1)] = !lazy[1+(node<<1)];\\n            }\\n        }\\n        if (st>en || us > en || ue < st)\\n            return ;\\n        if (us<=st && en<=ue)\\n        {\\n            tree[node] = en-st+1 - tree[node];\\n            if (st < en)\\n            {\\n                lazy[node<<1] = !lazy[node<<1];\\n                lazy[1+(node<<1)] = !lazy[1+(node<<1)];\\n            }\\n            return;\\n        }\\n        int mid = (st+en)/2;\\n        toggle((node<<1), st, mid, us, ue);\\n        toggle((node<<1)+1, mid+1,en, us, ue);\\n        if (st < en)\\n            tree[node] = tree[node<<1] + tree[(node<<1)+1];\\n    }\\n    int countQuery(int node, int st, int en, int qs, int qe)\\n    {\\n        if (st>en || qs > en || qe < st)\\n            return 0;\\n        if (lazy[node])\\n        {\\n            lazy[node] = false;\\n            tree[node] = en-st+1-tree[node];\\n            if (st<en)\\n            {\\n                lazy[node<<1] = !lazy[node<<1];\\n                lazy[(node<<1)+1] = !lazy[(node<<1)+1];\\n            }\\n        }\\n        if (qs<=st && en<=qe)\\n            return tree[node];\\n        int mid = (st+en)/2;\\n        return countQuery((node<<1), st, mid, qs, qe) +\\n               countQuery((node<<1)+1, mid+1, en, qs, qe);\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& q) {\\n        int n=nums1.size();\\n        int m=q.size();\\n        vector<long long> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i])\\n                toggle(1, 0, n-1, i, i);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n            ans+=nums2[i];\\n        // cout << countQuery(1, 0, n-1, 0, n-1) << endl;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(q[i][0]==1)\\n            {\\n                int l=q[i][1];\\n                int r=q[i][2];\\n                toggle(1, 0, n-1, l, r);\\n            }\\n            else if(q[i][0]==2)\\n            {\\n                int val=countQuery(1, 0, n-1, 0, n-1);\\n                long long imp=(1ll*q[i][1])*val;\\n                ans+=imp;\\n            }\\n            else\\n                res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3202267,
                "title": "segment-tree-lazy-propagation-toggle-bits-concept-c-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> tree, A, lazy;\\n    void build(long long node, long long start, long long end) {\\n        if (start == end) {\\n            tree[node] = A[start];\\n        } else {\\n            long long mid = (start + end) / 2;\\n            build(2 * node, start, mid);\\n            build(2 * node + 1, mid + 1, end);\\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\\n        }\\n    }\\n\\n    void updateRange(long long node, long long start, long long end, long long l, long long r) {\\n        if (lazy[node] != 0) {\\n            tree[node] = (end - start + 1) - tree[node];\\n            if (start != end) {\\n                lazy[node * 2] = !lazy[node * 2];\\n                lazy[node * 2 + 1] = !lazy[node * 2 + 1];\\n            }\\n            lazy[node] = 0;\\n        }\\n        if (start > end or start > r or end < l)\\n            return;\\n        if (start >= l and end <= r) {\\n            tree[node] = (end - start + 1) - tree[node];\\n            if (start != end) {\\n                lazy[node * 2] = !lazy[node * 2];\\n                lazy[node * 2 + 1] = !lazy[node * 2 + 1];\\n            }\\n            return;\\n        }\\n        long long mid = (start + end) / 2;\\n        updateRange(node * 2, start, mid, l, r);\\n        updateRange(node * 2 + 1, mid + 1, end, l, r);\\n        tree[node] = tree[node * 2] + tree[node * 2 + 1];\\n    }\\n\\n    long long queryRange(long long node, long long start, long long end, long long l, long long r) {\\n        if (start > end or start > r or end < l)\\n            return 0;\\n        if (lazy[node] != 0) {\\n            tree[node] += (end - start + 1) * lazy[node];\\n            if (start != end) {\\n                lazy[node * 2] += lazy[node];\\n                lazy[node * 2 + 1] += lazy[node];\\n            }\\n            lazy[node] = 0;\\n        }\\n        if (start >= l and end <= r)\\n            return tree[node];\\n        long long mid = (start + end) / 2;\\n        long long p1 = queryRange(node * 2, start, mid, l, r);\\n        long long p2 = queryRange(node * 2 + 1, mid + 1, end, l, r);\\n        return (p1 + p2);\\n    }\\n\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        A.resize(n + 1);\\n        tree.resize(5e5);\\n        lazy.resize(5e5);\\n        for(auto &x: lazy){\\n            x = 0;\\n        }\\n        for(int x = 1; x <= n; x++){\\n            A[x] = nums1[x - 1] * 1LL;\\n        }\\n        build(1, 1, n);\\n        long long sum = 0;\\n        for(auto x: nums2){\\n            sum += x * 1LL;\\n        }\\n        vector<long long> res;\\n        for(int x = 0; x < queries.size(); x++){\\n            if(queries[x][0] == 1){\\n                updateRange(1, 1, n, queries[x][1] + 1, queries[x][2] + 1);\\n            }else if(queries[x][0] == 2){\\n                long long off = queryRange(1, 1, n, 1, n);\\n                off = off * (long long)queries[x][1];\\n                sum += off;                \\n            }else{\\n                res.push_back(sum);                \\n            }\\n        }\\n        return res;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> tree, A, lazy;\\n    void build(long long node, long long start, long long end) {\\n        if (start == end) {\\n            tree[node] = A[start];\\n        } else {\\n            long long mid = (start + end) / 2;\\n            build(2 * node, start, mid);\\n            build(2 * node + 1, mid + 1, end);\\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\\n        }\\n    }\\n\\n    void updateRange(long long node, long long start, long long end, long long l, long long r) {\\n        if (lazy[node] != 0) {\\n            tree[node] = (end - start + 1) - tree[node];\\n            if (start != end) {\\n                lazy[node * 2] = !lazy[node * 2];\\n                lazy[node * 2 + 1] = !lazy[node * 2 + 1];\\n            }\\n            lazy[node] = 0;\\n        }\\n        if (start > end or start > r or end < l)\\n            return;\\n        if (start >= l and end <= r) {\\n            tree[node] = (end - start + 1) - tree[node];\\n            if (start != end) {\\n                lazy[node * 2] = !lazy[node * 2];\\n                lazy[node * 2 + 1] = !lazy[node * 2 + 1];\\n            }\\n            return;\\n        }\\n        long long mid = (start + end) / 2;\\n        updateRange(node * 2, start, mid, l, r);\\n        updateRange(node * 2 + 1, mid + 1, end, l, r);\\n        tree[node] = tree[node * 2] + tree[node * 2 + 1];\\n    }\\n\\n    long long queryRange(long long node, long long start, long long end, long long l, long long r) {\\n        if (start > end or start > r or end < l)\\n            return 0;\\n        if (lazy[node] != 0) {\\n            tree[node] += (end - start + 1) * lazy[node];\\n            if (start != end) {\\n                lazy[node * 2] += lazy[node];\\n                lazy[node * 2 + 1] += lazy[node];\\n            }\\n            lazy[node] = 0;\\n        }\\n        if (start >= l and end <= r)\\n            return tree[node];\\n        long long mid = (start + end) / 2;\\n        long long p1 = queryRange(node * 2, start, mid, l, r);\\n        long long p2 = queryRange(node * 2 + 1, mid + 1, end, l, r);\\n        return (p1 + p2);\\n    }\\n\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        int n = nums1.size();\\n        A.resize(n + 1);\\n        tree.resize(5e5);\\n        lazy.resize(5e5);\\n        for(auto &x: lazy){\\n            x = 0;\\n        }\\n        for(int x = 1; x <= n; x++){\\n            A[x] = nums1[x - 1] * 1LL;\\n        }\\n        build(1, 1, n);\\n        long long sum = 0;\\n        for(auto x: nums2){\\n            sum += x * 1LL;\\n        }\\n        vector<long long> res;\\n        for(int x = 0; x < queries.size(); x++){\\n            if(queries[x][0] == 1){\\n                updateRange(1, 1, n, queries[x][1] + 1, queries[x][2] + 1);\\n            }else if(queries[x][0] == 2){\\n                long long off = queryRange(1, 1, n, 1, n);\\n                off = off * (long long)queries[x][1];\\n                sum += off;                \\n            }else{\\n                res.push_back(sum);                \\n            }\\n        }\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202234,
                "title": "java-segmenttree-with-lazy-propagation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        long curSum = 0L;\\n        for (int i = 0; i < nums2.length; i++) {\\n            curSum += nums2[i];\\n        }\\n        \\n        SegTree tree = new SegTree(nums1);\\n        \\n        int resultSize = 0;\\n        for(int i = 0; i < queries.length; i++) {\\n            if (queries[i][0] == 3) resultSize++;\\n        }\\n        \\n        long[] result = new long[resultSize];\\n        \\n        int pos = 0;\\n        for (int[] q : queries){\\n            if (q[0] == 1) {\\n                tree.update(q[1], q[2]);\\n            }\\n            if (q[0] == 2) {\\n                curSum += tree.query(0, nums1.length - 1) * q[1];\\n            }\\n            if (q[0] == 3) {\\n                result[pos++] = curSum;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private static class SegTree{\\n        \\n        long[] tree;\\n        boolean[] flip;\\n        int size;\\n        \\n        public SegTree(int nums[]) {\\n            int s = 1;\\n            while (s < nums.length) s <<= 1;\\n            size = s;\\n            tree = new long[s * 2];\\n            flip = new boolean[s * 2];\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                tree[i + size] = nums[i];\\n            }\\n            for (int i = size - 1; i > 0; i--) {\\n                tree[i] = tree[i * 2] + tree[i * 2 + 1];\\n            }\\n        }\\n        \\n        public long query(int start, int end) {\\n            return query(start, end, 0, size - 1, 1);\\n        }\\n        \\n        public long query(int start, int end, int low, int high, int cur) {\\n            if (flip[cur]) {\\n                tree[cur] = high - low + 1 - tree[cur];\\n                if (low != high) {\\n                    flip[cur * 2] = !flip[cur * 2];\\n                    flip[cur * 2 + 1] = !flip[cur * 2 + 1];\\n                }\\n                flip[cur] = false;\\n            }\\n            if (start > high || end < low)\\n                return 0L;\\n            if (start <= low && end >= high) {\\n                return tree[cur];\\n            }\\n            \\n            int mid = low + (high - low) / 2;\\n            return query(start, end, low, mid, cur * 2) + query(start, end, mid + 1, high, cur * 2 + 1);\\n        }\\n        \\n        public void update(int start, int end) {\\n            update(start, end, 0, size - 1, 1);\\n        }\\n        \\n        public void update(int start, int end, int low, int high, int cur) {\\n            if (flip[cur]) {\\n                tree[cur] = high - low + 1 - tree[cur];\\n                if (low != high) {\\n                    flip[cur * 2] = !flip[cur * 2];\\n                    flip[cur * 2 + 1] = !flip[cur * 2 + 1];\\n                }\\n                flip[cur] = false;\\n            }\\n            \\n            if (start > high || end < low) return;\\n            if (start <= low && end >= high) {\\n                tree[cur] = high - low + 1 - tree[cur];\\n                if (low != high) {\\n                    flip[cur * 2] = !flip[cur * 2];\\n                    flip[cur * 2 + 1] = !flip[cur * 2 + 1];\\n                }\\n                return;\\n            }\\n            \\n            int mid = low + (high - low) / 2;\\n            update(start, end, low, mid, cur * 2);\\n            update(start, end, mid + 1, high, cur * 2 + 1);\\n            tree[cur] = tree[cur * 2] + tree[cur * 2 + 1];\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\\n        long curSum = 0L;\\n        for (int i = 0; i < nums2.length; i++) {\\n            curSum += nums2[i];\\n        }\\n        \\n        SegTree tree = new SegTree(nums1);\\n        \\n        int resultSize = 0;\\n        for(int i = 0; i < queries.length; i++) {\\n            if (queries[i][0] == 3) resultSize++;\\n        }\\n        \\n        long[] result = new long[resultSize];\\n        \\n        int pos = 0;\\n        for (int[] q : queries){\\n            if (q[0] == 1) {\\n                tree.update(q[1], q[2]);\\n            }\\n            if (q[0] == 2) {\\n                curSum += tree.query(0, nums1.length - 1) * q[1];\\n            }\\n            if (q[0] == 3) {\\n                result[pos++] = curSum;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private static class SegTree{\\n        \\n        long[] tree;\\n        boolean[] flip;\\n        int size;\\n        \\n        public SegTree(int nums[]) {\\n            int s = 1;\\n            while (s < nums.length) s <<= 1;\\n            size = s;\\n            tree = new long[s * 2];\\n            flip = new boolean[s * 2];\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                tree[i + size] = nums[i];\\n            }\\n            for (int i = size - 1; i > 0; i--) {\\n                tree[i] = tree[i * 2] + tree[i * 2 + 1];\\n            }\\n        }\\n        \\n        public long query(int start, int end) {\\n            return query(start, end, 0, size - 1, 1);\\n        }\\n        \\n        public long query(int start, int end, int low, int high, int cur) {\\n            if (flip[cur]) {\\n                tree[cur] = high - low + 1 - tree[cur];\\n                if (low != high) {\\n                    flip[cur * 2] = !flip[cur * 2];\\n                    flip[cur * 2 + 1] = !flip[cur * 2 + 1];\\n                }\\n                flip[cur] = false;\\n            }\\n            if (start > high || end < low)\\n                return 0L;\\n            if (start <= low && end >= high) {\\n                return tree[cur];\\n            }\\n            \\n            int mid = low + (high - low) / 2;\\n            return query(start, end, low, mid, cur * 2) + query(start, end, mid + 1, high, cur * 2 + 1);\\n        }\\n        \\n        public void update(int start, int end) {\\n            update(start, end, 0, size - 1, 1);\\n        }\\n        \\n        public void update(int start, int end, int low, int high, int cur) {\\n            if (flip[cur]) {\\n                tree[cur] = high - low + 1 - tree[cur];\\n                if (low != high) {\\n                    flip[cur * 2] = !flip[cur * 2];\\n                    flip[cur * 2 + 1] = !flip[cur * 2 + 1];\\n                }\\n                flip[cur] = false;\\n            }\\n            \\n            if (start > high || end < low) return;\\n            if (start <= low && end >= high) {\\n                tree[cur] = high - low + 1 - tree[cur];\\n                if (low != high) {\\n                    flip[cur * 2] = !flip[cur * 2];\\n                    flip[cur * 2 + 1] = !flip[cur * 2 + 1];\\n                }\\n                return;\\n            }\\n            \\n            int mid = low + (high - low) / 2;\\n            update(start, end, low, mid, cur * 2);\\n            update(start, end, mid + 1, high, cur * 2 + 1);\\n            tree[cur] = tree[cur * 2] + tree[cur * 2 + 1];\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202203,
                "title": "c-segment-tree-solution",
                "content": "\\n# Approach\\nUse segment trees with lazy update to flip values of nums1 array. Using this we can easily keep track of ones present in nums1 array.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>tree;\\n    vector<int>lazy;\\n    void lazy_update(int s,int e,int i)\\n    {\\n        if(lazy[i]>0)\\n        {\\n            swap(tree[i].first,tree[i].second);\\n            if(s!=e)\\n            {\\n                lazy[2*i+1]=(lazy[2*i+1]+1)%2;\\n                lazy[2*i+2]=(lazy[2*i+2]+1)%2;\\n            }\\n            lazy[i]=(lazy[i]+1)%2;\\n        }\\n    }\\n    void build(int s,int e,int i,vector<int>&v)\\n    {\\n        if(s==e)\\n        {\\n            if(v[s]==0)\\n            {\\n                tree[i].first++;\\n            }else\\n            {\\n                tree[i].second++;\\n            }\\n            return;\\n        }\\n        int mid=(s+e)>>1;\\n        build(s,mid,2*i+1,v);\\n        build(mid+1,e,2*i+2,v);\\n        tree[i].first=tree[2*i+1].first+tree[2*i+2].first;\\n        tree[i].second=tree[2*i+1].second+tree[2*i+2].second;\\n        return;\\n    }\\n    void update(int s,int e,int i,int l,int r)\\n    {\\n        lazy_update(s,e,i);\\n        if(s>r || e<l)\\n        {\\n            return;\\n        }\\n        if(l<=s and e<=r)\\n        {\\n            lazy[i]=(lazy[i]+1)%2;\\n            lazy_update(s,e,i);\\n            return;\\n        }\\n        int mid=(s+e)/2;\\n        update(s,mid,2*i+1,l,r);\\n        update(mid+1,e,2*i+2,l,r);\\n        tree[i].first=tree[2*i+1].first+tree[2*i+2].first;\\n        tree[i].second=tree[2*i+1].second+tree[2*i+2].second;\\n        return;\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n       int n=nums1.size();\\n       tree=vector<pair<int,int>>(4*n);\\n       lazy.assign(4*n,0);\\n       long long ans=0;\\n        for(auto &itr:nums2)\\n        {\\n            ans+=itr;\\n        }\\n        build(0,n-1,0,nums1);\\n        vector<long long>res;\\n       for(auto itr:queries)\\n       {\\n           int type=itr[0];\\n           if(type==1)\\n           {\\n               int l=itr[1],r=itr[2];\\n               update(0,n-1,0,l,r);\\n           }\\n           else if(type==2)\\n           {\\n               long long p=itr[1];\\n               ans+=(1LL*tree[0].second)*p;\\n           }else\\n           {\\n               res.push_back(ans);\\n           }\\n       }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>tree;\\n    vector<int>lazy;\\n    void lazy_update(int s,int e,int i)\\n    {\\n        if(lazy[i]>0)\\n        {\\n            swap(tree[i].first,tree[i].second);\\n            if(s!=e)\\n            {\\n                lazy[2*i+1]=(lazy[2*i+1]+1)%2;\\n                lazy[2*i+2]=(lazy[2*i+2]+1)%2;\\n            }\\n            lazy[i]=(lazy[i]+1)%2;\\n        }\\n    }\\n    void build(int s,int e,int i,vector<int>&v)\\n    {\\n        if(s==e)\\n        {\\n            if(v[s]==0)\\n            {\\n                tree[i].first++;\\n            }else\\n            {\\n                tree[i].second++;\\n            }\\n            return;\\n        }\\n        int mid=(s+e)>>1;\\n        build(s,mid,2*i+1,v);\\n        build(mid+1,e,2*i+2,v);\\n        tree[i].first=tree[2*i+1].first+tree[2*i+2].first;\\n        tree[i].second=tree[2*i+1].second+tree[2*i+2].second;\\n        return;\\n    }\\n    void update(int s,int e,int i,int l,int r)\\n    {\\n        lazy_update(s,e,i);\\n        if(s>r || e<l)\\n        {\\n            return;\\n        }\\n        if(l<=s and e<=r)\\n        {\\n            lazy[i]=(lazy[i]+1)%2;\\n            lazy_update(s,e,i);\\n            return;\\n        }\\n        int mid=(s+e)/2;\\n        update(s,mid,2*i+1,l,r);\\n        update(mid+1,e,2*i+2,l,r);\\n        tree[i].first=tree[2*i+1].first+tree[2*i+2].first;\\n        tree[i].second=tree[2*i+1].second+tree[2*i+2].second;\\n        return;\\n    }\\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n       int n=nums1.size();\\n       tree=vector<pair<int,int>>(4*n);\\n       lazy.assign(4*n,0);\\n       long long ans=0;\\n        for(auto &itr:nums2)\\n        {\\n            ans+=itr;\\n        }\\n        build(0,n-1,0,nums1);\\n        vector<long long>res;\\n       for(auto itr:queries)\\n       {\\n           int type=itr[0];\\n           if(type==1)\\n           {\\n               int l=itr[1],r=itr[2];\\n               update(0,n-1,0,l,r);\\n           }\\n           else if(type==2)\\n           {\\n               long long p=itr[1];\\n               ans+=(1LL*tree[0].second)*p;\\n           }else\\n           {\\n               res.push_back(ans);\\n           }\\n       }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1805570,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1805684,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1805612,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1805610,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1806932,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1806085,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1806050,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1806011,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1830185,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1821285,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1805570,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1805684,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1805612,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1805610,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1806932,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1806085,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1806050,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1806011,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1830185,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            },
            {
                "id": 1821285,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Only thing I could do was to get TLE "
                    },
                    {
                        "username": "drexdelta",
                        "content": "I solved literally 10 seconds after contest :) ."
                    },
                    {
                        "username": "drexdelta",
                        "content": "[@dtkalla](/dtkalla)  Use Segment tree with Lazy Prop."
                    },
                    {
                        "username": "dtkalla",
                        "content": "Same!\\nI got to TLE, did various optimizations, stayed at TLE..."
                    },
                    {
                        "username": "Diamantis",
                        "content": "I kept getting closer to the solution one step at a time but I wasn\\'t able to perform the queries of type 1 in non-linear time to the length of the query. The other 2 query types were optimized to constant time but this wasn\\'t enough. I got a lot to learn, Imagine solving this problem in under 10 minutes like the top people in [biweekly contest 98](https://leetcode.com/contest/biweekly-contest-98/)."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Don\\'t fret, the algorithm (segment tree) is not a very popular/too hard in job interviews but pretty common in competitive programming, so it really is a matter of perspective. If you seen it more than enough you know what to do."
                    },
                    {
                        "username": "piudpie",
                        "content": "Similar question : https://codeforces.com/blog/entry/103759"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Lol the problem totally got me, looks like similar problem I solved almost 6 months back during practice, never thought Leetcode could ask SGT so was searching prefsum solution 😂, very good problem it is btw, Again thanks for the link."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "Thanks for mentioning the link."
                    },
                    {
                        "username": "quicklybly",
                        "content": "please make really EASY to understand explanation. "
                    },
                    {
                        "username": "drexdelta",
                        "content": "segment tree with lazy propagation... just the same concept. "
                    },
                    {
                        "username": "piudpie",
                        "content": "I see many solutions using bitwise operations . I have a doubt, what if we have 10^5 queries and every query have l and r as 1 and 10^5. Then we are left shifting 10^5 times per query, why won\\'t this TLE ? Also can someone explain time complexity of Bit count and left shift / right shift operation. Can we do it in C++, like using bitset ? Thank you"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The shifting of a mask with just one set bit can be done in O(1) (you just have to clear one bit and set another bit). Shifting in general and counting set bits is indeed linear as far as I know, but it can be done with a very low constant factor using the CPUs very fast bit-manipulation instructions. Shifting and popcount can be performed on a block of 32 or 64 bits in just one CPU instruction that takes less cycles than a single integer multiplication and probably even less than an addition. C++'s bitset is built on these bit-level instructions, i.e. bitset operations are very fast (have a very low constant factor). I have a solution with bitset that passes all tests (https://leetcode.com/submissions/detail/901007059/). Nevertheless, it might be possible to construct a test case that would result in TLE for all the quadratic solutions. But the constraints of 1e5 instead of 2e5 or more are actually very benign ..."
                    },
                    {
                        "username": "vizzy205",
                        "content": "I just want to use inbuilt segmentTree package from Python once to solve such problems "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Is there a solution without segment tree, treap or other sophisticated data structure? I think it could be done with two layers Fenwick tree (working with prefix sums of prefix sums of difference array), but that is even worse to implement than a segment tree ..."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@ianliu1015](/ianliu1015) That\\'s neat. I think it is quadratic but bit operations are very fast on most CPUs so you have a low constant factor!"
                    },
                    {
                        "username": "ianliu1015",
                        "content": "Passed using some built-in bit manipulation functions. Probably not the optimal solution or time complexity."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Brute force gives 72/75 tests passed and... Not even TLE. It says \"Wrong answer\"..."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "[@Jeetaksh](/Jeetaksh) yes, really, it gives wrong answer. "
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "[@Jeetaksh](/Jeetaksh)  No i am also not getting TLE . It shows only 72/75 passed"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Not really, it gives TLE."
                    },
                    {
                        "username": "nikita_shkaruba",
                        "content": "Add `Segment Tree` tag, please!\n\nThis problem should appear [here](https://leetcode.com/tag/segment-tree/)"
                    },
                    {
                        "username": "tanni26",
                        "content": "Who tf asks such questions in an interview?"
                    }
                ]
            }
        ]
    }
]