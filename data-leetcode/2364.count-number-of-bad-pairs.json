[
    {
        "title": "Count Number of Bad Pairs",
        "question_content": "You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].\nReturn the total number of bad pairs in nums.\n&nbsp;\nExample 1:\n\nInput: nums = [4,1,3,3]\nOutput: 5\nExplanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.\nThe pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.\nThe pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.\nThe pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.\nThe pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.\nThere are a total of 5 bad pairs, so we return 5.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: 0\nExplanation: There are no bad pairs.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2388183,
                "title": "n-n-1-2-valid-c-java",
                "content": "When I first saw the question 2 different ways striked my mind:\\n1. Merge sort\\n2. Segment tree\\n\\nAfter sometimes I realised that none of them fits :(\\n\\n**Trick to this problem**: \\n        `Total`= `Valid` + `Invalid`\\n        `Invalid` = `Total`- `Valid`\\n    \\n **The real Equation**:   `( j - i )` != `( A[j] - A[i] )`\\n **The simple and more intuitive form of above equation**:    `( j - A[j] )` != `( i - A[i] )`\\n    \\n The above equation is exactly similar to problem:\\n - **[1814. Count Nice Pairs in an Array](https://leetcode.com/contest/biweekly-contest-49/problems/count-nice-pairs-in-an-array/)**\\n \\nFor faster access to valid count, we just need a hashmap.\\n  \\n **Time** - O(`n`)\\n **Space** - O(`n`)\\n \\n **Solution 1**:\\n \\n During runtime we keep counting `valid` and just extract `invalid` from `total` till every index.\\n \\n# C++\\n     long long countBadPairs(vector<int>& a,long cnt=0) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<size(a);i++)\\n            cnt+= i- mp[i-a[i]]++;\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public long countBadPairs(int[] a) {\\n        long cnt=0;\\n        HashMap<Integer,Integer> mp= new HashMap<>();\\n        for(int i=0;i<a.length;i++){\\n            int prev= mp.getOrDefault(i-a[i],0);\\n            cnt+= i- prev;\\n            mp.put(i-a[i],prev+1);\\n        }\\n        return cnt;\\n    }\\n\\t\\n**Solution 2**:\\n\\nLets say array is **[1,2,3,4]**.\\nFor 1 , it will make pair with all previous elements i.e **0 pairs**.\\nFor 2 , it will make pair with all previous elements i.e [1] which **1 pair**.\\nFor 3 , it will make pair with all previous elements i.e [1,2] which is **2 pairs**.\\nFor 4 , it will make pair with all previous elements i.e [1,2,3] which is **3 pairs**.\\n\\nNow the total count of pair is = **0 + 1 + 2 + 3**  which is **sum of whole numbers** i.e **n * (n-1)/2** .\\n\\n\\nWe simply count the `valid pairs`  from above equation and `subtract` it from total pairs in array i.e `n* (n-1)/2`.  \\n\\n`Invalid`= `n*(n-1)/2` - `valid`\\n\\n# C++\\n    long long countBadPairs(vector<int>& a,long cnt=0) {\\n        unordered_map<int,int> mp;\\n        int n=size(a);\\n        for(int i=0;i<n;i++)\\n            cnt+= mp[i-a[i]]++;\\n        return 1L*n*(n-1)/2 - cnt;\\n    }\\n# Java\\n    public long countBadPairs(int[] a) {\\n        long cnt=0;\\n        int n= a.length;\\n        HashMap<Integer,Integer> mp= new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int prev= mp.getOrDefault(i-a[i],0);\\n            cnt+= prev;\\n            mp.put(i-a[i],prev+1);\\n        }\\n        return 1L*n*(n-1)/2-cnt;\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "When I first saw the question 2 different ways striked my mind:\\n1. Merge sort\\n2. Segment tree\\n\\nAfter sometimes I realised that none of them fits :(\\n\\n**Trick to this problem**: \\n        `Total`= `Valid` + `Invalid`\\n        `Invalid` = `Total`- `Valid`\\n    \\n **The real Equation**:   `( j - i )` != `( A[j] - A[i] )`\\n **The simple and more intuitive form of above equation**:    `( j - A[j] )` != `( i - A[i] )`\\n    \\n The above equation is exactly similar to problem:\\n - **[1814. Count Nice Pairs in an Array](https://leetcode.com/contest/biweekly-contest-49/problems/count-nice-pairs-in-an-array/)**\\n \\nFor faster access to valid count, we just need a hashmap.\\n  \\n **Time** - O(`n`)\\n **Space** - O(`n`)\\n \\n **Solution 1**:\\n \\n During runtime we keep counting `valid` and just extract `invalid` from `total` till every index.\\n \\n# C++\\n     long long countBadPairs(vector<int>& a,long cnt=0) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<size(a);i++)\\n            cnt+= i- mp[i-a[i]]++;\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public long countBadPairs(int[] a) {\\n        long cnt=0;\\n        HashMap<Integer,Integer> mp= new HashMap<>();\\n        for(int i=0;i<a.length;i++){\\n            int prev= mp.getOrDefault(i-a[i],0);\\n            cnt+= i- prev;\\n            mp.put(i-a[i],prev+1);\\n        }\\n        return cnt;\\n    }\\n\\t\\n**Solution 2**:\\n\\nLets say array is **[1,2,3,4]**.\\nFor 1 , it will make pair with all previous elements i.e **0 pairs**.\\nFor 2 , it will make pair with all previous elements i.e [1] which **1 pair**.\\nFor 3 , it will make pair with all previous elements i.e [1,2] which is **2 pairs**.\\nFor 4 , it will make pair with all previous elements i.e [1,2,3] which is **3 pairs**.\\n\\nNow the total count of pair is = **0 + 1 + 2 + 3**  which is **sum of whole numbers** i.e **n * (n-1)/2** .\\n\\n\\nWe simply count the `valid pairs`  from above equation and `subtract` it from total pairs in array i.e `n* (n-1)/2`.  \\n\\n`Invalid`= `n*(n-1)/2` - `valid`\\n\\n# C++\\n    long long countBadPairs(vector<int>& a,long cnt=0) {\\n        unordered_map<int,int> mp;\\n        int n=size(a);\\n        for(int i=0;i<n;i++)\\n            cnt+= mp[i-a[i]]++;\\n        return 1L*n*(n-1)/2 - cnt;\\n    }\\n# Java\\n    public long countBadPairs(int[] a) {\\n        long cnt=0;\\n        int n= a.length;\\n        HashMap<Integer,Integer> mp= new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int prev= mp.getOrDefault(i-a[i],0);\\n            cnt+= prev;\\n            mp.put(i-a[i],prev+1);\\n        }\\n        return 1L*n*(n-1)/2-cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2388121,
                "title": "python-o-n-solution-how-to-reverse-a-problem-to-make-it-easier-to-solve",
                "content": "Sometimes a problem is asking you to do X. However, it may be easier to do Y, which is the opposite of X, and \"invert\" the answer of Y to tell you what X is. We do this in two different ways here:\\n\\n1. First, instead of finding the number of pairs that are bad, we\\'ll find the number of pairs that *are not* bad and subtract it from the total number of pairs.\\n   a. Remember, for an array of size n, there are exactly `n * (n - 1) / 2` unique pairs `(i, j)` where `i < j`. We get this from the sum of `i` from `i = 1` to `i = n`. \\n2. Then, consider the equation, `j - i = nums[j] - nums[i]`. The fact that we have two unique indices `i, j` on both sides of this equation is frustrating. It\\'d be easier if we could consider them individually. So, let\\'s rearrange the equation using basic algebra: `j - nums[j] = i - nums[i]`\\n\\nNow the problem is reducible to the classic two-sum problem. For each index `i` and element `nums[i]`, figure out what `i - nums[i]` is. If we have seen this difference before, we can make a \"non-bad\" pair with it.\\n\\nO(N) time and space complexity.\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        tot = len(nums) * (len(nums) - 1) // 2\\n        good = 0\\n        dp = {}\\n        \\n        for i,num in enumerate(nums):\\n            v = i - num\\n            good += dp.get(v, 0)\\n            dp[v] = dp.get(v, 0) + 1\\n        \\n        return tot - good\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        tot = len(nums) * (len(nums) - 1) // 2\\n        good = 0\\n        dp = {}\\n        \\n        for i,num in enumerate(nums):\\n            v = i - num\\n            good += dp.get(v, 0)\\n            dp[v] = dp.get(v, 0) + 1\\n        \\n        return tot - good\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388090,
                "title": "c-python3-hashmap-o-n",
                "content": "\\n\\n* Find difference of nums[i] and i\\n* Use a hashmap to store count of elements that have nums[i] - i difference \\n* Elements which have the same difference(nums[i] - i) will be good pairs. Elements which have different differences will form bad pairs\\n\\n**C++**\\n```\\nlong long countBadPairs(vector<int>& nums) {\\n    long long ans = 0;\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); i++) {\\n        ans += i - m[nums[i] - i];\\n        m[nums[i] - i]++;\\n    }\\n    return ans;\\n}\\n```\\n\\n**Python3**\\n```\\ndef countBadPairs(self, A: List[int]) -> int:\\n    m, ans = defaultdict(int), 0\\n    for i in range(len(A)):\\n        ans += i - m[A[i] - i]\\n        m[A[i] - i] += 1\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\nlong long countBadPairs(vector<int>& nums) {\\n    long long ans = 0;\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); i++) {\\n        ans += i - m[nums[i] - i];\\n        m[nums[i] - i]++;\\n    }\\n    return ans;\\n}\\n```\n```\\ndef countBadPairs(self, A: List[int]) -> int:\\n    m, ans = defaultdict(int), 0\\n    for i in range(len(A)):\\n        ans += i - m[A[i] - i]\\n        m[A[i] - i] += 1\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2388687,
                "title": "python-detailed-explanation-faster-than-100-less-than-100-simple-math",
                "content": "**Appreciate if you could upvote this solution**\\n\\n\\nMethod: `math`\\n\\nFirst, we know that the number of pair combinations for nums is `nCr`\\nAlso, the condition can transform from `i-j != num[j]-num[i]` to `num[i]-i != num[j]-j` via basic calculation.\\nThus, the result should be `nCr - num_of_pairs(num[i]-i == num[j]-j)`\\nThen, we can use a `dict` to store the duplication counts.\\n\\nFor example, `nums = [4, 1, 3, 3, 5, 5]`\\nThen, transforming `nums` to `[4, 0, 1, 0, 1, 0]`\\nand the duplication count dict equals to\\n```\\n{\\n\\t0: 3 // the values stored in indexes 1, 3 and 5 are 0 \\n\\t1: 2 // the values stored in indexes 2 and 4 are 1\\n\\t4: 1 // the values stored in index 0 is 4\\n}\\n```\\nThus, the pair combinations for  `num[i]-i == num[j]-j` is \\n```\\n3C2 (for value 0) + 2C1 (for value 1) + 0 (value 4 is not duplicated)\\n```\\nTherefore, the total number of bad pairs is `6C2 - 3C2 - 2C1 = 11`\\n<br/>\\nCode:\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        nums_len = len(nums)\\n        count_dict = dict()\\n        for i in range(nums_len):\\n            nums[i] -= i\\n            if nums[i] not in count_dict:\\n                count_dict[nums[i]] = 0\\n            count_dict[nums[i]] += 1\\n        \\n        count = 0\\n        for key in count_dict:\\n            count += math.comb(count_dict[key], 2)\\n        return math.comb(nums_len, 2) - count\\n```\\n\\n![image](https://assets.leetcode.com/users/images/696baba3-4b90-41a0-8ab2-a52290514446_1659804723.0299203.png)\\n<br/>\\n**Time complexity**:\\n - O(n) (ignoring the calculation of combination )\\n\\n**Space complexity**:\\n - O(1) (ignoring the calculation of combination )\\n<br/>\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n{\\n\\t0: 3 // the values stored in indexes 1, 3 and 5 are 0 \\n\\t1: 2 // the values stored in indexes 2 and 4 are 1\\n\\t4: 1 // the values stored in index 0 is 4\\n}\\n```\n```\\n3C2 (for value 0) + 2C1 (for value 1) + 0 (value 4 is not duplicated)\\n```\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        nums_len = len(nums)\\n        count_dict = dict()\\n        for i in range(nums_len):\\n            nums[i] -= i\\n            if nums[i] not in count_dict:\\n                count_dict[nums[i]] = 0\\n            count_dict[nums[i]] += 1\\n        \\n        count = 0\\n        for key in count_dict:\\n            count += math.comb(count_dict[key], 2)\\n        return math.comb(nums_len, 2) - count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389021,
                "title": "bad-pairs-total-good-pairs-c-map-hindi-explanation",
                "content": "**A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].\\nReturn the total number of bad pairs in nums.**\\n\\nTo find the bad pairs hum kya kr sakte hain  we can think ulta like\\ntotal no of pairs =no of good pairs+ BAD PAIRS \\ntoh BAD PAIRS =total -good\\nhum essa isliye kr rahain kyunki good pairs nikalna easy h ab wo kaise\\nyr good pairs kya honge jo bad nai h mtlb \\ni<j when j-i==nums[j]-nums[i] hoga \\nso we\\'ill rearrange it to get j-nums[j]==i-nums[i]\\ntoh bas \\nhum ek ek krke array pe iterate karenge phir map main  check karenge ki kya \\n i-nums[i] ki value  present h ki nai agar nai h mtlb humara current no  sabke saath bad pair banayega toh humare ans main uska index add ho jayega or agar \\nhogi toh humara current index un sabkmo chodke uske alawa jitte bhi no h un  sabhi no ke saath pair krlega  bas hum yahi karenge ek  ek krke har i-nums[i] ka count badate jayenge map main or check krlenge\\nki kya wo present h ki nai agar nai h toh direct index add or agar h toh index-uskacount add krdenge ans main  \\nor phir ans return kr denge\\n\\n**please do upvote**\\n```\\n long long countBadPairs(vector<int>& nums) \\n    {\\n        unordered_map<int,int> m;\\n        long long int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m.find(i-nums[i])==m.end())\\n            {\\n                ans+=i;\\n                m[i-nums[i]]=1;\\n            }\\n            else\\n            {\\n                ans=ans+i-m[i-nums[i]];\\n                m[i-nums[i]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n long long countBadPairs(vector<int>& nums) \\n    {\\n        unordered_map<int,int> m;\\n        long long int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m.find(i-nums[i])==m.end())\\n            {\\n                ans+=i;\\n                m[i-nums[i]]=1;\\n            }\\n            else\\n            {\\n                ans=ans+i-m[i-nums[i]];\\n                m[i-nums[i]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388149,
                "title": "java-y-x-f-y-f-x-linear-explained-ttt",
                "content": "We need to find the no of pairs such that `j - i != nums[j] - nums[i] ` OR `j - nums[j] != i - nums[i]`\\n\\n```\\nI found a lovely way to explain the though process:\\n\\nFind difference of nums[i] and i\\nUse a hashmap to store count of elements that have nums[i] - i difference\\nElements which have the same difference(nums[i] - i) will be good pairs. \\nElements which have different differences will form bad pairs\\n```\\n\\n\\nSo, everytime we get a pair of nums[j] and index j, we need to find if the diff `j- nums[j]` has alredy been found. \\n\\u2028If no, it means that the curr nums[j] can form a bad pair with all previous indices as `j - nums[j] != i - nums[i]` , for all i < j\\u2028\\u2028if yes, nums[i] can still form a bad pair with all other indices which we can get from i - seen.get(diff) \\n \\n \\n The hashmap is used to store the number of times a present diff is found\\n\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        long count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int diff = i - nums[i];\\n            if(seen.containsKey(diff)){\\n                count += (i - seen.get(diff));\\n            }else{\\n                count += i;\\n            }\\n            seen.put(diff, seen.getOrDefault(diff, 0) + 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nI found a lovely way to explain the though process:\\n\\nFind difference of nums[i] and i\\nUse a hashmap to store count of elements that have nums[i] - i difference\\nElements which have the same difference(nums[i] - i) will be good pairs. \\nElements which have different differences will form bad pairs\\n```\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        long count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int diff = i - nums[i];\\n            if(seen.containsKey(diff)){\\n                count += (i - seen.get(diff));\\n            }else{\\n                count += i;\\n            }\\n            seen.put(diff, seen.getOrDefault(diff, 0) + 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388160,
                "title": "find-good-pairs-instead-of-bad-pairs-o-n",
                "content": "Count Good pairs instead of Bad pairs\\nAns = Total pairs - No of Good pairs\\nNumber of total pairs where i<j = (n*(n-1))/2\\n\\nA pair is said to be good if i < j and j - i == nums[j] - nums[i]\\nThis can be rewritten as j - nums[j] == i- nums[i]\\n\\nKeep a track of this difference using a map\\n\\nIf difference is found in future - \\nIt is a good pair, add its count to goodpair_count\\nincrement its count also in the map as well.\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        unordered_map<int,int> hash;\\n        long long goodpair_count=0;\\n        long long int n=nums.size();\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            long long difference = i-nums[i];\\n            if(hash.count(difference)==1) \\n            {\\n                goodpair_count+= hash[difference]; \\n                hash[difference]++;\\n            }\\n            else \\n                hash[difference]=1;\\n        }\\n        long long totalpair= (n*(n-1))/2;\\n        return totalpair-goodpair_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        unordered_map<int,int> hash;\\n        long long goodpair_count=0;\\n        long long int n=nums.size();\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            long long difference = i-nums[i];\\n            if(hash.count(difference)==1) \\n            {\\n                goodpair_count+= hash[difference]; \\n                hash[difference]++;\\n            }\\n            else \\n                hash[difference]=1;\\n        }\\n        long long totalpair= (n*(n-1))/2;\\n        return totalpair-goodpair_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426058,
                "title": "java-thought-process-explained",
                "content": "### Approach 1: Brute Force\\n* \\tLets find all pairs (Combinations) in the given array and if the pair satisfies the condition   **j-i != nums[j] - nums[i]**, than it a bad pair ( maintain a counter and increase it whenever the contition satisfies ).\\n* \\tReturn the total count of **Bad pairs**.\\n*   Time Complexity is O(n^2) and constant space. But this gives **TLE.** \\nCode:\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        int pairs = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if( (j-i) != (nums[j]-nums[i]) )\\n                    pairs++;\\n            }\\n        }\\n        \\n        return pairs;\\n    }\\n}\\n```\\n\\n#### My thought process after Approach 1:\\n* I tried but couldn\\'t find any other way to count bad pairs, which would take less time.\\n* I ran throught the equation again....trying to decode it...and i observed:\\n\\t* I found that if **j - i == num[j] - num[i]**   would denote  a good pair --> this made me think---> can i find all good pairs and than subtract them from the total pairs??? ( maybe yes. )\\n\\t* **So now how do i find total pairs?** --> i simply remembered that these are combinations, so went back to the combinations formula which is nCr which mean ways to choose n numbers in pairs or r ---> r here being 2.\\n\\tSo my formula is nC2 == n * (n-1) / 2 ( **do this math on  your own ;).**...)\\n\\t* **So now how do i find total good pairs?**\\n\\t\\t* i have the condition for good pairs as **j - i == num[j] - num[i]**, so if i put both j\\'s and i\\'s in same side i would have **j - num[j] = i-num[i] ----> let this be (a)**. \\n\\t\\t* so good pairs are the one\\'s which have same i - nums[i], where i is the array element.\\n\\t\\t* eg. [4, 1, 3, 3] --> convert using fomula **(a)**----> [-4, 0, -1, 0].\\n\\t\\t\\t* Here -4 occurs only once so it will not form any good pair.\\n\\t\\t\\t* Here 0 occurs 2 times here, so  {0,0} will form **1 good pair.**\\n\\t\\t\\t* Here -1 occurs only once so it will not form any good pair.\\n\\t\\t\\t* Total pairs = **n * (n-1) / 2** = 4 * (4-1) / 2 = 6.\\n\\t\\t\\t* Good pairs = 1.\\n\\t\\t\\t* Bad pairs = Total pairs - good pairs = 6 - 1 = 5.\\n\\t\\t\\t* **Note:  suppose 0 is repeated 4 times, it would form 4C2 good pairs**.\\n\\t\\t\\t* We use a hashmap to store total count of each i-num[i] i.e **{ i-num[i], count }**\\n* Hence now that we know the solution, the code here is:\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            int difference = i-nums[i];\\n            map.put(difference,map.getOrDefault(difference,0)+1);\\n        }\\n        \\n        long total_pairs = (long)nums.length * (nums.length-1) / 2;       //nC2\\n        long good_pairs = 0L;\\n        for(int key: map.keySet()){\\n            if( map.get(key) > 1){\\n                long value = map.get(key);\\n                good_pairs += value*(value-1)/2;         //nC2\\n            }\\n        }\\n        return total_pairs - good_pairs;\\n    }\\n}\\n```\\n\\nPlease Upvote if you find this helpful.\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        int pairs = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if( (j-i) != (nums[j]-nums[i]) )\\n                    pairs++;\\n            }\\n        }\\n        \\n        return pairs;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            int difference = i-nums[i];\\n            map.put(difference,map.getOrDefault(difference,0)+1);\\n        }\\n        \\n        long total_pairs = (long)nums.length * (nums.length-1) / 2;       //nC2\\n        long good_pairs = 0L;\\n        for(int key: map.keySet()){\\n            if( map.get(key) > 1){\\n                long value = map.get(key);\\n                good_pairs += value*(value-1)/2;         //nC2\\n            }\\n        }\\n        return total_pairs - good_pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388109,
                "title": "good-pairs",
                "content": "How many good pairs does `nums[i]` produce?\\n\\nIt will produce good pairs with previous numbers that are equal to `nums[i] - i`. The rest are bad pairs.\\n\\n**C++**\\n```cpp\\nlong long countBadPairs(vector<int>& nums) {\\n    long long res = 0;\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        res += (long long)i - m[nums[i] - i];\\n        ++m[nums[i] - i];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long countBadPairs(vector<int>& nums) {\\n    long long res = 0;\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        res += (long long)i - m[nums[i] - i];\\n        ++m[nums[i] - i];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388309,
                "title": "simple-hashing-o-n",
                "content": "<br/>\\n<i><b>j - i != nums[j] - nums[i]</b></i> can be converted to <i><b>nums[i] - i != nums[j] - j</b></i>.\\n\\nSo, this problem can be converted to <b>count number of pairs such that difference between the number and it\\'s index is not equal.</b>\\n\\nCounting pairs with equal difference between number and it\\'s index is comparatively easier task. So our answer can be \\n<b>total pairs - pairs with equal difference between number and index</b>\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int, long long> count;\\n        long long n = nums.size(), equal = 0;\\n        for(int i = 0; i < n; ++i) count[nums[i]-i]++;\\n        \\n\\t\\t// counting pairs with equal difference between number and it\\'s index\\n\\t\\t// ex. if count[4] = 6, then there will be total (6 * 5) / 2  = 15 unique pairs\\n        for(auto& it: count) equal += ((it.second * (it.second-1)) / 2);\\n        \\n\\t\\t// total possible pairs in array\\n        long long total = (n * (n-1)) / 2;\\n\\t\\t\\n\\t\\t// not equal = total - equal\\n        return total - equal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int, long long> count;\\n        long long n = nums.size(), equal = 0;\\n        for(int i = 0; i < n; ++i) count[nums[i]-i]++;\\n        \\n\\t\\t// counting pairs with equal difference between number and it\\'s index\\n\\t\\t// ex. if count[4] = 6, then there will be total (6 * 5) / 2  = 15 unique pairs\\n        for(auto& it: count) equal += ((it.second * (it.second-1)) / 2);\\n        \\n\\t\\t// total possible pairs in array\\n        long long total = (n * (n-1)) / 2;\\n\\t\\t\\n\\t\\t// not equal = total - equal\\n        return total - equal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388132,
                "title": "hashing",
                "content": "**Intuition :**\\n**j - i != nums[j] - nums[i]** can be written as **j - nums[j] != i - nums[i].**\\n\\n**Now we have to find to find number of pairs whose differnce with there index are not equal.**\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        \\n        long long res(0);\\n        int n(size(nums));\\n        \\n        for (int i=0; i<n; i++) {\\n            nums[i] = i - nums[i];\\n        }\\n        \\n        unordered_map<int, int> m;\\n        for (int i=0; i<n; i++) {\\n            res += (m.count(nums[i])) ? i - m[nums[i]] : i;\\n            m[nums[i]]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        \\n        long long res(0);\\n        int n(size(nums));\\n        \\n        for (int i=0; i<n; i++) {\\n            nums[i] = i - nums[i];\\n        }\\n        \\n        unordered_map<int, int> m;\\n        for (int i=0; i<n; i++) {\\n            res += (m.count(nums[i])) ? i - m[nums[i]] : i;\\n            m[nums[i]]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388123,
                "title": "stepwise-solution-invalid-total-valid-o-n",
                "content": "Steps : \\nNumber of pairs with  j - i != nums[j] - nums[i]  will be equal to Total pairs in array (n * (n - 1) / 2  , n = array length) minus Number of pairs with  j - i == nums[j] - nums[i].\\nHence, Find Number of pairs with  j - i == nums[j] - nums[i]\\nj - i == nums[j] - nums[i] can be written as  nums[i] - i == nums[j] - j\\nReplace ith element of array with nums[i] - i and count number of pairs with same values\\nUsed hashmap to count such pairs\\nReturn Total array pairs - above calculated pairs\\n\\n\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long ans=0L;\\n        int len=nums.length;\\n        for(int i=0;i<len;i++) \\n            nums[i]-=i;\\n        HashMap<Integer,Integer> freq=new HashMap<>();\\n        for(int num:nums) {\\n            freq.put(num,freq.getOrDefault(num,0)+1);\\n        }\\n        for(int key:freq.keySet()) {\\n            if(freq.get(key)>1) {\\n                long value=freq.get(key);\\n                ans+=((value*1L*(value-1L))/2L);\\n            }\\n        }\\n        long length=len;\\n        long total=((length*1L*(length-1L))/2L);\\n        return total-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long ans=0L;\\n        int len=nums.length;\\n        for(int i=0;i<len;i++) \\n            nums[i]-=i;\\n        HashMap<Integer,Integer> freq=new HashMap<>();\\n        for(int num:nums) {\\n            freq.put(num,freq.getOrDefault(num,0)+1);\\n        }\\n        for(int key:freq.keySet()) {\\n            if(freq.get(key)>1) {\\n                long value=freq.get(key);\\n                ans+=((value*1L*(value-1L))/2L);\\n            }\\n        }\\n        long length=len;\\n        long total=((length*1L*(length-1L))/2L);\\n        return total-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389500,
                "title": "typescript-o-n-explained-3-key-ideas",
                "content": "**3 key ideas**\\n\\nWe have 3 key ideas here.\\n\\n1. Invert the task (invert the main condition we need to check). \\n\\t`Total number of pairs = Good pairs count + Bad pairs count`\\n\\ti.e. `Bad pairs count = Total number of pairs - Good pairs count`\\n\\tso instead of checking `!=` we can check `==` if we invert the task:\\n\\t`j - i == nums[j] - nums[i]`.\\n\\t\\n2. Keep an index and the value for the index on the same side of the equation. \\n\\tOriginally, we have: `j - i == nums[j] - nums[i]`. \\n\\tHowever it creates a problem to calculate the difference on each step because it requires we have value from the previous step. \\n\\tIf we rewrite the condition this way: `i - nums[i] == j - nums[j]`, \\n\\ton each `i-th` step we can canculate the difference because we have both variables (index and value) for that.\\n\\n3. Next step gives us the valid condition `i < j` automatically, because `i < (i + 1)`, so for each next index if we calculate and store value for the difference `i - nums[i]`, we can check whether we have such differences already and how much. If we have, we increase the number of good pairs.\\n\\n**How to calculate Total number of pairs**. \\nFor instance, we have an array of size 4 (n = 4). In this case for each next index we have the following pairs:\\n```\\nj  prev indexes\\n0\\n1  0 - pairs [1, 0], i.e. count = 1\\n2  0 1 - pairs [2, 0], [2, 1], i.e. count = 2\\n3  0 1 2 - pairs [3, 0], [3, 1], [3, 2], i.e. count = 3\\n```\\nWe can see that `index == number of pairs` and `total = 0 + 1 + 2 + 3`, i.e. we have an arithmetic progression with the step +1. The sum of arithmetic progression: `sum = N * (a0 + aN) / 2`. In our case: `total = n * (0 + n - 1) / 2 = n * (n - 1) / 2`.\\n\\n**Solution**:\\n\\n```\\nfunction countBadPairs(nums: number[]): number {\\n    return countTotal(nums) - countGoodPairs(nums);\\n}\\n\\nfunction countGoodPairs(nums: number[]): number {\\n    const map = new Map<Difference, Count>();\\n    let goodPairsCount = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        const diff = i - nums[i];\\n        let count = map.get(diff) || 0;\\n        goodPairsCount += count;\\n        map.set(diff, count + 1);\\n    }\\n    return goodPairsCount;\\n}\\n\\nfunction countTotal(nums: number[]): number {\\n    const n = nums.length;\\n    return n * (n - 1) / 2;\\n}\\n\\ntype Difference = number;\\ntype Count = number;\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nj  prev indexes\\n0\\n1  0 - pairs [1, 0], i.e. count = 1\\n2  0 1 - pairs [2, 0], [2, 1], i.e. count = 2\\n3  0 1 2 - pairs [3, 0], [3, 1], [3, 2], i.e. count = 3\\n```\n```\\nfunction countBadPairs(nums: number[]): number {\\n    return countTotal(nums) - countGoodPairs(nums);\\n}\\n\\nfunction countGoodPairs(nums: number[]): number {\\n    const map = new Map<Difference, Count>();\\n    let goodPairsCount = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        const diff = i - nums[i];\\n        let count = map.get(diff) || 0;\\n        goodPairsCount += count;\\n        map.set(diff, count + 1);\\n    }\\n    return goodPairsCount;\\n}\\n\\nfunction countTotal(nums: number[]): number {\\n    const n = nums.length;\\n    return n * (n - 1) / 2;\\n}\\n\\ntype Difference = number;\\ntype Count = number;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388659,
                "title": "python-play-with-the-formula",
                "content": "The given situation can be transformed as `nums[i] - i != nums[j] - j`.\\nIt simply means we take the difference between value and index and compare it with the remaining elements if it is not equal to an element then `ans += 1`.\\n\\nE.g.: if nums was [4,1,3,3] then num[i] - [i] for all i will be [4, 0, 1, 0].\\n\\nNow from the difference array\\n```\\nfor i == 0, num[i] - i != num[j] - j (for j = 1, 2, 3), so ans += 3\\nfor i == 1, num[i] - i != num[j] - j (for j = 2 only), so ans += 1\\nfor i == 2, num[i] - i != num[j] - j (for j = 3 only), so ans += 1\\n\\nTotal ans = 5\\n```\\n\\nNow how can you ***find non-equal elements*** ahead ***without using an inner for loop***?\\nTo do that maintain all indices of distinct elements in a hashmap.\\nSuch that for the above `diff = [4,0,1,0]`, The hashmap `diff_indx contains { 4 : [0], 0: [1, 3], 1: [2] }`.\\n\\nNow, \\n```\\nthe number of elements that are ahead of 4 (at index 0) not having the same value 4 = \\n\\t\\tTotal number of elements after 4 ( = last_index of nums - index of 4 = 3 - 0 = 3 ) \\n\\t\\t+ number of indices in diff_indx[4] hashmap that are greater than the current index\\n```\\n\\n\\nSince we stored the indices in ascending order while scanning, the popleft gives us the index of the current element, and also removes it from the list. Hence,` len(diff_indx[4])` gives us the number of indices in `diff_indx[4]` hashmap that are greater than the current index.\\n\\nSo, we need to pop from left... But in list it can be costly, So, I used a **deque** which **pops elements from both the ends in O(1) time**.\\n\\nTime and Space Complexity = O(n)\\n\\n```\\nclass Solution:\\n    from collections import defaultdict, deque\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        diff = [nums[i] - i for i in range(len(nums))]\\n        diff_indx = defaultdict(deque)\\n        for i, d in enumerate(diff):\\n            diff_indx[d].append(i)\\n        \\n        ans, n = 0, len(diff)\\n        for d in diff:\\n            remaining = n - 1 - diff_indx[d].popleft()\\n            ans += remaining - len(diff_indx[d])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nfor i == 0, num[i] - i != num[j] - j (for j = 1, 2, 3), so ans += 3\\nfor i == 1, num[i] - i != num[j] - j (for j = 2 only), so ans += 1\\nfor i == 2, num[i] - i != num[j] - j (for j = 3 only), so ans += 1\\n\\nTotal ans = 5\\n```\n```\\nthe number of elements that are ahead of 4 (at index 0) not having the same value 4 = \\n\\t\\tTotal number of elements after 4 ( = last_index of nums - index of 4 = 3 - 0 = 3 ) \\n\\t\\t+ number of indices in diff_indx[4] hashmap that are greater than the current index\\n```\n```\\nclass Solution:\\n    from collections import defaultdict, deque\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        diff = [nums[i] - i for i in range(len(nums))]\\n        diff_indx = defaultdict(deque)\\n        for i, d in enumerate(diff):\\n            diff_indx[d].append(i)\\n        \\n        ans, n = 0, len(diff)\\n        for d in diff:\\n            remaining = n - 1 - diff_indx[d].popleft()\\n            ans += remaining - len(diff_indx[d])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388148,
                "title": "very-simple-and-easy-to-understand-c-solution-using-map-with-explaination",
                "content": "<b>Up Vote if you like the solution\\n# The trick here is, subtract the index form its i th element. Then the two no. that makes pair will have same values. Count the no. with same values. Then subtract the possible non bad pair from the total possible pairs.\\n\\nTotal possible pairs for n no. is = n*(n-1)/2;\\nIf you woder where from I got above formula, then here is the answer:\\nThis is basically finding pairs between n numbers.\\n1 2 3 4  5\\nparing can be done like this:\\n with 1 you can take 4 numbers to make a pairs : (1,2) (1,3) (1,4) (1,5)\\n with 2 you can take 3 numbers to make a pairs :  (2,3) (2,4) (2,5)\\n with 3 you can take 2 numbers to make a pairs :  (3,4) (3,5)\\n with 4 you can take 1 numbers to make a pairs :  (4,5)\\nThis pattern shows that total count is dame as sum of (n-1) numbers:  n(n-1)/2\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = nums.size();\\n        long long ans = n*(n -1)/2;\\n        map<long long, long long> mp;\\n        for(int i = 0; i < nums.size(); ++i){\\n            mp[nums[i] - i]++;\\n        }\\n        for(auto m: mp){\\n            ans -= m.second *(m.second - 1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = nums.size();\\n        long long ans = n*(n -1)/2;\\n        map<long long, long long> mp;\\n        for(int i = 0; i < nums.size(); ++i){\\n            mp[nums[i] - i]++;\\n        }\\n        for(auto m: mp){\\n            ans -= m.second *(m.second - 1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390950,
                "title": "very-easy-c-solution-with-detailed-explanation",
                "content": "One of the solution is that for every integer in nums you check its bad pairs\\nBut it will take O(N^2) time and you will get TLE\\n\\nNow another way is that you can count the number of good pairs and subtract it from total number pairs\\nNumber of Bad pair= Total number of pair - Number of good pair\\nBut how will you count good pairs??\\nDefination of good pair\\nj-i = nums[j]-nums[i]\\nOR\\nnums[i] - i = nums[j]-j\\n\\nNow you can store nums[i]-i in a map and every integer with same (nums[i]-i) will form a good pair with each other \\n\\nso if 3 numbers have same (nums[i]-i) they will form (3)*(3-1)/2 number of good pairs \\n\\nEg: 4 5 8 7 10\\n\\n4 5 8 7 10\\n0 1 2 3 4\\n\\nin a map we can store nums[i]-i and how many times it is occuring \\n  for this map will store (4,3) (6, 2)\\n    as there are 3 number with nums[i]-i = 4  :  4-0, 5-1, 7-3\\n\\tand 2 numbers with nums[i]-i = 6 :   8-2, 10-4\\n\\t\\nno 4,5,7 will make goood pairs and 8,10 will make good pairs \\n\\tso total number of good pairs = 3+1=4 \\n\\ttotal pair = 10\\n\\tbad pairs = 10-4 =6\\n\\t\\ncode:\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n       unordered_map<int, long>  mp;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mp[nums[i]-i]++;\\n        }\\n        long long numberOfGoodPair=0;\\n        for(auto x : mp)\\n        { long long n =x.second;\\n            if(x.second>1)\\n                numberOfGoodPair += n*(n-1)/2;\\n        }\\n        long n = nums.size();\\n        long totalPair = n*(n-1)/2;\\n        return totalPiar-numberOfGoodPair;\\n    }\\n};\\n```\\nPlease Upvote if it helps \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n       unordered_map<int, long>  mp;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mp[nums[i]-i]++;\\n        }\\n        long long numberOfGoodPair=0;\\n        for(auto x : mp)\\n        { long long n =x.second;\\n            if(x.second>1)\\n                numberOfGoodPair += n*(n-1)/2;\\n        }\\n        long n = nums.size();\\n        long totalPair = n*(n-1)/2;\\n        return totalPiar-numberOfGoodPair;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388130,
                "title": "cpp-clean-concise-o-n-time-o-n-space",
                "content": "**Intuition** :keep counting the frequency of `v[i]-i` and also keep counting `total` till now\\nSo for current index `i` total bad pairs will be `total - frequency[v[i] - i]`\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countBadPairs(vector<int>& v) {\\n        unordered_map<int,int> mp;\\n        ll tot=0,ans=0,n=v.size();\\n        for(int i=0;i<n;i++){\\n            ans+=tot;\\n            ans-=mp[v[i]-i];\\n            mp[v[i]-i]++;\\n            tot++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**More concise version**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countBadPairs(vector<int>& v) {\\n        unordered_map<int,int> mp;\\n        ll tot=0,ans=0,n=v.size();\\n        for(int i=0;i<n;i++){\\n            ans+=i - mp[v[i]-i];\\n            mp[v[i]-i]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**Time** : O(n)\\n\\n**Space** : O(n)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countBadPairs(vector<int>& v) {\\n        unordered_map<int,int> mp;\\n        ll tot=0,ans=0,n=v.size();\\n        for(int i=0;i<n;i++){\\n            ans+=tot;\\n            ans-=mp[v[i]-i];\\n            mp[v[i]-i]++;\\n            tot++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countBadPairs(vector<int>& v) {\\n        unordered_map<int,int> mp;\\n        ll tot=0,ans=0,n=v.size();\\n        for(int i=0;i<n;i++){\\n            ans+=i - mp[v[i]-i];\\n            mp[v[i]-i]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388246,
                "title": "java-python-3-count-good-pairs-w-brief-explanation-and-analysis",
                "content": "\\nGood pairs have same `nums[i] - i` value, so we can use HashMap to count the number of elements with same hash, `nums[i] - i`, then count the good pairs; Then use total pairs minus good pairs.\\n\\n```java\\n    public long countBadPairs(int[] nums) {\\n        long n = nums.length;\\n        Map<Integer, Integer> good = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            good.merge(nums[i] - i, 1, Integer::sum);\\n        }\\n        long bad = n * (n - 1) / 2;\\n        for (int v : good.values()) {\\n            bad -= v * (v - 1L) / 2;\\n        }\\n        return bad;\\n    }\\n```\\n\\n```python\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        good, n = Counter(), len(nums)\\n        for i, num in enumerate(nums):\\n            good[num - i] += 1\\n        return (n - 1) * n // 2 - sum((v - 1) * v // 2 for v in good.values())\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(n)`, where `n = nums.length`.\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long countBadPairs(int[] nums) {\\n        long n = nums.length;\\n        Map<Integer, Integer> good = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            good.merge(nums[i] - i, 1, Integer::sum);\\n        }\\n        long bad = n * (n - 1) / 2;\\n        for (int v : good.values()) {\\n            bad -= v * (v - 1L) / 2;\\n        }\\n        return bad;\\n    }\\n```\n```python\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        good, n = Counter(), len(nums)\\n        for i, num in enumerate(nums):\\n            good[num - i] += 1\\n        return (n - 1) * n // 2 - sum((v - 1) * v // 2 for v in good.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2737709,
                "title": "easiest-explanation-o-n-c-hashmap-explained",
                "content": "# NO. OF BAD PAIRS =TOTAL PAIRS-GOOD PAIRS\\nclass Solution {\\npublic:\\nlong long countBadPairs(vector<int>& nums) {    \\nlong long ans=0;\\nlong long n=nums.size();\\nunordered_map<long long int,long long int>mpp;\\n**STORING VALUE OF (VALUE ON INDEX -INDEX) IN MAP**\\nfor(int i =0;i<n;i++){\\n    mpp[nums[i]-i]++;\\n}\\nfor(auto it : mpp){\\n    ans+=((it.second-1)*it.second)/2;\\n}\\nreturn ((n*(n-1))/2)-ans;\\n}\\n};\\n\\n** EXPLANATION **\\nfirst we are making an unordered_map to store the nums[index]-index and its occurence.\\nwe get this intution from nums[j]-nums[i] != j-i  . -->> nums[i]-i !=nums[j]-j .\\n\\n**AFTER DOING THIS **\\nFOR THIS TEST CASE : [4,1,3,3]\\nMAP :\\nKEY  FREQUENCY\\n0     -   2\\n1      -  1\\n4    -      1\\nCAN BE IN ANY ORDER . SINCE UNORDERED_MAP.\\n\\nTHERE ARE TWO PAIRS WHOSE NUMS[I]-I EQUALS ZERO . \\nTHEREFORE FOR THEM NUMS[J]-NUMS[I]=J-I . OR  NUMS[I]-I==NUMS[J]-J .{GOOD PAIRS }\\n\\nFOR FINDING TOTAL NUMBER OF PAIRS == Nc2 {COMBINATION FORMULA } 11TH CLASS NCERT .\\nNc2 = N(N-1)/2.\\n\\n.NOW TRAVERSING ALL INDEX OF THE MAP .  IF FREQUENCY OF AN INDEX IS GREATER OR EQUAL TO 2 .\\nIT WILL CONTRIBUTE TO TOTAL NUMBER OF GOOD PAIRS .\\n{\\nfor(auto it : mpp){\\n    ans+=((it.second-1)*it.second)/2;\\n}\\n# FINALLY \\nNUMBER OF BAD PAIR =TOTAL -GOOD PAIRS\\n                                      =n(n-1)/2 -ans . \\n\\n\\nTHANK YOU \\nCODE BY-->> AMAN MAURYA :)\\n\\n",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "class Solution {\\npublic:\\nlong long countBadPairs(vector<int>& nums) {    \\nlong long ans=0;\\nlong long n=nums.size();\\nunordered_map<long long int,long long int>mpp;\\n**STORING VALUE OF (VALUE ON INDEX -INDEX) IN MAP**\\nfor(int i =0;i<n;i++){\\n    mpp[nums[i]-i]++;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2388104,
                "title": "java-hashmap",
                "content": "```\\n/*\\n    rewriting the equation as \\n    nums[i] - i != nums[j] - j\\n    and finding the numbers of pairs on left of jth index which gives the same \"nums[j] - j\" value\\n    \\n*/\\n\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long answer = 0l;\\n        HashMap<Long, Long> map = new HashMap<>();\\n        for (int j = 0; j < nums.length; j++) {\\n            long key = nums[j] - j;\\n            answer += (j - map.getOrDefault(key, 0l));\\n            map.put(key, map.getOrDefault(key, 0l) + 1);\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        long answer = 0l;\\n        HashMap<Long, Long> map = new HashMap<>();\\n        for (int j = 0; j < nums.length; j++) {\\n            long key = nums[j] - j;\\n            answer += (j - map.getOrDefault(key, 0l));\\n            map.put(key, map.getOrDefault(key, 0l) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2388094,
                "title": "using-hashmap",
                "content": "\\n    class Solution {\\n    public long countBadPairs(int[] nums) {\\n        int n=nums.length;\\n        int arr[]=new int[n];\\n        Map<Long,Long> m=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            m.put((long)(i-nums[i]),m.getOrDefault((long)(i-nums[i]),0L)+1);\\n        }\\n        long r=(long)n*(long)(n+1)/2;\\n        for(long t1:m.values()){\\n            r-=t1*(t1+1)/2;\\n        }\\n        return r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        int n=nums.length;\\n        int arr[]=new int[n];\\n        Map<Long,Long> m=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            m.put((long)(i-nums[i]),m.getOrDefault((long)(i-nums[i]),0L)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3393292,
                "title": "c-hashmap-finding-good-pairs",
                "content": "## Explanation\\nInstead of finding the number of bad pairs, we can find the number of good pairs which is easier than the former one.\\n\\nFrom the problem statement, a bad pair is such that `i < j and j - i != nums[j] - nums[i]` . Thus a good pair can be any pair such that `nums[j] - nums[i] = j - i`. The equation would boil down to `nums[i] - i = nums[j] - j`. \\n\\nAnother thing to note is, the number of pairs formed from n values is $$nC2$$ which is $$n*(n-1)/2$$.\\n\\nHence we can find all the m values with same `nums[i] - i` and count the number of good pairs formed from them => $$m*(m-1)/2$$ . \\n\\nFinally we find the bad pairs by subtracting the good pairs from the total pairs.\\n**Result = $$n*(n-1)/2$$ - (No.of good pairs)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    ll countBadPairs(vector<int>& nums) {\\n\\n        unordered_map<ll,ll> mp;\\n        ll res = 0, n = size(nums), total = n * (n - 1) / 2;\\n\\n        for(int i = 0; i < size(nums); i++) mp[nums[i] - i]++;\\n        for(auto &[k,v] : mp) if(v > 1) res += v * (v - 1) / 2;\\n \\n        return total-res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    ll countBadPairs(vector<int>& nums) {\\n\\n        unordered_map<ll,ll> mp;\\n        ll res = 0, n = size(nums), total = n * (n - 1) / 2;\\n\\n        for(int i = 0; i < size(nums); i++) mp[nums[i] - i]++;\\n        for(auto &[k,v] : mp) if(v > 1) res += v * (v - 1) / 2;\\n \\n        return total-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555320,
                "title": "python-elegant-short-o-n-one-line-counter",
                "content": "\\tdef countBadPairs(self, nums: List[int]) -> int:\\n        return sum(x * (len(nums) - x) for x in Counter(i - num for i, num in enumerate(nums)).values()) // 2\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef countBadPairs(self, nums: List[int]) -> int:\\n        return sum(x * (len(nums) - x) for x in Counter(i - num for i, num in enumerate(nums)).values()) // 2\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2391661,
                "title": "bad-pairs-total-pairs-good-pairs-c-easy-solution-beginner-friendly",
                "content": "Total Pairs =  n * (n-1)/2\\nBad Pairs = Total Pairs - Good Pairs\\n\\nGiven Condition \\nBad Pairs : j - i != nums[j] - nums[i]\\nOn rearranging\\nGood Pairs = j - nums[j] == i - nums[i]\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long countBadPairs(vector<int>& a) { \\n        ll n=a.size(); \\n        \\n        map<ll,ll>mp; \\n        \\n        for(int i=0;i<n;i++) \\n        { \\n            a[i]=a[i]-i; \\n\\n            mp[a[i]]++; \\n        } \\n        \\n        ll totPair=(n*(n+1))/2;\\n        \\n        ll goodPair=0; \\n\\n        for(auto x:mp) \\n        { \\n            goodPair+=((x.second)*(x.second+1))/2; \\n        }\\n        return (ll)(totPair-goodPair); \\n         \\n    }\\n};\\n```\\n**Do not forget to upvote if you like the solution**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long countBadPairs(vector<int>& a) { \\n        ll n=a.size(); \\n        \\n        map<ll,ll>mp; \\n        \\n        for(int i=0;i<n;i++) \\n        { \\n            a[i]=a[i]-i; \\n\\n            mp[a[i]]++; \\n        } \\n        \\n        ll totPair=(n*(n+1))/2;\\n        \\n        ll goodPair=0; \\n\\n        for(auto x:mp) \\n        { \\n            goodPair+=((x.second)*(x.second+1))/2; \\n        }\\n        return (ll)(totPair-goodPair); \\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390266,
                "title": "c-map-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n\\t    //j - i != nums[j] - nums[i]\\n        //change this to nums[i]-i==nums[j]-j then we wil subtract this from total pairs to get the desired result\\n        int n=nums.size();\\n        long long res=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i]-i)!=mp.end()){\\n                res+=mp[nums[i]-i];\\n            }\\n            mp[nums[i]-i]++;\\n        }\\n        long long tot=n*1LL*(n-1)/2-res;\\n        return tot;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n\\t    //j - i != nums[j] - nums[i]\\n        //change this to nums[i]-i==nums[j]-j then we wil subtract this from total pairs to get the desired result\\n        int n=nums.size();\\n        long long res=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i]-i)!=mp.end()){\\n                res+=mp[nums[i]-i];\\n            }\\n            mp[nums[i]-i]++;\\n        }\\n        long long tot=n*1LL*(n-1)/2-res;\\n        return tot;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389426,
                "title": "easy-c-solution-using-math",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long>mp;\\n        long long n=nums.size();\\n        long long c=0;\\n        long long a;\\n        for(int i=0;i<n;i++){\\n            c+=mp[i-nums[i]];\\n            mp[i-nums[i]]++;\\n        }\\n       a=((n*(n-1))/2)-c;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long>mp;\\n        long long n=nums.size();\\n        long long c=0;\\n        long long a;\\n        for(int i=0;i<n;i++){\\n            c+=mp[i-nums[i]];\\n            mp[i-nums[i]]++;\\n        }\\n       a=((n*(n-1))/2)-c;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388520,
                "title": "c-totalpairs-good-pairs-bad-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        long long count=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int diff=nums[i]-i;\\n            if(mp[diff]){\\n                count+=mp[diff];\\n            }\\n            mp[diff]++;\\n        }\\n        \\n        long long totalPairs=(long long)(n-1)*(long long)(n)/2;        \\n        return totalPairs-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        long long count=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int diff=nums[i]-i;\\n            if(mp[diff]){\\n                count+=mp[diff];\\n            }\\n            mp[diff]++;\\n        }\\n        \\n        long long totalPairs=(long long)(n-1)*(long long)(n)/2;        \\n        return totalPairs-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388322,
                "title": "c-hashing-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long res=0;\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]-i]++;\\n        for(auto it:mp)\\n        {\\n            n-=it.second;\\n            res+=(long long)n*it.second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long res=0;\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]-i]++;\\n        for(auto it:mp)\\n        {\\n            n-=it.second;\\n            res+=(long long)n*it.second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388136,
                "title": "simple-solution-with-java",
                "content": "**Intuition:**\\nFind good pairs and subtract them from total number of pairs.\\n\\nfrom the question we can deduce that `j - nums[j] =  i - nums[i]` so we\\'ll push `i - nums[i]` to the hash map and then iterate over the map and see how many indexes have same `i - nums[i]` and those are the valid pairs.\\n\\nso just find them and add them valid pair count and total number of pairs in `(N*(N+1))/2;` where N = len-1 as number series would be n-1, n-2, n-3 .. 2,1. \\n\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        \\n        HashMap<Integer, Integer> fMap = new HashMap<>();\\n        int n = nums.length;\\n        long N = 1L * (n-1);\\n        long tp = (N*(N+1))/2;\\n        long vp = 0;\\n        \\n        for(int i = 0; i < n ; i++){\\n            int val = nums[i] - i;\\n            fMap.put(val, fMap.getOrDefault(val,0)+1);\\n        }\\n        \\n        \\n        for(int i = 0; i < n ; i++){\\n            \\n            Integer key = nums[i] - i;\\n            Integer value = fMap.get(key);\\n\\n            if(value >= 2){\\n                vp += value-1;\\n\\n                fMap.put(key, value-1);\\n            }\\n        }\\n        \\n        \\n        return tp-vp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        \\n        HashMap<Integer, Integer> fMap = new HashMap<>();\\n        int n = nums.length;\\n        long N = 1L * (n-1);\\n        long tp = (N*(N+1))/2;\\n        long vp = 0;\\n        \\n        for(int i = 0; i < n ; i++){\\n            int val = nums[i] - i;\\n            fMap.put(val, fMap.getOrDefault(val,0)+1);\\n        }\\n        \\n        \\n        for(int i = 0; i < n ; i++){\\n            \\n            Integer key = nums[i] - i;\\n            Integer value = fMap.get(key);\\n\\n            if(value >= 2){\\n                vp += value-1;\\n\\n                fMap.put(key, value-1);\\n            }\\n        }\\n        \\n        \\n        return tp-vp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735524,
                "title": "hash-table-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthe given Statement is : **j-i!=arr[j]-arr[i]**\\nchange the above statement to **j-arr[j]!=i-arr[i]**\\nNow Calculate the Number of Good pairs and **return Number of Total Pairs - Number of good Pairs.**\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& arr) {\\n        unordered_map<int,int> freq;\\n        long long ans = 0,n = arr.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            arr[i] = i-arr[i];\\n            freq[arr[i]]++;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            freq[arr[i]]--;\\n            ans+=(n-i-1-freq[arr[i]]);\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ea7fb6a3-784c-4df8-81be-b2eb8b957fcf_1688805172.6401658.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& arr) {\\n        unordered_map<int,int> freq;\\n        long long ans = 0,n = arr.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            arr[i] = i-arr[i];\\n            freq[arr[i]]++;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            freq[arr[i]]--;\\n            ans+=(n-i-1-freq[arr[i]]);\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721539,
                "title": "by-counting-number-of-good-pairs",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    typedef long long ll; \\npublic:\\n    long long comb(ll n) {\\n        return n * (n-1) / 2;\\n    }\\n\\n    long long countBadPairs(vector<int>& nums) {\\n        /*\\n        j - i != nums[j] - nums[i] - to be proved\\n        or, nums[j] - j != nums[i] - i\\n        */\\n        unordered_map<int, int> mp;\\n        ll n = nums.size();\\n        if(n == 1) return 0;\\n\\n        ll badPairs = 0;\\n        ll goodPairs = 0;\\n        ll totalPairs = comb(n);\\n\\n        for(int i = 0; i < n; i++) {\\n            ll diff = nums[i] - i;\\n            \\n            if(mp.count(diff) == 1) {\\n                goodPairs += mp[diff];\\n                mp[diff]++;\\n            }\\n            else mp[diff] = 1;\\n        }\\n        \\n        // gave TLE\\n        // for(int i = 0; i < mp.size(); i++) {\\n        //     if(mp[i] > 1) {\\n        //         goodPairs += comb(mp[i]);\\n        //     }\\n        // }\\n\\n        badPairs = totalPairs - goodPairs;\\n        return badPairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll; \\npublic:\\n    long long comb(ll n) {\\n        return n * (n-1) / 2;\\n    }\\n\\n    long long countBadPairs(vector<int>& nums) {\\n        /*\\n        j - i != nums[j] - nums[i] - to be proved\\n        or, nums[j] - j != nums[i] - i\\n        */\\n        unordered_map<int, int> mp;\\n        ll n = nums.size();\\n        if(n == 1) return 0;\\n\\n        ll badPairs = 0;\\n        ll goodPairs = 0;\\n        ll totalPairs = comb(n);\\n\\n        for(int i = 0; i < n; i++) {\\n            ll diff = nums[i] - i;\\n            \\n            if(mp.count(diff) == 1) {\\n                goodPairs += mp[diff];\\n                mp[diff]++;\\n            }\\n            else mp[diff] = 1;\\n        }\\n        \\n        // gave TLE\\n        // for(int i = 0; i < mp.size(); i++) {\\n        //     if(mp[i] > 1) {\\n        //         goodPairs += comb(mp[i]);\\n        //     }\\n        // }\\n\\n        badPairs = totalPairs - goodPairs;\\n        return badPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576592,
                "title": "simplify-inequality",
                "content": "# Approach\\nGiven: i < j and j - i != nums[j] - nums[i].\\nsimplify second one => j - nums[j] != i - nums[i]\\nCreate another array c s/t c[i] = i - nums[i]\\nand use i < j && c[j] != c[i] \\nIt\\'s  simple, isn\\'t it ?\\nTraverse from starting and if that elemnts occur in map then not same element will be total - same & if not present in map then add total element upto that index. Check out code for better understanding.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long ans = 0, n = size(nums);\\n        unordered_map<int,long long> mp;\\n        for(int i=0; i<n; ++i){\\n            int e = i - nums[i];\\n            if(mp.count(e)){\\n                long long same = mp[e];\\n                ans += (i - same);\\n            }else ans += i;\\n            mp[e]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long ans = 0, n = size(nums);\\n        unordered_map<int,long long> mp;\\n        for(int i=0; i<n; ++i){\\n            int e = i - nums[i];\\n            if(mp.count(e)){\\n                long long same = mp[e];\\n                ans += (i - same);\\n            }else ans += i;\\n            mp[e]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569527,
                "title": "total-pair-good-pair",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = size(nums);\\n\\n        long long total_pairs = n*(n-1)/2;\\n        long long good_pairs = 0;\\n        unordered_map<long long, long long> mp;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[nums[i]-i]++;\\n        }\\n\\n        for(auto i:mp){\\n            if(i.second > 1)\\n            {\\n                good_pairs += ((i.second*(i.second-1))/2);\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return total_pairs - good_pairs;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/d8056ee1-bf11-42fa-b052-311b79d13a4c_1685216108.6421616.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = size(nums);\\n\\n        long long total_pairs = n*(n-1)/2;\\n        long long good_pairs = 0;\\n        unordered_map<long long, long long> mp;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[nums[i]-i]++;\\n        }\\n\\n        for(auto i:mp){\\n            if(i.second > 1)\\n            {\\n                good_pairs += ((i.second*(i.second-1))/2);\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return total_pairs - good_pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073392,
                "title": "simple-explanation-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nwe have to make sure that i-nums[i] !=j-nums[j] so first store the difference between index and its corresponding value in a map.\\n\\nnow we just have to form the number of possible pairs and exclude those who have same difference\\n\\n for a particular index i the possible bad pairs would be \\n    (n-(i+1))    // (n- total number of elements)\\n    we have to remove those having same difference as current\\n    so we subtract the count of such indices,thus i have used unordered map to store the count.\\n\\nso the equation becomes \\n        (n-(i+1+count))\\n    here count is number of indices which are greater than i and having the same difference.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        long long ans=0;\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            mp[i-nums[i]]+=1;\\n            i+=1;\\n        }\\n\\n        i=0;\\n        while(i<nums.size())\\n        {\\n            mp[i-nums[i]]-=1;\\n            ans+=(n-(i+1+mp[i-nums[i]]));\\n            i+=1;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        long long ans=0;\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            mp[i-nums[i]]+=1;\\n            i+=1;\\n        }\\n\\n        i=0;\\n        while(i<nums.size())\\n        {\\n            mp[i-nums[i]]-=1;\\n            ans+=(n-(i+1+mp[i-nums[i]]));\\n            i+=1;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737864,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n long long countBadPairs(vector<int>& nums) {\\n    long long ans = 0;\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); i++) {\\n        ans += i - m[nums[i] - i];\\n        m[nums[i] - i]++;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n long long countBadPairs(vector<int>& nums) {\\n    long long ans = 0;\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); i++) {\\n        ans += i - m[nums[i] - i];\\n        m[nums[i] - i]++;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439863,
                "title": "python3-o-n-bad-total-good",
                "content": "- `j-i != nums[j]-nums[i]` is the same as    `nums[i]-i != nums[j]-j`\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        dct=collections.Counter()\\n        for i,el in enumerate(nums):\\n            dct[el-i]+=1\\n        n=len(nums)\\n        total=n*(n-1)//2\\n        good=sum(el*(el-1)//2 for el in dct.values())\\n        return total-good\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        dct=collections.Counter()\\n        for i,el in enumerate(nums):\\n            dct[el-i]+=1\\n        n=len(nums)\\n        total=n*(n-1)//2\\n        good=sum(el*(el-1)//2 for el in dct.values())\\n        return total-good\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417247,
                "title": "javascript-count-good-pairs-and-subtract-from-total-pairs",
                "content": "General idea:\\n1. Count total pairs by summing up indexes\\n2. Count good pairs by counting all pairs with the same difference\\n3. Return the difference\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countBadPairs = function(nums) {\\n    let totalPairs = 0\\n    let goodPairs = 0\\n    let differencesFreqsMap = {}\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        const diff = nums[i] - i\\n        \\n        totalPairs+=i\\n        \\n        if(diff in differencesFreqsMap) {\\n            goodPairs+= differencesFreqsMap[diff]\\n            differencesFreqsMap[diff]++\\n            continue\\n        }\\n        \\n        differencesFreqsMap[diff] = 1\\n    }\\n    \\n    return totalPairs - goodPairs\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countBadPairs = function(nums) {\\n    let totalPairs = 0\\n    let goodPairs = 0\\n    let differencesFreqsMap = {}\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        const diff = nums[i] - i\\n        \\n        totalPairs+=i\\n        \\n        if(diff in differencesFreqsMap) {\\n            goodPairs+= differencesFreqsMap[diff]\\n            differencesFreqsMap[diff]++\\n            continue\\n        }\\n        \\n        differencesFreqsMap[diff] = 1\\n    }\\n    \\n    return totalPairs - goodPairs\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2413012,
                "title": "c-full-explanation-easy-to-understand",
                "content": "So no of invalid pairs will be equal to total pairs - valid pairs. Now we are given that a pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i]. So we can rearrange the statement such that nums[i] - i != nums[j] - j. Seeing the statement we can easily see that pair of indices (i, j) is a good pair if i < j and nums[j] - j == nums[i] - i. So we create a hashmap where we store the frequeny of nums[i] - i. If nums[i] - i is already present in the hashmap it means it forms mp[nums[i] - i] good pairs with it\\'s previous indexes. So i - mp[nums[i] - i] will give use the count of no of bad pairs which means till i-th index mp[nums[i] - i] indexes form good pairs and so the ones\\'s remaining will form bad pairs.\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = nums.size();\\n        unordered_map<long long, long long> mp;\\n        long long count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            count += i - mp[nums[i] - i];\\n            ++mp[nums[i] - i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = nums.size();\\n        unordered_map<long long, long long> mp;\\n        long long count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            count += i - mp[nums[i] - i];\\n            ++mp[nums[i] - i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406024,
                "title": "one-line-solution-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long, long long> mp;\\n        long long res = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            res += (i - mp[i-nums[i]]++);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long, long long> mp;\\n        long long res = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            res += (i - mp[i-nums[i]]++);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404055,
                "title": "c-o-n-time-easy-solution",
                "content": "``` \\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<long long, long long> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]-i]++;\\n        }\\n\\t\\t//Total pairs\\n        long long count = (long long) n *((long long) n-1)/2;    \\n        for(auto i:mp){\\n            count = count - (i.second * (i.second-1)/2);\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<long long, long long> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]-i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2401301,
                "title": "c-easy-o-n",
                "content": "class Solution {\\npublic:\\n\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = nums.size();\\n        \\n        long long total = n * (n-1) / 2;// total pair-> good + bad = nC2\\n        long long cnt = 0;\\n        \\n        unordered_map<int, long long> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[nums[i] - i]++;//same difference -> makes good pairs with each other\\n        }\\n        \\n        for(auto it : mp){\\n            total -= (it.second * (it.second-1) / 2);//total - good pair\\n        }\\n        return total;\\n    }\\n       \\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = nums.size();\\n        \\n        long long total = n * (n-1) / 2;// total pair-> good + bad = nC2\\n        long long cnt = 0;\\n        \\n        unordered_map<int, long long> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[nums[i] - i]++;//same difference -> makes good pairs with each other\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2399108,
                "title": "easy-c-code-simple-concept",
                "content": "First of all Total number of pairs possible = (n*(n-1))/2\\n**To find the number of Bad pairs just subtract the good pairs from it.**\\nTo find the number of good pairs subtract i from nums[i] for each.\\nThen simply sort it at apply the formula (n*(n-1))/2 on the repeated elements.\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long count=0,c;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=nums[i]-i;\\n        }\\n        sort(nums.begin(),nums.end());\\n        long n=nums.size(),x=0;\\n        c=(n*(n-1))/2;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i+1]==nums[i]){\\n                x++;\\n                // cout<<\"x: \"<<x<<endl;\\n                if(i+1==nums.size()-1){\\n                    count+=(x*(x+1))/2;\\n                    break;\\n                }\\n                continue;\\n            }\\n            count+=(x*(x+1))/2;\\n            // cout<<\"count: \"<<count<<endl;\\n            x=0;\\n        }\\n        return c-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long count=0,c;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=nums[i]-i;\\n        }\\n        sort(nums.begin(),nums.end());\\n        long n=nums.size(),x=0;\\n        c=(n*(n-1))/2;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i+1]==nums[i]){\\n                x++;\\n                // cout<<\"x: \"<<x<<endl;\\n                if(i+1==nums.size()-1){\\n                    count+=(x*(x+1))/2;\\n                    break;\\n                }\\n                continue;\\n            }\\n            count+=(x*(x+1))/2;\\n            // cout<<\"count: \"<<count<<endl;\\n            x=0;\\n        }\\n        return c-count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2397622,
                "title": "c-map-o-n-my-600th-question-on-leetcode",
                "content": "\\nWe simplified j - i != nums[j] - nums[i] to  i-nums[i] != j-nums[j].\\n\\nWe firstly found good pairs and substracted these from total number of pairs to get the final answer.\\n\\n\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& a) {\\n        ll i,n=size(a);\\n        unordered_map<ll,ll> m;\\n     \\n        ll ans=(n-1)*n/2, notAns=0,tt=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            tt=i-a[i];\\n            if(m.find(tt)!=m.end())\\n            {\\n                notAns+=m[tt];\\n                m[tt]++;\\n            }\\n            else m[tt]=1;\\n            \\n        }\\n        ans-=notAns;\\n        return ans;\\n    }\\n};\\n```\\n\\nPs: This was my 600th question, please upvote guysss :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& a) {\\n        ll i,n=size(a);\\n        unordered_map<ll,ll> m;\\n     \\n        ll ans=(n-1)*n/2, notAns=0,tt=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            tt=i-a[i];\\n            if(m.find(tt)!=m.end())\\n            {\\n                notAns+=m[tt];\\n                m[tt]++;\\n            }\\n            else m[tt]=1;\\n            \\n        }\\n        ans-=notAns;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389673,
                "title": "bad-total-good-solution-with-detailed-explanation",
                "content": "\\n    //2364. Count Number of Bad Pairs\\n\\n    /*\\n\\t\\n     // bad pairs= i < j and j - i != nums[j] - nums[i].\\n    instead of counting bad pairs we count the good pairs\\n    then, bad pairs= total pairs- good pairs\\n    \\n    for a good pair, \\n    j - i == nums[j] - nums[i]\\n    => j-nums[j]= i-nums[i];\\n    \\n    we store these in a hash map with values as the count of the keys i-nums[i]\\n    \\n    \\n    for an array [ 1,2,3,4] of length 4, \\n    1 can make 3 pairs with the elements {2,3,4} \\n    2 can make 2 pairs with the elements {3,4} \\n    3 can make 1 pairs with the elements {4} \\n    4 can make 0 pairs\\n    \\n    therfore sum = 3 + 2 + 1 + 0= sum of first n-1 elements, ie, n*(n-1)/2\\n    \\n    */\\n    \\n    public long countBadPairs(int[] nums) {\\n        \\n        long n=nums.length, good_pairs=0;\\n        \\n        Map<Integer, Integer> freq_map= new HashMap<>();\\n        \\n        for( int i=0; i<n; i++){\\n            \\n            good_pairs+=freq_map.getOrDefault(i-nums[i], 0);\\n            \\n                freq_map.put(i-nums[i], freq_map.getOrDefault(i-nums[i], 0)+1);\\n            }\\n        \\n        \\n        \\n        return n*(n-1)/2 - good_pairs;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    //2364. Count Number of Bad Pairs\\n\\n    /*\\n\\t\\n     // bad pairs= i < j and j - i != nums[j] - nums[i].\\n    instead of counting bad pairs we count the good pairs\\n    then, bad pairs= total pairs- good pairs\\n    \\n    for a good pair, \\n    j - i == nums[j] - nums[i]\\n    => j-nums[j]= i-nums[i];\\n    \\n    we store these in a hash map with values as the count of the keys i-nums[i]\\n    \\n    \\n    for an array [ 1,2,3,4] of length 4, \\n    1 can make 3 pairs with the elements {2,3,4} \\n    2 can make 2 pairs with the elements {3,4} \\n    3 can make 1 pairs with the elements {4} \\n    4 can make 0 pairs\\n    \\n    therfore sum = 3 + 2 + 1 + 0= sum of first n-1 elements, ie, n*(n-1)/2\\n    \\n    */\\n    \\n    public long countBadPairs(int[] nums) {\\n        \\n        long n=nums.length, good_pairs=0;\\n        \\n        Map<Integer, Integer> freq_map= new HashMap<>();\\n        \\n        for( int i=0; i<n; i++){\\n            \\n            good_pairs+=freq_map.getOrDefault(i-nums[i], 0);\\n            \\n                freq_map.put(i-nums[i], freq_map.getOrDefault(i-nums[i], 0)+1);\\n            }\\n        \\n        \\n        \\n        return n*(n-1)/2 - good_pairs;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2389229,
                "title": "c-hashmap-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\nlong long countBadPairs(vector<int>& nums) {\\n\\tlong long count = 0;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tnums[i] = nums[i] - i;\\n\\t}\\n\\tunordered_map<int, int>mp;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tmp[nums[i]]++;\\n\\t}\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tcount += (nums.size() - (i + mp[nums[i]]));\\n\\t\\tmp[nums[i]]--;\\n\\t\\tif (mp[nums[i]] == 0) {\\n\\t\\t\\tmp.erase(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long countBadPairs(vector<int>& nums) {\\n\\tlong long count = 0;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tnums[i] = nums[i] - i;\\n\\t}\\n\\tunordered_map<int, int>mp;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tmp[nums[i]]++;\\n\\t}\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tcount += (nums.size() - (i + mp[nums[i]]));\\n\\t\\tmp[nums[i]]--;\\n\\t\\tif (mp[nums[i]] == 0) {\\n\\t\\t\\tmp.erase(nums[i]);\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388779,
                "title": "c-hash-solution",
                "content": "good pair => j - i == nums[j] - nums[i]\\nis same as \"nums[j]-j==nums[i]-i\"\\nwe can ues nums[j]-j as hash table key and count each hash group number\\n\\ncount element from back to front\\nif hash not found\\n=> ans+=numsSize-1-i;\\nif hash exist\\n=>ans+=numsSize-1-i-same group\\nwe count from \\n```\\nstruct myhash{\\n    int key;  \\n    int count;\\n    UT_hash_handle hh;\\n};\\nlong long countBadPairs(int* nums, int numsSize){\\n    struct myhash *total = NULL;\\n    \\n    long long ans = 0;\\n    for(int i=numsSize-1;i>=0;i--){\\n        int target = nums[i]-i;\\n        struct myhash *tmp = NULL;\\n        HASH_FIND_INT(total,&target,tmp);\\n        \\n        if(tmp==NULL){\\n            tmp = malloc(sizeof(struct myhash));\\n            tmp->key = target;\\n            tmp->count = 1;\\n            HASH_ADD_INT(total,key,tmp);\\n            ans+=numsSize-1-i;\\n        }\\n        else{\\n            ans+=numsSize-1-i-tmp->count;\\n            tmp->count+=1;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct myhash{\\n    int key;  \\n    int count;\\n    UT_hash_handle hh;\\n};\\nlong long countBadPairs(int* nums, int numsSize){\\n    struct myhash *total = NULL;\\n    \\n    long long ans = 0;\\n    for(int i=numsSize-1;i>=0;i--){\\n        int target = nums[i]-i;\\n        struct myhash *tmp = NULL;\\n        HASH_FIND_INT(total,&target,tmp);\\n        \\n        if(tmp==NULL){\\n            tmp = malloc(sizeof(struct myhash));\\n            tmp->key = target;\\n            tmp->count = 1;\\n            HASH_ADD_INT(total,key,tmp);\\n            ans+=numsSize-1-i;\\n        }\\n        else{\\n            ans+=numsSize-1-i-tmp->count;\\n            tmp->count+=1;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388633,
                "title": "java-ez-2-understand",
                "content": "```\\nclass Solution {\\n    //approach: on simplifying the equation we get nums[i]-i!=nums[j]-j;\\n    //so we make an array of nums[i]-i;\\n    //now to get the number of bad pairs at a point we calculate how many of previous elements are not equal to present one\\n\\t//the map will contain how many times the current element has occurred in the array previously\\n\\t//so number of times different elements were encountered =i-freq\\n    public long countBadPairs(int[] nums) {\\n        int n=nums.length;\\n        int arr[]=new int[n];\\n        for(int i=0;i<n;i++)\\n            arr[i]=nums[i]-i;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        long sum=0;\\n        map.put(arr[0],1);\\n        for(int i=1;i<n;i++){\\n            int freq=map.getOrDefault(arr[i],0);\\n            sum+=(i-freq);\\n            map.put(arr[i],freq+1);\\n        }\\n        return sum; \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    //approach: on simplifying the equation we get nums[i]-i!=nums[j]-j;\\n    //so we make an array of nums[i]-i;\\n    //now to get the number of bad pairs at a point we calculate how many of previous elements are not equal to present one\\n\\t//the map will contain how many times the current element has occurred in the array previously\\n\\t//so number of times different elements were encountered =i-freq\\n    public long countBadPairs(int[] nums) {\\n        int n=nums.length;\\n        int arr[]=new int[n];\\n        for(int i=0;i<n;i++)\\n            arr[i]=nums[i]-i;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        long sum=0;\\n        map.put(arr[0],1);\\n        for(int i=1;i<n;i++){\\n            int freq=map.getOrDefault(arr[i],0);\\n            sum+=(i-freq);\\n            map.put(arr[i],freq+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2388564,
                "title": "java-easy-map-bad-pairs-total-pairs-good-pairs",
                "content": "**Easy Approach, Bad pairs = Total pairs - Good pairs**\\n\\n...\\n\\n public long countBadPairs(int[] nums) {\\n       long c=0;\\n    HashMap<Integer,Integer> mp= new HashMap<>();\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        int prev= mp.getOrDefault(i-nums[i],0);\\n        c= c+ i- prev;\\n        mp.put(i-nums[i],prev+1);\\n    }\\n    return c;\\n    }\\n\\n...",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Easy Approach, Bad pairs = Total pairs - Good pairs**\\n\\n...\\n\\n public long countBadPairs(int[] nums) {\\n       long c=0;\\n    HashMap<Integer,Integer> mp= new HashMap<>();\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        int prev= mp.getOrDefault(i-nums[i],0);\\n        c= c+ i- prev;\\n        mp.put(i-nums[i],prev+1);\\n    }\\n    return c;\\n    }\\n\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 2388372,
                "title": "java-single-pass-hashmap",
                "content": "Consider the number of bad pairs that an array element at index ```i``` can form with all the elements to its left. This number can be maximum ```i``` ( if all pairs are bad pairs). If the number of good pairs ( where the condition is satisfied ```i < j and  j - i == nums[j] - nums[i]``` is ```x```, then number of bad pairs is ```i - x```. \\n\\nThe equation ``` j - i == nums[j] - nums[i]``` can be rewritten as ```nums[j] - j == nums[i] - i``` . We then can convert each element of the array ```nums[i]``` to ```nums[i] - i```. The number of good pairs can be found by simply searching to the left if the same number exists to the left. This can be optimized using a hashmap.\\n```\\npublic long countBadPairs(int[] nums) {\\n        long unEqualCount = 0L;\\n        Map<Integer, Long> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = nums[i] - i;\\n\\t\\t\\tLong equal = 0L;\\n            equal =  map.getOrDefault(nums[i], 0L);\\n            map.put(nums[i], map.getOrDefault(nums[i], 0L) + 1);\\n            unEqualCount += i - equal;\\n        }\\n\\n        return unEqualCount;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```i```\n```i```\n```i < j and  j - i == nums[j] - nums[i]```\n```x```\n```i - x```\n``` j - i == nums[j] - nums[i]```\n```nums[j] - j == nums[i] - i```\n```nums[i]```\n```nums[i] - i```\n```\\npublic long countBadPairs(int[] nums) {\\n        long unEqualCount = 0L;\\n        Map<Integer, Long> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            nums[i] = nums[i] - i;\\n\\t\\t\\tLong equal = 0L;\\n            equal =  map.getOrDefault(nums[i], 0L);\\n            map.put(nums[i], map.getOrDefault(nums[i], 0L) + 1);\\n            unEqualCount += i - equal;\\n        }\\n\\n        return unEqualCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388329,
                "title": "python-o-n-count-easy-approaches",
                "content": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        res = []\\n        for i in range(n):\\n            res.append(nums[i] - i)\\n\\n        a = Counter(res)\\n        ans = n * (n - 1) // 2\\n        for x in a:\\n            if a[x] > 1:\\n                ans -= a[x] * (a[x] - 1) // 2\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        res = []\\n        for i in range(n):\\n            res.append(nums[i] - i)\\n\\n        a = Counter(res)\\n        ans = n * (n - 1) // 2\\n        for x in a:\\n            if a[x] > 1:\\n                ans -= a[x] * (a[x] - 1) // 2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388138,
                "title": "short-concise-counting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long, long long> m;\\n        for(int i=0; i<nums.size(); i++) m[i - nums[i]]++;\\n        \\n        long long cnt = 0;\\n        for(auto i : m) {\\n            if(i.second < 2) continue;\\n            cnt += (long long) ((i.second) * (i.second - 1)) / 2;\\n        }\\n        \\n        return ((nums.size()) * (nums.size() - 1)) / 2 - cnt;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long, long long> m;\\n        for(int i=0; i<nums.size(); i++) m[i - nums[i]]++;\\n        \\n        long long cnt = 0;\\n        for(auto i : m) {\\n            if(i.second < 2) continue;\\n            cnt += (long long) ((i.second) * (i.second - 1)) / 2;\\n        }\\n        \\n        return ((nums.size()) * (nums.size() - 1)) / 2 - cnt;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389775,
                "title": "c-clean-code-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        unordered_map<int, long long> mp;\\n        long long n = nums.size();\\n        long long equal = 0;\\n        for(int i = 0; i < n; ++i) \\n        {\\n            mp[nums[i]-i]++;\\n        }\\n        for(auto i: mp) \\n        {\\n            equal += ((i.second * (i.second-1)) / 2);\\n        }\\n        long long total = (n * (n-1)) / 2;\\n        return total - equal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        unordered_map<int, long long> mp;\\n        long long n = nums.size();\\n        long long equal = 0;\\n        for(int i = 0; i < n; ++i) \\n        {\\n            mp[nums[i]-i]++;\\n        }\\n        for(auto i: mp) \\n        {\\n            equal += ((i.second * (i.second-1)) / 2);\\n        }\\n        long long total = (n * (n-1)) / 2;\\n        return total - equal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226652,
                "title": "simplest-c-best-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long int res = 0 ; \\n       long long  int n = nums.size();\\n        unordered_map<int,int> m ; \\n        long long int total = (n*(n-1))/2;\\n\\n        for(int i = 0; i<n;i++){\\n            nums[i] = nums[i]-i; \\n            res = res + m[nums[i]];\\n            m[nums[i]]++;\\n        }\\n\\n\\n\\n        return total-res;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long int res = 0 ; \\n       long long  int n = nums.size();\\n        unordered_map<int,int> m ; \\n        long long int total = (n*(n-1))/2;\\n\\n        for(int i = 0; i<n;i++){\\n            nums[i] = nums[i]-i; \\n            res = res + m[nums[i]];\\n            m[nums[i]]++;\\n        }\\n\\n\\n\\n        return total-res;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071177,
                "title": "easy-cpp-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long>m;\\n        long long n=nums.size();\\n        long long total=n*(n-1)/2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]-i]++;\\n        }\\n        unsigned long long count=0;\\n        for(auto it:m)\\n        {\\n            if(it.second>1)\\n            {\\n                count+=((it.second * (it.second-1)) / 2);\\n            }\\n        }\\n        return total-count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long>m;\\n        long long n=nums.size();\\n        long long total=n*(n-1)/2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]-i]++;\\n        }\\n        unsigned long long count=0;\\n        for(auto it:m)\\n        {\\n            if(it.second>1)\\n            {\\n                count+=((it.second * (it.second-1)) / 2);\\n            }\\n        }\\n        return total-count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739980,
                "title": "clean-trick-c",
                "content": "We are given the condition :``` j - i != nums[j] - nums[i]```. Rearrange it to``` j - nums[j] != i - nums[i]```. Now every index is self sufficient ! thus facilitating a O(n) solution. Simply count the pairs that are opposite of above condition and subtract it from the total number of pairs that can be made = n*(n-1)/2 -> n = length of the array.\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 1ll*n*(n-1)/2;\\n        unordered_map<int,vector<long long>> m;\\n        for(int i=0;i<n;i++){\\n            m[i-nums[i]].push_back(i);\\n        }\\n        for(auto itr:m){\\n            int k = itr.second.size();\\n            ans-=1ll*k*(k-1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` j - i != nums[j] - nums[i]```\n``` j - nums[j] != i - nums[i]```\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 1ll*n*(n-1)/2;\\n        unordered_map<int,vector<long long>> m;\\n        for(int i=0;i<n;i++){\\n            m[i-nums[i]].push_back(i);\\n        }\\n        for(auto itr:m){\\n            int k = itr.second.size();\\n            ans-=1ll*k*(k-1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576373,
                "title": "simple-solution-using-map-c",
                "content": "**Please upvote if you like my solution .**\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<int,int> m;\\n        long long int ans = 0;\\n        for(int i=0;i<nums.size();i++){ m[nums[i] - i]++;}\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i] - i]--;\\n            // find which one follow nums[i] - i == nums[j] - j\\n\\t\\t\\t// and minus it with remaing with other pairs \\n            ans += nums.size() - i - 1 - m[nums[i] - i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<int,int> m;\\n        long long int ans = 0;\\n        for(int i=0;i<nums.size();i++){ m[nums[i] - i]++;}\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i] - i]--;\\n            // find which one follow nums[i] - i == nums[j] - j\\n\\t\\t\\t// and minus it with remaing with other pairs \\n            ans += nums.size() - i - 1 - m[nums[i] - i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555375,
                "title": "java-easy-approach-detailed-explanation",
                "content": "* *Calculate all Good Pairs Using HashMap<>.*\\n* *A pair is good if there are Two or More Occurrences of (i-arr[i])  in array 7 keep count of it;*\\n* *(N(N-1))/2 this gives us the total posible pairs possible in an Array of size N.*\\n* *Substract i.e. BAD_PAIRS=(Total possible pairs)-( Good Pairs). This is your answer.*\\n```\\nclass Solution {\\n    public long countBadPairs(int[] a) {\\n        int n=a.length;\\n        long g=0l;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n//find occurrence of all Good Pairs and then substract from total posible pairs to get the count of Bad Pairs.! //  \\n        for(int i=0;i<n;i++){\\n            if(hm.containsKey(i-a[i])){g+=(long)hm.get(i-a[i]);}\\n            hm.put(i-a[i],hm.getOrDefault(i-a[i],0)+1);\\n        }\\n     // Formula to calculate the total possible pairs of an array of size N //  \\n        long tot=((long)(n)*(long)(n-1))/(long)2;\\n       \\n        return tot-(long)g;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] a) {\\n        int n=a.length;\\n        long g=0l;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n//find occurrence of all Good Pairs and then substract from total posible pairs to get the count of Bad Pairs.! //  \\n        for(int i=0;i<n;i++){\\n            if(hm.containsKey(i-a[i])){g+=(long)hm.get(i-a[i]);}\\n            hm.put(i-a[i],hm.getOrDefault(i-a[i],0)+1);\\n        }\\n     // Formula to calculate the total possible pairs of an array of size N //  \\n        long tot=((long)(n)*(long)(n-1))/(long)2;\\n       \\n        return tot-(long)g;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541156,
                "title": "java-total-valid",
                "content": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long res = 0;\\n        HashMap<Integer,Integer> map= new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            int prev= map.getOrDefault(i-nums[i] , 0);\\n            res += prev;\\n            map.put(i-nums[i] , prev+1);\\n        }\\n        return (long)nums.length*(nums.length-1)/2 - res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long res = 0;\\n        HashMap<Integer,Integer> map= new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            int prev= map.getOrDefault(i-nums[i] , 0);\\n            res += prev;\\n            map.put(i-nums[i] , prev+1);\\n        }\\n        return (long)nums.length*(nums.length-1)/2 - res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519665,
                "title": "c-total-good-bad",
                "content": "**For calculating bad pairs lets calculte all good pairs and subsract from total pairs ..**\\n \\n **Total pairs** = sum of natural number till n-1 ---> (n) * (n-1) / 2 ..\\n \\n    why ? -- > [1,2,3,4,5] ---> total pairs : [(1,2),(1,3),(1,4),(1,5) ] + [(2,3),(2,4),(2,5)] +[(3,4),(3,5)] +[(4,5)]  == > 4 + 3 + 2 + 1 = 10 ==> (5) * (5-1)/2 = 20 / 2 = 10 ....\\n\\t\\n\\tGood pairs will be formed from pairs whose nums[j] - nums[i]  ==  j - i \\n        means nums[j] - j == nums[i] - i .... \\n\\t\\t so for all element in arr we can do nums[i] = nums[i] - i and store this in any ds ( map used here ) .. \\n\\t\\t this way map[i] will contain cnt of  the elements which will make good pair and we can use the same .. formula for getting pairs [ n * n-1 / 2 ] .. \\n\\t\\n\\t\\n\\t\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unsigned long long cnt = 0;\\n        \\n        unordered_map<unsigned long long,unsigned long long>up;\\n        \\n        unsigned long long n = nums.size();\\n        \\n        for(unsigned long long i = 0 ; i < n ; i++){\\n            nums[i] = nums[i] - i;\\n            up[nums[i]]++;\\n            \\n        }\\n        \\n        unsigned long long total = (long long)((n - 1) * (n) ) / 2;\\n        \\n        unsigned long long  good = 0 ;\\n        \\n        for(auto it = up.begin() ; it!= up.end() ; it++){\\n              if(it->second > 1){\\n                  unsigned long long cnt = it->second;\\n                  good += (long long )((cnt) *(cnt-1))/2;\\n              }\\n        }\\n        \\n        return total - good;\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unsigned long long cnt = 0;\\n        \\n        unordered_map<unsigned long long,unsigned long long>up;\\n        \\n        unsigned long long n = nums.size();\\n        \\n        for(unsigned long long i = 0 ; i < n ; i++){\\n            nums[i] = nums[i] - i;\\n            up[nums[i]]++;\\n            \\n        }\\n        \\n        unsigned long long total = (long long)((n - 1) * (n) ) / 2;\\n        \\n        unsigned long long  good = 0 ;\\n        \\n        for(auto it = up.begin() ; it!= up.end() ; it++){\\n              if(it->second > 1){\\n                  unsigned long long cnt = it->second;\\n                  good += (long long )((cnt) *(cnt-1))/2;\\n              }\\n        }\\n        \\n        return total - good;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480451,
                "title": "c-finding-good-pair",
                "content": "\\t long long countBadPairs(vector<int>& nums) {\\n        long long good_pairs = 0;\\n        long long  n = nums.size();\\n        long long total_pairs = 0;\\n        if(n%2==0)\\n        {\\n            total_pairs = (n/2)*(n-1);\\n        }\\n        else{\\n            total_pairs = (n-1)/2*n;\\n        }\\n       unordered_map<int ,int> map;\\n        for( int i=0 ;i<nums.size() ;i++)\\n        {\\n            int find = nums[i] - i;\\n            if(map.count(find))\\n            {\\n                good_pairs += map[find];\\n            }\\n            map[find]++;\\n        }\\n        return (total_pairs - good_pairs) ;\\n    }",
                "solutionTags": [],
                "code": "\\t long long countBadPairs(vector<int>& nums) {\\n        long long good_pairs = 0;\\n        long long  n = nums.size();\\n        long long total_pairs = 0;\\n        if(n%2==0)\\n        {\\n            total_pairs = (n/2)*(n-1);\\n        }\\n        else{\\n            total_pairs = (n-1)/2*n;\\n        }\\n       unordered_map<int ,int> map;\\n        for( int i=0 ;i<nums.size() ;i++)\\n        {\\n            int find = nums[i] - i;\\n            if(map.count(find))\\n            {\\n                good_pairs += map[find];\\n            }\\n            map[find]++;\\n        }\\n        return (total_pairs - good_pairs) ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2471871,
                "title": "python-solution-brute-force-hashing-o-n",
                "content": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        count=0\\n        n=len(nums)\\n        # for i in range(n):\\n        #     for j in range(i+1, n):\\n        #         if j-i!=nums[j]-nums[i]:\\n        #             count+=1\\n        # return count\\n        d={}\\n        for i in range(n):\\n            if nums[i]-i in d:\\n                count+=d[nums[i]-i]\\n                d[nums[i]-i]+=1\\n            else:\\n                d[nums[i]-i]=1\\n\\n        return (n*(n-1)//2) - count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        count=0\\n        n=len(nums)\\n        # for i in range(n):\\n        #     for j in range(i+1, n):\\n        #         if j-i!=nums[j]-nums[i]:\\n        #             count+=1\\n        # return count\\n        d={}\\n        for i in range(n):\\n            if nums[i]-i in d:\\n                count+=d[nums[i]-i]\\n                d[nums[i]-i]+=1\\n            else:\\n                d[nums[i]-i]=1\\n\\n        return (n*(n-1)//2) - count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463958,
                "title": "80-tc-and-77-sc-easy-python-solution",
                "content": "```\\ndef countBadPairs(self, nums: List[int]) -> int:\\n\\tgood = 0\\n\\tn = len(nums)\\n\\td = defaultdict(int)\\n\\tfor i in range(n):\\n\\t\\tif(nums[i]-i in d):\\n\\t\\t\\tgood += d[nums[i]-i]\\n\\t\\td[nums[i]-i] += 1\\n\\treturn (n*(n-1)//2) - good\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countBadPairs(self, nums: List[int]) -> int:\\n\\tgood = 0\\n\\tn = len(nums)\\n\\td = defaultdict(int)\\n\\tfor i in range(n):\\n\\t\\tif(nums[i]-i in d):\\n\\t\\t\\tgood += d[nums[i]-i]\\n\\t\\td[nums[i]-i] += 1\\n\\treturn (n*(n-1)//2) - good\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2458174,
                "title": "java-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer, Long> pairs = new HashMap<>();\\n        long ans = 0l;\\n        for (int i = 0; i < nums.length; i++) {\\n            int diff = nums[i]-i;\\n            ans += pairs.getOrDefault(diff, 0l);\\n            pairs.put(diff, 1 + pairs.getOrDefault(diff, 0l));\\n        }\\n        return (long) nums.length * (nums.length-1) / 2 - ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer, Long> pairs = new HashMap<>();\\n        long ans = 0l;\\n        for (int i = 0; i < nums.length; i++) {\\n            int diff = nums[i]-i;\\n            ans += pairs.getOrDefault(diff, 0l);\\n            pairs.put(diff, 1 + pairs.getOrDefault(diff, 0l));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2449919,
                "title": "c-o-n-time-very-easy-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long size = nums.size();\\n        unordered_map<int, long long> goodPairs;\\n        \\n        for(int i = 0; i < size; i++){\\n            if(goodPairs.find(nums[i]-i) == goodPairs.end())\\n                goodPairs[nums[i] - i] = 0;\\n            else\\n                goodPairs[nums[i] - i]++;\\n        }\\n        \\n        long long goodCount = 0;\\n        \\n        for(auto x : goodPairs){\\n            goodCount += (x.second*(x.second+1)/2);\\n        }\\n        \\n        long long badCount = (size*(size-1)/2) - goodCount;\\n        \\n        return badCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long size = nums.size();\\n        unordered_map<int, long long> goodPairs;\\n        \\n        for(int i = 0; i < size; i++){\\n            if(goodPairs.find(nums[i]-i) == goodPairs.end())\\n                goodPairs[nums[i] - i] = 0;\\n            else\\n                goodPairs[nums[i] - i]++;\\n        }\\n        \\n        long long goodCount = 0;\\n        \\n        for(auto x : goodPairs){\\n            goodCount += (x.second*(x.second+1)/2);\\n        }\\n        \\n        long long badCount = (size*(size-1)/2) - goodCount;\\n        \\n        return badCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436995,
                "title": "easy-c-soluton-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    long long countBadPairs(vector<int>& nums) {\\n         long long cnt = 0;\\n         for(int i=0; i<nums.size(); i++) cnt+=i - mp[nums[i] - i]++;\\n         return cnt;\\n    }\\n};\\n/*\\nindex:  2   5\\nvalue:  8   11\\ndiff:   6 = 6 good pair\\ncalculate  j - i = a[j] - a[i] where j > i\\n0....j total pairs exists - equal pairs => unequal pairs \\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    long long countBadPairs(vector<int>& nums) {\\n         long long cnt = 0;\\n         for(int i=0; i<nums.size(); i++) cnt+=i - mp[nums[i] - i]++;\\n         return cnt;\\n    }\\n};\\n/*\\nindex:  2   5\\nvalue:  8   11\\ndiff:   6 = 6 good pair\\ncalculate  j - i = a[j] - a[i] where j > i\\n0....j total pairs exists - equal pairs => unequal pairs \\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434428,
                "title": "very-simple-solution-use-map-to-find-frequency",
                "content": "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        long len = nums.length;\\n        long total = len*(len-1)/2;\\n        for(int i = 0;i<nums.length;i++){\\n            nums[i] -= i;\\n        }\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        for(int i : map.keySet()){\\n            long freq = map.get(i);\\n            total -= (freq-1)*(freq)/2;\\n        }\\n        return total;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        long len = nums.length;\\n        long total = len*(len-1)/2;\\n        for(int i = 0;i<nums.length;i++){\\n            nums[i] -= i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2431398,
                "title": "easiest-solution-faster-than-100-efficient-than-100",
                "content": "**Self Explanatory**\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long total=0,countValid =0;\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.size();i++){\\n            total += i;\\n            countValid += umap[i-nums[i]]++;  // j - nums[j] == i - nums[i]\\n        }\\n        return total-countValid;     // invalid\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/4821b554-074e-4090-9734-8dd024534c8a_1660606772.2393253.png)\\n\\n**Please UPVOTE if you like**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long total=0,countValid =0;\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.size();i++){\\n            total += i;\\n            countValid += umap[i-nums[i]]++;  // j - nums[j] == i - nums[i]\\n        }\\n        return total-countValid;     // invalid\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429660,
                "title": "best-and-easytounderstand-code-in-c",
                "content": "##### ***If You Liked my solution then please Upvote***\\n\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n\\t\\n        long long countGoodPairs=0;\\n        long long size=nums.size();\\n        vector<int> vec(size);\\n        for(int i=0;i<size;i++)     //(j - i) != nums[j] - nums[i] can also be written as:-\\n            vec[i]=i-nums[i];       //(j - nums[j]) != (i - nums[i])\\n        unordered_map<int,int> mp;\\n        for(auto it:vec){\\n            if(mp.find(it)!=mp.end())\\n                countGoodPairs+=mp[it];     //counting good pairs\\n            mp[it]++;\\n        }\\n        long long totalPairs=(size*(size-1))/2;  //finding total pairs\\n        long long finalAns=totalPairs-countGoodPairs;  //No of bad pairs= Total pairs - No of good pairs\\n        return finalAns;\\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n\\t\\n        long long countGoodPairs=0;\\n        long long size=nums.size();\\n        vector<int> vec(size);\\n        for(int i=0;i<size;i++)     //(j - i) != nums[j] - nums[i] can also be written as:-\\n            vec[i]=i-nums[i];       //(j - nums[j]) != (i - nums[i])\\n        unordered_map<int,int> mp;\\n        for(auto it:vec){\\n            if(mp.find(it)!=mp.end())\\n                countGoodPairs+=mp[it];     //counting good pairs\\n            mp[it]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2428952,
                "title": "count-number-of-bad-pairs-c-100-less-space",
                "content": "**Here you go -->**\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        // NOTE : data-type has been taken \\'long long\\' everywhere because the return type in the question is given as \\'long long\\' to prevent integer overflow.\\n\\t\\t// TAKING EXAMPLE1 FOR EXPLAINATION, nums=[4,1,3,3];\\n        long long n=nums.size();\\n        long long numDiff=0;                    // declared and assigned 0 to numDiff which will store the difference of nums[i] and i.\\n        map<long long, long long> hash;         // Map to store unique keys with their values\\n        for (int i=0; i<n; i++){\\n            numDiff=nums[i]-i;                  // Calculating the difference which will be 4, 0, 1, 0 for the respective iterations of i.\\n            hash[numDiff]=hash[numDiff]+1;      // We insert the value in map with the key as follows:\\n                                                // map[key]=value;   at 4 value will be 1. This is because when you write map[key]; zero (0) is assigned to the key here Example:- map[5];   Here, 5:0 corresponding to 5 zero is assigned so when you do map[5]=map[5]+1 ==> 5=0+1  ==>5=1. Here 1 act as frequency and in the above code we are finding the frequency of every numDiff.\\n        }\\n        long long totalPairs= (n*(n-1)/2);      // Calc the total number of pairs\\n        cout<<totalPairs<<endl;\\n        long long goodPairs=0, badPairs;\\n        for (auto i:hash)\\n            goodPairs+=(i.second*(i.second-1)/2);   // Count the number of good pairs using the frequency in the map. Here i will be 0, 1, 4 (which are the keys of map). And i.second will give the frequency of those keys.\\n        cout<<goodPairs<<endl;\\n        badPairs=totalPairs-goodPairs;          // At the end calc bad pairs by subtracting good pairs from total pairs.\\n        cout<<badPairs;\\n        return badPairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        // NOTE : data-type has been taken \\'long long\\' everywhere because the return type in the question is given as \\'long long\\' to prevent integer overflow.\\n\\t\\t// TAKING EXAMPLE1 FOR EXPLAINATION, nums=[4,1,3,3];\\n        long long n=nums.size();\\n        long long numDiff=0;                    // declared and assigned 0 to numDiff which will store the difference of nums[i] and i.\\n        map<long long, long long> hash;         // Map to store unique keys with their values\\n        for (int i=0; i<n; i++){\\n            numDiff=nums[i]-i;                  // Calculating the difference which will be 4, 0, 1, 0 for the respective iterations of i.\\n            hash[numDiff]=hash[numDiff]+1;      // We insert the value in map with the key as follows:\\n                                                // map[key]=value;   at 4 value will be 1. This is because when you write map[key]; zero (0) is assigned to the key here Example:- map[5];   Here, 5:0 corresponding to 5 zero is assigned so when you do map[5]=map[5]+1 ==> 5=0+1  ==>5=1. Here 1 act as frequency and in the above code we are finding the frequency of every numDiff.\\n        }\\n        long long totalPairs= (n*(n-1)/2);      // Calc the total number of pairs\\n        cout<<totalPairs<<endl;\\n        long long goodPairs=0, badPairs;\\n        for (auto i:hash)\\n            goodPairs+=(i.second*(i.second-1)/2);   // Count the number of good pairs using the frequency in the map. Here i will be 0, 1, 4 (which are the keys of map). And i.second will give the frequency of those keys.\\n        cout<<goodPairs<<endl;\\n        badPairs=totalPairs-goodPairs;          // At the end calc bad pairs by subtracting good pairs from total pairs.\\n        cout<<badPairs;\\n        return badPairs;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2423556,
                "title": "java-hashmap-explanation",
                "content": "Idea:\\nGiven bad pair are: *nums[i] - nums[i] = j-i* where *j>i*\\n\\nwe can rewrite this like this: *nums[i] - i = nums[i] - j*\\nNow problem becomes simpler.\\nFor each index **k**, we siimply calculate like this: \\ntotalBad += k - (all good pairs until k) \\n\\n```java\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        long totalBad = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            int d = nums[i]-i;\\n            totalBad += i - map.getOrDefault(d, 0);\\n            map.put(d, map.getOrDefault(d, 0)+1);\\n        }\\n        return totalBad;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        long totalBad = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            int d = nums[i]-i;\\n            totalBad += i - map.getOrDefault(d, 0);\\n            map.put(d, map.getOrDefault(d, 0)+1);\\n        }\\n        return totalBad;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419375,
                "title": "java-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i]-i,map.getOrDefault(nums[i]-i,0)+1);\\n        }\\n        long sum=0;\\n        for(int x:map.values())\\n            sum+=((long)x*(x-1))/2; //Counting pairs that are not bad\\n        long total = ((long)(nums.length)*(nums.length-1))/2;\\n        return total-sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i]-i,map.getOrDefault(nums[i]-i,0)+1);\\n        }\\n        long sum=0;\\n        for(int x:map.values())\\n            sum+=((long)x*(x-1))/2; //Counting pairs that are not bad\\n        long total = ((long)(nums.length)*(nums.length-1))/2;\\n        return total-sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419291,
                "title": "c-bad-pairs-total-pairs-good-pair-well-explained-easy",
                "content": "Here, we have found good pairs by the condition :- (i-nums[i])=(j-nums[j])\\nwhere, i<j ;\\nIn this approach we store(  i-nums[i] ) val and its count in an unordered map, that count increment when the same difference we get between the index and the value on that index. That counter is nothing but good pairs .\\nBut, we want bad pairs so,\\nhere total possible pairs with i<j are n*(n-1)/2\\nso , bad pairs= n*(n-1)/2 -counter;\\n \\nI hope it would help you !!\\nif you like plz upvote :))\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long c=0;\\n        long long n=nums.size();\\n        unordered_map<long long,long long>map;\\n   long long  total;  \\n        for(int i=0;i<n;i++)\\n        {\\n            c+=map[i-nums[i]];\\n            map[i-nums[i]]++;\\n        }\\n        total=((n*(n-1)/2)-c);\\n              return total;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long c=0;\\n        long long n=nums.size();\\n        unordered_map<long long,long long>map;\\n   long long  total;  \\n        for(int i=0;i<n;i++)\\n        {\\n            c+=map[i-nums[i]];\\n            map[i-nums[i]]++;\\n        }\\n        total=((n*(n-1)/2)-c);\\n              return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409668,
                "title": "reverse-strategy-counting-number-of-good-pairs-linear-time-solution",
                "content": "The question asks to count number of bad pairs, that is the pairs which satisfy the given condition in the question which is that a pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].\\n\\nBut, if we look closely to the given equation, it can be simplified as nums[i] - i !=nums[j]-j.\\n\\nAnd so, we can now calculate the above reformed equation by just a linear traversal of the given vector of numbers and store the count of (nums[i] - i) in a map. After that, with that count in map, we can simply calculate how many good pairs of indices are there in the list of numbers.\\n\\nAs we calculate the total number of possible pairs when we are given the total number of elements, similarly we can calculate the number of pairs which follow \\nnums[i] - i=nums[j]-j by the count we stored in the map.\\n\\nFinally we can calculate the required number of bad pairs by simply subtracting the number of good pais from total number of pairs possible.\\n\\nI hope it\\'s all clear till now.\\nBelow is the emplementation of the above approach:\\n\\n```\\n// Time Complexity : O(n) as only  linear traversal of elemets is performed.\\n//Space Complexity : O(n) for using the hash map.\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<long long,long long>mp;\\n        for(long i=0;i<nums.size();i++)\\n        {\\n            int diff=nums[i]-i;\\n            mp[diff]++;\\n        }\\n        long long n=nums.size();\\n        long long total=(n*(n-1)/2);\\n        long long cnt=0;\\n        for(auto x=mp.begin();x!=mp.end();x++)\\n        {\\n            if(x->second>1)cnt+=((x->second)*(x->second-1))/2;\\n            \\n        }\\n        return (total-cnt);\\n    }\\n};\\n\\n```\\n***Please, please do upvote if you found it helpful, it keeps me motivated to post more of such solutions :)** and feel free to ask in comments if you have any queries/doubts :)*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Time Complexity : O(n) as only  linear traversal of elemets is performed.\\n//Space Complexity : O(n) for using the hash map.\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<long long,long long>mp;\\n        for(long i=0;i<nums.size();i++)\\n        {\\n            int diff=nums[i]-i;\\n            mp[diff]++;\\n        }\\n        long long n=nums.size();\\n        long long total=(n*(n-1)/2);\\n        long long cnt=0;\\n        for(auto x=mp.begin();x!=mp.end();x++)\\n        {\\n            if(x->second>1)cnt+=((x->second)*(x->second-1))/2;\\n            \\n        }\\n        return (total-cnt);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406928,
                "title": "python-o-n-easy-and-explained",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Expalaination:\\n        \\n        Transform the equation: j - i != nums[j] - nums[i]\\n        \\n        to nums[i] - i == nums[j] - j\\n        \\n        so at each index we are looking for elements after it that give us the same summation of nums[current index] - current index\\n        we can pre calculate those in a separate loop and when we start counting count of pairs\\n        make sure to decrement the count of (nums[current index] - current index) in our hash table because we want to make sure\\n        j > i.\\n        \\n        TC: O(N)\\n        SC: O(N)\\n        \"\"\"\\n        pairs = 0\\n        seen = collections.defaultdict(int)\\n        for idx, num in enumerate(nums):\\n            seen[num - idx] += 1\\n        for idx, num in enumerate(nums):\\n            seen[num - idx] -= 1\\n            target = num - idx\\n            remaining_elements_in_array = len(nums) - (idx + 1)\\n            elements_with_target = seen[target]\\n            pairs += (remaining_elements_in_array - elements_with_target)\\n        return pairs",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Expalaination:\\n        \\n        Transform the equation: j - i != nums[j] - nums[i]\\n        \\n        to nums[i] - i == nums[j] - j\\n        \\n        so at each index we are looking for elements after it that give us the same summation of nums[current index] - current index\\n        we can pre calculate those in a separate loop and when we start counting count of pairs\\n        make sure to decrement the count of (nums[current index] - current index) in our hash table because we want to make sure\\n        j > i.\\n        \\n        TC: O(N)\\n        SC: O(N)\\n        \"\"\"\\n        pairs = 0\\n        seen = collections.defaultdict(int)\\n        for idx, num in enumerate(nums):\\n            seen[num - idx] += 1\\n        for idx, num in enumerate(nums):\\n            seen[num - idx] -= 1\\n            target = num - idx\\n            remaining_elements_in_array = len(nums) - (idx + 1)\\n            elements_with_target = seen[target]\\n            pairs += (remaining_elements_in_array - elements_with_target)\\n        return pairs",
                "codeTag": "Java"
            },
            {
                "id": 2404292,
                "title": "python-solution-100-faster-hashmap",
                "content": "so this problem was very new to me, and during contest i wasn\\'t able to understand and solve it. \\n\\nafter careful analysis on this (watching several videos and going through many detailed explaination) finally i understand how to solve this. \\n\\nSo here\\'s how to learn this. \\n\\ngiven; i < j and i - nums[i] != j - nums[j] \\n\\nafter going through analysis, i have found out that there is no optimized way we can compute the bad pairs, so the question wants us to modify the defination itself and find good pairs and compute the result as => totalPairs - goodPairs = badPairs \\n\\nSo now, how to compute total pairs => (n * (n-1)) / 2 ; where n is the length of the list ;\\nit makes sense right, to compute the total number of such pairs where i < j (i and j are indexes). \\n\\nnow the big question how to find the goodPairs \\nlet\\'s play around with the give equation \\n\\nfrom this \\n\\n i - nums[i] != j - nums[j] \\n\\nwe can write as \\n\\ni - nums[i] != j - nums[j]\\n\\nnow to find the good pairs we need \\ni - nums[i] == j - nums[j]\\n\\nthis equation will somewhat gives us the good pairs, not exactly, this will give how many such good pairs exist for each i, so again use the above formulae (n * (n-1)) / 2\\nto get the number of pairs. \\n\\nJust go through the code and dry run by yourself. \\n\\nCode: \\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        totalPairs, goodPairs = (n*(n-1)) // 2, 0\\n        freq = {}\\n        \\n        for i in range(n):\\n            diff = i - nums[i]\\n            freq[diff] = freq[diff] + 1 if diff in freq else 1\\n        \\n        \\n        for v in freq.values():\\n            goodPairs += (v * (v-1)) // 2\\n        \\n        return totalPairs - goodPairs\\n```\\n\\nTime Complexity: O(n) - Linear Traversal\\nSpace Complexity: O(n) - Hashmap\\nAuxilary Space Complexity: O(1) - Iterative solution no recursive stack or any dynamic memory \\n\\n![image](https://assets.leetcode.com/users/images/5b43ebfe-a190-48a8-b621-e9fdc8b3a549_1660083898.7709603.png)\\n\\n\\nPlease comment if you need to add anything, i understand this article have alot of open questions and missing ends, i want to add as much as possible, so do comment. \\nHit upvote and support. \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        totalPairs, goodPairs = (n*(n-1)) // 2, 0\\n        freq = {}\\n        \\n        for i in range(n):\\n            diff = i - nums[i]\\n            freq[diff] = freq[diff] + 1 if diff in freq else 1\\n        \\n        \\n        for v in freq.values():\\n            goodPairs += (v * (v-1)) // 2\\n        \\n        return totalPairs - goodPairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398256,
                "title": "efficient-c-solution-t-c-o-n-with-explanation",
                "content": "**PLS UPVOTE IF YOU like the SOLUTION:)**\\n**IDEA:-** We observe that if we count bad pairs then we have to do it in O(N^2).\\nTo do efficiently we can change the problem to finding good pairs if we do this then we can get bad pairs by subtracting good pairs from total pairs.\\nSo, for bad pairs condition was:\\n\\n\\t\\t j-i  !=  nums[j]-nums[i]\\n\\nThus, for good pairs it will become:\\n\\n\\t\\tj-i = nums[j] - nums[i]\\n\\t\\t\\nNow lets observe one thing also:\\nLet a b be the two numbers and c and d be their indexes then\\naccording to expression of good pairs:\\n\\n\\td-c=b-a\\n\\twe can rewrite the expression as\\n\\ta-c = b-d\\n\\talso holds good..\\nThus we will use the last expression by taking the difference of elements with their indices and also keeping the count of occurence of that differnce by storing them in an unordered map.\\nThen we traverse through the map and since we got the occurences we will use the pair formula and subtract it from total pairs (ans in the code).\\n\\n**PAIR FORMULA:**\\n\\n\\t\\t\\t(n*(n-1))/2\\n\\n**T.C:-** O(N)   **S.C:-** O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long int,long long int>um;\\n        for(int i{0};i<nums.size();++i){\\n            um[nums.at(i)-i]++;\\n        }\\n        long long len=nums.size();\\n        long long ans=(len*(len-1))/2;\\n        for(auto i:um){\\n            ans-=(i.second*(i.second-1))/2;\\n        }         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long int,long long int>um;\\n        for(int i{0};i<nums.size();++i){\\n            um[nums.at(i)-i]++;\\n        }\\n        long long len=nums.size();\\n        long long ans=(len*(len-1))/2;\\n        for(auto i:um){\\n            ans-=(i.second*(i.second-1))/2;\\n        }         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397364,
                "title": "c-simple-solution",
                "content": "class Solution {\\n# public:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=nums[i]-i;\\n            m[nums[i]]++;\\n        }\\n        long long int ans=0;\\n        for(auto it:m){\\n            long long int x=it.second;\\n            x=x*(x-1)/2;\\n            ans+=x;\\n        }\\n        long long int n=nums.size();\\n        n=n*(n-1)/2;\\n        return n-ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=nums[i]-i;\\n            m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2395715,
                "title": "easy-hashmap-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        \\n        long long int n=nums.size(),pr=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            { \\n                pr+=m[i-nums[i]]++;\\n            }\\n         \\n        long long ans= (n*(n-1))/2;\\n        \\n        return ans-pr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        \\n        long long int n=nums.size(),pr=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            { \\n                pr+=m[i-nums[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2394953,
                "title": "using-simple-maths-c-map",
                "content": "**Intution**\\nonly thing we need in this ques is to know *how we can calculate total pairs for n elements if i<j*\\nthe formula to calculate total no pairs for n elements is\\n\\n\\t(n*(n-1))/2;\\n\\nAlgo\\n -> first condition was j-i = nums[j]-nums[i] for all i<j\\n     this can be written as nums[i]-i = nums[j]-j for all i<j\\n-> to track record of good pairs I used map \\n\\t here we store all count of same values which we get after modifying the array using above formula\\n -> then we check total no of pairs for each key in map considering values as n\\n\\tand have total of all good pairs\\n\\n-> at last we return total pair - good pair\\n\\n\\t#define ll unsigned long long\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long countBadPairs(vector<int>& nums) {\\n\\t\\t\\tll goodPairs=0;\\n\\t\\t\\tll n=nums.size();\\n\\n\\t\\t\\tll totalPairs = n*(n-1);\\n\\t\\t\\ttotalPairs/=2;\\n\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tnums[i]-=i;\\n\\t\\t\\t}\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\n\\t\\t\\tfor(int i : nums)\\n\\t\\t\\t\\tmp[i]++;\\n\\n\\t\\t\\tfor(auto it=mp.begin();it!=mp.end();it++){\\n\\t\\t\\t\\tif(it->second > 1){\\n\\t\\t\\t\\t\\tll r=it->second;\\n\\n\\t\\t\\t\\t\\tll pairs = r*(r-1);\\n\\t\\t\\t\\t\\tpairs/=2;\\n\\n\\t\\t\\t\\t\\tgoodPairs+=pairs;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn totalPairs-goodPairs;\\n\\t\\t}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long countBadPairs(vector<int>& nums) {\\n\\t\\t\\tll goodPairs=0;\\n\\t\\t\\tll n=nums.size();\\n\\n\\t\\t\\tll totalPairs = n*(n-1);\\n\\t\\t\\ttotalPairs/=2;\\n\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tnums[i]-=i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2394790,
                "title": "good-pairs-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums){\\n        \\n        long long n = nums.size();\\n        \\n        long long int tot = (n*(n-1))/2;\\n        \\n        map<int,int> mp;\\n        \\n        \\n        //clearly this can also be thought of finding good pairs -> j-nums[j] == i-nums[i]\\n        \\n        long long ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n           int diff = i-nums[i];\\n            \\n           if(mp.count(diff)){\\n               \\n               ans+=mp[diff];\\n               \\n               mp[diff]++;\\n           }\\n            \\n           else{\\n               mp[diff]++;\\n           }\\n            \\n        }\\n        \\n        return tot-ans;\\n        \\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums){\\n        \\n        long long n = nums.size();\\n        \\n        long long int tot = (n*(n-1))/2;\\n        \\n        map<int,int> mp;\\n        \\n        \\n        //clearly this can also be thought of finding good pairs -> j-nums[j] == i-nums[i]\\n        \\n        long long ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n           int diff = i-nums[i];\\n            \\n           if(mp.count(diff)){\\n               \\n               ans+=mp[diff];\\n               \\n               mp[diff]++;\\n           }\\n            \\n           else{\\n               mp[diff]++;\\n           }\\n            \\n        }\\n        \\n        return tot-ans;\\n        \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2391946,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        c=(len(nums)*(len(nums)-1))//2\\n        d=defaultdict(int)\\n        d[nums[0]]+=1\\n        for i in range(1,len(nums)):\\n                c-=d[nums[i]-i]\\n                d[nums[i]-i]+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        c=(len(nums)*(len(nums)-1))//2\\n        d=defaultdict(int)\\n        d[nums[0]]+=1\\n        for i in range(1,len(nums)):\\n                c-=d[nums[i]-i]\\n                d[nums[i]-i]+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391923,
                "title": "map-o-nlogn",
                "content": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n\\t\\n        for(int i=0;i<nums.size();i++)\\n            nums[i]=nums[i]-i;\\n     \\n       long long ans=0;\\n       long long iter=0;\\n\\t   \\n        unordered_map<long long,long long>m;\\n\\t\\t\\n        for( int i=nums.size()-1;i>=0;i--)\\n\\t\\t\\t{           \\n\\t\\t\\t\\t\\titer++;m[nums[i]]++;\\n                     ans+=iter-m[nums[i]];\\n                 }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n\\t\\n        for(int i=0;i<nums.size();i++)\\n            nums[i]=nums[i]-i;\\n     \\n       long long ans=0;\\n       long long iter=0;\\n\\t   \\n        unordered_map<long long,long long>m;\\n\\t\\t\\n        for( int i=nums.size()-1;i>=0;i--)\\n\\t\\t\\t{           \\n\\t\\t\\t\\t\\titer++;m[nums[i]]++;\\n                     ans+=iter-m[nums[i]];\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2391640,
                "title": "easy-c-solution",
                "content": "Count Good pairs and subtract them from total pairs ---> to get bad pairs \\n````\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        unordered_map<long long,long long>m;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums[i]-i]++;\\n        }\\n        \\n        unsigned long long  total_pairs=(1ll*n*(n-1))/2;\\n        long long good_pairs=0;\\n    \\n        \\n        for(auto x:m)\\n        {\\n            if(x.second>1)\\n            {\\n                int t=x.second;\\n                good_pairs+=(1ll*t*(t-1))/2;\\n            }\\n        }\\n        //cout<<\" \"<<total_pairs<<\" \";\\n        return (total_pairs-good_pairs);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        unordered_map<long long,long long>m;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums[i]-i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2391044,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-counting-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public long CountBadPairs(int[] nums) {\\n        Dictionary<int, int> d = new ();\\n        \\n        long ans = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            int k = nums[i] - i;\\n            if (!d.ContainsKey(k)) d[k] = 0;\\n            \\n            ans += i - d[k];\\n            d[k]++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```C#\\npublic class Solution {\\n    public long CountBadPairs(int[] nums) {\\n        Dictionary<int, int> d = new ();\\n        \\n        long ans = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            int k = nums[i] - i;\\n            if (!d.ContainsKey(k)) d[k] = 0;\\n            \\n            ans += i - d[k];\\n            d[k]++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390264,
                "title": "golang-o-n-solution",
                "content": "Bad pairs: ```j > i && j-i != nums[j]-nums[i]```.\\nLet *T* be the number of total pairs, *T := n * (n-1) / 2*. Let *b* and *g* be the number of bad and good pairs, respectively. *b + g = T*.\\nFor good pairs, ```j > i && j-i == nums[j]-nums[i]```, which equals to ```j > i && nums[j]-j == nums[i]-i```.\\n\\n```\\nfunc countBadPairs(nums []int) int64 {\\n    n := len(nums)\\n\\tm := make(map[int]int)\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tm[nums[i]-i]++\\n\\t}\\n\\tres := int64(n * (n - 1) / 2)\\n\\tfor _, v := range m {\\n\\t\\tif v > 1 {\\n\\t\\t\\tres -= int64(v * (v - 1) / 2)\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```j > i && j-i != nums[j]-nums[i]```\n```j > i && j-i == nums[j]-nums[i]```\n```j > i && nums[j]-j == nums[i]-i```\n```\\nfunc countBadPairs(nums []int) int64 {\\n    n := len(nums)\\n\\tm := make(map[int]int)\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tm[nums[i]-i]++\\n\\t}\\n\\tres := int64(n * (n - 1) / 2)\\n\\tfor _, v := range m {\\n\\t\\tif v > 1 {\\n\\t\\t\\tres -= int64(v * (v - 1) / 2)\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2389411,
                "title": "c-optimal-solution-faster-than-100-00-o-n-time",
                "content": "C++\\n```\\ntypedef long long lli;\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;//element,frequency\\n        int n = nums.size();\\n        lli ans = 0;\\n        vector<int> v(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            v[i] = nums[i] - i;\\n        }\\n        //Now we just have to check those pairs of i < j in vector v, such that v[j] != v[i] , as(v[j] represents nums[j] - j & v[i] represents nums[i] - i)\\n        mp[v[0]]++;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans += (i - mp[v[i]]);//adding only those elements (as pairs with v[i]), such that they are not equal to the current v[i]\\n            mp[v[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long lli;\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;//element,frequency\\n        int n = nums.size();\\n        lli ans = 0;\\n        vector<int> v(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            v[i] = nums[i] - i;\\n        }\\n        //Now we just have to check those pairs of i < j in vector v, such that v[j] != v[i] , as(v[j] represents nums[j] - j & v[i] represents nums[i] - i)\\n        mp[v[0]]++;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans += (i - mp[v[i]]);//adding only those elements (as pairs with v[i]), such that they are not equal to the current v[i]\\n            mp[v[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389187,
                "title": "c-hashmap-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long res=0;\\n        unordered_map<int,vector<int>> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i]-=i;\\n            m[nums[i]].push_back(i);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int p=lower_bound(m[nums[i]].begin(),m[nums[i]].end(),i)-m[nums[i]].begin();\\n            int q=m[nums[i]].size();\\n            q=q-p-1;\\n            long long n=nums.size()-i-1;\\n            n-=q;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long res=0;\\n        unordered_map<int,vector<int>> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i]-=i;\\n            m[nums[i]].push_back(i);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int p=lower_bound(m[nums[i]].begin(),m[nums[i]].end(),i)-m[nums[i]].begin();\\n            int q=m[nums[i]].size();\\n            q=q-p-1;\\n            long long n=nums.size()-i-1;\\n            n-=q;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388820,
                "title": "c-good-pair-map-overflow-solved",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\t// f is to calculate number of good pairs\\n\\t\\t\\tlong long f(vector<int>& A) {\\n\\t\\t\\t\\tlong long res = 0;\\n\\t\\t\\t\\tunordered_map<long long, int> count;\\n\\t\\t\\t\\tfor (int a: A) {\\n\\t\\t\\t\\t\\tres += count[a]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong long countBadPairs(vector<int>& nums) {\\n\\t\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\t\\tnums[i] = nums[i]-i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\t\\t// find good pair \\n\\t\\t\\t\\tlong long cnt = f(nums);\\n\\n\\n\\n\\t\\t\\t\\tlong long k;\\n\\t\\t\\t\\t// to avoid overflow \\n\\n\\t\\t\\t\\tif(n%2==0){\\n\\t\\t\\t\\t\\tk = n/2;\\n\\t\\t\\t\\t\\tk = k*(n-1);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tk = (n-1)/2;\\n\\t\\t\\t\\t\\tk = k*n;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn k-cnt;\\n\\n\\n\\t\\t\\t}\\n\\t\\t};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\t// f is to calculate number of good pairs\\n\\t\\t\\tlong long f(vector<int>& A) {\\n\\t\\t\\t\\tlong long res = 0;\\n\\t\\t\\t\\tunordered_map<long long, int> count;\\n\\t\\t\\t\\tfor (int a: A) {\\n\\t\\t\\t\\t\\tres += count[a]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2388805,
                "title": "c-total-equal",
                "content": "* `j-i != nums[j]-nums[i]` is same as `i - nums[i] != j - nums[j]` .\\n\\n* Find Paris where `i-nums[i] == j - nums[j]`.\\n\\n* Find total Pairs possible in array of size `n` which is `n*(n-1) / 2`.\\n\\n* Therefore , `valid Pairs = total - equal`.\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long countBadPairs(vector<int>& nums) {\\n        ll n = size(nums) ;\\n        \\n        vector<int> diff ;\\n        for(int i = 0 ; i < size(nums) ; ++i ) diff.push_back(i - nums[i]) ;\\n        \\n        ll total = (n * (n - 1)) / 2 ;\\n        \\n        unordered_map<int,int> mpp ;\\n        ll equal = 0 ;\\n        \\n        for(int i = 0 ; i < size(diff) ; ++i ){\\n            equal += mpp[diff[i]] ;\\n            ++mpp[diff[i]] ;\\n        }\\n        \\n        return total - equal ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long countBadPairs(vector<int>& nums) {\\n        ll n = size(nums) ;\\n        \\n        vector<int> diff ;\\n        for(int i = 0 ; i < size(nums) ; ++i ) diff.push_back(i - nums[i]) ;\\n        \\n        ll total = (n * (n - 1)) / 2 ;\\n        \\n        unordered_map<int,int> mpp ;\\n        ll equal = 0 ;\\n        \\n        for(int i = 0 ; i < size(diff) ; ++i ){\\n            equal += mpp[diff[i]] ;\\n            ++mpp[diff[i]] ;\\n        }\\n        \\n        return total - equal ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388766,
                "title": "suffix-sum-map-c",
                "content": "```\\nTime Complexity :- O(N)\\nSpace Complexity :- O(N)\\n\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<int, int> m;\\n        for(int i=0; i<nums.size(); i++)\\n            m[nums[i] - i]++;\\n        \\n        long long sum = 0;\\n        vector<pair<int, int>> p;\\n        for(auto k : m)\\n        {\\n            p.push_back({k.first, k.second});\\n            sum = k.second;\\n        }\\n        \\n        long long ans = 0;\\n        for(int i=p.size()-2; i>=0; i--)\\n        {\\n            ans += sum * p[i].second;\\n            sum += p[i].second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nTime Complexity :- O(N)\\nSpace Complexity :- O(N)\\n\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<int, int> m;\\n        for(int i=0; i<nums.size(); i++)\\n            m[nums[i] - i]++;\\n        \\n        long long sum = 0;\\n        vector<pair<int, int>> p;\\n        for(auto k : m)\\n        {\\n            p.push_back({k.first, k.second});\\n            sum = k.second;\\n        }\\n        \\n        long long ans = 0;\\n        for(int i=p.size()-2; i>=0; i--)\\n        {\\n            ans += sum * p[i].second;\\n            sum += p[i].second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388760,
                "title": "c-easy-o-n-with-comments",
                "content": "//         One Observation that changes the question is that we find the pairs that are not bad pairs, and nums[j]-j = nums[i]-i, so we need to store the frequency of (nums[i]-i) in a map and any two numbers with same diff of nums[i]-i will form a valid pair, so we need to select any two among those frequency count.\\n//         For selecting the numbers of pairs we select any two out of the frequency of that number.\\n//         After obtaining the total pairs which are not bad pairs we can subtract them from total possible pairs.\\n        \\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        map<int,int> st;\\n            long long n=nums.size();\\n            long long cnt=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                   st[nums[i]-i]++;\\n            }\\n            for(auto x:st)\\n            {\\n                    if(x.second==1)\\n                            continue;\\n                    long long t=x.second;\\n                    cnt+=(t*(t-1))/2;\\n            }\\n            \\n            long long tot=(n*(n-1))/2;\\n            return tot-cnt;;\\n            \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "//         One Observation that changes the question is that we find the pairs that are not bad pairs, and nums[j]-j = nums[i]-i, so we need to store the frequency of (nums[i]-i) in a map and any two numbers with same diff of nums[i]-i will form a valid pair, so we need to select any two among those frequency count.\\n//         For selecting the numbers of pairs we select any two out of the frequency of that number.\\n//         After obtaining the total pairs which are not bad pairs we can subtract them from total possible pairs.\\n        \\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        map<int,int> st;\\n            long long n=nums.size();\\n            long long cnt=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                   st[nums[i]-i]++;\\n            }\\n            for(auto x:st)\\n            {\\n                    if(x.second==1)\\n                            continue;\\n                    long long t=x.second;\\n                    cnt+=(t*(t-1))/2;\\n            }\\n            \\n            long long tot=(n*(n-1))/2;\\n            return tot-cnt;;\\n            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2388723,
                "title": "count-number-f-bad-pairs",
                "content": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long ans=0;\\n    \\n        map<int,int> mp;\\n       \\n        for(int i=0 ; i<nums.size(); i++){\\n            if(mp.find(nums[i]-i)!=mp.end()){\\n                ans+= i-(mp.find(nums[i]-i))->second;\\n            }\\n            else{\\n                ans+= i;\\n            }\\n           \\n            mp[nums[i]-i]++;   \\n            \\n        }\\n        \\n        return  ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long ans=0;\\n    \\n        map<int,int> mp;\\n       \\n        for(int i=0 ; i<nums.size(); i++){\\n            if(mp.find(nums[i]-i)!=mp.end()){\\n                ans+= i-(mp.find(nums[i]-i))->second;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388620,
                "title": "easy-solution-faster-than-others-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        //idea is to count no. of good pairs\\n        //j-num[j]==i-nums[i]//good pairs\\n        map<long long,long long>m;\\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            int diff=i-nums[i];\\n            if(m.count(diff)==1){\\n                count+=m[diff];\\n                m[diff]++;\\n            }\\n            else{\\n                m[diff]=1;\\n            }\\n        }\\n        long long total=(nums.size()*(nums.size()-1))/2;\\n        return total-count;\\n        \\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        //idea is to count no. of good pairs\\n        //j-num[j]==i-nums[i]//good pairs\\n        map<long long,long long>m;\\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            int diff=i-nums[i];\\n            if(m.count(diff)==1){\\n                count+=m[diff];\\n                m[diff]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388568,
                "title": "simple-java-o-n-hashmap-one-pass-solution",
                "content": "Flip the question. Count the number of good pairs `(i, j)` such that `j - i == nums[j] - num[i]`.\\n\\nIf we simplify the equation, we get `nums[i] - i == nums[j] - j`. Thus, find the total number of good pairs and subtract from the total number of pairs which is `n * (n - 1) / 2` where n is the number of the elements in the array.\\n\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        \\n        long count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int key = nums[i] - i;\\n            if(map.containsKey(key)) {\\n                count += map.get(key);\\n            }\\n            \\n            map.put(key, map.getOrDefault(key, 0l) + 1);\\n        }\\n        long len = nums.length;\\n        return len * (len - 1) / 2 - count;\\n    }\\n}\\n```\\n\\nTime Complexity :- `O(N)` where `N` is the number of elements in the array.\\nSpace Complexity :- `O(K)` where `K` is the number of unique elements in the array.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        \\n        long count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int key = nums[i] - i;\\n            if(map.containsKey(key)) {\\n                count += map.get(key);\\n            }\\n            \\n            map.put(key, map.getOrDefault(key, 0l) + 1);\\n        }\\n        long len = nums.length;\\n        return len * (len - 1) / 2 - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388528,
                "title": "easy-single-pass-using-map-in-o-n",
                "content": "```\\n**Solution to this problem \\nTotal_valid = Total_pair - Total_Invalid\\n\\n**The Equation is \\n j-i  != nums[j] - nums[i]\\n \\n count total number of pair satisfying equation  =  j- nums[j] =  i - nums[i]  (with i < j < n )\\n \\n**Our required answer  will be total_pair - total number of pair with the above equation\\n\\n \\n long long countBadPairs(vector<int>& nums) {\\n         map< int, int > m;\\n         int n = nums.size();\\n\\t\\t // **total number of pairs **\\n          long long ans = (long long )(n*(long long )(n-1))/2; \\n        \\n\\t\\t// total number of pair satisfying equations as above\\n\\t\\t long long c = 0;\\n         for(int i = 0; i< n; i++){\\n                if(m.find(nums[i] - i) !=  m.end()) c+=m[nums[i] - i];\\n                 m[nums[i] - i]++;\\n         }\\n\\t\\t // required answer will be  ans - c\\n         return ans-c;\\n\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n**Solution to this problem \\nTotal_valid = Total_pair - Total_Invalid\\n\\n**The Equation is \\n j-i  != nums[j] - nums[i]\\n \\n count total number of pair satisfying equation  =  j- nums[j] =  i - nums[i]  (with i < j < n )\\n \\n**Our required answer  will be total_pair - total number of pair with the above equation\\n\\n \\n long long countBadPairs(vector<int>& nums) {\\n         map< int, int > m;\\n         int n = nums.size();\\n\\t\\t // **total number of pairs **\\n          long long ans = (long long )(n*(long long )(n-1))/2; \\n        \\n\\t\\t// total number of pair satisfying equations as above\\n\\t\\t long long c = 0;\\n         for(int i = 0; i< n; i++){\\n                if(m.find(nums[i] - i) !=  m.end()) c+=m[nums[i] - i];\\n                 m[nums[i] - i]++;\\n         }\\n\\t\\t // required answer will be  ans - c\\n         return ans-c;\\n\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2388503,
                "title": "easy-to-understand-hashmap-solution",
                "content": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long int ans=nums.size()-1;\\n \\n       // cout<<ans<<endl;\\n        long long int count=0;\\n       \\n      \\n       // ans-=count;\\n               ans*=(ans+1);\\n        ans=ans/2;\\nunordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]-i]++;\\n        }\\n        for(auto x:m)\\n        {\\n           if(x.second>1)\\n           {\\n               long long int k=x.second;\\n               k=k-1;\\n               k*=(k+1);\\n               k=k/2;\\n               count+=k;\\n           }\\n            \\n        }\\n        return ans-count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long int ans=nums.size()-1;\\n \\n       // cout<<ans<<endl;\\n        long long int count=0;\\n       \\n      \\n       // ans-=count;\\n               ans*=(ans+1);\\n        ans=ans/2;\\nunordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]-i]++;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2388460,
                "title": "python-dictionary-approach",
                "content": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        #j - nums[j] != i - nums[i]\\n        ans = 0\\n\\t\\t#keep track of number of times i-nums[i] has appeared with a dictionary:\\n        counts = {}\\n        for i in range(len(nums)):\\n            if i-nums[i] in counts:\\n                counts[i-nums[i]] += 1\\n            else:\\n                counts[i-nums[i]] = 1\\n                \\n            ans += i-counts[i-nums[i]]+1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        #j - nums[j] != i - nums[i]\\n        ans = 0\\n\\t\\t#keep track of number of times i-nums[i] has appeared with a dictionary:\\n        counts = {}\\n        for i in range(len(nums)):\\n            if i-nums[i] in counts:\\n                counts[i-nums[i]] += 1\\n            else:\\n                counts[i-nums[i]] = 1\\n                \\n            ans += i-counts[i-nums[i]]+1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388412,
                "title": "c-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long, long long> maps;\\n        long long n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            maps[i - nums[i]]++;\\n        }\\n        long long answer = n * (n - 1) / 2;\\n        for (auto [key, value] : maps) {\\n            long long res = value * (value - 1) / 2;\\n            answer -= res;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long, long long> maps;\\n        long long n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            maps[i - nums[i]]++;\\n        }\\n        long long answer = n * (n - 1) / 2;\\n        for (auto [key, value] : maps) {\\n            long long res = value * (value - 1) / 2;\\n            answer -= res;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388366,
                "title": "o-n-solution-using-hashmap",
                "content": "**Upvote If you understood :)**\\nTotal pair for n length arr-> n(n-1)/2\\nSo we will subtract good pair(opposite of bad pair) from it\\nIn first pass we subtract index from num[index] so all good pair could be digtinguished\\nEx:->[4,1,3,3 ]  =) [4,0,1,0]  So there is 1 good pair\\n   ind 0 1 2 3\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        long long ans=(1LL*n*(n-1))>>1;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();++i){\\n            nums[i]-=i;\\n            m[nums[i]]++;\\n        }\\n        for(auto &p: m){\\n            ans-=((1LL*p.second*(p.second-1))>>1);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        long long ans=(1LL*n*(n-1))>>1;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();++i){\\n            nums[i]-=i;\\n            m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2388333,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        \\n        Map<Integer,Integer> mp=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(mp.containsKey(i-nums[i]))\\n            {\\n                mp.put(i-nums[i],mp.get(i-nums[i])+1);\\n            }\\n            else\\n                mp.put(i-nums[i],1);\\n        }\\n        long n=nums.length;\\n        long ans=0;\\n        // System.out.print(mp);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(mp.containsKey(i-nums[i]))\\n            {\\n                ans+=n-i-mp.get(i-nums[i]);\\n            }\\n            else\\n                ans+=i;\\n            if(mp.containsKey(i-nums[i]))\\n            {\\n                int tmp=mp.get(i-nums[i])-1;\\n                if(tmp==0)\\n                    mp.remove(i-nums[i]);\\n                else\\n                    mp.put(i-nums[i],tmp);\\n\\n            }\\n               \\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long countBadPairs(int[] nums) {\\n        \\n        Map<Integer,Integer> mp=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(mp.containsKey(i-nums[i]))\\n            {\\n                mp.put(i-nums[i],mp.get(i-nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388320,
                "title": "java-hashmap-with-explanation",
                "content": "We were given **(j-i) != (nums[j]-nums[i]) and i<j**.\\nAfter doing little bit of reshuffling-->\\n\\t\\n\\t(nums[j]-j) != (nums[i]-i) and i<j\\n\\nThis means that all the elements in the suffix of the array that has same (nums[i]-i) value will not count as the bad pairs.\\nThat is all the remaining pairs will count in the bad pairs.\\n\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long ans = 0;\\n        for(int i = 0;i<nums.length;i++)\\n            nums[i] = nums[i] - i;\\n        \\n        HashMap<Integer,Long> map = new HashMap<>();\\n        for(int i = nums.length-1;i>=0;i--)\\n        {\\n            if(map.containsKey(nums[i]))\\n                ans+=(nums.length-i-1)-map.get(nums[i]);\\n            else\\n                ans+=(nums.length-i-1);\\n            map.put(nums[i],map.getOrDefault(nums[i],(long)(0))+1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nHope this helps :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long ans = 0;\\n        for(int i = 0;i<nums.length;i++)\\n            nums[i] = nums[i] - i;\\n        \\n        HashMap<Integer,Long> map = new HashMap<>();\\n        for(int i = nums.length-1;i>=0;i--)\\n        {\\n            if(map.containsKey(nums[i]))\\n                ans+=(nums.length-i-1)-map.get(nums[i]);\\n            else\\n                ans+=(nums.length-i-1);\\n            map.put(nums[i],map.getOrDefault(nums[i],(long)(0))+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388318,
                "title": "easiest-solution",
                "content": "```\\nj-i != nums[i]-nums[j]\\ncan be written as\\nnums[i] - i != nums[j] - j\\n```\\nJust iterate over array elements, we can pair up all the elements before the element on which we are currently on excluding previous  ``` nums[idx] - idx``` that is same as our current ```nums[i] - i``` \\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<int, int> mp;\\n        int size = nums.size();\\n        long long int ans = 0;\\n        for(int i=0; i< size; i++){\\n            ans += i - mp[nums[i]-i];\\n            mp[nums[i]-i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nj-i != nums[i]-nums[j]\\ncan be written as\\nnums[i] - i != nums[j] - j\\n```\n``` nums[idx] - idx```\n```nums[i] - i```\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<int, int> mp;\\n        int size = nums.size();\\n        long long int ans = 0;\\n        for(int i=0; i< size; i++){\\n            ans += i - mp[nums[i]-i];\\n            mp[nums[i]-i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388293,
                "title": "c-using-i-nums-i-as-key",
                "content": "```\\n        public long CountBadPairs(int[] nums)\\n        {\\n            int n = nums.Length;\\n            long res = (long)n*(n-1)/2;//total count\\n            Dictionary<int,int> dict = new Dictionary<int, int>();\\n            for(int i = 0; i < n; i++)\\n            {\\n                int val = i - nums[i];//using i-nums[i] as key\\n                if (dict.ContainsKey(val)) dict[val]++;\\n                else dict.Add(val, 1);\\n            }\\n            foreach(var k in dict.Keys)\\n                res -= (long)dict[k] * (dict[k] - 1) / 2;//bad pairs must has same key\\n            return res;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public long CountBadPairs(int[] nums)\\n        {\\n            int n = nums.Length;\\n            long res = (long)n*(n-1)/2;//total count\\n            Dictionary<int,int> dict = new Dictionary<int, int>();\\n            for(int i = 0; i < n; i++)\\n            {\\n                int val = i - nums[i];//using i-nums[i] as key\\n                if (dict.ContainsKey(val)) dict[val]++;\\n                else dict.Add(val, 1);\\n            }\\n            foreach(var k in dict.Keys)\\n                res -= (long)dict[k] * (dict[k] - 1) / 2;//bad pairs must has same key\\n            return res;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388262,
                "title": "remove-good-pairs-from-total-no-of-pairs",
                "content": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        res = 0\\n        d = defaultdict(int)\\n        l = len(nums)\\n        total = l*(l-1)//2\\n        for i,n in enumerate(nums):\\n            res += d[n-i]\\n            d[n-i] += 1\\n        return total - res",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        res = 0\\n        d = defaultdict(int)\\n        l = len(nums)\\n        total = l*(l-1)//2\\n        for i,n in enumerate(nums):\\n            res += d[n-i]\\n            d[n-i] += 1\\n        return total - res",
                "codeTag": "Java"
            },
            {
                "id": 2388261,
                "title": "c-map-o-n-time-complexity",
                "content": "In this question we will instead count where j - i == nums[j] - nums[i] is satisfied, and decrease that from total possible pairs.\\n\\n` j - i = nums[j] - nums[i]`\\nor\\n`nums[i]-i = nums[j]-j\\n`\\nfor counting this we maintain a map of all possible values of i + nums[i], then we find number of pairs inside it.\\n\\n```\\nlong long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long> mp;\\n        \\n        long long n = nums.size();\\n        long long cnt = (n*(n-1))/2;//Total possible pairs\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            mp[nums[i]-i]++;//count of elements where nums[i]-i is the same\\n        \\n        for(auto a : mp) cnt -= (a.second*(a.second-1))/2;//decreasing what we don\\'t want\\n        return cnt;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long> mp;\\n        \\n        long long n = nums.size();\\n        long long cnt = (n*(n-1))/2;//Total possible pairs\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            mp[nums[i]-i]++;//count of elements where nums[i]-i is the same\\n        \\n        for(auto a : mp) cnt -= (a.second*(a.second-1))/2;//decreasing what we don\\'t want\\n        return cnt;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388205,
                "title": "java-count-good-pairs",
                "content": "The number of bad pairs equals to the number of total pairs minus the number of good pairs. The good pair is the pairs that meet i < j and j - i == nums[j] - nums[I], in other words, the points in good pairs are in the same lines whose slope is 1. We can split the nums to many lines, and count the number of pairs in those lines, then minus them by the total number of pairs in nums. To calculate the number of pairs, we can use [Combination Equation](https://en.wikipedia.org/wiki/Combination).\\n\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\t\\t// split num into different lines\\n        for (int i = 0; i < n; i++) {\\n            int delta = nums[i] - i;\\n            map.put(delta, 1 + map.getOrDefault(delta, 0));\\n        }\\n        // number of good pairs\\n        long count = 0;\\n        for (int key : map.keySet()) {\\n            count += getPairNum(map.get(key));\\n        }\\n        return getPairNum(n) - count;\\n    }\\n    // combination equation\\n    public long getPairNum(int num) {\\n        return (long)num * (long)(num - 1) / 2;\\n    }\\n}\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\t\\t// split num into different lines\\n        for (int i = 0; i < n; i++) {\\n            int delta = nums[i] - i;\\n            map.put(delta, 1 + map.getOrDefault(delta, 0));\\n        }\\n        // number of good pairs\\n        long count = 0;\\n        for (int key : map.keySet()) {\\n            count += getPairNum(map.get(key));\\n        }\\n        return getPairNum(n) - count;\\n    }\\n    // combination equation\\n    public long getPairNum(int num) {\\n        return (long)num * (long)(num - 1) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388182,
                "title": "solution-in-o-n-code-with-example-python",
                "content": "Consider the example  [4,7,6,7,10]\\nIf we reduce every element by their index value (i) then array becomes [4,6,4,4,6]\\n\\nNow here the element with same values form sequence with non-bad pairs, we can find the no of non-bad pairs using combinations, thus total combination - (non-bad pair) combinations = ans.\\n\\nThus here 4->3 and 6->2, so they form non-bad pairs of 3 and 1, thus ans is (5*4)//2 - 4 = 6;\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        \\n        for i in range(len(nums)):  #decrease array elements by their index value\\n            nums[i] -= i\\n    \\n        c = Counter(nums)     # count occurance which make pair\\n        ans = 0\\n        for k,v in c.items():\\n            if v>1:\\n                ans += (v-1)*(v)//2  # find no of pairs which can be formed\\n        n = len(nums)\\n    \\n        return (n*(n-1)//2) - ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        \\n        for i in range(len(nums)):  #decrease array elements by their index value\\n            nums[i] -= i\\n    \\n        c = Counter(nums)     # count occurance which make pair\\n        ans = 0\\n        for k,v in c.items():\\n            if v>1:\\n                ans += (v-1)*(v)//2  # find no of pairs which can be formed\\n        n = len(nums)\\n    \\n        return (n*(n-1)//2) - ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388152,
                "title": "c-very-easy-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mp[nums[i]-i]++;\\n            ans+=n-i-mp[nums[i]-i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mp[nums[i]-i]++;\\n            ans+=n-i-mp[nums[i]-i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388146,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        if(nums.size() == 1)return 0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] -= i +1;\\n            m[nums[i]]++;\\n        }\\n        if(m.size() == 1)return 0;\\n        long long n = nums.size();\\n        long long ans = 0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            ans += (n-i) - m[nums[i]];\\n            m[nums[i]]--;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        if(nums.size() == 1)return 0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] -= i +1;\\n            m[nums[i]]++;\\n        }\\n        if(m.size() == 1)return 0;\\n        long long n = nums.size();\\n        long long ans = 0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            ans += (n-i) - m[nums[i]];\\n            m[nums[i]]--;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089328,
                "title": "count-number-of-bad-pairs-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the concept of INVALID = TOTAL - VALID\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long int i, ans=0;\\n        unordered_map<int,int> mp;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            // Total good pairs\\n            mp[i-nums[i]];\\n\\n            // total pairs = i;\\n\\n            // Invalid Pairs = total - valid\\n            ans += i - mp[i-nums[i]];\\n            mp[i-nums[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/866dccfd-ee12-41f9-a06c-a1e180be6b02_1695656633.3216321.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long int i, ans=0;\\n        unordered_map<int,int> mp;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            // Total good pairs\\n            mp[i-nums[i]];\\n\\n            // total pairs = i;\\n\\n            // Invalid Pairs = total - valid\\n            ans += i - mp[i-nums[i]];\\n            mp[i-nums[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080128,
                "title": "undordered-map-using-a-bit-of-combinatorics",
                "content": "# Intuition\\nNumber of bad pairs = Total number of pairs - Number of good pairs. \\n\\n# Approach\\n For a pair to be a bad pair, i - j != nums[i] - nums[j]\\nSo, ``i-nums[i] != j -  nums[j]``\\nI define good pair to be ``i - nums[i] == j - nums[j]``\\n\\nSo, I create an unordered map of type ``<long long, long long>``. the key will be the difference`` (i - nums[i])`` and the value would be the frequency.\\n\\nThe for loopcounts the frequency of such good pairs, and later on, we subtract this from the total number of pairs possible which is ``nC2``\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\nlong long countBadPairs(vector<int>& nums) {\\n    ll good=0, bad=0, n = nums.size();\\n    unordered_map<ll, ll> umap;\\n    for(ll i = 0;i<nums.size();i++)\\n    {\\n        good+=(umap[i-nums[i]])++;\\n    }\\n    bad=n*(n-1)/2 - good;\\n    return bad;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\nlong long countBadPairs(vector<int>& nums) {\\n    ll good=0, bad=0, n = nums.size();\\n    unordered_map<ll, ll> umap;\\n    for(ll i = 0;i<nums.size();i++)\\n    {\\n        good+=(umap[i-nums[i]])++;\\n    }\\n    bad=n*(n-1)/2 - good;\\n    return bad;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071393,
                "title": "sol-wih-hm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < nums.length; i++) {\\n            int diff = i - nums[i];\\n            map.put(diff, map.getOrDefault(diff, 0) + 1);\\n        }\\n        long totalPair = (long) nums.length * (nums.length - 1) / 2;\\n        long goodPair = 0L;\\n        for (int key : map.keySet()) {\\n            if (map.get(key) > 1) {\\n                long value = map.get(key);\\n                goodPair += value * (value - 1) / 2;\\n            }\\n        }\\n        return totalPair - goodPair;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < nums.length; i++) {\\n            int diff = i - nums[i];\\n            map.put(diff, map.getOrDefault(diff, 0) + 1);\\n        }\\n        long totalPair = (long) nums.length * (nums.length - 1) / 2;\\n        long goodPair = 0L;\\n        for (int key : map.keySet()) {\\n            if (map.get(key) > 1) {\\n                long value = map.get(key);\\n                goodPair += value * (value - 1) / 2;\\n            }\\n        }\\n        return totalPair - goodPair;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071220,
                "title": "count-number-of-bad-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long sum = 0;\\n        int size = nums.length-1;\\n        long ans = 0;\\n        while(size>=0)\\n        {\\n            sum = sum+size;\\n            size--;\\n        }\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]-i))\\n            {\\n                ans = ans+hm.get(nums[i]-i);\\n            }\\n            hm.put((nums[i]-i),hm.getOrDefault((nums[i]-i),0)+1);\\n        }\\n        return sum-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        long sum = 0;\\n        int size = nums.length-1;\\n        long ans = 0;\\n        while(size>=0)\\n        {\\n            sum = sum+size;\\n            size--;\\n        }\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]-i))\\n            {\\n                ans = ans+hm.get(nums[i]-i);\\n            }\\n            hm.put((nums[i]-i),hm.getOrDefault((nums[i]-i),0)+1);\\n        }\\n        return sum-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036960,
                "title": "c-solution-count-the-good-pairs",
                "content": "# Intuition\\nThe key insight here was that all array entries that form good pairs with each other (a good group if you will) are related by a key math property: they will all have the same difference relative to their index.\\n\\nWe can see that this is true because by the definition of a good pair we can see that it must satisfy the equation `j - i == nums[j] - nums[i]`. Visualizing each entry in the array as a point where its x-coordinate is its index and its y-coordinate is its value, we can see that good pairs must lie on the same line! (Specifically all lines are slope 1, and the only thing that changes is their y-intercept!)\\n\\nWith this we can see that we can bucket points by what line they fall on! And regardless of where they lie on the line, by simply counting the number of points in that bucket we can know the number of good pairs (since it\\'ll just be (n choose 2))!\\n\\n# Approach\\nCount the number of points in each bucket (each bucket corresponds to a line with a given y-intercept). For each bucket count the number of good pairs that bucket would contribute.\\n\\nSubtract the total number of good pairs from the total number of possible pairs, and you\\'re left with the total number of bad pairs.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n). We iterate over each array entry once and do O(1) work per iteration to count it in the appropriate bucket, for an O(n) overall loop.\\n\\nThen in a separate loop over each bucket (where there are O(n) buckets (since the number of buckets is bounded by the number of index offsets, where there are at most as many index offsets as there are array entries)), we do O(1) work per iteration to count the number of good pairs that bucket contributes.\\n\\nSo O(n) overall (neither loop dominates).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n). (At most O(n) buckets, each bucket uses a constant amount of space to count the number of points in that bucket).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        // The key insight here was that all points that form good pairs with each other (a good group if you will) are related by a key math property: they will all have the same difference relative to their index.\\n        // We can see that this is true because by the definition of a good pair we can see that it must satisfy the equation `j - i == nums[j] - nums[i]`. Visualizing each entry in the array as a point where it\\'s x-coordinate is its index and its y-coordinate is its value, we can see that good pairs must lie on the same line! (Specifically all lines are slope 1, and the only thing that changes is their y-offset!)\\n\\n        // With this we can see that we can bucket points by what line they fall on! And regardless of where they lie on the line, by simply counting the number of points in that bucket we can know the number of good pairs!\\n\\n        // First we count the number of numbers that fall into each bucket.\\n        // Maps (value - index) -> count\\n        unordered_map<int, int> offset_counts;\\n        const long long n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            offset_counts[nums[i] - i] += 1;\\n        }\\n\\n        // We start off with the total number of possible pairs, then gradually subtract\\n        // all good pairs, till we\\'re left with only bad pairs.\\n        // (The total number of possible pairs is n choose 2).\\n        long long bad_pairs = (n * (n - 1)) / 2;\\n\\n        // Now we iterate over the offset buckets, subtracting the number of good pairs\\n        // they\\'d contribute.\\n        for (const auto& bucket : offset_counts)\\n        {\\n            long long cnt = bucket.second;\\n            long long good_pairs = (cnt * (cnt - 1)) / 2;\\n            bad_pairs -= good_pairs;\\n        }\\n\\n        return bad_pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        // The key insight here was that all points that form good pairs with each other (a good group if you will) are related by a key math property: they will all have the same difference relative to their index.\\n        // We can see that this is true because by the definition of a good pair we can see that it must satisfy the equation `j - i == nums[j] - nums[i]`. Visualizing each entry in the array as a point where it\\'s x-coordinate is its index and its y-coordinate is its value, we can see that good pairs must lie on the same line! (Specifically all lines are slope 1, and the only thing that changes is their y-offset!)\\n\\n        // With this we can see that we can bucket points by what line they fall on! And regardless of where they lie on the line, by simply counting the number of points in that bucket we can know the number of good pairs!\\n\\n        // First we count the number of numbers that fall into each bucket.\\n        // Maps (value - index) -> count\\n        unordered_map<int, int> offset_counts;\\n        const long long n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            offset_counts[nums[i] - i] += 1;\\n        }\\n\\n        // We start off with the total number of possible pairs, then gradually subtract\\n        // all good pairs, till we\\'re left with only bad pairs.\\n        // (The total number of possible pairs is n choose 2).\\n        long long bad_pairs = (n * (n - 1)) / 2;\\n\\n        // Now we iterate over the offset buckets, subtracting the number of good pairs\\n        // they\\'d contribute.\\n        for (const auto& bucket : offset_counts)\\n        {\\n            long long cnt = bucket.second;\\n            long long good_pairs = (cnt * (cnt - 1)) / 2;\\n            bad_pairs -= good_pairs;\\n        }\\n\\n        return bad_pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979921,
                "title": "python-easy-solution-beats-93-42",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        c=Counter(i-n for i,n in enumerate(nums))\\n        res=len(nums)*(len(nums)-1)\\n        for v in c.values():\\n            if v>1:\\n                res-=v*(v-1)\\n        return res//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        c=Counter(i-n for i,n in enumerate(nums))\\n        res=len(nums)*(len(nums)-1)\\n        for v in c.values():\\n            if v>1:\\n                res-=v*(v-1)\\n        return res//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972828,
                "title": "easy-approach",
                "content": "\\n# Approach\\nrearrange teh equation and it will become nums[i]-i!=nums[j]-j.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n         unordered_map<int,int>mp;\\n          long long  ans=0;\\n          int total=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           int x=nums[i]-i;\\n           total++;\\n            mp[x]++;\\n\\n            int y=total-mp[x];\\n\\n            ans+=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n         unordered_map<int,int>mp;\\n          long long  ans=0;\\n          int total=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           int x=nums[i]-i;\\n           total++;\\n            mp[x]++;\\n\\n            int y=total-mp[x];\\n\\n            ans+=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903697,
                "title": "c-easy-solution-hash-map-jinda-baad",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n       long long ans=0;\\n       long long n=nums.size() , m=n-1;   \\n       // total number of possible pairs\\n       long long  pos = (m*(m+1)/2) , cor=0;\\n\\n       unordered_map<long long ,long long > mp;\\n       for(int i=0; i<n; i++){\\n           if(mp.find(nums[i]-i)!=mp.end()){\\n               cor+=(long long)mp[nums[i]-i];\\n           }\\n           mp[nums[i]-i]++;\\n       }\\n       return pos-cor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n       long long ans=0;\\n       long long n=nums.size() , m=n-1;   \\n       // total number of possible pairs\\n       long long  pos = (m*(m+1)/2) , cor=0;\\n\\n       unordered_map<long long ,long long > mp;\\n       for(int i=0; i<n; i++){\\n           if(mp.find(nums[i]-i)!=mp.end()){\\n               cor+=(long long)mp[nums[i]-i];\\n           }\\n           mp[nums[i]-i]++;\\n       }\\n       return pos-cor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868699,
                "title": "unordered-map-solution-explained-easy-c",
                "content": "**Intuition:**\\n\\nThe given code is for a function `countBadPairs` that takes a vector of integers `nums` as input and returns the count of \"bad pairs.\" A bad pair is defined as a pair of indices (i, j) where i < j, but the difference between `j` and `i` is not equal to the difference between `nums[j]` and `nums[i]`.\\n\\n**Approach:**\\n\\nThe code utilizes a hash table (`unordered_map<int, int> mp`) to store the occurrences of the differences `nums[i] - i` as it iterates over the array `nums` in reverse order. It then updates the count of bad pairs (`ans`) by calculating the difference between the total possible pairs at index `i` and the occurrences of the current difference `nums[i] - i`.\\n\\n**Explanation:**\\n\\n1. The for loop starts from the last index of the array (`i = n - 1`) and iterates backwards.\\n2. For each index `i`, it calculates the difference `nums[i] - i`. This difference represents the constant offset required to match the index with the corresponding value such that j - i == nums[j] - nums[i]. \\n3. It then calculates the number of possible pairs (n - i - 1) that can be formed with elements to the right of index `i`.\\n4. It checks the occurrences of the current difference `nums[i] - i` in the `mp` unordered map and subtracts this count from the total possible pairs.\\n5. The difference is added to the `ans` count, representing the number of bad pairs that can be formed using the current element at index `i`.\\n6. The code updates the `mp` unordered map by incrementing the count for the current difference (`mp[nums[i] - i]++`).\\n7. The final count of bad pairs (`ans`) is returned as the result.\\n\\n**Time Complexity:**\\n\\nLet n be the number of elements in the input vector `nums`.\\n\\n1. The for loop iterates through the entire array, which takes O(n) time.\\n2. For each element, it performs constant-time operations to update the `mp` unordered map and update the `ans` count.\\n3. Therefore, the overall time complexity is O(n).\\n\\n**Space Complexity:**\\n\\nThe space complexity is determined by the space used to store the `mp` unordered map.\\n\\n1. In the worst case, all elements in the array have different differences, leading to a unique key-value pair in the `mp` map for each element. In this case, the size of the `mp` map would be equal to the number of elements in the array, i.e., O(n).\\n2. The `ans` variable and other constant-space variables do not contribute significantly to the space complexity.\\n3. Therefore, the overall space complexity is O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int n = nums.size();\\n        long long ans = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans += (n - i - 1 - mp[nums[i] - i]);\\n            mp[nums[i] - i]++; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int n = nums.size();\\n        long long ans = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans += (n - i - 1 - mp[nums[i] - i]);\\n            mp[nums[i] - i]++; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867090,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long countBadPairs(int[] nums) {\\n        long n=nums.length;\\n        long totalCount = n*(n-1)/2;\\n        long pans=0;\\n        long count=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n\\n        for(int i=0;i<n;i++){\\n            hm.put(i-nums[i],hm.getOrDefault(i-nums[i],0)+1);\\n        }\\n\\n        for(int key:hm.keySet()){\\n            count = hm.get(key);\\n            pans+=(count*(count-1))/2;\\n        }\\n\\n        return (long)(totalCount-pans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long countBadPairs(int[] nums) {\\n        long n=nums.length;\\n        long totalCount = n*(n-1)/2;\\n        long pans=0;\\n        long count=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n\\n        for(int i=0;i<n;i++){\\n            hm.put(i-nums[i],hm.getOrDefault(i-nums[i],0)+1);\\n        }\\n\\n        for(int key:hm.keySet()){\\n            count = hm.get(key);\\n            pans+=(count*(count-1))/2;\\n        }\\n\\n        return (long)(totalCount-pans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861791,
                "title": "a-more-mathematical-approach-beats-100-in-time-o-n-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/01b1fd62-589e-4654-93f2-b0c362587655_1691134807.4885557.png)\\n\\n# Intuition\\nThe first observation to make is that there are no bad pairs in any subsequence of an array in the form `[i+k for i in range(n)]` for some integer $k$. This is an arithmetic progression with common difference of $1$.\\n\\nThis in essence froms our equivalence class where no bad pairs can be formed from elements within the same class. To better understand what I am talking about, let us look at a more concrete example.\\n\\nConsider the following example,\\n$[3, 4, 5, 6, 7, 8, 9]$\\nThis array does not have any bad pairs.\\n\\nThis can be represented by the graph below\\n![image.png](https://assets.leetcode.com/users/images/34fbd2dc-76ba-402b-a933-db9c3e643f4a_1691135258.0573916.png)\\n\\nWhat happens when we bump one of the numbers out of place to the following?\\n$[3, 4, 5, 8, 7, 8, 9]$\\n![image.png](https://assets.leetcode.com/users/images/5d5b9fbd-a179-4e5d-b4be-64e4a5adcdd3_1691135870.861347.png)\\nWe now see that the number of bad pairs is the number of edges that can be formed between the equivalence classes which is `6`.\\n\\nLet us generalise this concept, suppose we are able to partition the numbers of the array of size $n$ into $m$ classes with $s_i$ is the size of the $i$th class. The number of bad pairs is $\\\\sum_{i=1}^{m} s_i * (n-s_i) / 2$. We divide by $2$ as we will be double counting every edge. \\n\\nFor people into graph theory, the problem can be thought as the number of edges of a complete `m`-partite graph.\\n\\n# Approach\\n1. Define the equivalence classes\\n    * For each $a_i$ of the list, find $k$ such that $a_i$ = $i + k$.\\n    * $k$ defines the equivalence class\\n2. Count number of edges as described above.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        apclass = dict()\\n        for i, x in enumerate(nums):\\n            d = x - i\\n            apclass[d] = apclass.get(d, 0) + 1\\n         \\n        total = 0\\n        for v in apclass.values():\\n            total += v * (n-v)\\n        return total // 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        apclass = dict()\\n        for i, x in enumerate(nums):\\n            d = x - i\\n            apclass[d] = apclass.get(d, 0) + 1\\n         \\n        total = 0\\n        for v in apclass.values():\\n            total += v * (n-v)\\n        return total // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859601,
                "title": "easy-to-solve-c-hashing",
                "content": "# Intuition\\ngiven condition is i < j and j-i != nums[j]-nums[i]. it means-->j-nums[j]!= i-nums[i].\\n\\n# Approach\\nwe solve can solve in O(n^2) also but it is TLE.\\nto solve in lower complexity. we use the hashing.we store value i-nums[i] at every index i. and check whether that values is present are not.\\nafter that we will get how many are values are we the same .we wil subtruct from the total no of subsets.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        // long long ans=0;\\n        // for(int i=0;i<nums.size();i++){\\n        //     for(int j=i+1;j<nums.size();j++){\\n        //         if((j-i)!=(nums[j]-nums[i])) ans++;\\n        //     }\\n        // }\\n        // return ans;\\n        long long n=nums.size();\\n        long long ans=((n*(n-1))/2);\\n        unordered_map<long long,long long>m;\\n        long long good=0;\\n        for(int i=0;i<n;i++){\\n            long long badpair=i-nums[i];\\n            if(m.count(badpair)) good+=m[badpair];\\n            m[badpair]++;\\n        }\\n        return ans-good;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        // long long ans=0;\\n        // for(int i=0;i<nums.size();i++){\\n        //     for(int j=i+1;j<nums.size();j++){\\n        //         if((j-i)!=(nums[j]-nums[i])) ans++;\\n        //     }\\n        // }\\n        // return ans;\\n        long long n=nums.size();\\n        long long ans=((n*(n-1))/2);\\n        unordered_map<long long,long long>m;\\n        long long good=0;\\n        for(int i=0;i<n;i++){\\n            long long badpair=i-nums[i];\\n            if(m.count(badpair)) good+=m[badpair];\\n            m[badpair]++;\\n        }\\n        return ans-good;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825008,
                "title": "easy-hash-map-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = nums.size()-1;\\n        long long pair = (n*(n+1))/2;\\n        long long ans=0;\\n        unordered_map<int , int> m;\\n        for(int i=0;i<=n;i++){\\n            if(m.find(nums[i]-i) != m.end()){\\n                ans+= m[nums[i]-i];\\n            }\\n            m[nums[i]-i]++;\\n        }\\n        return pair - ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long n = nums.size()-1;\\n        long long pair = (n*(n+1))/2;\\n        long long ans=0;\\n        unordered_map<int , int> m;\\n        for(int i=0;i<=n;i++){\\n            if(m.find(nums[i]-i) != m.end()){\\n                ans+= m[nums[i]-i];\\n            }\\n            m[nums[i]-i]++;\\n        }\\n        return pair - ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803330,
                "title": "ok",
                "content": "```\\nlong long countBadPairs(vector<int>& n) \\n{\\n\\tlong long out(size(n)*(size(n)-1)/2ll);\\n\\tunordered_map<int, int> m;\\n\\tfor(int i{}; i<size(n); ++i)\\n\\t\\tout -= m[i-n[i]]++;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long countBadPairs(vector<int>& n) \\n{\\n\\tlong long out(size(n)*(size(n)-1)/2ll);\\n\\tunordered_map<int, int> m;\\n\\tfor(int i{}; i<size(n); ++i)\\n\\t\\tout -= m[i-n[i]]++;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782796,
                "title": "c-with-good-pair-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long getSum(long long input) {\\n        return (input  - 1) * input / 2;\\n    }\\n\\n    long long countBadPairs(vector<int>& nums) {\\n        \\n        std::map<int, int> data;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            ++data[nums[i] - i];\\n        }\\n\\n        long long count = 0;\\n\\n        for (auto & record : data) {\\n            if (record.second > 1) {\\n                count += getSum(record.second);\\n            }\\n        }\\n\\n        return getSum(nums.size()) - count;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long getSum(long long input) {\\n        return (input  - 1) * input / 2;\\n    }\\n\\n    long long countBadPairs(vector<int>& nums) {\\n        \\n        std::map<int, int> data;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            ++data[nums[i] - i];\\n        }\\n\\n        long long count = 0;\\n\\n        for (auto & record : data) {\\n            if (record.second > 1) {\\n                count += getSum(record.second);\\n            }\\n        }\\n\\n        return getSum(nums.size()) - count;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781564,
                "title": "two-sum-variant-c",
                "content": "# Intuition\\nVariant of Two Sum\\n\\n# Approach\\nTwo Sum | C++\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> map;\\n        long long count = 0;\\n        for (int j = 0; j < n; j++) {\\n            count += (j - map[nums[j] - j]);\\n            map[nums[j] - j]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> map;\\n        long long count = 0;\\n        for (int j = 0; j < n; j++) {\\n            count += (j - map[nums[j] - j]);\\n            map[nums[j] - j]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779666,
                "title": "masum-easy-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<long long,long long>mp;\\n        long long n=nums.size();\\n        long long total_count=n*(n-1)/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-i]++;\\n        }\\n         long long count=0;\\n\\n        for(auto i:mp)\\n        {\\n            if(i.second>1)\\n            {\\n                count+=((i.second*(i.second-1))/2);\\n            }\\n        }\\n        return total_count-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<long long,long long>mp;\\n        long long n=nums.size();\\n        long long total_count=n*(n-1)/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-i]++;\\n        }\\n         long long count=0;\\n\\n        for(auto i:mp)\\n        {\\n            if(i.second>1)\\n            {\\n                count+=((i.second*(i.second-1))/2);\\n            }\\n        }\\n        return total_count-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734360,
                "title": "python3-following-hints",
                "content": "# Code\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        totalPair = N*(N-1)//2\\n\\n        hm = defaultdict(int)\\n        goodPair = 0\\n        for i in range(N):\\n            goodPair += hm[nums[i]-i]\\n            hm[nums[i]-i]+=1\\n\\n        return totalPair - goodPair\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        totalPair = N*(N-1)//2\\n\\n        hm = defaultdict(int)\\n        goodPair = 0\\n        for i in range(N):\\n            goodPair += hm[nums[i]-i]\\n            hm[nums[i]-i]+=1\\n\\n        return totalPair - goodPair\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722716,
                "title": "bad-pairs-total-good-pairs-c-map-hindi-explanation",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //We have to find pair which are not equal but i find equal pair then substract from all pair \\n    //count pair map pattern\\n    long long countBadPairs(vector<int>& nums) {\\n        long long c=0;\\n        int n=nums.size();\\n        unordered_map<int,long long> mp;\\n        for(int i=0;i<n;i++){\\n            long long same=mp[(i-nums[i])];\\n            c=(c+(i-same));\\n            mp[i-nums[i]]++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //We have to find pair which are not equal but i find equal pair then substract from all pair \\n    //count pair map pattern\\n    long long countBadPairs(vector<int>& nums) {\\n        long long c=0;\\n        int n=nums.size();\\n        unordered_map<int,long long> mp;\\n        for(int i=0;i<n;i++){\\n            long long same=mp[(i-nums[i])];\\n            c=(c+(i-same));\\n            mp[i-nums[i]]++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712107,
                "title": "using-map-cpp-easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        long long n =nums.size();\\n        long long count =0;\\n        map<int,int> mp;\\n        vector<int>ans;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]-i);\\n        }\\n        for(auto it:ans)\\n        {\\n            mp[it]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            long long x=it.second;\\n            if(it.second>1)\\n            {\\n                count+=x*(x-1)/2;\\n            }\\n        }\\n        return (n*(n-1))/2-count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        long long n =nums.size();\\n        long long count =0;\\n        map<int,int> mp;\\n        vector<int>ans;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]-i);\\n        }\\n        for(auto it:ans)\\n        {\\n            mp[it]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            long long x=it.second;\\n            if(it.second>1)\\n            {\\n                count+=x*(x-1)/2;\\n            }\\n        }\\n        return (n*(n-1))/2-count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694344,
                "title": "java-hashmap-and-frequency-counter",
                "content": "```\\npublic long countBadPairs(int[] nums) {\\n        long ans = 0, allFre = 0;\\n        HashMap<Integer, Long> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i] - i)) {\\n                ans += (allFre - map.get(nums[i] - i));\\n            } else ans += allFre;\\n            map.put((nums[i] - i), map.getOrDefault(nums[i] - i, 0L) + 1);\\n            allFre++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long countBadPairs(int[] nums) {\\n        long ans = 0, allFre = 0;\\n        HashMap<Integer, Long> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i] - i)) {\\n                ans += (allFre - map.get(nums[i] - i));\\n            } else ans += allFre;\\n            map.put((nums[i] - i), map.getOrDefault(nums[i] - i, 0L) + 1);\\n            allFre++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691672,
                "title": "c-map-first-find-all-possible-good-pair-subtract-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long>m;\\n        long long n=nums.size();\\n        long long total=n*(n-1)/2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]-i]++;\\n        }\\n        unsigned long long count=0;\\n        for(auto it:m)\\n        {\\n            if(it.second>1)\\n            {\\n                count+=((it.second * (it.second-1)) / 2);\\n            }\\n        }\\n        return total-count;// total -good pair(equal number pair)\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long>m;\\n        long long n=nums.size();\\n        long long total=n*(n-1)/2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]-i]++;\\n        }\\n        unsigned long long count=0;\\n        for(auto it:m)\\n        {\\n            if(it.second>1)\\n            {\\n                count+=((it.second * (it.second-1)) / 2);\\n            }\\n        }\\n        return total-count;// total -good pair(equal number pair)\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690271,
                "title": "java-implementation-o-n-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        for (int i = 0 ; i < nums.length ; i++) {\\n            // nums[i] - i != nums[j] - j\\n            // Transform every num into nums[i] - i\\n            nums[i] -= i;\\n        }\\n\\n        long count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0 ; i < nums.length ; i++) {\\n            // Counting good pairs\\n            count += map.getOrDefault(nums[i], 0);\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        return (1L * nums.length * (nums.length - 1)) / 2 - count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        for (int i = 0 ; i < nums.length ; i++) {\\n            // nums[i] - i != nums[j] - j\\n            // Transform every num into nums[i] - i\\n            nums[i] -= i;\\n        }\\n\\n        long count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0 ; i < nums.length ; i++) {\\n            // Counting good pairs\\n            count += map.getOrDefault(nums[i], 0);\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        return (1L * nums.length * (nums.length - 1)) / 2 - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688764,
                "title": "java-easy-understanind-explained-in-code",
                "content": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        \\n        //idea is to find good pairs\\n        //if bad pair condition is j - i != nums[j] - nums[i] \\n                            //=> nums[i] - i != nums[j] - j\\n        //then good condition is ==> nums[i] - i == nums[j] - j\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            //count all the numbers which are hiving same nums[i] - i\\n            map.put(nums[i] - i , map.getOrDefault(nums[i] - i,0) + 1);\\n        }\\n        \\n        long totPairs = nums.length*1L * (nums.length - 1)*1L/2L;\\n        \\n        long goodPair = 0L;\\n        \\n        for(Integer key : map.keySet()){\\n            \\n            int count = map.get(key);\\n            \\n            goodPair += (count*1L * (count - 1)*1L/2L);\\n            \\n        }\\n        \\n        return totPairs - goodPair;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        \\n        //idea is to find good pairs\\n        //if bad pair condition is j - i != nums[j] - nums[i] \\n                            //=> nums[i] - i != nums[j] - j\\n        //then good condition is ==> nums[i] - i == nums[j] - j\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            //count all the numbers which are hiving same nums[i] - i\\n            map.put(nums[i] - i , map.getOrDefault(nums[i] - i,0) + 1);\\n        }\\n        \\n        long totPairs = nums.length*1L * (nums.length - 1)*1L/2L;\\n        \\n        long goodPair = 0L;\\n        \\n        for(Integer key : map.keySet()){\\n            \\n            int count = map.get(key);\\n            \\n            goodPair += (count*1L * (count - 1)*1L/2L);\\n            \\n        }\\n        \\n        return totPairs - goodPair;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671990,
                "title": "easy-hash-map-solution-beats-95",
                "content": "# Intuition\\n* Convert j-i!=nums[j]-nums[i] to j-nums[j]!=i-nums[i]. \\n* Calculate no of pairs with j-nums[j]==i-nums[i] and substract it from total number of pairs.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* count number of pairs with value (i-nums[i]) and store it in hash table. Let x no of values equal to (i-nums[i]), we will now calculate number of pairs with value x ,which is $x\\\\choose2$=$(x*(x-1))/2$ . substract that from total number of possible pairs i.e $n\\\\choose2$.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int> hash;\\n        //count number of pairs with value i-nums[i];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            hash[nums[i]-i]++;\\n        }\\n        unsigned long long result=0;\\n        //sum up all the pairs with sum i-nums[i].\\n        for(auto it:hash)\\n        {\\n            long long n=it.second;\\n            result+=((n)*(n-1))/2;\\n        }\\n        long long n=nums.size();\\n        n=n*(n-1)/2;\\n        //substract it from total no of pairs and return.\\n        return n-result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int> hash;\\n        //count number of pairs with value i-nums[i];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            hash[nums[i]-i]++;\\n        }\\n        unsigned long long result=0;\\n        //sum up all the pairs with sum i-nums[i].\\n        for(auto it:hash)\\n        {\\n            long long n=it.second;\\n            result+=((n)*(n-1))/2;\\n        }\\n        long long n=nums.size();\\n        n=n*(n-1)/2;\\n        //substract it from total no of pairs and return.\\n        return n-result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648253,
                "title": "easy-by-using-map-optimise-approach-please-upvote-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    \\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n      map<long long ,long long>mp;\\n      long long ans=0;\\n      long long n=nums.size();\\n      //total no . of pairs;\\n      long long total=n*(n-1)/2;\\n      for(int i=0;i<n;i++){\\n       //count frequency of good pairs\\n       mp[nums[i]-i]++;\\n\\n      }\\n\\n      for(auto x:mp){\\n\\n          ans+=(x.second)*(x.second-1)/2;\\n\\n      }\\n      return total-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    \\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n      map<long long ,long long>mp;\\n      long long ans=0;\\n      long long n=nums.size();\\n      //total no . of pairs;\\n      long long total=n*(n-1)/2;\\n      for(int i=0;i<n;i++){\\n       //count frequency of good pairs\\n       mp[nums[i]-i]++;\\n\\n      }\\n\\n      for(auto x:mp){\\n\\n          ans+=(x.second)*(x.second-1)/2;\\n\\n      }\\n      return total-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646701,
                "title": "elixir-enum-reduce-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 531ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 91.1MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec count_bad_pairs(nums :: [integer]) :: integer\\n  def count_bad_pairs(nums) do\\n    Enum.reduce(nums, {0, 0, %{}}, fn num, {i, ans, cnt_dict} ->\\n      prev = Map.get(cnt_dict, i - num, 0)\\n      {i + 1, ans + (i - prev), Map.put(cnt_dict, i - num, prev + 1)}\\n    end) |> elem(1)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec count_bad_pairs(nums :: [integer]) :: integer\\n  def count_bad_pairs(nums) do\\n    Enum.reduce(nums, {0, 0, %{}}, fn num, {i, ans, cnt_dict} ->\\n      prev = Map.get(cnt_dict, i - num, 0)\\n      {i + 1, ans + (i - prev), Map.put(cnt_dict, i - num, prev + 1)}\\n    end) |> elem(1)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3639991,
                "title": "c-map-first-find-all-possible-good-pair-subtract-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long>m;\\n        long long n=nums.size();\\n        long long total=n*(n-1)/2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]-i]++;\\n        }\\n        unsigned long long count=0;\\n        for(auto it:m)\\n        {\\n            if(it.second>1)\\n            {\\n                count+=((it.second * (it.second-1)) / 2);\\n            }\\n        }\\n        return total-count;// total -good pair(equal number pair)\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<long long,long long>m;\\n        long long n=nums.size();\\n        long long total=n*(n-1)/2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]-i]++;\\n        }\\n        unsigned long long count=0;\\n        for(auto it:m)\\n        {\\n            if(it.second>1)\\n            {\\n                count+=((it.second * (it.second-1)) / 2);\\n            }\\n        }\\n        return total-count;// total -good pair(equal number pair)\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637118,
                "title": "easy-to-understand-solution-using-hashmap-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried to think this problem in a reverse manner, that is, getting the count of good pairs (basically not bad pairs). We can subtract this count from number of pairs to get our answer.\\n\\nSecondly, we can refram the condition as nums[i]-i != nums[j]-j. For getting count of good pairs we need to get the number of pairs of (i,j) with i<j such that nums[i]-i == nums[j]-j.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the hashmap for storing the values of nums[i]-i while traversing through the whole array (0 <= i < nums.size()). Update the answer at each iteration with value of : \\n\\n(nums[i]-i in the hashmap) - 1\\n\\nto get the value of total number of good pairs of indices.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        \\n        long long n=nums.size();\\n        long long total=n*(n-1)/2;\\n        long long good=0;\\n\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]-i]++;\\n            good+=mp[nums[i]-i]-1;\\n        }\\n\\n        return total-good;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        \\n        long long n=nums.size();\\n        long long total=n*(n-1)/2;\\n        long long good=0;\\n\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]-i]++;\\n            good+=mp[nums[i]-i]-1;\\n        }\\n\\n        return total-good;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628730,
                "title": "beats-100-c-easy-approach-total-valid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWE CAN CALCULATE THE NUMBER OF GOOD PAIRS USING AN UNORDERED MAP\\n(WE CAN ALSO CALCULATE BY USING A COUNT VARIABLE AND INCREMENTING IT BY THE IF CONDITION OF (j-nums[j] == i-nums[i] ))\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSTART THE LOOP AND RETURN total - count;\\nTOTAL is n*(n-1)/2 \\ntaking the examples 1,2,3,4,5\\n1 has all pairs befores it ie 0 pairs.\\n2 has all pairs before it ie 1 \\nsimilary 3 has 2, 4 has 3 and 5 has 4 \\n0+1+2+3+4+5 = n * ( n-1 ) / 2;\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        long int count=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        for(int i=0; i<n; i++)\\n        {\\n            count+= mp[i-nums[i]]++;\\n        }\\n        return 1L*n*(n-1)/2 - count;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        long int count=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        for(int i=0; i<n; i++)\\n        {\\n            count+= mp[i-nums[i]]++;\\n        }\\n        return 1L*n*(n-1)/2 - count;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615532,
                "title": "straight-forward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        // j - nums[j] != i - nums[i]\\n        // i < j\\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        long res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res += i  - (map.containsKey(i - nums[i]) ? map.get(i - nums[i]) : 0);\\n            map.put(i - nums[i], map.getOrDefault(i - nums[i], 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n        // j - nums[j] != i - nums[i]\\n        // i < j\\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        long res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res += i  - (map.containsKey(i - nums[i]) ? map.get(i - nums[i]) : 0);\\n            map.put(i - nums[i], map.getOrDefault(i - nums[i], 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566190,
                "title": "python-anti-1814-count-nice-pairs-in-an-array",
                "content": "This is invested version of https://leetcode.com/problems/count-nice-pairs-in-an-array/\\nThis looks like a separate pattern to train for such kind of problems.\\n\\nIf you have not seen/solved that one, this one might be an empty shot.\\n\\nI think I makes sence to explain the one here too (for myself):\\n\\nYou have the definition of a good pair:\\n`GOOD(i, j): nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])`\\n\\nBrute force is n^2 and there\\'s nothing interesting. How to optimize the brute force?\\nThe problem with `GOOD(i, j)` is that you need to operate on `i` and `j` at the same time and this is where the complexity comes from.\\n\\n`GOOD(i, j): f(i, j) == f(j, i)`\\n\\nA little equation tweak:\\n`GOOD(i, j): nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])`\\n\\nAnd now we have:\\n`GOOD(i, j): f(i) == f(j)`\\n\\nWhich reduces the problem from `2` params to just `1`.\\n\\nWe need to find all pairs where `f(i) == f(j)`:\\n\\nWe can go over each index and get `f(index)`. Store somewhere the results and count found duplicates.\\nThis way we now know how many `GOOD(i, j)` we can form.\\n\\nTotal pairs for the same value is nC2 which is `n(n - 1) / 2`\\n\\nAn example:\\n\\n```\\nidx  0 1 2 3  4\\n     42 11 1 97\\nrev  24 11 1 79\\nf(i) 18  0 0 18\\n\\nWe have 2 pairs with the same values: (0,3) and (1,2), which is : 2(2 - 1)/2 + 2(2 - 1)/2 = 2\\n```\\n\\n```\\nclass Solution:\\n    def countNicePairs(self, nums: List[int]) -> int:\\n        count = 0\\n        pairs = defaultdict(int)\\n        for num in nums:\\n            diff = num - int(str(num)[::-1])\\n            count += pairs[diff]\\n            pairs[diff] = pairs.get(diff, 0) + 1\\n\\n        # for num in nums:\\n        #     pairs[num - int(str(num)[::-1])] += 1\\n        # for key in pairs.keys():\\n        #     count += pairs[key] * (pairs[key] - 1) // 2\\n           \\n        return count % (10 ** 9 + 7)\\n```\\n\\nInverted solution for the current problem:\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        \"\"\"\\n         BAD(i,j): j - i != n[j] - n[i]\\n         BAD(i,j): j - n[j] != i - n[i]\\n        GOOD(i,j): j - n[j] == i - n[i]\\n        GOOD(i,j): f(i) == f(j)\\n        f(x) = x - n[x]\\n        Find all pairs of good\\n        substract total - good = bad\\n        \\n              0  1  2  3\\n              4  1  3  3\\n        f(x) -4  0 -1  0 <-- good at (1,3) because GOOD(1,3): f(1) == f(3)\\n        total: 4(4 - 1) / 2 - good_count\\n        \"\"\"\\n        N = len(nums)\\n        f_x = defaultdict(int)\\n        good_pairs = 0\\n        for i,num in enumerate(nums):\\n            good_pairs += f_x[i - num]\\n            f_x[i - num] += 1\\n        return N * (N - 1) // 2 - good_pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nidx  0 1 2 3  4\\n     42 11 1 97\\nrev  24 11 1 79\\nf(i) 18  0 0 18\\n\\nWe have 2 pairs with the same values: (0,3) and (1,2), which is : 2(2 - 1)/2 + 2(2 - 1)/2 = 2\\n```\n```\\nclass Solution:\\n    def countNicePairs(self, nums: List[int]) -> int:\\n        count = 0\\n        pairs = defaultdict(int)\\n        for num in nums:\\n            diff = num - int(str(num)[::-1])\\n            count += pairs[diff]\\n            pairs[diff] = pairs.get(diff, 0) + 1\\n\\n        # for num in nums:\\n        #     pairs[num - int(str(num)[::-1])] += 1\\n        # for key in pairs.keys():\\n        #     count += pairs[key] * (pairs[key] - 1) // 2\\n           \\n        return count % (10 ** 9 + 7)\\n```\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        \"\"\"\\n         BAD(i,j): j - i != n[j] - n[i]\\n         BAD(i,j): j - n[j] != i - n[i]\\n        GOOD(i,j): j - n[j] == i - n[i]\\n        GOOD(i,j): f(i) == f(j)\\n        f(x) = x - n[x]\\n        Find all pairs of good\\n        substract total - good = bad\\n        \\n              0  1  2  3\\n              4  1  3  3\\n        f(x) -4  0 -1  0 <-- good at (1,3) because GOOD(1,3): f(1) == f(3)\\n        total: 4(4 - 1) / 2 - good_count\\n        \"\"\"\\n        N = len(nums)\\n        f_x = defaultdict(int)\\n        good_pairs = 0\\n        for i,num in enumerate(nums):\\n            good_pairs += f_x[i - num]\\n            f_x[i - num] += 1\\n        return N * (N - 1) // 2 - good_pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488516,
                "title": "c-3-lines",
                "content": "I was stuck on this until I read the hints.\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int, long long> m;\\n        for (int i = 0; i < nums.size(); ++i) m[INT_MAX] += ++m[nums[i] - i] - 1;\\n        return nums.size() * (nums.size() - 1) / 2 - m[INT_MAX];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        unordered_map<int, long long> m;\\n        for (int i = 0; i < nums.size(); ++i) m[INT_MAX] += ++m[nums[i] - i] - 1;\\n        return nums.size() * (nums.size() - 1) / 2 - m[INT_MAX];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472631,
                "title": "hashing-easy-c-solution",
                "content": "# Intuition\\n`j-i != nums[j]-nums[i]` can be transformed to `nums[i]-i == nums[j]-j`.\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int x=0; x<n; x++) m[nums[x]-x]++;\\n        if(m.size()==1) return 0;\\n        long long ans=0;\\n        for(auto it: m)\\n        {\\n            ans+=(long long)it.second*(it.second-1)/2;\\n        }\\n        return (long long)n*(n-1)/2-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long countBadPairs(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int x=0; x<n; x++) m[nums[x]-x]++;\\n        if(m.size()==1) return 0;\\n        long long ans=0;\\n        for(auto it: m)\\n        {\\n            ans+=(long long)it.second*(it.second-1)/2;\\n        }\\n        return (long long)n*(n-1)/2-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458175,
                "title": "simple-java-solution-using-combinations",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    //as per question i - j = nums[i] - nums[j] is a good pair which means i - nums[i] = j - nums[j]\\n    // so we will have counter hashmap which will count occurances of same value of i -nums[i]\\n    //say we have 2 entries for [i-nums[i]] being 6....so there exists one pair...if it was 3..there exists 3C2 = 3(3-1)/2 = 3 pairs..\\n//BASICALLY FINDING COMBINATIONS OF 2 IN A GROUP OF 3\\n    //total pairs will be NC2 = N(N-1)/2\\n    //Bad pairs will be total-good\\n    public long countBadPairs(int[] nums) {\\n    \\n    long n=nums.length, good_pairs=0;\\n    \\n    Map<Integer, Integer> freq_map= new HashMap<>();\\n    \\n    for( int i=0; i<n; i++){\\n        \\n            freq_map.put(i-nums[i], freq_map.getOrDefault(i-nums[i], 0)+1);\\n    }\\n   \\n    for(Integer i :  freq_map.keySet()){\\n        long y = freq_map.get(i);\\n        if(y > 1){\\n           good_pairs+=  (y) * (y-1) / 2;\\n        }\\n    }\\n   \\n    long total_pairs = n*(n-1)/2;\\n    return total_pairs - good_pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //as per question i - j = nums[i] - nums[j] is a good pair which means i - nums[i] = j - nums[j]\\n    // so we will have counter hashmap which will count occurances of same value of i -nums[i]\\n    //say we have 2 entries for [i-nums[i]] being 6....so there exists one pair...if it was 3..there exists 3C2 = 3(3-1)/2 = 3 pairs..\\n//BASICALLY FINDING COMBINATIONS OF 2 IN A GROUP OF 3\\n    //total pairs will be NC2 = N(N-1)/2\\n    //Bad pairs will be total-good\\n    public long countBadPairs(int[] nums) {\\n    \\n    long n=nums.length, good_pairs=0;\\n    \\n    Map<Integer, Integer> freq_map= new HashMap<>();\\n    \\n    for( int i=0; i<n; i++){\\n        \\n            freq_map.put(i-nums[i], freq_map.getOrDefault(i-nums[i], 0)+1);\\n    }\\n   \\n    for(Integer i :  freq_map.keySet()){\\n        long y = freq_map.get(i);\\n        if(y > 1){\\n           good_pairs+=  (y) * (y-1) / 2;\\n        }\\n    }\\n   \\n    long total_pairs = n*(n-1)/2;\\n    return total_pairs - good_pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434407,
                "title": "beats-95-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n    long cnt=0;\\n    HashMap<Integer,Integer> mp= new HashMap<>();\\n    for(int i=0;i<nums.length;i++){\\n        int prev= mp.getOrDefault(i-nums[i],0);\\n        cnt+= i- prev;\\n        mp.put(i-nums[i],prev+1);\\n    }\\n    return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long countBadPairs(int[] nums) {\\n    long cnt=0;\\n    HashMap<Integer,Integer> mp= new HashMap<>();\\n    for(int i=0;i<nums.length;i++){\\n        int prev= mp.getOrDefault(i-nums[i],0);\\n        cnt+= i- prev;\\n        mp.put(i-nums[i],prev+1);\\n    }\\n    return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432819,
                "title": "scala-o-n-using-hashmap-beats-100-100",
                "content": "## Find an awesome explanation [here](https://leetcode.com/problems/count-number-of-bad-pairs/solutions/2388149/java-y-x-f-y-f-x-linear-explained-ttt/).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```scala\\nobject Solution {\\n  import scala.collection.mutable\\n\\n  def countBadPairs(nums: Array[Int]): Long = {\\n    var count = 0L\\n    val counts = new mutable.HashMap[Int, Int](10_000, mutable.HashMap.defaultLoadFactor)\\n\\n    for (i <- nums.indices) {\\n      val diff = i - nums(i)\\n      count += i - counts.getOrElse(diff, 0)\\n\\n      counts.updateWith(diff) {\\n        case Some(value) => Some(value + 1)\\n        case None        => Some(1)\\n      }\\n    }\\n\\n    count\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```scala\\nobject Solution {\\n  import scala.collection.mutable\\n\\n  def countBadPairs(nums: Array[Int]): Long = {\\n    var count = 0L\\n    val counts = new mutable.HashMap[Int, Int](10_000, mutable.HashMap.defaultLoadFactor)\\n\\n    for (i <- nums.indices) {\\n      val diff = i - nums(i)\\n      count += i - counts.getOrElse(diff, 0)\\n\\n      counts.updateWith(diff) {\\n        case Some(value) => Some(value + 1)\\n        case None        => Some(1)\\n      }\\n    }\\n\\n    count\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3429797,
                "title": "total-good-easy-approach",
                "content": "# Intuition \\nTOTAL-GOOD PAIRS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIF WE RE ARRANGE THE EQUATION (j - i == nums[j] - nums[i]) TO (j - nums[j] == i- nums[i]) THEN WE HVE TO CALCULATE THE NUMBER OF COUNT OF SAME DIFFERENCE . \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<int,int> mp;\\n       long long  int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[i-nums[i]]++;\\n        }\\n        long long temp=0;\\n        for(auto it:mp)\\n        {\\n            long long  count=it.second;\\n            temp+= (count*(count-1))/2;\\n\\n        }\\n        long long a=(n*(n-1))/2;\\n        return a-temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        map<int,int> mp;\\n       long long  int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[i-nums[i]]++;\\n        }\\n        long long temp=0;\\n        for(auto it:mp)\\n        {\\n            long long  count=it.second;\\n            temp+= (count*(count-1))/2;\\n\\n        }\\n        long long a=(n*(n-1))/2;\\n        return a-temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429010,
                "title": "easy-10-line-solution-with-intution",
                "content": "# Intuition\\nrule 1: total pairs = good pairs + bad pairs //in any array\\nrule 2: difference = current number - current index\\nrule 3: if you know the number of nums say x,traversed until now ,having the same differnce as current num ,the total number of good pairs will be increased by x\\n\\n# Approach\\n\\ntraverse from one side of array and have a count in a map called differMap which maintains count for each difference ,then add the value of differMap for the current difference to good pairs\\nand later don\\'t forget to increase differMap\\'s current difference count\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar countBadPairs = function(nums) {\\n    let differMap = new Map(),goodPairs = 0,n = nums.length\\n    for(let i = 0 ;i<n ; i++){\\n        let difference = nums[i] - i\\n        goodPairs += (differMap[difference]??0) //you can increase your goodpairs by simply checking for numbers  who has same difference as of (nums[i]) from thier index\\n        differMap[difference] = differMap[difference]? differMap[difference]+1 :1;\\n    }\\n    let totalPairs = (n*(n-1))/2\\n    return totalPairs-goodPairs//totalPairs = goodpairs + badPairs\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countBadPairs = function(nums) {\\n    let differMap = new Map(),goodPairs = 0,n = nums.length\\n    for(let i = 0 ;i<n ; i++){\\n        let difference = nums[i] - i\\n        goodPairs += (differMap[difference]??0) //you can increase your goodpairs by simply checking for numbers  who has same difference as of (nums[i]) from thier index\\n        differMap[difference] = differMap[difference]? differMap[difference]+1 :1;\\n    }\\n    let totalPairs = (n*(n-1))/2\\n    return totalPairs-goodPairs//totalPairs = goodpairs + badPairs\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3426334,
                "title": "transform-the-equation-c",
                "content": "\\n**LOGIC:**\\nGIVEN EQUATION : **j - i != nums[j] - nums[i].**\\nTRANSFORM THE ABOVE EQUATION TO : **j - nums[j] != i - nums[i].**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long res=0;\\n        unordered_map<int,int>fre;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int to_find=i-nums[i];\\n            res+=(i)-fre[to_find];\\n            fre[to_find]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countBadPairs(vector<int>& nums) {\\n        long long res=0;\\n        unordered_map<int,int>fre;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int to_find=i-nums[i];\\n            res+=(i)-fre[to_find];\\n            fre[to_find]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417192,
                "title": "easiest-python-solution-beats-99-explained",
                "content": "\\n\\n# Approach\\n(j - i != nums[j] - nums[i]) is the same as (nums[i] - i != nums[j] - j).\\nUsing this insight, we subtract i from each nums[i].\\nWe then keep the frequency of each element in nums using Counter.\\nThe total number of good pairs  is equal to $$ ^nC_2 $$ where \\'n\\' is the number of times that number appears in nums (or the value in the counter dictionary)\\n\\nFinally we return the total number of pairs in nums, subtracted by the number of good pairs.\\n\\n# Complexity\\n- Time complexity: I\\'m not sure, but probably $$O(n)$$\\n\\n- Space complexity:  $$O(n)$$ , I think\\n\\n# Code\\n```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = [nums[i] - i for i in range(n)]\\n        good_pairs = 0\\n        for freq in Counter(nums).values():\\n            good_pairs += math.comb(freq, 2) #freq * (freq - 1) // 2\\n        return n * (n - 1) // 2 - good_pairs\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/da4b8db4-855a-4f4c-897f-67be31a93280_1681492437.1706812.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countBadPairs(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = [nums[i] - i for i in range(n)]\\n        good_pairs = 0\\n        for freq in Counter(nums).values():\\n            good_pairs += math.comb(freq, 2) #freq * (freq - 1) // 2\\n        return n * (n - 1) // 2 - good_pairs\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1838579,
                "content": [
                    {
                        "username": "mayurpatle",
                        "content": "We  can  Count the  good pairs first  and  then  subtract the good pairs  from  the total number of  pairs ie  n   *    ( n - 1 )  / 2   ;  \\ntotal good  pairs  = j   -  nums[j]  ==  i  -  nums[i]   ; \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n57 / 65 testcases passed\\nWhy ??????????????????......\\n\\nSimilar Question : 2563. Count the Number of Fair Pairs\\nTime Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "roysumit949",
                        "content": "I guess test cases stopped you :P"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2364.%20Count%20Number%20of%20Bad%20Pairs.CPP\\nAll LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR."
                    },
                    {
                        "username": "maryushka",
                        "content": "hello i\\'m marshellundikalibra i\\'m 17 y.o from kg\\n"
                    },
                    {
                        "username": "roysumit949",
                        "content": "why  `numbs[I]-I` is not working where as I-nums[I] is working?"
                    },
                    {
                        "username": "AlexLC87",
                        "content": "Its working. See code below. \n\n```cpp\nconstexpr long long calculateAllCombinations(const long long &size){\n    return size * (size - 1) >> 1LL;\n}\n\nclass Solution {\npublic:\n    long long countBadPairs(vector<int>& nums) {\n        const auto &N = std::size(nums);\n\n        unordered_map<int, int> goodPairs;\n        for(size_t index = 0; index < N; ++index){\n            //goodPairs[index - nums[index]]++;\n            goodPairs[nums[index] - index]++;\n        }\n        \n        const auto &countAllPairs = calculateAllCombinations(N);\n\n        auto &&countGoodPairs = 0LL;\n\n        for_each(cbegin(goodPairs), cend(goodPairs), [&](const auto &pairs){\n            const auto &[number, count] = pairs;\n            countGoodPairs += calculateAllCombinations(count);\n        });\n\n        const auto &countBadPairs = countAllPairs - countGoodPairs;\n\n        return countBadPairs;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1880328,
                "content": [
                    {
                        "username": "mayurpatle",
                        "content": "We  can  Count the  good pairs first  and  then  subtract the good pairs  from  the total number of  pairs ie  n   *    ( n - 1 )  / 2   ;  \\ntotal good  pairs  = j   -  nums[j]  ==  i  -  nums[i]   ; \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n57 / 65 testcases passed\\nWhy ??????????????????......\\n\\nSimilar Question : 2563. Count the Number of Fair Pairs\\nTime Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "roysumit949",
                        "content": "I guess test cases stopped you :P"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2364.%20Count%20Number%20of%20Bad%20Pairs.CPP\\nAll LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR."
                    },
                    {
                        "username": "maryushka",
                        "content": "hello i\\'m marshellundikalibra i\\'m 17 y.o from kg\\n"
                    },
                    {
                        "username": "roysumit949",
                        "content": "why  `numbs[I]-I` is not working where as I-nums[I] is working?"
                    },
                    {
                        "username": "AlexLC87",
                        "content": "Its working. See code below. \n\n```cpp\nconstexpr long long calculateAllCombinations(const long long &size){\n    return size * (size - 1) >> 1LL;\n}\n\nclass Solution {\npublic:\n    long long countBadPairs(vector<int>& nums) {\n        const auto &N = std::size(nums);\n\n        unordered_map<int, int> goodPairs;\n        for(size_t index = 0; index < N; ++index){\n            //goodPairs[index - nums[index]]++;\n            goodPairs[nums[index] - index]++;\n        }\n        \n        const auto &countAllPairs = calculateAllCombinations(N);\n\n        auto &&countGoodPairs = 0LL;\n\n        for_each(cbegin(goodPairs), cend(goodPairs), [&](const auto &pairs){\n            const auto &[number, count] = pairs;\n            countGoodPairs += calculateAllCombinations(count);\n        });\n\n        const auto &countBadPairs = countAllPairs - countGoodPairs;\n\n        return countBadPairs;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1807989,
                "content": [
                    {
                        "username": "mayurpatle",
                        "content": "We  can  Count the  good pairs first  and  then  subtract the good pairs  from  the total number of  pairs ie  n   *    ( n - 1 )  / 2   ;  \\ntotal good  pairs  = j   -  nums[j]  ==  i  -  nums[i]   ; \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n57 / 65 testcases passed\\nWhy ??????????????????......\\n\\nSimilar Question : 2563. Count the Number of Fair Pairs\\nTime Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "roysumit949",
                        "content": "I guess test cases stopped you :P"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2364.%20Count%20Number%20of%20Bad%20Pairs.CPP\\nAll LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR."
                    },
                    {
                        "username": "maryushka",
                        "content": "hello i\\'m marshellundikalibra i\\'m 17 y.o from kg\\n"
                    },
                    {
                        "username": "roysumit949",
                        "content": "why  `numbs[I]-I` is not working where as I-nums[I] is working?"
                    },
                    {
                        "username": "AlexLC87",
                        "content": "Its working. See code below. \n\n```cpp\nconstexpr long long calculateAllCombinations(const long long &size){\n    return size * (size - 1) >> 1LL;\n}\n\nclass Solution {\npublic:\n    long long countBadPairs(vector<int>& nums) {\n        const auto &N = std::size(nums);\n\n        unordered_map<int, int> goodPairs;\n        for(size_t index = 0; index < N; ++index){\n            //goodPairs[index - nums[index]]++;\n            goodPairs[nums[index] - index]++;\n        }\n        \n        const auto &countAllPairs = calculateAllCombinations(N);\n\n        auto &&countGoodPairs = 0LL;\n\n        for_each(cbegin(goodPairs), cend(goodPairs), [&](const auto &pairs){\n            const auto &[number, count] = pairs;\n            countGoodPairs += calculateAllCombinations(count);\n        });\n\n        const auto &countBadPairs = countAllPairs - countGoodPairs;\n\n        return countBadPairs;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1789249,
                "content": [
                    {
                        "username": "mayurpatle",
                        "content": "We  can  Count the  good pairs first  and  then  subtract the good pairs  from  the total number of  pairs ie  n   *    ( n - 1 )  / 2   ;  \\ntotal good  pairs  = j   -  nums[j]  ==  i  -  nums[i]   ; \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n57 / 65 testcases passed\\nWhy ??????????????????......\\n\\nSimilar Question : 2563. Count the Number of Fair Pairs\\nTime Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "roysumit949",
                        "content": "I guess test cases stopped you :P"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2364.%20Count%20Number%20of%20Bad%20Pairs.CPP\\nAll LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR."
                    },
                    {
                        "username": "maryushka",
                        "content": "hello i\\'m marshellundikalibra i\\'m 17 y.o from kg\\n"
                    },
                    {
                        "username": "roysumit949",
                        "content": "why  `numbs[I]-I` is not working where as I-nums[I] is working?"
                    },
                    {
                        "username": "AlexLC87",
                        "content": "Its working. See code below. \n\n```cpp\nconstexpr long long calculateAllCombinations(const long long &size){\n    return size * (size - 1) >> 1LL;\n}\n\nclass Solution {\npublic:\n    long long countBadPairs(vector<int>& nums) {\n        const auto &N = std::size(nums);\n\n        unordered_map<int, int> goodPairs;\n        for(size_t index = 0; index < N; ++index){\n            //goodPairs[index - nums[index]]++;\n            goodPairs[nums[index] - index]++;\n        }\n        \n        const auto &countAllPairs = calculateAllCombinations(N);\n\n        auto &&countGoodPairs = 0LL;\n\n        for_each(cbegin(goodPairs), cend(goodPairs), [&](const auto &pairs){\n            const auto &[number, count] = pairs;\n            countGoodPairs += calculateAllCombinations(count);\n        });\n\n        const auto &countBadPairs = countAllPairs - countGoodPairs;\n\n        return countBadPairs;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1960131,
                "content": [
                    {
                        "username": "mayurpatle",
                        "content": "We  can  Count the  good pairs first  and  then  subtract the good pairs  from  the total number of  pairs ie  n   *    ( n - 1 )  / 2   ;  \\ntotal good  pairs  = j   -  nums[j]  ==  i  -  nums[i]   ; \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Time Limit Exceeded\\n57 / 65 testcases passed\\nWhy ??????????????????......\\n\\nSimilar Question : 2563. Count the Number of Fair Pairs\\nTime Limit Exceeded\\n47 / 53 testcases passed\\n\\uD83E\\uDD7A\\uD83E\\uDD72\\uD83D\\uDE25\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "roysumit949",
                        "content": "I guess test cases stopped you :P"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2364.%20Count%20Number%20of%20Bad%20Pairs.CPP\\nAll LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR."
                    },
                    {
                        "username": "maryushka",
                        "content": "hello i\\'m marshellundikalibra i\\'m 17 y.o from kg\\n"
                    },
                    {
                        "username": "roysumit949",
                        "content": "why  `numbs[I]-I` is not working where as I-nums[I] is working?"
                    },
                    {
                        "username": "AlexLC87",
                        "content": "Its working. See code below. \n\n```cpp\nconstexpr long long calculateAllCombinations(const long long &size){\n    return size * (size - 1) >> 1LL;\n}\n\nclass Solution {\npublic:\n    long long countBadPairs(vector<int>& nums) {\n        const auto &N = std::size(nums);\n\n        unordered_map<int, int> goodPairs;\n        for(size_t index = 0; index < N; ++index){\n            //goodPairs[index - nums[index]]++;\n            goodPairs[nums[index] - index]++;\n        }\n        \n        const auto &countAllPairs = calculateAllCombinations(N);\n\n        auto &&countGoodPairs = 0LL;\n\n        for_each(cbegin(goodPairs), cend(goodPairs), [&](const auto &pairs){\n            const auto &[number, count] = pairs;\n            countGoodPairs += calculateAllCombinations(count);\n        });\n\n        const auto &countBadPairs = countAllPairs - countGoodPairs;\n\n        return countBadPairs;\n    }\n};\n```"
                    }
                ]
            }
        ]
    }
]