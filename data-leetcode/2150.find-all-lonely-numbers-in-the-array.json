[
    {
        "title": "Find All Lonely Numbers in the Array",
        "question_content": "You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\nReturn all lonely numbers in nums. You may return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [10,6,5,8]\nOutput: [10,8]\nExplanation: \n- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.\n- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.\n- 5 is not a lonely number since 6 appears in nums and vice versa.\nHence, the lonely numbers in nums are [10, 8].\nNote that [8, 10] may also be returned.\n\nExample 2:\n\nInput: nums = [1,3,5,3]\nOutput: [1,5]\nExplanation: \n- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.\n- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.\n- 3 is not a lonely number since it appears twice.\nHence, the lonely numbers in nums are [1, 5].\nNote that [5, 1] may also be returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t0 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 1711316,
                "title": "counter",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        m = Counter(nums)\\n        return [n for n in nums if m[n] == 1 and m[n - 1] + m[n + 1] == 0]\\n```\\n\\n**C++**\\n```cpp\\nvector<int> findLonely(vector<int>& nums) {\\n    unordered_map<int, int> m;\\n    vector<int> res;\\n    for (int n : nums)\\n        ++m[n];\\n    for (const auto [n, cnt] : m)\\n        if (cnt == 1 && m.count(n + 1) == 0 && m.count(n - 1) == 0)\\n            res.push_back(n);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        m = Counter(nums)\\n        return [n for n in nums if m[n] == 1 and m[n - 1] + m[n + 1] == 0]\\n```\n```cpp\\nvector<int> findLonely(vector<int>& nums) {\\n    unordered_map<int, int> m;\\n    vector<int> res;\\n    for (int n : nums)\\n        ++m[n];\\n    for (const auto [n, cnt] : m)\\n        if (cnt == 1 && m.count(n + 1) == 0 && m.count(n - 1) == 0)\\n            res.push_back(n);\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711428,
                "title": "java-hashmap",
                "content": "Complexity\\nTime O(n)\\nSpace O(n)\\n\\n Iterating over the map could be better becase of the duplicates in the nums array, thanks @indianpie.\\n```\\npublic List<Integer> findLonely(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n\\t\\tfor (int num : map.keySet()) {\\n       //  for (int num : nums) {\\n            if (map.get(num) == 1 && !map.containsKey(num - 1) && !map.containsKey(num + 1)) {\\n                res.add(num);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findLonely(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n\\t\\tfor (int num : map.keySet()) {\\n       //  for (int num : nums) {\\n            if (map.get(num) == 1 && !map.containsKey(num - 1) && !map.containsKey(num + 1)) {\\n                res.add(num);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1716675,
                "title": "c-hashmap-clean-and-easy-to-understand",
                "content": "\\n\\n(Honestly, the first thing that striked me was sorting , but in a second I realised that it needs frequency of all the numbers and hence we are using hashmap) \\n\\nWe are storing the frequency of each number in a hashmap and in another loop we are simply checking whether that number is lonely or not by using the two conditions:\\n1. Count of that number is 1\\n2. No adjacent digit i.e n+1 and n-1 is present in our array.\\n\\n\\nTime complexity: **O(n),** n=number of elements in the array\\nSpace complexity: **O(P)**, P= number of unique elements in the array.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        vector<int>ans;\\n        for(int n:nums) mp[n]++;   // storing the frequency of all the numbers in the array\\n        for(pair<int,int>n:mp){\\n            int x=n.first,y=n.second;\\n            if(y==1 and mp.count(x+1)==0 and mp.count(x-1)==0){   // if count of that number is 1 and no adjacent number is present then it is a lonely number \\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        vector<int>ans;\\n        for(int n:nums) mp[n]++;   // storing the frequency of all the numbers in the array\\n        for(pair<int,int>n:mp){\\n            int x=n.first,y=n.second;\\n            if(y==1 and mp.count(x+1)==0 and mp.count(x-1)==0){   // if count of that number is 1 and no adjacent number is present then it is a lonely number \\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711880,
                "title": "c-counter-easy-approach-and-explanation",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* Return the vector of the lonely numbers whose adjacent or copy numbers  are not present in the given vector.\\n#### \\u2714\\uFE0F **Solution - I (Easy Approach)**\\n##### **Intuition :-**\\n* Just mark the count of every element.\\n* Check weather its any adjacent no is present in the count array or the number appears more than one.\\n* If none of the condition satisfy add the element in the ans vector.\\n##### **Code :-**\\n```\\nclass Solution\\n{\\npublic:\\n     vector<int> findLonely(vector<int> &nums)\\n     {\\n          vector<int> mark(1000001);\\n          for (auto &&num : nums)\\n               mark[num]++;\\n          vector<int> ans;\\n          for (auto &&num : nums)\\n               if (num == 0 and !(mark[num + 1] or mark[num] > 1))\\n                    ans.push_back(num);\\n               else if (num == 1000000 and !(mark[num - 1] or mark[num] > 1))\\n                    ans.push_back(num);\\n               else if ((num > 0 and num < 1000000) and !(mark[num - 1] or mark[num] > 1 or mark[num + 1]))\\n                    ans.push_back(num);\\n          return ans;\\n     }\\n};\\n```\\n**Time Complexity** : `O(N)`, Iteration is done two times.\\n**Space Complexity** : `O(10^6)`, creater a counter vector with maximum size.\\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n     vector<int> findLonely(vector<int> &nums)\\n     {\\n          vector<int> mark(1000001);\\n          for (auto &&num : nums)\\n               mark[num]++;\\n          vector<int> ans;\\n          for (auto &&num : nums)\\n               if (num == 0 and !(mark[num + 1] or mark[num] > 1))\\n                    ans.push_back(num);\\n               else if (num == 1000000 and !(mark[num - 1] or mark[num] > 1))\\n                    ans.push_back(num);\\n               else if ((num > 0 and num < 1000000) and !(mark[num - 1] or mark[num] > 1 or mark[num + 1]))\\n                    ans.push_back(num);\\n          return ans;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711698,
                "title": "c-hashmap-clean-easy",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n             if(m[nums[i]] == 1 && m.count(nums[i] - 1) == 0 && m.count(nums[i] + 1) == 0){\\n                ans.push_back(nums[i]);\\n        }\\n      }\\n        return ans;\\n    }\\n};\\n\\nfeel free to ask your doubts :)\\nand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734286,
                "title": "lol-solution-99-faster-when-i-used-gareeb-approach-instead-of-data-structure",
                "content": "```\\n\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        int[] arr = new int[1000001] ;\\n        List<Integer> result = new ArrayList<>() ;\\n        for(int i : nums){\\n            if(i>0)\\n            arr[i-1]++ ;\\n            arr[i]++ ;\\n            if(i<1000000)\\n            arr[i+1]++ ;\\n        }\\n        for(int i: nums){\\n            if(arr[i]==1){\\n                result.add(i) ;\\n            }\\n        }\\n        return result ;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        int[] arr = new int[1000001] ;\\n        List<Integer> result = new ArrayList<>() ;\\n        for(int i : nums){\\n            if(i>0)\\n            arr[i-1]++ ;\\n            arr[i]++ ;\\n            if(i<1000000)\\n            arr[i+1]++ ;\\n        }\\n        for(int i: nums){\\n            if(arr[i]==1){\\n                result.add(i) ;\\n            }\\n        }\\n        return result ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766758,
                "title": "java-easiest-solution-using-hashmap",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n      Map<Integer, Integer> map = new HashMap<>();\\n      for(int num : nums) {\\n          map.put(num, map.getOrDefault(num, 0) + 1);\\n      }\\n      List<Integer> ans = new ArrayList<>();\\n      for(int num : nums) {\\n          if(map.get(num) == 1 && ! map.containsKey(num - 1) && ! map.containsKey(num + 1))\\n          ans.add(num);\\n      } \\n      return ans;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n      Map<Integer, Integer> map = new HashMap<>();\\n      for(int num : nums) {\\n          map.put(num, map.getOrDefault(num, 0) + 1);\\n      }\\n      List<Integer> ans = new ArrayList<>();\\n      for(int num : nums) {\\n          if(map.get(num) == 1 && ! map.containsKey(num - 1) && ! map.containsKey(num + 1))\\n          ans.add(num);\\n      } \\n      return ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711759,
                "title": "java-100-tc-100-sc-sorted-array",
                "content": "```java\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (nums[i - 1] + 1 < nums[i] && nums[i] + 1 < nums[i + 1]) {\\n                list.add(nums[i]);\\n            }\\n        }\\n        if (nums.length == 1) {\\n            list.add(nums[0]);\\n        }\\n        if (nums.length > 1) {\\n            if (nums[0] + 1 < nums[1]) {\\n                list.add(nums[0]);\\n            }\\n            if (nums[nums.length - 2] + 1 < nums[nums.length - 1]) {\\n                list.add(nums[nums.length - 1]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (nums[i - 1] + 1 < nums[i] && nums[i] + 1 < nums[i + 1]) {\\n                list.add(nums[i]);\\n            }\\n        }\\n        if (nums.length == 1) {\\n            list.add(nums[0]);\\n        }\\n        if (nums.length > 1) {\\n            if (nums[0] + 1 < nums[1]) {\\n                list.add(nums[0]);\\n            }\\n            if (nums[nums.length - 2] + 1 < nums[nums.length - 1]) {\\n                list.add(nums[nums.length - 1]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711458,
                "title": "js-using-map",
                "content": "```\\nvar findLonely = function(nums) {\\n    let countMap = new Map();\\n    let result = [];\\n    for (let num of nums) {\\n        countMap.set(num, (countMap.get(num) || 0) + 1);\\n    }\\n    for (let num of nums) {\\n        if (!countMap.has(num - 1) && !countMap.has(num + 1) && countMap.get(num) === 1) {\\n            \\n            result.push(num);\\n        }\\n        \\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLonely = function(nums) {\\n    let countMap = new Map();\\n    let result = [];\\n    for (let num of nums) {\\n        countMap.set(num, (countMap.get(num) || 0) + 1);\\n    }\\n    for (let num of nums) {\\n        if (!countMap.has(num - 1) && !countMap.has(num + 1) && countMap.get(num) === 1) {\\n            \\n            result.push(num);\\n        }\\n        \\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2961559,
                "title": "java-2-line-code-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712181,
                "title": "c-easy-solution-using-map",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector <int> ans;\\n        map <int, int> m;\\n        for(int i=0; i<nums.size(); i++){\\n          m[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n          if(m[nums[i]]==1 && m.find(nums[i]-1)==m.end() && m.find(nums[i]+1)==m.end()){\\n            ans.push_back(nums[i]);\\n          }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector <int> ans;\\n        map <int, int> m;\\n        for(int i=0; i<nums.size(); i++){\\n          m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1717563,
                "title": "java-simple-solution-faster-than-98-online-java-users",
                "content": "***//Please upvote if you like my approach***\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        Arrays.sort(arr);\\n        if(arr.length==1){\\n            al.add(arr[0]);\\n            return al;\\n        }\\n        if(arr[0]+1!=arr[1]&&arr[0]!=arr[1])al.add(arr[0]);\\n        if(arr[arr.length-1]-1!=arr[arr.length-2]&&arr[arr.length-1]!=arr[arr.length-2])al.add(arr[arr.length-1]);\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i]==arr[i-1]||arr[i]==arr[i+1])continue;\\n            else if(arr[i-1]+1!=arr[i]&&arr[i+1]-1!=arr[i])al.add(arr[i]);\\n        }\\n        return al;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        Arrays.sort(arr);\\n        if(arr.length==1){\\n            al.add(arr[0]);\\n            return al;\\n        }\\n        if(arr[0]+1!=arr[1]&&arr[0]!=arr[1])al.add(arr[0]);\\n        if(arr[arr.length-1]-1!=arr[arr.length-2]&&arr[arr.length-1]!=arr[arr.length-2])al.add(arr[arr.length-1]);\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i]==arr[i-1]||arr[i]==arr[i+1])continue;\\n            else if(arr[i-1]+1!=arr[i]&&arr[i+1]-1!=arr[i])al.add(arr[i]);\\n        }\\n        return al;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711397,
                "title": "c-two-lines-o-n-time-space",
                "content": "```\\npublic class Solution\\n{\\n    public IList<int> FindLonely(int[] nums)\\n    {\\n        var dict = nums.GroupBy(x => x).ToDictionary(g => g.Key, g => g.Count());\\n        return nums.Where(x => dict[x] == 1 && !dict.ContainsKey(x - 1) && !dict.ContainsKey(x + 1)).ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<int> FindLonely(int[] nums)\\n    {\\n        var dict = nums.GroupBy(x => x).ToDictionary(g => g.Key, g => g.Count());\\n        return nums.Where(x => dict[x] == 1 && !dict.ContainsKey(x - 1) && !dict.ContainsKey(x + 1)).ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160821,
                "title": "time-100-space-100-beats-sorting-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        if(nums.size()<=1)return nums;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(i && i<n-1){\\n                if(nums[i]-nums[i-1]>1 && nums[i+1]-nums[i]>1){\\n                    ans.push_back(nums[i]);\\n                }\\n            }else if(i){\\n                if((nums[i]-nums[i-1])>1){\\n                    ans.push_back(nums[i]);\\n                }\\n            }else{\\n                if((nums[i+1]-nums[i])>1){\\n                    ans.push_back(nums[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        if(nums.size()<=1)return nums;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(i && i<n-1){\\n                if(nums[i]-nums[i-1]>1 && nums[i+1]-nums[i]>1){\\n                    ans.push_back(nums[i]);\\n                }\\n            }else if(i){\\n                if((nums[i]-nums[i-1])>1){\\n                    ans.push_back(nums[i]);\\n                }\\n            }else{\\n                if((nums[i+1]-nums[i])>1){\\n                    ans.push_back(nums[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806033,
                "title": "easy-and-faster-approach-without-using-hashmap",
                "content": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> l1=new ArrayList<>();\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        if(n==1){\\n            l1.add(nums[0]);\\n        }\\n        else{\\n        if(nums[0]!=nums[1] && nums[0]+1!=nums[1]){\\n            l1.add(nums[0]);\\n        }\\n        if(nums[n-1]!=nums[n-2] && nums[n-1]-1!=nums[n-2]){\\n            l1.add(nums[n-1]);\\n        }\\n        }\\n        for(int i=1;i<n-1;i++){\\n            if(nums[i]!=nums[i-1] && nums[i]!=nums[i+1] && nums[i]-1!=nums[i-1] && nums[i]+1!=nums[i+1]){\\n                l1.add(nums[i]);\\n            }\\n        }\\n        return l1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> l1=new ArrayList<>();\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        if(n==1){\\n            l1.add(nums[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1725345,
                "title": "c-easy-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> ump;\\n        vector<int> sol;\\n        for(int i=0;i<n;i++)\\n        {\\n            ump[nums[i]]++;\\n        }\\n        for(auto a: ump)\\n        {\\n            if(a.second==1 and !ump.count(a.first+1) and !ump .count(a.first-1))\\n                sol.push_back(a.first);\\n        }\\n\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> ump;\\n        vector<int> sol;\\n        for(int i=0;i<n;i++)\\n        {\\n            ump[nums[i]]++;\\n        }\\n        for(auto a: ump)\\n        {\\n            if(a.second==1 and !ump.count(a.first+1) and !ump .count(a.first-1))\\n                sol.push_back(a.first);\\n        }\\n\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713694,
                "title": "python3-runtime-o-n",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        check = defaultdict(int)\\n        for i in nums:\\n            check[i] += 1\\n        ans = []\\n        for i in nums:\\n            if ((i==0) or (i>=1 and check[i-1]==0)):\\n                if check[i]==1 and check[i+1]==0:\\n                    ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        check = defaultdict(int)\\n        for i in nums:\\n            check[i] += 1\\n        ans = []\\n        for i in nums:\\n            if ((i==0) or (i>=1 and check[i-1]==0)):\\n                if check[i]==1 and check[i+1]==0:\\n                    ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308021,
                "title": "c-solution-brute-force-hash-map",
                "content": "# Approach: Hash Map\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n    vector<int> ans;\\n    unordered_map<int, int> m;\\n    for (int a : nums)\\n        m[a]++;\\n\\n    for (auto it = m.begin(); it != m.end(); it++)\\n        if (m.find(it->first - 1) == m.end() && m.find(it->first + 1) == m.end() && it->second == 1)\\n            ans.push_back(it->first);\\n    return ans;\\n\\n    }\\n};\\n```\\n# Approach: Brute Force\\n\\n# Complexity\\n- Time complexity:O(nlog n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n    sort(nums.begin(),nums.end());\\n    vector<int> ans;\\n    int n=nums.size();\\n    if(n==1)\\n    {\\n        ans.push_back(nums[0]);\\n        return ans;\\n    }\\n    if (nums[0] != nums[1] - 1 && nums[0]!=nums[1])\\n        ans.push_back(nums[0]);\\n    if (nums[n - 1] != (nums[n - 2] + 1) && nums[n-1]!=nums[n-2])\\n        ans.push_back(nums[n-1]);\\n\\n    for (int i = 1; i < n - 1; i++)\\n    {\\n        if ((nums[i] != nums[i - 1] + 1 && nums[i] != nums[i - 1]) && (nums[i] != nums[i + 1] - 1 && nums[i] != nums[i + 1]))\\n            ans.push_back(nums[i]);\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n    vector<int> ans;\\n    unordered_map<int, int> m;\\n    for (int a : nums)\\n        m[a]++;\\n\\n    for (auto it = m.begin(); it != m.end(); it++)\\n        if (m.find(it->first - 1) == m.end() && m.find(it->first + 1) == m.end() && it->second == 1)\\n            ans.push_back(it->first);\\n    return ans;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n    sort(nums.begin(),nums.end());\\n    vector<int> ans;\\n    int n=nums.size();\\n    if(n==1)\\n    {\\n        ans.push_back(nums[0]);\\n        return ans;\\n    }\\n    if (nums[0] != nums[1] - 1 && nums[0]!=nums[1])\\n        ans.push_back(nums[0]);\\n    if (nums[n - 1] != (nums[n - 2] + 1) && nums[n-1]!=nums[n-2])\\n        ans.push_back(nums[n-1]);\\n\\n    for (int i = 1; i < n - 1; i++)\\n    {\\n        if ((nums[i] != nums[i - 1] + 1 && nums[i] != nums[i - 1]) && (nums[i] != nums[i + 1] - 1 && nums[i] != nums[i + 1]))\\n            ans.push_back(nums[i]);\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996836,
                "title": "cpp-map-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>v;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m[nums[i]]==1 && m.find(nums[i]-1)==m.end() && m.find(nums[i]+1)==m.end())\\n            {\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>v;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m[nums[i]]==1 && m.find(nums[i]-1)==m.end() && m.find(nums[i]+1)==m.end())\\n            {\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959869,
                "title": "optimized-c-solution",
                "content": "# Approach\\nIf one goes for the below written approach , then the constraints are large enough to generate a **TLE error**.\\n\\n![tle.png](https://assets.leetcode.com/users/images/d3565f5c-ecaf-4c19-b9bb-32e655baaa16_1672169444.703417.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n// function to check if (x-1) and (x+1) is present or not\\nbool check(vector<int>& nums,int n){\\n    int a=n-1;\\n    int b=n+1;\\n    bool value = true;\\n    for(int i=0;i<nums.size();++i){\\n        if(nums[i]==a || nums[i]==b){\\n            value=false;\\n            //cout<<value<<\" \";\\n            break;\\n        }\\n    }\\n    return value;\\n}\\n    vector<int> findLonely(vector<int>& nums) {\\n     unordered_map<int,int> mp;\\n     for(int i=0;i<nums.size();++i){\\n         mp[nums[i]]++;\\n     }   \\n     vector<int> temp;\\n     for(auto i:mp){\\n         if(i.second==1){\\n             temp.push_back(i.first);\\n         }\\n     }\\n     vector<int> ans;\\n     for(int i=0;i<temp.size();++i){\\n        bool okay = check(nums,temp[i]);\\n        if(okay) ans.push_back(temp[i]);\\n     }\\n     return ans;\\n    }\\n};\\n```\\n So an optimised approach would be , using **HASHING** as well as the **find** function which was missing in the above  approach to reduce time and space complexity thus avoiding a TLE Error which is always a nightmare !\\n\\n\\n# Optimized Approach\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n     //declared a vector to store the lonely numbers\\n     vector<int> ans;\\n\\n     //Use hashmap to count the frequency of all the elements of the vector\\n      unordered_map<int,int> mp;\\n      for(int i=0;i<nums.size();++i){\\n         mp[nums[i]]++; \\n      }  \\n      \\n      // Now check if the frequency of the element is 1 and the adjacent numbers x+1 and x-1 are not found (for this use find function to check whether their frequency is not present in hashmap or it is -1)\\n      for(int i=0;i<nums.size();++i){\\n\\n          if(mp[nums[i]]==1){\\n\\n              if(mp.find(nums[i]+1)==mp.end() && mp.find(nums[i]-1)==mp.end())   {\\n\\n                 //If all the conditions are met , then push the lonely numbers into the ans vector\\n                  ans.push_back(nums[i]);\\n\\n              }\\n          }\\n      }\\n\\n      return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// function to check if (x-1) and (x+1) is present or not\\nbool check(vector<int>& nums,int n){\\n    int a=n-1;\\n    int b=n+1;\\n    bool value = true;\\n    for(int i=0;i<nums.size();++i){\\n        if(nums[i]==a || nums[i]==b){\\n            value=false;\\n            //cout<<value<<\" \";\\n            break;\\n        }\\n    }\\n    return value;\\n}\\n    vector<int> findLonely(vector<int>& nums) {\\n     unordered_map<int,int> mp;\\n     for(int i=0;i<nums.size();++i){\\n         mp[nums[i]]++;\\n     }   \\n     vector<int> temp;\\n     for(auto i:mp){\\n         if(i.second==1){\\n             temp.push_back(i.first);\\n         }\\n     }\\n     vector<int> ans;\\n     for(int i=0;i<temp.size();++i){\\n        bool okay = check(nums,temp[i]);\\n        if(okay) ans.push_back(temp[i]);\\n     }\\n     return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n     //declared a vector to store the lonely numbers\\n     vector<int> ans;\\n\\n     //Use hashmap to count the frequency of all the elements of the vector\\n      unordered_map<int,int> mp;\\n      for(int i=0;i<nums.size();++i){\\n         mp[nums[i]]++; \\n      }  \\n      \\n      // Now check if the frequency of the element is 1 and the adjacent numbers x+1 and x-1 are not found (for this use find function to check whether their frequency is not present in hashmap or it is -1)\\n      for(int i=0;i<nums.size();++i){\\n\\n          if(mp[nums[i]]==1){\\n\\n              if(mp.find(nums[i]+1)==mp.end() && mp.find(nums[i]-1)==mp.end())   {\\n\\n                 //If all the conditions are met , then push the lonely numbers into the ans vector\\n                  ans.push_back(nums[i]);\\n\\n              }\\n          }\\n      }\\n\\n      return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2650879,
                "title": "easy-c-solution-using-mapping",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>res;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(m[nums[i]]==1){\\n                if((m.find(nums[i]-1)==m.end()) &&(m.find(nums[i]+1)==m.end())){\\n                    res.push_back(nums[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>res;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(m[nums[i]]==1){\\n                if((m.find(nums[i]-1)==m.end()) &&(m.find(nums[i]+1)==m.end())){\\n                    res.push_back(nums[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521056,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> res;\\n        vector<int> hash(1e6+2,0);\\n        for(auto &i:nums)hash[i]++;\\n        for(auto &i:nums){\\n            if(i)\\n            { if(hash[i] == 1 && !hash[i+1] && !hash[i-1])\\n                    res.push_back(i);\\n            }\\n            else if(hash[0] == 1 && !hash[1])res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> res;\\n        vector<int> hash(1e6+2,0);\\n        for(auto &i:nums)hash[i]++;\\n        for(auto &i:nums){\\n            if(i)\\n            { if(hash[i] == 1 && !hash[i+1] && !hash[i-1])\\n                    res.push_back(i);\\n            }\\n            else if(hash[0] == 1 && !hash[1])res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838036,
                "title": "python-using-hashmap-simple-linear-approach",
                "content": "**Please upvote if it helps**\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        counter=defaultdict(int)\\n        ans=[]\\n        for i in nums:\\n            counter[i]+=1\\n        for i in nums:\\n            if counter[i-1] or counter [i+1] or counter[i]>1: continue\\n            ans.append(i)\\n        return ans\\n        \\n```\\nTime and space complexity : O(N)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        counter=defaultdict(int)\\n        ans=[]\\n        for i in nums:\\n            counter[i]+=1\\n        for i in nums:\\n            if counter[i-1] or counter [i+1] or counter[i]>1: continue\\n            ans.append(i)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830420,
                "title": "python-dictionary",
                "content": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dict1=dict()\\n        l=[]\\n        for i in nums:\\n            if(i in dict1.keys()):\\n                dict1[i]=-1\\n            else:    \\n                dict1[i]=1\\n            dict1[i-1]=-1\\n            dict1[i+1]=-1    \\n        for i in nums:\\n            if(dict1[i]==1):\\n                l.append(i)\\n        return l",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dict1=dict()\\n        l=[]\\n        for i in nums:\\n            if(i in dict1.keys()):\\n                dict1[i]=-1\\n            else:    \\n                dict1[i]=1\\n            dict1[i-1]=-1\\n            dict1[i+1]=-1    \\n        for i in nums:\\n            if(dict1[i]==1):\\n                l.append(i)\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 1719391,
                "title": "java-hashmap-approach",
                "content": "# HashMap Approach\\n## Intuition\\nFrom the problem, we feel the need to have the frequency of the elements present in the given array.\\nAfter we have the frequency of elements, we can scan through the map\\'s keys to learn about the frequency of the key and get information about the presence of its consecutive elements in the map.\\n\\n## Algorithm\\nWe will follow the following steps to solve the problem:\\n**Step 1:** We will use a hashmap to store the frequency of the elements in the given array.\\n**Step 2:** Traverse through the keys of the map.\\n**Step 3:** For every key of the map, we check if the frequency of the current key is equal to one, and the consecutive numbers to the given key are not present in the map.\\n**Step 4:** If the above conditions are satisfied, we add the current key into the ans list.\\n\\n## Visualisation\\nConsider an example, nums = [10, 6, 5, 8, 5]\\nThe HashMap will look like\\n![image](https://assets.leetcode.com/users/images/1e9673bb-b223-4116-8ff0-a4a695b13b30_1643132635.9604485.png)\\n\\nIterating through the map\\n![image](https://assets.leetcode.com/users/images/7522c902-4655-4d31-a62b-46bc7c0ae76c_1643133463.997268.png)\\n![image](https://assets.leetcode.com/users/images/fe1b68f2-7081-46d2-ad19-e556fbed0c59_1643133589.7946994.png)\\n![image](https://assets.leetcode.com/users/images/ae967fa9-4ec0-4a21-b06e-90686129d99d_1643133663.6053195.png)\\n![image](https://assets.leetcode.com/users/images/5e662b01-417c-4d62-a601-9521fa6ca059_1643133767.9396262.png)\\n\\nFinal ans = [10, 8]\\n\\n## Implementation\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n\\t\\tfor (int num : nums) {\\n            if (map.get(num) == 1 && !map.containsKey(num + 1) && !map.containsKey(num - 1)) {\\n                ans.add(num);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n## Complexity Analysis\\n### Space Complexity\\nWe use a HashMap in our solution, giving us a **O(N)** space complexity.\\n\\n### Time Complexity\\nWe traverse the given array once, taking O(N) time.\\nThen, we traverse the keys of the map; in the worst case, if all the elements in the array are distinct, it takes O(N) time.\\nHence, the resulting time complexity is **O(N)**\\n\\n## Curiosity Question\\n**Why do we traverse the keys of the map rather than traverse the array again?**\\nSuppose there are ten duplicate elements present in the array, then we will have to traverse through ten elements of the array.\\nInstead, if we traverse through the keys of the map, we will have to traverse only one single entry of the map.\\nHence, Traversing through the keys of the map is an optimised way to solve the problem.\\n\\n**Happy Coding!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n\\t\\tfor (int num : nums) {\\n            if (map.get(num) == 1 && !map.containsKey(num + 1) && !map.containsKey(num - 1)) {\\n                ans.add(num);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716964,
                "title": "java-hashmap-and-sorting-approaches-easy-to-understand",
                "content": "# SOLUTION-1 (Using Sorting)\\n## TC : O(nlogn)  SC : O(1)\\n```\\npublic List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0;i < nums.length;i++){\\n            if(i - 1 >= 0 && ( nums[i - 1] + 1 == nums[i] || nums[i - 1] == nums[i])){\\n                continue;\\n            }\\n            \\n            if(i + 1 <= nums.length - 1 && (nums[i + 1] == nums[i] + 1 || nums[i + 1] == nums[i])){\\n                continue;\\n            }\\n            \\n            ans.add(nums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n# SOLUTION-2 (Using HashMap)\\n## TC : O(n)   SC : O(n)\\n\\n```\\npublic List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n                map.put(nums[i],map.get(nums[i]) + 1);\\n            else\\n                map.put(nums[i],1);\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0;i < nums.length;i++){\\n            if(map.get(nums[i]) > 1 || map.containsKey(nums[i] + 1) || map.containsKey(nums[i] - 1))\\n                continue;\\n            \\n            ans.add(nums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0;i < nums.length;i++){\\n            if(i - 1 >= 0 && ( nums[i - 1] + 1 == nums[i] || nums[i - 1] == nums[i])){\\n                continue;\\n            }\\n            \\n            if(i + 1 <= nums.length - 1 && (nums[i + 1] == nums[i] + 1 || nums[i + 1] == nums[i])){\\n                continue;\\n            }\\n            \\n            ans.add(nums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\npublic List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0;i < nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n                map.put(nums[i],map.get(nums[i]) + 1);\\n            else\\n                map.put(nums[i],1);\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = 0;i < nums.length;i++){\\n            if(map.get(nums[i]) > 1 || map.containsKey(nums[i] + 1) || map.containsKey(nums[i] - 1))\\n                continue;\\n            \\n            ans.add(nums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1716024,
                "title": "c-python-easy-to-understand-o-n-simple-clean-explained",
                "content": "### Approach:\\nHashmaps are the most convenient way since we are dealing with frequencies of more than one element. The definition of a lonely number `x` requires us to check:\\n1. the presence of `x - 1` and `x + 1`  -> frequency of `x - 1` and `x + 1` = 0\\n2. whether frequency of `x` in the array to be **exactly 1**.\\n\\nHence, the steps are as follows:\\n- Record frequencies of all the elements in the array\\n- Iterate through the array and check for the conditions 1 and 2 above.\\n- If condition is met, we append it to the result array\\n\\n#### C++ Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int, int> freq;\\n        vector<int> lonelies;\\n\\t\\t\\n        for (int i = 0; i < nums.size(); i++) {\\n            freq[nums[i]]++;\\n        }\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (freq[nums[i] - 1] == 0 && freq[nums[i]] == 1 && freq[nums[i] + 1] == 0) {\\n                lonelies.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return lonelies;\\n    }\\n};\\n```\\n\\n#### Python Solution\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        freq = dict()\\n        result = []\\n        \\n        for n in nums:\\n            freq[n] = freq.get(n, 0) + 1\\n            \\n        for n in nums:\\n            if freq.get(n - 1, 0) == 0 and freq.get(n, 0) == 1 and freq.get(n + 1, 0) == 0:\\n                result.append(n)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int, int> freq;\\n        vector<int> lonelies;\\n\\t\\t\\n        for (int i = 0; i < nums.size(); i++) {\\n            freq[nums[i]]++;\\n        }\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (freq[nums[i] - 1] == 0 && freq[nums[i]] == 1 && freq[nums[i] + 1] == 0) {\\n                lonelies.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return lonelies;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        freq = dict()\\n        result = []\\n        \\n        for n in nums:\\n            freq[n] = freq.get(n, 0) + 1\\n            \\n        for n in nums:\\n            if freq.get(n - 1, 0) == 0 and freq.get(n, 0) == 1 and freq.get(n + 1, 0) == 0:\\n                result.append(n)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715253,
                "title": "hashing-o-n-time-complexity-easy-cpp-code",
                "content": "/* The basic idea was to create a frequency count of each element , so from this step it helped me to eliminate two things first the elements which were repeating , and second the elements x+1 and x-1 . Then they are stored in a different array , now I have the actual array which is following the above conditon of lonely array. Now its very simple we just have to check whether any adjacent elements are still not holding those condition if not they are the elements to be shown.\\n*/\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int , int > mp;\\n        \\n        for ( auto i : nums) mp[i]++;\\n        \\n        vector <int> a , b;\\n        \\n       for ( int i = 0 ; i < nums.size() ; i++){\\n           if (mp[nums[i]] == 1 and mp[nums[i]-1]==0 and mp[nums[i]+1] == 0)\\n               a.push_back(nums[i]);\\n       }\\n        \\n       for ( int i = 0 ; i < a.size() ; i++){\\n           if ( i == 0 ){\\n               if ( a.size() > 1 and a[i+1] != a[i]-1 )\\n                   b.push_back(a[i]);\\n               else return a;\\n           }\\n           \\n           else if ( i == a.size() - 1){\\n               if ( a.size()>1 and a[i-1]+1 != a[i] )\\n                   b.push_back(a[i]);\\n               else return a;\\n           }\\n           \\n          else if ( a[i-1] +1 != a[i] and a[i] != a[i+1]-1)\\n               b.push_back(a[i]);\\n       }\\n        \\n      \\n        \\n    \\n    return b;\\n    }\\n    \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int , int > mp;\\n        \\n        for ( auto i : nums) mp[i]++;\\n        \\n        vector <int> a , b;\\n        \\n       for ( int i = 0 ; i < nums.size() ; i++){\\n           if (mp[nums[i]] == 1 and mp[nums[i]-1]==0 and mp[nums[i]+1] == 0)\\n               a.push_back(nums[i]);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1714619,
                "title": "c-counter",
                "content": "```\\npublic class Solution {\\n    public IList<int> FindLonely(int[] nums) {\\n        var res = new List<int>();\\n        var map = new Dictionary<int, int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            map[nums[i]] = map.GetValueOrDefault(nums[i], 0) + 1;\\n        }\\n\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (map[nums[i]] == 1 && !(map.ContainsKey(nums[i] + 1) || map.ContainsKey(nums[i] - 1))) {\\n                res.Add(nums[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindLonely(int[] nums) {\\n        var res = new List<int>();\\n        var map = new Dictionary<int, int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            map[nums[i]] = map.GetValueOrDefault(nums[i], 0) + 1;\\n        }\\n\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (map[nums[i]] == 1 && !(map.ContainsKey(nums[i] + 1) || map.ContainsKey(nums[i] - 1))) {\\n                res.Add(nums[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712243,
                "title": "c-hashmap-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) mp[nums[i]]++;\\n        \\n        vector<int> ans;\\n        \\n        for(int i=0; i<nums.size();i++)\\n            if((!mp.count(nums[i]+1) && !mp.count(nums[i]-1) ) && mp[nums[i]]==1)\\n                    ans.push_back(nums[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) mp[nums[i]]++;\\n        \\n        vector<int> ans;\\n        \\n        for(int i=0; i<nums.size();i++)\\n            if((!mp.count(nums[i]+1) && !mp.count(nums[i]-1) ) && mp[nums[i]]==1)\\n                    ans.push_back(nums[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711957,
                "title": "c-2-line-map-very-easy-solution",
                "content": "Please upvote if you find my solution helpful!!\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> ans;\\n         unordered_map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;   //storing frequency of elements\\n        }\\n        \\n         for(int i=0;i<n;i++){\\n\\t\\t //simply checking the given condition in question \\n           if(mp[nums[i]]==1 && mp[nums[i]-1]==0 && mp[nums[i]+1]==0 ){\\n              ans.push_back(nums[i]);\\n           }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> ans;\\n         unordered_map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;   //storing frequency of elements\\n        }\\n        \\n         for(int i=0;i<n;i++){\\n\\t\\t //simply checking the given condition in question \\n           if(mp[nums[i]]==1 && mp[nums[i]-1]==0 && mp[nums[i]+1]==0 ){\\n              ans.push_back(nums[i]);\\n           }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711278,
                "title": "python-solution-using-sorting-counter",
                "content": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        freq_count = Counter(nums)\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n):\\n            val = nums[i]\\n            if freq_count[val] == 1 and (i == 0 or nums[i-1] != val-1) and (i == n-1 or nums[i+1] != val+1):\\n                ans.append(val)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        freq_count = Counter(nums)\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n):\\n            val = nums[i]\\n            if freq_count[val] == 1 and (i == 0 or nums[i-1] != val-1) and (i == n-1 or nums[i+1] != val+1):\\n                ans.append(val)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711274,
                "title": "c-easy-code-with-inline-explanation-o-nlogn",
                "content": "```\\nvector<int> findLonely(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>vec;\\n        for(int i=0;i<nums.size();i++){\\n            while(i+1<n && nums[i]==nums[i+1])i++;     //skip same value element\\n            int flag1=1,flag2=1;                       //set flags \\n            \\n            if(i!=0 && (nums[i-1]==nums[i] || nums[i-1]==nums[i]-1)) flag1=0; \\n            if(i!=n-1 &&  nums[i]+1==nums[i+1]) flag2=0; //reset flag if condition violet\\n            if(flag1 && flag2) vec.push_back(nums[i]);  //lonely element if both condition followed\\n        }\\n        return vec;\\n    }\\n```\\n\\nUpvote if you appreciate :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> findLonely(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>vec;\\n        for(int i=0;i<nums.size();i++){\\n            while(i+1<n && nums[i]==nums[i+1])i++;     //skip same value element\\n            int flag1=1,flag2=1;                       //set flags \\n            \\n            if(i!=0 && (nums[i-1]==nums[i] || nums[i-1]==nums[i]-1)) flag1=0; \\n            if(i!=n-1 &&  nums[i]+1==nums[i+1]) flag2=0; //reset flag if condition violet\\n            if(flag1 && flag2) vec.push_back(nums[i]);  //lonely element if both condition followed\\n        }\\n        return vec;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711230,
                "title": "c-hash-map-o-n",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Hash Map\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-277/problems/find-all-lonely-numbers-in-the-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(U) where U is the number of unique elements in `A`\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& A) {\\n        unordered_map<int, int> m;\\n        for (int n : A) m[n]++;\\n        vector<int> ans;\\n        for (int n : A) {\\n            if (m[n] == 1 && m.count(n + 1) == 0 && m.count(n - 1) == 0) {\\n                ans.push_back(n);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-277/problems/find-all-lonely-numbers-in-the-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(U) where U is the number of unique elements in `A`\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& A) {\\n        unordered_map<int, int> m;\\n        for (int n : A) m[n]++;\\n        vector<int> ans;\\n        for (int n : A) {\\n            if (m[n] == 1 && m.count(n + 1) == 0 && m.count(n - 1) == 0) {\\n                ans.push_back(n);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954545,
                "title": "c-using-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>v;\\n       unordered_map<int,int>mp;\\n       for(auto it:nums){\\n           mp[it]++;\\n       }\\n       for(int i=0;i<nums.size();i++){\\n           if(mp.find(nums[i]+1)==mp.end() && mp.find(nums[i]-1)==mp.end() && mp[nums[i]]<2){\\n            v.push_back(nums[i]);\\n           }\\n       }\\n       return v; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>v;\\n       unordered_map<int,int>mp;\\n       for(auto it:nums){\\n           mp[it]++;\\n       }\\n       for(int i=0;i<nums.size();i++){\\n           if(mp.find(nums[i]+1)==mp.end() && mp.find(nums[i]-1)==mp.end() && mp[nums[i]]<2){\\n            v.push_back(nums[i]);\\n           }\\n       }\\n       return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773652,
                "title": "python-easy-solution-hash-table",
                "content": "# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        res=[]\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n        for i in nums:\\n            if dic[i]==1:\\n                if (i-1 not in dic) and (i+1 not in dic):\\n                    res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        res=[]\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n        for i in nums:\\n            if dic[i]==1:\\n                if (i-1 not in dic) and (i+1 not in dic):\\n                    res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642388,
                "title": "c-easy-to-grasp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int freq[1000002] = {0};\\n        vector<int> ans;\\n        for(auto it : nums){\\n            freq[it]++;\\n        }\\n        for(auto it : nums){\\n            if(freq[it] == 1 && (!it || !freq[it-1]) && !freq[it+1]){\\n                ans.push_back(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int freq[1000002] = {0};\\n        vector<int> ans;\\n        for(auto it : nums){\\n            freq[it]++;\\n        }\\n        for(auto it : nums){\\n            if(freq[it] == 1 && (!it || !freq[it-1]) && !freq[it+1]){\\n                ans.push_back(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613525,
                "title": "python-elegant-short-hash-map-counter",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        count = Counter(nums)\\n        return [num for num, cnt in count.items() if cnt == 1 and count[num - 1] == count[num + 1] == 0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        count = Counter(nums)\\n        return [num for num, cnt in count.items() if cnt == 1 and count[num - 1] == count[num + 1] == 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573877,
                "title": "beginners-friendly",
                "content": "\\n# Complexity \\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> ls= new ArrayList<>();\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        for(int i:nums) map.put(i, map.getOrDefault(i,0)+1);\\n\\n        for(int j: nums){\\n            if(map.containsKey(j-1) || map.containsKey(j+1) || map.get(j)>1) continue;\\n            else ls.add(j);\\n        }\\n\\n        return ls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> ls= new ArrayList<>();\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        for(int i:nums) map.put(i, map.getOrDefault(i,0)+1);\\n\\n        for(int j: nums){\\n            if(map.containsKey(j-1) || map.containsKey(j+1) || map.get(j)>1) continue;\\n            else ls.add(j);\\n        }\\n\\n        return ls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464928,
                "title": "easy-python-solution",
                "content": "# Intuition\\nThe code counts the frequency of integers in the input list using the collections.Counter() function. It then checks if an integer occurs only once in the input list and does not have adjacent integers. The integers satisfying these conditions are added to the output list.\\n\\n# Approach\\nThe approach taken in the code is to first count the frequency of integers in the input list, and then iterate over the list to check for the required conditions. The check involves looking up the frequency of each integer and verifying that it appears only once and that its neighboring integers do not appear in the list. If the integer satisfies these conditions, it is added to the output list.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        numCount = collections.Counter(nums)\\n        ans = []\\n\\n        for i in nums:\\n            if numCount[i] == 1 and i - 1 not in numCount and i + 1 not in numCount:\\n                ans.append(i)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        numCount = collections.Counter(nums)\\n        ans = []\\n\\n        for i in nums:\\n            if numCount[i] == 1 and i - 1 not in numCount and i + 1 not in numCount:\\n                ans.append(i)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209443,
                "title": "simplest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> res ; \\n        unordered_map<int,int> m ;\\n        for(auto x:nums)\\n        m[x]++ ; \\n        for(auto x:m)\\n        {\\n            if(x.second==1 && m.find(x.first+1)==m.end() && m.find(x.first-1)==m.end())\\n            res.push_back(x.first);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> res ; \\n        unordered_map<int,int> m ;\\n        for(auto x:nums)\\n        m[x]++ ; \\n        for(auto x:m)\\n        {\\n            if(x.second==1 && m.find(x.first+1)==m.end() && m.find(x.first-1)==m.end())\\n            res.push_back(x.first);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973198,
                "title": "javascript-solution-fasted-100-memory-73",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nlet findLonely = function(nums) {\\n    let map = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!map.has(nums[i])) {\\n            map.set(nums[i], 1);\\n        } else {\\n            map.set(nums[i], map.get(nums[i]) + 1);\\n        }\\n    }\\n    let result = [];\\n    for (let item of map) {\\n        if (item[1] === 1) {\\n            if (!map.has(item[0] - 1) && !map.has(item[0] + 1)) {\\n                result.push(item[0]);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nlet findLonely = function(nums) {\\n    let map = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!map.has(nums[i])) {\\n            map.set(nums[i], 1);\\n        } else {\\n            map.set(nums[i], map.get(nums[i]) + 1);\\n        }\\n    }\\n    let result = [];\\n    for (let item of map) {\\n        if (item[1] === 1) {\\n            if (!map.has(item[0] - 1) && !map.has(item[0] + 1)) {\\n                result.push(item[0]);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2805998,
                "title": "easy-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        List<Integer> l1=new ArrayList<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(!hm.containsKey(nums[i])){\\n                hm.put(nums[i],1);\\n            }\\n            else{\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n    if(hm.get(nums[i])==1 && !hm.containsKey(nums[i]-1) && !hm.containsKey(nums[i]+1)){\\n                l1.add(nums[i]);\\n            }\\n        }\\n        return l1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        List<Integer> l1=new ArrayList<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(!hm.containsKey(nums[i])){\\n                hm.put(nums[i],1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2563431,
                "title": "cpp-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        int n=nums.size(),i;\\n        unordered_map<int,int>m;\\n        for(i=0;i<n;i++)\\n            m[nums[i]]++;\\n        for(i=0;i<n;i++){\\n            if(m.find(nums[i]+1)==m.end() && m.find(nums[i]-1)==m.end() && m[nums[i]]==1)\\n                ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        int n=nums.size(),i;\\n        unordered_map<int,int>m;\\n        for(i=0;i<n;i++)\\n            m[nums[i]]++;\\n        for(i=0;i<n;i++){\\n            if(m.find(nums[i]+1)==m.end() && m.find(nums[i]-1)==m.end() && m[nums[i]]==1)\\n                ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557027,
                "title": "c-two-methods-space-optimised",
                "content": "```\\n\\n// 1. Using Mapping , SC : O(n) , TC : O(n)\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n          vector<int> ans;\\n        unordered_map<int, int> mp;\\n        \\n        for(auto i : nums)\\n            mp[i]++;\\n        \\n        for(auto i : mp)\\n        {\\n            if(i.second == 1)\\n            {\\n                if(mp.find(i.first-1) == mp.end() && mp.find(i.first+1) == mp.end())\\n                    ans.push_back(i.first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n// 2. Without Maping  , SC : O(1)  , TC : (O(NLog(n))\\n\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        sort(nums.begin() , nums.end());\\n        \\n        nums.insert(nums.begin() , -100);\\n        nums.push_back(10000000);\\n        \\n        for(int i = 1 ; i <nums.size()-1 ; i++)\\n        {\\n            if(nums[i]-nums[i-1] > 1 && nums[i+1]-nums[i] > 1)\\n                ans.push_back(nums[i]);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\n// 1. Using Mapping , SC : O(n) , TC : O(n)\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n          vector<int> ans;\\n        unordered_map<int, int> mp;\\n        \\n        for(auto i : nums)\\n            mp[i]++;\\n        \\n        for(auto i : mp)\\n        {\\n            if(i.second == 1)\\n            {\\n                if(mp.find(i.first-1) == mp.end() && mp.find(i.first+1) == mp.end())\\n                    ans.push_back(i.first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n// 2. Without Maping  , SC : O(1)  , TC : (O(NLog(n))\\n\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        sort(nums.begin() , nums.end());\\n        \\n        nums.insert(nums.begin() , -100);\\n        nums.push_back(10000000);\\n        \\n        for(int i = 1 ; i <nums.size()-1 ; i++)\\n        {\\n            if(nums[i]-nums[i-1] > 1 && nums[i+1]-nums[i] > 1)\\n                ans.push_back(nums[i]);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555916,
                "title": "beginner-s-level-solution-python",
                "content": "Any Suggestions or Doubts?\\nPut in comments..\\nPlease **UpVote**, if you like the solution **:)**\\n```\\n    def findLonely(self, nums):\\n        ans, dic = [], {}\\n        for n in nums:\\n            if n not in dic: dic[n] = 1\\n            else: dic[n] += 1\\n        for n in dic:\\n            if dic[n] == 1 and n-1 not in dic and n+1 not in dic:\\n                ans.append(n)\\n        return ans\\n```\\n**UpVote :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def findLonely(self, nums):\\n        ans, dic = [], {}\\n        for n in nums:\\n            if n not in dic: dic[n] = 1\\n            else: dic[n] += 1\\n        for n in dic:\\n            if dic[n] == 1 and n-1 not in dic and n+1 not in dic:\\n                ans.append(n)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2263618,
                "title": "c-solution-using-hashmap",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        int i,s;\\n        s=nums.size();\\n        map <int,int >m;\\n        vector <int> v;\\n        for(i=0;i<s;i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it:m)\\n        {        \\n            if(it.second==1)\\n            {          \\n                auto iprev=m.find(it.first-1);\\n                auto inext=m.find(it.first+1);\\n                if(iprev==m.end() && inext==m.end())\\n                    v.push_back(it.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        int i,s;\\n        s=nums.size();\\n        map <int,int >m;\\n        vector <int> v;\\n        for(i=0;i<s;i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it:m)\\n        {        \\n            if(it.second==1)\\n            {          \\n                auto iprev=m.find(it.first-1);\\n                auto inext=m.find(it.first+1);\\n                if(iprev==m.end() && inext==m.end())\\n                    v.push_back(it.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238029,
                "title": "c-o-nlogn-time-and-o-n-space-solution-using-binary-search",
                "content": "Please do **upvote**\\n\\n```\\nclass Solution {\\nprivate:\\n    bool binSrch(vector<int> &arr, int find) {\\n        int l = 0, r = arr.size() - 1;\\n        while (l <= r) {\\n            int mid = l + (r - l)/2;\\n            if (find == arr[mid]) return true;\\n            if (find < arr[mid]) r = mid - 1;\\n            if (find > arr[mid]) l = mid + 1;\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<int> findLonely(vector<int> &nums) {\\n        vector<int> res;\\n        unordered_map<int, int> mp;\\n        for (int num : nums) mp[num]++;\\n        sort(nums.begin(), nums.end());\\n        for (int num : nums) {\\n            if (mp[num] == 1 && !binSrch(nums, num+1) && !binSrch(nums, num-1)) {\\n                res.push_back(num);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool binSrch(vector<int> &arr, int find) {\\n        int l = 0, r = arr.size() - 1;\\n        while (l <= r) {\\n            int mid = l + (r - l)/2;\\n            if (find == arr[mid]) return true;\\n            if (find < arr[mid]) r = mid - 1;\\n            if (find > arr[mid]) l = mid + 1;\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<int> findLonely(vector<int> &nums) {\\n        vector<int> res;\\n        unordered_map<int, int> mp;\\n        for (int num : nums) mp[num]++;\\n        sort(nums.begin(), nums.end());\\n        for (int num : nums) {\\n            if (mp[num] == 1 && !binSrch(nums, num+1) && !binSrch(nums, num-1)) {\\n                res.push_back(num);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941747,
                "title": "python-easy-solution-100-faster",
                "content": "\\'\\'\\'\\n\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        \\n        d={}\\n        l1=[]\\n        for i in nums:  \\n            if i not in d:\\n                d[i]=1\\n            else:                       # count the repetitive elements\\n                d[i]+=1\\n                \\n        for key,value in d.items():\\n            if value==1 :                           #if count is 1 and key-1 and key+1 is not present then append key\\n                if key-1 not in d and key+1 not in d:\\n                    l1.append(key)\\n        return l1\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        \\n        d={}\\n        l1=[]\\n        for i in nums:  \\n            if i not in d:\\n                d[i]=1\\n            else:                       # count the repetitive elements\\n                d[i]+=1\\n                \\n        for key,value in d.items():\\n            if value==1 :                           #if count is 1 and key-1 and key+1 is not present then append key\\n                if key-1 not in d and key+1 not in d:\\n                    l1.append(key)\\n        return l1\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1808469,
                "title": "simple-c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map <int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]]++;\\n        vector <int> ans;\\n        for(auto &it:mp)\\n            if(it.second == 1 && !mp.count(it.first-1) && !mp.count(it.first+1))\\n                ans.push_back(it.first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map <int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]]++;\\n        vector <int> ans;\\n        for(auto &it:mp)\\n            if(it.second == 1 && !mp.count(it.first-1) && !mp.count(it.first+1))\\n                ans.push_back(it.first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799589,
                "title": "python-clean-and-easy-code-simple-if-else",
                "content": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        if(len(nums)==1):return nums\\n        nums.sort()\\n        print(nums)\\n        res = []\\n        for i in range(len(nums)):\\n                if i == 0 and nums[i] != nums[i+1] and nums[i]+1 != nums[i+1]:\\n                    res.append(nums[i])\\n                \\n                if i == len(nums) - 1 and nums[i] != nums[i-1] and nums[i] != nums[i-1]+1:\\n                    res.append(nums[i])\\n\\n                if(0<i<len(nums)-1 and nums[i] != nums[i+1] and nums[i] != nums[i-1]  and nums[i] != nums[i+1]-1 and nums[i] != nums[i-1]+1):\\n                    res.append(nums[i])\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        if(len(nums)==1):return nums\\n        nums.sort()\\n        print(nums)\\n        res = []\\n        for i in range(len(nums)):\\n                if i == 0 and nums[i] != nums[i+1] and nums[i]+1 != nums[i+1]:\\n                    res.append(nums[i])\\n                \\n                if i == len(nums) - 1 and nums[i] != nums[i-1] and nums[i] != nums[i-1]+1:\\n                    res.append(nums[i])\\n\\n                if(0<i<len(nums)-1 and nums[i] != nums[i+1] and nums[i] != nums[i-1]  and nums[i] != nums[i+1]-1 and nums[i] != nums[i-1]+1):\\n                    res.append(nums[i])\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781304,
                "title": "java-o-n-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> ans = new ArrayList();\\n        HashMap<Integer, Integer> s = new HashMap();\\n        for (int i: nums) {\\n            s.put(i, s.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for (int i: nums) {\\n            if (s.get(i) == 1 && !s.containsKey(i+1) && !s.containsKey(i-1)) ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> ans = new ArrayList();\\n        HashMap<Integer, Integer> s = new HashMap();\\n        for (int i: nums) {\\n            s.put(i, s.getOrDefault(i, 0) + 1);\\n        }\\n        \\n        for (int i: nums) {\\n            if (s.get(i) == 1 && !s.containsKey(i+1) && !s.containsKey(i-1)) ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764024,
                "title": "cpp-hashmap-easy-understanding-4-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n        map<int,int>m;\\n        for(auto x : nums)m[x]++;\\n        vector<int>ans;\\n        for(auto x : m)if(x.second == 1 and m.find(x.first+1)==m.end() and m.find(x.first-1)==m.end())ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n        map<int,int>m;\\n        for(auto x : nums)m[x]++;\\n        vector<int>ans;\\n        for(auto x : m)if(x.second == 1 and m.find(x.first+1)==m.end() and m.find(x.first-1)==m.end())ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760186,
                "title": "python-easy-solution-with-explanation",
                "content": "Here in this ques we don\\'t have to think much and just have to apply basic understanding of concepts and follow the ques as it is told .\\n\\nSo first we sort the array to make things easier and save our time from again and again checking for conditions in our array .\\n\\nThen we use the concept of sliding window , to check for 3 array values at a time the current one and compare it with the previous and next value at once and follow the conditions told in the ques.\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        if(len(nums)<=1):\\n            return(nums)\\n        \\n        nums.sort()\\n        l=[]\\n        for i in range(len(nums)):\\n            if(i==0):\\n                if (nums[i]!=nums[i+1]) and (nums[i+1]!=(nums[i]+1)):\\n                    l.append(nums[i])\\n                \\n            elif(i==len(nums)-1):\\n                if (nums[i]!=nums[i-1]) and (nums[i-1]!=(nums[i]-1)):\\n                    l.append(nums[i])\\n            \\n            else:\\n                if (nums[i]!=nums[i+1]) and (nums[i+1]!=(nums[i]+1)) and (nums[i]!=nums[i-1]) and (nums[i-1]!=(nums[i]-1)):\\n                    l.append(nums[i])\\n        \\n        return(l)\\n```\\nIf u understood the code then plz....UPVOTE....Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        if(len(nums)<=1):\\n            return(nums)\\n        \\n        nums.sort()\\n        l=[]\\n        for i in range(len(nums)):\\n            if(i==0):\\n                if (nums[i]!=nums[i+1]) and (nums[i+1]!=(nums[i]+1)):\\n                    l.append(nums[i])\\n                \\n            elif(i==len(nums)-1):\\n                if (nums[i]!=nums[i-1]) and (nums[i-1]!=(nums[i]-1)):\\n                    l.append(nums[i])\\n            \\n            else:\\n                if (nums[i]!=nums[i+1]) and (nums[i+1]!=(nums[i]+1)) and (nums[i]!=nums[i-1]) and (nums[i-1]!=(nums[i]-1)):\\n                    l.append(nums[i])\\n        \\n        return(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755290,
                "title": "c-easy-solution-hashing",
                "content": "First take count of all elements using hashing and then check for adjacent numbers and check if it appears only once.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int, int> dict;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (dict.find(nums[i]) != dict.end()) {\\n                dict[nums[i]]++;\\n            }\\n            else {\\n                dict[nums[i]] = 1;\\n            }\\n        } \\n        for (auto [a, b] : dict) {\\n            if (dict.find(a+1) == dict.end() && dict.find(a-1) == dict.end() && b == 1) //check for adjacent numbers using a+1 and a-1 and check if it appears only once\\n                ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int, int> dict;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (dict.find(nums[i]) != dict.end()) {\\n                dict[nums[i]]++;\\n            }\\n            else {\\n                dict[nums[i]] = 1;\\n            }\\n        } \\n        for (auto [a, b] : dict) {\\n            if (dict.find(a+1) == dict.end() && dict.find(a-1) == dict.end() && b == 1) //check for adjacent numbers using a+1 and a-1 and check if it appears only once\\n                ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751897,
                "title": "find-all-lonely-numbers-in-the-array-unordered-map-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++; //storing in map with frequency\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.second==1)  //frequency must be 1\\n            {\\n                int x=it.first-1;  \\n                int y=it.first+1;\\n                \\n                if(mp.find(x)==mp.end() && mp.find(y)==mp.end())\\n                {\\n               \\n                    ans.push_back(it.first);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++; //storing in map with frequency\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.second==1)  //frequency must be 1\\n            {\\n                int x=it.first-1;  \\n                int y=it.first+1;\\n                \\n                if(mp.find(x)==mp.end() && mp.find(y)==mp.end())\\n                {\\n               \\n                    ans.push_back(it.first);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746105,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        c = collections.Counter(nums)\\n        s = set(nums)\\n        ans = []\\n        for i in s:\\n            if c[i] == 1 and i+1 not in s and i-1 not in s:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        c = collections.Counter(nums)\\n        s = set(nums)\\n        ans = []\\n        for i in s:\\n            if c[i] == 1 and i+1 not in s and i-1 not in s:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743161,
                "title": "2150-python-fast-hashmap-and-if-check",
                "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        \\n        numbers = []\\n        \\n        seen = {}\\n        \\n        for num in nums:\\n            seen[num] = 1 + seen.get(num,0) #Get appearance counter\\n            \\n            \\n        for val in nums:\\n            \\n            if (val - 1) not in seen and (val + 1) not in seen and seen[val] == 1: #Must appear once.\\n                numbers.append(val)\\n                \\n        return numbers\\n    \\n    \\n        #Time: O(n)\\n        #Space: O(n)",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        \\n        numbers = []\\n        \\n        seen = {}",
                "codeTag": "Java"
            },
            {
                "id": 1739526,
                "title": "java-solution-in-2-lines",
                "content": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        var freqMap = Arrays.stream(nums).boxed()\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\\n\\n        return Arrays.stream(nums).boxed().filter(e -> \\n                freqMap.get(e) == 1 && !freqMap.containsKey(e+1) && !freqMap.containsKey(e-1))\\n            .collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        var freqMap = Arrays.stream(nums).boxed()\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\\n\\n        return Arrays.stream(nums).boxed().filter(e -> \\n                freqMap.get(e) == 1 && !freqMap.containsKey(e+1) && !freqMap.containsKey(e-1))\\n            .collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739440,
                "title": "typescript-readable-solution-with-code-documentation",
                "content": "```\\n// Leetcode: https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/\\n\\ntype map = {\\n    [key: number]: number;\\n};\\n\\nconst findLonely = (nums: Array<number>): Array<number> => {\\n    let lonelyNumbers: Array<number> = [];\\n    let map: map = {};\\n\\n    for (let i: number = 0; i < nums.length; i++) {\\n        map[nums[i]] ? (map[nums[i]] += 1) : (map[nums[i]] = 1);\\n    }\\n\\n    /*\\n        LOOP THROUGH MAP AND CHECK FOLLOWING CONDITIONS\\n            1) IF NUMBER HAS NO ADJACENT NUMBERS PRESENT IN THE MAP\\n            2) IF NUMBER APPREARS EXACTLY ONCE IN THE MAP\\n    */\\n    for (let [key, value] of Object.entries(map)) {\\n        const next = Number(key) + 1;\\n        const previous = Number(key) - 1;\\n        if (!map.hasOwnProperty(next) && !map.hasOwnProperty(previous) && value === 1) {\\n            lonelyNumbers.push(Number(key));\\n        }\\n    }\\n\\n    return lonelyNumbers;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\n// Leetcode: https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/\\n\\ntype map = {\\n    [key: number]: number;\\n};\\n\\nconst findLonely = (nums: Array<number>): Array<number> => {\\n    let lonelyNumbers: Array<number> = [];\\n    let map: map = {};\\n\\n    for (let i: number = 0; i < nums.length; i++) {\\n        map[nums[i]] ? (map[nums[i]] += 1) : (map[nums[i]] = 1);\\n    }\\n\\n    /*\\n        LOOP THROUGH MAP AND CHECK FOLLOWING CONDITIONS\\n            1) IF NUMBER HAS NO ADJACENT NUMBERS PRESENT IN THE MAP\\n            2) IF NUMBER APPREARS EXACTLY ONCE IN THE MAP\\n    */\\n    for (let [key, value] of Object.entries(map)) {\\n        const next = Number(key) + 1;\\n        const previous = Number(key) - 1;\\n        if (!map.hasOwnProperty(next) && !map.hasOwnProperty(previous) && value === 1) {\\n            lonelyNumbers.push(Number(key));\\n        }\\n    }\\n\\n    return lonelyNumbers;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729151,
                "title": "java-simple-solution-hashmap-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        List<Integer> res = new ArrayList<>();\\n\\n        for(int i : nums)map.put(i,map.getOrDefault(i,0)+1);\\n        for(int i : nums){\\n            if(map.get(i) == 1 && map.containsKey(i+1) == false && map.containsKey(i-1) == false){\\n                res.add(i);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n}\\n```\\n**O(n) : Time\\n\\tO(n) : Space**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        List<Integer> res = new ArrayList<>();\\n\\n        for(int i : nums)map.put(i,map.getOrDefault(i,0)+1);\\n        for(int i : nums){\\n            if(map.get(i) == 1 && map.containsKey(i+1) == false && map.containsKey(i-1) == false){\\n                res.add(i);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724491,
                "title": "python-easy-to-undestand-hash-map",
                "content": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n        count = {}\\n        for num in nums:\\n            if num in count:\\n                count[num] += 1\\n            else:\\n                count[num] = 1\\n            \\n        result = []\\n        for num in nums:\\n            if not count.get(num-1) and not count.get(num+1) and count.get(num, 0) < 2:\\n                result.append(num)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n        count = {}\\n        for num in nums:\\n            if num in count:\\n                count[num] += 1\\n            else:\\n                count[num] = 1\\n            \\n        result = []\\n        for num in nums:\\n            if not count.get(num-1) and not count.get(num+1) and count.get(num, 0) < 2:\\n                result.append(num)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723844,
                "title": "java-steps-broken-down-explained-short-linear-space-time-solution-hashmap",
                "content": "**Step I:**  We are going to use a hashmap to store the frequency of the elements in the given array.\\n**Step II:** Browse the map keys.\\n**Step III:** For each key on the map, we check whether the current key frequency is equal to one, and the consecutive numbers to the given key are not present in the map or not.\\n**Step IV:** If the above conditions are satisfied, we add the current key into the ans arraylist.\\n\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> ans=new ArrayList<>();\\n        if(ans==null || nums.length==0) return ans;\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n\\n        for(int x:map.keySet()){\\n            if(map.get(x)>1 || map.containsKey(x+1) || map.containsKey(x-1)) continue;\\n            else ans.add(x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> ans=new ArrayList<>();\\n        if(ans==null || nums.length==0) return ans;\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n\\n        for(int x:map.keySet()){\\n            if(map.get(x)>1 || map.containsKey(x+1) || map.containsKey(x-1)) continue;\\n            else ans.add(x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722205,
                "title": "c-simple-approach-without-extra-space",
                "content": "follow below steps:\\n1. sort the array\\n2. If element\\'s just above & just after element is not present, then that element is lonely element. just add it in answer array.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        //sort the array\\n        sort(nums.begin(), nums.end());\\n        //if element\\'s just above & just after element is not present\\n        //then that element is lonely element.\\n        for(int i=0; i<n; i++) {\\n            bool flag = true;\\n            if(i > 0  && (nums[i-1] + 1 == nums[i] || nums[i-1] == nums[i])) {\\n                flag = false;\\n            }\\n            if(i < n-1 && (nums[i] + 1 ==nums[i+1] || nums[i] == nums[i+1])) {\\n                flag = false;\\n            }\\n            if(flag) {\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        //sort the array\\n        sort(nums.begin(), nums.end());\\n        //if element\\'s just above & just after element is not present\\n        //then that element is lonely element.\\n        for(int i=0; i<n; i++) {\\n            bool flag = true;\\n            if(i > 0  && (nums[i-1] + 1 == nums[i] || nums[i-1] == nums[i])) {\\n                flag = false;\\n            }\\n            if(i < n-1 && (nums[i] + 1 ==nums[i+1] || nums[i] == nums[i+1])) {\\n                flag = false;\\n            }\\n            if(flag) {\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720359,
                "title": "cpp-easiest-solution",
                "content": "\\n```\\n\\tvector<int> findLonely(vector<int>& nums) {\\n\\t\\tmap<int, int> m;\\n        vector<int> res;\\n        for (int n : nums) ++m[n];\\n        for (const auto [n, cnt] : m)\\n            if (cnt == 1 && m.count(n + 1) == 0 && m.count(n - 1) == 0) res.push_back(n);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvector<int> findLonely(vector<int>& nums) {\\n\\t\\tmap<int, int> m;\\n        vector<int> res;\\n        for (int n : nums) ++m[n];\\n        for (const auto [n, cnt] : m)\\n            if (cnt == 1 && m.count(n + 1) == 0 && m.count(n - 1) == 0) res.push_back(n);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1718482,
                "title": "java-solution",
                "content": "```\\n\\n// O(N) Solution\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        int present[] = new int[1000_001];   // Creating a count array \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            present[nums[i]]++;     \\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        if(present[0]==1 && present[1]==0)\\n        {\\n            ans.add(0);\\n        }\\n        if(present[1000000]==1 && present[1000000-1]==0)\\n        {\\n            ans.add(1000000);\\n        }\\n        for(int i=1;i<present.length-1;i++)\\n        {\\n            if(present[i]==1 && present[i-1]==0 && present[i+1]==0)\\n            {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        int present[] = new int[1000_001];   // Creating a count array \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            present[nums[i]]++;     \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1717937,
                "title": "python3-runtime-2051ms-59-44-memory-38-4mb-53-48",
                "content": "We can do this by using a set also, but when we going to use the count in sets set.count(x) == 1 I think thats an O(n) operation, so I thought hashMap is better for this.\\nTimeComplex: O(N)\\nSpace: O(N)\\n```\\ndef lonelyNum(arrList):\\n\\thashMap = dict()\\n\\tres = list()\\n\\tfor i in arrList:\\n\\t\\thashMap[i] = 1 + hashMap.get(i, 0)\\n\\tfor key in hashMap:\\n\\t\\tif hashMap[key] == 1 and not key+1 in hashMap and not key-1 in hashMap:\\n\\t\\t\\tres.append(key)\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndef lonelyNum(arrList):\\n\\thashMap = dict()\\n\\tres = list()\\n\\tfor i in arrList:\\n\\t\\thashMap[i] = 1 + hashMap.get(i, 0)\\n\\tfor key in hashMap:\\n\\t\\tif hashMap[key] == 1 and not key+1 in hashMap and not key-1 in hashMap:\\n\\t\\t\\tres.append(key)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1716334,
                "title": "very-easy-map-based-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp.find(nums[i]+1)==mp.end() &&mp.find(nums[i]-1)==mp.end() &&mp[nums[i]]==1){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1716057,
                "title": "a-few-solutions",
                "content": "Use a map `m` to count each value `x` of the input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findLonely(A: IntArray): List<Int> {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1 + (m[x] ?: 0)\\n        return m.map{ (x, _) -> x }.filter{ m[it]!! == 1 && !m.contains(it - 1) && !m.contains(it + 1) }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findLonely = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1 + (m.get(x) || 0));\\n    return [...m].map(([x, _]) => x).filter(x => m.get(x) == 1 && !m.get(x - 1) && !m.get(x + 1));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findLonely(self, A: List[int]) -> List[int]:\\n        m = Counter(A)\\n        return [x for x in m.keys() if m[x] == 1 and x - 1 not in m and x + 1 not in m]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    VI findLonely(VI& A, Map m = {}, VI ans = {}) {\\n        for (auto x: A)\\n            ++m[x];\\n        for (auto [x, _]: m)\\n            if (m[x] == 1 && m.find(x - 1) == m.end() && m.find(x + 1) == m.end())\\n                ans.push_back(x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findLonely(A: IntArray): List<Int> {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1 + (m[x] ?: 0)\\n        return m.map{ (x, _) -> x }.filter{ m[it]!! == 1 && !m.contains(it - 1) && !m.contains(it + 1) }\\n    }\\n}\\n```\n```\\nlet findLonely = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1 + (m.get(x) || 0));\\n    return [...m].map(([x, _]) => x).filter(x => m.get(x) == 1 && !m.get(x - 1) && !m.get(x + 1));\\n};\\n```\n```\\nclass Solution:\\n    def findLonely(self, A: List[int]) -> List[int]:\\n        m = Counter(A)\\n        return [x for x in m.keys() if m[x] == 1 and x - 1 not in m and x + 1 not in m]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    VI findLonely(VI& A, Map m = {}, VI ans = {}) {\\n        for (auto x: A)\\n            ++m[x];\\n        for (auto [x, _]: m)\\n            if (m[x] == 1 && m.find(x - 1) == m.end() && m.find(x + 1) == m.end())\\n                ans.push_back(x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712339,
                "title": "c-map-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int>m ;\\n        vector<int> v;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n             m[nums[i]]++;\\n        }\\n        for (int i=0;i<nums.size();i++)\\n        {\\n             if (m[nums[i]]==1)\\n             {\\n                  if (m.find(nums[i]+1)==m.end() && m.find(nums[i]-1)==m.end())\\n                      v.push_back(nums[i]);\\n             }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int>m ;\\n        vector<int> v;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n             m[nums[i]]++;\\n        }\\n        for (int i=0;i<nums.size();i++)\\n        {\\n             if (m[nums[i]]==1)\\n             {\\n                  if (m.find(nums[i]+1)==m.end() && m.find(nums[i]-1)==m.end())\\n                      v.push_back(nums[i]);\\n             }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712169,
                "title": "o-n-python-solution",
                "content": "```\\ndef findLonely(self, nums: List[int]) -> List[int]:\\n        dic = {}\\n        res = []\\n        for i in nums:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        for i in dic:\\n            if dic[i] != 1:\\n                continue\\n            elif i+1 in dic:\\n                continue\\n            elif i-1 in dic:\\n                continue\\n            else:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findLonely(self, nums: List[int]) -> List[int]:\\n        dic = {}\\n        res = []\\n        for i in nums:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        for i in dic:\\n            if dic[i] != 1:\\n                continue\\n            elif i+1 in dic:\\n                continue\\n            elif i-1 in dic:\\n                continue\\n            else:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1712158,
                "title": "python-hashmap-o-n-time-o-n-space",
                "content": "**PYTHON**\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        hm = {}\\n        for i in range(n):\\n            if nums[i] in hm:\\n                hm[nums[i]] += 1\\n            else:\\n                hm[nums[i]] = 1\\n        answer = []\\n        for i in range(n):\\n            if (nums[i] - 1) not in hm:\\n                if (nums[i] + 1) not in hm:\\n                        if hm[nums[i]] == 1:\\n                            answer.append(nums[i])\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        hm = {}\\n        for i in range(n):\\n            if nums[i] in hm:\\n                hm[nums[i]] += 1\\n            else:\\n                hm[nums[i]] = 1\\n        answer = []\\n        for i in range(n):\\n            if (nums[i] - 1) not in hm:\\n                if (nums[i] + 1) not in hm:\\n                        if hm[nums[i]] == 1:\\n                            answer.append(nums[i])\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712070,
                "title": "o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        nums.push_back(-10);\\n        nums.push_back(1e6 + 10);\\n        vector<int> result;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n-1;i++){\\n            if(abs(nums[i]-nums[i-1])>1 && abs(nums[i+1]-nums[i])>1)\\n                result.push_back(nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        nums.push_back(-10);\\n        nums.push_back(1e6 + 10);\\n        vector<int> result;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n-1;i++){\\n            if(abs(nums[i]-nums[i-1])>1 && abs(nums[i+1]-nums[i])>1)\\n                result.push_back(nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711985,
                "title": "c-bruteforce-with-hasing-t-c-o-n",
                "content": "// Bruteforce => T.C. = TLE\\n//Bruteforce + hashing =>  T.C. = O(N)\\n\\n\\tvector<int> findLonely(vector<int>& nums) {\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tint size = nums.size();\\n        \\n        vector<int> cnt(1e6+10,0);\\n        for(int i = 0;i<size;i++)\\n        {\\n            cnt[nums[i]]++;\\n        }\\n        \\n        for(int i = 0; i < size; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                if(cnt[0] == 1 and cnt[1] == 0) ans.push_back(nums[i]);\\n            }\\n            else if(cnt[nums[i]] == 1)\\n            {\\n                if(cnt[nums[i]-1] == 0 and cnt[nums[i]+1] == 0)\\n                    ans.push_back(nums[i]);\\n            }\\n            else continue;                                                                                                       \\n                                                                                                                   \\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "// Bruteforce => T.C. = TLE\\n//Bruteforce + hashing =>  T.C. = O(N)\\n\\n\\tvector<int> findLonely(vector<int>& nums) {\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tint size = nums.size();\\n        \\n        vector<int> cnt(1e6+10,0);\\n        for(int i = 0;i<size;i++)\\n        {\\n            cnt[nums[i]]++;\\n        }\\n        \\n        for(int i = 0; i < size; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                if(cnt[0] == 1 and cnt[1] == 0) ans.push_back(nums[i]);\\n            }\\n            else if(cnt[nums[i]] == 1)\\n            {\\n                if(cnt[nums[i]-1] == 0 and cnt[nums[i]+1] == 0)\\n                    ans.push_back(nums[i]);\\n            }\\n            else continue;                                                                                                       \\n                                                                                                                   \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1711617,
                "title": "brute-force-in-c",
                "content": "class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& n) {\\n        vector<int>v2;\\n        sort(n.begin(),n.end());\\n        long long int k;\\n        if(n.size()==1)\\n           return n;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            k=0;\\n            if(i==0)\\n            {\\n                if((n[i]==n[i+1]) or ((n[i]+1)==n[i+1]))\\n                    k++;\\n            }\\n            else if(i==n.size()-1)\\n            {\\n                if((n[i]==n[i-1]) or (n[i]==(n[i-1]+1)))\\n                    k++;\\n            }\\n            else\\n            {\\n                if((n[i]==n[i+1]) or ((n[i]+1)==n[i+1]) or (n[i-1]==n[i]) or ((n[i-1]+1)==n[i]))\\n                  k++;\\n            }\\n            if(k==0){\\n                v2.push_back(n[i]);}\\n        }\\n        return v2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& n) {\\n        vector<int>v2;\\n        sort(n.begin(),n.end());\\n        long long int k;\\n        if(n.size()==1)\\n           return n;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            k=0;\\n            if(i==0)\\n            {\\n                if((n[i]==n[i+1]) or ((n[i]+1)==n[i+1]))\\n                    k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1711538,
                "title": "c-easy-to-understand",
                "content": "```\\nvector<int> findLonely(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]-1]==0 and mp[nums[i]+1]==0 and mp[nums[i]]==1) ans.push_back(nums[i]);\\n        }\\n        return ans;   \\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nvector<int> findLonely(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]-1]==0 and mp[nums[i]+1]==0 and mp[nums[i]]==1) ans.push_back(nums[i]);\\n        }\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711524,
                "title": "c-solution",
                "content": "Easily understandable for beginner level.\\n```\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> res;\\n        int n = nums.size();\\n        if(n==1) return nums;\\n        \\n        sort(nums.begin(),nums.end());\\n        if(n==2 && nums[1]-nums[0]>1) return nums;\\n        if(nums[0]!=nums[1] && nums[1]-nums[0]>1) \\n            res.push_back(nums[0]);\\n        if(nums[n-1]!=nums[n-2] && nums[n-1]-nums[n-2]>1) \\n            res.push_back(nums[n-1]);\\n        for(int i= 1;i<n-1;i++){\\n            if(nums[i]!=nums[i-1] && nums[i]-nums[i-1]>1 && nums[i]!=nums[i+1] && nums[i+1]-nums[i]>1)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n```\\n**LEAVE COMMENTS IF ANY QUERRIES!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> res;\\n        int n = nums.size();\\n        if(n==1) return nums;\\n        \\n        sort(nums.begin(),nums.end());\\n        if(n==2 && nums[1]-nums[0]>1) return nums;\\n        if(nums[0]!=nums[1] && nums[1]-nums[0]>1) \\n            res.push_back(nums[0]);\\n        if(nums[n-1]!=nums[n-2] && nums[n-1]-nums[n-2]>1) \\n            res.push_back(nums[n-1]);\\n        for(int i= 1;i<n-1;i++){\\n            if(nums[i]!=nums[i-1] && nums[i]-nums[i-1]>1 && nums[i]!=nums[i+1] && nums[i+1]-nums[i]>1)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711500,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> list1 = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        if(nums.length==1){\\n            list1.add(nums[0]);\\n            return list1;\\n        }\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(i==0){\\n                if(nums[i]+1!=nums[i+1] && nums[i]!=nums[i+1]){\\n                    list1.add(nums[i]);\\n                }\\n            }\\n            else if(i==nums.length-1){\\n                if(nums[i]!=nums[i-1]+1 && nums[i]!=nums[i-1]){\\n                    list1.add(nums[i]);\\n                }\\n            }\\n            else{\\n                if(nums[i]!=nums[i-1]+1 && nums[i]+1!=nums[i+1] && nums[i]!=nums[i-1] && nums[i]!=nums[i+1]){\\n                    list1.add(nums[i]);\\n                }\\n            }\\n        }\\n        \\n        return list1;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> list1 = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        if(nums.length==1){\\n            list1.add(nums[0]);\\n            return list1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1711495,
                "title": "java-map",
                "content": "```\\nclass Solution {\\n    public List < Integer > findLonely(int[] nums) {\\n\\n        List < Integer > ans = new ArrayList < Integer > ();\\n        Map < Integer, Integer > map = new HashMap < > ();\\n        for (int e: nums) {\\n            map.put(e, map.getOrDefault(e, 0) + 1);\\n        }\\n        for (int key: map.keySet()) {\\n            if (map.get(key) == 1 && !map.containsKey(key + 1) &&! map.containsKey(key - 1)) {\\n                ans.add(key);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List < Integer > findLonely(int[] nums) {\\n\\n        List < Integer > ans = new ArrayList < Integer > ();\\n        Map < Integer, Integer > map = new HashMap < > ();\\n        for (int e: nums) {\\n            map.put(e, map.getOrDefault(e, 0) + 1);\\n        }\\n        for (int key: map.keySet()) {\\n            if (map.get(key) == 1 && !map.containsKey(key + 1) &&! map.containsKey(key - 1)) {\\n                ans.add(key);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711388,
                "title": "c-easy-to-understand-hashing-brute-forces",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& arr) \\n    {\\n        int n = arr.size()-1;\\n        vector<int>hsh(1000002,-1);\\n        for(int i = 0;i<=n;i++)\\n        {\\n            hsh[arr[i]]++;\\n        }\\n        vector<int>ans;\\n        for(int i = 0;i<=n;i++)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                if(hsh[arr[i]+1] == -1 and hsh[arr[i]] == 0)\\n                {\\n                    ans.push_back(arr[i]);\\n                }\\n            }\\n            else if(hsh[arr[i]-1] == -1 and hsh[arr[i]+1] == -1 and hsh[arr[i]] == 0)\\n            {\\n                ans.push_back(arr[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease upvote if you like this solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& arr) \\n    {\\n        int n = arr.size()-1;\\n        vector<int>hsh(1000002,-1);\\n        for(int i = 0;i<=n;i++)\\n        {\\n            hsh[arr[i]]++;\\n        }\\n        vector<int>ans;\\n        for(int i = 0;i<=n;i++)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                if(hsh[arr[i]+1] == -1 and hsh[arr[i]] == 0)\\n                {\\n                    ans.push_back(arr[i]);\\n                }\\n            }\\n            else if(hsh[arr[i]-1] == -1 and hsh[arr[i]+1] == -1 and hsh[arr[i]] == 0)\\n            {\\n                ans.push_back(arr[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease upvote if you like this solution :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711345,
                "title": "c-2150-find-all-lonely-numbers-in-the-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int, int> freq; \\n        for (auto& x : nums) ++freq[x]; \\n        vector<int> ans; \\n        for (auto& [k, v] : freq) \\n            if (v == 1 && !freq.count(k-1) && !freq.count(k+1)) ans.push_back(k); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int, int> freq; \\n        for (auto& x : nums) ++freq[x]; \\n        vector<int> ans; \\n        for (auto& [k, v] : freq) \\n            if (v == 1 && !freq.count(k-1) && !freq.count(k+1)) ans.push_back(k); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711295,
                "title": "java-simple-hash-map-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Set<Integer> all = new HashSet<>();\\n        Set<Integer> unique = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            boolean uni = true;\\n            if(all.contains(nums[i])){\\n                unique.remove(nums[i]);\\n                uni = false;\\n            }\\n            if(all.contains(nums[i] +1)){\\n                unique.remove(nums[i]);\\n                unique.remove(nums[i]+1);\\n                uni = false;\\n            }\\n            if(all.contains(nums[i] - 1)){\\n                unique.remove(nums[i]);\\n                unique.remove(nums[i]-1);\\n                uni = false;\\n            }\\n            if(uni) {\\n                unique.add(nums[i]);\\n            }\\n            all.add(nums[i]);\\n        }\\n        return new ArrayList<>(unique);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Set<Integer> all = new HashSet<>();\\n        Set<Integer> unique = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            boolean uni = true;\\n            if(all.contains(nums[i])){\\n                unique.remove(nums[i]);\\n                uni = false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4062952,
                "title": "map-and-a-set-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n        unordered_set<int> s;\\n        unordered_map<int,int> map;\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n            map[nums[i]]++;\\n        }\\n        vector<int> ans;\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            if(map[nums[i]] == 1 and s.find(nums[i] - 1) == s.end() and s.find(nums[i]+1) == s.end())\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        \\n        unordered_set<int> s;\\n        unordered_map<int,int> map;\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n            map[nums[i]]++;\\n        }\\n        vector<int> ans;\\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            if(map[nums[i]] == 1 and s.find(nums[i] - 1) == s.end() and s.find(nums[i]+1) == s.end())\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062246,
                "title": "golang-simple-map-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunc findLonely(nums []int) []int {\\n\\n    m := make(map[int]int)\\n\\n    for _, n := range nums {\\n        m[n]++\\n    }\\n\\n    var ret []int\\n    for n, cnt := range m {\\n        if cnt == 1 && m[n-1] == 0 && m[n+1] == 0 {\\n            ret = append(ret, n)\\n        }\\n    }\\n\\n    return ret\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findLonely(nums []int) []int {\\n\\n    m := make(map[int]int)\\n\\n    for _, n := range nums {\\n        m[n]++\\n    }\\n\\n    var ret []int\\n    for n, cnt := range m {\\n        if cnt == 1 && m[n-1] == 0 && m[n+1] == 0 {\\n            ret = append(ret, n)\\n        }\\n    }\\n\\n    return ret\\n    \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059465,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (i!=0 && (nums[i-1]==nums[i] || nums[i-1]==nums[i]-1)) continue;\\n            if (i!=nums.size()-1 && (nums[i+1]==nums[i] || nums[i+1]==nums[i]+1)) continue;\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (i!=0 && (nums[i-1]==nums[i] || nums[i-1]==nums[i]-1)) continue;\\n            if (i!=nums.size()-1 && (nums[i+1]==nums[i] || nums[i+1]==nums[i]+1)) continue;\\n            ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052387,
                "title": "c-easy-set-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n      set<int>st(nums.begin(),nums.end());\\n      int sz=nums.size();\\n        vector<int>res;\\n        map<int,int>mp;\\n        for(auto it:nums)\\n          mp[it]++;\\n        for(int i=0;i<sz;i++)\\n           {\\n             int val=nums[i];\\n             if(mp[val]==1 and  st.find(val-1) ==st.end() and st.find(val+1)==st.end())\\n                    res.push_back(val);\\n           }\\n           return res;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n      set<int>st(nums.begin(),nums.end());\\n      int sz=nums.size();\\n        vector<int>res;\\n        map<int,int>mp;\\n        for(auto it:nums)\\n          mp[it]++;\\n        for(int i=0;i<sz;i++)\\n           {\\n             int val=nums[i];\\n             if(mp[val]==1 and  st.find(val-1) ==st.end() and st.find(val+1)==st.end())\\n                    res.push_back(val);\\n           }\\n           return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047996,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        map<int , int> count;\\n        vector<int> answer;\\n        for(auto i : nums) count[i]++;\\n        for(auto i : nums)\\n        {\\n            if(count[i] == 1 && !count[i-1] && !count[i+1]) answer.push_back(i);\\n        }    \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        map<int , int> count;\\n        vector<int> answer;\\n        for(auto i : nums) count[i]++;\\n        for(auto i : nums)\\n        {\\n            if(count[i] == 1 && !count[i-1] && !count[i+1]) answer.push_back(i);\\n        }    \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031693,
                "title": "c-solution-with-unordered-map-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        vector<int> res;\\n        unordered_map<int, int> mp;\\n\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(mp[nums[i]] < 2 and mp[nums[i]+1] == 0 and mp[nums[i]-1] == 0)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        vector<int> res;\\n        unordered_map<int, int> mp;\\n\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(mp[nums[i]] < 2 and mp[nums[i]+1] == 0 and mp[nums[i]-1] == 0)\\n                res.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030531,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n      \\n        for(auto const&p:mp){\\n            if(p.second==1){\\n                int x = p.first;\\n                //auto next_element = mp.find(x+1);\\n               // auto prev_element = mp.find(x-1);\\n                \\n                if(mp.find(x+1) == mp.end() && mp.find(x-1) == mp.end()){\\n                    ans.push_back(p.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n      \\n        for(auto const&p:mp){\\n            if(p.second==1){\\n                int x = p.first;\\n                //auto next_element = mp.find(x+1);\\n               // auto prev_element = mp.find(x-1);\\n                \\n                if(mp.find(x+1) == mp.end() && mp.find(x-1) == mp.end()){\\n                    ans.push_back(p.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024103,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBaisc Approach \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nchecking previos element with current element , firstly checked first and last element then remaining ones\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList <Integer> List = new ArrayList<>();\\n       \\n        for(int i = 1 ; i< nums.length-1 ; i++){\\n if(nums[ i -1 ] +1 < nums[i] && nums[i] +1 < nums[i+1]){\\n     List.add(nums[i]);\\n }\\n  }\\n  if(nums.length == 1){\\n            List.add(nums[0]);\\n        }\\nif(nums.length > 1){\\n    if(nums[0] +1 < nums[1]){\\n        List.add(nums[0]);\\n    }\\n    if(nums[ nums.length -2 ] +1 < nums[nums.length-1]){\\n        List.add(nums[nums.length-1]);\\n    }\\n}\\n\\n       \\n        return List;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList <Integer> List = new ArrayList<>();\\n       \\n        for(int i = 1 ; i< nums.length-1 ; i++){\\n if(nums[ i -1 ] +1 < nums[i] && nums[i] +1 < nums[i+1]){\\n     List.add(nums[i]);\\n }\\n  }\\n  if(nums.length == 1){\\n            List.add(nums[0]);\\n        }\\nif(nums.length > 1){\\n    if(nums[0] +1 < nums[1]){\\n        List.add(nums[0]);\\n    }\\n    if(nums[ nums.length -2 ] +1 < nums[nums.length-1]){\\n        List.add(nums[nums.length-1]);\\n    }\\n}\\n\\n       \\n        return List;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016983,
                "title": "find-all-lonely-numbers-in-the-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n        }\\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n        for(Map.Entry<Integer,Integer> e:hm.entrySet())\\n        {\\n            if(e.getValue()==1&&hm.containsKey(e.getKey()+1)==false&&hm.containsKey(e.getKey()-1)==false)\\n            ans.add(e.getKey());\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n        }\\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n        for(Map.Entry<Integer,Integer> e:hm.entrySet())\\n        {\\n            if(e.getValue()==1&&hm.containsKey(e.getKey()+1)==false&&hm.containsKey(e.getKey()-1)==false)\\n            ans.add(e.getKey());\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010623,
                "title": "beginners-friendly-solution-using-hashmap-easy-to-understand-beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        ArrayList<Integer> ll = new ArrayList<>();\\n\\t\\tMap<Integer,Integer> hm = new HashMap<>();\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\thm.put(nums[i], hm.getOrDefault(nums[i], 0)+1);\\n\\t\\t}\\n\\t\\tfor(Map.Entry<Integer,Integer> ele : hm.entrySet()) {\\n\\t\\t\\tint key = ele.getKey();\\n\\t\\t\\tif(ele.getValue() > 1 || hm.containsKey(key+1) || hm.containsKey(key-1)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tll.add(key);\\n\\t\\t}\\n\\t\\treturn ll;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        ArrayList<Integer> ll = new ArrayList<>();\\n\\t\\tMap<Integer,Integer> hm = new HashMap<>();\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\thm.put(nums[i], hm.getOrDefault(nums[i], 0)+1);\\n\\t\\t}\\n\\t\\tfor(Map.Entry<Integer,Integer> ele : hm.entrySet()) {\\n\\t\\t\\tint key = ele.getKey();\\n\\t\\t\\tif(ele.getValue() > 1 || hm.containsKey(key+1) || hm.containsKey(key-1)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tll.add(key);\\n\\t\\t}\\n\\t\\treturn ll;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007505,
                "title": "python-video-walkthrough-time-o-n-space-o-n",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/hzgiQf5KmPI)\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        X = defaultdict(lambda: 0)\\n        for x in nums: X[x] += 1\\n        res = []\\n        for x in nums:\\n            if X[x] == 1 and x + 1 not in X and x - 1 not in X: res.append(x)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        X = defaultdict(lambda: 0)\\n        for x in nums: X[x] += 1\\n        res = []\\n        for x in nums:\\n            if X[x] == 1 and x + 1 not in X and x - 1 not in X: res.append(x)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991868,
                "title": "easy-approach-using-hashmap",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            map.put(i,map.getOrDefault(i,0) + 1);\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int key:map.keySet()){\\n            if(map.get(key) == 1){\\n                if(!map.containsKey(key + 1) && !map.containsKey(key - 1)){\\n                    ans.add(key);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            map.put(i,map.getOrDefault(i,0) + 1);\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int key:map.keySet()){\\n            if(map.get(key) == 1){\\n                if(!map.containsKey(key + 1) && !map.containsKey(key - 1)){\\n                    ans.add(key);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983792,
                "title": "easy-and-simple-approach-using-hashmap-o-n",
                "content": "Please Upvote my answer if you are able to understand the answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i:nums) m[i]++;\\n        vector<int> ans;\\n        for(auto i:m){\\n            if(i.second == 1){\\n                if(m.count(i.first+1)==false && m.count(i.first-1)==false) ans.push_back(i.first);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i:nums) m[i]++;\\n        vector<int> ans;\\n        for(auto i:m){\\n            if(i.second == 1){\\n                if(m.count(i.first+1)==false && m.count(i.first-1)==false) ans.push_back(i.first);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970685,
                "title": "easy-using-iterator-in-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        unordered_map<int,int>mp;\\n        vector<int>ans;\\n        for(auto i:nums)\\n        {\\n            mp[i]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n        if((mp.find(it->first+1)==mp.end()) and (mp.find(it->first-1)==mp.end()) and it->second==1)\\n            ans.push_back(it->first);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        unordered_map<int,int>mp;\\n        vector<int>ans;\\n        for(auto i:nums)\\n        {\\n            mp[i]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n        if((mp.find(it->first+1)==mp.end()) and (mp.find(it->first-1)==mp.end()) and it->second==1)\\n            ans.push_back(it->first);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956893,
                "title": "solution-using-map-and-list-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> findLonely(List<int> nums) {\\n      Map<int, int> lonely = {};\\n      List<int> result = [];\\n      for(int i=0; i<nums.length; i++){\\n         lonely[nums[i]] = (lonely[nums[i]] ?? 0) + 1;\\n      }\\n      for(int number in nums){\\n          if(lonely[number]==1){\\n              if(!lonely.containsKey(number-1) && !lonely.containsKey(number+1)){\\n                  result.add(number);\\n              }\\n          }\\n      }\\n      return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findLonely(List<int> nums) {\\n      Map<int, int> lonely = {};\\n      List<int> result = [];\\n      for(int i=0; i<nums.length; i++){\\n         lonely[nums[i]] = (lonely[nums[i]] ?? 0) + 1;\\n      }\\n      for(int number in nums){\\n          if(lonely[number]==1){\\n              if(!lonely.containsKey(number-1) && !lonely.containsKey(number+1)){\\n                  result.add(number);\\n              }\\n          }\\n      }\\n      return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951011,
                "title": "fastest-and-cleanest-approach",
                "content": "# Complexity\\n- Time complexity: O(n) [For Both Codes]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) [For Both Codes]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1 (Using Array)\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        int maxValue = 0;\\n        \\n        for(int i: nums) {\\n            maxValue = Math.max(maxValue, i);\\n        }\\n\\n        int[] freq = new int[maxValue+2];\\n        for(int i: nums) {\\n            freq[i]++;\\n        } \\n\\n        for(int i: nums) {\\n            if(i == 0 && freq[i] == 1 && freq[i+1] == 0) list.add(i);\\n            else if(i != 0 && freq[i] == 1 && freq[i-1] == 0 && freq[i+1] == 0)\\n                list.add(i);\\n        }\\n\\n        return list;\\n    }\\n}\\n```\\n\\n# Code2 (Using HashMap)\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        for(int i: nums) {\\n            hm.put(i, hm.getOrDefault(i, 0)+1);\\n        }\\n\\n        for(int i: nums) {\\n            if(hm.get(i) == 1 && !hm.containsKey(i-1) && !hm.containsKey(i+1)) {\\n                list.add(i);\\n            }\\n        } \\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        int maxValue = 0;\\n        \\n        for(int i: nums) {\\n            maxValue = Math.max(maxValue, i);\\n        }\\n\\n        int[] freq = new int[maxValue+2];\\n        for(int i: nums) {\\n            freq[i]++;\\n        } \\n\\n        for(int i: nums) {\\n            if(i == 0 && freq[i] == 1 && freq[i+1] == 0) list.add(i);\\n            else if(i != 0 && freq[i] == 1 && freq[i-1] == 0 && freq[i+1] == 0)\\n                list.add(i);\\n        }\\n\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        for(int i: nums) {\\n            hm.put(i, hm.getOrDefault(i, 0)+1);\\n        }\\n\\n        for(int i: nums) {\\n            if(hm.get(i) == 1 && !hm.containsKey(i-1) && !hm.containsKey(i+1)) {\\n                list.add(i);\\n            }\\n        } \\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944862,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn find_lonely(nums: Vec<i32>) -> Vec<i32> {\\n    let mut memo = vec![0;10usize.pow(6)+10];\\n    for &v in &nums {\\n      memo[v as usize+5] += 1;\\n    }\\n\\n    let mut result = vec![];\\n    for v in nums {\\n      let ci = v as usize+5;\\n      if memo[ci] == 1 && memo[ci-1] == 0 && memo[ci+1] == 0 {\\n        result.push(v);\\n      }\\n    }\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn find_lonely(nums: Vec<i32>) -> Vec<i32> {\\n    let mut memo = vec![0;10usize.pow(6)+10];\\n    for &v in &nums {\\n      memo[v as usize+5] += 1;\\n    }\\n\\n    let mut result = vec![];\\n    for v in nums {\\n      let ci = v as usize+5;\\n      if memo[ci] == 1 && memo[ci-1] == 0 && memo[ci+1] == 0 {\\n        result.push(v);\\n      }\\n    }\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941306,
                "title": "c-solution-using-stacks",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        stack<int> st;\\n        for(int i=0; i<nums.size(); i++){\\n            if(!st.empty() && (nums[i] == st.top() || nums[i]+1 == st.top() || nums[i]-1 == st.top())){\\n                st.pop();\\n            }\\n            else if(i>0 &&( nums[i-1] == nums[i] - 1 || nums[i-1] == nums[i])){\\n                \\n            }  \\n            else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        stack<int> st;\\n        for(int i=0; i<nums.size(); i++){\\n            if(!st.empty() && (nums[i] == st.top() || nums[i]+1 == st.top() || nums[i]-1 == st.top())){\\n                st.pop();\\n            }\\n            else if(i>0 &&( nums[i-1] == nums[i] - 1 || nums[i-1] == nums[i])){\\n                \\n            }  \\n            else{\\n                st.push(nums[i]);\\n            }\\n        }\\n        vector<int> ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923373,
                "title": "very-easy-solution-in-c-using-hashmap-unordered-map-with-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n     vector<int> ans;\\n\\n     //Use hashmap to count the frequency of all the elements of the vector\\n      unordered_map<int,int> mp;\\n      for(int i=0;i<nums.size();++i)\\n      {\\n        mp[nums[i]]++; \\n      }  \\n      \\n      for(int i=0;i<nums.size();++i)\\n      {\\n        if(mp[nums[i]]==1)\\n        {\\n          if(mp.find(nums[i]+1)==mp.end() && mp.find(nums[i]-1)==mp.end())\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n     vector<int> ans;\\n\\n     //Use hashmap to count the frequency of all the elements of the vector\\n      unordered_map<int,int> mp;\\n      for(int i=0;i<nums.size();++i)\\n      {\\n        mp[nums[i]]++; \\n      }  \\n      \\n      for(int i=0;i<nums.size();++i)\\n      {\\n        if(mp[nums[i]]==1)\\n        {\\n          if(mp.find(nums[i]+1)==mp.end() && mp.find(nums[i]-1)==mp.end())\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919624,
                "title": "an-be-solved-even-easier",
                "content": "\\n\\n# \\u0421++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    vector<int> lonely;\\n\\n    for (int i = 0; i < nums.size(); ++i) {\\n      if ((i == 0 || nums[i] - nums[i - 1] > 1) && (i == nums.size() - 1 || nums[i + 1] - nums[i] > 1))\\n        lonely.push_back(nums[i]);\\n    }\\n\\n    return lonely; \\n    }\\n};\\n```\\n# Java\\n\\n```\\npublic List<Integer> findLonely(int[] nums) {\\n    Arrays.sort(nums);\\n    List<Integer> lonely = new ArrayList<>();\\n\\n    for (int i = 0; i < nums.length; ++i) {\\n      if ((i == 0 || nums[i] - nums[i - 1] > 1) && (i == nums.length - 1 || nums[i + 1] - nums[i] > 1))\\n        lonely.add(nums[i]);\\n    }\\n\\n    return lonely;\\n  }\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    vector<int> lonely;\\n\\n    for (int i = 0; i < nums.size(); ++i) {\\n      if ((i == 0 || nums[i] - nums[i - 1] > 1) && (i == nums.size() - 1 || nums[i + 1] - nums[i] > 1))\\n        lonely.push_back(nums[i]);\\n    }\\n\\n    return lonely; \\n    }\\n};\\n```\n```\\npublic List<Integer> findLonely(int[] nums) {\\n    Arrays.sort(nums);\\n    List<Integer> lonely = new ArrayList<>();\\n\\n    for (int i = 0; i < nums.length; ++i) {\\n      if ((i == 0 || nums[i] - nums[i - 1] > 1) && (i == nums.length - 1 || nums[i + 1] - nums[i] > 1))\\n        lonely.add(nums[i]);\\n    }\\n\\n    return lonely;\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919190,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> findLonely(List<int> nums) {\\n      Map<int, int> m = {};\\n      final List<int> ans = [];\\n      for (var i in nums) {\\n          if (!m.containsKey(i)) {\\n              m[i] = 1;\\n          } else {\\n              m[i] = m[i]! + 1;\\n          }\\n      }\\n\\n      for (var i in nums) {\\n          if (m[i] == 1) {\\n              if (!m.containsKey(i - 1) && !m.containsKey(i + 1)) {\\n                  ans.add(i);\\n              }\\n          }\\n      }\\n\\n      return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findLonely(List<int> nums) {\\n      Map<int, int> m = {};\\n      final List<int> ans = [];\\n      for (var i in nums) {\\n          if (!m.containsKey(i)) {\\n              m[i] = 1;\\n          } else {\\n              m[i] = m[i]! + 1;\\n          }\\n      }\\n\\n      for (var i in nums) {\\n          if (m[i] == 1) {\\n              if (!m.containsKey(i - 1) && !m.containsKey(i + 1)) {\\n                  ans.add(i);\\n              }\\n          }\\n      }\\n\\n      return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902834,
                "title": "easy-to-understand-code-but-this-is-not-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> himeshRasemiaLonelySong;\\n        unordered_map<int,int> m;\\n        set<int> s;\\n        for(auto i:nums){\\n            s.insert(i);\\n            m[i]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if( m[nums[i]] == 1 && s.find(nums[i]-1) == s.end() && s.find(nums[i]+1) == s.end()){\\n                himeshRasemiaLonelySong.push_back(nums[i]);\\n            }\\n        }\\n        return himeshRasemiaLonelySong;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> himeshRasemiaLonelySong;\\n        unordered_map<int,int> m;\\n        set<int> s;\\n        for(auto i:nums){\\n            s.insert(i);\\n            m[i]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if( m[nums[i]] == 1 && s.find(nums[i]-1) == s.end() && s.find(nums[i]+1) == s.end()){\\n                himeshRasemiaLonelySong.push_back(nums[i]);\\n            }\\n        }\\n        return himeshRasemiaLonelySong;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896517,
                "title": "c-solution-using-mapping-without-using-maps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n    int arr[10000001]={0};\\n        \\n    vector<int> ans;\\n        for(auto number: nums){\\n            arr[number]++;\\n        }\\n        for(auto number: nums){\\n            if(arr[number]==1 && ((!number|| !arr[number-1]) && !arr[number+1])){\\n                ans.push_back(number);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n    int arr[10000001]={0};\\n        \\n    vector<int> ans;\\n        for(auto number: nums){\\n            arr[number]++;\\n        }\\n        for(auto number: nums){\\n            if(arr[number]==1 && ((!number|| !arr[number-1]) && !arr[number+1])){\\n                ans.push_back(number);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886925,
                "title": "c-solution-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int, int> mp;\\n        vector<int> ans;\\n        \\n        for(int i=0;i<n;i++) mp[nums[i]]++;\\n        \\n        for(auto it:mp){\\n            // cout<<it.first<<\" \"<<it.second<<endl;\\n            if(it.second==1){\\n                if((mp.find(it.first-1)==mp.end()) && mp.find(it.first+1)==mp.end()){\\n                    ans.push_back(it.first);\\n                }\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int, int> mp;\\n        vector<int> ans;\\n        \\n        for(int i=0;i<n;i++) mp[nums[i]]++;\\n        \\n        for(auto it:mp){\\n            // cout<<it.first<<\" \"<<it.second<<endl;\\n            if(it.second==1){\\n                if((mp.find(it.first-1)==mp.end()) && mp.find(it.first+1)==mp.end()){\\n                    ans.push_back(it.first);\\n                }\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3865941,
                "title": "easy-java-solution-easy-method",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n       Map<Integer,Integer> hm= new HashMap<>();\\n       List<Integer> ans=new ArrayList<Integer>();\\n\\n       for(int k : nums){\\n           if(hm.containsKey(k)){\\n               hm.put(k,hm.getOrDefault(k,0)+1);\\n           }else{\\n               hm.put(k,1);\\n           }\\n       }\\n       for(int i=0;i<nums.length;i++){\\n           if(!hm.containsKey(nums[i]+1) && !hm.containsKey(nums[i]-1) && hm.get(nums[i]) ==1 ) ans.add(nums[i]);\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n       Map<Integer,Integer> hm= new HashMap<>();\\n       List<Integer> ans=new ArrayList<Integer>();\\n\\n       for(int k : nums){\\n           if(hm.containsKey(k)){\\n               hm.put(k,hm.getOrDefault(k,0)+1);\\n           }else{\\n               hm.put(k,1);\\n           }\\n       }\\n       for(int i=0;i<nums.length;i++){\\n           if(!hm.containsKey(nums[i]+1) && !hm.containsKey(nums[i]-1) && hm.get(nums[i]) ==1 ) ans.add(nums[i]);\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854338,
                "title": "easy-python-solution-beats-98-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        ans=[]\\n        for i in range(len(nums)):\\n            if nums[i] not in dic:\\n                dic[nums[i]]=1\\n            else:\\n                dic[nums[i]]+=1\\n        for j in range(len(nums)):\\n            if dic[nums[j]]==1:\\n                if nums[j]-1 not in dic  and nums[j]+1 not in dic:\\n        \\n                    ans.append(nums[j])\\n        return ans \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        ans=[]\\n        for i in range(len(nums)):\\n            if nums[i] not in dic:\\n                dic[nums[i]]=1\\n            else:\\n                dic[nums[i]]+=1\\n        for j in range(len(nums)):\\n            if dic[nums[j]]==1:\\n                if nums[j]-1 not in dic  and nums[j]+1 not in dic:\\n        \\n                    ans.append(nums[j])\\n        return ans \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853967,
                "title": "c-map-most-easy-solution",
                "content": "**If u like please upvote my solution :)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n\\n       vector<int> ans;\\n       unordered_map<int,int> mp;\\n       int n=nums.size();\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           mp[nums[i]]++;\\n       } \\n       for(int i=0;i<n;i++)\\n       {\\n        int ele=nums[i];\\n         if(mp[ele]==1)\\n         {\\n        if((mp.find(ele-1)!=mp.end()) or (mp.find(ele+1)!=mp.end()))\\n        {\\n            continue;\\n        }\\n        else\\n        {\\n           ans.push_back(ele);\\n        }\\n         }\\n\\n       }\\n\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n\\n       vector<int> ans;\\n       unordered_map<int,int> mp;\\n       int n=nums.size();\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           mp[nums[i]]++;\\n       } \\n       for(int i=0;i<n;i++)\\n       {\\n        int ele=nums[i];\\n         if(mp[ele]==1)\\n         {\\n        if((mp.find(ele-1)!=mp.end()) or (mp.find(ele+1)!=mp.end()))\\n        {\\n            continue;\\n        }\\n        else\\n        {\\n           ans.push_back(ele);\\n        }\\n         }\\n\\n       }\\n\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853786,
                "title": "using-qsort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint compare(const void*a,const void*b) {\\n    return (*(int*)a-*(int*)b);\\n}\\n\\nint* findLonely(int* nums, int numsSize, int* returnSize){\\n    int* arr=(int*)malloc(sizeof(int)*numsSize);\\n    qsort(nums,numsSize,sizeof(int),compare);\\n    int count=0;\\nfor(int i=0; i<numsSize; i++) {\\n    if((i == 0 || nums[i] != nums[i - 1]) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1]) &&\\n            (i == 0 || nums[i] != nums[i - 1] + 1) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1] - 1)) { \\n        arr[count++]=nums[i];\\n    }  \\n    }\\n*returnSize=count;\\nreturn arr;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint compare(const void*a,const void*b) {\\n    return (*(int*)a-*(int*)b);\\n}\\n\\nint* findLonely(int* nums, int numsSize, int* returnSize){\\n    int* arr=(int*)malloc(sizeof(int)*numsSize);\\n    qsort(nums,numsSize,sizeof(int),compare);\\n    int count=0;\\nfor(int i=0; i<numsSize; i++) {\\n    if((i == 0 || nums[i] != nums[i - 1]) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1]) &&\\n            (i == 0 || nums[i] != nums[i - 1] + 1) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1] - 1)) { \\n        arr[count++]=nums[i];\\n    }  \\n    }\\n*returnSize=count;\\nreturn arr;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851077,
                "title": "c-easy-solution",
                "content": "Very Easy Solution. A very stupid problem for a medium level tag.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        if(nums.size()<=1)return nums;\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(i==0){\\n                if(nums[i+1]-nums[i]>1)ans.push_back(nums[i]);\\n            }else if(i==nums.size()-1){\\n                if(nums[i]-nums[i-1]>1)ans.push_back(nums[i]);\\n            }else{\\n                if(nums[i]-nums[i-1]>1 and nums[i+1]-nums[i]>1)ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity is O(n log n). Time complexity can be reduced to O(n) by using a hashmap, which is very easy to implement.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        if(nums.size()<=1)return nums;\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(i==0){\\n                if(nums[i+1]-nums[i]>1)ans.push_back(nums[i]);\\n            }else if(i==nums.size()-1){\\n                if(nums[i]-nums[i-1]>1)ans.push_back(nums[i]);\\n            }else{\\n                if(nums[i]-nums[i-1]>1 and nums[i+1]-nums[i]>1)ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845595,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- use dictionary to record the count of each number\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> FindLonely(int[] nums) {\\n        Dictionary<int, int> dict = new ();\\n\\n        foreach(int num in nums)\\n        {\\n            if (!dict.TryAdd(num, 1)) \\n            {\\n                dict[num]++;\\n            }\\n        }\\n\\n        return dict\\n            .Where(p => p.Value == 1 && !dict.ContainsKey(p.Key - 1) && !dict.ContainsKey(p.Key + 1))\\n            .Select(p => p.Key)\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindLonely(int[] nums) {\\n        Dictionary<int, int> dict = new ();\\n\\n        foreach(int num in nums)\\n        {\\n            if (!dict.TryAdd(num, 1)) \\n            {\\n                dict[num]++;\\n            }\\n        }\\n\\n        return dict\\n            .Where(p => p.Value == 1 && !dict.ContainsKey(p.Key - 1) && !dict.ContainsKey(p.Key + 1))\\n            .Select(p => p.Key)\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841275,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto i:nums){\\n            mp[i]++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n           if(mp[nums[i]]==1){\\n               if(mp[nums[i]+1]==0 && mp[nums[i]-1]==0){\\n                   ans.push_back(nums[i]);\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto i:nums){\\n            mp[i]++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n           if(mp[nums[i]]==1){\\n               if(mp[nums[i]+1]==0 && mp[nums[i]-1]==0){\\n                   ans.push_back(nums[i]);\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832704,
                "title": "hash-map-o-n-c",
                "content": "# Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n\\n        for (auto &num : nums)\\n            m[num]++;\\n\\n        vector<int> answer;\\n\\n        for (auto &num : nums) {\\n            if (m[num] != 1)\\n                continue;\\n\\n            if (m.find(num - 1) != m.end() || m.find(num + 1) != m.end())\\n                continue;\\n\\n            answer.push_back(num);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n\\n        for (auto &num : nums)\\n            m[num]++;\\n\\n        vector<int> answer;\\n\\n        for (auto &num : nums) {\\n            if (m[num] != 1)\\n                continue;\\n\\n            if (m.find(num - 1) != m.end() || m.find(num + 1) != m.end())\\n                continue;\\n\\n            answer.push_back(num);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826849,
                "title": "using-arrays-sort-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer>list=new ArrayList<>();\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i-1]+1<nums[i]&&nums[i]+1<nums[i+1]){\\n                list.add(nums[i]);\\n            }\\n\\n        }\\n        if(nums.length==1){\\n            list.add(nums[0]);\\n        }\\n        if(nums.length>1){\\n            if(nums[0]+1<nums[1]){\\n                list.add(nums[0]);\\n            }\\n            if(nums[nums.length-2]+1<nums[nums.length-1] )          {\\n                list.add(nums[nums.length-1]);\\n\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer>list=new ArrayList<>();\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i-1]+1<nums[i]&&nums[i]+1<nums[i+1]){\\n                list.add(nums[i]);\\n            }\\n\\n        }\\n        if(nums.length==1){\\n            list.add(nums[0]);\\n        }\\n        if(nums.length>1){\\n            if(nums[0]+1<nums[1]){\\n                list.add(nums[0]);\\n            }\\n            if(nums[nums.length-2]+1<nums[nums.length-1] )          {\\n                list.add(nums[nums.length-1]);\\n\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825812,
                "title": "c-simple-and-easy-solution-using-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int>mpp;\\n        for(int i = 0 ; i<nums.size() ; i++){\\n            mpp[nums[i]]++;\\n        }\\n        vector<int>ans;   \\n        for(int i = 0 ; i<nums.size() ; i++){\\n            if(mpp.find(nums[i]-1) == mpp.end() && mpp.find(nums[i]+1) == mpp.end() && mpp[nums[i]] == 1) ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int>mpp;\\n        for(int i = 0 ; i<nums.size() ; i++){\\n            mpp[nums[i]]++;\\n        }\\n        vector<int>ans;   \\n        for(int i = 0 ; i<nums.size() ; i++){\\n            if(mpp.find(nums[i]-1) == mpp.end() && mpp.find(nums[i]+1) == mpp.end() && mpp[nums[i]] == 1) ans.push_back(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822945,
                "title": "90-faster-using-hash-map-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCount all the appearence of value using hash map ,if no of value is less than 2 then check the conditions .\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        new_dict={}\\n        lonely=[]\\n        for value in nums:\\n            if value in new_dict:\\n                new_dict[value]+=1\\n            else:\\n                new_dict[value]=1\\n        for val in new_dict:\\n            if new_dict[val]>1:\\n                continue\\n            else:\\n                if val+1 in new_dict:\\n                    continue\\n                elif val-1 in new_dict:\\n                    continue\\n                else:\\n                    lonely.append(val)\\n        return (lonely)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        new_dict={}\\n        lonely=[]\\n        for value in nums:\\n            if value in new_dict:\\n                new_dict[value]+=1\\n            else:\\n                new_dict[value]=1\\n        for val in new_dict:\\n            if new_dict[val]>1:\\n                continue\\n            else:\\n                if val+1 in new_dict:\\n                    continue\\n                elif val-1 in new_dict:\\n                    continue\\n                else:\\n                    lonely.append(val)\\n        return (lonely)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815313,
                "title": "solution-using-map-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>m;\\n        // pushing all the elements of nums in map\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            // checking if the count of nums[i] is 1 and its adjacent are not present \\n            // then we can insert in to the answer vector\\n            if(m[nums[i]]==1 && m.find(nums[i]-1)==m.end() && m.find(nums[i]+1)==m.end())\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>m;\\n        // pushing all the elements of nums in map\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            // checking if the count of nums[i] is 1 and its adjacent are not present \\n            // then we can insert in to the answer vector\\n            if(m[nums[i]]==1 && m.find(nums[i]-1)==m.end() && m.find(nums[i]+1)==m.end())\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815109,
                "title": "different-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\neasy\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort and compare with prev index and next index\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)^2\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            boolean lonely = true;\\n            \\n            if ((i > 0 && nums[i] == nums[i - 1]) || \\n                (i < nums.length - 1 && nums[i] == nums[i + 1]) ||\\n                (i > 0 && nums[i] == nums[i - 1] + 1) ||\\n                (i < nums.length - 1 && nums[i] == nums[i + 1] - 1)) {\\n                lonely = false;\\n            }\\n            \\n            if (lonely) {\\n                ans.add(nums[i]);\\n            }\\n        }\\n        \\n        return ans;    \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            boolean lonely = true;\\n            \\n            if ((i > 0 && nums[i] == nums[i - 1]) || \\n                (i < nums.length - 1 && nums[i] == nums[i + 1]) ||\\n                (i > 0 && nums[i] == nums[i - 1] + 1) ||\\n                (i < nums.length - 1 && nums[i] == nums[i + 1] - 1)) {\\n                lonely = false;\\n            }\\n            \\n            if (lonely) {\\n                ans.add(nums[i]);\\n            }\\n        }\\n        \\n        return ans;    \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809440,
                "title": "simple-java-solution",
                "content": "# Simple JAVA Solution!!!\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        \\n        Map<Integer,Integer> m = new HashMap<>();\\n\\n        int l = nums.length;\\n        for(int i=0;i<l;i++)\\n        {\\n           m.put(nums[i],m.getOrDefault(nums[i],0) + 1);\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(Map.Entry<Integer,Integer> i : m.entrySet())\\n        {\\n            if(i.getValue()==1)\\n            {\\n                if(!m.containsKey(i.getKey()+1) && !m.containsKey(i.getKey()-1)) ans.add(i.getKey());\\n            }\\n        }\\n\\n\\n        // System.out.println(m);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        \\n        Map<Integer,Integer> m = new HashMap<>();\\n\\n        int l = nums.length;\\n        for(int i=0;i<l;i++)\\n        {\\n           m.put(nums[i],m.getOrDefault(nums[i],0) + 1);\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(Map.Entry<Integer,Integer> i : m.entrySet())\\n        {\\n            if(i.getValue()==1)\\n            {\\n                if(!m.containsKey(i.getKey()+1) && !m.containsKey(i.getKey()-1)) ans.add(i.getKey());\\n            }\\n        }\\n\\n\\n        // System.out.println(m);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808119,
                "title": "simple-solution-with-map",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findLonely = function(nums) {\\n    const r = nums.reduce((acc, curr) => {\\n    acc.set(curr, acc.get(curr) + 1 || 1)\\n    return acc\\n  }, new Map())\\n\\n  return nums.reduce((acc, curr) => {\\n    if (!(r.has(curr + 1) || r.has(curr - 1)) && r.get(curr) === 1) {\\n      acc.push(curr)\\n    }\\n    return acc\\n  }, [])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findLonely = function(nums) {\\n    const r = nums.reduce((acc, curr) => {\\n    acc.set(curr, acc.get(curr) + 1 || 1)\\n    return acc\\n  }, new Map())\\n\\n  return nums.reduce((acc, curr) => {\\n    if (!(r.has(curr + 1) || r.has(curr - 1)) && r.get(curr) === 1) {\\n      acc.push(curr)\\n    }\\n    return acc\\n  }, [])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800227,
                "title": "using-hashmap-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n\\n        List<Integer> temp = new ArrayList<>();\\n\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        \\n        for(int i:nums){\\n        \\n        if(map.containsKey(i))\\n\\n           map.put(i, map.get(i)+1);\\n       \\n        else   \\n           map.put(i,1);\\n        }\\n\\n        for(int j: nums){\\n            if(map.containsKey(j-1) || map.containsKey(j+1) || map.get(j)>1) continue;\\n            else temp.add(j);\\n        }\\n\\n        return temp;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n\\n        List<Integer> temp = new ArrayList<>();\\n\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        \\n        for(int i:nums){\\n        \\n        if(map.containsKey(i))\\n\\n           map.put(i, map.get(i)+1);\\n       \\n        else   \\n           map.put(i,1);\\n        }\\n\\n        for(int j: nums){\\n            if(map.containsKey(j-1) || map.containsKey(j+1) || map.get(j)>1) continue;\\n            else temp.add(j);\\n        }\\n\\n        return temp;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800225,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        boolean lonely = true;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            lonely = true;\\n\\n            if(nums.length == 1) {\\n                list.add(nums[i]);\\n                break;\\n            }\\n\\n            if(i == 0) {\\n                \\n                if((nums[i] + 1 == nums[i+1]) || (nums[i] == nums[i+1])) {\\n                    lonely = false;\\n                }\\n\\n            } else if(i == nums.length-1) {\\n\\n                if((nums[i] - 1 == nums[i-1]) || (nums[i] == nums[i-1])) {\\n                    lonely = false;\\n                }\\n\\n            } else {\\n\\n                if((nums[i]+1==nums[i+1])||(nums[i]==nums[i+1])||(nums[i]-1==nums[i-1])||(nums[i]==nums[i-1])) {\\n                    lonely = false;\\n                }\\n\\n            }\\n            \\n            if(lonely == true) {\\n                list.add(nums[i]);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        boolean lonely = true;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            lonely = true;\\n\\n            if(nums.length == 1) {\\n                list.add(nums[i]);\\n                break;\\n            }\\n\\n            if(i == 0) {\\n                \\n                if((nums[i] + 1 == nums[i+1]) || (nums[i] == nums[i+1])) {\\n                    lonely = false;\\n                }\\n\\n            } else if(i == nums.length-1) {\\n\\n                if((nums[i] - 1 == nums[i-1]) || (nums[i] == nums[i-1])) {\\n                    lonely = false;\\n                }\\n\\n            } else {\\n\\n                if((nums[i]+1==nums[i+1])||(nums[i]==nums[i+1])||(nums[i]-1==nums[i-1])||(nums[i]==nums[i-1])) {\\n                    lonely = false;\\n                }\\n\\n            }\\n            \\n            if(lonely == true) {\\n                list.add(nums[i]);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797301,
                "title": "simple-sort-very-intiutive-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums;\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=1;i<n-1;i++)\\n            if(nums[i+1]-nums[i]>1 and nums[i]-nums[i-1]>1) ans.push_back(nums[i]);\\n        \\n        if(nums[1]-nums[0]>1) ans.push_back(nums[0]);\\n        if(nums[n-1]-nums[n-2]>1) ans.push_back(nums[n-1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums;\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=1;i<n-1;i++)\\n            if(nums[i+1]-nums[i]>1 and nums[i]-nums[i-1]>1) ans.push_back(nums[i]);\\n        \\n        if(nums[1]-nums[0]>1) ans.push_back(nums[0]);\\n        if(nums[n-1]-nums[n-2]>1) ans.push_back(nums[n-1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796911,
                "title": "js-hashmap",
                "content": "\\n```\\n\\nconst findLonely = nums => {\\n  const map = {};\\n\\n  for (const n of nums) map[n] = (map[n] || 0) + 1;\\n\\n  return nums.filter(n => map[n] === 1 && !map[n - 1] && !map[n + 1]);\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst findLonely = nums => {\\n  const map = {};\\n\\n  for (const n of nums) map[n] = (map[n] || 0) + 1;\\n\\n  return nums.filter(n => map[n] === 1 && !map[n - 1] && !map[n + 1]);\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3792418,
                "title": "two-solution-one-is-o-n-2-beginners-level-another-is-by-using-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        /*int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(i!=j&&(nums[j]+1==nums[i] || nums[j]-1==nums[i] || nums[i]==nums[j])){\\n                    c++;\\n                }\\n            }\\n            if(c==0){\\n                ans.push_back(nums[i]);\\n            }\\n            c=0;\\n        }\\n    return ans;*/\\n    map<int,int>mp;\\n    for(int i=0;i<nums.size();i++){\\n        mp[nums[i]]++;\\n    }\\n    for(int i=0;i<nums.size();i++){\\n        if(mp[nums[i]]==1 && mp.find(nums[i]+1)==mp.end()&& mp.find(nums[i]-1)==mp.end()){\\n            ans.push_back(nums[i]);\\n        }\\n    }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int>ans;\\n        /*int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(i!=j&&(nums[j]+1==nums[i] || nums[j]-1==nums[i] || nums[i]==nums[j])){\\n                    c++;\\n                }\\n            }\\n            if(c==0){\\n                ans.push_back(nums[i]);\\n            }\\n            c=0;\\n        }\\n    return ans;*/\\n    map<int,int>mp;\\n    for(int i=0;i<nums.size();i++){\\n        mp[nums[i]]++;\\n    }\\n    for(int i=0;i<nums.size();i++){\\n        if(mp[nums[i]]==1 && mp.find(nums[i]+1)==mp.end()&& mp.find(nums[i]-1)==mp.end()){\\n            ans.push_back(nums[i]);\\n        }\\n    }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788232,
                "title": "no-map-only-sorting-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& v) {\\n        int n = v.size();\\n        v.push_back(-2);\\n        v.push_back(1e9);\\n        sort(v.begin(), v.end());\\n\\n        vector<int> a;\\n        for (int i = 1; i <= n; i++) {\\n            if (v[i-1]+1 < v[i] && v[i]+1 < v[i+1]) a.push_back(v[i]);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& v) {\\n        int n = v.size();\\n        v.push_back(-2);\\n        v.push_back(1e9);\\n        sort(v.begin(), v.end());\\n\\n        vector<int> a;\\n        for (int i = 1; i <= n; i++) {\\n            if (v[i-1]+1 < v[i] && v[i]+1 < v[i+1]) a.push_back(v[i]);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788008,
                "title": "unordered-map",
                "content": "\\n# Code\\n```\\n//TC : O(number of elements)\\n//SC : O(number of unique elements in array)\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> ans;\\n\\n        //creating map\\n        unordered_map<int, int> mp;\\n        for(auto x: nums){\\n            mp[x]++;\\n        }\\n\\n        // checking every element\\n        for(auto p : mp){\\n            int curNum = p.first;\\n            //freq of cur element == 1 and cur element - 1  and cur element + 1should not be there\\n            if(mp[curNum] == 1 && mp.find(curNum - 1) == mp.end() && mp.find(curNum + 1) == mp.end()){\\n                ans.push_back(curNum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//TC : O(number of elements)\\n//SC : O(number of unique elements in array)\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        vector<int> ans;\\n\\n        //creating map\\n        unordered_map<int, int> mp;\\n        for(auto x: nums){\\n            mp[x]++;\\n        }\\n\\n        // checking every element\\n        for(auto p : mp){\\n            int curNum = p.first;\\n            //freq of cur element == 1 and cur element - 1  and cur element + 1should not be there\\n            if(mp[curNum] == 1 && mp.find(curNum - 1) == mp.end() && mp.find(curNum + 1) == mp.end()){\\n                ans.push_back(curNum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768497,
                "title": "simple-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer>al=new ArrayList<>();\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n        }\\n        for(int i:hm.keySet()){\\n            if(!hm.containsKey(i-1) && !hm.containsKey(i+1) && hm.get(i)==1){\\n                al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer>al=new ArrayList<>();\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n        }\\n        for(int i:hm.keySet()){\\n            if(!hm.containsKey(i-1) && !hm.containsKey(i+1) && hm.get(i)==1){\\n                al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765972,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for (auto& n : nums) ++m[n];\\n        vector<int> ans;\\n        for (auto& [f,s] : m)\\n            if (s == 1 && !m.count(f - 1) && !m.count(f + 1))\\n                ans.push_back(f);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for (auto& n : nums) ++m[n];\\n        vector<int> ans;\\n        for (auto& [f,s] : m)\\n            if (s == 1 && !m.count(f - 1) && !m.count(f + 1))\\n                ans.push_back(f);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764344,
                "title": "c-hash-beat-80-simple",
                "content": "class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(auto num:nums)\\n        {\\n            map[num]++;\\n        }\\n        vector<int> result;\\n        for(auto element: map)\\n        {\\n            if(element.second==1 && map.count(element.first+1)==0 && map.count(element.first-1)==0)\\n            {\\n                   result.push_back(element.first);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(auto num:nums)\\n        {\\n            map[num]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3762729,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        ArrayList <Integer> list = new ArrayList <>();\\n        for(int i =0;i<nums.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<nums.length;j++)\\n                if(i!=j)\\n                    if(nums[j]+1==nums[i]||nums[j]-1==nums[i]||nums[i]==nums[j])\\n                        count=1;\\n            if(count ==0)\\n                list.add(nums[i]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        ArrayList <Integer> list = new ArrayList <>();\\n        for(int i =0;i<nums.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<nums.length;j++)\\n                if(i!=j)\\n                    if(nums[j]+1==nums[i]||nums[j]-1==nums[i]||nums[i]==nums[j])\\n                        count=1;\\n            if(count ==0)\\n                list.add(nums[i]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762728,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        ArrayList <Integer> list = new ArrayList <>();\\n        for(int i =0;i<nums.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<nums.length;j++)\\n                if(i!=j)\\n                    if(nums[j]+1==nums[i]||nums[j]-1==nums[i]||nums[i]==nums[j])\\n                        count=1;\\n            if(count ==0)\\n                list.add(nums[i]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        ArrayList <Integer> list = new ArrayList <>();\\n        for(int i =0;i<nums.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<nums.length;j++)\\n                if(i!=j)\\n                    if(nums[j]+1==nums[i]||nums[j]-1==nums[i]||nums[i]==nums[j])\\n                        count=1;\\n            if(count ==0)\\n                list.add(nums[i]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744640,
                "title": "easy-solution-with-sorted-array-no-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findLonely = function (nums) {\\n    nums.sort((a, b) => a - b)\\n    let cur = 0\\n    let ans = []\\n    while (cur < nums.length) {\\n        if (nums[cur - 1] !== nums[cur] && nums[cur+1] !== nums[cur] && nums[cur-1] +1 !== nums[cur] && nums[cur+1] - 1 !== nums[cur]) {\\n            ans.push(nums[cur])\\n        }\\n        cur++\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findLonely = function (nums) {\\n    nums.sort((a, b) => a - b)\\n    let cur = 0\\n    let ans = []\\n    while (cur < nums.length) {\\n        if (nums[cur - 1] !== nums[cur] && nums[cur+1] !== nums[cur] && nums[cur-1] +1 !== nums[cur] && nums[cur+1] - 1 !== nums[cur]) {\\n            ans.push(nums[cur])\\n        }\\n        cur++\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3744099,
                "title": "vector-sorting-not-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n    nums.push_back(INT_MIN);\\n    sort(nums.begin(),nums.end());\\n    nums.push_back(INT_MAX-1);\\n    vector<int> output;\\n    int i,size=nums.size(); \\n    for(i=1;i<size-1;i++){\\n        if(nums[i-1]==nums[i]-1 || nums[i]==nums[i+1] || nums[i]+1==nums[i+1] || nums[i]==nums[i-1]){\\n            continue;\\n        }else{\\n            output.push_back(nums[i]);\\n        }\\n    }\\n    return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n    nums.push_back(INT_MIN);\\n    sort(nums.begin(),nums.end());\\n    nums.push_back(INT_MAX-1);\\n    vector<int> output;\\n    int i,size=nums.size(); \\n    for(i=1;i<size-1;i++){\\n        if(nums[i-1]==nums[i]-1 || nums[i]==nums[i+1] || nums[i]+1==nums[i+1] || nums[i]==nums[i-1]){\\n            continue;\\n        }else{\\n            output.push_back(nums[i]);\\n        }\\n    }\\n    return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740653,
                "title": "hashmap-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static HashMap<Integer,Integer> populateHashMap(int[] nums){\\n        HashMap<Integer,Integer> hashmap = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n            hashmap.put(nums[i],hashmap.getOrDefault(nums[i],0)+1);\\n        \\n        return hashmap;\\n    }\\n\\n    public static List<Integer> lonelyPairs(HashMap<Integer,Integer> hashmap){\\n        List<Integer> result = new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> map : hashmap.entrySet()){\\n            int prev = map.getKey()-1;\\n            int next = map.getKey()+1;\\n\\n            if(map.getValue() == 1) // Lonely\\n                if(!hashmap.containsKey(prev) && !hashmap.containsKey(next))\\n                    result.add(map.getKey());\\n        }\\n        return result;\\n    }\\n\\n    public List<Integer> findLonely(int[] nums) {\\n\\n        List<Integer> result = new ArrayList<>();\\n        HashMap<Integer,Integer> hashmap = populateHashMap(nums);\\n        return lonelyPairs(hashmap);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static HashMap<Integer,Integer> populateHashMap(int[] nums){\\n        HashMap<Integer,Integer> hashmap = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n            hashmap.put(nums[i],hashmap.getOrDefault(nums[i],0)+1);\\n        \\n        return hashmap;\\n    }\\n\\n    public static List<Integer> lonelyPairs(HashMap<Integer,Integer> hashmap){\\n        List<Integer> result = new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> map : hashmap.entrySet()){\\n            int prev = map.getKey()-1;\\n            int next = map.getKey()+1;\\n\\n            if(map.getValue() == 1) // Lonely\\n                if(!hashmap.containsKey(prev) && !hashmap.containsKey(next))\\n                    result.add(map.getKey());\\n        }\\n        return result;\\n    }\\n\\n    public List<Integer> findLonely(int[] nums) {\\n\\n        List<Integer> result = new ArrayList<>();\\n        HashMap<Integer,Integer> hashmap = populateHashMap(nums);\\n        return lonelyPairs(hashmap);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732618,
                "title": "fast-and-simple-python-solution-using-counter-and-converting-to-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        lon_nums = set()\\n        counter = collections.Counter(nums)\\n        \\n        nums_set = set(nums)\\n\\n        for num, count in counter.items():\\n            if not num + 1 in nums_set and not num - 1 in nums_set and count == 1:\\n                lon_nums.add(num)\\n        return list(lon_nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        lon_nums = set()\\n        counter = collections.Counter(nums)\\n        \\n        nums_set = set(nums)\\n\\n        for num, count in counter.items():\\n            if not num + 1 in nums_set and not num - 1 in nums_set and count == 1:\\n                lon_nums.add(num)\\n        return list(lon_nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717913,
                "title": "initial-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to check if the numbers in array are defined as lonely.\\nLonely means that the number occurs only once in the array\\n**AND** there are no adjacent numbers less than 1 or greater than 1 beside it!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a hashmap, we will count the frequency of numbers within the nums array.  \\n\\nAfter we do that and finish counting the frequencies , we iterate through the nums to check: \\n    1. if there exists a key with a value of 1 \\n    2. There does not exist a key that is less than 1 and greater than 1 of the current num\\n\\nIf both these condition are satisfied we push the current num to our output array.\\n\\n# Complexity\\n- Time complexity: O(n) linear\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) linear\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findLonely = function(nums) {\\n\\n    let lookup = {};\\n    let output  = [];\\n\\n    for (let num of nums){\\n        lookup[num] = (lookup[num] || 0 )+1;\\n    }\\n\\n    for(let num of nums){\\n        if(lookup[num]===1 && (!lookup[num-1] && !lookup[num+1])){\\n            output.push(num);\\n        }\\n    }\\n\\n    return output;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findLonely = function(nums) {\\n\\n    let lookup = {};\\n    let output  = [];\\n\\n    for (let num of nums){\\n        lookup[num] = (lookup[num] || 0 )+1;\\n    }\\n\\n    for(let num of nums){\\n        if(lookup[num]===1 && (!lookup[num-1] && !lookup[num+1])){\\n            output.push(num);\\n        }\\n    }\\n\\n    return output;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706330,
                "title": "cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        if(nums.size()==1) return nums; \\n        int max=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max) max=nums[i];\\n        }\\n        int a[max+1];\\n        for(int i=0;i<=max;i++){\\n            a[i]=0;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            a[nums[i]]++;\\n        }\\n       \\n        vector<int> v;\\n       \\n         for(int i=0;i<nums.size();i++){\\n             if(nums[i]==0){\\n                 if(a[0]==1 && a[1]==0) v.push_back(0);\\n             }\\n             if(nums[i]!=0 && nums[i]!=max){\\n            if(a[nums[i]]==1 && a[nums[i]-1]==0 && a[nums[i]+1]==0) v.push_back(nums[i]);}\\n            if(nums[i]==max && max!=0){\\n             if(a[max-1]==0 && a[max]==1) v.push_back(max);\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        if(nums.size()==1) return nums; \\n        int max=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max) max=nums[i];\\n        }\\n        int a[max+1];\\n        for(int i=0;i<=max;i++){\\n            a[i]=0;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            a[nums[i]]++;\\n        }\\n       \\n        vector<int> v;\\n       \\n         for(int i=0;i<nums.size();i++){\\n             if(nums[i]==0){\\n                 if(a[0]==1 && a[1]==0) v.push_back(0);\\n             }\\n             if(nums[i]!=0 && nums[i]!=max){\\n            if(a[nums[i]]==1 && a[nums[i]-1]==0 && a[nums[i]+1]==0) v.push_back(nums[i]);}\\n            if(nums[i]==max && max!=0){\\n             if(a[max-1]==0 && a[max]==1) v.push_back(max);\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703768,
                "title": "turbocharge-your-code-supercharged-solution-for-finding-lonely-numbers",
                "content": "# Intuition\\nTo solve this problem, we can use a combination of a HashMap and a HashSet. The HashMap will be used to store the count of each number in the input array, while the HashSet will store the numbers that are not alone.\\n\\n# Approach\\n1. Create a HashMap called `countMap` to store the count of each number in the input array.\\n2. Iterate over the input array and update the count in the `countMap` for each number.\\n3. Create a HashSet called `notAlone` to store the numbers that are not alone.\\n4. Iterate over the input array again and check if the current number is not alone by checking the count in the `countMap` as well as the presence of adjacent numbers (i.e., current number - 1 or current number + 1) in the `countMap`. If the number is not alone, add it to the `notAlone` set.\\n5. Create a result list to store the numbers that are alone.\\n6. Iterate over the input array one more time and check if each number is not in the `notAlone` set. If it is not in the set, add it to the result list.\\n7. Return the result list.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input array. We iterate over the array three times, but each iteration is O(n) since we process each element once.\\n- Space complexity: O(n), where n is the length of the input array. We use a HashMap and a HashSet to store information about the numbers, which can take up to O(n) space in the worst case. Additionally, the result list will also take O(n) space if all numbers are alone.\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        Set<Integer> notAlone = new HashSet<>();\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n\\n        for (int num : nums) {\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for (int num : nums) {\\n            if (countMap.get(num) > 1 || countMap.containsKey(num - 1) || countMap.containsKey(num + 1)) {\\n                notAlone.add(num);\\n            }\\n        }\\n\\n        for (int num : nums) {\\n            if (!notAlone.contains(num)) {\\n                result.add(num);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\nclass InnerSolution {\\n    public static void main(String[] args) {\\n        int[] nums = {1, 3, 5, 3};\\n        Solution solution = new Solution();\\n        System.out.println(solution.findLonely(nums));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        Set<Integer> notAlone = new HashSet<>();\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n\\n        for (int num : nums) {\\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n        }\\n\\n        for (int num : nums) {\\n            if (countMap.get(num) > 1 || countMap.containsKey(num - 1) || countMap.containsKey(num + 1)) {\\n                notAlone.add(num);\\n            }\\n        }\\n\\n        for (int num : nums) {\\n            if (!notAlone.contains(num)) {\\n                result.add(num);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\nclass InnerSolution {\\n    public static void main(String[] args) {\\n        int[] nums = {1, 3, 5, 3};\\n        Solution solution = new Solution();\\n        System.out.println(solution.findLonely(nums));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662346,
                "title": "simple-counter-approach-beats-82",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        d = Counter(nums)\\n        ans = []\\n        for i in d:\\n            if d[i]>1:\\n                continue\\n            if i-1 in d or i+1 in d:\\n                continue\\n            ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        d = Counter(nums)\\n        ans = []\\n        for i in d:\\n            if d[i]>1:\\n                continue\\n            if i-1 in d or i+1 in d:\\n                continue\\n            ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654719,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> hs = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            hs.put(nums[i], hs.getOrDefault(nums[i],0)+1);\\n        }\\n\\n        List<Integer> l = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++){\\n            if(hs.get(nums[i])==1 && !hs.containsKey(nums[i]-1) && !hs.containsKey(nums[i]+1) ){\\n                l.add(nums[i]);\\n            }\\n        }\\n\\n        return l;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer,Integer> hs = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            hs.put(nums[i], hs.getOrDefault(nums[i],0)+1);\\n        }\\n\\n        List<Integer> l = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++){\\n            if(hs.get(nums[i])==1 && !hs.containsKey(nums[i]-1) && !hs.containsKey(nums[i]+1) ){\\n                l.add(nums[i]);\\n            }\\n        }\\n\\n        return l;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647029,
                "title": "simple-solution-without-using-hash-java-but-with-average-space-complexity",
                "content": "# Intuition\\nCheck from 1-n-2 (n = size of array)\\nby comparing previous and next element \\nMake  a separate case for if array is empty\\nand for 0th element and last element\\n\\n# Approach\\nfirst sort array , this will help in comparison\\nthen compare as mentioned in code\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nAverage\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i =1; i<nums.length-1; i++){\\n            if(nums[i-1]+1<nums[i] && nums[i]+1<nums[i+1]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        if(nums.length==1){\\n            list.add(nums[0]);\\n        }\\n        if(nums.length>1){\\n            if(nums[0]+1<nums[1]){\\n                list.add(nums[0]);\\n            \\n            }\\n            if(nums[nums.length-2]+1<nums[nums.length-1]){\\n                list.add(nums[nums.length-1]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i =1; i<nums.length-1; i++){\\n            if(nums[i-1]+1<nums[i] && nums[i]+1<nums[i+1]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        if(nums.length==1){\\n            list.add(nums[0]);\\n        }\\n        if(nums.length>1){\\n            if(nums[0]+1<nums[1]){\\n                list.add(nums[0]);\\n            \\n            }\\n            if(nums[nums.length-2]+1<nums[nums.length-1]){\\n                list.add(nums[nums.length-1]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632149,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Map<Integer,Integer> hm=new HashMap<>();\\n        List<Integer> res=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int n:nums){\\n            hm.put(n,hm.getOrDefault(n,0)+1);\\n        }\\n        for(int n:nums){\\n            if(hm.get(n)<=1)\\n            if(!hm.containsKey(n-1) && !hm.containsKey(n+1)) res.add(n);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        Map<Integer,Integer> hm=new HashMap<>();\\n        List<Integer> res=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int n:nums){\\n            hm.put(n,hm.getOrDefault(n,0)+1);\\n        }\\n        for(int n:nums){\\n            if(hm.get(n)<=1)\\n            if(!hm.containsKey(n-1) && !hm.containsKey(n+1)) res.add(n);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631889,
                "title": "o-nlogn-solution-to-find-all-lonely-numbers-in-the-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int i;\\n        vector<int> ans;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()==1)\\n        {\\n            ans.push_back(nums[0]);\\n            return ans;\\n        }\\n        else if(nums.size()>1 && (nums[0]!=nums[1] && nums[0]+1!=nums[1]))\\n        {\\n            ans.push_back(nums[0]);\\n        }\\n        for(i=1 ; i<nums.size()-1 ; i++)\\n        {\\n            if((nums[i]!=nums[i+1] && nums[i]+1!=nums[i+1]) && (nums[i]!=nums[i-1] && nums[i-1]+1!=nums[i]))\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        if(nums.size()>1 && (nums[nums.size()-1]!=nums[nums.size()-2] && nums[nums.size()-2]+1!=nums[nums.size()-1]))\\n        {\\n            ans.push_back(nums[nums.size()-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6859af21-1564-4306-8cc1-aa924e598157_1686637311.3969665.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        int i;\\n        vector<int> ans;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()==1)\\n        {\\n            ans.push_back(nums[0]);\\n            return ans;\\n        }\\n        else if(nums.size()>1 && (nums[0]!=nums[1] && nums[0]+1!=nums[1]))\\n        {\\n            ans.push_back(nums[0]);\\n        }\\n        for(i=1 ; i<nums.size()-1 ; i++)\\n        {\\n            if((nums[i]!=nums[i+1] && nums[i]+1!=nums[i+1]) && (nums[i]!=nums[i-1] && nums[i-1]+1!=nums[i]))\\n            {\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        if(nums.size()>1 && (nums[nums.size()-1]!=nums[nums.size()-2] && nums[nums.size()-2]+1!=nums[nums.size()-1]))\\n        {\\n            ans.push_back(nums[nums.size()-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625075,
                "title": "simple-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        if(nums.size()==1) return nums;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(i==0 && nums[i+1]>nums[i]+1){\\n                ans.push_back(nums[i]);\\n            }else if(i==nums.size()-1 && nums[i-1]<nums[i]-1){\\n                ans.push_back(nums[i]);\\n            }else if(i>0 && i<nums.size()-1 && nums[i-1]<nums[i]-1 && nums[i+1]>nums[i]+1){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        if(nums.size()==1) return nums;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(i==0 && nums[i+1]>nums[i]+1){\\n                ans.push_back(nums[i]);\\n            }else if(i==nums.size()-1 && nums[i-1]<nums[i]-1){\\n                ans.push_back(nums[i]);\\n            }else if(i>0 && i<nums.size()-1 && nums[i-1]<nums[i]-1 && nums[i+1]>nums[i]+1){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615144,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer, Integer> mapa = new HashMap<>();\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++){\\n            mapa.put(nums[i], mapa.getOrDefault(nums[i], 0) + 1);\\n        }\\n        for (int key : mapa.keySet()){\\n            if (mapa.get(key) == 1 && !mapa.containsKey(key + 1) && !mapa.containsKey(key - 1)){\\n                ans.add(key);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findLonely(int[] nums) {\\n        HashMap<Integer, Integer> mapa = new HashMap<>();\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++){\\n            mapa.put(nums[i], mapa.getOrDefault(nums[i], 0) + 1);\\n        }\\n        for (int key : mapa.keySet()){\\n            if (mapa.get(key) == 1 && !mapa.containsKey(key + 1) && !mapa.containsKey(key - 1)){\\n                ans.add(key);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599732,
                "title": "find-all-lonely-number-easy-approach-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        unordered_map<int,int>m;\\n        vector<int>ans;\\n\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it : m)\\n        {\\n            int x = it.first;\\n            int y = it.second;\\n\\n            if(y == 1 and m.count(x+1)==0 and m.count(x-1)==0)\\n            {\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) \\n    {\\n        unordered_map<int,int>m;\\n        vector<int>ans;\\n\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it : m)\\n        {\\n            int x = it.first;\\n            int y = it.second;\\n\\n            if(y == 1 and m.count(x+1)==0 and m.count(x-1)==0)\\n            {\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591632,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        nums.sort()\\n        if len(nums) <= 1:\\n            return nums\\n        for i in range(1, len(nums) - 1):\\n            if nums[i-1] != nums[i]-1 and nums[i+1] != nums[i]+1 and nums[i]!=nums[i+1] and nums[i]!=nums[i-1]:\\n                ans.append(nums[i])\\n        if(nums[0]!=nums[1] and nums[0]+1!=nums[1]):\\n            ans.append(nums[0])\\n        if(nums[-1]!=nums[-2] and nums[-1]-1!=nums[-2]):\\n            ans.append(nums[-1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        nums.sort()\\n        if len(nums) <= 1:\\n            return nums\\n        for i in range(1, len(nums) - 1):\\n            if nums[i-1] != nums[i]-1 and nums[i+1] != nums[i]+1 and nums[i]!=nums[i+1] and nums[i]!=nums[i-1]:\\n                ans.append(nums[i])\\n        if(nums[0]!=nums[1] and nums[0]+1!=nums[1]):\\n            ans.append(nums[0])\\n        if(nums[-1]!=nums[-2] and nums[-1]-1!=nums[-2]):\\n            ans.append(nums[-1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576351,
                "title": "using-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_multiset<int>st(nums.begin(),nums.end());\\n        unordered_set<int>s(nums.begin(),nums.end());\\n        vector<int>ans;\\n        for(auto x:s)\\n        {\\n            if(st.count(x)==1)\\n            {\\n                if(st.count(x+1)==0 && st.count(x-1)==0)\\n                {\\n                    ans.push_back(x);\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_multiset<int>st(nums.begin(),nums.end());\\n        unordered_set<int>s(nums.begin(),nums.end());\\n        vector<int>ans;\\n        for(auto x:s)\\n        {\\n            if(st.count(x)==1)\\n            {\\n                if(st.count(x+1)==0 && st.count(x-1)==0)\\n                {\\n                    ans.push_back(x);\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1791767,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1829385,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1856885,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1847202,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1780818,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1998552,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1983510,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1873715,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1815914,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1728003,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1791767,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1829385,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1856885,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1847202,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1780818,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1998552,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1983510,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1873715,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1815914,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            },
            {
                "id": 1728003,
                "content": [
                    {
                        "username": "Jason-Law",
                        "content": "This one should be easy, not medium."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It's medium easy bruh AND it's giving a TLE if you don't pay attention"
                    },
                    {
                        "username": "Msey",
                        "content": "Some easy questions are more disappointing than this medium one"
                    },
                    {
                        "username": "dcollins175",
                        "content": "I implemented two solutions. One involving sorting the array, and another involving a hashmap. What I can\\'t figure out is why the first solution is faster than the second."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findLonely(vector<int>& nums) {\\n        unordered_map<int,int> hashMap;\\n        for(auto &i:nums)\\n            hashMap[i]++;\\n        vector<int> sol;\\n        for(auto i:hashMap){\\n            if(i.second>1 || hashMap[i.first-1] || hashMap[i.first+1]) continue;\\n            sol.push_back(i.first);\\n        }\\n        return sol;\\n    }\\n};\\n```\\nWhat is wrong in this answer?\\nSomewhat i find that if the element is not there and i try to access that element it inserts that element with a value of 0\\nbut this doesn\\'t meant anything as also 0 is alse considered as false."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "if someone got this as your problem\\nthe reason why it is wrong is that we are using iterator to iterate over unordered_map\\nwhen a new key value pair is inserted in it it get a random position because of unordered_map and for that too the loop is iterated \\nWhich generates a bug \\nso this accesing element can be replaced by std::map.count()"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Should be easy.\nHint (spoiler alert)\n.\n.\n.\n.\n.\n.\n.\n.\n.\nuse hash map"
                    },
                    {
                        "username": "user2433WY",
                        "content": " `class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        res = []\\n        Dict = {}\\n        for i in nums:\\n            if i in Dict:\\n                Dict[i] += 1\\n            else:\\n                Dict[i] = 1\\n        for i in Dict:\\n            if Dict[i] == 1:\\n                if i+1 in nums or i-1 in nums:\\n                    continue\\n                else:\\n                    res.append(i)\\n        return res`\\nI am getting time limit exceeded, how can I improve?"
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "instead of searching in nums, you can search in dict\\nwhich in O(1)."
                    },
                    {
                        "username": "SouradeepSaha",
                        "content": "Many easy questions are harder than this, should change difficulty to easy."
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "this is a easy question. But it can be lengthy to solve without using maps"
                    },
                    {
                        "username": "renatoRocha",
                        "content": "[62,35,59,55,84,61,38,87,55,82]\\n62 here should be lonely since 61 or 63 arent adjacent.\\n\"...and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\"\\n\\nStill the expected output does not contain 62.\\n"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why 62 will be in the answer as 61 is the adjacent no. present \\nThe no.os should be adjacent not their positions.\\nWhat i see You have problem with"
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "class Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        sol=[]\\n        for i in nums:\\n            if nums.count(i)==1:\\n                if i-1 in nums or i+1 in nums:\\n                    pass\\n                else:\\n                    sol.append(i)\\n        return sol\\n\\nI\\'m having time limit exceeded problem with this program, any suggestions for improving the performance?"
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "yes because the complexity for your code is n2 as nums is an array counting freqency of a specific element have complexity of O(n)\\nand you are doing this for each element means O(n2)"
                    }
                ]
            }
        ]
    }
]