[
    {
        "title": "Minimum Common Value",
        "question_content": "Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.\nNote that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.\n&nbsp;\nExample 1:\n\nInput: nums1 = [1,2,3], nums2 = [2,4]\nOutput: 2\nExplanation: The smallest element common to both arrays is 2, so we return 2.\n\nExample 2:\n\nInput: nums1 = [1,2,3,6], nums2 = [2,3,4,5]\nOutput: 2\nExplanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums1.length, nums2.length <= 105\n\t1 <= nums1[i], nums2[j] <= 109\n\tBoth nums1 and nums2 are sorted in non-decreasing order.",
        "solutions": [
            {
                "id": 3082119,
                "title": "very-simple-and-easy-to-understand-solution-without-hashmap",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0, j = 0;\\n        while(i < nums1.size() && j < nums2.size() ){\\n            if(nums1[i] == nums2[j]) return nums1[i];\\n            if(nums1[i] > nums2[j]) j++;\\n            else i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0, j = 0;\\n        while(i < nums1.size() && j < nums2.size() ){\\n            if(nums1[i] == nums2[j]) return nums1[i];\\n            if(nums1[i] > nums2[j]) j++;\\n            else i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082138,
                "title": "two-pointer-vs-one-hashset",
                "content": "# UPVOTE IF YOU LIKE!\\n\\n**Two-pointer**\\n# Intuition:\\n> The Arrays are sorted.\\n+ Borrow the `Two-pointers` from standard question **Merge Two Sorted Arrays**\\n# C++\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int l = 0, r = 0;\\n        while(l < size(nums1) && r < size(nums2)){\\n            if(nums1[l] < nums2[r]) l++;\\n            else if(nums1[l] > nums2[r]) r++;\\n            else return nums1[l];\\n        }\\n        return -1;\\n    }\\nTime - O(`n1 + n2`)\\nSpace - O(`1`) \\n\\n**Hashing Approach**:\\n+ Just `Hash` One array and traverse the other & return first found element. \\n# C++    \\n\\tint getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> st(begin(nums1), end(nums1));\\n        for(int i : nums2)\\n            if(st.count(i)) return i;\\n        return -1;\\n    }\\nTime - O(`n1 + n2`)\\nSpace - O(`n1`)",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "# UPVOTE IF YOU LIKE!\\n\\n**Two-pointer**\\n# Intuition:\\n> The Arrays are sorted.\\n+ Borrow the `Two-pointers` from standard question **Merge Two Sorted Arrays**\\n# C++\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int l = 0, r = 0;\\n        while(l < size(nums1) && r < size(nums2)){\\n            if(nums1[l] < nums2[r]) l++;\\n            else if(nums1[l] > nums2[r]) r++;\\n            else return nums1[l];\\n        }\\n        return -1;\\n    }\\nTime - O(`n1 + n2`)\\nSpace - O(`1`) \\n\\n**Hashing Approach**:\\n+ Just `Hash` One array and traverse the other & return first found element. \\n# C++    \\n\\tint getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> st(begin(nums1), end(nums1));\\n        for(int i : nums2)\\n            if(st.count(i)) return i;\\n        return -1;\\n    }\\nTime - O(`n1 + n2`)\\nSpace - O(`n1`)",
                "codeTag": "Unknown"
            },
            {
                "id": 3082385,
                "title": "python-1-line",
                "content": "```python\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        return min(set(nums1) & set(nums2), default=-1)\\n```\\n\\nPlease vote up if you like my solution \\uD83D\\uDE4F",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        return min(set(nums1) & set(nums2), default=-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082200,
                "title": "python3-dict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThen I marked the elements that were in one of them.\\nThen I looked at another list and returned the first character number I encountered.\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        mp=defaultdict(int)\\n        for i in nums1:\\n            mp[i]=1\\n        for i in nums2:\\n            if mp[i]==1:\\n                return i\\n        return -1  \\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        mp=defaultdict(int)\\n        for i in nums1:\\n            mp[i]=1\\n        for i in nums2:\\n            if mp[i]==1:\\n                return i\\n        return -1  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082615,
                "title": "set-intersection-vs-two-pointers",
                "content": "Arrays are already sorted, so we can use set intersection, or two pointers to track the next smallest element in `n1` and `n2`.\\n\\n## Set Intersection\\nLess efficient as `set_intersection` finds all common elements.\\n\\n**C++**\\n```cpp\\nint getCommon(vector<int>& n1, vector<int>& n2) {\\n    auto it = set_intersection(begin(n1), end(n1), begin(n2), end(n2), begin(n1));\\n    return it == begin(n1) ? -1 : n1.front();\\n}\\n```\\n\\n## Two Pointers\\n**C++**\\n```cpp\\nint getCommon(vector<int>& n1, vector<int>& n2) {\\n    for (int i = 0, j = 0; i < n1.size() && j < n2.size(); ) {\\n        if (n1[i] == n2[j])\\n            return n1[i];\\n        i += n1[i] < n2[j];\\n        j += n1[i] > n2[j];\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint getCommon(vector<int>& n1, vector<int>& n2) {\\n    auto it = set_intersection(begin(n1), end(n1), begin(n2), end(n2), begin(n1));\\n    return it == begin(n1) ? -1 : n1.front();\\n}\\n```\n```cpp\\nint getCommon(vector<int>& n1, vector<int>& n2) {\\n    for (int i = 0, j = 0; i < n1.size() && j < n2.size(); ) {\\n        if (n1[i] == n2[j])\\n            return n1[i];\\n        i += n1[i] < n2[j];\\n        j += n1[i] > n2[j];\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082086,
                "title": "c-too-easy-map-solution",
                "content": "\\n# Too Easy Map Solution\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& n1, vector<int>& n2) {\\n        \\n        // insert the n1 vector into the map\\n        map<int,int> mp;\\n        for( auto it : n1 ) mp[it]++;\\n        \\n        // if the min common value from n2 is present in the map\\n        for( auto it : n2 ){\\n            if( mp.find(it) != mp.end() ) return it;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& n1, vector<int>& n2) {\\n        \\n        // insert the n1 vector into the map\\n        map<int,int> mp;\\n        for( auto it : n1 ) mp[it]++;\\n        \\n        // if the min common value from n2 is present in the map\\n        for( auto it : n2 ){\\n            if( mp.find(it) != mp.end() ) return it;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082044,
                "title": "two-pointers-vs-binary-search-vs-hash-set",
                "content": "## 1. Set\\n### **Complexity:**\\n- Time ```O(N * LogM)```\\n- Space ```O(N)```\\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        unique = set(nums1)\\n        for num in nums2:\\n            if num in unique: return num\\n        return -1\\n```\\n## 2. Binary Search\\n### **Complexity:**\\n- Time ```O(N * LogM)```\\n- Space ```O(1)```\\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        m, n = len(nums1), len(nums2)\\n        for key in nums1:\\n            left, right = 0, m - 1\\n            while right >= left:\\n                mid = (left + right) // 2\\n                if nums2[mid] == key: return key\\n                elif nums2[mid] > key: right = mid - 1\\n                else: left = mid + 1\\n        return -1\\n```\\n## 3. Two Pointers\\n### **Complexity:**\\n- Time ```O(N + M)```\\n- Space ```O(1)```\\n\\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        ptr1, ptr2 = 0, 0\\n        m, n = len(nums1), len(nums2)\\n        while m > ptr1 and n > ptr2:\\n            if nums1[ptr1] == nums2[ptr2]: return nums1[ptr1]\\n            elif nums1[ptr1] > nums2[ptr2]: ptr2 += 1\\n            else: ptr1 += 1\\n        return -1\\n```\\n\\nUpVote **:)**, If you like it.!",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```O(N * LogM)```\n```O(N)```\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        unique = set(nums1)\\n        for num in nums2:\\n            if num in unique: return num\\n        return -1\\n```\n```O(N * LogM)```\n```O(1)```\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        m, n = len(nums1), len(nums2)\\n        for key in nums1:\\n            left, right = 0, m - 1\\n            while right >= left:\\n                mid = (left + right) // 2\\n                if nums2[mid] == key: return key\\n                elif nums2[mid] > key: right = mid - 1\\n                else: left = mid + 1\\n        return -1\\n```\n```O(N + M)```\n```O(1)```\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        ptr1, ptr2 = 0, 0\\n        m, n = len(nums1), len(nums2)\\n        while m > ptr1 and n > ptr2:\\n            if nums1[ptr1] == nums2[ptr2]: return nums1[ptr1]\\n            elif nums1[ptr1] > nums2[ptr2]: ptr2 += 1\\n            else: ptr1 += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973578,
                "title": "java-10000-beats-0-n-pointers-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing two pointer approach....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere two variable that is \"first\" which indicate 0th position of nums1 array and \"second\" variable indicate 0th position of nums2 array. Now compare both value of nums1 and nums2 arrays..\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int first = 0 , second = 0;\\n        while(first!=nums1.length && second!=nums2.length){\\n            if(nums1[first]==nums2[second]) return nums1[first];\\n            else if(nums1[first]<nums2[second]) first++;\\n            else second++;   \\n        }\\n        return -1;\\n    }\\n}\\n// PLEASE UPVOTE ME\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int first = 0 , second = 0;\\n        while(first!=nums1.length && second!=nums2.length){\\n            if(nums1[first]==nums2[second]) return nums1[first];\\n            else if(nums1[first]<nums2[second]) first++;\\n            else second++;   \\n        }\\n        return -1;\\n    }\\n}\\n// PLEASE UPVOTE ME\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478262,
                "title": "easy-o-n-java-code-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] a, int[] b) {\\n        int i,j,k,c=0,s=0;\\n        i=0;\\n        j=0;\\n        while(i<a.length && j<b.length){\\n            if(a[i]==b[j])\\n            return a[i];\\n            else if(a[i]>b[j]){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] a, int[] b) {\\n        int i,j,k,c=0,s=0;\\n        i=0;\\n        j=0;\\n        while(i<a.length && j<b.length){\\n            if(a[i]==b[j])\\n            return a[i];\\n            else if(a[i]>b[j]){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082101,
                "title": "very-easy-to-understand-c-for-beginners",
                "content": "\\n\\n# Approach\\nUse 2 pointers in total, 1 pointer each in both the arrays and compare the elements.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0, element;\\n        while(i<nums1.size() && j<nums2.size()) {\\n            if(nums1[i]<nums2[j]) {\\n                // if the ith element in nums1 is smaller than\\n                // the jth element in nums2, increment pointer i\\n                i++;\\n            } else if(nums1[i]>nums2[j]) {\\n                // if the ith element in nums1 is greater than\\n                // the jth element in nums2, increment pointer j\\n                j++;\\n            } else if(nums1[i] == nums2[j]) {\\n                // if the ith and jth elements are equal, return it\\n                // this will always return the smallest element\\n                return nums1[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0, element;\\n        while(i<nums1.size() && j<nums2.size()) {\\n            if(nums1[i]<nums2[j]) {\\n                // if the ith element in nums1 is smaller than\\n                // the jth element in nums2, increment pointer i\\n                i++;\\n            } else if(nums1[i]>nums2[j]) {\\n                // if the ith element in nums1 is greater than\\n                // the jth element in nums2, increment pointer j\\n                j++;\\n            } else if(nums1[i] == nums2[j]) {\\n                // if the ith and jth elements are equal, return it\\n                // this will always return the smallest element\\n                return nums1[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082022,
                "title": "c-binary-search-o-n-log-n",
                "content": "\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size(), lo = 0, hi = n - 1;\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] == target) return true;\\n            else if(nums[mid] > target) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            if(search(nums2, nums1[i])) return nums1[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size(), lo = 0, hi = n - 1;\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] == target) return true;\\n            else if(nums[mid] > target) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            if(search(nums2, nums1[i])) return nums1[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110256,
                "title": "very-simple-solution-with-explanation-using-set",
                "content": "# Explanation\\n\\n1. Create a `Set` using the first array, `nums1`, to store unique values.\\n2. Loop through each element, `n`, in the second array, `nums2`.\\n3. Check if `n` is in the set. If it is, return `n` as the *common* and *smallest* integer\\n4. If the loop completes without finding a common integer, return `-1` to indicate no common integer exists.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nconst getCommon = function (nums1, nums2) {\\n  const set = new Set(nums1);\\n  for (const n of nums2) {\\n    if (set.has(n)) return n;\\n  }\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nconst getCommon = function (nums1, nums2) {\\n  const set = new Set(nums1);\\n  for (const n of nums2) {\\n    if (set.has(n)) return n;\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082115,
                "title": "c-use-hashmap-simple-approach",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        unordered_map<int, int> mp;\\n        int mini = INT_MAX;\\n        \\n        for(auto it:nums1) //storing frequency of nums1\\'s element in the hashmap mp\\n            mp[it]++;\\n        \\n        for(auto it:nums2) //searching minimum common element and storing it\\n        {\\n            if(mp[it]>0)\\n            {\\n                mini = min(mini, it);\\n            }\\n        }\\n        return mini==INT_MAX ? -1 : mini; //if no element is common return -1 else return minimum common element\\n        \\n    }\\n};\\n```\\n\\n# Please upvote if it helps...\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        unordered_map<int, int> mp;\\n        int mini = INT_MAX;\\n        \\n        for(auto it:nums1) //storing frequency of nums1\\'s element in the hashmap mp\\n            mp[it]++;\\n        \\n        for(auto it:nums2) //searching minimum common element and storing it\\n        {\\n            if(mp[it]>0)\\n            {\\n                mini = min(mini, it);\\n            }\\n        }\\n        return mini==INT_MAX ? -1 : mini; //if no element is common return -1 else return minimum common element\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082047,
                "title": "java-two-pointers-explained",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0, j = 0;\\n        // we start from the 0-th index of both arrays\\n        // note that, we might be at unequal elements at the start\\n        while (i < nums1.length && j < nums2.length) {\\n            // if at nums1 we are at a lower value\\n            // we will move forward and try to match \\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } \\n            // if at nums2 we are at a lower value\\n            // we will move forward and try to match \\n            else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } \\n            // when we finally match, we get the lowest common element\\n            else {\\n                return nums1[i];    // so we return it\\n            }\\n        }\\n        \\n        // if we finish iteration and don\\'t find any match\\n        return -1;  // we return -1\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n#### Clean solution:\\n``` java []\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0, j = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) i++;\\n            else if (nums1[i] > nums2[j]) j++;\\n            else return nums1[i];   \\n        }\\n        \\n        return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0, j = 0;\\n        // we start from the 0-th index of both arrays\\n        // note that, we might be at unequal elements at the start\\n        while (i < nums1.length && j < nums2.length) {\\n            // if at nums1 we are at a lower value\\n            // we will move forward and try to match \\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } \\n            // if at nums2 we are at a lower value\\n            // we will move forward and try to match \\n            else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } \\n            // when we finally match, we get the lowest common element\\n            else {\\n                return nums1[i];    // so we return it\\n            }\\n        }\\n        \\n        // if we finish iteration and don\\'t find any match\\n        return -1;  // we return -1\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0, j = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) i++;\\n            else if (nums1[i] > nums2[j]) j++;\\n            else return nums1[i];   \\n        }\\n        \\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602475,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe intuition behind the solution is that since the arrays are sorted in non-decreasing order, the minimum common integer must be the smallest value that appears in both arrays. Therefore, by comparing the first elements of both arrays, we can determine if they are equal, smaller in nums1, or smaller in nums2, and accordingly, we can move the pointers to the next elements in the respective arrays.\\n\\n\\n# Approach\\nThe solution iterates over the arrays using a while loop, and as long as both arrays have elements remaining, it compares the first elements of both arrays. If they are equal, it means that the minimum common integer has been found, so it is returned. If the element in nums1 is smaller, it means that the minimum common integer must be greater than that element, so the pointer in nums1 is moved to the next element. Similarly, if the element in nums2 is smaller, the pointer in nums2 is moved to the next element. If the loop finishes without finding a common integer, it means that there is no common integer, so -1 is returned.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is determined by the length of the shorter array between nums1 and nums2. In the worst case, the while loop will iterate until one of the arrays is exhausted. Therefore, the time complexity is O(min(N, M)), where N and M are the lengths of nums1 and nums2, respectively.\\n\\n\\n- Space complexity:\\nThe space complexity of the solution is O(1) since it only uses a constant amount of additional space to store the indices and temporary variables for comparisons.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        while len(nums1)>0 and len(nums2)>0:\\n            if nums1[0]==nums2[0]:\\n                return nums1[0]\\n            elif nums1[0]<nums2[0]:\\n                nums1.pop(0)\\n            else:\\n                nums2.pop(0)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        while len(nums1)>0 and len(nums2)>0:\\n            if nums1[0]==nums2[0]:\\n                return nums1[0]\\n            elif nums1[0]<nums2[0]:\\n                nums1.pop(0)\\n            else:\\n                nums2.pop(0)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309097,
                "title": "one-line-code-binary-search-two-pointers-set-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        //Sets Appraoch\\n        return min(list(set(nums1) & set(nums2))) if list(set(nums1) & set(nums2)) else -1\\n        \\n    //please upvote me it would encourage me alot\\n\\n\\n```\\n```\\n\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        //Two Pointers Approach\\n        m,n=len(nums1),len(nums2)\\n        for val in nums1:\\n            left,right=0,n-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if nums2[mid]==val:\\n                    return nums2[mid]\\n                elif nums2[mid]>val:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return -1\\n\\n    //please upvote me it would encourage me alot\\n\\n\\n\\n```\\n```\\n\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        //Binary Search Approach\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            if nums1[i]==nums2[j]:\\n                return nums2[j]\\n            elif nums1[i]>nums2[j]:\\n                j+=1\\n            else:\\n                i+=1\\n        return -1\\n\\n    //please upvote me it would encourage me alot\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        //Sets Appraoch\\n        return min(list(set(nums1) & set(nums2))) if list(set(nums1) & set(nums2)) else -1\\n        \\n    //please upvote me it would encourage me alot\\n\\n\\n```\n```\\n\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        //Two Pointers Approach\\n        m,n=len(nums1),len(nums2)\\n        for val in nums1:\\n            left,right=0,n-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if nums2[mid]==val:\\n                    return nums2[mid]\\n                elif nums2[mid]>val:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return -1\\n\\n    //please upvote me it would encourage me alot\\n\\n\\n\\n```\n```\\n\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        //Binary Search Approach\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            if nums1[i]==nums2[j]:\\n                return nums2[j]\\n            elif nums1[i]>nums2[j]:\\n                j+=1\\n            else:\\n                i+=1\\n        return -1\\n\\n    //please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116030,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1, nums2 = set(nums1), set(nums2)\\n        common = sorted(list(nums1.intersection(nums2))) # sorted(list(nums1 & nums2))  will also work\\n        return -1 if not len(common) else common[0]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1, nums2 = set(nums1), set(nums2)\\n        common = sorted(list(nums1.intersection(nums2))) # sorted(list(nums1 & nums2))  will also work\\n        return -1 if not len(common) else common[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086637,
                "title": "easy-step-by-step-solution-hashset",
                "content": "# Intuition\\nHashing using HashSet\\n\\n# Approach\\n1. Store the unique elements of the first array `nums1` in a `HashSet` called *`set`*. \\n2. Iterate through the second array `nums2` and check if the set contains the element.\\n> - if `true` : return the element\\n> - else / (if `false`) : carry on till the last element of `nums2`\\n3. If not found `return -1;`\\n\\n# Complexity\\n- Time complexity: $$O(n+m)$$ $$=>$$ $$O(n)$$\\n  *assuming size of one array is `m` and the other is `n`*\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) \\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i:nums1)\\n            set.add(i);\\n        for(int i:nums2)\\n        {\\n            if(set.contains(i))\\n                return i;\\n        }\\n    return -1;\\n    }\\n}\\n```\\nWould love to hear any suggestion or Improvisation.\\nPlease **UPVOTE** if it helps\\u2764\\uFE0F\\n*Thank you.*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) \\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i:nums1)\\n            set.add(i);\\n        for(int i:nums2)\\n        {\\n            if(set.contains(i))\\n                return i;\\n        }\\n    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082672,
                "title": "python-3-5-lines-loop-and-ptr-w-example-t-m-98-95",
                "content": "My first thought was`sets`, but now I see that also was true for most of you, so here\\'s my second thought.\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        i, len2 = 0, len(nums2)                         #  Example: nums1 = [     2,  4,   8,  13]   \\n        for n1 in nums1:                                #           nums2 = [1, 1,  3,  6, 8, 9]\\n                              \\n            while i < len2 and nums2[i] < n1: i += 1    #       n1      nums2[i]\\n                                                        #    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013     \\n            if i < len2 and n1 == nums2[i]: return n1   #       2          1\\n                                                        #                  1    \\n        return -1                                       #                  3    <-- 2 < 3\\n                                                        #       4          3\\n                                                        #                  6    <-- 4 < 6\\n                                                        #       8          6\\n                                                        #                  8    <-- return 8\\n```\\n[https://leetcode.com/problems/minimum-common-value/submissions/882567303/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        i, len2 = 0, len(nums2)                         #  Example: nums1 = [     2,  4,   8,  13]   \\n        for n1 in nums1:                                #           nums2 = [1, 1,  3,  6, 8, 9]\\n                              \\n            while i < len2 and nums2[i] < n1: i += 1    #       n1      nums2[i]\\n                                                        #    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013     \\n            if i < len2 and n1 == nums2[i]: return n1   #       2          1\\n                                                        #                  1    \\n        return -1                                       #                  3    <-- 2 < 3\\n                                                        #       4          3\\n                                                        #                  6    <-- 4 < 6\\n                                                        #       8          6\\n                                                        #                  8    <-- return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299618,
                "title": "python3-two-pointer-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo arrays are sorted, so we can just compare two like merge function in merge sort to find the min similar number start from the left\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintain 2 pointer and do binary search with it\\n\\n# Complexity\\n- Time complexity: $$O(m + n)$$ - m, n are length of nums1, nums2, respectively.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i, j = 0, 0\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] == nums2[j]:\\n                return nums1[i]\\n            if nums1[i] < nums2[j]:\\n                i += 1\\n            else:\\n                j += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i, j = 0, 0\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] == nums2[j]:\\n                return nums1[i]\\n            if nums1[i] < nums2[j]:\\n                i += 1\\n            else:\\n                j += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089550,
                "title": "fastest-beats-100",
                "content": "# Upvote it :)\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = set(nums1).intersection(set(nums2))\\n        return min(n) if n else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = set(nums1).intersection(set(nums2))\\n        return min(n) if n else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084230,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size())\\n        {\\n            if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            if(nums1[i]<nums2[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size())\\n        {\\n            if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            if(nums1[i]<nums2[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139457,
                "title": "as-easy-as-it-can-be-2-approaches-beats-99-9-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/db2e4dbd-01fc-420f-9224-3998745b2cbf_1679113774.5833566.png)\\n\\n\\n# Code\\n```\\n// This method takes two arrays of integers as input and returns the first common element between them.\\npublic int getCommon(int[] nums1, int[] nums2) {\\n    \\n    // Initialize two pointers to the start of each array.\\n    int ptr1 = 0;\\n    int ptr2 = 0;\\n\\n    // Loop through both arrays until we reach the end of one of them or find a common element.\\n    while(ptr1 < nums1.length && ptr2 < nums2.length){\\n\\n        // If the current element in the first array is less than the current element in the second array,\\n        // move the first pointer to the next element in the first array.\\n        if(nums1[ptr1] < nums2[ptr2]){\\n            ptr1++;\\n        }\\n        // If the current element in the first array is greater than the current element in the second array,\\n        // move the second pointer to the next element in the second array.\\n        else if(nums1[ptr1] > nums2[ptr2]){\\n            ptr2++;\\n        }\\n        // If the current elements in both arrays are equal, we have found a common element, so return it.\\n        else{\\n            return nums1[ptr1];\\n        }\\n    }\\n    // If we reach this point, there is no common element between the two arrays, so return -1.\\n    return -1;\\n}\\n```\\n\\n**APPROACH 2**\\n\\n\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        \\n        HashMap<Integer, Integer> map=  new HashMap<>();\\n\\n        //Store all the elements of nums1 array in hashMap\\n        \\n        for(int i = 0; i < nums1.length; i++){\\n            \\n            if(map.containsKey(nums1[i])){//we will not have duplicate elements as it\\'s arrays are in non-decreasing order\\n                continue;\\n            }\\n            else{\\n                map.put(nums1[i],1);\\n            }\\n        }\\n        //run a loop and check if any element in nums2 is same as nums1\\n        for(int i = 0; i < nums2.length; i++){\\n\\n            if(map.containsKey(nums2[i])){// if found the match return the element \\n                return nums2[i];\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        return -1;// if no common element is found then return -1\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\n// This method takes two arrays of integers as input and returns the first common element between them.\\npublic int getCommon(int[] nums1, int[] nums2) {\\n    \\n    // Initialize two pointers to the start of each array.\\n    int ptr1 = 0;\\n    int ptr2 = 0;\\n\\n    // Loop through both arrays until we reach the end of one of them or find a common element.\\n    while(ptr1 < nums1.length && ptr2 < nums2.length){\\n\\n        // If the current element in the first array is less than the current element in the second array,\\n        // move the first pointer to the next element in the first array.\\n        if(nums1[ptr1] < nums2[ptr2]){\\n            ptr1++;\\n        }\\n        // If the current element in the first array is greater than the current element in the second array,\\n        // move the second pointer to the next element in the second array.\\n        else if(nums1[ptr1] > nums2[ptr2]){\\n            ptr2++;\\n        }\\n        // If the current elements in both arrays are equal, we have found a common element, so return it.\\n        else{\\n            return nums1[ptr1];\\n        }\\n    }\\n    // If we reach this point, there is no common element between the two arrays, so return -1.\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3105044,
                "title": "java-simple-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n    int i=0,j=0;\\n    while(i<nums1.length&&j<nums2.length)\\n    {\\n        if(nums1[i]==nums2[j])return nums2[j];\\n        else if(nums1[i]<nums2[j])i++;\\n        else j++;\\n    }\\n     return -1;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n    int i=0,j=0;\\n    while(i<nums1.length&&j<nums2.length)\\n    {\\n        if(nums1[i]==nums2[j])return nums2[j];\\n        else if(nums1[i]<nums2[j])i++;\\n        else j++;\\n    }\\n     return -1;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087147,
                "title": "c-very-simple-and-easy-to-understand-beginner-friendly",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially take i and j to 0. Checking if the i-th value of nums1 is greater than compare it to the j-th value of nums2 till it gets equal or remain small and if it gets greater than value of nums1 for that i check like this in num1 till it gets equal otherwise return -1.\\n\\n# Complexity\\n\\nTC:- O(n+m)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int a=nums1.size();\\n        int b=nums2.size();\\n        int i=0;\\n        int j=0;\\n        int ans=-1;\\n        while(i<a&&j<b)\\n        {\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums2[j]>nums1[i])\\n                i++;\\n            else\\n            {\\n                ans=nums1[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int a=nums1.size();\\n        int b=nums2.size();\\n        int i=0;\\n        int j=0;\\n        int ans=-1;\\n        while(i<a&&j<b)\\n        {\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums2[j]>nums1[i])\\n                i++;\\n            else\\n            {\\n                ans=nums1[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084351,
                "title": "two-pointer-solution",
                "content": "# Intuition\\nLook at constraints, you just need to write an O(n) soolution.\\n\\n# Approach\\nSince, both the arrays are sorted in ascending order, iterate through both of them but by using two difft pointers. Compare values at each indices, then either update mini or update the pointers.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO((1))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int mini = INT_MAX; //can\\'t take 1e9 bcoz constraints says nums[i] can assume that value\\n        int m = nums1.size(), n = nums2.size();\\n        int i = 0, j = 0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i] == nums2[j]){\\n                mini = min(mini, nums1[i]);\\n                i++; j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n        if(mini != INT_MAX) return mini;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int mini = INT_MAX; //can\\'t take 1e9 bcoz constraints says nums[i] can assume that value\\n        int m = nums1.size(), n = nums2.size();\\n        int i = 0, j = 0;\\n\\n        while(i<m && j<n){\\n            if(nums1[i] == nums2[j]){\\n                mini = min(mini, nums1[i]);\\n                i++; j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n        if(mini != INT_MAX) return mini;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083568,
                "title": "short-javascript-solution-using-two-set-objects",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar getCommon = function (nums1, nums2) {\\n    let nums1Set = new Set(nums1)\\n    let nums2Set = new Set(nums2)\\n\\n    if (nums1.length < nums2.length) {\\n        for (let num of nums1Set) {\\n            if (nums2Set.has(num)) return num\\n        }\\n    } else {\\n        for (let num of nums2Set) {\\n            if (nums1Set.has(num)) return num\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getCommon = function (nums1, nums2) {\\n    let nums1Set = new Set(nums1)\\n    let nums2Set = new Set(nums2)\\n\\n    if (nums1.length < nums2.length) {\\n        for (let num of nums1Set) {\\n            if (nums2Set.has(num)) return num\\n        }\\n    } else {\\n        for (let num of nums2Set) {\\n            if (nums1Set.has(num)) return num\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082549,
                "title": "hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> m1, m2;\\n        for(int i : nums1) m1[i]++;\\n        for(int i : nums2) m2[i]++;\\n        \\n        for(auto i : m1) {\\n            if(m2.find(i.first) != m2.end()) return i.first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> m1, m2;\\n        for(int i : nums1) m1[i]++;\\n        for(int i : nums2) m2[i]++;\\n        \\n        for(auto i : m1) {\\n            if(m2.find(i.first) != m2.end()) return i.first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082297,
                "title": "c-explained-solution-using-map",
                "content": "\\n\\n# Approach\\n- Declare 2 maps.\\n- Store all the elements of first array in first map.\\n- Store all the elements of second array in second map.\\n- Iterate through the elements of first map, and if second map has - it, return the element.\\n- Return -1 if the element is not found.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map <int,int> m1,m2;//declare 2 maps\\n        //store numbers in first map\\n        for(int i=0;i<nums1.size();i++){\\n            m1[nums1[i]]++;\\n            m2[nums1[i]]=0;\\n        }\\n        //store numbers in second map\\n        for(int i=0;i<nums2.size();i++){\\n            m2[nums2[i]]++;\\n        }\\n        //check presence of numbers of first map in second map\\n        for(auto itr:m1){\\n            int t=itr.first;\\n            if(m2[t]>0){\\n                return t;//return the number if found\\n            }\\n        }\\n        return -1;//if no common element is present\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map <int,int> m1,m2;//declare 2 maps\\n        //store numbers in first map\\n        for(int i=0;i<nums1.size();i++){\\n            m1[nums1[i]]++;\\n            m2[nums1[i]]=0;\\n        }\\n        //store numbers in second map\\n        for(int i=0;i<nums2.size();i++){\\n            m2[nums2[i]]++;\\n        }\\n        //check presence of numbers of first map in second map\\n        for(auto itr:m1){\\n            int t=itr.first;\\n            if(m2[t]>0){\\n                return t;//return the number if found\\n            }\\n        }\\n        return -1;//if no common element is present\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933300,
                "title": "easy-c-solution-beginner-s-friendly",
                "content": "\\n\\n# Approach\\n1. Remove duplicates from both the vectors.\\n2. Initialise Map and count no of element.\\n3. Check if count of element is greater than 1 or not if yes than check for the min value.\\n4. If the min value remains the same from the starting then return -1\\n5. Else return the min value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n\\n    nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end());\\n    nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end());\\n    map<int,int> m;\\n    int mini=INT_MAX;\\n    for(int i=0;i<nums1.size();i++){\\n           m[nums1[i]]++;\\n    }\\n    for(int i=0;i<nums2.size();i++){\\n           m[nums2[i]]++;\\n    }\\n    for(auto it=m.begin();it!=m.end();it++){\\n        if(it->second>=2){\\n            mini=min(mini,it->first);\\n        }\\n    }\\n    if( mini==INT_MAX)\\n    {\\n        return -1;\\n    }\\n    return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n\\n    nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end());\\n    nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end());\\n    map<int,int> m;\\n    int mini=INT_MAX;\\n    for(int i=0;i<nums1.size();i++){\\n           m[nums1[i]]++;\\n    }\\n    for(int i=0;i<nums2.size();i++){\\n           m[nums2[i]]++;\\n    }\\n    for(auto it=m.begin();it!=m.end();it++){\\n        if(it->second>=2){\\n            mini=min(mini,it->first);\\n        }\\n    }\\n    if( mini==INT_MAX)\\n    {\\n        return -1;\\n    }\\n    return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577442,
                "title": "beginners-friendly-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        add num1 element to hashset\\n        check nums2 element is present or not \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set= new HashSet<>();\\n\\n        //add 1st array to set\\n        for(int n1: nums1) set.add(n1);\\n\\n        // now check with 2nd array\\n\\n        for(int n2: nums2) if(set.contains(n2)) return n2;\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set= new HashSet<>();\\n\\n        //add 1st array to set\\n        for(int n1: nums1) set.add(n1);\\n\\n        // now check with 2nd array\\n\\n        for(int n2: nums2) if(set.contains(n2)) return n2;\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479412,
                "title": "java-simple-two-pointers-solution-100",
                "content": "```java\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0, j = 0;\\n\\n        while(i < nums1.length && j < nums2.length) {\\n            if(nums1[i] == nums2[j])\\n                return nums1[i];\\n            else if(nums1[i] < nums2[j])\\n                ++i;\\n            else\\n                ++j;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0, j = 0;\\n\\n        while(i < nums1.length && j < nums2.length) {\\n            if(nums1[i] == nums2[j])\\n                return nums1[i];\\n            else if(nums1[i] < nums2[j])\\n                ++i;\\n            else\\n                ++j;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462780,
                "title": "minimum-common-value-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOptimized Approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size())\\n        {\\n            if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            else if(nums1[i]<nums2[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i, j;\\n        for(i=0 ; i<nums1.size() ; i++)\\n        {\\n            for(j=0 ; j<nums2.size() ; j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                }\\n                else if(nums2[j]>nums1[i])\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/d025a296-c5ef-47ea-b315-62a8cd16c9de_1682665988.7703972.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size())\\n        {\\n            if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            else if(nums1[i]<nums2[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i, j;\\n        for(i=0 ; i<nums1.size() ; i++)\\n        {\\n            for(j=0 ; j<nums2.size() ; j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                }\\n                else if(nums2[j]>nums1[i])\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381730,
                "title": "java-fastest-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int in1 = 0, in2 = 0;\\n        int n1 = nums1.length, n2 = nums2.length;\\n\\n        while(in1 < n1 && in2 < n2){\\n            if(nums1[in1] == nums2[in2]){\\n                return nums1[in1];\\n            }else if(nums1[in1] > nums2[in2]){\\n                in2++;\\n            }else{\\n                in1++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int in1 = 0, in2 = 0;\\n        int n1 = nums1.length, n2 = nums2.length;\\n\\n        while(in1 < n1 && in2 < n2){\\n            if(nums1[in1] == nums2[in2]){\\n                return nums1[in1];\\n            }else if(nums1[in1] > nums2[in2]){\\n                in2++;\\n            }else{\\n                in1++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307826,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0,j = 0;\\n\\n        while(i < n && j < m)\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i] > nums2[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0,j = 0;\\n\\n        while(i < n && j < m)\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i] > nums2[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259374,
                "title": "easy-o-n-m-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n    let i = 0;\\n    let j = 0;\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] === nums2[j]) return nums1[i];\\n        if (nums1[i] < nums2[j]) {\\n            i++;\\n        } else {\\n            j++;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n    let i = 0;\\n    let j = 0;\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] === nums2[j]) return nums1[i];\\n        if (nums1[i] < nums2[j]) {\\n            i++;\\n        } else {\\n            j++;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3176643,
                "title": "java-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n\\n    int i=0,j=0;\\n    while(i<nums1.length && j<nums2.length)\\n    {\\n        if(nums1[i]<nums2[j]) i++;\\n        else if(nums1[i]>nums2[j]) j++;\\n        else return nums1[i];\\n    }\\n    return -1;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n\\n    int i=0,j=0;\\n    while(i<nums1.length && j<nums2.length)\\n    {\\n        if(nums1[i]<nums2[j]) i++;\\n        else if(nums1[i]>nums2[j]) j++;\\n        else return nums1[i];\\n    }\\n    return -1;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098072,
                "title": "easy-java-solution-100-faster",
                "content": "Time complexity: O(n)\\n\\n Space complexity: O(n)\\n\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n\\n    int i=0,j=0;\\n    while(i<nums1.length && j<nums2.length)\\n    {\\n        if(nums1[i]<nums2[j]) i++;\\n        else if(nums1[i]>nums2[j]) j++;\\n        else return nums1[i];\\n    }\\n    return -1;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n\\n    int i=0,j=0;\\n    while(i<nums1.length && j<nums2.length)\\n    {\\n        if(nums1[i]<nums2[j]) i++;\\n        else if(nums1[i]>nums2[j]) j++;\\n        else return nums1[i];\\n    }\\n    return -1;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083641,
                "title": "python3-beginner-friendly-solutions-set-hashmap",
                "content": "The problem is [Intersection of two arrays](https://leetcode.com/problems/intersection-of-two-arrays/) with an additional condition \"if there is no common integer amongst nums1 and nums2, return -1.\"\\n**Set (Accepted)**\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = list(set(nums1) & set(nums2))\\n        \\n        return min(nums) if nums else -1\\n```\\n\\n**Hashmap (Accepted)**\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = []\\n        hashmap = {}\\n        \\n        for num in nums1:\\n            if num in hashmap:\\n                hashmap[num] += 1\\n            else:\\n                hashmap[num] = 1\\n            \\n        for num in nums2:\\n            if num in hashmap and hashmap[num] > 0:\\n                nums.append(num)\\n                hashmap[num] = 0\\n    \\n        return min(nums) if nums else -1\\n```\\n**Stack (TLE)**\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = []\\n        \\n        for num in nums1:\\n            if num not in nums and num in nums2:\\n                nums.append(num)\\n\\n        return min(nums) if nums else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = list(set(nums1) & set(nums2))\\n        \\n        return min(nums) if nums else -1\\n```\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = []\\n        hashmap = {}\\n        \\n        for num in nums1:\\n            if num in hashmap:\\n                hashmap[num] += 1\\n            else:\\n                hashmap[num] = 1\\n            \\n        for num in nums2:\\n            if num in hashmap and hashmap[num] > 0:\\n                nums.append(num)\\n                hashmap[num] = 0\\n    \\n        return min(nums) if nums else -1\\n```\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = []\\n        \\n        for num in nums1:\\n            if num not in nums and num in nums2:\\n                nums.append(num)\\n\\n        return min(nums) if nums else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083604,
                "title": "two-pointer-approach-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n\\n    let i = 0, j = 0;\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] === nums2[j]) {\\n            return nums1[i];\\n        } else if (nums1[i] < nums2[j]) {\\n            i++;\\n        } else {\\n            j++;\\n        }\\n    }\\n    return -1;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n\\n    let i = 0, j = 0;\\n    while (i < nums1.length && j < nums2.length) {\\n        if (nums1[i] === nums2[j]) {\\n            return nums1[i];\\n        } else if (nums1[i] < nums2[j]) {\\n            i++;\\n        } else {\\n            j++;\\n        }\\n    }\\n    return -1;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083262,
                "title": "c-java-python3-2-pointer",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7c339707e031611c80809107e7a667b2c6b6f7f0) for solutions of biweekly 96. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        for (int i = 0, ii = 0; i < nums1.size() && ii < nums2.size(); ) {\\n            if (nums1[i] < nums2[ii]) ++i; \\n            else if (nums1[i] == nums2[ii]) return nums1[i]; \\n            else ++ii; \\n        }\\n        return -1; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        for (int i = 0, ii = 0; i < nums1.length && ii < nums2.length; ) {\\n            if (nums1[i] < nums2[ii]) ++i;\\n            else if (nums1[i] == nums2[ii]) return nums1[i]; \\n            else ++ii; \\n        }\\n        return -1; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i = ii = 0 \\n        while i < len(nums1) and ii < len(nums2): \\n            if nums1[i] < nums2[ii]: i += 1\\n            elif nums1[i] == nums2[ii]: return nums1[i]\\n            else: ii += 1\\n        return -1 \\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        for (int i = 0, ii = 0; i < nums1.size() && ii < nums2.size(); ) {\\n            if (nums1[i] < nums2[ii]) ++i; \\n            else if (nums1[i] == nums2[ii]) return nums1[i]; \\n            else ++ii; \\n        }\\n        return -1; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        for (int i = 0, ii = 0; i < nums1.length && ii < nums2.length; ) {\\n            if (nums1[i] < nums2[ii]) ++i;\\n            else if (nums1[i] == nums2[ii]) return nums1[i]; \\n            else ++ii; \\n        }\\n        return -1; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i = ii = 0 \\n        while i < len(nums1) and ii < len(nums2): \\n            if nums1[i] < nums2[ii]: i += 1\\n            elif nums1[i] == nums2[ii]: return nums1[i]\\n            else: ii += 1\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083178,
                "title": "c-java-js-easy-to-understand-beats-100-comments-added-beginner-friendly",
                "content": "# Approach\\nThis solution iterates through both arrays using two pointers, i and j, which are initially set to 0. It compares the current element in nums1 with the current element in nums2. If the element in nums1 is less than the element in nums2, the pointer for nums1 is incremented. If the element in nums2 is less than the element in nums1, the pointer for nums2 is incremented. If the elements are equal, the element is returned as it is common to both arrays. If the while loop completes and no common elements were found, -1 is returned.\\n\\nThe time complexity of this solution is O(n), where n is the length of the shorter array. This is because we are iterating through both arrays using two pointers, i and j, which are incremented based on the comparison between the current element in nums1 and the current element in nums2. Since we are only incrementing one of the pointers at a time, the maximum number of iterations is equal to the length of the shorter array.\\n\\nThe space complexity of this solution is O(1), because we are only using a constant amount of extra memory for the two pointers, i and j. We are not using any additional data structures, such as arrays or hash tables, so the space used does not depend on the size of the input.\\n\\nThis solution is efficient in terms of both time and space complexity as it has O(n) time and O(1) space complexity, which are optimal for this problem.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Request \\uD83D\\uDE42: \\nIf you find this solution easy to understand and helpful, then Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        // Initialize pointers for both arrays\\n    int i = 0;\\n    int j = 0;\\n\\n    // Iterate through both arrays\\n    while (i < nums1.size() && j < nums2.size()) {\\n        // If the current element in nums1 is less than nums2, move the pointer for nums1\\n        if (nums1[i] < nums2[j]) {\\n            i++;\\n        }\\n        // If the current element in nums2 is less than nums1, move the pointer for nums2\\n        else if (nums1[i] > nums2[j]) {\\n            j++;\\n        }\\n        // If the current elements are equal, return the element (it is common to both arrays)\\n        else {\\n            return nums1[i];\\n        }\\n    }\\n\\n    // If no common elements were found, return -1\\n    return -1;\\n    }\\n};\\n```\\n\\n# JS Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n    // Initialize pointers for both arrays\\n    let i = 0;\\n    let j = 0;\\n\\n    // Iterate through both arrays\\n    while (i < nums1.length && j < nums2.length) {\\n        // If the current element in nums1 is less than nums2, move the pointer for nums1\\n        if (nums1[i] < nums2[j]) {\\n            i++;\\n        }\\n        // If the current element in nums2 is less than nums1, move the pointer for nums2\\n        else if (nums1[i] > nums2[j]) {\\n            j++;\\n        }\\n        // If the current elements are equal, return the element (it is common to both arrays)\\n        else {\\n            return nums1[i];\\n        }\\n    }\\n\\n    // If no common elements were found, return -1\\n    return -1;\\n};\\n```\\n\\n# JAVA Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0;\\n        int j = 0;\\n\\n        // Iterate through both arrays\\n        while (i < nums1.length && j < nums2.length) {\\n        // If the current element in nums1 is less than nums2, move the pointer for nums1\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            }\\n            // If the current element in nums2 is less than nums1, move the pointer for nums2\\n            else if (nums1[i] > nums2[j]) {\\n                j++;\\n            }\\n            // If the current elements are equal, return the element (it is common to both arrays)\\n            else {\\n                return nums1[i];\\n            }\\n        }\\n\\n    // If no common elements were found, return -1\\n    return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        // Initialize pointers for both arrays\\n    int i = 0;\\n    int j = 0;\\n\\n    // Iterate through both arrays\\n    while (i < nums1.size() && j < nums2.size()) {\\n        // If the current element in nums1 is less than nums2, move the pointer for nums1\\n        if (nums1[i] < nums2[j]) {\\n            i++;\\n        }\\n        // If the current element in nums2 is less than nums1, move the pointer for nums2\\n        else if (nums1[i] > nums2[j]) {\\n            j++;\\n        }\\n        // If the current elements are equal, return the element (it is common to both arrays)\\n        else {\\n            return nums1[i];\\n        }\\n    }\\n\\n    // If no common elements were found, return -1\\n    return -1;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n    // Initialize pointers for both arrays\\n    let i = 0;\\n    let j = 0;\\n\\n    // Iterate through both arrays\\n    while (i < nums1.length && j < nums2.length) {\\n        // If the current element in nums1 is less than nums2, move the pointer for nums1\\n        if (nums1[i] < nums2[j]) {\\n            i++;\\n        }\\n        // If the current element in nums2 is less than nums1, move the pointer for nums2\\n        else if (nums1[i] > nums2[j]) {\\n            j++;\\n        }\\n        // If the current elements are equal, return the element (it is common to both arrays)\\n        else {\\n            return nums1[i];\\n        }\\n    }\\n\\n    // If no common elements were found, return -1\\n    return -1;\\n};\\n```\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0;\\n        int j = 0;\\n\\n        // Iterate through both arrays\\n        while (i < nums1.length && j < nums2.length) {\\n        // If the current element in nums1 is less than nums2, move the pointer for nums1\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            }\\n            // If the current element in nums2 is less than nums1, move the pointer for nums2\\n            else if (nums1[i] > nums2[j]) {\\n                j++;\\n            }\\n            // If the current elements are equal, return the element (it is common to both arrays)\\n            else {\\n                return nums1[i];\\n            }\\n        }\\n\\n    // If no common elements were found, return -1\\n    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083148,
                "title": "javascript-solution-time-complexity-o-n-m-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCould either use two pointers or a hash set with extra memory\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThrow all of nums1 in a set and return the first element in num2 that appears in that set\\n\\n# Complexity\\n- Time complexity: O(n + m) || O(nums1.length + nums2.length)\\n- `const set = new Set(nums1)` // O(n) Time \\n- `for (let num of nums2)` // O(m) Time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) || O(nums1.length)\\n- - `const set = new Set(nums1)` // O(n) Space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar getCommon = function(nums1, nums2) {\\n  const set = new Set(nums1)\\n  let count = 0\\n\\n  for (let num of nums2) {\\n    if (set.has(num)) return num \\n  }\\n  return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getCommon = function(nums1, nums2) {\\n  const set = new Set(nums1)\\n  let count = 0\\n\\n  for (let num of nums2) {\\n    if (set.has(num)) return num \\n  }\\n  return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083099,
                "title": "cpp-easy-and-fast-solution-o-n",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will take two pointer say i and j  one at num1 and one at num2 and then we will se \\n #1. if num1[i]==num2[j] then return any ;\\n #2. will be if num1>num2 then we will increment j since then only we   will get close to num1 as both are sorted arrays \\n #3. else we will increase i pointer \\n# Complexity\\n- Time complexity: O(n+m);\\n- Space complexity: o(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(),m = nums2.size();\\n        int i = 0 , j =0 ;\\n        while(i< n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                return nums2[j];\\n            }\\n            else if(nums1[i]<nums2[j]){\\n               ++i;\\n            }else{\\n                ++j;\\n            } \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(),m = nums2.size();\\n        int i = 0 , j =0 ;\\n        while(i< n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                return nums2[j];\\n            }\\n            else if(nums1[i]<nums2[j]){\\n               ++i;\\n            }else{\\n                ++j;\\n            } \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082542,
                "title": "python3-one-liner-rust-three-liner-o-n",
                "content": "# Approach\\nCreate sets of `nums1` and `nums2`, get the intersection and get the minimum of this set. If the intersection is empty return the default -1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n## Python3\\nRuntime 457 ms\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        return min(set(nums1) & set(nums2), default=-1)\\n```\\n\\n## Rust\\nRuntime 16 ms\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let nums1: HashSet<_> = nums1.into_iter().collect();\\n        let nums2: HashSet<_> = nums2.into_iter().collect();\\n        *nums1.intersection(&nums2).min().unwrap_or(&-1)\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Rust",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        return min(set(nums1) & set(nums2), default=-1)\\n```\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let nums1: HashSet<_> = nums1.into_iter().collect();\\n        let nums2: HashSet<_> = nums2.into_iter().collect();\\n        *nums1.intersection(&nums2).min().unwrap_or(&-1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082342,
                "title": "simple-c-solution-using-map",
                "content": "# Approach\\nUse Map for one array and then map all values in second array with the value in map.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums1.size(); i++) {\\n            mp[nums1[i]]++;\\n        }\\n        for(int i=0; i<nums2.size(); i++) {\\n            if(mp[nums2[i]] > 0) {\\n                return nums2[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums1.size(); i++) {\\n            mp[nums1[i]]++;\\n        }\\n        for(int i=0; i<nums2.size(); i++) {\\n            if(mp[nums2[i]] > 0) {\\n                return nums2[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082215,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0,j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j])\\n                return nums1[i];\\n            else if(nums1[i] > nums2[j])\\n                j++;\\n            else\\n                i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0,j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j])\\n                return nums1[i];\\n            else if(nums1[i] > nums2[j])\\n                j++;\\n            else\\n                i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082153,
                "title": "c-easy-fastest-hash-table",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> mp;\\n        for(auto x : nums1) mp[x]++;\\n        for(auto x : nums2){\\n            if(mp.find(x) != mp.end()) return x;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nPlease UPVOTE if you find helpful.\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> mp;\\n        for(auto x : nums1) mp[x]++;\\n        for(auto x : nums2){\\n            if(mp.find(x) != mp.end()) return x;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082136,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        res=list(set(nums1)& set(nums2))\\n        if len(res)==0:\\n            return -1\\n        else:\\n            res.sort()\\n            return res[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        res=list(set(nums1)& set(nums2))\\n        if len(res)==0:\\n            return -1\\n        else:\\n            res.sort()\\n            return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082116,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nimpl Solution {\\n    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let (mut i, mut j) = (0, 0);\\n        \\n        while i < nums1.len() && j < nums2.len() {\\n            if nums1[i] == nums2[j] { return nums1[i] }\\n            \\n            if nums1[i] < nums2[j] { i += 1; }\\n            else { j += 1; }\\n        }\\n        \\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let (mut i, mut j) = (0, 0);\\n        \\n        while i < nums1.len() && j < nums2.len() {\\n            if nums1[i] == nums2[j] { return nums1[i] }\\n            \\n            if nums1[i] < nums2[j] { i += 1; }\\n            else { j += 1; }\\n        }\\n        \\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049805,
                "title": "simplest-for-java-beginner",
                "content": "# Intuition\\nIf you are new Java Learner this question and given solution will really help you.\\n\\n# Approach\\n***Make Hashset of int values acc to ques... Iterate through nums1 add 1st array into set...then Iterate through nums2 and check whether any same number contains in another array or not...then use of break statement coz if two same values are found but it will exit on first value which is lowest acc to ques...good luck...cheers***\\n# Complexity\\n- Time complexity:O(n); n is no. of elemnts in array\\n- Space complexity:O(n); as n is no. of elements of 1st array which we input in code\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer>set = new HashSet<>(); \\n        int result=-1;\\n        for(int num:nums1){\\n            set.add(num);\\n        }\\n        for(int num:nums2){\\n            if(set.contains(num)){\\n                result=num;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer>set = new HashSet<>(); \\n        int result=-1;\\n        for(int num:nums1){\\n            set.add(num);\\n        }\\n        for(int num:nums2){\\n            if(set.contains(num)){\\n                result=num;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048778,
                "title": "two-pointer-approach-in-c-o-m-n",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif both the numbers are equal break the loop\\nelse increment the index of smaller element\\n# Complexity\\n- Time complexity: O(M+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0, j = 0;\\n        int ans = -1;\\n\\n        while(i < nums1.size() && j < nums2.size()){\\n            if(nums1[i] == nums2[j]){ \\n                ans = nums1[i];\\n                break;\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0, j = 0;\\n        int ans = -1;\\n\\n        while(i < nums1.size() && j < nums2.size()){\\n            if(nums1[i] == nums2[j]){ \\n                ans = nums1[i];\\n                break;\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957151,
                "title": "c-simple-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetCommon(int[] nums1, int[] nums2) {\\n        int i = 0;\\n        int j =0;\\n        while(i<nums1.Length && j<nums2.Length)\\n        {\\n            if(nums1[i]==nums2[j])\\n            {\\n                return nums1[i];\\n            }else if(nums1[i]>nums2[j])\\n            {\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetCommon(int[] nums1, int[] nums2) {\\n        int i = 0;\\n        int j =0;\\n        while(i<nums1.Length && j<nums2.Length)\\n        {\\n            if(nums1[i]==nums2[j])\\n            {\\n                return nums1[i];\\n            }else if(nums1[i]>nums2[j])\\n            {\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911745,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int a=nums1.size();\\n        int b=nums2.size();\\n        int i=0;\\n        int j=0;\\n        int ans=-1;\\n        while(i<a&&j<b)\\n        {\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums2[j]>nums1[i])\\n                i++;\\n            else\\n            {\\n                ans=nums1[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int a=nums1.size();\\n        int b=nums2.size();\\n        int i=0;\\n        int j=0;\\n        int ans=-1;\\n        while(i<a&&j<b)\\n        {\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums2[j]>nums1[i])\\n                i++;\\n            else\\n            {\\n                ans=nums1[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882835,
                "title": "java-runtime-1ms-beats-97-81-simple-and-easy-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       int si=0;\\n       int ei=0;\\n       while(si<nums1.length && ei<nums2.length){\\n           if(nums1[si]==nums2[ei])\\n           return nums1[si];\\n           else if(nums1[si]>nums2[ei])\\n           ei++;\\n           else\\n           si++;\\n       }\\n       return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       int si=0;\\n       int ei=0;\\n       while(si<nums1.length && ei<nums2.length){\\n           if(nums1[si]==nums2[ei])\\n           return nums1[si];\\n           else if(nums1[si]>nums2[ei])\\n           ei++;\\n           else\\n           si++;\\n       }\\n       return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721709,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n\\n# Intuition\\nThe problem asks us to find the minimum integer common to two sorted arrays. We can use a two-pointer technique to compare the elements of the two arrays and find the first common integer.\\n\\n# Approach\\n1. Initialize two pointers `i` and `j` to 0, representing the current indices in `nums1` and `nums2`, respectively.\\n2. Initialize variables `n` and `m` to the lengths of `nums1` and `nums2`, respectively.\\n3. Use a while loop to iterate until either pointer reaches the end of its respective array.\\n4. If `nums1[i]` is less than `nums2[j]`, increment `i`.\\n5. If `nums1[i]` is greater than `nums2[j]`, increment `j`.\\n6. Otherwise, return `nums1[i]`.\\n7. If the loop terminates without finding a common integer, return -1.\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$, where $$n$$ and $$m$$ are the lengths of the two arrays.\\n- Space complexity: $$O(1)$$, as we only need constant extra space for the pointers and variables.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i,j = 0,0\\n        n,m = len(nums1), len(nums2)\\n        while i<n and j<m:\\n            if nums1[i]<nums2[j]:\\n                i+=1\\n            elif nums1[i]>nums2[j]:\\n                j+=1\\n            else:\\n                return nums1[i]\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i,j = 0,0\\n        n,m = len(nums1), len(nums2)\\n        while i<n and j<m:\\n            if nums1[i]<nums2[j]:\\n                i+=1\\n            elif nums1[i]>nums2[j]:\\n                j+=1\\n            else:\\n                return nums1[i]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558315,
                "title": "simple-solution-binary-search",
                "content": "# Intuition\\nThe provided code defines a class named Solution with a member function named getCommon. This function takes two vector parameters, nums1 and nums2, which represent sorted arrays. The purpose of this function is to find a common element between the two arrays.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code iterates over each element in nums1 using a for loop. For each element, it sets it as the target value and performs a binary search in nums2 to find the target value. The binary search is performed by maintaining two pointers, low and high, which represent the lower and upper bounds of the search range. The mid-point is calculated as the average of low and high, and the value at the mid-point in nums2 is compared with the target value. Based on the comparison, the search range is adjusted by updating either low or high. If the target value is found, it is returned immediately.\\n\\nIf no common element is found after searching through all elements in nums1, the function returns -1.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(MlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n      for (int i = 0 ; i < nums1.size();i++)\\n      {\\n          int target = nums1[i];\\n          int low = 0 , high = nums2.size()-1, mid =0;\\n          while(high>=low)\\n          {\\n            mid = high + (low-high)/2;\\n            if(nums2[mid] == target)\\n            {\\n                return target;\\n            }\\n            else if (nums2[mid]>target) high = mid - 1;\\n            else low = mid + 1;\\n          }\\n         \\n      }  \\n       return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n      for (int i = 0 ; i < nums1.size();i++)\\n      {\\n          int target = nums1[i];\\n          int low = 0 , high = nums2.size()-1, mid =0;\\n          while(high>=low)\\n          {\\n            mid = high + (low-high)/2;\\n            if(nums2[mid] == target)\\n            {\\n                return target;\\n            }\\n            else if (nums2[mid]>target) high = mid - 1;\\n            else low = mid + 1;\\n          }\\n         \\n      }  \\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469569,
                "title": "two-pointer-approach-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        p1=0\\n        p2=0\\n        while p1<len(nums1) and p2<len(nums2):\\n            if nums1[p1]<nums2[p2]:\\n                p1+=1\\n            elif nums1[p1]>nums2[p2]:\\n                p2+=1\\n            else:\\n                return nums1[p1]\\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        p1=0\\n        p2=0\\n        while p1<len(nums1) and p2<len(nums2):\\n            if nums1[p1]<nums2[p2]:\\n                p1+=1\\n            elif nums1[p1]>nums2[p2]:\\n                p2+=1\\n            else:\\n                return nums1[p1]\\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374392,
                "title": "simple-understandable-binary-search",
                "content": "# Approach\\nSince the arrrays are sorted in **non-decreasing** order, therefore we can use **Binary Search** to solve this problem.\\n\\nWe use **Binary Search** to find the number while traversing the nums1 and judge whether it exist in nums2 array or not, if we find it, just return it as it is the target; **else if the number is biger than the nums2[m], we enlarge the left side, otherwise narrow the right side.**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int len2 = nums2.size() - 1;\\n        for (int num : nums1) {\\n            int l = 0, r = len2;\\n            while (l <= r) {\\n                int m = l + (r - l) / 2;\\n                if (nums2[m] == num) {\\n                    return num;\\n                } else if (nums2[m] < num) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return -1;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int len2 = nums2.size() - 1;\\n        for (int num : nums1) {\\n            int l = 0, r = len2;\\n            while (l <= r) {\\n                int m = l + (r - l) / 2;\\n                if (nums2[m] == num) {\\n                    return num;\\n                } else if (nums2[m] < num) {\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n        }\\n        return -1;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341442,
                "title": "c-two-pointer-halwa-xd",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        //here we use two pointer approach\\n        int s = 0, e = 0;\\n        while(s<nums1.size() && e<nums2.size()){\\n            if(nums1[s] == nums2[e])return nums1[s];\\n            else if(nums1[s]<nums2[e]) s++;\\n            else e++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        //here we use two pointer approach\\n        int s = 0, e = 0;\\n        while(s<nums1.size() && e<nums2.size()){\\n            if(nums1[s] == nums2[e])return nums1[s];\\n            else if(nums1[s]<nums2[e]) s++;\\n            else e++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307973,
                "title": "2-easy-approaches-must-see",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0,j = 0;\\n\\n        while(i < n && j < m)\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i] > nums2[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n\\n```\\n\\n\\n\\n# Approach-2\\nStep-1 : Create a HashMap that is used to store the elements of nums1 array.\\n\\nStep-2 : Store nums1 element in the HashMap.\\n\\nStep-3 : If nums2 element found in the HashMap then return that else return -1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        \\n        // Creating a HashMap\\n        HashMap<Integer , Integer> map = new HashMap<Integer , Integer>();\\n\\n        // Storing Frequency of the elements of nums1 in the HashMap\\n        for (int i = 0; i < nums1.length ; i++) {\\n\\n            map.put(nums1[i] , 1);\\n        }\\n        \\n        // Initializing ans by -1.\\n        int ans = -1;\\n\\n        for (int i = 0; i < nums2.length ; i++) {\\n            \\n            // is nums2[i] present in the map \\n            if (map.containsKey (nums2[i])) {\\n\\n                ans = nums2[i];\\n                return ans;\\n            }\\n        }\\n        \\n        // No Common Elements btw nums1 and nums2.\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0,j = 0;\\n\\n        while(i < n && j < m)\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i] > nums2[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n\\n```\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        \\n        // Creating a HashMap\\n        HashMap<Integer , Integer> map = new HashMap<Integer , Integer>();\\n\\n        // Storing Frequency of the elements of nums1 in the HashMap\\n        for (int i = 0; i < nums1.length ; i++) {\\n\\n            map.put(nums1[i] , 1);\\n        }\\n        \\n        // Initializing ans by -1.\\n        int ans = -1;\\n\\n        for (int i = 0; i < nums2.length ; i++) {\\n            \\n            // is nums2[i] present in the map \\n            if (map.containsKey (nums2[i])) {\\n\\n                ans = nums2[i];\\n                return ans;\\n            }\\n        }\\n        \\n        // No Common Elements btw nums1 and nums2.\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297843,
                "title": "beat-97-56-443ms-set-operation",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        if max(nums1) < min(nums2): return -1\\n        else:\\n            return min(set(nums1) & set(nums2)) if(set(nums1) & set(nums2)) else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        if max(nums1) < min(nums2): return -1\\n        else:\\n            return min(set(nums1) & set(nums2)) if(set(nums1) & set(nums2)) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281201,
                "title": "98-fastest-solution-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int i=0, j=0;\\n    while(i<nums1Size && j<nums2Size){\\n        if(nums1[i]==nums2[j]){\\n            return nums1[i];\\n        }\\n        else if(nums1[i]<nums2[j]){\\n            i++;\\n        }\\n        else{\\n            j++;\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int i=0, j=0;\\n    while(i<nums1Size && j<nums2Size){\\n        if(nums1[i]==nums2[j]){\\n            return nums1[i];\\n        }\\n        else if(nums1[i]<nums2[j]){\\n            i++;\\n        }\\n        else{\\n            j++;\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3249073,
                "title": "binary-search-solution-in-java-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Upvote\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n![4q0zf1.jpg](https://assets.leetcode.com/users/images/6c0b1c25-f2e4-4fba-9de6-e87c2ea7eec6_1677784640.6219244.jpeg)\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       int s=-1;\\n       int l=0;\\n       int h=nums2.length-1;\\n       for(int i=0;i<nums1.length;i++)\\n       {\\n           l=0;\\n           h=nums2.length-1;\\n           \\n           while(l<=h)\\n           {\\n               int mid=l+(h-l)/2;\\n               if(nums2[mid]==nums1[i])\\n               {\\n                   s=nums1[i];\\n                   break;\\n               }\\n               else if(nums2[mid]>nums1[i])\\n               {\\n                   h=mid-1;\\n               }\\n               else\\n               {\\n                   l=mid+1;\\n               }\\n           }\\n           if(s>-1)\\n           {\\n               break;\\n           }\\n       }\\n       return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       int s=-1;\\n       int l=0;\\n       int h=nums2.length-1;\\n       for(int i=0;i<nums1.length;i++)\\n       {\\n           l=0;\\n           h=nums2.length-1;\\n           \\n           while(l<=h)\\n           {\\n               int mid=l+(h-l)/2;\\n               if(nums2[mid]==nums1[i])\\n               {\\n                   s=nums1[i];\\n                   break;\\n               }\\n               else if(nums2[mid]>nums1[i])\\n               {\\n                   h=mid-1;\\n               }\\n               else\\n               {\\n                   l=mid+1;\\n               }\\n           }\\n           if(s>-1)\\n           {\\n               break;\\n           }\\n       }\\n       return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223669,
                "title": "two-pointer-c-easy-to-understand",
                "content": "\\n\\nSimple two pointer approach. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size(),i=0,j=0;\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j])return nums1[i]; //if values are equal return it\\n            else if(nums1[i]>nums2[j])j++; //if nums1[i] is greater so for nums2[j] will take more iterations to reach a value equal or greater than it\\n            else i++;//if nums2[j] is greater so for nums1[i] will take more iterations to reach a value equal or greater than it\\n        }\\n        return -1;//not found\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size(),i=0,j=0;\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j])return nums1[i]; //if values are equal return it\\n            else if(nums1[i]>nums2[j])j++; //if nums1[i] is greater so for nums2[j] will take more iterations to reach a value equal or greater than it\\n            else i++;//if nums2[j] is greater so for nums1[i] will take more iterations to reach a value equal or greater than it\\n        }\\n        return -1;//not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160073,
                "title": "js-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n    const set = new Set(nums1);\\n    const common = nums2.filter(n => set.has(n)).sort((a,b) => a - b)[0];\\n    \\n    return common !== undefined ? common : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n    const set = new Set(nums1);\\n    const common = nums2.filter(n => set.has(n)).sort((a,b) => a - b)[0];\\n    \\n    return common !== undefined ? common : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3145775,
                "title": "easy-to-understand-beginner-friendly-solution-using-binary-search",
                "content": "# Intuition\\nFor every element in first vector we want to know if this element is in a second vector. We can check it in an efficient wat using binary search.\\n\\n# Approach\\nIterate over one vector and for every element in it check if there is corresponding value in the second array. If yes, return it. If the value haven\\'t been found for any element of first array return -1.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogm) n - size of the first array, m - size of the  second array.\\n\\n- Space complexity:\\nO(1) There is no need for addicional space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& A, int target){\\n\\n        int l = 0; int p = A.size()-1;\\n        int s;\\n        while(l<p){\\n            s = (l+p)/2;\\n            if(A[s] < target){\\n                l = s+1;\\n            }else{\\n                p = s;\\n            }\\n        }\\n        return l;\\n    }\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        for(int i = 0; i < nums1.size(); i++){\\n            int index = bs(nums2, nums1[i]);\\n            if(nums2[index] == nums1[i])\\n            return nums1[i];\\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& A, int target){\\n\\n        int l = 0; int p = A.size()-1;\\n        int s;\\n        while(l<p){\\n            s = (l+p)/2;\\n            if(A[s] < target){\\n                l = s+1;\\n            }else{\\n                p = s;\\n            }\\n        }\\n        return l;\\n    }\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        for(int i = 0; i < nums1.size(); i++){\\n            int index = bs(nums2, nums1[i]);\\n            if(nums2[index] == nums1[i])\\n            return nums1[i];\\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142966,
                "title": "using-hashset-rust",
                "content": "\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n         use std::collections::HashSet;\\n\\n        let s1 = nums1.into_iter().collect::<HashSet<_>>();\\n\\n        let s2 = nums2.into_iter().collect::<HashSet<_>>();\\n\\n        let mut res = s1.intersection(&s2).into_iter().map(|e| *e).collect::<Vec<_>>();\\n        res.sort();\\n\\n        if res.is_empty() {\\n            return -1;\\n        } else {\\n            return res[0];\\n        }\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n         use std::collections::HashSet;\\n\\n        let s1 = nums1.into_iter().collect::<HashSet<_>>();\\n\\n        let s2 = nums2.into_iter().collect::<HashSet<_>>();\\n\\n        let mut res = s1.intersection(&s2).into_iter().map(|e| *e).collect::<Vec<_>>();\\n        res.sort();\\n\\n        if res.is_empty() {\\n            return -1;\\n        } else {\\n            return res[0];\\n        }\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3117555,
                "title": "python-two-pointers",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        l, r = 0, 0\\n\\n        while l < len(nums1) and r < len(nums2):\\n            if nums1[l] < nums2[r]:\\n                l += 1\\n            elif nums1[l] > nums2[r]:\\n                r += 1\\n            else:\\n                return nums1[l]\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        l, r = 0, 0\\n\\n        while l < len(nums1) and r < len(nums2):\\n            if nums1[l] < nums2[r]:\\n                l += 1\\n            elif nums1[l] > nums2[r]:\\n                r += 1\\n            else:\\n                return nums1[l]\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110267,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = -1;\\n        priority_queue <int, vector<int>, greater<int> > pq1;\\n        priority_queue <int, vector<int>, greater<int> > pq2;\\n        for(int i = 0; i < nums1.size(); i++) {\\n            pq1.push(nums1[i]);\\n        }\\n        for(int j = 0; j < nums2.size(); j++) {\\n            pq2.push(nums2[j]);\\n        }\\n        while(!pq1.empty() && !pq2.empty()) {\\n            if(pq1.top() == pq2.top()) {\\n                ans = pq1.top();\\n                pq1.pop();\\n                pq2.pop();\\n                break;\\n            }\\n            else if(pq1.top() < pq2.top()) {\\n                pq1.pop();\\n            }\\n            else {\\n                pq2.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = -1;\\n        priority_queue <int, vector<int>, greater<int> > pq1;\\n        priority_queue <int, vector<int>, greater<int> > pq2;\\n        for(int i = 0; i < nums1.size(); i++) {\\n            pq1.push(nums1[i]);\\n        }\\n        for(int j = 0; j < nums2.size(); j++) {\\n            pq2.push(nums2[j]);\\n        }\\n        while(!pq1.empty() && !pq2.empty()) {\\n            if(pq1.top() == pq2.top()) {\\n                ans = pq1.top();\\n                pq1.pop();\\n                pq2.pop();\\n                break;\\n            }\\n            else if(pq1.top() < pq2.top()) {\\n                pq1.pop();\\n            }\\n            else {\\n                pq2.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107088,
                "title": "explained-and-commented-kotlin-solution",
                "content": "The function uses the intersect method available in kotlin, which returns a new set containing only the elements that are contained by both this set and the specified collection.\\n\\nThen it is using the min() function which returns the smallest element or null if there are no elements, and the elvis operator (?:) which returns the left-hand side operand if it isn\\'t null, otherwise it returns the right-hand side operand. Here, it is returning -1 if the result of min() is null, otherwise it returns the minimum element of the intersection set.\\n\\n```\\nclass Solution {\\n    // Define a function to find the smallest common element in two arrays\\n    fun getCommon(nums1: IntArray, nums2: IntArray) : Int {\\n        // Find the intersection of the two arrays and convert nums2 to a set\\n        // Intersection returns a new set containing only the elements that are contained by both this set and the specified collection\\n        val intersection = nums1.intersect(nums2.toSet())\\n        // Find the smallest element in the intersection set\\n        val min = intersection.min()\\n        // If min is null, return -1\\n        // Else, return the minimum element of the intersection set\\n        return min ?: -1\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    // Define a function to find the smallest common element in two arrays\\n    fun getCommon(nums1: IntArray, nums2: IntArray) : Int {\\n        // Find the intersection of the two arrays and convert nums2 to a set\\n        // Intersection returns a new set containing only the elements that are contained by both this set and the specified collection\\n        val intersection = nums1.intersect(nums2.toSet())\\n        // Find the smallest element in the intersection set\\n        val min = intersection.min()\\n        // If min is null, return -1\\n        // Else, return the minimum element of the intersection set\\n        return min ?: -1\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104378,
                "title": "c-two-pointers-faster-easy-to-understand",
                "content": "* ***Using Two Pointers***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        int i = 0;\\n        \\n        int j = 0;\\n        \\n        while(i < n1 && j < n2)\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i] < nums2[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        int i = 0;\\n        \\n        int j = 0;\\n        \\n        while(i < n1 && j < n2)\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i] < nums2[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093600,
                "title": "c-hash-table-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int>m;\\n        for(int i=0; i<nums1.size(); i++){\\n            m[nums1[i]]++;\\n        }\\n        for(int i=0; i<nums2.size(); i++){\\n            if(m.find(nums2[i])!=m.end()){\\n                return nums2[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int>m;\\n        for(int i=0; i<nums1.size(); i++){\\n            m[nums1[i]]++;\\n        }\\n        for(int i=0; i<nums2.size(); i++){\\n            if(m.find(nums2[i])!=m.end()){\\n                return nums2[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086687,
                "title": "java-3ms",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int l=0;int h=0;\\n        \\n        while(l<nums1.length && h<nums2.length){\\n            if(nums1[l]==nums2[h]){\\n                return nums1[l];\\n            }\\n            else{\\n                if(nums1[l]<nums2[h]){\\n                    l++;\\n                }\\n                else{\\n                    h++;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int l=0;int h=0;\\n        \\n        while(l<nums1.length && h<nums2.length){\\n            if(nums1[l]==nums2[h]){\\n                return nums1[l];\\n            }\\n            else{\\n                if(nums1[l]<nums2[h]){\\n                    l++;\\n                }\\n                else{\\n                    h++;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086268,
                "title": "simple-cpp-datta-bayo",
                "content": "Easy Approach just keeping track of numbers by giving bool values we must know about the point that default values in map for bool is false.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,bool>mp1;\\n        for(auto it : nums1)\\n        {\\n            mp1[it]=true;\\n        }\\n        for(auto it : nums2)\\n        {\\n            if(mp1[it]==true)\\n            {\\n                return it;\\n            }\\n        }\\n        return -1;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,bool>mp1;\\n        for(auto it : nums1)\\n        {\\n            mp1[it]=true;\\n        }\\n        for(auto it : nums2)\\n        {\\n            if(mp1[it]==true)\\n            {\\n                return it;\\n            }\\n        }\\n        return -1;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086246,
                "title": "python-easy-soln-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   Hashmap\\n\\n# Complexity\\n- Time complexity:\\n-                    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n-                    O(n)\\n- \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums2=Counter(nums2)\\n        l=[]\\n        for i in nums1:\\n            if i in nums2:\\n                l.append(i)\\n        if l:\\n            return min(l)\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums2=Counter(nums2)\\n        l=[]\\n        for i in nums1:\\n            if i in nums2:\\n                l.append(i)\\n        if l:\\n            return min(l)\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085242,
                "title": "go-clean-solution-two-pointers",
                "content": "**Time complexity**: O(n+m) time, because we iterate over both arrays\\n**Space complexity**: O(1) space, because we don\\'t need extra space, only two pointers\\n\\nEnjoy:\\n```\\nfunc getCommon(nums1 []int, nums2 []int) int {\\n  i := 0\\n  j := 0\\n  \\n  for i != len(nums1)-1 || j != len(nums2)-1 {\\n    if nums1[i] == nums2[j] {\\n      return nums1[i]\\n    }\\n    \\n    if i == len(nums1)-1 || nums1[i] > nums2[j] {\\n      j++\\n    } else if j == len(nums2)-1 || nums1[i] < nums2[j] {\\n      i++\\n    }\\n  }\\n  \\n  if nums1[i] == nums2[j] {\\n    return nums1[i]\\n  }\\n  \\n  return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\nfunc getCommon(nums1 []int, nums2 []int) int {\\n  i := 0\\n  j := 0\\n  \\n  for i != len(nums1)-1 || j != len(nums2)-1 {\\n    if nums1[i] == nums2[j] {\\n      return nums1[i]\\n    }\\n    \\n    if i == len(nums1)-1 || nums1[i] > nums2[j] {\\n      j++\\n    } else if j == len(nums2)-1 || nums1[i] < nums2[j] {\\n      i++\\n    }\\n  }\\n  \\n  if nums1[i] == nums2[j] {\\n    return nums1[i]\\n  }\\n  \\n  return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084942,
                "title": "easy-to-understand-c-solution",
                "content": "```\\n\\tclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0, j = 0, m = nums1.size(),n = nums2.size();\\n        while(i<m&&j<n){\\n            if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }else if(nums1[i]>nums2[j]){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0, j = 0, m = nums1.size(),n = nums2.size();\\n        while(i<m&&j<n){\\n            if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }else if(nums1[i]>nums2[j]){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084863,
                "title": "easy-approach",
                "content": "\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i,j=0,0\\n        while(i<len(nums1) and j<len(nums2)):\\n            if(nums1[i]==nums2[j]):\\n                return nums1[i]\\n            elif(nums1[i]<nums2[j]):\\n                i+=1\\n            else:\\n                j+=1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i,j=0,0\\n        while(i<len(nums1) and j<len(nums2)):\\n            if(nums1[i]==nums2[j]):\\n                return nums1[i]\\n            elif(nums1[i]<nums2[j]):\\n                i+=1\\n            else:\\n                j+=1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084354,
                "title": "c-100-faster-3-lines",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& n1, vector<int>& n2, int i1 = 0, int i2 = 0) {\\n        while (i1 < n1.size() && i2 < n2.size()) {\\n            if (n1[i1] == n2[i2]) return n1[i1];\\n            else if (n1[i1] > n2[i2]) i2++;\\n            else i1++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& n1, vector<int>& n2, int i1 = 0, int i2 = 0) {\\n        while (i1 < n1.size() && i2 < n2.size()) {\\n            if (n1[i1] == n2[i2]) return n1[i1];\\n            else if (n1[i1] > n2[i2]) i2++;\\n            else i1++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082776,
                "title": "c-very-simple-maps-solution-one-map-only",
                "content": "In this question, we just have to get the common value that is minimum. So, the most optimal way to search for element is using a HashMap->\\n\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]=i;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums2.size();i++){\\n            if(m.count(nums2[i])){\\n                ans=min(ans,nums2[i]);\\n            }\\n        }\\n        return (ans==INT_MAX)? -1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]=i;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums2.size();i++){\\n            if(m.count(nums2[i])){\\n                ans=min(ans,nums2[i]);\\n            }\\n        }\\n        return (ans==INT_MAX)? -1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082399,
                "title": "java-simple-treeset-solution-have-a-look",
                "content": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer> treeset1 = new TreeSet<>();\\n        Set<Integer> treeset2 = new TreeSet<>();\\n        //Put the numbers in the sets\\n        for(int num : nums1){\\n            treeset1.add(num);\\n        }\\n        \\n        for(int num : nums2){\\n            treeset2.add(num);\\n        }\\n        //iterate any set and if we find the same number in the other set, we return that\\n\\t\\t//Here since it is a treeset, we are starting from the smallest number itself.\\n        for(Integer num : treeset1){\\n            if(treeset2.contains(num)){\\n                return num;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer> treeset1 = new TreeSet<>();\\n        Set<Integer> treeset2 = new TreeSet<>();\\n        //Put the numbers in the sets\\n        for(int num : nums1){\\n            treeset1.add(num);\\n        }\\n        \\n        for(int num : nums2){\\n            treeset2.add(num);\\n        }\\n        //iterate any set and if we find the same number in the other set, we return that\\n\\t\\t//Here since it is a treeset, we are starting from the smallest number itself.\\n        for(Integer num : treeset1){\\n            if(treeset2.contains(num)){\\n                return num;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082227,
                "title": "simplest-python-two-liner",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        st = set(nums1) & set(nums2)\\n        return min(st) if len(st) else -1\\n```\\nWe can also return a one liner solution just for fun which is basically the same code:\\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        return min(set(nums1) & set(nums2)) if len(set(nums1) & set(nums2)) else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        st = set(nums1) & set(nums2)\\n        return min(st) if len(st) else -1\\n```\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        return min(set(nums1) & set(nums2)) if len(set(nums1) & set(nums2)) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082181,
                "title": "simplest-c-o-n-solution-using-hashing",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will traverse the nums1 and store the presence of every element in a HashMap. Then we will traverse the num2 and check if the current element is present in the HashMap or not, if it is presentthen current element is the  minimum common value as the arrays are sorted in non-increasing order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size(), n2=nums2.size();\\n        unordered_map<int,bool> hash;\\n        for(int i=0 ; i<n1 ; i++)\\n            hash[nums1[i]]=true;\\n        for(int j=0 ; j<n2 ; j++)\\n        {\\n            if(hash.find(nums2[j]) != hash.end())\\n                return nums2[j];\\n        }   \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size(), n2=nums2.size();\\n        unordered_map<int,bool> hash;\\n        for(int i=0 ; i<n1 ; i++)\\n            hash[nums1[i]]=true;\\n        for(int j=0 ; j<n2 ; j++)\\n        {\\n            if(hash.find(nums2[j]) != hash.end())\\n                return nums2[j];\\n        }   \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082166,
                "title": "4-lines-easy-c-binarysearch",
                "content": "just look for element in nums2 via binary search.\\n```\\nint getCommon(vector<int>& nums1, vector<int>& nums2) \\n{\\n    for(int i=0;i<nums1.size();i++)\\n    {\\n        if(binary_search(nums2.begin(),nums2.end(),nums1[i]))\\n        {\\n            return nums1[i];\\n        }\\n    }        \\n    return -1; \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint getCommon(vector<int>& nums1, vector<int>& nums2) \\n{\\n    for(int i=0;i<nums1.size();i++)\\n    {\\n        if(binary_search(nums2.begin(),nums2.end(),nums1[i]))\\n        {\\n            return nums1[i];\\n        }\\n    }        \\n    return -1; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082118,
                "title": "easy-short-efficient-clean-code",
                "content": "```c++\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int getCommon(vector<int>&u, vector<int>&v) {\\n        unordered_set<ll>ust;\\n        for(ll it:u){\\n            ust.insert(it);\\n        }\\n        for(ll it:v){\\n            if(ust.find(it)!=end(ust)){\\n                return it;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int getCommon(vector<int>&u, vector<int>&v) {\\n        unordered_set<ll>ust;\\n        for(ll it:u){\\n            ust.insert(it);\\n        }\\n        for(ll it:v){\\n            if(ust.find(it)!=end(ust)){\\n                return it;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082078,
                "title": "python-simple-python-solution-using-binary-search",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 2298 ms, faster than 12.50% of Python3 online submissions for Minimum Common Value.\\n# Memory Usage: 32.4 MB, less than 100.00% of Python3 online submissions for Minimum Common Value.\\n\\n\\tclass Solution:\\n\\t\\tdef getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\t\\t\\tdef BinarySearch(start, end, target):\\n\\n\\t\\t\\t\\twhile start <= end:\\n\\n\\t\\t\\t\\t\\tmid = (start + end) // 2\\n\\n\\t\\t\\t\\t\\tif target == nums2[mid]:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\telif nums2[mid] < target:\\n\\t\\t\\t\\t\\t\\tstart = mid + 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tend = mid - 1\\n\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tstart = 0\\n\\t\\t\\tend = len(nums2)\\n\\n\\t\\t\\tfor num in nums1:\\n\\n\\t\\t\\t\\tif BinarySearch(start, end, num) == True:\\n\\t\\t\\t\\t\\treturn num\\n\\n\\t\\t\\treturn -1\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 2298 ms, faster than 12.50% of Python3 online submissions for Minimum Common Value.\\n# Memory Usage: 32.4 MB, less than 100.00% of Python3 online submissions for Minimum Common Value.\\n\\n\\tclass Solution:\\n\\t\\tdef getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\t\\t\\tdef BinarySearch(start, end, target):\\n\\n\\t\\t\\t\\twhile start <= end:\\n\\n\\t\\t\\t\\t\\tmid = (start + end) // 2\\n\\n\\t\\t\\t\\t\\tif target == nums2[mid]:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\telif nums2[mid] < target:\\n\\t\\t\\t\\t\\t\\tstart = mid + 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tend = mid - 1\\n\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tstart = 0\\n\\t\\t\\tend = len(nums2)\\n\\n\\t\\t\\tfor num in nums1:\\n\\n\\t\\t\\t\\tif BinarySearch(start, end, num) == True:\\n\\t\\t\\t\\t\\treturn num\\n\\n\\t\\t\\treturn -1\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3082063,
                "title": "using-hashmap-easy-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Maps/HashMaps\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse over the first array and store the array elements in the Map.\\nNow traverse over the second array and check if it exist in map.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // remember the arrays are sorted (Given)\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++){\\n            // storing the values of nums1 in map\\n            m[nums1[i]]++;\\n        }\\n        int ans=-1;\\n        // now intialise the ans as -1; \\n        for(int i=0;i<nums2.size();i++){\\n            // traverse the nums2\\n            if(m[nums2[i]]){\\n            // if nums2[i] is present in the map(foundThe Element) \\n                ans=nums2[i]; // store in ans\\n                break;\\n            }\\n        }\\n        // remember the arrays are sorted\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // remember the arrays are sorted (Given)\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++){\\n            // storing the values of nums1 in map\\n            m[nums1[i]]++;\\n        }\\n        int ans=-1;\\n        // now intialise the ans as -1; \\n        for(int i=0;i<nums2.size();i++){\\n            // traverse the nums2\\n            if(m[nums2[i]]){\\n            // if nums2[i] is present in the map(foundThe Element) \\n                ans=nums2[i]; // store in ans\\n                break;\\n            }\\n        }\\n        // remember the arrays are sorted\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082011,
                "title": "c-binary-search-o-n-log-n",
                "content": "\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size(), lo = 0, hi = n - 1;\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] == target) return true;\\n            else if(nums[mid] > target) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            if(search(nums2, nums1[i])) return nums1[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int n = nums.size(), lo = 0, hi = n - 1;\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] == target) return true;\\n            else if(nums[mid] > target) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            if(search(nums2, nums1[i])) return nums1[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098128,
                "title": "simple-solution-using-iter",
                "content": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        it1, it2 = iter(nums1), iter(nums2)\\n        n1, n2 = next(it1), next(it2)\\n        while n1 > 0 and n2 > 0:\\n            if n1 < n2:\\n                n1 = next(it1, -1)\\n            elif n1 > n2:\\n                n2 = next(it2, -1)\\n            else:\\n                return n1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        it1, it2 = iter(nums1), iter(nums2)\\n        n1, n2 = next(it1), next(it2)\\n        while n1 > 0 and n2 > 0:\\n            if n1 < n2:\\n                n1 = next(it1, -1)\\n            elif n1 > n2:\\n                n2 = next(it2, -1)\\n            else:\\n                return n1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097678,
                "title": "very-simple-solutions-for-beginners",
                "content": "# Intuition\\nHashSet dont Store Duplicate\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer>mp=new HashSet<>();\\n        for(int ele:nums1){\\n            mp.add(ele);\\n        }\\n        for(int ele:nums2){\\n            if(mp.contains(ele)){\\n                return ele;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer>mp=new HashSet<>();\\n        for(int ele:nums1){\\n            mp.add(ele);\\n        }\\n        for(int ele:nums2){\\n            if(mp.contains(ele)){\\n                return ele;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095335,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = set(nums1).intersection(set(nums2))\\n        return min(n) if n else -1 \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = set(nums1).intersection(set(nums2))\\n        return min(n) if n else -1 \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090936,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] n1, int[] n2) {\\n        int i=0,j=0;\\n        while(i<n1.length && j<n2.length){\\n            if(n1[i]==n2[j]){\\n                return n1[i];\\n            }else if(n1[i]>n2[j]){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] n1, int[] n2) {\\n        int i=0,j=0;\\n        while(i<n1.length && j<n2.length){\\n            if(n1[i]==n2[j]){\\n                return n1[i];\\n            }else if(n1[i]>n2[j]){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079944,
                "title": "runtime-beats-97-31-of-users-and-memory-beats-51-08-of-users-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        re=sorted(list(set(nums1).intersection(nums2)))\\n        if len(re):\\n            return re[0]\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        re=sorted(list(set(nums1).intersection(nums2)))\\n        if len(re):\\n            return re[0]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074791,
                "title": "75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\nlet y=nums1.concat(nums2).sort((a,b)=>a-b);\\n    \\n    for(let i=0;i<y.length;i++){\\n        if(y[i]==y[i+1] && nums1.includes(y[i])&& nums2.includes(y[i])){\\n          return y[i]\\n        }\\n    }\\n\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\nlet y=nums1.concat(nums2).sort((a,b)=>a-b);\\n    \\n    for(let i=0;i<y.length;i++){\\n        if(y[i]==y[i+1] && nums1.includes(y[i])&& nums2.includes(y[i])){\\n          return y[i]\\n        }\\n    }\\n\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070470,
                "title": "o-min-n-m-solution-easy-approach-leetcode-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the arrays are already sorted so just compare with i,j variable and increment if i if nums1[i]<nums2[j] or viceversa.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Just Compare by two pointer variable and if found equal then return that number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(min(nums1.size(),nums2.size()))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n            O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int cnt=-1;\\n            int i=0,j=0;\\n            while(i<nums1.size()&&j<nums2.size()){\\n                if(nums1[i]==nums2[j]){\\n                cnt = nums1[i];\\n                break;\\n                i++;\\n                j++;\\n                \\n                }\\n                else if(nums1[i]>nums2[j])j++;\\n                else if(nums1[i]<nums2[j])i++;\\n            }\\n            return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int cnt=-1;\\n            int i=0,j=0;\\n            while(i<nums1.size()&&j<nums2.size()){\\n                if(nums1[i]==nums2[j]){\\n                cnt = nums1[i];\\n                break;\\n                i++;\\n                j++;\\n                \\n                }\\n                else if(nums1[i]>nums2[j])j++;\\n                else if(nums1[i]<nums2[j])i++;\\n            }\\n            return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062075,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num1 : nums1){\\n            set.add(num1);\\n        }\\n        int result = Integer.MIN_VALUE;\\n        for(int num2 : nums2){\\n            if(set.contains(num2)){\\n                result = num2;\\n                break;\\n            }\\n        }\\n        return result == Integer.MIN_VALUE ? -1 : result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num1 : nums1){\\n            set.add(num1);\\n        }\\n        int result = Integer.MIN_VALUE;\\n        for(int num2 : nums2){\\n            if(set.contains(num2)){\\n                result = num2;\\n                break;\\n            }\\n        }\\n        return result == Integer.MIN_VALUE ? -1 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060589,
                "title": "solutions-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1=set(nums1)\\n        s2=set(nums2)\\n        final=s1.intersection(s2)\\n        li=list(final)\\n        if len(li)>0:\\n            return min(li)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1=set(nums1)\\n        s2=set(nums2)\\n        final=s1.intersection(s2)\\n        li=list(final)\\n        if len(li)>0:\\n            return min(li)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058119,
                "title": "92-runtime-90-memory-two-pointer-intresting-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/56191ea0-5505-41ab-a0dc-a2960d0d4c9d_1695009550.4518816.png)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1, n2, l, r = len(nums1), len(nums2), 0, 0\\n\\n        while r < n2 and l < n1:\\n            left, right = nums1[l], nums2[r]\\n\\n            if left == right: return left\\n            elif left > right: r += 1\\n            else: l += 1\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1, n2, l, r = len(nums1), len(nums2), 0, 0\\n\\n        while r < n2 and l < n1:\\n            left, right = nums1[l], nums2[r]\\n\\n            if left == right: return left\\n            elif left > right: r += 1\\n            else: l += 1\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058065,
                "title": "simple-python-beats-96",
                "content": "Code:\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        i,j = 0,0\\n\\n        if nums1[-1] < nums2[0]:\\n            return -1\\n        if nums2[-1] < nums1[0]:\\n            return -1\\n\\n        while (i < len(nums1) and j<len(nums2)):\\n            if nums1[i] == nums2[j]:\\n                return nums1[i]\\n            elif nums1[i] > nums2[j]:\\n                j = j+1\\n            else:\\n                i = i+1\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        i,j = 0,0\\n\\n        if nums1[-1] < nums2[0]:\\n            return -1\\n        if nums2[-1] < nums1[0]:\\n            return -1\\n\\n        while (i < len(nums1) and j<len(nums2)):\\n            if nums1[i] == nums2[j]:\\n                return nums1[i]\\n            elif nums1[i] > nums2[j]:\\n                j = j+1\\n            else:\\n                i = i+1\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051705,
                "title": "very-simple-using-hashmap-using-2-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n***Approach 1***:using HashMap--->time & space complexity O(n)\\n    public int getCommon(int[] nums1, int[] nums2) {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    for(int i=0;i<nums1.length;i++){\\n        map.put(nums1[i],i+1);\\n    }\\n    for(int i:nums2){\\n        if(map.containsKey(i))return i;\\n    }\\n        return -1;\\n\\n---\\n\\n# ***Approach 2***:using 2 pointer --->time complexity:O(n)& space complexity:O(1);\\n\\n    int i=0,j=0;\\n    while(i<nums1.length&&j<nums2.length){\\n        if(nums1[i]==nums2[j])return nums1[i];\\n        else if(nums1[i]>nums2[j])j++;\\n        else i++;\\n        }\\n    return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\n***Approach 1***:using HashMap--->time & space complexity O(n)\\n    public int getCommon(int[] nums1, int[] nums2) {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    for(int i=0;i<nums1.length;i++){\\n        map.put(nums1[i],i+1);\\n    }\\n    for(int i:nums2){\\n        if(map.containsKey(i))return i;\\n    }\\n        return -1;\\n\\n---\\n\\n# ***Approach 2***:using 2 pointer --->time complexity:O(n)& space complexity:O(1);\\n\\n    int i=0,j=0;\\n    while(i<nums1.length&&j<nums2.length){\\n        if(nums1[i]==nums2[j])return nums1[i];\\n        else if(nums1[i]>nums2[j])j++;\\n        else i++;\\n        }\\n    return -1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050307,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use Two pointer Approach. It is very simple approach.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    0(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0;\\n        int j=0;\\n      \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            if(nums1[i] == nums2[j]){\\n                return nums1[i];\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n\\n            else if(nums1[i] > nums2[j]){\\n                j++;\\n            }\\n        }\\n       return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0;\\n        int j=0;\\n      \\n        while(i<nums1.size() && j<nums2.size()){\\n\\n            if(nums1[i] == nums2[j]){\\n                return nums1[i];\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n\\n            else if(nums1[i] > nums2[j]){\\n                j++;\\n            }\\n        }\\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047676,
                "title": "java-98-faster-solution-using-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length)\\n        {\\n            if(nums1[i]<nums2[j])\\n            {\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                return nums1[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length)\\n        {\\n            if(nums1[i]<nums2[j])\\n            {\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                return nums1[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047468,
                "title": "simple-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N LOG N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] arr, int[] nums2) {\\n       for(int tar:nums2){\\n        int start=0;\\n        int end=arr.length-1;\\n        while(start<=end){\\n            int mid=start + (end-start)/2;\\n            if(arr[mid]==tar){\\n                return arr[mid];\\n            }\\n            else if(arr[mid]>tar){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n       }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] arr, int[] nums2) {\\n       for(int tar:nums2){\\n        int start=0;\\n        int end=arr.length-1;\\n        while(start<=end){\\n            int mid=start + (end-start)/2;\\n            if(arr[mid]==tar){\\n                return arr[mid];\\n            }\\n            else if(arr[mid]>tar){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n       }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042405,
                "title": "gwrb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        //here we use two pointer approach\\n        int s = 0, e = 0;\\n        while(s<nums1.size() && e<nums2.size()){\\n            if(nums1[s] == nums2[e])return nums1[s];\\n            else if(nums1[s]<nums2[e]) s++;\\n            else e++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        //here we use two pointer approach\\n        int s = 0, e = 0;\\n        while(s<nums1.size() && e<nums2.size()){\\n            if(nums1[s] == nums2[e])return nums1[s];\\n            else if(nums1[s]<nums2[e]) s++;\\n            else e++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030350,
                "title": "easy-cpp-solution-beginner-friendly-using-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0, j = 0;\\n        int sz1 = nums1.size(), sz2 = nums2.size();\\n        while(i < sz1 && j < sz2){\\n            if(nums1[i] == nums2[j]) return nums1[i];\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0, j = 0;\\n        int sz1 = nums1.size(), sz2 = nums2.size();\\n        while(i < sz1 && j < sz2){\\n            if(nums1[i] == nums2[j]) return nums1[i];\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029629,
                "title": "two-pointer-solution-runtime-beats-95-96",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n    let i = 0, j = 0\\n\\n    while(i < nums1.length && j < nums2.length) {\\n        if(nums1[i] === nums2[j]) return nums1[i]\\n\\n        if(nums1[i] > nums2[j]) j++\\n        else i++\\n    }\\n\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = function(nums1, nums2) {\\n    let i = 0, j = 0\\n\\n    while(i < nums1.length && j < nums2.length) {\\n        if(nums1[i] === nums2[j]) return nums1[i]\\n\\n        if(nums1[i] > nums2[j]) j++\\n        else i++\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023031,
                "title": "minimum-common-value-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int min=Integer.MAX_VALUE;\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length)\\n        {\\n            if(nums1[i] == nums2[j])\\n            return nums1[i];\\n            else if(nums1[i]<nums2[j])\\n            i++;\\n            else\\n            j++;\\n        }   \\n        return -1;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int min=Integer.MAX_VALUE;\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length)\\n        {\\n            if(nums1[i] == nums2[j])\\n            return nums1[i];\\n            else if(nums1[i]<nums2[j])\\n            i++;\\n            else\\n            j++;\\n        }   \\n        return -1;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020690,
                "title": "java-hashset-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0;\\n        int j = 0;\\n        while(i < nums1.length && j < nums2.length){\\n            if(nums1[i] == nums2[j]){\\n                return nums1[i];\\n            }else if(nums1[i] < nums2[j]){\\n                i++;\\n            }else if(nums1[i] > nums2[j]){\\n                j++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num: nums1){\\n            set.add(num);\\n        }\\n        for(int num: nums2){\\n            if(set.contains(num)){\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0;\\n        int j = 0;\\n        while(i < nums1.length && j < nums2.length){\\n            if(nums1[i] == nums2[j]){\\n                return nums1[i];\\n            }else if(nums1[i] < nums2[j]){\\n                i++;\\n            }else if(nums1[i] > nums2[j]){\\n                j++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num: nums1){\\n            set.add(num);\\n        }\\n        for(int num: nums2){\\n            if(set.contains(num)){\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011672,
                "title": "2540-minimum-common-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int ans = Integer.MAX_VALUE ;  \\n        boolean found = false ;\\n\\n        HashSet<Integer> myset = new HashSet<>();\\n\\n        for(int i = 0 ; i<nums1.length ; i++){\\n            myset.add(nums1[i]);\\n        }\\n\\n        for(int i = 0 ; i<nums2.length ; i++){\\n            if(myset.contains(nums2[i])  && ans > nums2[i]){\\n                ans = nums2[i];\\n                found = true;\\n            }\\n        }\\n\\n        if(found==true){\\n            return ans;\\n        }\\n\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int ans = Integer.MAX_VALUE ;  \\n        boolean found = false ;\\n\\n        HashSet<Integer> myset = new HashSet<>();\\n\\n        for(int i = 0 ; i<nums1.length ; i++){\\n            myset.add(nums1[i]);\\n        }\\n\\n        for(int i = 0 ; i<nums2.length ; i++){\\n            if(myset.contains(nums2[i])  && ans > nums2[i]){\\n                ans = nums2[i];\\n                found = true;\\n            }\\n        }\\n\\n        if(found==true){\\n            return ans;\\n        }\\n\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008750,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int a=nums1.size();\\n        int b=nums2.size();\\n        int i=0;\\n        int j=0;\\n        int ans=-1;\\n        while(i<a&&j<b)\\n        {\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums2[j]>nums1[i])\\n                i++;\\n            else\\n            {\\n                ans=nums1[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int a=nums1.size();\\n        int b=nums2.size();\\n        int i=0;\\n        int j=0;\\n        int ans=-1;\\n        while(i<a&&j<b)\\n        {\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums2[j]>nums1[i])\\n                i++;\\n            else\\n            {\\n                ans=nums1[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007687,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i=0\\n        j=0\\n        while len(nums1)>i and len(nums2)>j:\\n            if nums1[i]==nums2[j]:\\n                return nums1[i]\\n            elif nums1[i]<nums2[j]:\\n                i+=1\\n            else:\\n                j+=1\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i=0\\n        j=0\\n        while len(nums1)>i and len(nums2)>j:\\n            if nums1[i]==nums2[j]:\\n                return nums1[i]\\n            elif nums1[i]<nums2[j]:\\n                i+=1\\n            else:\\n                j+=1\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005628,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int getCommon(int[] nums1, int[] nums2) \\n    {\\n        int i=0;\\n        int j=0;\\n//why we use while???\\n//we use while because on the first occurence of common value it returns directly the value for the large sized arrays it goes time limit exceed we use while loop instead of nested for loop......\\n        while(nums1.length!=i && nums2.length!=j)\\n        {\\n            if(nums1[i]==nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i]<nums2[j])\\n            {\\n                i++;\\n            }\\n            \\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```PLEASE UPVOTE",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int getCommon(int[] nums1, int[] nums2) \\n    {\\n        int i=0;\\n        int j=0;\\n//why we use while???\\n//we use while because on the first occurence of common value it returns directly the value for the large sized arrays it goes time limit exceed we use while loop instead of nested for loop......\\n        while(nums1.length!=i && nums2.length!=j)\\n        {\\n            if(nums1[i]==nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i]<nums2[j])\\n            {\\n                i++;\\n            }\\n            \\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004817,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &res,int target){\\n        int low=0,high=res.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(res[mid]==target) return res[mid];\\n            if(res[mid]>target) high=mid-1;\\n            else low=mid+1;\\n        }\\n        return 0;\\n    }\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n    \\n         for(int i=0;i<nums1.size();i++){\\n           int p= solve(nums2,nums1[i]);\\n            if(p) return p;\\n         }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &res,int target){\\n        int low=0,high=res.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(res[mid]==target) return res[mid];\\n            if(res[mid]>target) high=mid-1;\\n            else low=mid+1;\\n        }\\n        return 0;\\n    }\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n    \\n         for(int i=0;i<nums1.size();i++){\\n           int p= solve(nums2,nums1[i]);\\n            if(p) return p;\\n         }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994276,
                "title": "beginner-code-for-beginner-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ntwo pointers\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i=0,j=0;\\n        while(i<nums1.length&&j<nums2.length){\\n            if (nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n            else if (nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i=0,j=0;\\n        while(i<nums1.length&&j<nums2.length){\\n            if (nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n            else if (nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993600,
                "title": "2540-minimum-common-value-c-siplified-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n                  \\n            for(int i=0,j=0;i<nums1.size()&&j<nums2.size();)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                 return nums1[i];   \\n                }\\n                else if(nums1[i]<nums2[j])\\n                {\\n                    i++;\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n           return -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n                  \\n            for(int i=0,j=0;i<nums1.size()&&j<nums2.size();)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                 return nums1[i];   \\n                }\\n                else if(nums1[i]<nums2[j])\\n                {\\n                    i++;\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n           return -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984918,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        l1,l2= 0, 0\\n\\n        while l1 < len(nums1) and l2 < len(nums2):\\n            if nums1[l1] == nums2[l2]:\\n                return nums1[l1]\\n            \\n            if nums1[l1] < nums2[l2]:\\n                l1 += 1\\n            else:\\n                l2 += 1\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        l1,l2= 0, 0\\n\\n        while l1 < len(nums1) and l2 < len(nums2):\\n            if nums1[l1] == nums2[l2]:\\n                return nums1[l1]\\n            \\n            if nums1[l1] < nums2[l2]:\\n                l1 += 1\\n            else:\\n                l2 += 1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981376,
                "title": "go-2-pointers-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc getCommon(nums1 []int, nums2 []int) int {\\n    l1 := len(nums1)\\n    l2 := len(nums2)\\n    i := 0 \\n    j := 0\\n\\n    for i < l1 && j < l2 {\\n        if nums1[i] == nums2[j] {\\n            return nums1[i]\\n        }else if nums1[i] < nums2[j] {\\n            i++\\n        }else {\\n            j++\\n        }\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getCommon(nums1 []int, nums2 []int) int {\\n    l1 := len(nums1)\\n    l2 := len(nums2)\\n    i := 0 \\n    j := 0\\n\\n    for i < l1 && j < l2 {\\n        if nums1[i] == nums2[j] {\\n            return nums1[i]\\n        }else if nums1[i] < nums2[j] {\\n            i++\\n        }else {\\n            j++\\n        }\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978791,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int getCommon(int[] nums1, int[] nums2) \\n    {\\n        int i = 0, j = 0;\\n        while(i<nums1.length && j<nums2.length)\\n        {\\n            if(nums1[i] == nums2[j])\\n            return nums1[i];\\n            else if(nums1[i]>nums2[j])\\n            j++;\\n            else\\n            i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int getCommon(int[] nums1, int[] nums2) \\n    {\\n        int i = 0, j = 0;\\n        while(i<nums1.length && j<nums2.length)\\n        {\\n            if(nums1[i] == nums2[j])\\n            return nums1[i];\\n            else if(nums1[i]>nums2[j])\\n            j++;\\n            else\\n            i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978132,
                "title": "five-lines",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        equal_numbers = set(nums1) & set(nums2)\\n\\n        if len(equal_numbers) > 0: \\n            return min(equal_numbers)\\n            \\n        else: \\n            return -1\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getCommon(self, nums1, nums2):\\n        equal_numbers = set(nums1) & set(nums2)\\n\\n        if len(equal_numbers) > 0: \\n            return min(equal_numbers)\\n            \\n        else: \\n            return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977206,
                "title": "simple-easy-two-pointer-approach",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i =0 , j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]) return nums2[j];\\n            if(nums1[i]<nums2[j]) i++;\\n            else j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i =0 , j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]) return nums2[j];\\n            if(nums1[i]<nums2[j]) i++;\\n            else j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976217,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) \\n\\t\\t{\\n         HashSet<Integer> l1= new  HashSet();\\n\\t\\t \\n\\t\\t \\n\\t\\t for (int i :nums1) \\n\\t\\t {\\n\\t\\t\\tl1.add(i);\\n\\t\\t}\\n\\t\\t \\n\\t\\t \\n\\t\\t for (int i:nums2)\\n\\t\\t {\\n\\t\\t\\t if( l1.contains(i))\\n\\t\\t\\t \\n\\t\\t\\t\\t \\n\\t\\t\\t\\t return i;\\n\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) \\n\\t\\t{\\n         HashSet<Integer> l1= new  HashSet();\\n\\t\\t \\n\\t\\t \\n\\t\\t for (int i :nums1) \\n\\t\\t {\\n\\t\\t\\tl1.add(i);\\n\\t\\t}\\n\\t\\t \\n\\t\\t \\n\\t\\t for (int i:nums2)\\n\\t\\t {\\n\\t\\t\\t if( l1.contains(i))\\n\\t\\t\\t \\n\\t\\t\\t\\t \\n\\t\\t\\t\\t return i;\\n\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974004,
                "title": "easy-java-solution-only-for-short-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1); Arrays.sort(nums2);\\n        int returnResult = 0;\\n        for(int i = 0; i < nums1.length; i++) {\\n            for(int j = 0; j < nums2.length; j++) {\\n                if(nums1[i] == nums2[j]) {\\n                    returnResult = nums2[j];\\n                    return returnResult;\\n                }\\n            }\\n        }\\n        return returnResult;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1); Arrays.sort(nums2);\\n        int returnResult = 0;\\n        for(int i = 0; i < nums1.length; i++) {\\n            for(int j = 0; j < nums2.length; j++) {\\n                if(nums1[i] == nums2[j]) {\\n                    returnResult = nums2[j];\\n                    return returnResult;\\n                }\\n            }\\n        }\\n        return returnResult;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974000,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1); Arrays.sort(nums2);\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0,j = 0;\\n\\n        while(i < n && j < m)\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i] > nums2[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1); Arrays.sort(nums2);\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0,j = 0;\\n\\n        while(i < n && j < m)\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                return nums1[i];\\n            }\\n            else if(nums1[i] > nums2[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972259,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int index1 = 0;\\n        int index2 = 0;\\n\\n        while (index1 != nums1.length && index2 != nums2.length) {\\n            if (nums1[index1] == nums2[index2]) return nums1[index1];\\n            if (nums1[index1] < nums2[index2]) {\\n                index1++;\\n            } else {\\n                index2++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int index1 = 0;\\n        int index2 = 0;\\n\\n        while (index1 != nums1.length && index2 != nums2.length) {\\n            if (nums1[index1] == nums2[index2]) return nums1[index1];\\n            if (nums1[index1] < nums2[index2]) {\\n                index1++;\\n            } else {\\n                index2++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963965,
                "title": "easy-solution-c-with-time-complexity-o-n-and-space-complexity-o-1",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n(1).Intialialize variables \\'i\\' and \\'j\\' with zero \\n(2).Start traversing along two arrays nums1 and nums2, If nums1[i]<nums2[j]. Increment i value by 1 .If nums1[i] > nums2[j], incerement j by 1\\n(3).If nums1[i]==nums2[j] store nums1[i] in ans and return ans.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n- Where \\'n\\' is size of smallest vector array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int i=0;\\n        int j=0;\\n        int ans = -1;\\n        while(i < n &&  j < m){\\n            if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i] > nums2[j]){\\n                j++;\\n            }\\n            else{\\n                ans = nums1[i];\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int i=0;\\n        int j=0;\\n        int ans = -1;\\n        while(i < n &&  j < m){\\n            if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i] > nums2[j]){\\n                j++;\\n            }\\n            else{\\n                ans = nums1[i];\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963180,
                "title": "python-beats-98-single-line",
                "content": "# Approach\\nTo condense the code into a single line, we can employ a useful trick. By using the walrus operator (:=) in an expression that is guaranteed to be True, we can utilize a variable within a loop in the same line.\\n\\n# Complexity\\n- Time complexity:\\nO(n + m)\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        return next((num for num in nums1 if num in nums2), -1) if (nums2:=frozenset(nums2)) else None\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        return next((num for num in nums1 if num in nums2), -1) if (nums2:=frozenset(nums2)) else None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955465,
                "title": "c-easiest-solution-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n    int ans=-1;\\n\\n    int i=0;\\n    int j=0;\\n    int n=nums1.size();\\n    int m=nums2.size();\\n\\n    while(i<n && j<m){\\n        if(nums1[i]>nums2[j]){\\n            j++;\\n        }\\n        else if(nums1[i]<nums2[j]){\\n            i++;\\n        }\\n        else{\\n            ans=nums1[i];\\n            break;\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n    int ans=-1;\\n\\n    int i=0;\\n    int j=0;\\n    int n=nums1.size();\\n    int m=nums2.size();\\n\\n    while(i<n && j<m){\\n        if(nums1[i]>nums2[j]){\\n            j++;\\n        }\\n        else if(nums1[i]<nums2[j]){\\n            i++;\\n        }\\n        else{\\n            ans=nums1[i];\\n            break;\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948084,
                "title": "faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       if(nums1[nums1.length-1]<nums2[0]){\\n           return -1;\\n       }\\n       int i=0,j=0;\\n       while(i<nums1.length&&j<nums2.length){\\n           if(nums1[i]==nums2[j]){\\n               return nums1[i];\\n           }\\n           else if(nums1[i]>nums2[j]){\\n               j++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n       return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       if(nums1[nums1.length-1]<nums2[0]){\\n           return -1;\\n       }\\n       int i=0,j=0;\\n       while(i<nums1.length&&j<nums2.length){\\n           if(nums1[i]==nums2[j]){\\n               return nums1[i];\\n           }\\n           else if(nums1[i]>nums2[j]){\\n               j++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n       return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948064,
                "title": "java-solution-faster-than-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       if(nums1[nums1.length-1]<nums2[0]){\\n           return -1;\\n       }\\n       for(int i=0;i<nums1.length;i++){\\n           int ans=BS(nums2,nums1[i],0,nums2.length-1);\\n           if(ans>-1){\\n               return nums2[ans];\\n           }\\n       }\\n       return -1;\\n    }\\n    static int BS(int[] arr,int n,int start,int end){\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(arr[mid]==n){\\n                return mid;\\n            }else if(arr[mid]>n){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       if(nums1[nums1.length-1]<nums2[0]){\\n           return -1;\\n       }\\n       for(int i=0;i<nums1.length;i++){\\n           int ans=BS(nums2,nums1[i],0,nums2.length-1);\\n           if(ans>-1){\\n               return nums2[ans];\\n           }\\n       }\\n       return -1;\\n    }\\n    static int BS(int[] arr,int n,int start,int end){\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(arr[mid]==n){\\n                return mid;\\n            }else if(arr[mid]>n){\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947570,
                "title": "binary-search-solution-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince both arrays are sorted we can try to search for the elements of nums1 in nums2 using binary search. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each element in nums1 seach for element in nums2 via Binary search. As smallest number is required, search from index 0 and at the moment element is found in nums2 return the result. If at the end of the iteration no result is found then return back -1 as default value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlinear search over nums1 will be O(n) and binary search on nums2 will be O(logN). Total time complexity O(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo extra space requird, O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\n        for n1 in nums1:\\n            left, right = 0, len(nums2)-1\\n            while left <= right:\\n                mid = (left + right)//2\\n                if nums2[mid]==n1:\\n                    return n1\\n                elif nums2[mid]>n1:\\n                    right = mid-1\\n                else:\\n                    left = mid+1\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\n        for n1 in nums1:\\n            left, right = 0, len(nums2)-1\\n            while left <= right:\\n                mid = (left + right)//2\\n                if nums2[mid]==n1:\\n                    return n1\\n                elif nums2[mid]>n1:\\n                    right = mid-1\\n                else:\\n                    left = mid+1\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933188,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp[nums1[i]]++;\\n        }\\n        int ans;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            if(mp.find(nums2[i])!=mp.end())\\n            {\\n                ans=nums2[i];\\n                return ans;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp[nums1[i]]++;\\n        }\\n        int ans;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            if(mp.find(nums2[i])!=mp.end())\\n            {\\n                ans=nums2[i];\\n                return ans;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931617,
                "title": "approach-using-hashtable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing HashTable and java \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set1= new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            set1.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(set1.contains(nums2[i])){\\n                set2.add(nums2[i]);\\n            }\\n        }\\n        ArrayList<Integer> list =new ArrayList<>(set2);\\n        Collections.sort(list);\\n        if(!list.isEmpty()){\\n            return list.get(0);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set1= new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            set1.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(set1.contains(nums2[i])){\\n                set2.add(nums2[i]);\\n            }\\n        }\\n        ArrayList<Integer> list =new ArrayList<>(set2);\\n        Collections.sort(list);\\n        if(!list.isEmpty()){\\n            return list.get(0);\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926394,
                "title": "better-time-and-space-complexity-than-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       \\n       int ans=0;\\n       for(int i=0;i<nums2.length;i++)\\n       {\\n           ans=search(nums1,nums2[i]);\\n           if(ans!= -1)\\n           {\\n               return ans;\\n           }\\n       } \\n       return -1;\\n    }\\n    public int search(int[] arr, int target){\\n        int start=0;\\n        int end=arr.length-1;\\n        if(target> arr[end])\\n        {\\n            return -1;\\n        }\\n        while(start<=end)\\n        {\\n            int mid= start + (end - start)/2;\\n            if(target> arr[mid])\\n            {\\n                start=mid+1;\\n            }\\n            else if(target< arr[mid])\\n            {\\n                end= mid-1;\\n            }\\n            else\\n            {\\n                return arr[mid];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n       \\n       int ans=0;\\n       for(int i=0;i<nums2.length;i++)\\n       {\\n           ans=search(nums1,nums2[i]);\\n           if(ans!= -1)\\n           {\\n               return ans;\\n           }\\n       } \\n       return -1;\\n    }\\n    public int search(int[] arr, int target){\\n        int start=0;\\n        int end=arr.length-1;\\n        if(target> arr[end])\\n        {\\n            return -1;\\n        }\\n        while(start<=end)\\n        {\\n            int mid= start + (end - start)/2;\\n            if(target> arr[mid])\\n            {\\n                start=mid+1;\\n            }\\n            else if(target< arr[mid])\\n            {\\n                end= mid-1;\\n            }\\n            else\\n            {\\n                return arr[mid];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925235,
                "title": "binarysearch-java-easy",
                "content": "# Intuition\\nBinarySearch\\n# Approach\\nsimple as we gonna use the each element of one of the array as key and search in another array using binary search method;\\n\\n# Complexity\\n- Time complexity:\\no(nlogn);\\n- Space complexity:\\no(nlogn);\\n# Code\\n```\\nclass Solution {\\n\\n    public static boolean binary(int t,int arr[])\\n    {\\n        int start =0;\\n        int end = arr.length-1;\\n        \\n\\n       while(start<=end)\\n\\t    {\\n\\t\\tint mid = (start+end)/2;\\n\\t\\tif(t>arr[mid])\\n\\t\\tstart = mid+1;\\n\\t\\telse if(t<arr[mid])\\n\\t     end = mid-1;\\n\\t\\telse \\n\\t\\t\\treturn true;\\n\\t    }\\n        return false;\\n    }\\n    public int getCommon(int[] nums1, int[] nums2) {\\n\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(binary(nums1[i],nums2)==true)\\n            return nums1[i];\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static boolean binary(int t,int arr[])\\n    {\\n        int start =0;\\n        int end = arr.length-1;\\n        \\n\\n       while(start<=end)\\n\\t    {\\n\\t\\tint mid = (start+end)/2;\\n\\t\\tif(t>arr[mid])\\n\\t\\tstart = mid+1;\\n\\t\\telse if(t<arr[mid])\\n\\t     end = mid-1;\\n\\t\\telse \\n\\t\\t\\treturn true;\\n\\t    }\\n        return false;\\n    }\\n    public int getCommon(int[] nums1, int[] nums2) {\\n\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(binary(nums1[i],nums2)==true)\\n            return nums1[i];\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922851,
                "title": "c-easiest-solution-beats-80-of-the-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v;\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                v.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(v.size()==0){\\n            return -1;\\n        }\\n        else{\\n            return v[0];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v;\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                v.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        if(v.size()==0){\\n            return -1;\\n        }\\n        else{\\n            return v[0];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916078,
                "title": "python-easy-two-pointers-solution",
                "content": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i1 = i2 = 0\\n        while i1 < len(nums1) and i2 < len(nums2):\\n            if nums1[i1] > nums2[i2]:\\n                i2 += 1\\n            elif nums1[i1] < nums2[i2]:\\n                i1 += 1\\n            else:\\n                return nums1[i1]\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i1 = i2 = 0\\n        while i1 < len(nums1) and i2 < len(nums2):\\n            if nums1[i1] > nums2[i2]:\\n                i2 += 1\\n            elif nums1[i1] < nums2[i2]:\\n                i1 += 1\\n            else:\\n                return nums1[i1]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912740,
                "title": "using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n   public static int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\nint ans =-1;\\n        for (var num:nums1) {\\n            set.add(num);\\n\\n        }\\n        System.out.println(set);\\n\\n        for (var num:nums2) {\\n            if(set.contains(num)){\\n                ans =  num;\\n                break;\\n            }\\n        }\\n        \\nreturn ans ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static int getCommon(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\nint ans =-1;\\n        for (var num:nums1) {\\n            set.add(num);\\n\\n        }\\n        System.out.println(set);\\n\\n        for (var num:nums2) {\\n            if(set.contains(num)){\\n                ans =  num;\\n                break;\\n            }\\n        }\\n        \\nreturn ans ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909512,
                "title": "c-simplest-solution-with-hashset",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int GetCommon(int[] nums1, int[] nums2) {\\n        var set = new HashSet<int>(nums2);\\n\\n        var min = int.MaxValue;\\n        for (var i = 0; i < nums1.Length; i++) {\\n            if (set.Contains(nums1[i])) {\\n                min = Math.Min(min, nums1[i]);\\n            }\\n        }\\n\\n        return min == int.MaxValue ? -1 : min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetCommon(int[] nums1, int[] nums2) {\\n        var set = new HashSet<int>(nums2);\\n\\n        var min = int.MaxValue;\\n        for (var i = 0; i < nums1.Length; i++) {\\n            if (set.Contains(nums1[i])) {\\n                min = Math.Min(min, nums1[i]);\\n            }\\n        }\\n\\n        return min == int.MaxValue ? -1 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893422,
                "title": "java-solution-beats-99-very-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i=0,j=0;\\n\\n        while(i<nums1.length && j< nums2.length){\\n            if(nums1[i]==nums2[j]) return nums1[i];\\n            if(nums1[i]>nums2[j]){ j++;}\\n            else i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i=0,j=0;\\n\\n        while(i<nums1.length && j< nums2.length){\\n            if(nums1[i]==nums2[j]) return nums1[i];\\n            if(nums1[i]>nums2[j]){ j++;}\\n            else i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892607,
                "title": "javascript-clean-and-descriptive-time-o-max-n-m-space-o-1",
                "content": "```js\\n/**\\n * HashSet\\n * Time O(N + M) | Space O(N + M)\\n * https://leetcode.com/problems/minimum-common-value/\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = (nums1, nums2) => {\\n    const set = new Set(nums1);                      /* Time O(N) | Space O(N) */\\n    const nums = nums2.filter((num) => set.has(num));/* Time O(M) | Space O(M) */\\n    const min = Math.min(...nums);                   /* Time O(M) */\\n\\n    return min;\\n};\\n\\n/**\\n * 2-Pointer\\n * Time O(max(N, M)) | Space O(1)\\n * https://leetcode.com/problems/minimum-common-value/\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = (nums1, nums2) => {\\n    let [ left, right ] = [ 0, 0 ];\\n\\n    while ((left < nums1.length) && (right < nums2.length)) {/* Time O(max(N, M))*/\\n        const isTarget = (nums1[left] === nums2[right]);\\n        if (isTarget) return nums1[left];\\n\\n        const isRightGreater = (nums1[left] < nums2[right]);\\n        if (isRightGreater) left += 1;\\n\\n        const isRightLess = (nums2[right] < nums1[left]);\\n        if (isRightLess) right += 1;\\n    }\\n\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * HashSet\\n * Time O(N + M) | Space O(N + M)\\n * https://leetcode.com/problems/minimum-common-value/\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = (nums1, nums2) => {\\n    const set = new Set(nums1);                      /* Time O(N) | Space O(N) */\\n    const nums = nums2.filter((num) => set.has(num));/* Time O(M) | Space O(M) */\\n    const min = Math.min(...nums);                   /* Time O(M) */\\n\\n    return min;\\n};\\n\\n/**\\n * 2-Pointer\\n * Time O(max(N, M)) | Space O(1)\\n * https://leetcode.com/problems/minimum-common-value/\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar getCommon = (nums1, nums2) => {\\n    let [ left, right ] = [ 0, 0 ];\\n\\n    while ((left < nums1.length) && (right < nums2.length)) {/* Time O(max(N, M))*/\\n        const isTarget = (nums1[left] === nums2[right]);\\n        if (isTarget) return nums1[left];\\n\\n        const isRightGreater = (nums1[left] < nums2[right]);\\n        if (isRightGreater) left += 1;\\n\\n        const isRightLess = (nums2[right] < nums1[left]);\\n        if (isRightLess) right += 1;\\n    }\\n\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3889052,
                "title": "common-way-to-solve-it-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0;int j=0;int n=nums1.size(); int m=nums2.size();\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){  \\n                return nums1[i];\\n                 \\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0;int j=0;int n=nums1.size(); int m=nums2.size();\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){  \\n                return nums1[i];\\n                 \\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887185,
                "title": "simple-java-solution-with-hashset",
                "content": "Firstly we take array nums and add to hashSet after we check nums in HashSet (return);\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int nums:nums1){\\n            hs.add(nums);\\n        }\\n        for(int nums:nums2){\\n           if( hs.contains(nums)) return nums;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int nums:nums1){\\n            hs.add(nums);\\n        }\\n        for(int nums:nums2){\\n           if( hs.contains(nums)) return nums;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886864,
                "title": "best-java-solution-beats-100-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2 * n)\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0 , j = 0 ; \\n        while (i < nums1.length && j < nums2.length ){\\n            if (nums1[i] == nums2[j]) {\\n                return nums1[i] ; \\n            }\\n            if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                i++ ; \\n            } \\n        }\\n       return -1 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i = 0 , j = 0 ; \\n        while (i < nums1.length && j < nums2.length ){\\n            if (nums1[i] == nums2[j]) {\\n                return nums1[i] ; \\n            }\\n            if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                i++ ; \\n            } \\n        }\\n       return -1 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870965,
                "title": "solution-python-java-two-pointers",
                "content": "**PLEASE UPVOTE IF YOU FIND THE SOLUTION HELPFUL**\\u2714\\n\\n# JAVA Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) { \\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0, j = 0;\\n\\n        while ((i!=n) && (j!=m)){\\n            if (nums1[i] == nums2[j]){\\n                return nums1[i];\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n``` \\n# PYTHON CODE\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int: \\n        n = len(nums1)\\n        m = len(nums2)\\n        i,j = 0,0\\n        while i!=n and j!=m:\\n            if nums1[i]==nums2[j]:\\n                return nums1[i]\\n            elif nums1[i]<nums2[j]:\\n                i+=1\\n            else:\\n                j+=1 \\n        return -1\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) { \\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i = 0, j = 0;\\n\\n        while ((i!=n) && (j!=m)){\\n            if (nums1[i] == nums2[j]){\\n                return nums1[i];\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int: \\n        n = len(nums1)\\n        m = len(nums2)\\n        i,j = 0,0\\n        while i!=n and j!=m:\\n            if nums1[i]==nums2[j]:\\n                return nums1[i]\\n            elif nums1[i]<nums2[j]:\\n                i+=1\\n            else:\\n                j+=1 \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870135,
                "title": "java-1ms-beats-97-78",
                "content": "# Intuition & Approach\\n- 2-pointer method, advancing through both arrays simultaneously\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n// 1ms Beats 97.78%\\n\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n\\n        // strategy: 2-pointer method\\n\\n        int idx1 = 0;\\n        int idx2 = 0;\\n\\n        while (idx1 < nums1.length && idx2 < nums2.length) {\\n            if (nums1[idx1] < nums2[idx2]) {\\n                ++idx1;\\n            } else if (nums1[idx1] > nums2[idx2]) {\\n                ++idx2;\\n            } else {  // nums1[idx1] == nums2[idx2]\\n                return nums1[idx1];\\n            }\\n        }\\n\\n        return -1;  // no common integers\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 1ms Beats 97.78%\\n\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n\\n        // strategy: 2-pointer method\\n\\n        int idx1 = 0;\\n        int idx2 = 0;\\n\\n        while (idx1 < nums1.length && idx2 < nums2.length) {\\n            if (nums1[idx1] < nums2[idx2]) {\\n                ++idx1;\\n            } else if (nums1[idx1] > nums2[idx2]) {\\n                ++idx2;\\n            } else {  // nums1[idx1] == nums2[idx2]\\n                return nums1[idx1];\\n            }\\n        }\\n\\n        return -1;  // no common integers\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867097,
                "title": "simple-java-2-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i=0,n1=nums1.length;\\n        int j=0,n2=nums2.length;\\n\\n        while(i<n1 && j<n2){\\n            if(nums1[i]==nums2[j])return nums1[i];\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getCommon(int[] nums1, int[] nums2) {\\n        int i=0,n1=nums1.length;\\n        int j=0,n2=nums2.length;\\n\\n        while(i<n1 && j<n2){\\n            if(nums1[i]==nums2[j])return nums1[i];\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865660,
                "title": "most-beginner-friendly-code-you-will-come-accross",
                "content": "# Most beginner friendly code you will come accross\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to think of a two pointer approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n\\n        while(i<n1 && j < n2){\\n            if(nums1[i] == nums2[j]){\\n                return nums1[i];\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return -1; //If not found \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n\\n        while(i<n1 && j < n2){\\n            if(nums1[i] == nums2[j]){\\n                return nums1[i];\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return -1; //If not found \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865379,
                "title": "easy-sol-cpp",
                "content": "bool find(int ele, vector<int>& nums, int m)\\n    {\\n        int st=0,en=m-1;\\n        while(st<=en)\\n        {\\n            int mid=(st+en)/2;\\n            if(nums[mid]==ele)return 1;\\n            else if(nums[mid]>ele)en=mid-1;\\n            else st=mid+1;\\n        }\\n        return 0;\\n    }\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i,n=nums1.size(),m=nums2.size();\\n        if(n<=m)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                if(find(nums1[i],nums2,m))return nums1[i];\\n            }    \\n        }\\n        else\\n        {\\n            for(i=0;i<m;i++)\\n            {\\n                if(find(nums2[i],nums1,n))return nums2[i];\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "bool find(int ele, vector<int>& nums, int m)\\n    {\\n        int st=0,en=m-1;\\n        while(st<=en)\\n        {\\n            int mid=(st+en)/2;\\n            if(nums[mid]==ele)return 1;\\n            else if(nums[mid]>ele)en=mid-1;\\n            else st=mid+1;\\n        }\\n        return 0;\\n    }\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\\n        int i,n=nums1.size(),m=nums2.size();\\n        if(n<=m)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                if(find(nums1[i],nums2,m))return nums1[i];\\n            }    \\n        }\\n        else\\n        {\\n            for(i=0;i<m;i++)\\n            {\\n                if(find(nums2[i],nums1,n))return nums2[i];\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3864813,
                "title": "ruby-3-ways",
                "content": "# Hash\\n```\\ndef get_common(nums1, nums2)\\n    # hashmap\\n    count = Hash.new(0)\\n    nums1.each { |num1| count[num1] += 1 }\\n\\n    nums2.each do |num2|\\n        return num2 if count[num2] > 0\\n    end\\n    -1\\nend\\n```\\n# Two Pointers\\n```\\ndef get_common(nums1, nums2)\\n    # two pointers\\n    i = j = 0\\n    while i < nums1.length && j < nums2.length do \\n        if nums1[i] == nums2[j]\\n            return nums1[i] \\n        elsif nums1[i] < nums2[j]\\n            i += 1\\n        else\\n            j += 1\\n        end\\n    end\\n    -1\\nend\\n```\\n# Binary Search\\n```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer}\\ndef get_common(nums1, nums2)\\n    # binary search\\n    i = 0\\n    for i in i...nums1.length do \\n        left, right = 0, nums2.length-1\\n\\n        while left <= right do \\n            mid = left + (right-left) / 2\\n\\n            if nums1[i] == nums2[mid]\\n                return nums1[i]\\n            elsif nums1[i] < nums2[mid]\\n                right = mid - 1\\n            else\\n                left = mid + 1\\n            end\\n        end\\n    end\\n\\n    -1\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\ndef get_common(nums1, nums2)\\n    # hashmap\\n    count = Hash.new(0)\\n    nums1.each { |num1| count[num1] += 1 }\\n\\n    nums2.each do |num2|\\n        return num2 if count[num2] > 0\\n    end\\n    -1\\nend\\n```\n```\\ndef get_common(nums1, nums2)\\n    # two pointers\\n    i = j = 0\\n    while i < nums1.length && j < nums2.length do \\n        if nums1[i] == nums2[j]\\n            return nums1[i] \\n        elsif nums1[i] < nums2[j]\\n            i += 1\\n        else\\n            j += 1\\n        end\\n    end\\n    -1\\nend\\n```\n```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer}\\ndef get_common(nums1, nums2)\\n    # binary search\\n    i = 0\\n    for i in i...nums1.length do \\n        left, right = 0, nums2.length-1\\n\\n        while left <= right do \\n            mid = left + (right-left) / 2\\n\\n            if nums1[i] == nums2[mid]\\n                return nums1[i]\\n            elsif nums1[i] < nums2[mid]\\n                right = mid - 1\\n            else\\n                left = mid + 1\\n            end\\n        end\\n    end\\n\\n    -1\\nend\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1768088,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1776987,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1791559,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1768194,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1847633,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1794784,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1769839,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1768224,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1768140,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1769882,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1768088,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1776987,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1791559,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1768194,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1847633,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1794784,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1769839,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1768224,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1768140,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            },
            {
                "id": 1769882,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Brute force gives TLE.\\nGood question of Hashing."
                    },
                    {
                        "username": "feistyfawn",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "Thanat05",
                        "content": "i think i brute force it :)"
                    },
                    {
                        "username": "MichaelBHerman",
                        "content": "This problem calls for no specific time complexity constraint, however it times out with a solution like this:\n\nTimeout is reached with an input of int[]nums1 containing 200,000 numbers.\n\n public int getCommon(int[] nums1, int[] nums2) {\n        int minimum = 0;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        for (int n : nums1){\n            for (int k : nums2){\n                if (n == k){\n                    minimum = n;\n                    return minimum;\n                }\n            }\n        }\n        return minimum;\n    }"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "the arrays are already sorted"
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "For test case nums1 = [2,4] nums2 = [1,2], I am getting expected answer 2 in my IntelliJ, but leetcode says output is 0.\n\nHere is my code:\nint res=0;int total=0;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] arr = new int[nums1.length];\n        int len1=nums1.length;int len2=nums2.length;\n        for (int i=0;i<len1;i++){\n            hashMap.put(nums1[i],i+1);\n        }\n        for (int j=0;j<nums2.length;j++){\n            if(hashMap.containsKey(nums2[j])){\n                arr[j]=nums2[j];\n            }\n        }\n        for (int k=0;k< arr.length;k++){\n            total += arr[k];\n        }\n        if(total==0){\n            res=-1;\n        }\n        else {\n            res=arr[0];\n        }\n        return res;"
                    },
                    {
                        "username": "akash_hardha",
                        "content": "Two pointer approach work fine.\\ntry it."
                    },
                    {
                        "username": "speedyy",
                        "content": "If I set the size of vector ans to 9 or 9+ it runs okkay..When I set that size to <9 it gives heap-buffer overflow..WHYYY IT WORKS ON 9>=?????\\n```\\nclass Solution \\n{\\npublic:\\n    int getCommon(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<int>ans(10,-1); \\n        set_intersection(begin(nums1),end(nums1),begin(nums2),end(nums2),begin(ans));\\n        return ans.front();\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NI94",
                        "content": "two pointer process \\nhttps://leetcode.com/problems/minimum-common-value/solutions/3161825/o-n-solution-simple-to-understand/\\n"
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": " ```\nconst auto it = find_if(nums1, [&](const auto v) { return binary_search(nums2, v); });\nreturn it == cend(nums1) ? -1 : *it;\n```\nit would be nice to write such short code on C++ (even it's not the best solution) but leetcode platform still doesn't support c++20 "
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "Mr_Backbencher",
                        "content": "Hint: Use Map for one integer array and then map all values in second array with the values in the map.\\n\\n\\nFor code refer (First try yourself): \\n[https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/](https://leetcode.com/problems/minimum-common-value/solutions/3082342/simple-c-solution-using-map/)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Used **HashSet** in Java for Hashing...\\n> Code was short and simple.\\n\\n[Link to My Solution](https://leetcode.com/problems/minimum-common-value/solutions/3086637/easy-java-solution-hashset)"
                    }
                ]
            }
        ]
    }
]