[
    {
        "title": "Remove Duplicates from Sorted List II",
        "question_content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n\nExample 2:\n\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 300].\n\t-100 <= Node.val <= 100\n\tThe list is guaranteed to be sorted in ascending order.",
        "solutions": [
            {
                "id": 28335,
                "title": "my-accepted-java-code",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n            if(head==null) return null;\\n            ListNode FakeHead=new ListNode(0);\\n            FakeHead.next=head;\\n            ListNode pre=FakeHead;\\n            ListNode cur=head;\\n            while(cur!=null){\\n                while(cur.next!=null&&cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                if(pre.next==cur){\\n                    pre=pre.next;\\n                }\\n                else{\\n                    pre.next=cur.next;\\n                }\\n                cur=cur.next;\\n            }\\n            return FakeHead.next;\\n        }",
                "solutionTags": [],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n            if(head==null) return null;\\n            ListNode FakeHead=new ListNode(0);\\n            FakeHead.next=head;\\n            ListNode pre=FakeHead;\\n            ListNode cur=head;\\n            while(cur!=null){\\n                while(cur.next!=null&&cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                if(pre.next==cur){\\n                    pre=pre.next;\\n                }\\n                else{\\n                    pre.next=cur.next;\\n                }\\n                cur=cur.next;\\n            }\\n            return FakeHead.next;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1395724,
                "title": "8-lines-c-solution-faster-than-100-submissions-for-beginners-explanation-of-approach",
                "content": "first make a dummy node and assign its value equals to 0 and its next points to the head of the given linked list.\\nalso make a prev node and point it to the dummy node.\\n***Always remember that a prev node is always required wherever we have to delete a node or we have to break links and create new links . this thing is very important for beginner coders for developing their intusions in future. That\\'s not a rule i have said it on the basis of my coding expirience***.\\nThen you have to traverse the linked list so run a while loop.\\ncheck that if the two adjacent nodes are equal or not if the two adjacent nodes are equal then traverse trhe linked list upto ehen the adjacent nodes are not identical.\\nThen directly connect the link from prev->next to the head->next.\\nWhile in other case is the adjacent nodes are not equal then simply traverse the linked list by prev=prev->next.\\n\\n\\n\\n\\n ListNode* deleteDuplicates(ListNode* head) {\\n       \\n        ListNode *dummy=new ListNode(0,head);\\n           ListNode *prev=dummy;\\n            \\n            while(head!=NULL){\\n           \\n            if(head->next!=NULL && head->val==head->next->val){\\n                    \\n    while(head->next!=NULL && head->val==head->next->val)head=head->next;\\n                         \\n                       \\n                            prev->next=head->next;\\n                    }\\n                    \\n                    else prev=prev->next;\\n                           \\n                   \\n                    head=head->next;\\n            }\\n            \\n            return dummy->next;\\n                \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t//if(you_like_and_understand_my_solution)\\n\\t\\t//{\\n\\t\\t//  please_upvote++;\\n\\t\\t// }\\n\\t\\t\\n\\t\\t/*Guys plz plz plz upvote my solution if you really like and understand it.and if you stuck at any point then feel free to comment*/.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "first make a dummy node and assign its value equals to 0 and its next points to the head of the given linked list.\\nalso make a prev node and point it to the dummy node.\\n***Always remember that a prev node is always required wherever we have to delete a node or we have to break links and create new links . this thing is very important for beginner coders for developing their intusions in future. That\\'s not a rule i have said it on the basis of my coding expirience***.\\nThen you have to traverse the linked list so run a while loop.\\ncheck that if the two adjacent nodes are equal or not if the two adjacent nodes are equal then traverse trhe linked list upto ehen the adjacent nodes are not identical.\\nThen directly connect the link from prev->next to the head->next.\\nWhile in other case is the adjacent nodes are not equal then simply traverse the linked list by prev=prev->next.\\n\\n\\n\\n\\n ListNode* deleteDuplicates(ListNode* head) {\\n       \\n        ListNode *dummy=new ListNode(0,head);\\n           ListNode *prev=dummy;\\n            \\n            while(head!=NULL){\\n           \\n            if(head->next!=NULL && head->val==head->next->val){\\n                    \\n    while(head->next!=NULL && head->val==head->next->val)head=head->next;\\n                         \\n                       \\n                            prev->next=head->next;\\n                    }\\n                    \\n                    else prev=prev->next;\\n                           \\n                   \\n                    head=head->next;\\n            }\\n            \\n            return dummy->next;\\n                \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t//if(you_like_and_understand_my_solution)\\n\\t\\t//{\\n\\t\\t//  please_upvote++;\\n\\t\\t// }\\n\\t\\t\\n\\t\\t/*Guys plz plz plz upvote my solution if you really like and understand it.and if you stuck at any point then feel free to comment*/.",
                "codeTag": "Unknown"
            },
            {
                "id": 28336,
                "title": "python-in-place-solution-with-dummy-head-node",
                "content": "        \\n    def deleteDuplicates(self, head):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                pre.next = head\\n            else:\\n                pre = pre.next\\n                head = head.next\\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def deleteDuplicates(self, head):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                pre.next = head\\n            else:\\n                pre = pre.next\\n                head = head.next\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 28364,
                "title": "java-simple-and-clean-code-with-comment",
                "content": "    public class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n    \\t//use two pointers, slow - track the node before the dup nodes, \\n    \\t// fast - to find the last node of dups.\\n        ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n        slow.next = fast;\\n        while(fast != null) {\\n        \\twhile (fast.next != null && fast.val == fast.next.val) {\\n         \\t\\tfast = fast.next;    //while loop to find the last node of the dups.\\n        \\t}\\n        \\tif (slow.next != fast) { //duplicates detected.\\n        \\t\\tslow.next = fast.next; //remove the dups.\\n        \\t\\tfast = slow.next;     //reposition the fast pointer.\\n        \\t} else { //no dup, move down both pointer.\\n        \\t\\tslow = slow.next;\\n        \\t\\tfast = fast.next;\\n        \\t}\\n        \\t\\n        }\\n        return dummy.next;\\n    } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n    \\t//use two pointers, slow - track the node before the dup nodes, \\n    \\t// fast - to find the last node of dups.\\n        ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n        slow.next = fast;\\n        while(fast != null) {\\n        \\twhile (fast.next != null && fast.val == fast.next.val) {\\n         \\t\\tfast = fast.next;    //while loop to find the last node of the dups.\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 28339,
                "title": "my-recursive-java-solution",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n        \\n        if (head.next != null && head.val == head.next.val) {\\n            while (head.next != null && head.val == head.next.val) {\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        } else {\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n    \\n\\n\\nif current node is not unique, return deleteDuplicates with head.next. \\nIf current node is unique, link it to the result of next list made by recursive call. Any improvement?",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n        \\n        if (head.next != null && head.val == head.next.val) {\\n            while (head.next != null && head.val == head.next.val) {\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        } else {\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n    \\n\\n\\nif current node is not unique, return deleteDuplicates with head.next. \\nIf current node is unique, link it to the result of next list made by recursive call. Any improvement?",
                "codeTag": "Unknown"
            },
            {
                "id": 28355,
                "title": "simple-and-clear-c-recursive-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if (!head) return 0;\\n            if (!head->next) return head;\\n            \\n            int val = head->val;\\n            ListNode* p = head->next;\\n            \\n            if (p->val != val) {\\n                head->next = deleteDuplicates(p);\\n                return head;\\n            } else {\\n                while (p && p->val == val) p = p->next;\\n                return deleteDuplicates(p);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if (!head) return 0;\\n            if (!head->next) return head;\\n            \\n            int val = head->val;\\n            ListNode* p = head->next;\\n            \\n            if (p->val != val) {\\n                head->next = deleteDuplicates(p);\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2419088,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 93.57% of Java online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if (head == null || head.next == null)\\n            return head;\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next and curr.next.next not null\\n        while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n            // if the value of curr.next and curr.next.next is same...\\n            // There is a duplicate value present in the list...\\n            if(curr.next.val == curr.next.next.val) {\\n                int duplicate = curr.next.val;\\n                // If the next node of curr is not null and its value is eual to the duplicate value...\\n                while(curr.next !=null && curr.next.val == duplicate) {\\n                    // Skip those element and keep updating curr...\\n                    curr.next = curr.next.next;\\n                }\\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 88.10% of C++ online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // create a fake node that acts like a fake head of list pointing to the original head...\\n        ListNode* fake = new ListNode(0);\\n        // fake node points to the original head...\\n        fake->next = head;\\n        ListNode* pre = fake;     //pointing to last node which has no duplicate...\\n        ListNode* curr = head;      // To traverse the linked list...\\n        // Now we traverse nodes and do the process...\\n        while (curr != NULL) {\\n            // Create a loop until the current and previous values are same, keep updating curr...\\n            while (curr->next != NULL && pre->next->val == curr->next->val)\\n                curr = curr->next;\\n            // if curr has non-duplicate value, move the pre pointer to next node...\\n            if (pre->next == curr)\\n                pre = pre->next;\\n            // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n            else\\n                pre->next = curr->next;\\n                // Move curr forward...\\n                // In next iteration, we still need to check whether curr points to duplicate value...\\n                curr = curr->next;\\n        }\\n        // Return the linked list...\\n        return fake->next;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 28 ms, faster than 79.86% of Python online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n        \\n# **JavaScript Solution:**\\nRuntime: 91 ms, faster than 67.42% of JavaScript online submissions for Remove Duplicates from Sorted List II.\\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if (head == null || head.next == null)\\n        return head;\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next and curr.next.next not null\\n    while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n        // if the value of curr.next and curr.next.next is same...\\n        // There is a duplicate value present in the list...\\n        if(curr.next.val == curr.next.next.val) {\\n            let duplicate = curr.next.val;\\n            // If the next node of curr is not null and its value is eual to the duplicate value...\\n            while(curr.next !=null && curr.next.val == duplicate) {\\n                // Skip those element and keep updating curr...\\n                curr.next = curr.next.next;\\n            }\\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // create a fake node that acts like a fake head of list pointing to the original head...\\n    struct ListNode* fake = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    // fake node points to the original head...\\n    fake->next = head;\\n    struct ListNode* pre = fake;        //pointing to last node which has no duplicate...\\n    struct ListNode* curr = head;       // To traverse the linked list...\\n    // Now we traverse nodes and do the process...\\n    while (curr != NULL) {\\n        // Create a loop until the current and previous values are same, keep updating curr...\\n        while (curr->next != NULL && pre->next->val == curr->next->val)\\n            curr = curr->next;\\n        // if curr has non-duplicate value, move the pre pointer to next node...\\n        if (pre->next == curr)\\n            pre = pre->next;\\n        // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n        else\\n            pre->next = curr->next;\\n            // Move curr forward...\\n            // In next iteration, we still need to check whether curr points to duplicate value...\\n            curr = curr->next;\\n    }\\n    // Return the linked list...\\n    return fake->next;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if (head == null || head.next == null)\\n            return head;\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next and curr.next.next not null\\n        while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n            // if the value of curr.next and curr.next.next is same...\\n            // There is a duplicate value present in the list...\\n            if(curr.next.val == curr.next.next.val) {\\n                int duplicate = curr.next.val;\\n                // If the next node of curr is not null and its value is eual to the duplicate value...\\n                while(curr.next !=null && curr.next.val == duplicate) {\\n                    // Skip those element and keep updating curr...\\n                    curr.next = curr.next.next;\\n                }\\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // create a fake node that acts like a fake head of list pointing to the original head...\\n        ListNode* fake = new ListNode(0);\\n        // fake node points to the original head...\\n        fake->next = head;\\n        ListNode* pre = fake;     //pointing to last node which has no duplicate...\\n        ListNode* curr = head;      // To traverse the linked list...\\n        // Now we traverse nodes and do the process...\\n        while (curr != NULL) {\\n            // Create a loop until the current and previous values are same, keep updating curr...\\n            while (curr->next != NULL && pre->next->val == curr->next->val)\\n                curr = curr->next;\\n            // if curr has non-duplicate value, move the pre pointer to next node...\\n            if (pre->next == curr)\\n                pre = pre->next;\\n            // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n            else\\n                pre->next = curr->next;\\n                // Move curr forward...\\n                // In next iteration, we still need to check whether curr points to duplicate value...\\n                curr = curr->next;\\n        }\\n        // Return the linked list...\\n        return fake->next;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if (head == null || head.next == null)\\n        return head;\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next and curr.next.next not null\\n    while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n        // if the value of curr.next and curr.next.next is same...\\n        // There is a duplicate value present in the list...\\n        if(curr.next.val == curr.next.next.val) {\\n            let duplicate = curr.next.val;\\n            // If the next node of curr is not null and its value is eual to the duplicate value...\\n            while(curr.next !=null && curr.next.val == duplicate) {\\n                // Skip those element and keep updating curr...\\n                curr.next = curr.next.next;\\n            }\\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // create a fake node that acts like a fake head of list pointing to the original head...\\n    struct ListNode* fake = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    // fake node points to the original head...\\n    fake->next = head;\\n    struct ListNode* pre = fake;        //pointing to last node which has no duplicate...\\n    struct ListNode* curr = head;       // To traverse the linked list...\\n    // Now we traverse nodes and do the process...\\n    while (curr != NULL) {\\n        // Create a loop until the current and previous values are same, keep updating curr...\\n        while (curr->next != NULL && pre->next->val == curr->next->val)\\n            curr = curr->next;\\n        // if curr has non-duplicate value, move the pre pointer to next node...\\n        if (pre->next == curr)\\n            pre = pre->next;\\n        // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n        else\\n            pre->next = curr->next;\\n            // Move curr forward...\\n            // In next iteration, we still need to check whether curr points to duplicate value...\\n            curr = curr->next;\\n    }\\n    // Return the linked list...\\n    return fake->next;\\n}\\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28334,
                "title": "is-this-the-best-c-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode **runner = &head;\\n            \\n            if(!head || !head->next)return head;\\n            \\n            while(*runner)\\n            {\\n                if((*runner)->next && (*runner)->next->val == (*runner)->val)\\n                {\\n                    ListNode *temp = *runner;\\n                    while(temp && (*runner)->val == temp->val)\\n                        temp = temp->next;\\n                    \\n                    *runner = temp;\\n                }\\n                else\\n                    runner = &((*runner)->next);\\n            }\\n            \\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode **runner = &head;\\n            \\n            if(!head || !head->next)return head;\\n            \\n            while(*runner)\\n            {\\n                if((*runner)->next && (*runner)->next->val == (*runner)->val)\\n                {\\n                    ListNode *temp = *runner;\\n                    while(temp && (*runner)->val == temp->val)\\n                        temp = temp->next;\\n                    \\n                    *runner = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28351,
                "title": "c-solution-simple-and-easy-to-understand",
                "content": "Simply check if the element is duplicate. If yes, record it and use a while loop to go to the next unique element.\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode* cur = dummy;\\n            int duplicate;\\n            while (cur->next && cur->next->next) {\\n                if (cur->next->val == cur->next->next->val) {\\n                    duplicate = cur->next->val;\\n                    while (cur->next && cur->next->val == duplicate) {\\n                        cur->next = cur->next->next;\\n                    }\\n                }\\n                else {\\n                    cur = cur->next;\\n                }\\n            }\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode* cur = dummy;\\n            int duplicate;\\n            while (cur->next && cur->next->next) {\\n                if (cur->next->val == cur->next->next->val) {\\n                    duplicate = cur->next->val;\\n                    while (cur->next && cur->next->val == duplicate) {\\n                        cur->next = cur->next->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1002902,
                "title": "python-2-pointers-solution-explained",
                "content": "Idea here is to traverse our linked list and use two pointers:\\n\\n1. `slow` is for node just before duplications begins\\n2. `fast` is for the last node of duplication group.\\n\\nNow, we traverse nodes and do the following steps:\\n1. while we have `fast.next` and its value is equal to `fast`, it means, than we have one more duplicate, so we move `fast` pointer to the right.\\n2. If it happen, that `slow.next` equal to `fast`, it means, that we have only `1` element in group of duplicated elements, that is we do not need to delete it and we move both pointers to right.\\n3. If it happen, that `slow.next` is not equal to `fast`, it means, that we need to skip group of duplicated elements: we create new connection: `slow.next = fast.next`, and also we allocate `fast = slow.next`. Note, that now we still have the original property: `slow` points to node before group of duplicated elements and `fast` will be the last element of this group (after `while fast.next and fast.val == fast.next.val:` line)\\n\\n**Complexity**: time complexity is `O(n)`: we traverse our list at most twice for each of the pointers. Space complexity is `O(1)`: we did not use any additional memory here.\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast, slow = head, dummy\\n        while fast:\\n            while fast.next and fast.val == fast.next.val:\\n                fast = fast.next\\n            if slow.next == fast:\\n                slow, fast = slow.next, fast.next\\n            else:\\n                slow.next = fast.next\\n                fast = slow.next\\n                \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast, slow = head, dummy\\n        while fast:\\n            while fast.next and fast.val == fast.next.val:\\n                fast = fast.next\\n            if slow.next == fast:\\n                slow, fast = slow.next, fast.next\\n            else:\\n                slow.next = fast.next\\n                fast = slow.next\\n                \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165015,
                "title": "python3-simple-recursive-and-iterative-solution-with-figure-explanation",
                "content": "**Recursive**\\n- Idea\\n\\t- Base case: list is empty or contains only one element --> No duplicates\\n\\t- Recursive case: Assuming that the rest of the list is already done removing duplicates, we only need to consider the first part\\n\\t\\t- There\\'s no duplicate in the first part\\n\\t\\t\\t![image](https://assets.leetcode.com/users/images/490adbec-efbb-4f4e-87aa-feff28e37f78_1618746910.08464.png)\\n\\t\\t- There\\'re duplicates in the first part\\n\\t\\t\\t![image](https://assets.leetcode.com/users/images/7e0078bb-8da8-4ffe-a3ef-4f1c6748603f_1618747062.235478.png)\\n- Implementation\\n   ```python\\n   def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # Recursive case\\n        \\n        # No duplicate in the first part\\n        if head.next.val != head.val: \\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n        \\n        # Duplicates exist in the first part\\n        cur = head\\n        while cur.next and cur.next.val == cur.val:\\n            cur = cur.next\\n        return self.deleteDuplicates(cur.next)\\n   ```\\n   \\n- Complexity\\n\\t- Time: O(n)\\n\\t- Space: O(n)\\n\\n\\n\\n**Iterative**\\n- Idea\\n\\t- Add `dummy_head` before `head`. `dummy.next` is the first node of the list.\\n\\t\\t- Using `dummy_head` can help us to handle edge cases easily. For example, removing duplicate nodes at the beginning of list.\\n\\t- Use two pointers `prev` and `cur` for removing nodes\\n\\t- Iterate the list\\n\\t\\t- If there\\'s no duplicate, move `prev` and `cur` one step forward\\n\\t\\t- If there\\'re duplicate\\n\\t\\t\\t- Iterate `cur` to the last duplicate node\\n\\t\\t\\t- \"Jump over\" the duplicates \\n\\t\\t\\t\\t- `prev.next = cur.next` \\n\\t\\t\\t\\t- `cur = cur.next`\\n\\t\\t![image](https://assets.leetcode.com/users/images/b1eff2b9-24b8-47ac-9b09-88341cc0db64_1618752302.197709.png)\\n- Implementation\\n\\t```python\\n\\tdef deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode(next=head)\\n        prev, cur = dummy_head, head\\n        \\n        while cur and cur.next:\\n            if cur.val != cur.next.val:\\n                # If there\\'s no duplicate,\\n                # move prev and cur one step forward\\n                prev, cur = cur, cur.next\\n            else:\\n                # If there\\'re duplicates,\\n                # iterate cur to the last duplicate nodes,\\n                while cur.next and cur.val == cur.next.val:\\n                    cur = cur.next\\n                    \\n                # and jump over the duplicates\\n                prev.next = cur.next\\n                cur = cur.next\\n        \\n        return dummy_head.next\\n\\t```\\n\\t\\n- Complexity\\n\\t- Time: O(n)\\n\\t- Space: O(1)\\n\\n\\nIf you think this is helpful, please give it a vote.",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n   def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # Recursive case\\n        \\n        # No duplicate in the first part\\n        if head.next.val != head.val: \\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n        \\n        # Duplicates exist in the first part\\n        cur = head\\n        while cur.next and cur.next.val == cur.val:\\n            cur = cur.next\\n        return self.deleteDuplicates(cur.next)\\n   ```\n```python\\n\\tdef deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode(next=head)\\n        prev, cur = dummy_head, head\\n        \\n        while cur and cur.next:\\n            if cur.val != cur.next.val:\\n                # If there\\'s no duplicate,\\n                # move prev and cur one step forward\\n                prev, cur = cur, cur.next\\n            else:\\n                # If there\\'re duplicates,\\n                # iterate cur to the last duplicate nodes,\\n                while cur.next and cur.val == cur.next.val:\\n                    cur = cur.next\\n                    \\n                # and jump over the duplicates\\n                prev.next = cur.next\\n                cur = cur.next\\n        \\n        return dummy_head.next\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 28338,
                "title": "o-n-time-o-1-space-easiest-understanding",
                "content": "The idea is simple, we maintain two pointers, pre, cur in the given List. Pre pointer is always referring to one position before the cur pointer. When we found pre.val != cur.val && cur.val != cur.next.val, the node referred by cur pointer is a unique node. \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode dummy = new ListNode(0 == head.val ? 1 : 0); // to guarantee the dummy node is not same as the original head. \\n\\n        dummy.next = head;\\n        \\n        ListNode pre = dummy;\\n        ListNode cur = head;\\n\\n        ListNode first = dummy;  // the first node in the new unduplicated(result) list.\\n        \\n        while (cur != null && cur.next != null) {\\n            if (cur.val != pre.val && cur.val != cur.next.val) { // we found a unique node, we connect it at the tail of the unduplicated list, and update the first node.\\n                first.next = cur;\\n                first = first.next;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        \\n        if (pre.val != cur.val) { // the last node needs to be dealt with independently\\n            first.next = cur;\\n            first = first.next;\\n        }\\n        \\n        first.next = null; // the subsequent list is duplicate.\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "The idea is simple, we maintain two pointers, pre, cur in the given List. Pre pointer is always referring to one position before the cur pointer. When we found pre.val != cur.val && cur.val != cur.next.val, the node referred by cur pointer is a unique node. \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode dummy = new ListNode(0 == head.val ? 1 : 0); // to guarantee the dummy node is not same as the original head. \\n\\n        dummy.next = head;\\n        \\n        ListNode pre = dummy;\\n        ListNode cur = head;\\n\\n        ListNode first = dummy;  // the first node in the new unduplicated(result) list.\\n        \\n        while (cur != null && cur.next != null) {\\n            if (cur.val != pre.val && cur.val != cur.next.val) { // we found a unique node, we connect it at the tail of the unduplicated list, and update the first node.\\n                first.next = cur;\\n                first = first.next;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        \\n        if (pre.val != cur.val) { // the last node needs to be dealt with independently\\n            first.next = cur;\\n            first = first.next;\\n        }\\n        \\n        first.next = null; // the subsequent list is duplicate.\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 816387,
                "title": "simple-3-pointer-solution-8ms-c",
                "content": "* Faster than 93.08% (8ms)\\n* Memory usage less than 96.39% (10.8 MB)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        if(!head)\\n            return head;\\n        \\n        ListNode *prev=NULL, *curr=head, *next=curr->next;\\n        while(next)\\n        {\\n            if(curr->val == next->val)\\n            {\\n                while(next && next->val == curr->val)\\n                    next=next->next;\\n                if(!prev) // This condition means element at the head is repeating. So, head pointer needs to be shifted.\\n                    head=next;\\n                else\\n                    prev->next = next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n            }\\n            \\n            curr=next;\\n            if(next)\\n                next=curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n#### If you like the solution, do give it an upvote. In case of queries, feel free to leave them in the comment.\\n#### LeetCode and Chill !!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        if(!head)\\n            return head;\\n        \\n        ListNode *prev=NULL, *curr=head, *next=curr->next;\\n        while(next)\\n        {\\n            if(curr->val == next->val)\\n            {\\n                while(next && next->val == curr->val)\\n                    next=next->next;\\n                if(!prev) // This condition means element at the head is repeating. So, head pointer needs to be shifted.\\n                    head=next;\\n                else\\n                    prev->next = next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n            }\\n            \\n            curr=next;\\n            if(next)\\n                next=curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28572,
                "title": "a-short-and-simple-java-solution",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode d = dummy;\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val)\\n                    head = head.next;\\n            } else {\\n                d.next = head;\\n                d = d.next;\\n            }\\n            head = head.next;\\n        }\\n        d.next = null;\\n        return dummy.next;\\n    }\\n\\n1->1->1->2->2->3\\n\\nwe skip all the 1's and start the loop from 2\\n\\nand also skip all the 2's, and now head.val == 3;\\n\\nponit d.next to the tail, end the loop",
                "solutionTags": [],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode d = dummy;\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val)\\n                    head = head.next;\\n            } else {\\n                d.next = head;\\n                d = d.next;\\n            }\\n            head = head.next;\\n        }\\n        d.next = null;\\n        return dummy.next;\\n    }\\n\\n1->1->1->2->2->3\\n\\nwe skip all the 1's and start the loop from 2\\n\\nand also skip all the 2's, and now head.val == 3;\\n\\nponit d.next to the tail, end the loop",
                "codeTag": "Unknown"
            },
            {
                "id": 1832481,
                "title": "c-detailed-explanation-w-actually-memory-delete-commented-code-easy-to-understand",
                "content": "***Brief note about Question-***\\n```\\nLet\\'s take an example not given-\\nSuppose our head given to us as head = -1 -> 0 -> 3 -> 4 -> 4 -> 4 -> 5 -> 5-> 6\\n\\nSince, 4 and 5 are repeating, so we delete that nodes, and our final answer looks like\\nhead = -1 -> 0 -> 3 -> 6\\n```\\n_____________\\n***Solution - I (Accepted)-***\\n* First we create a dummy node name as `prehead` whose next contains the` head` node.\\n* After that, we have to make a current pointer and moves that pointer in the our linked list.\\n* Suppose at  a point we find `curr ->next -> val == curr -> next -> next -> val`then we have to delete all nodes upto which they are having the same value.\\n* We actually delete that nodes from our linked list and free up memory.\\n* And lastly, as use of dummy node i.e our` prehead`, it\\'s next store our head node, so we return `prehead -> next.`\\n* Since, It is pretty straightforward to visuliaze the links how they works here, that\\'s why in this post i don\\'t include images.\\n* See code for more clarification.\\n________\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //if head is NULL or just having a single node, simply return from here head \\n        if(head == NULL || head->next == NULL) \\n            return head;\\n        \\n        // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n        ListNode* prehead = new ListNode(-101);\\n        \\n        prehead -> next = head; // prehead\\'s next contain head\\n        \\n        ListNode* curr = prehead; // make a current pointer to move\\n        \\n        // while it not reaches to the end\\n        while(curr -> next != NULL && curr -> next -> next != NULL)\\n        {\\n            // if values are equal, now we have to delete values, till when they are equal\\n           if(curr -> next -> val == curr -> next -> next -> val)\\n           {\\n               // temp pointer to find upto when the va;ues are equal and delete that nodes which ar not be include in our answer\\n               ListNode* temp = curr -> next -> next;\\n               while(temp != NULL && curr -> next -> val == temp -> val)\\n               {\\n                   ListNode *anthortemp = temp;\\n                   temp = temp -> next;\\n                   delete anthortemp; // actually freeing up the memory\\n               }\\n               curr -> next = temp;\\n           }\\n           else // if values are not equal\\'s then simply move curr to next\\n           {\\n               curr = curr -> next;\\n           }\\n        }\\n        \\n        // and at last, prehead\\'s next contain head node, so return that\\n        return prehead -> next;\\n        \\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given-\\nSuppose our head given to us as head = -1 -> 0 -> 3 -> 4 -> 4 -> 4 -> 5 -> 5-> 6\\n\\nSince, 4 and 5 are repeating, so we delete that nodes, and our final answer looks like\\nhead = -1 -> 0 -> 3 -> 6\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //if head is NULL or just having a single node, simply return from here head \\n        if(head == NULL || head->next == NULL) \\n            return head;\\n        \\n        // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n        ListNode* prehead = new ListNode(-101);\\n        \\n        prehead -> next = head; // prehead\\'s next contain head\\n        \\n        ListNode* curr = prehead; // make a current pointer to move\\n        \\n        // while it not reaches to the end\\n        while(curr -> next != NULL && curr -> next -> next != NULL)\\n        {\\n            // if values are equal, now we have to delete values, till when they are equal\\n           if(curr -> next -> val == curr -> next -> next -> val)\\n           {\\n               // temp pointer to find upto when the va;ues are equal and delete that nodes which ar not be include in our answer\\n               ListNode* temp = curr -> next -> next;\\n               while(temp != NULL && curr -> next -> val == temp -> val)\\n               {\\n                   ListNode *anthortemp = temp;\\n                   temp = temp -> next;\\n                   delete anthortemp; // actually freeing up the memory\\n               }\\n               curr -> next = temp;\\n           }\\n           else // if values are not equal\\'s then simply move curr to next\\n           {\\n               curr = curr -> next;\\n           }\\n        }\\n        \\n        // and at last, prehead\\'s next contain head node, so return that\\n        return prehead -> next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28398,
                "title": "clean-python-solution-involving-dummy-node",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        \\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                val_to_rem = curr.val\\n                \\n                while curr and curr.val == val_to_rem:\\n                    curr = curr.next\\n                    \\n                prev.next = curr\\n                \\n            else:\\n                prev, curr = curr, curr.next\\n                \\n        return dummy.next",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        \\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                val_to_rem = curr.val\\n                \\n                while curr and curr.val == val_to_rem:\\n                    curr = curr.next\\n                    \\n                prev.next = curr\\n                \\n            else:\\n                prev, curr = curr, curr.next\\n                \\n        return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 3224134,
                "title": "detailed-explanation-how-to-think-about-the-ques-100",
                "content": "# Intuition\\nTo solve this problem, we can use a dummy node and two pointers, current and previous. The dummy node serves as the head of the result linked list and helps us handle the case where the original head node needs to be removed. The current pointer moves through the linked list, checking for duplicates, and the previous pointer follows behind it, keeping track of the last distinct node.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We first create a dummy node with a value of 0 and set its next pointer to the original head node. We also initialize the prev and curr pointers to the dummy node and the head node, respectively.\\n- We then iterate through the linked list using the curr pointer, checking for duplicates with the curr.next node. If we find duplicates, we keep moving the curr pointer until we find the last duplicate node. We then update the prev.next pointer to point to the node after the last duplicate node.\\n- If we don\\'t find duplicates, we simply update the prev pointer to the curr node and move the curr pointer to its next node\\n- After iterating through the entire linked list, we return the next pointer of the dummy node, which points to the head of the resulting linked list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL || head->next == NULL) return head;\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = dummy;\\n\\n        while(curr != NULL){\\n            if(curr->next != NULL && curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr= curr->next;\\n                }\\n                prev->next = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/53a2ee22-0977-4b5c-9768-f81d45e59bc2_1677219527.1926677.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL || head->next == NULL) return head;\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = dummy;\\n\\n        while(curr != NULL){\\n            if(curr->next != NULL && curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr= curr->next;\\n                }\\n                prev->next = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565744,
                "title": "simple-c-iterative-solution-comments-97-faster",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // handle edge cases, if list is empty\\n        // or if it has one element, return it\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        // create an auxiliary head pointer\\n        // and a new iterator\\n        auto auxiliary_head = new ListNode(-1);\\n        auto iter = auxiliary_head;\\n        \\n        while (head != nullptr) {\\n            if (head->next && head->val == head->next->val) {\\n                // if current node value is equal to its next value\\n                // skip all nodes of that value\\n                int curr = head->val;\\n                while (head && head->val == curr) {\\n                    head = head->next;\\n                }\\n            } else {\\n                // otherwise, assign node to next iterator\\n                // increment new iterator and increment node\\n                iter->next = head;\\n                iter = iter->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        // we need to cut the cord\\n        iter->next = nullptr;\\n        \\n        // return new head\\n        return auxiliary_head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // handle edge cases, if list is empty\\n        // or if it has one element, return it\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        // create an auxiliary head pointer\\n        // and a new iterator\\n        auto auxiliary_head = new ListNode(-1);\\n        auto iter = auxiliary_head;\\n        \\n        while (head != nullptr) {\\n            if (head->next && head->val == head->next->val) {\\n                // if current node value is equal to its next value\\n                // skip all nodes of that value\\n                int curr = head->val;\\n                while (head && head->val == curr) {\\n                    head = head->next;\\n                }\\n            } else {\\n                // otherwise, assign node to next iterator\\n                // increment new iterator and increment node\\n                iter->next = head;\\n                iter = iter->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        // we need to cut the cord\\n        iter->next = nullptr;\\n        \\n        // return new head\\n        return auxiliary_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28371,
                "title": "javascript-iterative-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n    const dummy = new ListNode();\\n    dummy.next = head;\\n    let node = dummy;                                                  // the last known distinct node\\n    while (node.next) {\\n        if (node.next.next && node.next.val === node.next.next.val) {  // if the next two nodes are equal...\\n            let nonValNode = node.next.next.next;\\n            while (nonValNode && nonValNode.val === node.next.val) {   // ...find the first one that isn't...\\n                nonValNode = nonValNode.next;\\n            }\\n            node.next = nonValNode;                                    // ...and glue it to the last known distinct node;...\\n        } else {\\n            node = node.next;                                          // ...otherwise the next node is distinct\\n        }\\n    }\\n    return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    const dummy = new ListNode();\\n    dummy.next = head;\\n    let node = dummy;                                                  // the last known distinct node\\n    while (node.next) {\\n        if (node.next.next && node.next.val === node.next.next.val) {  // if the next two nodes are equal...\\n            let nonValNode = node.next.next.next;\\n            while (nonValNode && nonValNode.val === node.next.val) {   // ...find the first one that isn't...\\n                nonValNode = nonValNode.next;\\n            }\\n            node.next = nonValNode;                                    // ...and glue it to the last known distinct node;...\\n        } else {\\n            node = node.next;                                          // ...otherwise the next node is distinct\\n        }\\n    }\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560641,
                "title": "java-solution-short-simple",
                "content": "```\\n\\tpublic ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n    \\n        if(head.val != head.next.val){\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        \\n        while(head.next != null && head.val == head.next.val){\\n            head = head.next;\\n        }\\n        \\n        return deleteDuplicates(head.next);\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n    \\n        if(head.val != head.next.val){\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        \\n        while(head.next != null && head.val == head.next.val){\\n            head = head.next;\\n        }\\n        \\n        return deleteDuplicates(head.next);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28483,
                "title": "c-8ms-iterative-naive-but-easy-to-implement",
                "content": "It is my first post ever... Did not saw similar ones so I would like to share a naive way to implement this.\\nIdea is to set a flag, which indicates the current head should be added or not.\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head||!head->next) return head;\\n            ListNode* dummy = new ListNode(0);\\n            ListNode* tail = dummy;\\n            int flag = true; // should the current head be added ?\\n            while(head){\\n                while(head&&head->next&&head->val==head->next->val)\\n                {\\n                    flag = false; // finds duplicate, set it to false\\n                    head = head->next;\\n                }\\n                if(flag) // if should be added\\n                {\\n                    tail->next = head;\\n                    tail = tail->next;\\n                }\\n                head = head->next;\\n                flag = true; // time for a new head value, set flag back to true\\n            }\\n            tail->next = nullptr; // Don't forget this... I did..\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head||!head->next) return head;\\n            ListNode* dummy = new ListNode(0);\\n            ListNode* tail = dummy;\\n            int flag = true; // should the current head be added ?\\n            while(head){\\n                while(head&&head->next&&head->val==head->next->val)\\n                {\\n                    flag = false; // finds duplicate, set it to false\\n                    head = head->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1833176,
                "title": "4ms-simple-c-easy",
                "content": "\\n```\\n  ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n        \\n        int x=head->val;\\n        int y=head->next->val;\\n        \\n        if(x!=y)\\n        {\\n            head->next=deleteDuplicates(head->next);\\n        }\\n        else\\n        {\\n            while(head && x==head->val)\\n            {\\n                head=head->next;\\n            }\\n           return deleteDuplicates(head);\\n        }\\n     \\n        return head;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n```\\n  ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n        \\n        int x=head->val;\\n        int y=head->next->val;\\n        \\n        if(x!=y)\\n        {\\n            head->next=deleteDuplicates(head->next);\\n        }\\n        else\\n        {\\n            while(head && x==head->val)\\n            {\\n                head=head->next;\\n            }\\n           return deleteDuplicates(head);\\n        }\\n     \\n        return head;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1832645,
                "title": "c-efficient-short-easy-clean-solution-beginner-friendly",
                "content": "#### *please Upvote, if you Find its Helpful :)*\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=new ListNode(0,head);//dummy node\\n        ListNode* prev=temp;\\n        \\n        while(head!=NULL){\\n            if(head->next!=NULL && head->val==head->next->val){\\n               while(head->next!=NULL && head->val==head->next->val){\\n                   head=head->next;\\n               }\\n                prev->next=head->next;\\n            }else{\\n                prev=prev->next;\\n            }\\n            head=head->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=new ListNode(0,head);//dummy node\\n        ListNode* prev=temp;\\n        \\n        while(head!=NULL){\\n            if(head->next!=NULL && head->val==head->next->val){\\n               while(head->next!=NULL && head->val==head->next->val){\\n                   head=head->next;\\n               }\\n                prev->next=head->next;\\n            }else{\\n                prev=prev->next;\\n            }\\n            head=head->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832457,
                "title": "java-100-faster-solution-using-two-pointer",
                "content": "```class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            if(curr.next!=null && curr.val==curr.next.val) {\\n                while(curr.next!=null && curr.val==curr.next.val){\\n                    curr=curr.next;\\n                }\\n               prev.next=curr.next;\\n            }\\n            else{\\n                prev=curr; \\n            }\\n            curr=curr.next;\\n        }\\n      return dummy.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            if(curr.next!=null && curr.val==curr.next.val) {\\n                while(curr.next!=null && curr.val==curr.next.val){\\n                    curr=curr.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28479,
                "title": "8ms-clean-c-code",
                "content": "This is not a hard problem, but it is also not very easy to make the code clean and neat.\\n\\n    class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if( !head ) return NULL;\\n                ListNode* p = new ListNode(head->val-1), *ptr = p, *pre = p;\\n                while( head ) {\\n                    if( pre->val != head->val && (!head->next || head->next->val != head->val )) {\\n                        ptr->next = head;\\n                        ptr = ptr->next;\\n                    }\\n                    pre = head;\\n                    head = head->next;\\n                }\\n                ptr->next = NULL;\\n                return p->next;\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if( !head ) return NULL;\\n                ListNode* p = new ListNode(head->val-1), *ptr = p, *pre = p;\\n                while( head ) {\\n                    if( pre->val != head->val && (!head->next || head->next->val != head->val )) {\\n                        ptr->next = head;\\n                        ptr = ptr->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2583544,
                "title": "easy-recursive-c-approach",
                "content": "In the recursive approach we\\'ll first set our base cases that if our *head* or *head -> next* is *NULL* then we simply return the head node as we have either a *NULL* or a Single Node in the Linked List.\\n\\nNow,\\nIf the value in head Node and the next Node is equal then using a while loop we\\'ll shift the head Node forward till the time two adjacent nodes have the same value \\n(i.e. till *head -> val == head -> next -> val*).\\n```\\n/*\\nFor example : 1 -> 1 -> 1 -> 2 -> 3 \\nInitially our head will point at the first Node containing the value 1.\\nAfter going through the loop the head will be pointing at the third Node that again contains 1 but the value of the next Node isn\\'t 1 so the loop will terminate .\\n*/\\n```\\nAt the end of the while loop it\\'s important to notice that we\\'ll currently be on the Node whose value was duplicated so we\\'ll call recursion on the next value of head and update our pre-existing head. \\n**head = deleteDuplicates(head -> next)**\\n\\nOtherwise if the value of head and the next node are different we\\'ll just simply update our  *head -> next* by calling recursion on it leaving our head Node preserved as it wasn\\'t duplicated. \\n **head -> next = deleteDuplicates(head -> next)**\\n\\nFinally we\\'ll return the head Node. \\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\t// Base Case\\n    if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int flag = head -> val;\\n        //If head is found duplicated\\n        if(head -> next -> val == flag){\\n            while(head -> next && head -> next -> val == flag){\\n               head = head -> next; \\n            }\\n            // Since head node is still the one which was duplicated calling recursion on next Node and updating current head\\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n        // If head isn\\'t duplicated\\n        else{\\n            //Leaving current head preserved and calling recursion from the next Node of list\\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n\\t\\n\\t/*\\n\\tif(solution -> understandable){\\n\\t\\tupvote++;\\n\\t}\\n\\tPS : This is my first ever answer on leetcode hope you liked it. Please comment for suggestions and feedback :)\\n\\t*/\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/*\\nFor example : 1 -> 1 -> 1 -> 2 -> 3 \\nInitially our head will point at the first Node containing the value 1.\\nAfter going through the loop the head will be pointing at the third Node that again contains 1 but the value of the next Node isn\\'t 1 so the loop will terminate .\\n*/\\n```\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\t// Base Case\\n    if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int flag = head -> val;\\n        //If head is found duplicated\\n        if(head -> next -> val == flag){\\n            while(head -> next && head -> next -> val == flag){\\n               head = head -> next; \\n            }\\n            // Since head node is still the one which was duplicated calling recursion on next Node and updating current head\\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n        // If head isn\\'t duplicated\\n        else{\\n            //Leaving current head preserved and calling recursion from the next Node of list\\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n\\t\\n\\t/*\\n\\tif(solution -> understandable){\\n\\t\\tupvote++;\\n\\t}\\n\\tPS : This is my first ever answer on leetcode hope you liked it. Please comment for suggestions and feedback :)\\n\\t*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832725,
                "title": "c-easy-to-understand-iteration-simple",
                "content": "**82. Remove Duplicates from Sorted List II**\\n\\n#### **APPROACH -**\\n*Create a **dummyHead** with `dummyHead->next = head`\\nTraverse through the linked list with intially `isDuplicate = false`\\nMove through the nodes till same valued nodes present and update **isDuplicate**\\nSet the new links based on whether the current node is a duplicate\\nReturn **dummyHead->next***\\n</br>\\n#### **COMPLEXITY -**\\n* Time Complexity : O(N)\\n* Space Complexity : O(1)\\n</br>\\n#### **CODE -**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *dummyHead = new ListNode(0, head);\\n        ListNode *prev = dummyHead, *curr = head;\\n        \\n        while(curr) {\\n            bool isDuplicate = false;\\n            while(curr->next && curr->val == curr->next->val) {\\n                isDuplicate = true;\\n                curr = curr->next;\\n            }\\n            if(isDuplicate)\\n                prev->next = curr->next;\\n            else\\n                prev = curr;\\n            curr = curr->next;\\n        }\\n\\t\\t\\n        return dummyHead->next;\\n    }\\n};\\n```\\n\\n**Please Upvote if it helps** \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *dummyHead = new ListNode(0, head);\\n        ListNode *prev = dummyHead, *curr = head;\\n        \\n        while(curr) {\\n            bool isDuplicate = false;\\n            while(curr->next && curr->val == curr->next->val) {\\n                isDuplicate = true;\\n                curr = curr->next;\\n            }\\n            if(isDuplicate)\\n                prev->next = curr->next;\\n            else\\n                prev = curr;\\n            curr = curr->next;\\n        }\\n\\t\\t\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832310,
                "title": "c-easy-to-understand-recursion-simple",
                "content": "# 82. Remove Duplicates from Sorted List II\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n[LeetCode](https://github.com/knockcat/Leetcode)       **LINK TO LEETCODE REPOSITORY**\\n``` ```\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n\\n* **Traverse the list** from the **head** (or start) node.\\n* While traversing, **compare each node with its next node.**\\n* If the **data of the next node is the same as the current node** then **delete the next node.** \\n* **Before we delete a node**, we need to store the next pointer of the node.\\n\\n``` ```\\n\\n**TIME COMPLEXITY**  : O(N)  , *N is number of Nodes*\\n**SPACE COMPLEXITY** : O(1) \\n``` ```\\n\\n**CODE WITH EXPLANATION**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t// if list contains no node\\n        if(!head)\\n            return 0;\\n\\t\\t//if list containg a single node return head\\n        if(!head -> next)\\n            return head;\\n        \\n\\t\\t// keepitn val of head in a temp variable var.\\n        int val = head ->val;\\n\\t\\t// temp contain the reference of next  node\\n        ListNode *temp = head -> next;\\n        \\n\\t\\t// if the next node have different value then,\\n\\t\\t// update head->next by temp(temp contains reference to next node)\\n        if(temp -> val != val)\\n        {\\n            head -> next = deleteDuplicates(temp);\\n            return head;\\n        }\\n        else\\n        {\\n\\t\\t\\t// if the values are same just update temp to temp->next;\\n           while(temp && temp -> val == val)\\n            {\\n\\t\\t\\t\\t// assigning temp to p \\n                ListNode *p = temp;\\n\\t\\t\\t\\t// updating temp with next node\\n                temp = temp->next;\\n\\t\\t\\t\\t// freeing the memory\\n                delete p;\\n            }\\n            return deleteDuplicates(temp);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n``` ```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t// if list contains no node\\n        if(!head)\\n            return 0;\\n\\t\\t//if list containg a single node return head\\n        if(!head -> next)\\n            return head;\\n        \\n\\t\\t// keepitn val of head in a temp variable var.\\n        int val = head ->val;\\n\\t\\t// temp contain the reference of next  node\\n        ListNode *temp = head -> next;\\n        \\n\\t\\t// if the next node have different value then,\\n\\t\\t// update head->next by temp(temp contains reference to next node)\\n        if(temp -> val != val)\\n        {\\n            head -> next = deleteDuplicates(temp);\\n            return head;\\n        }\\n        else\\n        {\\n\\t\\t\\t// if the values are same just update temp to temp->next;\\n           while(temp && temp -> val == val)\\n            {\\n\\t\\t\\t\\t// assigning temp to p \\n                ListNode *p = temp;\\n\\t\\t\\t\\t// updating temp with next node\\n                temp = temp->next;\\n\\t\\t\\t\\t// freeing the memory\\n                delete p;\\n            }\\n            return deleteDuplicates(temp);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918883,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        let dummy: ListNode? = ListNode(-1)\\n        dummy?.next = head\\n\\n        var curr = dummy\\n        while let nextVal = curr?.next?.val, let nextNextVal = curr?.next?.next?.val {\\n            if nextVal == nextNextVal {\\n                let duplicate = nextVal\\n                while curr?.next != nil, curr?.next?.val == duplicate {\\n                    curr?.next = curr?.next?.next\\n                }\\n            } else {\\n                curr = curr?.next\\n            }\\n        }\\n\\n        return dummy?.next\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        let dummy: ListNode? = ListNode(-1)\\n        dummy?.next = head\\n\\n        var curr = dummy\\n        while let nextVal = curr?.next?.val, let nextNextVal = curr?.next?.next?.val {\\n            if nextVal == nextNextVal {\\n                let duplicate = nextVal\\n                while curr?.next != nil, curr?.next?.val == duplicate {\\n                    curr?.next = curr?.next?.next\\n                }\\n            } else {\\n                curr = curr?.next\\n            }\\n        }\\n\\n        return dummy?.next\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28438,
                "title": "my-python-solution-beats-91",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if head==None:\\n            return None\\n        \\n        dummy=ListNode(0)\\n        dummy.next=head\\n        \\n        cur=head\\n        prev=dummy\\n        \\n        dup=0\\n        \\n        while cur!=None and cur.next!=None:\\n            if cur.val==cur.next.val:\\n                cur=cur.next\\n                dup=1\\n            else:\\n                if dup==1:\\n                    prev.next=cur.next\\n                    cur=cur.next\\n                    dup=0\\n                else:\\n                    prev=cur\\n                    cur=cur.next\\n        if dup==1:\\n            prev.next=cur.next\\n            cur=cur.next\\n            \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if head==None:\\n            return None\\n        \\n        dummy=ListNode(0)\\n        dummy.next=head\\n        \\n        cur=head\\n        prev=dummy\\n        \\n        dup=0\\n        \\n        while cur!=None and cur.next!=None:\\n            if cur.val==cur.next.val:\\n                cur=cur.next\\n                dup=1\\n            else:\\n                if dup==1:\\n                    prev.next=cur.next\\n                    cur=cur.next\\n                    dup=0\\n                else:\\n                    prev=cur\\n                    cur=cur.next\\n        if dup==1:\\n            prev.next=cur.next\\n            cur=cur.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28487,
                "title": "recommend-for-beginners-c-implementation-with-detailed-explaination",
                "content": "At the first glance, we can use the similar code of the simpler problem : which only delete the duplicate ones, So if we want to delete all the duplicate ones including the copy. We can use  the dummy node and the pre pointer to jump over all the duplicate nodes.\\nThe Trap is that you may ignore that when we meet the no-duplicate numbers, we should do different op based the previous states. Just like state-machine.\\nAt last but not least important, we should delete the duplicate number occurs at the end . \\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(INT_MAX);\\n            dummy->next=head;\\n            ListNode* pre=dummy, *cur=head, *next=head->next;\\n            bool flag=false;\\n            while(next){\\n                if(next->val==cur->val){\\n                    flag=true;\\n                    next=next->next;\\n                }\\n                else{\\n                    if(flag) {\\n                        pre->next=next;\\n                        cur=next;\\n                        next=next->next;\\n                    }\\n                    else{\\n                        pre=pre->next;\\n                        cur=cur->next;\\n                        next=next->next;\\n                    }\\n                    flag=false;\\n                }\\n            }\\n            //the corner cases : if the duplicate number locates at the end \\n            if(flag) pre->next=next;\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(INT_MAX);\\n            dummy->next=head;\\n            ListNode* pre=dummy, *cur=head, *next=head->next;\\n            bool flag=false;\\n            while(next){\\n                if(next->val==cur->val){\\n                    flag=true;\\n                    next=next->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1003243,
                "title": "c-iterative-2-pointer-solution-explained-100-time-40-space",
                "content": "This problem is rather easy to solve with extra memory and possibly an extra pass; a better challenge comes from trying to trying to work under more constrained requirements.\\n\\nFirst of all we will declare a few support variables:\\n* `res` will be the base from which we will build our solution and will save us a bit of painful edge cases to otherwise consider, for the affordable cost of one extra node;\\n* `prev` and `iter` will be the 2 pointers we will use to parse and purge the list from duplicates;\\n* `currVal` is a convenience variable to store the currently parsed value.\\n\\nWe will attach `head` right after `res` and then move on with a main loop that will run as long as we have `prev && prev->next`, in which:\\n* we will prepare the ground for the next inner loop, setting `iter` right after `prev` and assigning `iter->val` to `currVal`;\\n* advance `iter` with our inner loop, as long as we still have `iter->next` and its value matches the one stored in `currVal`;\\n* we will then have 2 cases:\\n\\t* the loop never run, since we only have one node with `currVal` right after `prev`, so this very node will become our `prev` for the next iteration;\\n\\t* otherwise, it means we found multiple occurrences of the same value and then we will just have to slice them away frome the list: in the next iteration `prev` will stay the same (so, potentially it might always be just `res`) and its successor will be the next node with a different value than `currVal`.\\n\\nOnce we are done, we can return `res->next` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        int currVal;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            currVal = iter->val;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == currVal) iter = iter->next;\\n            // case 1: only one node with currVal\\n            if (iter == prev->next || !iter) prev = iter;\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```\\n\\nAnd since it just occurred to me that with my last version of the code `currVal` has little use, refactor without it - performance is clearly basically the same, despite saving a few bytes and assignments:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == iter->val) iter = iter->next;\\n            // case 1: only one node with the same value\\n            if (iter == prev->next || !iter) prev = iter;\\n            // case 2: multiple nodes with the same value found\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        int currVal;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            currVal = iter->val;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == currVal) iter = iter->next;\\n            // case 1: only one node with currVal\\n            if (iter == prev->next || !iter) prev = iter;\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == iter->val) iter = iter->next;\\n            // case 1: only one node with the same value\\n            if (iter == prev->next || !iter) prev = iter;\\n            // case 2: multiple nodes with the same value found\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382651,
                "title": "standard-c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe standard way to handle this use case is to use the so-called Sentinel Node. Sentinel nodes are widely used for trees and linked lists as pseudo-heads, pseudo-tails, etc. They are purely functional and usually don\\'t hold any data. Their primary purpose is to standardize the situation to avoid edge case handling.\\n\\nFor example, let\\'s use here pseudo-head with zero value to ensure that the situation \"delete the list head\" could never happen, and all nodes to delete are \"inside\" the list.\\n\\n# Complexity\\n- Time complexity: O(N)\\n    one linear traversing of the linked list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n    Because not using any additonal space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel = new ListNode(0, head);\\n        ListNode* prev = sentinel;\\n        while(head){\\n            if(head->next and head->val == head->next->val){\\n                while(head->next and head->val == head->next->val){\\n                    head = head->next;\\n                }\\n                prev->next = head->next;\\n            }\\n            else{\\n                prev = prev->next;\\n            }\\n            head = head->next; \\n        }\\n        return sentinel->next;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel = new ListNode(0, head);\\n        ListNode* prev = sentinel;\\n        while(head){\\n            if(head->next and head->val == head->next->val){\\n                while(head->next and head->val == head->next->val){\\n                    head = head->next;\\n                }\\n                prev->next = head->next;\\n            }\\n            else{\\n                prev = prev->next;\\n            }\\n            head = head->next; \\n        }\\n        return sentinel->next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185194,
                "title": "82-remove-duplicates-from-sorted-list-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a dummy node dummy and set its next node as the head of the linked list.\\n2. Create a prev variable and initialize it with dummy.\\n3. Use a while loop to traverse the linked list while head and head.next are not None.\\n4. Check if the value of the current node head is equal to the value of the next node head.next.\\n5. If yes, then use another while loop to traverse the linked list and find all the duplicates.\\n6. Once all the duplicates are found, set head to head.next and update the next node of prev to head.\\n7. If the values are not equal, update the prev to prev.next and head to head.next.\\n8. Return dummy.next as the new head of the linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                prev.next = head\\n            else:\\n                prev = prev.next\\n                head = head.next\\n        return dummy.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                prev.next = head\\n            else:\\n                prev = prev.next\\n                head = head.next\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893347,
                "title": "100-fastest-typescript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) { return null }\\n  if (!head.next) { return head }\\n  let fakeHead = new ListNode(undefined, head) // beginning of a returned linked list\\n  let prev = fakeHead // start of the group with same values\\n  let current = head // pointer\\n\\n  while (current) { // move through the current group until new value is seen\\n    while (current.next && prev.next && prev.next.val === current.next.val) { current = current.next }\\n\\n    if (prev.next === current) {\\n      prev = prev.next // if group has only one member, move prev to current\\n    } else {\\n      prev.next = current.next // otherwise, exclude the group\\n    }\\n\\n    current = current.next as ListNode // Move to the next node\\n  }\\n\\n  return fakeHead.next\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) { return null }\\n  if (!head.next) { return head }\\n  let fakeHead = new ListNode(undefined, head) // beginning of a returned linked list\\n  let prev = fakeHead // start of the group with same values\\n  let current = head // pointer\\n\\n  while (current) { // move through the current group until new value is seen\\n    while (current.next && prev.next && prev.next.val === current.next.val) { current = current.next }\\n\\n    if (prev.next === current) {\\n      prev = prev.next // if group has only one member, move prev to current\\n    } else {\\n      prev.next = current.next // otherwise, exclude the group\\n    }\\n\\n    current = current.next as ListNode // Move to the next node\\n  }\\n\\n  return fakeHead.next\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832665,
                "title": "python3-runtime-28-ms-faster-than-99-71-memory-13-8-mb-less-than-96-26",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        fake = ListNode(0, head)\\n        pred = fake\\n        while head:\\n            if head.next and head.val==head.next.val:\\n                while head.next and head.val==head.next.val:\\n                    head = head.next\\n                pred.next = head.next\\n            else: \\n\\t\\t\\t\\tpred = pred.next\\n            head = head.next\\n        return fake.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        fake = ListNode(0, head)\\n        pred = fake\\n        while head:\\n            if head.next and head.val==head.next.val:\\n                while head.next and head.val==head.next.val:\\n                    head = head.next\\n                pred.next = head.next\\n            else: \\n\\t\\t\\t\\tpred = pred.next\\n            head = head.next\\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003116,
                "title": "c-recursion-simple-straight-and-easy-to-understand-solution",
                "content": "```\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(head->val!=head->next->val){\\n            head->next=deleteDuplicates(head->next);\\n            return head;\\n        }\\n        int val=head->val;\\n        while(head && head->val==val)\\n            head=head->next;\\n        return deleteDuplicates(head);\\n    }\\n};\\n```\\n\\nTime Complexity:  O(n) where n is number of nodes in linked list.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(head->val!=head->next->val){\\n            head->next=deleteDuplicates(head->next);\\n            return head;\\n        }\\n        int val=head->val;\\n        while(head && head->val==val)\\n            head=head->next;\\n        return deleteDuplicates(head);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588495,
                "title": "java-clear-explanation-of-question-and-logic-behind-the-answer",
                "content": "ok lets do this!!\\ni see a lot of people unabe to explain the question and the solution!\\nlet me first explain the question!!\\nquestion says to remove the duplicates from an sorted linked list!\\n(piece of advice-whenever you are given a sorted ds ,this is a hint that the question is easy....so dont think too much)\\nanyways lets see some ex:\\n1->2->2->3->3->4;\\nwe are required to remove ALL THE DUPLICATES ;\\nthus final list would be\\n1->4\\nand not\\n1->2->3->4;\\n\\nso lets go into the solution!\\nlike any other linked list problem lets take two pointer,\\none fast and one slow!\\nthe fast and slow both move one step at a time but fast is always ahead of slow as fast starts one node further than slow in the beginning!\\nLOGIC AND INTUITION:\\n\"thus the function of our fast node is to search for duplicates and wait for slow to catch up before moving any further!\\nin other words whenever fast detects a duplicate it would keep traversing till the last duplicate and then wait..\\nthe slow pointer will remove(delete) all the duplicate in the way and finally come to  fast node!\\nthis process continues till the fast encounters a null value indicating end of linkedl list\"\\n\\nINITIALLY WE ALSO NEED A DUMMY NODE SO THAT FAST IS ONE STEP AHEAD OF SLOW!\\n\\n```\\npublic class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n    slow.next = fast;\\n    while(fast != null) {\\n    \\twhile (fast.next != null && fast.val == fast.next.val) { // this loop basically takes fast to end of the current duplicates that we are tracking\\n     \\t\\tfast = fast.next;   \\n    \\t}\\n    \\tif (slow.next != fast) { \\n    \\t\\tslow.next = fast.next; //remove the duplicates.\\n    \\t\\tfast = slow.next;     //fast moves to next unique value .\\n    \\t} else { //no duplicates...lets move towards right!!.\\n    \\t\\tslow = slow.next;\\n    \\t\\tfast = fast.next;\\n    \\t}\\n    \\t\\n    }\\n    return dummy.next;\\n} }\\n\\n\\nhope it helps!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n    slow.next = fast;\\n    while(fast != null) {\\n    \\twhile (fast.next != null && fast.val == fast.next.val) { // this loop basically takes fast to end of the current duplicates that we are tracking\\n     \\t\\tfast = fast.next;   \\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 508337,
                "title": "java-easy-10-line-solution-with-explanation",
                "content": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif(head == null) return head;\\n\\tListNode dummy = new ListNode(0), pre = dummy, curr = head;\\n\\tpre.next = curr;\\n\\twhile(curr != null) {\\n\\t\\twhile(curr.next != null && curr.val == curr.next.val) \\n\\t\\t\\tcurr = curr.next;                   // curr goes to next node until it finds new val which is not same as prev one\\n\\t\\tif(pre.next == curr) pre = pre.next;    // no duplicate, so move pre to next node\\n\\t\\telse pre.next = curr.next;              // skip duplicate but don\\'t move pre\\n\\t\\tcurr = curr.next;                       // update curr\\n\\t}\\n\\treturn dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif(head == null) return head;\\n\\tListNode dummy = new ListNode(0), pre = dummy, curr = head;\\n\\tpre.next = curr;\\n\\twhile(curr != null) {\\n\\t\\twhile(curr.next != null && curr.val == curr.next.val) \\n\\t\\t\\tcurr = curr.next;                   // curr goes to next node until it finds new val which is not same as prev one\\n\\t\\tif(pre.next == curr) pre = pre.next;    // no duplicate, so move pre to next node\\n\\t\\telse pre.next = curr.next;              // skip duplicate but don\\'t move pre\\n\\t\\tcurr = curr.next;                       // update curr\\n\\t}\\n\\treturn dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905732,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* dummyNode = new ListNode(-1);\\n        dummyNode -> next = head;\\n        ListNode* curr = dummyNode;\\n\\n        while(curr->next!=nullptr&&curr->next->next!=nullptr){\\n            if(curr->next->val==curr->next->next->val){\\n                int duplicate = curr->next->val;\\n                while(curr->next!=nullptr&&curr->next->val==duplicate){\\n                    ListNode* temp = curr -> next;\\n                    curr -> next = curr->next->next;\\n                    delete temp;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```\\n\\n![i.jpg](https://assets.leetcode.com/users/images/5ee16cc9-1523-46bf-bcae-e384caf0092f_1691954059.9454777.webp)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* dummyNode = new ListNode(-1);\\n        dummyNode -> next = head;\\n        ListNode* curr = dummyNode;\\n\\n        while(curr->next!=nullptr&&curr->next->next!=nullptr){\\n            if(curr->next->val==curr->next->next->val){\\n                int duplicate = curr->next->val;\\n                while(curr->next!=nullptr&&curr->next->val==duplicate){\\n                    ListNode* temp = curr -> next;\\n                    curr -> next = curr->next->next;\\n                    delete temp;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617877,
                "title": "both-the-solutions-fully-and-clearly-explained-1-iterative-solution-2-using-stl-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. For iterative solution, simply iterate the Linked List and check for duplicate nodes and delete them.\\n2. For STL solution, store the elements of the Linked List in the map and delete them if their frequency is greater than 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Solution 1:***\\n\\n1. Iterate the Linked List from one step back than the head, as it is possible that we need to delete the first element as well, and we know that **for deleting any node we require the previous node**.\\n2. Now just iterate the Linked List and store the current value of node in a variable named \\'variable\\' and till the subsequent elements == varible delete them.\\n3. If the above condition is not true, just move forward i.e., itr = itr -> next.\\n4. Finally return prev -> next (since our head of the list is stored in prev -> next pointer).\\n\\n\\n***Solution 2:***\\n\\n1. Iterate the Linked List and store the elements in a map named mp.\\n2. Create a new node \\'newHead\\' as the dummy head of the resulting Linked List.\\n3. Create a temporary pointer \\'temp\\' to keep treack of the last node in the resulting Linked List. Initalize it to \\'newHead\\'.\\n4. Iterate over the map, when (it.second == 1) create a new node \\'ans\\' with the value (it.first).\\n5. Connect the new node \\'ans\\' to the last node in the resulting Linked List by assigning \\'temp -> next = ans\\', and update \\'temp\\' to \\'ans\\' for the next iteration.\\n6. After processing all the unique values, the resulting Linked List is ready. Return \\'newHead -> next\\', which points to the first node in the resulting Linked List. \\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is O(n) for both the approaches.\\n\\n- Space complexity: \\n**Solution 1: O(1)\\n Solution 2: O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIn Solution 2 we are using map to store the unique values of the Linked List.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head == NULL) return head;\\n\\n        ListNode* prev = new ListNode(); //this is pointing before head\\n        //Let\\'s say the list is 2 -> 2 -> 3 -> 5 -> 5 -> 5, in this case we have to delete the 1st element as well, therefore we have used prev pointer\\n        prev -> next = head;\\n\\n        ListNode* itr = prev;\\n\\n        while(itr -> next != NULL && itr -> next -> next != NULL)\\n        {\\n            if(itr -> next -> val == itr -> next -> next -> val)\\n            {\\n                int variable = itr -> next -> val;\\n                //We have to delete all the duplicate elements along with the original element\\n                while(itr -> next != NULL && itr -> next -> val == variable)\\n                {\\n                    itr -> next = itr -> next -> next;\\n                }\\n            }\\n            else //if we\\'ll not write else condition, we\\'ll get TLE\\n            {\\n                itr = itr -> next;\\n            }\\n        }\\n        return prev -> next; //head pointer is in prev -> next\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map <int, int> mp;\\n\\n        while(head != NULL)\\n        {\\n            mp[head -> val]++;\\n            head = head -> next;\\n        }\\n\\n        ListNode* newHead = new ListNode(); //Creating new list for answer\\n        ListNode* temp = newHead; //temp variable to keep track of the last node\\n        for(auto & it: mp)\\n        {\\n            if(it.second == 1)\\n            {\\n                ListNode* ans = new ListNode(it.first); //to avoid integer to pointer conversion\\n                temp -> next = ans;\\n                temp = ans;\\n            }\\n        }\\n        return newHead -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head == NULL) return head;\\n\\n        ListNode* prev = new ListNode(); //this is pointing before head\\n        //Let\\'s say the list is 2 -> 2 -> 3 -> 5 -> 5 -> 5, in this case we have to delete the 1st element as well, therefore we have used prev pointer\\n        prev -> next = head;\\n\\n        ListNode* itr = prev;\\n\\n        while(itr -> next != NULL && itr -> next -> next != NULL)\\n        {\\n            if(itr -> next -> val == itr -> next -> next -> val)\\n            {\\n                int variable = itr -> next -> val;\\n                //We have to delete all the duplicate elements along with the original element\\n                while(itr -> next != NULL && itr -> next -> val == variable)\\n                {\\n                    itr -> next = itr -> next -> next;\\n                }\\n            }\\n            else //if we\\'ll not write else condition, we\\'ll get TLE\\n            {\\n                itr = itr -> next;\\n            }\\n        }\\n        return prev -> next; //head pointer is in prev -> next\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map <int, int> mp;\\n\\n        while(head != NULL)\\n        {\\n            mp[head -> val]++;\\n            head = head -> next;\\n        }\\n\\n        ListNode* newHead = new ListNode(); //Creating new list for answer\\n        ListNode* temp = newHead; //temp variable to keep track of the last node\\n        for(auto & it: mp)\\n        {\\n            if(it.second == 1)\\n            {\\n                ListNode* ans = new ListNode(it.first); //to avoid integer to pointer conversion\\n                temp -> next = ans;\\n                temp = ans;\\n            }\\n        }\\n        return newHead -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989127,
                "title": "100-faster-java-code-with-comments-for-better-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy =new ListNode(0,head);\\n        ListNode prev=dummy;\\n        while(head!=null){\\n            if(head.next!=null && head.val==head.next.val){\\n                //skip that nodes\\n                while(head.next!=null && head.val==head.next.val){\\n                    head=head.next;\\n                }\\n                prev.next=head.next;  //prev\\'s next point to the head next\\n            }else{\\n                prev=prev.next;\\n            }\\n            head=head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\nif it is helpful upvote please",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy =new ListNode(0,head);\\n        ListNode prev=dummy;\\n        while(head!=null){\\n            if(head.next!=null && head.val==head.next.val){\\n                //skip that nodes\\n                while(head.next!=null && head.val==head.next.val){\\n                    head=head.next;\\n                }\\n                prev.next=head.next;  //prev\\'s next point to the head next\\n            }else{\\n                prev=prev.next;\\n            }\\n            head=head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433787,
                "title": "js-o-n-time-o-1-space-with-explanation",
                "content": "Approach:\\nIn this problem, there are 3 cases to consider mainly\\n1. duplicates in the beginning - need to set a new `head`.\\n2. duplicates in between and at the end of the list.\\n3. unique value\\n\\nBasically, we start by checking values of the two adjacent nodes. If the values are equal (duplicates) -\\n1. for case 1, we did not have a prior node with unique value, the current node will basically be the first possible node encountered with a unique value (`possible` since after traversing further nodes, this node could also be having duplicate value). So we set this as the new node as head.\\n2. for case 2, we will have encountered a prior node with a unique value already, so we set the next pointer of that node as the current node.\\n3. for case 3, we set the prev node as the current node and move to the next node.\\n\\n```\\nvar deleteDuplicates = function(head) {\\n    let curr = head,\\n        prev = null;\\n    while(curr && curr.next) {\\n\\t\\t// if current node and next node value are same,\\n\\t\\t// iterate until we get to the node which does not have the same value as these 2 nodes\\n        if(curr.val === curr.next.val) {\\n            while(curr && curr.next && curr.val === curr.next.val) {\\n                curr = curr.next;\\n            }\\n\\t\\t\\t// the above loop will stop at the last duplicate node, for instance for 1,1,1,2,...\\n\\t\\t\\t// the loop will stop at 3rd node from start with value 1\\n\\t\\t\\t// so we move to next node which is not part of the previous set of duplicates\\n            curr = curr.next;\\n\\t\\t\\t\\n\\t\\t\\t// if no prev unique value node is encountered, set the `head` to this node\\n            if(!prev) {\\n                head = curr;\\n            } else {    // if there is a prev unique value node, reset it\\'s next pointer\\n\\t\\t\\t\\t// we do not change the prev node, since the current node itself can be having duplicate value\\n\\t\\t\\t\\t// so we will process the current node, until we identify it as having a unique value\\n                prev.next = curr;    \\n            }\\n        } else {    // node is having unique value\\n\\t\\t\\t// set prev as the current node and move to the next node\\n            prev = curr;\\n            curr = curr.next;    \\n        }\\n    }\\n    return head;    // finally return the head\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(1)\\n\\nTest Cases for dry run:\\n```\\n[1,2,3,3,4,4,5]      // duplicates in between\\n[1,1,1,2,2,2,3,4]    // duplicates at the beginning\\n[1,2,3,4,4,4]        // duplicates at the end\\n[1,1,2,2,3,3]        // all duplicates\\n[]                   // empty list\\n[1]                  // only one node\\n[1,1]                // only two nodes (duplicates)\\n[1,2]                // only two nodes (no duplicates)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    let curr = head,\\n        prev = null;\\n    while(curr && curr.next) {\\n\\t\\t// if current node and next node value are same,\\n\\t\\t// iterate until we get to the node which does not have the same value as these 2 nodes\\n        if(curr.val === curr.next.val) {\\n            while(curr && curr.next && curr.val === curr.next.val) {\\n                curr = curr.next;\\n            }\\n\\t\\t\\t// the above loop will stop at the last duplicate node, for instance for 1,1,1,2,...\\n\\t\\t\\t// the loop will stop at 3rd node from start with value 1\\n\\t\\t\\t// so we move to next node which is not part of the previous set of duplicates\\n            curr = curr.next;\\n\\t\\t\\t\\n\\t\\t\\t// if no prev unique value node is encountered, set the `head` to this node\\n            if(!prev) {\\n                head = curr;\\n            } else {    // if there is a prev unique value node, reset it\\'s next pointer\\n\\t\\t\\t\\t// we do not change the prev node, since the current node itself can be having duplicate value\\n\\t\\t\\t\\t// so we will process the current node, until we identify it as having a unique value\\n                prev.next = curr;    \\n            }\\n        } else {    // node is having unique value\\n\\t\\t\\t// set prev as the current node and move to the next node\\n            prev = curr;\\n            curr = curr.next;    \\n        }\\n    }\\n    return head;    // finally return the head\\n};\\n```\n```\\n[1,2,3,3,4,4,5]      // duplicates in between\\n[1,1,1,2,2,2,3,4]    // duplicates at the beginning\\n[1,2,3,4,4,4]        // duplicates at the end\\n[1,1,2,2,3,3]        // all duplicates\\n[]                   // empty list\\n[1]                  // only one node\\n[1,1]                // only two nodes (duplicates)\\n[1,2]                // only two nodes (no duplicates)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338369,
                "title": "short-rust-solution",
                "content": "```rust\\npub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    if head.is_none() { return head; }\\n\\n    let mut to_remove = head.as_ref().unwrap().val - 1;\\n    let mut dummy = Some(Box::new(ListNode { next: head, val: to_remove, }));\\n    let mut node = &mut dummy.as_mut().unwrap().next;\\n\\n    loop {\\n        match node {\\n            None => return dummy.unwrap().next,\\n            Some(n) if n.val == to_remove => *node = n.next.take(),\\n            Some(n) if n.next.is_some() && n.val == n.next.as_ref().unwrap().val => to_remove = n.val,\\n            Some(n) => {\\n                node = &mut n.next;\\n                if let Some(n) = node { to_remove = n.val - 1; }\\n            }\\n        }\\n    }\\n}\\n```\\nIt\\'s important to use pattern matching with conditions inside its branches, otherwise the ownership issues will drive you crazy.",
                "solutionTags": [],
                "code": "```rust\\npub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    if head.is_none() { return head; }\\n\\n    let mut to_remove = head.as_ref().unwrap().val - 1;\\n    let mut dummy = Some(Box::new(ListNode { next: head, val: to_remove, }));\\n    let mut node = &mut dummy.as_mut().unwrap().next;\\n\\n    loop {\\n        match node {\\n            None => return dummy.unwrap().next,\\n            Some(n) if n.val == to_remove => *node = n.next.take(),\\n            Some(n) if n.next.is_some() && n.val == n.next.as_ref().unwrap().val => to_remove = n.val,\\n            Some(n) => {\\n                node = &mut n.next;\\n                if let Some(n) = node { to_remove = n.val - 1; }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048375,
                "title": "beginner-friendly-solution-hash-map-c-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* newlist=new ListNode();\\n        ListNode* temp2=newlist;\\n        map<int,int>m;\\n        while(temp)\\n        {\\n            m[temp->val]++;\\n            temp=temp->next;\\n        }\\n        for(auto i=m.begin();i!=m.end();i++)\\n        {\\n            if(i->second==1)\\n            {\\n                cout<<i->first<<endl;\\n                ListNode* node=new ListNode(i->first);\\n                temp2->next=node;\\n                temp2=temp2->next;\\n            }\\n        }\\n        return newlist->next;\\n    }\\n    \\n};\\n```\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/98ecf9d3-1257-4ca7-9638-6b2afb6c4ce6_1694792835.9833024.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* newlist=new ListNode();\\n        ListNode* temp2=newlist;\\n        map<int,int>m;\\n        while(temp)\\n        {\\n            m[temp->val]++;\\n            temp=temp->next;\\n        }\\n        for(auto i=m.begin();i!=m.end();i++)\\n        {\\n            if(i->second==1)\\n            {\\n                cout<<i->first<<endl;\\n                ListNode* node=new ListNode(i->first);\\n                temp2->next=node;\\n                temp2=temp2->next;\\n            }\\n        }\\n        return newlist->next;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3212752,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode ans = new ListNode();\\n        ans.next = head;\\n\\n        ListNode ptr = ans;\\n\\n        while (ptr.next != null && ptr.next.next != null) {\\n\\n            if (ptr.next.val == ptr.next.next.val) {\\n                int value = ptr.next.val;\\n                while (ptr.next != null && ptr.next.val == value) {\\n                    ptr.next = ptr.next.next;\\n                }\\n            } else {\\n                ptr = ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode ans = new ListNode();\\n        ans.next = head;\\n\\n        ListNode ptr = ans;\\n\\n        while (ptr.next != null && ptr.next.next != null) {\\n\\n            if (ptr.next.val == ptr.next.next.val) {\\n                int value = ptr.next.val;\\n                while (ptr.next != null && ptr.next.val == value) {\\n                    ptr.next = ptr.next.next;\\n                }\\n            } else {\\n                ptr = ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124662,
                "title": "c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        bool j = false;\\n        while (head->next!=NULL && head->val == head->next->val){\\n            j = true;\\n            head->next = head->next->next;\\n        }\\n        if (j){\\n            head = deleteDuplicates(head->next);\\n            return head;\\n        }\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/34398cd7-c2e8-4957-8661-69f127428365_1654659184.92216.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        bool j = false;\\n        while (head->next!=NULL && head->val == head->next->val){\\n            j = true;\\n            head->next = head->next->next;\\n        }\\n        if (j){\\n            head = deleteDuplicates(head->next);\\n            return head;\\n        }\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834089,
                "title": "1-ms-java-solution-o-1-space-complexity-o-n-time-complexity",
                "content": "***STEPS :***\\n* Make two arrays of 100 length to keep the track of the count of ListNodes Value.\\n* Iterate the Linked List for counting .\\n* Create a dummy node and marks its next to head node.\\n* Create a temp node to iterate the linked list .\\n* Now while iterating check if nexts nodes count in the array is 1 or not if it is one then move to next node else move to next of next node .\\n* Return dummy\\'s next node\\n\\n\\n\\n**TIME COMPLEXITY ANALYSIS:**\\n* *TIME COMPLEXITY :* O(N) {For counting} + O(N) {For iterating the array} =O(2N)\\n* *SPACE COMPLEXITY :* O(1) {For keep track of count of Nodes value = O(1)\\n\\n\\n*Code for more understanding*\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        int pos [] = new int [101];\\n        int neg [] = new int [100];\\n        ListNode temp = head;\\n        while(temp!=null){\\n            if(temp.val>=0){\\n                pos[temp.val]++;\\n            }\\n            else{\\n                neg[Math.abs(temp.val)]++;\\n            }\\n            temp = temp.next;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy .next = head;\\n        temp = dummy;\\n        while(temp.next!=null){\\n            \\n            if(temp.next.val>=0){\\n                if(pos[temp.next.val]!=1){\\n                    temp.next = temp.next.next;\\n                }\\n                else temp = temp.next;\\n            }\\n            else{\\n               if(neg[Math.abs(temp.next.val)]!=1){\\n                   temp.next = temp.next.next;\\n               } \\n                else temp = temp.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        int pos [] = new int [101];\\n        int neg [] = new int [100];\\n        ListNode temp = head;\\n        while(temp!=null){\\n            if(temp.val>=0){\\n                pos[temp.val]++;\\n            }\\n            else{\\n                neg[Math.abs(temp.val)]++;\\n            }\\n            temp = temp.next;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy .next = head;\\n        temp = dummy;\\n        while(temp.next!=null){\\n            \\n            if(temp.next.val>=0){\\n                if(pos[temp.next.val]!=1){\\n                    temp.next = temp.next.next;\\n                }\\n                else temp = temp.next;\\n            }\\n            else{\\n               if(neg[Math.abs(temp.next.val)]!=1){\\n                   temp.next = temp.next.next;\\n               } \\n                else temp = temp.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833446,
                "title": "c-code-easy-explanation-w-commented-code-faster-than-100-00-easy-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n     //if head is NULL or just having a single node, simply return from here head \\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    \\n    // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n    struct ListNode* prehead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    \\n    prehead -> val = -101;\\n    prehead -> next = head; // prehead\\'s next contain head\\n    \\n    struct ListNode* curr = prehead; // make a current pointer to move\\n    \\n    // while it not reaches to the end\\n    while(curr -> next != NULL && curr -> next -> next != NULL)\\n    {\\n        // if values are equal, now we have to delete values, till when they are equal\\n        if(curr -> next -> val == curr -> next -> next -> val)\\n        {\\n            struct ListNode* temp = curr -> next -> next;\\n            \\n            while(temp != NULL && curr -> next -> val == temp -> val)\\n            {\\n                struct ListNode* anthortemp = temp;\\n                temp = temp -> next;\\n                \\n                free(anthortemp); // actually freeing up the memory\\n            }\\n            \\n            curr -> next = temp;\\n            \\n        }\\n        else // if values are not equal\\'s then simply move curr to next\\n        {\\n            curr = curr -> next;\\n        }\\n    }\\n    \\n     // and at last, prehead\\'s next contain head node, so return that\\n    return prehead -> next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n     //if head is NULL or just having a single node, simply return from here head \\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    \\n    // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n    struct ListNode* prehead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    \\n    prehead -> val = -101;\\n    prehead -> next = head; // prehead\\'s next contain head\\n    \\n    struct ListNode* curr = prehead; // make a current pointer to move\\n    \\n    // while it not reaches to the end\\n    while(curr -> next != NULL && curr -> next -> next != NULL)\\n    {\\n        // if values are equal, now we have to delete values, till when they are equal\\n        if(curr -> next -> val == curr -> next -> next -> val)\\n        {\\n            struct ListNode* temp = curr -> next -> next;\\n            \\n            while(temp != NULL && curr -> next -> val == temp -> val)\\n            {\\n                struct ListNode* anthortemp = temp;\\n                temp = temp -> next;\\n                \\n                free(anthortemp); // actually freeing up the memory\\n            }\\n            \\n            curr -> next = temp;\\n            \\n        }\\n        else // if values are not equal\\'s then simply move curr to next\\n        {\\n            curr = curr -> next;\\n        }\\n    }\\n    \\n     // and at last, prehead\\'s next contain head node, so return that\\n    return prehead -> next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833010,
                "title": "javascript-easy-to-understand-2-solutions-detailed-explanation",
                "content": "## Core Strategy\\n\\nThe important points for this problem are:\\n- the original linked list is sorted\\n- we need to remove all the duplicate number, rather than left one there\\n\\nSo, what we need to do is:\\n- find a way to check one value is duplicated or not\\n- traverse the linked list and remove the duplicate nodes\\n- make sure we can still get the head of the final linked list\\n\\nFor step 2, we just use loop to traverse the linked list.\\nFor step 3, we could use a dummy node as the new head, to let us easier remove the old head node if we need.\\nFor step 1, here are 2 solutions with extra space or not.\\n\\n## With extra space\\n\\nFor this solution, we use a hashtable to do the counting for values in linked list. Then traverse again and remove the nodes we don\\'t need.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst deleteDuplicates = head => {\\n  const count = {};\\n  const dummy = { next: head };\\n  for (let cur = head; cur; cur = cur.next) {\\n    count[cur.val] = (count[cur.val] || 0) + 1;\\n  }\\n  for (let cur = dummy; cur.next;) {\\n    count[cur.next.val] > 1 ? (cur.next = cur.next.next) : (cur = cur.next);\\n  }\\n  return dummy.next;\\n};\\n```\\n\\n## Without extra space\\n\\nFor this solution, since we don\\'t want to use extra space, so we need to maintain 3 pointers - `prev`, `cur` and `next`. By this, we could compare the value and remove the nodes easily.\\n\\nI use the optional chaining operator (`?.`) in JS to avoid more checking logic.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst deleteDuplicates = head => {\\n  const dummy = { next: head };\\n  let prev = dummy;\\n  let cur = head;\\n  let next = head?.next;\\n  while (next) {\\n    if (cur.val !== next.val) {\\n      prev = cur;\\n      cur = next;\\n      next = next.next;\\n    } else {\\n      const val = cur.val;\\n      while (next && next.val === val) {\\n        next = next.next;\\n      }\\n      cur = next;\\n      next = next?.next;\\n      prev.next = cur;\\n    }\\n  }\\n  return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst deleteDuplicates = head => {\\n  const count = {};\\n  const dummy = { next: head };\\n  for (let cur = head; cur; cur = cur.next) {\\n    count[cur.val] = (count[cur.val] || 0) + 1;\\n  }\\n  for (let cur = dummy; cur.next;) {\\n    count[cur.next.val] > 1 ? (cur.next = cur.next.next) : (cur = cur.next);\\n  }\\n  return dummy.next;\\n};\\n```\n```js\\nconst deleteDuplicates = head => {\\n  const dummy = { next: head };\\n  let prev = dummy;\\n  let cur = head;\\n  let next = head?.next;\\n  while (next) {\\n    if (cur.val !== next.val) {\\n      prev = cur;\\n      cur = next;\\n      next = next.next;\\n    } else {\\n      const val = cur.val;\\n      while (next && next.val === val) {\\n        next = next.next;\\n      }\\n      cur = next;\\n      next = next?.next;\\n      prev.next = cur;\\n    }\\n  }\\n  return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706302,
                "title": "python3-easy-to-understand-recurrsion-faster-then-98",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tif not head.next:\\n\\t\\treturn head\\n\\n\\tif head.val != head.next.val:\\n\\t\\thead.next = self.deleteDuplicates(head.next)\\n\\t\\treturn head\\n\\n\\tif not head.next.next or head.next.val != head.next.next.val:\\n\\t\\treturn self.deleteDuplicates(head.next.next)\\n\\n\\n\\treturn self.deleteDuplicates(head.next) \\n```\\n\\n![image](https://assets.leetcode.com/users/images/18cd6f3e-253d-4785-8a74-937a33da5d5b_1642746179.505114.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tif not head.next:\\n\\t\\treturn head\\n\\n\\tif head.val != head.next.val:\\n\\t\\thead.next = self.deleteDuplicates(head.next)\\n\\t\\treturn head\\n\\n\\tif not head.next.next or head.next.val != head.next.next.val:\\n\\t\\treturn self.deleteDuplicates(head.next.next)\\n\\n\\n\\treturn self.deleteDuplicates(head.next) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003478,
                "title": "c-super-simple-easy-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *last = new ListNode(0), *new_head = last;\\n        \\n        while (head) {\\n            \\n            if (head->next && head->val == head->next->val) {\\n                while (head->next && head->val == head->next->val)\\n                    head = head->next;\\n            }\\n            \\n            else {\\n                last->next = head;\\n                last = head;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        last->next = NULL;\\n        return new_head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *last = new ListNode(0), *new_head = last;\\n        \\n        while (head) {\\n            \\n            if (head->next && head->val == head->next->val) {\\n                while (head->next && head->val == head->next->val)\\n                    head = head->next;\\n            }\\n            \\n            else {\\n                last->next = head;\\n                last = head;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        last->next = NULL;\\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561149,
                "title": "c-mimimalizm",
                "content": "```cpp\\nListNode* deleteDuplicates(ListNode* head, bool dup = false) {\\n    if (head == nullptr)\\n        return nullptr;\\n    while (head->next != 0 && head->val == head->next->val) {\\n        dup = true;\\n        head->next = head->next->next;\\n    }\\n    head->next = deleteDuplicates(head->next);\\n    return dup ? head->next : head;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* deleteDuplicates(ListNode* head, bool dup = false) {\\n    if (head == nullptr)\\n        return nullptr;\\n    while (head->next != 0 && head->val == head->next->val) {\\n        dup = true;\\n        head->next = head->next->next;\\n    }\\n    head->next = deleteDuplicates(head->next);\\n    return dup ? head->next : head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28469,
                "title": "java-concise-iterative-solution",
                "content": "        \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0);\\n        p = dummy;\\n        dummy.next = head;\\n        while (head != null && head.next != null) {\\n            if (head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val) {\\n                    head = head.next;\\n                }\\n                head = head.next;\\n                p.next = head;\\n            } else {\\n                head = head.next;\\n                p = p.next;\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "        \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0);\\n        p = dummy;\\n        dummy.next = head;\\n        while (head != null && head.next != null) {\\n            if (head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val) {\\n                    head = head.next;\\n                }\\n                head = head.next;\\n                p.next = head;\\n            } else {\\n                head = head.next;\\n                p = p.next;\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28390,
                "title": "a-easy-to-understand-python-solution",
                "content": "\\n\\n    def deleteDuplicates(self, head):\\n        # Add a dummy node point to the current list\\n        newhead = ListNode(0)\\n        newhead.next = head\\n        val_need_to_be_deleted = None\\n        tail = newhead\\n        \\n        while head:\\n            \\n            # Triger delete mode if current has the same val as the next\\n            if head and head.next and head.val == head.next.val:\\n                val_need_to_be_deleted = head.val\\n            \\n            # Not a dup if delete mode is off or the current value doesn't match the value need to be deleted\\n            if val_need_to_be_deleted == None or head.val != val_need_to_be_deleted:\\n                # add it to the newlist\\n                tail.next = head\\n                tail = head\\n                \\n            head = head.next\\n            \\n        tail.next = None\\n        return newhead.next",
                "solutionTags": [],
                "code": "\\n\\n    def deleteDuplicates(self, head):\\n        # Add a dummy node point to the current list\\n        newhead = ListNode(0)\\n        newhead.next = head\\n        val_need_to_be_deleted = None\\n        tail = newhead\\n        \\n        while head:\\n            \\n            # Triger delete mode if current has the same val as the next\\n            if head and head.next and head.val == head.next.val:\\n                val_need_to_be_deleted = head.val\\n            \\n            # Not a dup if delete mode is off or the current value doesn't match the value need to be deleted\\n            if val_need_to_be_deleted == None or head.val != val_need_to_be_deleted:\\n                # add it to the newlist\\n                tail.next = head\\n                tail = head\\n                \\n            head = head.next\\n            \\n        tail.next = None\\n        return newhead.next",
                "codeTag": "Python3"
            },
            {
                "id": 3142482,
                "title": "easy-c-solution-linked-list-two-pointer-best-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Linklist + Two Pointer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approache by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist + Two Pointer.\\n\\n*/\\n\\n\\n/********************************************* First Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                if(prev == NULL){\\n                    head = curr->next;\\n                }\\n                else{\\n                    prev->next = curr->next;\\n                }\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Second Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail->next = curr;\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Third Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        dummyTail->next = curr;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist + Two Pointer.\\n\\n*/\\n\\n\\n/********************************************* First Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                if(prev == NULL){\\n                    head = curr->next;\\n                }\\n                else{\\n                    prev->next = curr->next;\\n                }\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Second Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail->next = curr;\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Third Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        dummyTail->next = curr;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120308,
                "title": "sabse-easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int target = head -> val;\\n\\n        if(head -> next -> val == target){\\n            while(head -> next && head -> next -> val == target){\\n               head = head -> next; \\n            }\\n           \\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n      \\n        else{\\n            \\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int target = head -> val;\\n\\n        if(head -> next -> val == target){\\n            while(head -> next && head -> next -> val == target){\\n               head = head -> next; \\n            }\\n           \\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n      \\n        else{\\n            \\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066893,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* t=head;\\n        int c=1;\\n        ListNode* dummy=new ListNode(1);\\n        ListNode* ans=dummy;\\n        int f=1;\\n        while(f && t)\\n        {\\n            ListNode* p=t;\\n            int c=0;\\n            while(t->next && t->val==t->next->val)\\n            {\\n                c++;\\n                t=t->next;\\n            }\\n            if(c==0)\\n            {\\n                ans->next=p;\\n                ans=ans->next;\\n            }\\n            t=t->next;\\n        }\\n        ans->next=NULL;\\n        return dummy->next;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* t=head;\\n        int c=1;\\n        ListNode* dummy=new ListNode(1);\\n        ListNode* ans=dummy;\\n        int f=1;\\n        while(f && t)\\n        {\\n            ListNode* p=t;\\n            int c=0;\\n            while(t->next && t->val==t->next->val)\\n            {\\n                c++;\\n                t=t->next;\\n            }\\n            if(c==0)\\n            {\\n                ans->next=p;\\n                ans=ans->next;\\n            }\\n            t=t->next;\\n        }\\n        ans->next=NULL;\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035441,
                "title": "my-accepted-python-code",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        if head is not None:\\n            if head.next is not None:\\n                if head.val == head.next.val:\\n                    headTemp = self.deleteDuplicates(head.next)\\n                    if headTemp is not None:\\n                        if head.val == headTemp.val:\\n                            if headTemp is not None:\\n                                return headTemp.next\\n                            return None\\n                    return headTemp\\n                else:\\n                    head.next = self.deleteDuplicates(head.next)\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        if head is not None:\\n            if head.next is not None:\\n                if head.val == head.next.val:\\n                    headTemp = self.deleteDuplicates(head.next)\\n                    if headTemp is not None:\\n                        if head.val == headTemp.val:\\n                            if headTemp is not None:\\n                                return headTemp.next\\n                            return None\\n                    return headTemp\\n                else:\\n                    head.next = self.deleteDuplicates(head.next)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027773,
                "title": "javascript-solution-with-explanation-o-n-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is defining a function deleteDuplicates that takes in a singly linked list head and removes any duplicate nodes from the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere is an explanation of the code:\\n\\nFirst, a dummy node is created with a value of 0 and it is set as the next node of the dummy node. This dummy node will be used to track the head of the list as it is modified. prev is set to dummy and curr is set to head.\\n\\nA while loop is then entered that will continue until curr is null. Inside the loop, there is another while loop that will continue until curr.next is null or curr.val is not equal to curr.next.val. This inner loop is used to move curr to the last occurrence of a value that is duplicated in the list.\\n\\nAfter the inner loop, there is an if statement that checks if prev.next is equal to curr. If it is, this means that curr was not a duplicate and prev should be advanced to curr. If prev.next is not equal to curr, this means that curr was a duplicate and prev.next should be set to curr.next to skip over the duplicates.\\n\\nFinally, curr is advanced to curr.next and the process repeats until curr is null. The modified list, with duplicates removed, is then returned as dummy.next.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), because the function iterates through the linked list once, and performs a constant amount of work on each iteration.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(1), because the function only stores a constant amount of data (the dummy node, the prev and curr pointers) regardless of the size of the input.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n   let dummy = new ListNode(0)\\n    dummy.next = head;\\n    let prev = dummy, curr = head;\\n    while (curr) {\\n        while (curr.next && curr.val == curr.next.val)\\n            curr = curr.next\\n        if (prev.next == curr)\\n            prev = curr\\n        else\\n            prev.next = curr.next\\n        curr = curr.next\\n    }\\n    return dummy.next\\n\\n};\\n<!--I hope this helps!-->\\n<!--Please upvote if you like this solution-->\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is defining a function deleteDuplicates that takes in a singly linked list head and removes any duplicate nodes from the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere is an explanation of the code:\\n\\nFirst, a dummy node is created with a value of 0 and it is set as the next node of the dummy node. This dummy node will be used to track the head of the list as it is modified. prev is set to dummy and curr is set to head.\\n\\nA while loop is then entered that will continue until curr is null. Inside the loop, there is another while loop that will continue until curr.next is null or curr.val is not equal to curr.next.val. This inner loop is used to move curr to the last occurrence of a value that is duplicated in the list.\\n\\nAfter the inner loop, there is an if statement that checks if prev.next is equal to curr. If it is, this means that curr was not a duplicate and prev should be advanced to curr. If prev.next is not equal to curr, this means that curr was a duplicate and prev.next should be set to curr.next to skip over the duplicates.\\n\\nFinally, curr is advanced to curr.next and the process repeats until curr is null. The modified list, with duplicates removed, is then returned as dummy.next.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), because the function iterates through the linked list once, and performs a constant amount of work on each iteration.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(1), because the function only stores a constant amount of data (the dummy node, the prev and curr pointers) regardless of the size of the input.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n   let dummy = new ListNode(0)\\n    dummy.next = head;\\n    let prev = dummy, curr = head;\\n    while (curr) {\\n        while (curr.next && curr.val == curr.next.val)\\n            curr = curr.next\\n        if (prev.next == curr)\\n            prev = curr\\n        else\\n            prev.next = curr.next\\n        curr = curr.next\\n    }\\n    return dummy.next\\n\\n};\\n<!--I hope this helps!-->\\n<!--Please upvote if you like this solution-->\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2743244,
                "title": "beginner-level-to-optimised-solution",
                "content": "**1. Beginner Level -**\\n\\nIn this approach, we are using an auxliary space (HashMap and HashSet) to point out duplicates and in the HashSet we are not considering those duplicates.\\n\\nI can certainly tell that it is a very lengthy approach, but in an Interview, it is bit easy to come up with, if you have a good knowledge of HashMap & HashSet.\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) { return null; }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ListNode node = head;\\n        \\n        // Traversing the LL and making the Map such that we can point duplicates\\n        while(node != null){\\n            if(map.containsKey(node.val)) { map.put(node.val, 1); }\\n            else { map.put(node.val, 0); }\\n            node = node.next;\\n        }\\n        \\n        HashSet<Integer> finalNodeVals = new HashSet<>();\\n        for(int i : map.keySet()){\\n            if(map.get(i) == 0) { finalNodeVals.add(i); }\\n        }\\n        \\n        if(finalNodeVals.size() == 0) { return null; }\\n        \\n        ListNode node1 = head, finalHead = head;\\n        boolean first = true;\\n        \\n        while(node1 != null){\\n            if(finalNodeVals.contains(node1.val) && first == true) { \\n                head = node1; finalHead = head; first = false; \\n            }\\n            else if(finalNodeVals.contains(node1.val) && first == false) { \\n                head.next = node1; head = head.next;\\n            }\\n            node1 = node1.next;\\n        }\\n        \\n        head.next = null;\\n        \\n        return finalHead;\\n    }\\n}\\n```\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(n)**\\n\\n**2. Optimised Level :-**\\n\\nBelow is the algorithm for the problem - \\n\\n* Make three nodes `pre`, \\'ans\\' & `curr`.\\n* `pre` will be the previous node to the current node and `curr` will be the current node. \\'ans\\' will point to `pre` at first, and will stay there.\\n* While duplicates found in current node(`curr`), then move on to the next node.\\n* If we move on, then the `curr` will **NOT** certainly be the next node to the `pre` node.\\n* At this point of time `pre`\\'s next pointer will point to `curr`\\'s next pointer. This way we are linking the non-duplicate nodes togher.\\n* Else the `pre`\\'s  next pointer will point to `curr`. Also `pre` will move on by 1 node like `curr`.\\n* Move forward the curr.\\n* After traversing the entire list as `curr`, just return the next pointed node of `ans`, which is our answer.\\n\\nPlease practise it to get a better point of view.\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode pre = new ListNode(0);\\n        pre.next = head;\\n        ListNode curr = head, ans = pre;\\n        \\n        while(curr != null){\\n            while(curr.next != null && curr.val == curr.next.val){\\n                curr = curr.next;\\n            }\\n            if(pre.next != curr){\\n                pre.next = curr.next;\\n            }\\n            else{\\n                pre.next = curr; pre = pre.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(n)\\nSpace Complexity: O(1)**\\n\\nHappy Coding :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) { return null; }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ListNode node = head;\\n        \\n        // Traversing the LL and making the Map such that we can point duplicates\\n        while(node != null){\\n            if(map.containsKey(node.val)) { map.put(node.val, 1); }\\n            else { map.put(node.val, 0); }\\n            node = node.next;\\n        }\\n        \\n        HashSet<Integer> finalNodeVals = new HashSet<>();\\n        for(int i : map.keySet()){\\n            if(map.get(i) == 0) { finalNodeVals.add(i); }\\n        }\\n        \\n        if(finalNodeVals.size() == 0) { return null; }\\n        \\n        ListNode node1 = head, finalHead = head;\\n        boolean first = true;\\n        \\n        while(node1 != null){\\n            if(finalNodeVals.contains(node1.val) && first == true) { \\n                head = node1; finalHead = head; first = false; \\n            }\\n            else if(finalNodeVals.contains(node1.val) && first == false) { \\n                head.next = node1; head = head.next;\\n            }\\n            node1 = node1.next;\\n        }\\n        \\n        head.next = null;\\n        \\n        return finalHead;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode pre = new ListNode(0);\\n        pre.next = head;\\n        ListNode curr = head, ans = pre;\\n        \\n        while(curr != null){\\n            while(curr.next != null && curr.val == curr.next.val){\\n                curr = curr.next;\\n            }\\n            if(pre.next != curr){\\n                pre.next = curr.next;\\n            }\\n            else{\\n                pre.next = curr; pre = pre.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118235,
                "title": "cpp-easy-solution",
                "content": "```class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* dummyNode=new ListNode(-1); \\n    dummyNode->next=head;//add a extra node so that we can check that whether the repeated num starts from first node or not.\\n    ListNode* curr=dummyNode;\\n    \\n    while(curr->next != NULL and curr->next->next != NULL){\\n        if(curr->next->val != curr->next->next->val){\\n          curr=curr->next;\\n        }\\n        else{\\n            int value=curr->next->val;\\n            \\n            while(curr->next and curr->next->val == value){ //Checking repetitions of the duplicate node\\n                curr->next=curr->next->next;\\n            }\\n        }\\n    }\\n    return dummyNode->next;\\n    }\\n};\\n```\\nPlease upvote if you like this solution .",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* dummyNode=new ListNode(-1); \\n    dummyNode->next=head;//add a extra node so that we can check that whether the repeated num starts from first node or not.\\n    ListNode* curr=dummyNode;\\n    \\n    while(curr->next != NULL and curr->next->next != NULL){\\n        if(curr->next->val != curr->next->next->val){\\n          curr=curr->next;\\n        }\\n        else{\\n            int value=curr->next->val;\\n            \\n            while(curr->next and curr->next->val == value){ //Checking repetitions of the duplicate node\\n                curr->next=curr->next->next;\\n            }\\n        }\\n    }\\n    return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832692,
                "title": "c-easy-to-understand-iterative-simple",
                "content": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\\n\\n**EXPLANATION**\\n\\n\\n* **Traverse the list** from the **head** (or start) node.\\n* While traversing, **compare each node with its next node**.\\n* If the data of the next node is the **same** as the current node then **skip** the next node.(don\\'t add to answer)\\n* If node has **unique value add to answer**  \\n* Then we need **update** our pointers.\\n\\nTIME COMPLEXITY : O(N) , N is number of Nodes\\nSPACE COMPLEXITY : O(1)\\n\\n\\n\\n\\n\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n\\tif(!head || !head->next) return head; //base case\\n\\t\\n\\tListNode* prev,*start=head,*end=head;  // 3 pointers\\n\\tListNode* dummy=new ListNode();   // to handle corner case-> first element has duplicate\\n\\tprev=dummy;\\n\\t\\n\\twhile(end){\\n\\n\\t\\tif(end->next && end->val==end->next->val) {end=end->next; continue;} //skip duplicate\\n\\t\\t\\n\\t\\tif(!end->next && start!=end) {prev->next=NULL;break;} // to handle corner case-> last element has duplicate\\n\\t\\t\\n\\t\\tif(start==end) {prev->next=end, prev=prev->next;} //unique element add to answer\\n\\t\\t\\n\\t\\tstart=end->next, end=end->next; //update pointers\\n\\t}\\n\\t\\n\\treturn dummy->next; \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n\\tif(!head || !head->next) return head; //base case\\n\\t\\n\\tListNode* prev,*start=head,*end=head;  // 3 pointers\\n\\tListNode* dummy=new ListNode();   // to handle corner case-> first element has duplicate\\n\\tprev=dummy;\\n\\t\\n\\twhile(end){\\n\\n\\t\\tif(end->next && end->val==end->next->val) {end=end->next; continue;} //skip duplicate\\n\\t\\t\\n\\t\\tif(!end->next && start!=end) {prev->next=NULL;break;} // to handle corner case-> last element has duplicate\\n\\t\\t\\n\\t\\tif(start==end) {prev->next=end, prev=prev->next;} //unique element add to answer\\n\\t\\t\\n\\t\\tstart=end->next, end=end->next; //update pointers\\n\\t}\\n\\t\\n\\treturn dummy->next; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832500,
                "title": "c-95-faster",
                "content": "![image](https://assets.leetcode.com/users/images/002a7e8a-8850-455a-bfad-c32c2e7efd6f_1646794760.4226303.png)\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640463,
                "title": "c-easy-to-undersand-efficient-code-3-approaches",
                "content": "**Approach 1**\\n**Iterative method**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel=new ListNode(0);\\n        sentinel->next=head;\\n        ListNode* pred=sentinel;\\n        if(!head)\\n        return NULL;\\n        while(head)\\n        {\\n            if(head->next!=NULL&&head->val==head->next->val)\\n            {\\n            while(head->next!=NULL&&head->val==head->next->val)\\n            {\\n                head=head->next;\\n            }\\n                pred->next=head->next;\\n            }\\n            else\\n            {\\n                pred=pred->next;\\n            }\\n            head=head->next;\\n        }\\n        return sentinel->next;\\n    }\\n};\\n```\\n**Approach 2**\\n**Recurcive solution**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       if(!head)\\n       return NULL;\\n       if(!head->next)\\n       return head;\\n       int value=head->val;\\n        ListNode* curr=head->next;\\n        if(curr->val==value)\\n        {\\n            while(curr&&curr->val==value)\\n            {\\n                curr=curr->next;\\n            }\\n            return deleteDuplicates(curr);\\n        }\\n        else\\n        {\\n            head->next=deleteDuplicates(curr);\\n            return head;\\n        }\\n    }\\n};\\n```\\n**Approach 3**\\n**Creating new nodes**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head)\\n        return NULL;\\n        unordered_map<int,int> freq;\\n        while(head)\\n        {\\n            freq[head->val]++;\\n            head=head->next;\\n        }\\n        vector<int> v;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second==1)\\n            v.push_back(pr.first);\\n        }\\n        if(v.size()==0)\\n        return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* temp=new ListNode(v[0]);\\n        ListNode* p=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->next=new ListNode(v[i]);\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        return p;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel=new ListNode(0);\\n        sentinel->next=head;\\n        ListNode* pred=sentinel;\\n        if(!head)\\n        return NULL;\\n        while(head)\\n        {\\n            if(head->next!=NULL&&head->val==head->next->val)\\n            {\\n            while(head->next!=NULL&&head->val==head->next->val)\\n            {\\n                head=head->next;\\n            }\\n                pred->next=head->next;\\n            }\\n            else\\n            {\\n                pred=pred->next;\\n            }\\n            head=head->next;\\n        }\\n        return sentinel->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       if(!head)\\n       return NULL;\\n       if(!head->next)\\n       return head;\\n       int value=head->val;\\n        ListNode* curr=head->next;\\n        if(curr->val==value)\\n        {\\n            while(curr&&curr->val==value)\\n            {\\n                curr=curr->next;\\n            }\\n            return deleteDuplicates(curr);\\n        }\\n        else\\n        {\\n            head->next=deleteDuplicates(curr);\\n            return head;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head)\\n        return NULL;\\n        unordered_map<int,int> freq;\\n        while(head)\\n        {\\n            freq[head->val]++;\\n            head=head->next;\\n        }\\n        vector<int> v;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second==1)\\n            v.push_back(pr.first);\\n        }\\n        if(v.size()==0)\\n        return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* temp=new ListNode(v[0]);\\n        ListNode* p=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->next=new ListNode(v[i]);\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215315,
                "title": "simple-and-clear-explanation-of-recursive-solution",
                "content": "Problem Statement:[https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/](http://)\\n\\n### How to  write a Recursive function?\\n*We have to follow three steps to write a*  **recursive code** \\n1.  **Assumption:**\\n* \\t  Assumption is nothing but what do you want your function to do.\\n2. **Main Logic:**\\n*     Solving problem using sub problems\\n3. **Base Condition:**\\n*     When recursion should terminate \\n\\n**Before diving into the solution lets understand the question**:\\n\\tThey have given a Linked list, we have to remove all the occurences of an element whose frequency is more than one and return the new linkedlist.\\n\\t![image](https://assets.leetcode.com/users/images/3fae7b24-93ab-4cfd-b452-de689684fa2f_1621272982.2501419.png)\\n\\t\\nIn the given linkedlist frequencies of 3 and 4 is 2, which is greater than 1, so we have to delete all the occurence of 3 and 4 then we have to return head node of new linked list.\\n\\n### Defining our three steps in recursion\\n**Assumption:** Remove all the occurences of an element whose frequency is more than one and return the linkedlist.\\n\\n**Main Logic:** Here we have two cases for a node either to consider it or not in final linkedlist.\\n*    **Case-1:** If we land on a node whose frequency is 1, then we should \\n      consider it and this node should point to the **nextnode** in the linkedlist\\n      whose frequency is 1, if we don\\'t find any node then it should point to NULL.\\n*   **Case-2:** If we land on a node whose frequency is more than 1, then \\n\\t  we have to ignore all the nodes of same value till we get **nextnode** whose \\n\\t  frequency is 1, if we don\\'t find any node then it should point to NULL.\\n\\t  \\n**BaseCondition**: \\n*    If we are at **Last node** then there is no need to check its frequency (because we are at lastnode there will be no nodes after it, so it\\'s frequency is one.) so we can simply return that node.\\n*    If the head node is NULL then we have to return.\\n\\n### Recursive Solution:\\n```\\nListNode* recursiveDeletion(ListNode*head){\\n\\t\\t//Base Conditions:\\n\\t\\tif(head==NULL || head->next==NULL)\\n\\t\\t\\treturn head;\\n\\t\\t\\t\\n\\t\\tbool flag=false //To check the given node is repeating or not.\\n\\t\\tint headValue=head->val;\\n\\t\\t\\n\\t\\tListNode*temp=head->next; //temporary pointer for itearating till we get\\n\\t\\t\\t\\t\\t\\t\\t\\t //a node whose data is not equal to headValue.\\n\\t\\twhile(temp!=NULL && temp->next==headValue){\\n\\t\\t\\tflag=true;\\n\\t\\t\\ttemp=temp->next; //shift to next node \\n\\t\\t}\\n\\t\\t//Now temp pointer points to a node whose value is different from headValue.\\n\\t\\t\\n\\t\\t// MAIN LOGIC: Case-2 (frequency more than 1)\\n\\t\\tif(flag==true){\\n\\t\\t\\treturn recursiveDeletion(temp);\\n\\t\\t\\t// we are not appending temp node to the previous node of head \\n            //because we don\\'t know whether temp node is repeating or not \\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\t//Case-1 ( frequency is 1)\\n\\t\\t\\thead->next= recursiveDeletion(head->next);\\n\\t\\t\\t// we are considering head in our linkedlist\\n\\t\\t\\t\\n\\t\\t\\treturn head;\\n\\t\\t\\t//******why should we return head?***********\\n\\t\\t\\t// beacuse we have to link head node to the prev node as we called\\n\\t\\t\\t//prev->next=recursiveDeletion(prev->next)  prev->next == head \\n            //as head is not repeating we have to return pointer of head.\\n\\t\\t\\t\\n\\t\\t\\t//head points to the nextnode return by the function it can either be\\n\\t\\t\\t // NULL or a node\\n\\t\\t\\t\\n\\t\\t}\\t\\n}\\n```\\n\\nIf you have any doubts feel free to ask in comment section\\n\\nThis is my first article tell me your review on this and where can I improve.\\n\\n\\n\\n\\t\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* recursiveDeletion(ListNode*head){\\n\\t\\t//Base Conditions:\\n\\t\\tif(head==NULL || head->next==NULL)\\n\\t\\t\\treturn head;\\n\\t\\t\\t\\n\\t\\tbool flag=false //To check the given node is repeating or not.\\n\\t\\tint headValue=head->val;\\n\\t\\t\\n\\t\\tListNode*temp=head->next; //temporary pointer for itearating till we get\\n\\t\\t\\t\\t\\t\\t\\t\\t //a node whose data is not equal to headValue.\\n\\t\\twhile(temp!=NULL && temp->next==headValue){\\n\\t\\t\\tflag=true;\\n\\t\\t\\ttemp=temp->next; //shift to next node \\n\\t\\t}\\n\\t\\t//Now temp pointer points to a node whose value is different from headValue.\\n\\t\\t\\n\\t\\t// MAIN LOGIC: Case-2 (frequency more than 1)\\n\\t\\tif(flag==true){\\n\\t\\t\\treturn recursiveDeletion(temp);\\n\\t\\t\\t// we are not appending temp node to the previous node of head \\n            //because we don\\'t know whether temp node is repeating or not \\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\t//Case-1 ( frequency is 1)\\n\\t\\t\\thead->next= recursiveDeletion(head->next);\\n\\t\\t\\t// we are considering head in our linkedlist\\n\\t\\t\\t\\n\\t\\t\\treturn head;\\n\\t\\t\\t//******why should we return head?***********\\n\\t\\t\\t// beacuse we have to link head node to the prev node as we called\\n\\t\\t\\t//prev->next=recursiveDeletion(prev->next)  prev->next == head \\n            //as head is not repeating we have to return pointer of head.\\n\\t\\t\\t\\n\\t\\t\\t//head points to the nextnode return by the function it can either be\\n\\t\\t\\t // NULL or a node\\n\\t\\t\\t\\n\\t\\t}\\t\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175415,
                "title": "c-8ms-o-n-solution",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        ListNode*prev=new ListNode(-101);\\n        prev->next=head;\\n        ListNode*temp=head;\\n        ListNode*temp2=new ListNode(-102);\\n        ListNode*h=temp2;\\n        while(temp->next!=NULL){\\n            if(temp->val!=prev->val && temp->val!=temp->next->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }\\n                \\n                else{\\n                     ListNode*node=new ListNode(temp->val);\\n                   temp2->next=node;\\n                temp2=node;   \\n                }\\n              \\n            }\\n            temp=temp->next;\\n            prev=prev->next;\\n        }\\n           if(temp->val!=prev->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }\\n                \\n                else{\\n                     ListNode*node=new ListNode(temp->val);\\n                   temp2->next=node;\\n                temp2=node;   \\n                }\\n              \\n            }\\n        temp2->next=NULL;\\n        if(h->val==-102)\\n            return NULL;\\n        return h;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        ListNode*prev=new ListNode(-101);\\n        prev->next=head;\\n        ListNode*temp=head;\\n        ListNode*temp2=new ListNode(-102);\\n        ListNode*h=temp2;\\n        while(temp->next!=NULL){\\n            if(temp->val!=prev->val && temp->val!=temp->next->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 805304,
                "title": "both-recursive-and-iterative-c",
                "content": "\\n         //iterative\\n\\t\\t \\n        class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==NULL ||head->next==NULL)\\n                    return head;\\n                ListNode *tail= new ListNode(-1);\\n                ListNode* newhead=tail;\\n                while(head!=NULL){\\n                    if(head->next!=NULL && head->val==head->next->val){\\n                        int curr=head->val;\\n                        head=head->next;\\n                        while(head && head->val==curr)\\n                            head=head->next;\\n                    }else{\\n                        tail->next=head;\\n                        tail=tail->next;\\n                        head=head->next;\\n                    }\\n                }\\n                tail->next=NULL;\\n                return newhead->next;\\n            }\\n        };\\n\\t\\t\\n\\t\\t//recursive\\n\\t\\t\\n\\t\\tclass Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==nullptr) return head;\\n                ListNode* p1=head->next;\\n                if(p1 && p1->val==head->val){\\n                 while(p1 && p1->val==head->val) {\\n                     p1=p1->next;\\n                 }\\n                    return deleteDuplicates(p1);\\n                }\\n                else \\n                head->next = deleteDuplicates(head->next);\\n                return head;\\n            } \\n        };\\n\\t\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==NULL ||head->next==NULL)\\n                    return head;\\n                ListNode *tail= new ListNode(-1);\\n                ListNode* newhead=tail;\\n                while(head!=NULL){\\n                    if(head->next!=NULL && head->val==head->next->val){\\n                        int curr=head->val;\\n                        head=head->next;\\n                        while(head && head->val==curr)\\n                            head=head->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 509070,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return \\n        ret = pre = ListNode(0)\\n        ret.next = cur = head\\n        while(cur.next):\\n            nxt = cur.next\\n            if cur.val == nxt.val:\\n                while(nxt.next and nxt.val == nxt.next.val):\\n                    nxt = nxt.next\\n                pre.next = cur = nxt.next\\n                if not cur: return ret.next\\n            else:\\n                pre,cur,nxt = cur,nxt,nxt.next\\n            \\n            \\n        return ret.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return \\n        ret = pre = ListNode(0)\\n        ret.next = cur = head\\n        while(cur.next):\\n            nxt = cur.next\\n            if cur.val == nxt.val:\\n                while(nxt.next and nxt.val == nxt.next.val):\\n                    nxt = nxt.next\\n                pre.next = cur = nxt.next\\n                if not cur: return ret.next\\n            else:\\n                pre,cur,nxt = cur,nxt,nxt.next\\n            \\n            \\n        return ret.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234766,
                "title": "python-recursive-iterative-easy-to-understand-both-beat-100",
                "content": "recursive:\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        if not head or not head.next: return head\\n        nxt = head.next\\n        if nxt.val != head.val:\\n            head.next = self.deleteDuplicates(nxt)\\n            return head\\n        else:\\n            while nxt and nxt.val == head.val:\\n                nxt = nxt.next\\n            return self.deleteDuplicates(nxt)\\n```\\niterative:\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        dum = ListNode(0)\\n        dum.next, pre, cur = head, dum, head\\n        while cur:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur: \\n                pre = cur\\n            else: \\n                pre.next = cur.next\\n            cur = cur.next\\n        return dum.next\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        if not head or not head.next: return head\\n        nxt = head.next\\n        if nxt.val != head.val:\\n            head.next = self.deleteDuplicates(nxt)\\n            return head\\n        else:\\n            while nxt and nxt.val == head.val:\\n                nxt = nxt.next\\n            return self.deleteDuplicates(nxt)\\n```\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        dum = ListNode(0)\\n        dum.next, pre, cur = head, dum, head\\n        while cur:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur: \\n                pre = cur\\n            else: \\n                pre.next = cur.next\\n            cur = cur.next\\n        return dum.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28333,
                "title": "accpted-javascript-solution",
                "content": "``` \\nconst deleteDuplicates = function(head) {\\n    if(head === null || head.next === null) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    head = dummy;\\n    \\n    while(head.next !== null && head.next.next !== null) {\\n        if(head.next.val === head.next.next.val) {\\n            let val = head.next.val;\\n            while( head.next !== null && head.next.val === val ){\\n                head.next = head.next.next;\\n            }\\n        } else {\\n            head = head.next;\\n        }\\n\\t}\\n\\treturn dummy.next\\n}\\n```",
                "solutionTags": [],
                "code": "``` \\nconst deleteDuplicates = function(head) {\\n    if(head === null || head.next === null) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    head = dummy;\\n    \\n    while(head.next !== null && head.next.next !== null) {\\n        if(head.next.val === head.next.next.val) {\\n            let val = head.next.val;\\n            while( head.next !== null && head.next.val === val ){\\n                head.next = head.next.next;\\n            }\\n        } else {\\n            head = head.next;\\n        }\\n\\t}\\n\\treturn dummy.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28594,
                "title": "11-lines-c-solution-with-comments",
                "content": "    \\tListNode *deleteDuplicates(ListNode *head) {\\n        if(!head||!head->next)return head;\\n        ListNode *newhead=0,**phead=&newhead;//phead pointer to new head pointer\\n        while(head)\\n        {\\n            if(head->next&&head->val==head->next->val)\\n\\t\\t\\t{//skip all nodes has duplicate value\\n\\t\\t\\t\\tint dupval=head->val;\\n\\t\\t\\t\\twhile(head&&head->val==dupval)head=head->next;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}//assign and advance phead\\n\\t\\t\\telse {*phead=head; phead=&((*phead)->next);}\\n\\t\\t\\thead=head->next;\\n        }\\n        *phead=0;// point the next of last node to NULL\\n        return newhead;\\n    }",
                "solutionTags": [],
                "code": "    \\tListNode *deleteDuplicates(ListNode *head) {\\n        if(!head||!head->next)return head;\\n        ListNode *newhead=0,**phead=&newhead;//phead pointer to new head pointer\\n        while(head)\\n        {\\n            if(head->next&&head->val==head->next->val)\\n\\t\\t\\t{//skip all nodes has duplicate value\\n\\t\\t\\t\\tint dupval=head->val;\\n\\t\\t\\t\\twhile(head&&head->val==dupval)head=head->next;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}//assign and advance phead\\n\\t\\t\\telse {*phead=head; phead=&((*phead)->next);}\\n\\t\\t\\thead=head->next;\\n        }\\n        *phead=0;// point the next of last node to NULL\\n        return newhead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3835448,
                "title": "easy-c-solution",
                "content": "\\n# Approach\\nCreate a dummy node:\\n\\nWe start by creating a dummy node that acts as the \"head\" of the updated linked list. The dummy node will have a value of 0 and point to the original head of the linked list.\\nInitialize pointers:\\n\\nWe initialize two pointers, head and prev, both pointing to the dummy node initially.\\nThe head pointer is used to traverse the original linked list, and the prev pointer is used to keep track of the last non-duplicate node in the updated linked list.\\nTraverse the linked list:\\n\\nWe use a while loop to iterate through the linked list until the head pointer reaches the end (NULL).\\nInside the loop, we check if the current node\\'s value is equal to the value of its next node (indicating a duplicate).\\nRemove duplicates:\\n\\nIf a duplicate is found (i.e., head->val == head->next->val), we enter another nested while loop to skip all the consecutive nodes with the same value. This ensures that we find the last node with the same value.\\nUpdate pointers:\\n\\nAfter the nested loop, head will be pointing to the last duplicate node.\\nWe then update the prev->next pointer to skip all the duplicate nodes and point to the node after the last duplicate node.\\nIf no duplicates were found, we simply move the prev pointer to the next node.\\nMove head pointer:\\n\\nIn either case (duplicate found or not), we move the head pointer to the next node.\\nReturn the updated linked list:\\n\\nAfter the loop ends, the original linked list is modified such that all duplicates are removed, and the prev pointer points to the last non-duplicate node.\\nWe return dummy->next, which is the head of the updated linked list.\\nThis approach effectively removes all duplicate elements from the linked list while maintaining the order of the non-duplicate elements.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {\\n            if(head->next!=NULL && head->val==head->next->val)\\n            {\\n                while(head->next!=NULL && head->val==head->next->val)\\n                {\\n                    head=head->next;\\n                }\\n            prev->next=head->next;\\n            }\\n            else\\n            {\\n                prev=prev->next;\\n            }\\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {\\n            if(head->next!=NULL && head->val==head->next->val)\\n            {\\n                while(head->next!=NULL && head->val==head->next->val)\\n                {\\n                    head=head->next;\\n                }\\n            prev->next=head->next;\\n            }\\n            else\\n            {\\n                prev=prev->next;\\n            }\\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404383,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate through the list while counting the frequency of every element. If the frequency of the element is one then we add the element to the list.\\n\\nTo do this take a previous pointer and point it to NULL. Take a temporary pointer to iterate though the list. Count the frequency of every element. If the frequency is one, point the prevoius Node to the current Node and initialize the privious node to the current Node. But if the previous node is NULL, then initialize head pointer to the current Node and previous Node to also the current node. When temp reaches to NULL and previous node is not NULL then point the Previous Node to NULL.\\n\\nBut if the prevoius node is still is NULL it means the list has no value of single frequency. In this case return NULL.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ Cause the list is iterated only once. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity $$O(1)$$ We only use constant size variables\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        ListNode* temp = head;//Temporary pointer\\n        ListNode* pre = NULL;//Initializing previous pointer to NULL\\n        \\n        /* Looping through the list untill the tempurary pointer\\n        reaches NULL */  \\n        while(temp != NULL){\\n\\n            int k = 1;\\n            ListNode* curr = temp; //Initialize current pointer to temp\\n            \\n            //Counting the frequency of the current element\\n            while((temp != NULL) && (temp->val == curr->val)){\\n                temp = temp->next;\\n                k++;\\n            }\\n            k--;\\n\\n            //If frequency of the element is 1 put it in the the list\\n            if(k == 1){\\n\\n                // If the previous pointer is null then initialize\\n                // the head pointer  and the previous pointer \\n                // to the current pointer\\n  \\n                if(pre == NULL){\\n                    head = curr;\\n                    pre = curr;\\n                }\\n\\n                //if not then previous to current and next value of\\n                // privious pointer to current pointer\\n                else{\\n                    pre->next = curr;\\n                    pre = curr;\\n                }\\n            }\\n            // when temporary pointer reaches to NULL\\n            // and prevoius pointer is not null then initialie\\n            // next value of prevoius pointer to NULL or temp\\n\\n            if(temp == NULL && pre != NULL){\\n                pre->next = temp;\\n            }\\n        } \\n\\n        // If prevoius pointer is still is NULL, it means that \\n        // no value is eligible for the ans list\\n        // so initialize head to NULL and return head\\n\\n        if(pre == NULL){\\n            head = NULL;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        ListNode* temp = head;//Temporary pointer\\n        ListNode* pre = NULL;//Initializing previous pointer to NULL\\n        \\n        /* Looping through the list untill the tempurary pointer\\n        reaches NULL */  \\n        while(temp != NULL){\\n\\n            int k = 1;\\n            ListNode* curr = temp; //Initialize current pointer to temp\\n            \\n            //Counting the frequency of the current element\\n            while((temp != NULL) && (temp->val == curr->val)){\\n                temp = temp->next;\\n                k++;\\n            }\\n            k--;\\n\\n            //If frequency of the element is 1 put it in the the list\\n            if(k == 1){\\n\\n                // If the previous pointer is null then initialize\\n                // the head pointer  and the previous pointer \\n                // to the current pointer\\n  \\n                if(pre == NULL){\\n                    head = curr;\\n                    pre = curr;\\n                }\\n\\n                //if not then previous to current and next value of\\n                // privious pointer to current pointer\\n                else{\\n                    pre->next = curr;\\n                    pre = curr;\\n                }\\n            }\\n            // when temporary pointer reaches to NULL\\n            // and prevoius pointer is not null then initialie\\n            // next value of prevoius pointer to NULL or temp\\n\\n            if(temp == NULL && pre != NULL){\\n                pre->next = temp;\\n            }\\n        } \\n\\n        // If prevoius pointer is still is NULL, it means that \\n        // no value is eligible for the ans list\\n        // so initialize head to NULL and return head\\n\\n        if(pre == NULL){\\n            head = NULL;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383200,
                "title": "java-simple-straightforward-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Create a new LikedList that will contain our final answer in .next\\n        ListNode newList = new ListNode();\\n        // Create a copy of the head of the new LinkedList\\n        ListNode newListHead = newList;\\n\\n        // Iterate over the list\\n        while(head != null){\\n            // Keep track of whether or not we moved over a chunk of duplicated\\n            boolean wentOverAChunk = false;\\n            // This while loop jumps over the chunk of duplicated\\n            while(head.next != null && head.next.val == head.val){\\n                head = head.next;\\n                wentOverAChunk = true; // Set to true if we encountered duplicates\\n            }\\n            // If we haven\\'t encountered duplicates, add a copy of the node to the newList\\n            if(!wentOverAChunk){\\n                newList.next = new ListNode(head.val);\\n                newList = newList.next;\\n            }\\n            head = head.next;\\n        }\\n        return newListHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Create a new LikedList that will contain our final answer in .next\\n        ListNode newList = new ListNode();\\n        // Create a copy of the head of the new LinkedList\\n        ListNode newListHead = newList;\\n\\n        // Iterate over the list\\n        while(head != null){\\n            // Keep track of whether or not we moved over a chunk of duplicated\\n            boolean wentOverAChunk = false;\\n            // This while loop jumps over the chunk of duplicated\\n            while(head.next != null && head.next.val == head.val){\\n                head = head.next;\\n                wentOverAChunk = true; // Set to true if we encountered duplicates\\n            }\\n            // If we haven\\'t encountered duplicates, add a copy of the node to the newList\\n            if(!wentOverAChunk){\\n                newList.next = new ListNode(head.val);\\n                newList = newList.next;\\n            }\\n            head = head.next;\\n        }\\n        return newListHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235911,
                "title": "python-93-83-faster-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        d={}\\n        temp=head\\n        while temp!=None:\\n            if temp.val in d:\\n                d[temp.val]+=1\\n            else:\\n                d[temp.val]=1\\n            temp=temp.next\\n        temp=head\\n        L=ListNode()\\n        temp2=L\\n        while temp!=None:\\n            if temp.next==None and d[temp.val]>1:\\n                temp2.next=None\\n            if d[temp.val]>1:\\n                temp=temp.next\\n            else:\\n                temp2.next=temp\\n                temp2=temp2.next\\n                temp=temp.next\\n        return L.next\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        d={}\\n        temp=head\\n        while temp!=None:\\n            if temp.val in d:\\n                d[temp.val]+=1\\n            else:\\n                d[temp.val]=1\\n            temp=temp.next\\n        temp=head\\n        L=ListNode()\\n        temp2=L\\n        while temp!=None:\\n            if temp.next==None and d[temp.val]>1:\\n                temp2.next=None\\n            if d[temp.val]>1:\\n                temp=temp.next\\n            else:\\n                temp2.next=temp\\n                temp2=temp2.next\\n                temp=temp.next\\n        return L.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368612,
                "title": "c-recusrive-solution-easy-understanding",
                "content": "```\\n if(!head || !head->next)\\n        return head;\\n        \\n        Node*next=head->next;\\n        if(head->data==next->data)\\n        {\\n            while(next && next->data==head->data)\\n                next=next->next;\\n            return removeAllDuplicates(next);\\n        }\\n        else\\n        {\\n            head->next=removeAllDuplicates(next);\\n            return head;\\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n if(!head || !head->next)\\n        return head;\\n        \\n        Node*next=head->next;\\n        if(head->data==next->data)\\n        {\\n            while(next && next->data==head->data)\\n                next=next->next;\\n            return removeAllDuplicates(next);\\n        }\\n        else\\n        {\\n            head->next=removeAllDuplicates(next);\\n            return head;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2242508,
                "title": "golang-solution-sentinel-node",
                "content": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // sentinel\\n    sentinel := &ListNode{Next: head}\\n    \\n    // predecessor = the last node\\n    // before the sublist of duplicates\\n    pred := sentinel\\n    \\n    for head != nil {\\n        if head.Next != nil && head.Val == head.Next.Val {\\n            for head.Next != nil && head.Val == head.Next.Val {\\n                head = head.Next\\n            }\\n            \\n            pred.Next = head.Next\\n        } else {\\n            pred = pred.Next\\n        }\\n        \\n        // move forward\\n        head = head.Next\\n    }\\n    \\n    return sentinel.Next\\n}\\n``",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // sentinel\\n    sentinel := &ListNode{Next: head}\\n    \\n    // predecessor = the last node\\n    // before the sublist of duplicates\\n    pred := sentinel\\n    \\n    for head != nil {\\n        if head.Next != nil && head.Val == head.Next.Val {\\n            for head.Next != nil && head.Val == head.Next.Val {\\n                head = head.Next\\n            }\\n            \\n            pred.Next = head.Next\\n        } else {\\n            pred = pred.Next\\n        }\\n        \\n        // move forward\\n        head = head.Next\\n    }\\n    \\n    return sentinel.Next\\n}\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1833627,
                "title": "python-go-dummy-node-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/Go] \\uD83C\\uDF1F Dummy Node Solution and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 Main Idea:\\nIt is very important to set a dummy node **points to head**, in this question the head of linked lists will be change if original head is duplicate\\n\\nFor Example 2\\n\\n\\thead = [1,1,1,2,3], Output: [2,3]\\n\\nYou can see that we change head to 2, so it\\'s important to set a dummy node before head and then we return dummy.next\\n\\nAnother requirement for this question is that we have to remove duplicate nodes.\\n\\n**Algorithm**\\n\\n0. We set a prev node, before we traverse into list\\n1. We set subHead = prev.next, and sent it to traverse the list.\\nOnce we find that **subHead.val != subHead.next.val** means subHead is not duplicate, we can move prev.next = subHead, and move prev forwar\\n2. If we find that subHead is **duplicate**, and then move subHead = subHead.next until **subHead.val != subHead.next.val** (Could be None or new value)\\nAnd then we make **prev.next = subHead.next**\\nNote that we not move prev forward at this stage, only remove duplicate. We only move prev forward to non duplicate nodes which will be excute at step2\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of linked list\\n* Space: O(1)\\n## Floyd\\'s Cycle Detection Code\\n**Python**\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        # Create a dummy node\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        \\n        while prev.next and prev.next.next:\\n            # Init subHead\\n            subHead = prev.next\\n            # If not duplicate move prev forward\\n            if subHead.val != subHead.next.val:\\n                prev.next = subHead\\n                prev = prev.next\\n                continue\\n            # If duplicate remove them and point prev.next to next integer\\n            # Note that we not move prev forward at this stage, only remove duplicate\\n            while subHead.next and subHead.val == subHead.next.val:\\n                subHead = subHead.next\\n            prev.next = subHead.next\\n        # return head\\n        return dummy.next\\n```\\n**Go**\\n```go\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // Create a dummy node\\n    dummy := ListNode{0, head}\\n    prev := &dummy\\n    \\n    for prev.Next != nil && prev.Next.Next != nil{\\n        // Init subHead\\n        subHead := prev.Next\\n        // If not duplicate move prev forward\\n        if subHead.Val != subHead.Next.Val{\\n            prev.Next = subHead\\n            prev = prev.Next\\n            continue\\n        }\\n        // If duplicate remove them and point prev.next to next integer\\n        // Note that we not move prev forward at this stage, only remove duplicate\\n        for subHead.Next != nil && subHead.Val == subHead.Next.Val{\\n            subHead = subHead.Next\\n        }\\n        prev.Next = subHead.Next\\n        \\n    }\\n\\n    return dummy.Next\\n}\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        # Create a dummy node\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        \\n        while prev.next and prev.next.next:\\n            # Init subHead\\n            subHead = prev.next\\n            # If not duplicate move prev forward\\n            if subHead.val != subHead.next.val:\\n                prev.next = subHead\\n                prev = prev.next\\n                continue\\n            # If duplicate remove them and point prev.next to next integer\\n            # Note that we not move prev forward at this stage, only remove duplicate\\n            while subHead.next and subHead.val == subHead.next.val:\\n                subHead = subHead.next\\n            prev.next = subHead.next\\n        # return head\\n        return dummy.next\\n```\n```go\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // Create a dummy node\\n    dummy := ListNode{0, head}\\n    prev := &dummy\\n    \\n    for prev.Next != nil && prev.Next.Next != nil{\\n        // Init subHead\\n        subHead := prev.Next\\n        // If not duplicate move prev forward\\n        if subHead.Val != subHead.Next.Val{\\n            prev.Next = subHead\\n            prev = prev.Next\\n            continue\\n        }\\n        // If duplicate remove them and point prev.next to next integer\\n        // Note that we not move prev forward at this stage, only remove duplicate\\n        for subHead.Next != nil && subHead.Val == subHead.Next.Val{\\n            subHead = subHead.Next\\n        }\\n        prev.Next = subHead.Next\\n        \\n    }\\n\\n    return dummy.Next\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833360,
                "title": "c-2-methods-100-faster-easy-to-understand",
                "content": "**Method 1 :**  Brute Force [ TC : O(N)  & SC : O(N) ]\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        unordered_map<int,int>m;\\n        ListNode* h = new ListNode(0);\\n        \\n        ListNode* curr = head;\\n        while(curr)\\n        {\\n            m[curr->val]++;\\n            curr = curr->next;\\n        }\\n        \\n        curr = h;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            if(m[temp->val] == 1)\\n            {\\n                curr->next = temp;\\n                curr = curr->next;\\n            }\\n            \\n        temp = temp->next;\\n        }\\n        curr->next = NULL;\\n\\n        return h->next;\\n        \\n       \\n    }\\n};\\n```\\n\\n\\n**Method 2:** Optimize Solution [ TC : O(N)  & SC : O(1) ]\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* h = new ListNode(0);\\n        ListNode* prev = h;\\n        ListNode* curr = head;\\n     \\n        \\n        while(curr)\\n        {\\n            if(curr->next && curr->val == curr->next->val)\\n            {\\n                while(curr->next && curr->val == curr->next->val)\\n                    curr = curr->next;\\n            }\\n            else\\n            {\\n                   prev->next = curr;\\n                    prev = curr;   \\n            }\\n            \\n            curr = curr->next;\\n        }\\n        prev->next = NULL;\\n        return h->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        unordered_map<int,int>m;\\n        ListNode* h = new ListNode(0);\\n        \\n        ListNode* curr = head;\\n        while(curr)\\n        {\\n            m[curr->val]++;\\n            curr = curr->next;\\n        }\\n        \\n        curr = h;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            if(m[temp->val] == 1)\\n            {\\n                curr->next = temp;\\n                curr = curr->next;\\n            }\\n            \\n        temp = temp->next;\\n        }\\n        curr->next = NULL;\\n\\n        return h->next;\\n        \\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* h = new ListNode(0);\\n        ListNode* prev = h;\\n        ListNode* curr = head;\\n     \\n        \\n        while(curr)\\n        {\\n            if(curr->next && curr->val == curr->next->val)\\n            {\\n                while(curr->next && curr->val == curr->next->val)\\n                    curr = curr->next;\\n            }\\n            else\\n            {\\n                   prev->next = curr;\\n                    prev = curr;   \\n            }\\n            \\n            curr = curr->next;\\n        }\\n        prev->next = NULL;\\n        return h->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832967,
                "title": "tc-o-n-sc-o-1-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode* temp=head;\\n        ListNode* prev=dummy;\\n        \\n        while(temp!=NULL){\\n            if(temp->next!=NULL && temp->val == temp->next->val){\\n                while(temp->next!=NULL && temp->val == temp->next->val)\\n                    temp=temp->next;\\n                prev->next=temp->next;\\n            }\\n            else if(prev->next!=NULL)\\n                prev=prev->next;\\n            temp=temp->next;      \\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode* temp=head;\\n        ListNode* prev=dummy;\\n        \\n        while(temp!=NULL){\\n            if(temp->next!=NULL && temp->val == temp->next->val){\\n                while(temp->next!=NULL && temp->val == temp->next->val)\\n                    temp=temp->next;\\n                prev->next=temp->next;\\n            }\\n            else if(prev->next!=NULL)\\n                prev=prev->next;\\n            temp=temp->next;      \\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783662,
                "title": "java-solution-with-dry-run",
                "content": "```\\n\\nprev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nhead will keep track of removing the duplicates elements of Sorted LL\\nso when head.next != null and head.next.val == head.val \\nmove the head pointer to it\\'s next until head.next.val != head.val\\n \\nWhen head.next.val not equal to head.val then just mov prev and head pointer by one step\\n\\n\\n         prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\n              prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nNow head.next.val == head.val so move head pointer till head.next.val != head.val\\n\\n\\n              prev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n              prev      head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\n2. head = head.next\\n              prev          head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\nnow head.val == head.next.val so move head pointer till head.next.val != head.val\\n\\n              prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n             prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\n2. head = head.next\\n\\n             prev                    head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\nResultant LL  : \\n\\n     0 -> 1->2->5\\n    dummy    \\n    \\n    RETURN dummy.next\\n\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n \\n ```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && head.val == head.next.val)\\n            {\\n                while(head.next != null && head.val == head.next.val)\\n                {\\n                    head = head.next;\\n                }\\n                \\n                prev.next = head.next;\\n                head = head.next;\\n            }\\n            else\\n            {\\n                prev= prev.next;\\n                head = head.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nprev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nhead will keep track of removing the duplicates elements of Sorted LL\\nso when head.next != null and head.next.val == head.val \\nmove the head pointer to it\\'s next until head.next.val != head.val\\n \\nWhen head.next.val not equal to head.val then just mov prev and head pointer by one step\\n\\n\\n         prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\n              prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nNow head.next.val == head.val so move head pointer till head.next.val != head.val\\n\\n\\n              prev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n              prev      head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\n2. head = head.next\\n              prev          head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\nnow head.val == head.next.val so move head pointer till head.next.val != head.val\\n\\n              prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n             prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\n2. head = head.next\\n\\n             prev                    head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\nResultant LL  : \\n\\n     0 -> 1->2->5\\n    dummy    \\n    \\n    RETURN dummy.next\\n\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1703186,
                "title": "c-easy-to-understand-faster-than-95-percent",
                "content": "```\\n ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407383,
                "title": "ultra-simple-cpp-solution-suggestions-for-optimization-are-welcomed",
                "content": "Runtime: 8 ms, faster than 60.39% of C++ online submissions for Remove Duplicates from Sorted List II.\\nMemory Usage: 11.1 MB, less than 90.02% of C++ online submissions for Remove Duplicates from Sorted List II.\\n\\nT(n) = O(n)\\nS(n) = O(1)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* curr   = head;\\n        ListNode* prev   = nullptr;\\n        ListNode* ahead  = head;\\n        \\n        \\n        while(curr){\\n            \\n            if(curr->next && curr->val==curr->next->val){\\n                \\n                while(curr->next && curr->val==curr->next->val)\\n                    curr = curr->next;    \\n                \\n                if(prev==nullptr){\\n                    head = curr->next;\\n                    prev==nullptr;\\n                }\\n                else\\n                    prev->next = curr->next;    \\n                \\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* curr   = head;\\n        ListNode* prev   = nullptr;\\n        ListNode* ahead  = head;\\n        \\n        \\n        while(curr){\\n            \\n            if(curr->next && curr->val==curr->next->val){\\n                \\n                while(curr->next && curr->val==curr->next->val)\\n                    curr = curr->next;    \\n                \\n                if(prev==nullptr){\\n                    head = curr->next;\\n                    prev==nullptr;\\n                }\\n                else\\n                    prev->next = curr->next;    \\n                \\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235937,
                "title": "c-recursion-easy",
                "content": "As the solution is recursive, let\\'s see the base cases.\\n1. If the ```head``` is ```NULL``` return ```head```, coz nothing to do further.\\n2. Else check for the duplicates of ```head``` with the help of temp pointer and update the ```head```\\n3. If the present ```temp``` or ```head``` is not ```NULL``` then call the deleteDuplicates on ```temp->next```.\\n4. Return ```head```.\\n\\nHope this helps!\\n```\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head) return head;\\n        ListNode* temp = head;\\n        while(head and head->next and head->val == head->next->val){\\n            while(temp and head->val == temp->val)\\n                temp = temp->next;\\n            head = temp;\\n        }\\n        if(temp)\\n        temp->next = deleteDuplicates(temp->next);\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```head```\n```NULL```\n```head```\n```head```\n```head```\n```temp```\n```head```\n```NULL```\n```temp->next```\n```head```\n```\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head) return head;\\n        ListNode* temp = head;\\n        while(head and head->next and head->val == head->next->val){\\n            while(temp and head->val == temp->val)\\n                temp = temp->next;\\n            head = temp;\\n        }\\n        if(temp)\\n        temp->next = deleteDuplicates(temp->next);\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232028,
                "title": "different-way-to-write-the-solution-python-code-not-using-two-while-loops",
                "content": "I tried alternate approach compared to solution.\\n\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        s = ListNode(0, head)\\n        p = s\\n        d = None\\n        while s and s.next and s.next.next:\\n            if s.next.val == s.next.next.val:\\n                d = s.next.val\\n                s.next = s.next.next.next\\n            elif d is not None and d == s.next.val:\\n                s.next = s.next.next\\n            else:\\n                s = s.next\\n        if s.next and s.next.val == d:\\n            s.next = s.next.next\\n        return p.next\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        s = ListNode(0, head)\\n        p = s\\n        d = None\\n        while s and s.next and s.next.next:\\n            if s.next.val == s.next.next.val:\\n                d = s.next.val\\n                s.next = s.next.next.next\\n            elif d is not None and d == s.next.val:\\n                s.next = s.next.next\\n            else:\\n                s = s.next\\n        if s.next and s.next.val == d:\\n            s.next = s.next.next\\n        return p.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003306,
                "title": "remove-duplicates-from-sorted-list-ii-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //recursion exit condition\\n        if (!head||!head->next) return head;\\n        \\n        ListNode* node = head->next;\\n        \\n        //case: node val is not a duplicate of head val\\n        if (node->val != head->val) {\\n            //repeat process with next two nodes\\n            head->next = deleteDuplicates(node);\\n            return head;\\n        } \\n        //case: node val is a duplicate of head val\\n        else {\\n            //remove all nodes until no duplicate value as head, or end of list\\n            while (node && node->val == head->val) node = node->next;\\n            //return node here because head is part of the duplicate\\n            return deleteDuplicates(node);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //recursion exit condition\\n        if (!head||!head->next) return head;\\n        \\n        ListNode* node = head->next;\\n        \\n        //case: node val is not a duplicate of head val\\n        if (node->val != head->val) {\\n            //repeat process with next two nodes\\n            head->next = deleteDuplicates(node);\\n            return head;\\n        } \\n        //case: node val is a duplicate of head val\\n        else {\\n            //remove all nodes until no duplicate value as head, or end of list\\n            while (node && node->val == head->val) node = node->next;\\n            //return node here because head is part of the duplicate\\n            return deleteDuplicates(node);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715415,
                "title": "java-recursion-o-n",
                "content": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif( head != null && head.next != null) {            \\n\\t\\tif(head.next.val != head.val) {\\n\\t\\t\\thead.next = deleteDuplicates(head.next);\\n\\t\\t} else {\\n\\t\\t\\twhile(head.next != null && head.val == head.next.val)\\n\\t\\t\\t\\thead = head.next;\\n\\t\\t\\treturn deleteDuplicates(head.next);\\n\\t\\t}\\n\\t}\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif( head != null && head.next != null) {            \\n\\t\\tif(head.next.val != head.val) {\\n\\t\\t\\thead.next = deleteDuplicates(head.next);\\n\\t\\t} else {\\n\\t\\t\\twhile(head.next != null && head.val == head.next.val)\\n\\t\\t\\t\\thead = head.next;\\n\\t\\t\\treturn deleteDuplicates(head.next);\\n\\t\\t}\\n\\t}\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362394,
                "title": "java-recursive-and-iterative-approaches",
                "content": "Recursive approach:\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        // When the current heads are followed with a bunch of duplicates;\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\\n\\nIterative approach:\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        ListNode cur = dummyHead;\\n        while (cur.next != null && cur.next.next != null) {\\n            // pass when no duplicate\\n            if (cur.next.val != cur.next.next.val) {\\n                cur = cur.next;\\n                continue;\\n            }\\n            ListNode prev = cur;\\n            cur = cur.next;\\n            while (cur.next != null && cur.val == cur.next.val) {\\n                cur = cur.next;\\n            }\\n            prev.next = cur.next;\\n            cur = prev;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        // When the current heads are followed with a bunch of duplicates;\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        ListNode cur = dummyHead;\\n        while (cur.next != null && cur.next.next != null) {\\n            // pass when no duplicate\\n            if (cur.next.val != cur.next.next.val) {\\n                cur = cur.next;\\n                continue;\\n            }\\n            ListNode prev = cur;\\n            cur = cur.next;\\n            while (cur.next != null && cur.val == cur.next.val) {\\n                cur = cur.next;\\n            }\\n            prev.next = cur.next;\\n            cur = prev;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249643,
                "title": "swift-solution",
                "content": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var temp = ListNode(0)\\n        var slow: ListNode? = temp, fast = head\\n        while slow != nil {\\n            if fast != nil && fast!.val == fast!.next?.val {\\n                while fast!.val == fast!.next?.val {\\n                    fast = fast!.next\\n                }\\n                fast = fast?.next\\n            \\n            } else {\\n                slow!.next = fast\\n                slow = slow?.next\\n                fast = fast?.next\\n            }\\n        }\\n        return temp.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var temp = ListNode(0)\\n        var slow: ListNode? = temp, fast = head\\n        while slow != nil {\\n            if fast != nil && fast!.val == fast!.next?.val {\\n                while fast!.val == fast!.next?.val {\\n                    fast = fast!.next\\n                }\\n                fast = fast?.next\\n            \\n            } else {\\n                slow!.next = fast\\n                slow = slow?.next\\n                fast = fast?.next\\n            }\\n        }\\n        return temp.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225398,
                "title": "python-simple-recursive-100-with-explanation",
                "content": "Look at the first node, it is either duplicate or unique.\\n**(1)** duplicate: it is like A-A-......-B, then B is the head we return\\n**(2)** unique: it is like A-B-......, then A is the head we return\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Edge/Base case\\n        if not head or not head.next:\\n            return head\\n        # case (1)\\n        if head.val == head.next.val:\\n            while head.next and head.val == head.next.val:\\n                head = head.next\\n            return self.deleteDuplicates(head.next)    \\n        # case (2)\\n        else:\\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Edge/Base case\\n        if not head or not head.next:\\n            return head\\n        # case (1)\\n        if head.val == head.next.val:\\n            while head.next and head.val == head.next.val:\\n                head = head.next\\n            return self.deleteDuplicates(head.next)    \\n        # case (2)\\n        else:\\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164789,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        curr = head\\n        prev = ListNode(0)\\n        prev.next = curr\\n        rec = prev\\n        while curr:\\n            dupl = False \\n            while curr.next and curr.val == curr.next.val:\\n                dupl = True\\n                curr = curr.next\\n            if dupl:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        return rec.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        curr = head\\n        prev = ListNode(0)\\n        prev.next = curr\\n        rec = prev\\n        while curr:\\n            dupl = False \\n            while curr.next and curr.val == curr.next.val:\\n                dupl = True\\n                curr = curr.next\\n            if dupl:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        return rec.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28522,
                "title": "super-simple-and-easy-to-understand-cpp-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *p = &dummy;\\n            ListNode *p1 = head;\\n            ListNode *p2 = head;\\n            while (p1) {\\n                while (p2->next && p1->val==p2->next->val) {\\n                    p2 = p2->next;\\n                }\\n\\n                if (p1==p2) {\\n                    p = p1;\\n                } else {\\n                    p->next = p2->next;\\n                }\\n\\n                p1 = p2 = p->next;\\n            }\\n\\n            return dummy.next;\\n\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *p = &dummy;\\n            ListNode *p1 = head;\\n            ListNode *p2 = head;\\n            while (p1) {\\n                while (p2->next && p1->val==p2->next->val) {\\n                    p2 = p2->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4019039,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null)return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.next!=null && cur.val==cur.next.val){\\n                while(cur.next!=null && cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                prev.next=cur.next;\\n            }\\n            else{\\n                prev=cur;\\n            }\\n            cur=cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null)return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.next!=null && cur.val==cur.next.val){\\n                while(cur.next!=null && cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                prev.next=cur.next;\\n            }\\n            else{\\n                prev=cur;\\n            }\\n            cur=cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840394,
                "title": "javascript-with-explanation",
                "content": "# Intuition\\nI had to review other answers to get a better understanding, but none of the explanation really were thorough enough to fully understand.\\n\\n# Approach\\nAs other have mentioned, we need to create a dummy node or preNode.\\nSince the intent is that we need a pre node in order for us to keep track and remove the duplicates. \\nIf we don\\'t have the pre node, we going to have a hard time updating the current node. The pre node is key to solving this problem.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst deleteDuplicates = function(head) {\\n    // Example head: [1,2,3,3,4,4,5]\\n    let dummyNode = new ListNode(0)\\n    dummyNode.next = head \\n    // dummyNode -> [0,1,2,3,3,4,4,5] \\n    // which now gives us a starting node to update once\\n    // we\\'ve found and removed duplicate\\n    // we assign dummyNode to list \\n    let list = dummyNode\\n\\n    // Start list = [0,1,2,3,3,4,4,5]\\n    // We want to continously check the next and the next.next node\\n    // AKA nodes 1 -> 2 above in list\\n    // The while loop below will reach the else statement until \\n    // we reach the  3 -> 3 nodes\\n    while (list.next && list.next.next) {\\n        if (list.next.val === list.next.next.val) {\\n            // [1,2,3,3,4,4,5]\\n            //      ^ ^ \\n            // Now that we\\'ve found our first duplicate,\\n            // it turns into a sub loop to remove not just one, \\n            // but all dupes, referring to 2nd Ex: [1,1,1,2,3]\\n            while (list.next && list.next.next && list.next.val === list.next.next.val) {\\n                 // [1,2,3,3,4,4,5]\\n                 //        ^ ^ \\n                list.next = list.next.next\\n                // Next, which is the 2nd node 3 gets updated to 4. \\n                // We then wold loop again in the while loop\\n                // which will be false, moving on to the next line below\\n            }\\n            // Now we remove the first 3 since it\\'s part of the dupes\\n            // list is 1 below, so list.next is 2\\n            // [1,2,3,4,4,5] -> [1,2,4,4,5]\\n            //  | ^   ^ \\n            list.next = list.next.next\\n        } else {\\n            // If not a dupe we update current with next.\\n            list = list.next\\n        }\\n    }\\n    return dummyNode.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst deleteDuplicates = function(head) {\\n    // Example head: [1,2,3,3,4,4,5]\\n    let dummyNode = new ListNode(0)\\n    dummyNode.next = head \\n    // dummyNode -> [0,1,2,3,3,4,4,5] \\n    // which now gives us a starting node to update once\\n    // we\\'ve found and removed duplicate\\n    // we assign dummyNode to list \\n    let list = dummyNode\\n\\n    // Start list = [0,1,2,3,3,4,4,5]\\n    // We want to continously check the next and the next.next node\\n    // AKA nodes 1 -> 2 above in list\\n    // The while loop below will reach the else statement until \\n    // we reach the  3 -> 3 nodes\\n    while (list.next && list.next.next) {\\n        if (list.next.val === list.next.next.val) {\\n            // [1,2,3,3,4,4,5]\\n            //      ^ ^ \\n            // Now that we\\'ve found our first duplicate,\\n            // it turns into a sub loop to remove not just one, \\n            // but all dupes, referring to 2nd Ex: [1,1,1,2,3]\\n            while (list.next && list.next.next && list.next.val === list.next.next.val) {\\n                 // [1,2,3,3,4,4,5]\\n                 //        ^ ^ \\n                list.next = list.next.next\\n                // Next, which is the 2nd node 3 gets updated to 4. \\n                // We then wold loop again in the while loop\\n                // which will be false, moving on to the next line below\\n            }\\n            // Now we remove the first 3 since it\\'s part of the dupes\\n            // list is 1 below, so list.next is 2\\n            // [1,2,3,4,4,5] -> [1,2,4,4,5]\\n            //  | ^   ^ \\n            list.next = list.next.next\\n        } else {\\n            // If not a dupe we update current with next.\\n            list = list.next\\n        }\\n    }\\n    return dummyNode.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531498,
                "title": "simple-solution-two-pointer-c-java",
                "content": "\\n# Approach 1 - Using HashMap\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a hashmap and store the frequency of elements and recreate the linked list by taking the elements occurring once.\\n\\nBut for that we have to traverse the linked list twice and we will not use the fact that the given linked list is sorted.\\n\\n# Approach 2 - Two pointer\\n$$ Optimized \\\\hspace{0.2cm} solution $$\\n<!-- This is the actual solution in the code. -->\\nWe can use the given condition that the linked list is sorted and use two pointers to keep track of repeated nodes.\\n\\nKeep a `count` variable and keep track of number of occurances of nodes.\\n\\nTraverse through the linked list and add the elements which occur only once to the new linked list.\\n> **Optimization:** Can modify the given linked list without using extra space.\\n\\nNote: Don\\'t forget to check for the last element of the linked list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\n\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == NULL || head->next == NULL) return head;\\n\\n        ListNode *curr = head, *prev = NULL;\\n        ListNode *r_head = NULL, *r_tail = NULL;\\n\\n        int cnt = 0;\\n        while (curr != NULL) {\\n            if (prev == NULL || prev->val == curr->val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == NULL) {\\n                        r_head = new ListNode(prev->val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail->next = new ListNode(prev->val);\\n                        r_tail = r_tail->next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != NULL) {\\n            if (r_head == NULL) {\\n                r_head = new ListNode(prev->val);\\n            } else {\\n                r_tail->next = new ListNode(prev->val);\\n            }\\n        }\\n        return r_head;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode curr = head, prev = null;\\n        ListNode r_head = null, r_tail = null;\\n\\n        int cnt = 0;\\n        while (curr != null) {\\n            if (prev == null || prev.val == curr.val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == null) {\\n                        r_head = new ListNode(prev.val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail.next = new ListNode(prev.val);\\n                        r_tail = r_tail.next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != null) {\\n            if (r_head == null) {\\n                r_head = new ListNode(prev.val);\\n            } else {\\n                r_tail.next = new ListNode(prev.val);\\n            }\\n        }\\n        return r_head;\\n    }\\n}\\n```\\n\\n**Will you upvote if the solution was helpful?**",
                "solutionTags": [
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\n\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == NULL || head->next == NULL) return head;\\n\\n        ListNode *curr = head, *prev = NULL;\\n        ListNode *r_head = NULL, *r_tail = NULL;\\n\\n        int cnt = 0;\\n        while (curr != NULL) {\\n            if (prev == NULL || prev->val == curr->val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == NULL) {\\n                        r_head = new ListNode(prev->val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail->next = new ListNode(prev->val);\\n                        r_tail = r_tail->next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != NULL) {\\n            if (r_head == NULL) {\\n                r_head = new ListNode(prev->val);\\n            } else {\\n                r_tail->next = new ListNode(prev->val);\\n            }\\n        }\\n        return r_head;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode curr = head, prev = null;\\n        ListNode r_head = null, r_tail = null;\\n\\n        int cnt = 0;\\n        while (curr != null) {\\n            if (prev == null || prev.val == curr.val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == null) {\\n                        r_head = new ListNode(prev.val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail.next = new ListNode(prev.val);\\n                        r_tail = r_tail.next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != null) {\\n            if (r_head == null) {\\n                r_head = new ListNode(prev.val);\\n            } else {\\n                r_tail.next = new ListNode(prev.val);\\n            }\\n        }\\n        return r_head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453909,
                "title": "easy-and-simple-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n         ListNode curr=dummy;\\n        if(head==null || head.next==null){\\n             return head;\\n        }\\n        while(curr.next!=null && curr.next.next!=null){\\n          if(curr.next.val==curr.next.next.val){\\n              int value=curr.next.val;\\n              while(curr.next!=null && curr.next.val==value){\\n                  curr.next=curr.next.next;\\n              }\\n          }\\n          else{\\n              curr=curr.next;\\n          }  \\n        }\\n        return dummy.next;\\n        // ListNode ptr=head;\\n        // ListNode ptr2=head.next;\\n        // if(head==null || head.next==null){\\n        //     return head;\\n        // }\\n        // if(head.val==head.next.val){\\n        //     head=head.next.next.next;\\n        // }\\n        // while(ptr2.next!=null){\\n        //     if(ptr2.val==ptr2.next.val){\\n        //        ptr.next=ptr2.next.next;\\n        //        ptr2=ptr2.next.next;\\n        //     }\\n        //     else{\\n        //         ptr=ptr.next;\\n        //         ptr2=ptr2.next;\\n        //     }\\n        // }\\n        // return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n         ListNode curr=dummy;\\n        if(head==null || head.next==null){\\n             return head;\\n        }\\n        while(curr.next!=null && curr.next.next!=null){\\n          if(curr.next.val==curr.next.next.val){\\n              int value=curr.next.val;\\n              while(curr.next!=null && curr.next.val==value){\\n                  curr.next=curr.next.next;\\n              }\\n          }\\n          else{\\n              curr=curr.next;\\n          }  \\n        }\\n        return dummy.next;\\n        // ListNode ptr=head;\\n        // ListNode ptr2=head.next;\\n        // if(head==null || head.next==null){\\n        //     return head;\\n        // }\\n        // if(head.val==head.next.val){\\n        //     head=head.next.next.next;\\n        // }\\n        // while(ptr2.next!=null){\\n        //     if(ptr2.val==ptr2.next.val){\\n        //        ptr.next=ptr2.next.next;\\n        //        ptr2=ptr2.next.next;\\n        //     }\\n        //     else{\\n        //         ptr=ptr.next;\\n        //         ptr2=ptr2.next;\\n        //     }\\n        // }\\n        // return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239255,
                "title": "python-97-02-faster-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        temp=head\\n        dummy=pre=ListNode()\\n        while temp and temp.next:\\n            if temp.val==temp.next.val:\\n                while temp and temp.next and temp.val==temp.next.val:\\n                    temp=temp.next\\n                temp=temp.next\\n                pre.next=temp\\n            else:\\n                pre.next=temp\\n                pre=pre.next\\n                temp=temp.next\\n        return dummy.next\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        temp=head\\n        dummy=pre=ListNode()\\n        while temp and temp.next:\\n            if temp.val==temp.next.val:\\n                while temp and temp.next and temp.val==temp.next.val:\\n                    temp=temp.next\\n                temp=temp.next\\n                pre.next=temp\\n            else:\\n                pre.next=temp\\n                pre=pre.next\\n                temp=temp.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150415,
                "title": "1-baar-code-dekhe-fir-vishwas-kare-sabse-easy-approach-using-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        unordered_map<int,int> ump;\\n        ListNode* head1=new ListNode(0);\\n        ListNode *tomp=head1;\\n\\n        ListNode *temp=head;\\n        while(temp!=NULL)\\n        {\\n            ump[temp->val]++;\\n            temp=temp->next;\\n        }\\n         \\n        temp=head;\\n        while(temp!=NULL)\\n        {\\n            if(ump[temp->val]==1)\\n            {\\n             ListNode * temp1 =new ListNode(temp->val);\\n             tomp->next=temp1;\\n             tomp=temp1;\\n\\n            \\n               \\n\\n            }\\n            temp=temp->next;\\n        }\\n\\nreturn head1->next;\\n\\n    \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        unordered_map<int,int> ump;\\n        ListNode* head1=new ListNode(0);\\n        ListNode *tomp=head1;\\n\\n        ListNode *temp=head;\\n        while(temp!=NULL)\\n        {\\n            ump[temp->val]++;\\n            temp=temp->next;\\n        }\\n         \\n        temp=head;\\n        while(temp!=NULL)\\n        {\\n            if(ump[temp->val]==1)\\n            {\\n             ListNode * temp1 =new ListNode(temp->val);\\n             tomp->next=temp1;\\n             tomp=temp1;\\n\\n            \\n               \\n\\n            }\\n            temp=temp->next;\\n        }\\n\\nreturn head1->next;\\n\\n    \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081759,
                "title": "easy-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return  NULL;\\n        ListNode* dummy = new ListNode(0,head);\\n        ListNode* p=dummy, *q=head;\\n        int flag=1;\\n        while(q && q->next){\\n            if(q->val == q->next->val){\\n                q=q->next;\\n                flag=0;\\n            }\\n            else{\\n                if(flag){\\n                    p=p->next;\\n                    q=q->next;\\n                }\\n                else{\\n                    p->next = q->next;\\n                    q=q->next;\\n                }\\n                flag=1;\\n            }\\n        }\\n        if(flag){\\n            p=p->next;\\n            q=q->next;\\n        }\\n        else{\\n            p->next = q->next;\\n            q=q->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return  NULL;\\n        ListNode* dummy = new ListNode(0,head);\\n        ListNode* p=dummy, *q=head;\\n        int flag=1;\\n        while(q && q->next){\\n            if(q->val == q->next->val){\\n                q=q->next;\\n                flag=0;\\n            }\\n            else{\\n                if(flag){\\n                    p=p->next;\\n                    q=q->next;\\n                }\\n                else{\\n                    p->next = q->next;\\n                    q=q->next;\\n                }\\n                flag=1;\\n            }\\n        }\\n        if(flag){\\n            p=p->next;\\n            q=q->next;\\n        }\\n        else{\\n            p->next = q->next;\\n            q=q->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059535,
                "title": "0ms-beats100-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode ptr=dummy;\\n        while(ptr.next!=null && ptr.next.next!=null){\\n            if(ptr.next.val==ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode ptr=dummy;\\n        while(ptr.next!=null && ptr.next.next!=null){\\n            if(ptr.next.val==ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057378,
                "title": "0ms-100-faster-java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n\\n        ListNode ptr=ans;\\n\\n        while(ptr.next!=null && ptr.next.next!=null){\\n\\n            if(ptr.next.val == ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n\\n        ListNode ptr=ans;\\n\\n        while(ptr.next!=null && ptr.next.next!=null){\\n\\n            if(ptr.next.val == ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831244,
                "title": "java-solution-faster-than-100-of-java-submissions-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {    \\n        ListNode result = new ListNode(0, null);\\n        ListNode curr = result;\\n        boolean isRepeated = false;\\n        while (head != null){\\n            while (head.next != null && head.val == head.next.val){\\n                isRepeated = true;\\n                head = head.next;\\n            }\\n            \\n            if (!isRepeated){\\n                curr.next = new ListNode(head.val, null);\\n                curr = curr.next;\\n            }\\n            \\n            isRepeated = false;\\n            head = head.next;\\n        }\\n        return result.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {    \\n        ListNode result = new ListNode(0, null);\\n        ListNode curr = result;\\n        boolean isRepeated = false;\\n        while (head != null){\\n            while (head.next != null && head.val == head.next.val){\\n                isRepeated = true;\\n                head = head.next;\\n            }\\n            \\n            if (!isRepeated){\\n                curr.next = new ListNode(head.val, null);\\n                curr = curr.next;\\n            }\\n            \\n            isRepeated = false;\\n            head = head.next;\\n        }\\n        return result.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834326,
                "title": "python-easy-solution",
                "content": "```\\n\\n```class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = {}\\n        h = ret = ListNode(0)\\n        while head:\\n            if head.val not in l.keys():\\n                l[head.val] = 1\\n            else:\\n                l[head.val] += 1\\n            head = head.next\\n        for i in l.keys():\\n            if l[i] == 1:\\n                # print(i)\\n                ret.next = ListNode(i)\\n                ret = ret.next\\n        return h.next",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833325,
                "title": "remove-duplicate-from-sorted-list-ii-t-c-o-n-s-c-o-1",
                "content": "```\\nListNode* deleteDuplicates(ListNode* head) \\n    {\\n\\t\\t// Return head, if no nodes are present or only one node is present.\\n        if (!head || !head->next)\\n            return head;\\n\\t\\t// Create a prev variable of ListNode type and initialize it with 0.\\n        ListNode* prev = new ListNode(0);\\n        ListNode* ans = prev; // To keep track of first element of the prev.\\n        ListNode* curr = head; \\n\\t\\t// Run the loop unless you find end of the loop or last node.\\n        while (curr && curr->next)\\n        {\\n\\t\\t\\t// Run another loop to skip the duplicate number.\\n            while (curr && curr->next && curr->val == curr->next->val)\\n            {\\n                int x = curr->val;\\n                while (curr && curr->val == x)\\n                    curr = curr->next;\\n            }\\n\\t\\t\\t// After skipping the nodes, join the prev node to the next of the last repeating or duplicate node.\\n            prev->next = curr;\\n            prev = prev->next;\\n            curr = (curr != NULL)? curr->next: NULL; // increment curr until it become NULL.\\n        }\\n\\t\\t// Return next of ans, since prev is having a dummy value a the first node.\\n        return ans->next;\\n    }\\n\\t// Even after running two nested loops, each node is visited only ones, hence the solution is O(n) and space requirement is O(1).\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) \\n    {\\n\\t\\t// Return head, if no nodes are present or only one node is present.\\n        if (!head || !head->next)\\n            return head;\\n\\t\\t// Create a prev variable of ListNode type and initialize it with 0.\\n        ListNode* prev = new ListNode(0);\\n        ListNode* ans = prev; // To keep track of first element of the prev.\\n        ListNode* curr = head; \\n\\t\\t// Run the loop unless you find end of the loop or last node.\\n        while (curr && curr->next)\\n        {\\n\\t\\t\\t// Run another loop to skip the duplicate number.\\n            while (curr && curr->next && curr->val == curr->next->val)\\n            {\\n                int x = curr->val;\\n                while (curr && curr->val == x)\\n                    curr = curr->next;\\n            }\\n\\t\\t\\t// After skipping the nodes, join the prev node to the next of the last repeating or duplicate node.\\n            prev->next = curr;\\n            prev = prev->next;\\n            curr = (curr != NULL)? curr->next: NULL; // increment curr until it become NULL.\\n        }\\n\\t\\t// Return next of ans, since prev is having a dummy value a the first node.\\n        return ans->next;\\n    }\\n\\t// Even after running two nested loops, each node is visited only ones, hence the solution is O(n) and space requirement is O(1).\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597764,
                "title": "two-pointers-with-python",
                "content": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        dummy = ListNode(0,head)\\n        cur = head\\n        pre = dummy\\n        while cur and cur.next:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur:\\n                pre = pre.next\\n                \\n            else:\\n                pre.next = cur.next\\n                \\n            cur = cur.next\\n\\n        return dummy.next\\n\\t\\t\\n\\n**Note**\\n\\n1. Linked list in python is a blind point to me. It was hard for me to realize that the `head` is actually a node, that points to the following list, say, `[1,2,3,3,4,4,5]`. \\n\\n2. In python, linked list has shallow copy too.\\n3. Whenever deal with the linked list type of problem, consider the feasibility of `dummy` node first. Two pointers must have a dummy node.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        dummy = ListNode(0,head)\\n        cur = head\\n        pre = dummy\\n        while cur and cur.next:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur:\\n                pre = pre.next\\n                \\n            else:\\n                pre.next = cur.next\\n                \\n            cur = cur.next\\n\\n        return dummy.next\\n\\t\\t\\n\\n**Note**\\n\\n1. Linked list in python is a blind point to me. It was hard for me to realize that the `head` is actually a node, that points to the following list, say, `[1,2,3,3,4,4,5]`. \\n\\n2. In python, linked list has shallow copy too.\\n3. Whenever deal with the linked list type of problem, consider the feasibility of `dummy` node first. Two pointers must have a dummy node.",
                "codeTag": "Java"
            },
            {
                "id": 1545206,
                "title": "o-n-and-o-1",
                "content": "\\n\\t\\tListNode* tmp = new ListNode(-1);\\n        tmp->next = head;\\n        ListNode* prev = tmp;\\n        while(head != NULL && head->next != NULL)\\n        {\\n            if(head->val == head->next->val)\\n            {\\n                while(head->next != NULL && head->val == head->next->val)\\n                    head = head->next;\\n                head = head->next;\\n                prev->next = head;\\n            }\\n            else\\n            {\\n                prev = head;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return tmp->next;",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n\\t\\tListNode* tmp = new ListNode(-1);\\n        tmp->next = head;\\n        ListNode* prev = tmp;\\n        while(head != NULL && head->next != NULL)\\n        {\\n            if(head->val == head->next->val)\\n            {\\n                while(head->next != NULL && head->val == head->next->val)\\n                    head = head->next;\\n                head = head->next;\\n                prev->next = head;\\n            }\\n            else\\n            {\\n                prev = head;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return tmp->next;",
                "codeTag": "Unknown"
            },
            {
                "id": 1520823,
                "title": "javascript-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n    let tmpHead = new ListNode();\\n    tmpHead.next = head;\\n    let cur = tmpHead;\\n    let visted = new Set();\\n    while(cur.next){\\n       let counter = 0;\\n       let val = cur.next.val;\\n       let tmp = cur.next;\\n       while(tmp && tmp.val == val){\\n           counter++;\\n           tmp =  tmp.next\\n       }\\n       if(counter > 1) cur.next = tmp;\\n       else cur = cur.next; \\n    }\\n    return tmpHead.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    let tmpHead = new ListNode();\\n    tmpHead.next = head;\\n    let cur = tmpHead;\\n    let visted = new Set();\\n    while(cur.next){\\n       let counter = 0;\\n       let val = cur.next.val;\\n       let tmp = cur.next;\\n       while(tmp && tmp.val == val){\\n           counter++;\\n           tmp =  tmp.next\\n       }\\n       if(counter > 1) cur.next = tmp;\\n       else cur = cur.next; \\n    }\\n    return tmpHead.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403605,
                "title": "recursive-rust-short-and-easy-to-understand-0ms-beats-100",
                "content": "I find recursion to be more intuitive for this problem. Essentially, if the current node\\'s value is the same as the previous node\\'s value (`prev`) or if the next node is not `None` and both the current node and the next node have the same value, then I\\'ll skip the current node. Or else, the `next` of the current node is the result of recursively calling the function using the next node as head, and the current node\\'s value as `prev`.\\n\\n```rust\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        fn go(node: Option<Box<ListNode>>, prev: Option<i32>) -> Option<Box<ListNode>> {\\n            if let Some(mut n) = node {\\n                let x = Some(n.val);\\n                if x == prev {\\n                    go(n.next, prev)\\n                } else {\\n                    match n.next {\\n                        Some(n2) if n2.val == n.val => go(Some(n2), x),\\n                        _ => {\\n                            n.next = go(n.next, x);\\n                            Some(Box::new(*n))\\n                        }\\n                    }\\n                }\\n            } else {\\n                None\\n            }\\n        }\\n\\n        go(head, None)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        fn go(node: Option<Box<ListNode>>, prev: Option<i32>) -> Option<Box<ListNode>> {\\n            if let Some(mut n) = node {\\n                let x = Some(n.val);\\n                if x == prev {\\n                    go(n.next, prev)\\n                } else {\\n                    match n.next {\\n                        Some(n2) if n2.val == n.val => go(Some(n2), x),\\n                        _ => {\\n                            n.next = go(n.next, x);\\n                            Some(Box::new(*n))\\n                        }\\n                    }\\n                }\\n            } else {\\n                None\\n            }\\n        }\\n\\n        go(head, None)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368599,
                "title": "golang-clean-solution",
                "content": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    prev := &ListNode{-101, head}\\n    res := prev\\n    \\n    for prev.Next != nil {\\n        val := prev.Next.Val\\n        removed := false\\n        \\n        for prev.Next.Next != nil && prev.Next.Next.Val == val {\\n            prev.Next = prev.Next.Next\\n            removed = true\\n        }\\n        \\n        if removed {\\n            prev.Next = prev.Next.Next\\n            continue\\n        } \\n        prev = prev.Next\\n    }\\n    return res.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    prev := &ListNode{-101, head}\\n    res := prev\\n    \\n    for prev.Next != nil {\\n        val := prev.Next.Val\\n        removed := false\\n        \\n        for prev.Next.Next != nil && prev.Next.Next.Val == val {\\n            prev.Next = prev.Next.Next\\n            removed = true\\n        }\\n        \\n        if removed {\\n            prev.Next = prev.Next.Next\\n            continue\\n        } \\n        prev = prev.Next\\n    }\\n    return res.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265247,
                "title": "simplest-approach-and-explained-with-comments",
                "content": "**Idea is to count the number of nodes and if its freq is 1 connect them.**\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        \\n        ListNode *dummy = new ListNode(0);\\n        ListNode *iter = dummy;\\n        ListNode *cur = head;\\n        //itearte until cur is not NULL\\n        while(cur != NULL){\\n            //store the current node\\n           ListNode *temp = cur;\\n            //counter to store the value repeat\\n           int cnt = 0;\\n            //count number of times it is repeat\\n           while(cur != NULL and (temp -> val == cur -> val)){\\n               cur = cur -> next;\\n               cnt++;\\n           }\\n            //disconnect link with cur\\n           temp -> next = NULL;\\n            //if count is 1 \\n            //that means it is not repeated\\n           if(cnt == 1){    \\n             iter -> next = temp;\\n             iter = iter -> next;\\n           }\\n        }\\n        return dummy -> next;\\n    }\\n```\\n**If you found this approach helpful Please upvote this post :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        \\n        ListNode *dummy = new ListNode(0);\\n        ListNode *iter = dummy;\\n        ListNode *cur = head;\\n        //itearte until cur is not NULL\\n        while(cur != NULL){\\n            //store the current node\\n           ListNode *temp = cur;\\n            //counter to store the value repeat\\n           int cnt = 0;\\n            //count number of times it is repeat\\n           while(cur != NULL and (temp -> val == cur -> val)){\\n               cur = cur -> next;\\n               cnt++;\\n           }\\n            //disconnect link with cur\\n           temp -> next = NULL;\\n            //if count is 1 \\n            //that means it is not repeated\\n           if(cnt == 1){    \\n             iter -> next = temp;\\n             iter = iter -> next;\\n           }\\n        }\\n        return dummy -> next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261074,
                "title": "simple-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {if(head->next!=NULL && head->val==head->next->val)\\n            {while(head->next!=NULL && head->val==head->next->val)\\n                    head=head->next;   \\n             prev->next=head->next;\\n            }\\n            else\\n            prev=head;  \\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {if(head->next!=NULL && head->val==head->next->val)\\n            {while(head->next!=NULL && head->val==head->next->val)\\n                    head=head->next;   \\n             prev->next=head->next;\\n            }\\n            else\\n            prev=head;  \\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198277,
                "title": "c-one-pass-solution-o-n-time-o-1-space",
                "content": "Basically at each value, have a slow pointer wait there, and have another pointer go forward and see if any others have the same value.\\nSince we know that this list is sorted, if there is another node with the same value, we know that there are duplicates.\\nSimply overwrite the duplicates and set slow to fast (as fast will be set to a new value) and continue.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // zero or one nodes in list\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* res_curr = res;\\n        \\n        while (slow) {\\n            int c = 0;\\n            \\n            while (fast && slow->val == fast->val) {\\n                fast = fast->next;\\n                c++;\\n            }\\n            \\n            if (c < 2) {\\n                res_curr->next = slow;\\n                res_curr = res_curr->next;\\n            }\\n            \\n            if (!fast) {\\n                res_curr->next = nullptr;\\n                break;\\n            }\\n            slow = fast;\\n        }\\n        \\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // zero or one nodes in list\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* res_curr = res;\\n        \\n        while (slow) {\\n            int c = 0;\\n            \\n            while (fast && slow->val == fast->val) {\\n                fast = fast->next;\\n                c++;\\n            }\\n            \\n            if (c < 2) {\\n                res_curr->next = slow;\\n                res_curr = res_curr->next;\\n            }\\n            \\n            if (!fast) {\\n                res_curr->next = nullptr;\\n                break;\\n            }\\n            slow = fast;\\n        }\\n        \\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179340,
                "title": "c-easy-using-maps",
                "content": "***Do upvote if it helped you to keep me motivated***  \\uD83D\\uDE0A\\u270C\\n***Explanation in the comments section***\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n      map<int,int> m;\\n      ListNode* temp = head;\\n        while(temp!=NULL)\\n        {\\n            m[temp->val]++;\\n            temp = temp->next;\\n        }\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        for(auto x: m)\\n        {\\n            if(x.second==1)\\n            {\\n               curr->next = new ListNode(x.first);\\n                curr = curr->next;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n      map<int,int> m;\\n      ListNode* temp = head;\\n        while(temp!=NULL)\\n        {\\n            m[temp->val]++;\\n            temp = temp->next;\\n        }\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        for(auto x: m)\\n        {\\n            if(x.second==1)\\n            {\\n               curr->next = new ListNode(x.first);\\n                curr = curr->next;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056505,
                "title": "c-0ms-two-pointers-iterative-beat-100-speed-and-96-87-memory",
                "content": "**Simple Understandable Two pointers approach. (Iterative)**\\n\\nIntializing two pointers temp and prev (previous), temp points to head and intially previous is dummy node (pointing to NULL). \\n1. Starting from head, compare every node value with its next node value.\\n2. If value is same, move temp pointer to the node until value is different. Now, temp is at present just before the node where value is different. **Point to next of this node with prev pointer ( because we want different value)** No need of extra pointer :).\\n3. Relocating the pointers to new postion and move ahead until last node.\\n\\nHere is the code for the same approach. \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp = head;\\n        ListNode* prev = new ListNode(0);\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->val== temp->next->val){\\n                while(temp->next != NULL && temp->val == temp->next->val ) {\\n                    temp->next = temp->next->next;\\n                }\\n                if(temp == head) head = temp->next;\\n                else {\\n                     prev->next = temp->next;\\n                     temp = temp->next;\\n                }\\n            }\\n            else {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp = head;\\n        ListNode* prev = new ListNode(0);\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->val== temp->next->val){\\n                while(temp->next != NULL && temp->val == temp->next->val ) {\\n                    temp->next = temp->next->next;\\n                }\\n                if(temp == head) head = temp->next;\\n                else {\\n                     prev->next = temp->next;\\n                     temp = temp->next;\\n                }\\n            }\\n            else {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003849,
                "title": "swift-solution-using-two-pointers-and-a-dummy-with-comments",
                "content": "```\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        guard let head = head else { return nil }\\n        // Declare a dummy node to start from it and later use it to return the result.\\n        let dummy: ListNode? = ListNode(Int.min)\\n        // Connect dummy with the head\\n        dummy?.next = head\\n        // Use two pointer approach to be able to delete nodes in between them.\\n        var previous: ListNode? = dummy\\n        var current: ListNode? = dummy?.next\\n\\n        // Iterate through all nodes in the list\\n        while current != nil {\\n            // If we have a duplicate\\n            if current?.next?.val == current?.val {\\n                // Iterate until current points to the last duplicated node, needed if there\\'s more than 2 duplicates in a row\\n                while current?.next?.val == current?.val {\\n                    current = current?.next\\n                }\\n                // Remove duplicates by connecting previous with the node after last duplicate\\n                previous?.next = current?.next\\n                // Move current pointer to the next node to continue looping\\n                current = current?.next\\n            } else {\\n                // if the duplicate condition didn\\'t trigger, continue looping\\n                previous = current\\n                current = current?.next\\n            }\\n        }\\n        // The result is dummy\\'s next node\\n        return dummy?.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        guard let head = head else { return nil }\\n        // Declare a dummy node to start from it and later use it to return the result.\\n        let dummy: ListNode? = ListNode(Int.min)\\n        // Connect dummy with the head\\n        dummy?.next = head\\n        // Use two pointer approach to be able to delete nodes in between them.\\n        var previous: ListNode? = dummy\\n        var current: ListNode? = dummy?.next\\n\\n        // Iterate through all nodes in the list\\n        while current != nil {\\n            // If we have a duplicate\\n            if current?.next?.val == current?.val {\\n                // Iterate until current points to the last duplicated node, needed if there\\'s more than 2 duplicates in a row\\n                while current?.next?.val == current?.val {\\n                    current = current?.next\\n                }\\n                // Remove duplicates by connecting previous with the node after last duplicate\\n                previous?.next = current?.next\\n                // Move current pointer to the next node to continue looping\\n                current = current?.next\\n            } else {\\n                // if the duplicate condition didn\\'t trigger, continue looping\\n                previous = current\\n                current = current?.next\\n            }\\n        }\\n        // The result is dummy\\'s next node\\n        return dummy?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003385,
                "title": "java-o-n-0ms-recursive-solution",
                "content": "```\\n/**\\n  Definition for singly-linked list.\\n  public class ListNode {\\n      int val;\\n      ListNode next;\\n      ListNode() {}\\n      ListNode(int val) { this.val = val; }\\n      ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n  }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null)\\n            return head;\\n        if(head.next==null)\\n            return head;\\n        if(head.val !=head.next.val)\\n        {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }else{\\n            int temp = head.val;\\n            while(head!=null && head.val==temp)\\n                head=head.next;\\n            return deleteDuplicates(head);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n  Definition for singly-linked list.\\n  public class ListNode {\\n      int val;\\n      ListNode next;\\n      ListNode() {}\\n      ListNode(int val) { this.val = val; }\\n      ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n  }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null)\\n            return head;\\n        if(head.next==null)\\n            return head;\\n        if(head.val !=head.next.val)\\n        {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }else{\\n            int temp = head.val;\\n            while(head!=null && head.val==temp)\\n                head=head.next;\\n            return deleteDuplicates(head);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003278,
                "title": "c-iteration-recursion-with-sentinel-head-predecessor",
                "content": "**Idea:**\\nSimulation.\\nJust begin with the conceret examples and try to solve them one by one: \\ni) with/without repetition,\\nii) repetition shows up in the middle, begining, ending.\\nDone.\\n\\n**Comments:**\\nWith iteration  apporach, you need address each corner cases.\\nWith recursion approach, you only need focus on the recursion pattern. Your code is only as crystal clear as your thinking. \\n\\nApproach 1: 2-pointer: Sentinel Head + Predecessor\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {        \\n        ListNode dummy(-101), *p = head, *p2=&dummy;        \\n        while(p){\\n            ListNode *l = p, *r = p->next;            \\n            while(r && l->val == r->val) r = r->next;                            \\n            if(l->next == r){ // no repetition\\n                p2->next = l;\\n                p2 = p2->next;\\n                p2->next = NULL; // break chain/list, example: [1, 2, 2]\\n            }\\n            p = r;            \\n        }\\n        return dummy.next;\\n    }\\n};\\n```\\n\\nApproach 2: Recursion\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode * p = head->next;\\n        if(p->val != head->val){\\n            head->next = deleteDuplicates(head->next);\\n            return head;\\n        }else{\\n            while(p && p-> val == head->val) p = p->next;\\n            return deleteDuplicates(p);            \\n        }        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {        \\n        ListNode dummy(-101), *p = head, *p2=&dummy;        \\n        while(p){\\n            ListNode *l = p, *r = p->next;            \\n            while(r && l->val == r->val) r = r->next;                            \\n            if(l->next == r){ // no repetition\\n                p2->next = l;\\n                p2 = p2->next;\\n                p2->next = NULL; // break chain/list, example: [1, 2, 2]\\n            }\\n            p = r;            \\n        }\\n        return dummy.next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode * p = head->next;\\n        if(p->val != head->val){\\n            head->next = deleteDuplicates(head->next);\\n            return head;\\n        }else{\\n            while(p && p-> val == head->val) p = p->next;\\n            return deleteDuplicates(p);            \\n        }        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003000,
                "title": "simple-java-solution-with-explaination-0ms-100-faster",
                "content": "1.To avoid head null checks create dummy node and point dummy.next=head.\\n2.Take two pointers. prev and temp. prev point to dummy initially and temp point to head.\\n3. loop till temp and temp next is available. (as for single node nothing to be deleted)\\n4. if matching element found keep on incrementing temp without changing previous inside loop.\\n5. after loop finishes at point 4 we use boolean to check if some duplicates has found. if yes just point prev.next=temp.next. else just increment prev.\\n6. in any case if duplicate exists or not increment temp to point to next element. \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy= new ListNode(101,head);\\n        ListNode prev = dummy;\\n        ListNode temp = head;\\n        boolean match=false;\\n        while(temp!=null && temp.next!=null) {\\n            match=false;\\n            while(temp.next!=null && temp.next.val==temp.val) {\\n                temp=temp.next;\\n                match=true;\\n            }   \\n            if(match) {\\n                prev.next=temp.next;\\n            } else {\\n                prev=prev.next;\\n            }\\n            temp=temp.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy= new ListNode(101,head);\\n        ListNode prev = dummy;\\n        ListNode temp = head;\\n        boolean match=false;\\n        while(temp!=null && temp.next!=null) {\\n            match=false;\\n            while(temp.next!=null && temp.next.val==temp.val) {\\n                temp=temp.next;\\n                match=true;\\n            }   \\n            if(match) {\\n                prev.next=temp.next;\\n            } else {\\n                prev=prev.next;\\n            }\\n            temp=temp.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758858,
                "title": "java-100-recursion-short-code",
                "content": "If you found the solution helpfu, kindly like or upvote. :)\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null || head.next==null)\\n    \\t\\treturn head;\\n    \\tif(head.val!= head.next.val)\\n    \\t{\\n    \\t\\thead.next=deleteDuplicates(head.next);\\n    \\t\\treturn head;\\n    \\t}\\n    \\t//If there are duplicacy in head\\n    \\tListNode curr= head;\\n    \\twhile(curr !=null &&curr.val==head.val)\\n    \\t{\\n    \\t\\tcurr=curr.next;\\n    \\t}\\n    \\t\\n    \\treturn deleteDuplicates(curr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null || head.next==null)\\n    \\t\\treturn head;\\n    \\tif(head.val!= head.next.val)\\n    \\t{\\n    \\t\\thead.next=deleteDuplicates(head.next);\\n    \\t\\treturn head;\\n    \\t}\\n    \\t//If there are duplicacy in head\\n    \\tListNode curr= head;\\n    \\twhile(curr !=null &&curr.val==head.val)\\n    \\t{\\n    \\t\\tcurr=curr.next;\\n    \\t}\\n    \\t\\n    \\treturn deleteDuplicates(curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738462,
                "title": "c-very-important-memory-leak-handled-beats-95-speed-and-100-memory",
                "content": "The major issue when handling pointers are to check for a memory leak. \\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr) return head;\\n        ListNode* p1=head->next;\\n        if(p1 && p1->val==head->val){\\n         while(p1 && p1->val==head->val) {\\n             ListNode* p2= p1;\\n             p1=p1->next;\\n             p2->next = nullptr;\\n         }\\n            return deleteDuplicates(p1);\\n        }\\n        else \\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    } \\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr) return head;\\n        ListNode* p1=head->next;\\n        if(p1 && p1->val==head->val){\\n         while(p1 && p1->val==head->val) {\\n             ListNode* p2= p1;\\n             p1=p1->next;\\n             p2->next = nullptr;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 694199,
                "title": "java-solution-create-dummy-node",
                "content": "````\\npublic ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if(head.next==null) return head;\\n        \\n        ListNode dummy=new ListNode(-1,head);\\n        ListNode p=dummy;\\n        \\n        while(p.next!=null){\\n                     \\n            ListNode n=p.next;\\n            while(n.next!=null && n.val==n.next.val){\\n                n=n.next;\\n            }\\n            \\n            if(p.next==n){\\n                p=n;\\n            }else{\\n                p.next=n.next;\\n            }\\n            \\n        }\\n        \\n        return dummy.next;\\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "````\\npublic ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if(head.next==null) return head;\\n        \\n        ListNode dummy=new ListNode(-1,head);\\n        ListNode p=dummy;\\n        \\n        while(p.next!=null){\\n                     \\n            ListNode n=p.next;\\n            while(n.next!=null && n.val==n.next.val){\\n                n=n.next;\\n            }\\n            \\n            if(p.next==n){\\n                p=n;\\n            }else{\\n                p.next=n.next;\\n            }\\n            \\n        }\\n        \\n        return dummy.next;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 396679,
                "title": "easy-to-understand-recursive-approach-and-iterative-approach-in-java-with-detailed-comment",
                "content": "Solution A: Recursive way\\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next != null && head.val == head.next.val){\\n            while(head.next != null && head.val == head.next.val){ // if current node is not unique, skip it and its duplicates, then check following\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        }else{\\n            head.next = deleteDuplicates(head.next); // if current node is unique, keep it, and check following\\n        }\\n        return head;\\n    }\\n```\\n\\nSolution B: Iterative way\\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode newDummy = new ListNode(-1); // the dummy head of the non-duplicate linked list\\n        ListNode nonDup = newDummy; // the pointer used to traverse non-duplicate linked list\\n        \\n        ListNode node = head; // the pointer used to traverse the original linked list\\n        \\n        while(node != null){\\n            if(node.next != null && node.val == node.next.val){\\n                int dupVal = node.val; // record the value of duplicates\\n                while(node != null && node.val == dupVal){\\n                    node = node.next; // skip all the duplicates\\n                }\\n            }else{\\n                nonDup.next = node;\\n                nonDup = nonDup.next;\\n                node = node.next;\\n            }\\n        }\\n        \\n        nonDup.next = null; // cut the following nodes referenced by node.next ...\\n        \\n        return newDummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next != null && head.val == head.next.val){\\n            while(head.next != null && head.val == head.next.val){ // if current node is not unique, skip it and its duplicates, then check following\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        }else{\\n            head.next = deleteDuplicates(head.next); // if current node is unique, keep it, and check following\\n        }\\n        return head;\\n    }\\n```\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode newDummy = new ListNode(-1); // the dummy head of the non-duplicate linked list\\n        ListNode nonDup = newDummy; // the pointer used to traverse non-duplicate linked list\\n        \\n        ListNode node = head; // the pointer used to traverse the original linked list\\n        \\n        while(node != null){\\n            if(node.next != null && node.val == node.next.val){\\n                int dupVal = node.val; // record the value of duplicates\\n                while(node != null && node.val == dupVal){\\n                    node = node.next; // skip all the duplicates\\n                }\\n            }else{\\n                nonDup.next = node;\\n                nonDup = nonDup.next;\\n                node = node.next;\\n            }\\n        }\\n        \\n        nonDup.next = null; // cut the following nodes referenced by node.next ...\\n        \\n        return newDummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386437,
                "title": "4ms-c-solution",
                "content": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    if(head == NULL)\\n        return NULL;\\n    if(head->next && head->val == head->next->val) {\\n        /* Remove all duplicate numbers */\\n        while(head->next && head->val == head->next->val)\\n            head = head -> next;\\n        return deleteDuplicates(head->next);\\n    } else {\\n        head->next = deleteDuplicates(head->next);\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    if(head == NULL)\\n        return NULL;\\n    if(head->next && head->val == head->next->val) {\\n        /* Remove all duplicate numbers */\\n        while(head->next && head->val == head->next->val)\\n            head = head -> next;\\n        return deleteDuplicates(head->next);\\n    } else {\\n        head->next = deleteDuplicates(head->next);\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381446,
                "title": "c-best-solution-easy-simplest-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\n        unordered_set<int> s;\\n        \\n        ListNode *t=head;\\n        \\n        if(!head)\\n            return head;\\n        \\n        while(t->next)\\n        {\\n            if(t->next->val == t->val)\\n                s.insert(t->val);\\n            \\n            t=t->next;\\n        }\\n        \\n        t=head;\\n        \\n        \\n        {\\n            while(t->next){\\n                if(s.find(t->next->val)!=s.end())\\n                    t->next=t->next->next;\\n                else\\n                    t=t->next;\\n                \\n            }\\n        }\\n        \\n        if(s.find(head->val)!=s.end())\\n            return head->next;\\n        else\\n            return head;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\n        unordered_set<int> s;\\n        \\n        ListNode *t=head;\\n        \\n        if(!head)\\n            return head;\\n        \\n        while(t->next)\\n        {\\n            if(t->next->val == t->val)\\n                s.insert(t->val);\\n            \\n            t=t->next;\\n        }\\n        \\n        t=head;\\n        \\n        \\n        {\\n            while(t->next){\\n                if(s.find(t->next->val)!=s.end())\\n                    t->next=t->next->next;\\n                else\\n                    t=t->next;\\n                \\n            }\\n        }\\n        \\n        if(s.find(head->val)!=s.end())\\n            return head->next;\\n        else\\n            return head;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322205,
                "title": "javascript-straightforward-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n\\n    let curr = head;\\n    let prev = null; // previous node\\n    \\n    while(curr != null && curr.next != null){\\n        let val; \\n        if(curr.val == curr.next.val){\\n            val = curr.val; // find next node not equal to val:\\n            while(curr != null && curr.val == val)\\n                curr = curr.next;\\n            // erase all \\'val\\' nodes:\\n            if(prev != null){  \\n                prev.next = curr;\\n            }\\n            else{\\n                head = curr;  // change head if it\\'s first node              \\n            }\\n        }\\n        else{\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n    }\\n   \\n    return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n\\n    let curr = head;\\n    let prev = null; // previous node\\n    \\n    while(curr != null && curr.next != null){\\n        let val; \\n        if(curr.val == curr.next.val){\\n            val = curr.val; // find next node not equal to val:\\n            while(curr != null && curr.val == val)\\n                curr = curr.next;\\n            // erase all \\'val\\' nodes:\\n            if(prev != null){  \\n                prev.next = curr;\\n            }\\n            else{\\n                head = curr;  // change head if it\\'s first node              \\n            }\\n        }\\n        else{\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n    }\\n   \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315543,
                "title": "java-recursive-solution-100-time-100-space",
                "content": "Time O(n)  Space O(n)\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\\nIterative solution space is O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258435,
                "title": "c-solution-with-explanation",
                "content": "In terms of memory leak, it is dangerous to delete or free memories which are not allocated by your program.\\n\\nIn addition, modern C++ encourages programmers to use smart pointer classes, like shared_ptr, instead of pure pointers. Interviewers may be more than happy to disscuss these topics.\\n\\n```\\nclass Solution {\\npublic:\\n    // return the ptr of first non-repeating elements starting from head\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // base cases\\n        if (head->next->val == head->val) {\\n            // this head is duplicate and can not be used\\n            \\n            while (head->next && head->next->val == head->val) {\\n                // skip until a non-repeating element (or NULL) appears\\n                head = head->next;\\n            }\\n            // check that element\\n            return deleteDuplicates(head->next);\\n        }\\n        // this head can be use, check the subsequent elements \\n        // and connect them together\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // return the ptr of first non-repeating elements starting from head\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // base cases\\n        if (head->next->val == head->val) {\\n            // this head is duplicate and can not be used\\n            \\n            while (head->next && head->next->val == head->val) {\\n                // skip until a non-repeating element (or NULL) appears\\n                head = head->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 216313,
                "title": "clean-easy-to-understand-c-solution-without-memory-leaks",
                "content": "Most C/C++ solutions leak the nodes that are supposedly deleted or the \\'dummy\\' node. Here\\'s a clean, compact solution that actually doesn\\'t leak memory:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)  return head;\\n        \\n        ListNode dummyHead(0);  dummyHead.next = head;\\n        ListNode* crt = head;   ListNode* prev = &dummyHead;\\n        while (crt != nullptr && crt->next != nullptr)\\n        {\\n             if (crt->next->val == crt->val)\\n             {\\n                int duplicateVal = crt->val;\\n                while (crt != nullptr && crt->val == duplicateVal)\\n                {\\n                    prev->next = crt->next;\\n                    delete crt;\\n                    crt = prev->next;\\n                }\\n             }\\n             else\\n             {\\n                 prev = crt;\\n                 crt = crt->next;\\n             }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)  return head;\\n        \\n        ListNode dummyHead(0);  dummyHead.next = head;\\n        ListNode* crt = head;   ListNode* prev = &dummyHead;\\n        while (crt != nullptr && crt->next != nullptr)\\n        {\\n             if (crt->next->val == crt->val)\\n             {\\n                int duplicateVal = crt->val;\\n                while (crt != nullptr && crt->val == duplicateVal)\\n                {\\n                    prev->next = crt->next;\\n                    delete crt;\\n                    crt = prev->next;\\n                }\\n             }\\n             else\\n             {\\n                 prev = crt;\\n                 crt = crt->next;\\n             }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28344,
                "title": "python-simple-solution",
                "content": "`curr` will always be the node behind, in case the next node is a duplicate that needs to be removed. Even the head can be removed. Hence having a dummy node solves this problem. \\n\\n*- Yangshun*\\n\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        dummy = ListNode(None)\\n        dummy.next = head\\n        curr = dummy\\n        while curr:\\n            has_dup = False\\n            # Remove duplicates and leave the last of the duplicates.\\n            while curr.next and curr.next.next and curr.next.val == curr.next.next.val:\\n                curr.next = curr.next.next\\n                has_dup = True\\n            if has_dup:\\n                # Remove the last duplicate\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        dummy = ListNode(None)\\n        dummy.next = head\\n        curr = dummy\\n        while curr:\\n            has_dup = False\\n            # Remove duplicates and leave the last of the duplicates.\\n            while curr.next and curr.next.next and curr.next.val == curr.next.next.val:\\n                curr.next = curr.next.next\\n                has_dup = True\\n            if has_dup:\\n                # Remove the last duplicate\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28388,
                "title": "simple-iterative-solution-with-memory-management",
                "content": "I am not sure why none of the top C++ answers has memory deletion. Here is my simple solution with correct memory release. Would appreciate suggestions.\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode *prev = &dummy;\\n        \\n        while (prev->next) {\\n            ListNode *cur = prev->next;\\n            if (cur->next && cur->next->val == cur->val) {\\n                do {\\n                    ListNode* tmp = cur->next->next;\\n                    delete cur->next;\\n                    cur->next = tmp;\\n                } while (cur->next && cur->next->val == cur->val);\\n                prev->next = cur->next;\\n                delete cur;\\n            } else {\\n                prev = prev->next;\\n            }\\n        }\\n      \\n        return dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode *prev = &dummy;\\n        \\n        while (prev->next) {\\n            ListNode *cur = prev->next;\\n            if (cur->next && cur->next->val == cur->val) {\\n                do {\\n                    ListNode* tmp = cur->next->next;\\n                    delete cur->next;\\n                    cur->next = tmp;\\n                } while (cur->next && cur->next->val == cur->val);\\n                prev->next = cur->next;\\n                delete cur;\\n            } else {\\n                prev = prev->next;\\n            }\\n        }\\n      \\n        return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28501,
                "title": "share-beat-100-python-code",
                "content": "    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy = ListNode(0)\\n        pt = dummy\\n        repeated = 0\\n        while head and head.next:\\n            if head.val != head.next.val:\\n                if not repeated:\\n                    pt.next = head\\n                    pt = pt.next\\n                repeated = 0\\n            else:\\n                repeated = 1\\n            head = head.next\\n            \\n        pt.next = None if repeated else head\\n        \\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy = ListNode(0)\\n        pt = dummy\\n        repeated = 0\\n        while head and head.next:\\n            if head.val != head.next.val:\\n                if not repeated:\\n                    pt.next = head\\n                    pt = pt.next\\n                repeated = 0\\n            else:\\n                repeated = 1\\n            head = head.next\\n            \\n        pt.next = None if repeated else head\\n        \\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 4023606,
                "title": "java-beats-100-o-n-time-complexity-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        head = new ListNode(0, head);\\n        ListNode curr = head, prev = head;\\n\\n        while (curr != null && curr.next != null) {\\n            if (curr == head) {\\n                curr = curr.next;\\n                continue;\\n            }\\n            if (curr.val != curr.next.val) {\\n                prev = curr;\\n            }\\n            else {\\n                while (curr.next != null && curr.val == curr.next.val) {\\n                    curr = curr.next;\\n                }\\n                prev.next = curr.next;\\n            }\\n\\n            curr = curr.next;\\n        }\\n\\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        head = new ListNode(0, head);\\n        ListNode curr = head, prev = head;\\n\\n        while (curr != null && curr.next != null) {\\n            if (curr == head) {\\n                curr = curr.next;\\n                continue;\\n            }\\n            if (curr.val != curr.next.val) {\\n                prev = curr;\\n            }\\n            else {\\n                while (curr.next != null && curr.val == curr.next.val) {\\n                    curr = curr.next;\\n                }\\n                prev.next = curr.next;\\n            }\\n\\n            curr = curr.next;\\n        }\\n\\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005092,
                "title": "best-recursive-solution-for-java",
                "content": "# Intuition\\nDo recursion with the given function, only need to declare a global variable. \\n\\n# Approach\\nA duplicate node is when the adjacents are holding sama value. When head is a duplicate node then store head as duplicate and check the next node for if it\\'s duplicate or not. Otherwise set head next by deleting duplicates from the head next node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode duplicate;\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        } \\n        if (duplicate != null) {\\n            if (head.val == duplicate.val) {\\n                return deleteDuplicates(head.next);\\n            } else {\\n                duplicate = null;\\n                head = deleteDuplicates(head);\\n            }\\n        } else if (head.next != null && head.val == head.next.val) {\\n            duplicate = head;\\n            return deleteDuplicates(head.next.next);\\n        } else {\\n            duplicate = null;\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode duplicate;\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        } \\n        if (duplicate != null) {\\n            if (head.val == duplicate.val) {\\n                return deleteDuplicates(head.next);\\n            } else {\\n                duplicate = null;\\n                head = deleteDuplicates(head);\\n            }\\n        } else if (head.next != null && head.val == head.next.val) {\\n            duplicate = head;\\n            return deleteDuplicates(head.next.next);\\n        } else {\\n            duplicate = null;\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998727,
                "title": "easy-solution-without-extra-space-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing through the linked list maintaining previous pointer and connecting latest found (appearently) non duplicate node as it\\'s next.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. It first checks if the list is empty (has no elements). If it\\'s empty, there\\'s nothing to do, so it returns an empty list.\\n\\n2. It creates a special node called \\'x\\' and connects it to the beginning of the list. This helps in handling cases where the first element of the list is a duplicate.\\n\\n3. It sets up two pointers, \\'head\\' and \\'prev,\\' to traverse the list. \\'Head\\' is used to move through the list, and \\'prev\\' keeps track of the previous node.\\n\\n4. The code then goes through the list one element at a time using a loop.\\n\\n5. Inside the loop, it checks if the current element has duplicates by comparing its value with the next element\\'s value. If duplicates are found, it marks them and moves the \\'head\\' pointer past all duplicates.\\n\\n6. If duplicates were marked, it makes the \\'prev\\' node skip these duplicates by updating its \\'next\\' pointer to point to the first non-duplicate element.\\n\\n7. If no duplicates were found, it updates \\'prev\\' to the current element.\\n\\n8. It then moves the \\'head\\' pointer to the next element and repeats the process until it reaches the end of the list.\\n\\n9. Finally, it returns the modified list, which starts from \\'x->next,\\' excluding the initial \\'x\\' node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nTraversing through entire linked list for once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nNot using any extra space.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n    // Check if the linked list is empty, if so, return NULL\\n    if (!head) return NULL;\\n\\n    // Create a new node \\'x\\' and set its next pointer to the head of the linked list\\n    ListNode* x = new ListNode(0);\\n    x->next = head;\\n\\n    // Create a \\'prev\\' pointer to keep track of the previous node while traversing\\n    ListNode* prev = x;\\n\\n    // Loop through the linked list\\n    while (head) {\\n        // Initialize a boolean \\'dup\\' to false to track duplicate nodes\\n        bool dup = false;\\n\\n        // Check for duplicates by comparing the current node\\'s value with the next node\\'s value\\n        while (head->next && head->next->val == head->val) {\\n            head = head->next;\\n            dup = true;\\n        }\\n\\n        // If duplicates were found, update the \\'prev\\' node\\'s next pointer to skip the duplicates\\n        if (dup) {\\n            prev->next = head->next;\\n        } else {\\n            // If no duplicates were found, simply update \\'prev\\' to the current node\\n            prev = head;\\n        }\\n\\n        // Move to the next node in the linked list\\n        head = head->next;\\n    }\\n\\n    // Return the modified linked list starting from \\'x->next\\'\\n    return x->next;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n    // Check if the linked list is empty, if so, return NULL\\n    if (!head) return NULL;\\n\\n    // Create a new node \\'x\\' and set its next pointer to the head of the linked list\\n    ListNode* x = new ListNode(0);\\n    x->next = head;\\n\\n    // Create a \\'prev\\' pointer to keep track of the previous node while traversing\\n    ListNode* prev = x;\\n\\n    // Loop through the linked list\\n    while (head) {\\n        // Initialize a boolean \\'dup\\' to false to track duplicate nodes\\n        bool dup = false;\\n\\n        // Check for duplicates by comparing the current node\\'s value with the next node\\'s value\\n        while (head->next && head->next->val == head->val) {\\n            head = head->next;\\n            dup = true;\\n        }\\n\\n        // If duplicates were found, update the \\'prev\\' node\\'s next pointer to skip the duplicates\\n        if (dup) {\\n            prev->next = head->next;\\n        } else {\\n            // If no duplicates were found, simply update \\'prev\\' to the current node\\n            prev = head;\\n        }\\n\\n        // Move to the next node in the linked list\\n        head = head->next;\\n    }\\n\\n    // Return the modified linked list starting from \\'x->next\\'\\n    return x->next;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974848,
                "title": "python-3-o-1-space-solution",
                "content": "##### UPVOTE IF YOU LIKE ;)\\n![SpidermanTobeyMaguireGIF.gif](https://assets.leetcode.com/users/images/b55a37a9-a9f5-4be8-a13e-455c0a0a2714_1693289534.1989064.gif)\\n\\n# Code\\n```py\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Base Case\\n        if not head: return None\\n        \\n        # Dummy Node\\n        dummy = ListNode(0, head)\\n\\n        # dup\\'s initial value is a value that \\n        # a node cannot have in this problem\\n        prev, cur = dummy, head\\n        dup = -101\\n        while cur.next:\\n            # If a duplicate is found, save that value\\n            if cur.val == cur.next.val:\\n                dup = cur.val\\n            \\n            # If the current node\\'s value is dup\\n            # Remove the current node\\n            if cur.val == dup:\\n                prev.next = cur.next\\n\\n            # If not just update prev to its next node                \\n            else:\\n                prev = prev.next\\n\\n            cur = cur.next\\n\\n        # Check the last node\\n        if cur.val == dup:\\n            prev.next = None\\n        \\n        return dummy.next\\n            \\n```\\n\\n# Explanation\\nCheck my blog for detailed explanations: https://gaebalogaebal.tistory.com/category/%5BLeetCode%5D\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```py\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Base Case\\n        if not head: return None\\n        \\n        # Dummy Node\\n        dummy = ListNode(0, head)\\n\\n        # dup\\'s initial value is a value that \\n        # a node cannot have in this problem\\n        prev, cur = dummy, head\\n        dup = -101\\n        while cur.next:\\n            # If a duplicate is found, save that value\\n            if cur.val == cur.next.val:\\n                dup = cur.val\\n            \\n            # If the current node\\'s value is dup\\n            # Remove the current node\\n            if cur.val == dup:\\n                prev.next = cur.next\\n\\n            # If not just update prev to its next node                \\n            else:\\n                prev = prev.next\\n\\n            cur = cur.next\\n\\n        # Check the last node\\n        if cur.val == dup:\\n            prev.next = None\\n        \\n        return dummy.next\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961110,
                "title": "simple-c-solution",
                "content": "# Using Extra Space - Map\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int> mp;\\n        ListNode *temp=head;\\n        while(temp!=nullptr){\\n            mp[temp->val]++;\\n            temp=temp->next;\\n        }\\n        ListNode *res=new ListNode(0);\\n        temp=res;\\n        for(auto m:mp){\\n            if(m.second==1){\\n                temp->next=new ListNode(m.first);\\n                temp=temp->next;\\n            }\\n        }\\n        return res->next;\\n    }\\n};\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *deleteDuplicates(ListNode *head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *res=new ListNode(0);\\n        ListNode *current=head,*prevNode=res;\\n        while(current){\\n            bool isDuplicate=false;\\n            while(current->next && current->val==current->next->val){\\n                current=current->next;\\n                isDuplicate=true;\\n            }\\n            if(!isDuplicate){\\n                prevNode->next=current;\\n                prevNode=current;\\n            }\\n            current=current->next;\\n        }\\n        prevNode->next=nullptr;\\n        return res->next;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int> mp;\\n        ListNode *temp=head;\\n        while(temp!=nullptr){\\n            mp[temp->val]++;\\n            temp=temp->next;\\n        }\\n        ListNode *res=new ListNode(0);\\n        temp=res;\\n        for(auto m:mp){\\n            if(m.second==1){\\n                temp->next=new ListNode(m.first);\\n                temp=temp->next;\\n            }\\n        }\\n        return res->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *deleteDuplicates(ListNode *head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *res=new ListNode(0);\\n        ListNode *current=head,*prevNode=res;\\n        while(current){\\n            bool isDuplicate=false;\\n            while(current->next && current->val==current->next->val){\\n                current=current->next;\\n                isDuplicate=true;\\n            }\\n            if(!isDuplicate){\\n                prevNode->next=current;\\n                prevNode=current;\\n            }\\n            current=current->next;\\n        }\\n        prevNode->next=nullptr;\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941117,
                "title": "putta-easy-solution-c-beats-95",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* newhead = new ListNode(0);\\n        ListNode* head2 =newhead ;\\n       ListNode* temp = head;\\n       while(temp) {\\n           int val = temp->val;\\n           ListNode* dummy = temp;\\n           temp = temp->next;\\n            int flag = 0;\\n           while(temp && val == temp->val){\\n               flag = 1;\\n               temp = temp->next;\\n            }\\n           if( flag == 0) {newhead->next = dummy;\\n           newhead = newhead->next;\\n           newhead->next = NULL;}\\n       }\\n       return head2->next;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* newhead = new ListNode(0);\\n        ListNode* head2 =newhead ;\\n       ListNode* temp = head;\\n       while(temp) {\\n           int val = temp->val;\\n           ListNode* dummy = temp;\\n           temp = temp->next;\\n            int flag = 0;\\n           while(temp && val == temp->val){\\n               flag = 1;\\n               temp = temp->next;\\n            }\\n           if( flag == 0) {newhead->next = dummy;\\n           newhead = newhead->next;\\n           newhead->next = NULL;}\\n       }\\n       return head2->next;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890977,
                "title": "use-simple-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        dummy = ListNode(0)  \\n        dummy.next = head\\n        prev = dummy\\n        current = head\\n\\n        while current:\\n            next_node = current.next\\n\\n            while next_node and next_node.val == current.val:\\n                next_node = next_node.next\\n\\n            if current.next != next_node:\\n                prev.next = next_node\\n            else:\\n                prev = current\\n            \\n            current = next_node\\n\\n        return dummy.next\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        dummy = ListNode(0)  \\n        dummy.next = head\\n        prev = dummy\\n        current = head\\n\\n        while current:\\n            next_node = current.next\\n\\n            while next_node and next_node.val == current.val:\\n                next_node = next_node.next\\n\\n            if current.next != next_node:\\n                prev.next = next_node\\n            else:\\n                prev = current\\n            \\n            current = next_node\\n\\n        return dummy.next\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890476,
                "title": "simple-iterative-c-solution",
                "content": "# Intuition\\nCompare adjacent values in the linked list and move the pointer to the next until repeated values are present. \\n\\n# Approach\\nCreate a new header for creating the new list. Iterate through the given list and if current value and value of the next pointer is same, iterate till the value repeats. If the values are not same, create a new node with the same value as the node. If header is null i.e. has not been assigned yet, then set the header equal to the new node, else, set header -> next = new node and header = header -> next.\\n\\nAt the end, if last element is not repeated create a new node with same value as that of last node and set header -> next to the last node.\\nReturn the new header which will be the new list with duplicated values removed.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL) return head;\\n\\n        if(head -> next == NULL) return head;\\n        \\n        ListNode *h = NULL;\\n        ListNode *start = head;\\n\\n        ListNode *ans = NULL;\\n\\n        bool f = false;\\n        \\n        while(start -> next != NULL) {\\n            if(start -> val == start -> next -> val) {\\n                int v = start -> val;\\n                while(start -> next -> val == v) {\\n                    start = start -> next;\\n                    if(start -> next == NULL) break;\\n                }\\n\\n                if(start -> next == NULL) {\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(h == NULL) {\\n                    ListNode *new_node = new ListNode(start -> val);\\n                    new_node -> next = NULL;\\n                    h = new_node;\\n                    ans = h;\\n                }\\n                else{\\n                    ListNode *node = new ListNode(start -> val);\\n                    node -> next = NULL;\\n                    h -> next = node;\\n                    h = h -> next;\\n                }\\n            }\\n            start = start -> next;\\n        }\\n\\n        if(!f) {\\n            if(h == NULL) {\\n                ans = start;\\n            }\\n            else{\\n                h -> next = start;\\n            }\\n        }\\n\\n        h = ans;\\n\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL) return head;\\n\\n        if(head -> next == NULL) return head;\\n        \\n        ListNode *h = NULL;\\n        ListNode *start = head;\\n\\n        ListNode *ans = NULL;\\n\\n        bool f = false;\\n        \\n        while(start -> next != NULL) {\\n            if(start -> val == start -> next -> val) {\\n                int v = start -> val;\\n                while(start -> next -> val == v) {\\n                    start = start -> next;\\n                    if(start -> next == NULL) break;\\n                }\\n\\n                if(start -> next == NULL) {\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(h == NULL) {\\n                    ListNode *new_node = new ListNode(start -> val);\\n                    new_node -> next = NULL;\\n                    h = new_node;\\n                    ans = h;\\n                }\\n                else{\\n                    ListNode *node = new ListNode(start -> val);\\n                    node -> next = NULL;\\n                    h -> next = node;\\n                    h = h -> next;\\n                }\\n            }\\n            start = start -> next;\\n        }\\n\\n        if(!f) {\\n            if(h == NULL) {\\n                ans = start;\\n            }\\n            else{\\n                h -> next = start;\\n            }\\n        }\\n\\n        h = ans;\\n\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884851,
                "title": "c-o-n-3ms-100-beats-easy-solution-with-proper-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n        struct ListNode *dummy = malloc(sizeof(struct ListNode));\\n        dummy->next = head;\\n        dummy->val = 0;\\n        struct ListNode *prev = dummy , *curr = head;\\n\\n        while(curr)\\n        {\\n            struct ListNode *next_node = curr->next;\\n            while(next_node && curr->val == next_node->val)\\n            {\\n                struct ListNode *temp = next_node->next;\\n                // delete next_node;\\n                next_node = temp;\\n            }\\n\\n            if(curr->next != next_node)\\n            {\\n                prev->next = next_node;\\n                // delete curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n\\n            }\\n            curr = next_node;\\n        }\\n        return dummy->next;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n        struct ListNode *dummy = malloc(sizeof(struct ListNode));\\n        dummy->next = head;\\n        dummy->val = 0;\\n        struct ListNode *prev = dummy , *curr = head;\\n\\n        while(curr)\\n        {\\n            struct ListNode *next_node = curr->next;\\n            while(next_node && curr->val == next_node->val)\\n            {\\n                struct ListNode *temp = next_node->next;\\n                // delete next_node;\\n                next_node = temp;\\n            }\\n\\n            if(curr->next != next_node)\\n            {\\n                prev->next = next_node;\\n                // delete curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n\\n            }\\n            curr = next_node;\\n        }\\n        return dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775202,
                "title": "easy-java-solution-beats-100-in-place-solution-clean-code-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n        int flag = 0;\\n\\n        while(traverse.next != null) {\\n            if(traverse.next.val != traverse.val) {\\n                if(flag == 1) {\\n                    traverse = traverse.next;\\n                }\\n                else {\\n                temp.next = traverse;\\n                temp = temp.next;\\n                traverse = traverse.next;\\n                }\\n                flag = 0;\\n            }\\n            else if(traverse.next.val == traverse.val) {\\n                flag = 1;\\n                traverse = traverse.next;\\n            }\\n        } \\n        if(flag == 1) {\\n            temp.next = null;\\n        }\\n        else {\\n        temp.next = traverse;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/a3de047b-a131-4982-a2f2-0013d429d217_1689535320.8316107.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n        int flag = 0;\\n\\n        while(traverse.next != null) {\\n            if(traverse.next.val != traverse.val) {\\n                if(flag == 1) {\\n                    traverse = traverse.next;\\n                }\\n                else {\\n                temp.next = traverse;\\n                temp = temp.next;\\n                traverse = traverse.next;\\n                }\\n                flag = 0;\\n            }\\n            else if(traverse.next.val == traverse.val) {\\n                flag = 1;\\n                traverse = traverse.next;\\n            }\\n        } \\n        if(flag == 1) {\\n            temp.next = null;\\n        }\\n        else {\\n        temp.next = traverse;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732971,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere i have used concept of hash map and basic concept of linkedlist\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n   if(head==null||head.next==null){ return head;}\\n   HashMap<Integer,Integer> map=new HashMap<>();\\n   ListNode node=new ListNode(-1);\\n   ListNode prev=node;\\n   ListNode curr=head;\\n   while(curr!=null){\\n       if(map.containsKey(curr.val)){\\n           map.put(curr.val,map.get(curr.val)+1);\\n       }else{\\n           map.put(curr.val,0);\\n       }\\n       curr=curr.next;\\n   }\\ncurr=head;\\nwhile(curr!=null){\\n    if(map.get(curr.val)==0){\\n        prev.next=curr;\\n        prev=curr;\\n    }\\ncurr=curr.next;}\\nif(prev.next!=null){\\n    prev.next=null;\\n\\n    }\\n    return node.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n   if(head==null||head.next==null){ return head;}\\n   HashMap<Integer,Integer> map=new HashMap<>();\\n   ListNode node=new ListNode(-1);\\n   ListNode prev=node;\\n   ListNode curr=head;\\n   while(curr!=null){\\n       if(map.containsKey(curr.val)){\\n           map.put(curr.val,map.get(curr.val)+1);\\n       }else{\\n           map.put(curr.val,0);\\n       }\\n       curr=curr.next;\\n   }\\ncurr=head;\\nwhile(curr!=null){\\n    if(map.get(curr.val)==0){\\n        prev.next=curr;\\n        prev=curr;\\n    }\\ncurr=curr.next;}\\nif(prev.next!=null){\\n    prev.next=null;\\n\\n    }\\n    return node.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714833,
                "title": "easy-constant-space-solution-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn Linked List write the basic Solution and then try to go for the edge cases , this was one of them , you have to handle the edge cases here.\\n1) what if duplicates were in head ,you gotta handle that\\n2) what if duplicates were the last values you gotta handle that\\n\\n\\nALWAYS TRY DRAWING DIAGRAM FIRST AND SIMLUATE IT \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head,prev = null;\\n\\n        while(temp != null){\\n            ListNode k = temp.next;\\n            \\n            if(temp.next != null && temp.val == temp.next.val){\\n                while(k != null && temp.val == k.val) {\\n                    k = k.next;\\n                }\\n                if( prev == null && k == null) {\\n                    head = null;\\n                    break;\\n                }\\n                else if(prev == null){\\n                    head = k;\\n                    temp = head;\\n                    prev = null;\\n                }\\n                else if( k == null){\\n                    prev.next = null;\\n                    break;\\n                } else {\\n                    prev.next = k;\\n                    temp = prev;\\n                }\\n                continue;\\n            }\\n\\n            prev = temp;\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head,prev = null;\\n\\n        while(temp != null){\\n            ListNode k = temp.next;\\n            \\n            if(temp.next != null && temp.val == temp.next.val){\\n                while(k != null && temp.val == k.val) {\\n                    k = k.next;\\n                }\\n                if( prev == null && k == null) {\\n                    head = null;\\n                    break;\\n                }\\n                else if(prev == null){\\n                    head = k;\\n                    temp = head;\\n                    prev = null;\\n                }\\n                else if( k == null){\\n                    prev.next = null;\\n                    break;\\n                } else {\\n                    prev.next = k;\\n                    temp = prev;\\n                }\\n                continue;\\n            }\\n\\n            prev = temp;\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633297,
                "title": "easy-solution-in-java",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        while(curr!=null && curr.next!=null)\\n        {\\n            boolean flag = false;\\n            if(curr.val != curr.next.val)\\n            {\\n                prev.next = curr;\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n            else\\n            {\\n                int data = curr.val;\\n                while(curr.next!=null && curr.val == curr.next.val)\\n                {\\n                    curr.next = curr.next.next;\\n                }\\n                prev.next = curr.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n```\\n---\\n##### *Please upvote if you\\'ve liked my solution : ))*",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        while(curr!=null && curr.next!=null)\\n        {\\n            boolean flag = false;\\n            if(curr.val != curr.next.val)\\n            {\\n                prev.next = curr;\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n            else\\n            {\\n                int data = curr.val;\\n                while(curr.next!=null && curr.val == curr.next.val)\\n                {\\n                    curr.next = curr.next.next;\\n                }\\n                prev.next = curr.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533733,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic ListNode DeleteDuplicates(ListNode head) {\\n        var dummyHead = new ListNode(0, head);\\n        var prev = dummyHead;\\n        \\n        while (prev != null)\\n        {\\n            // Found value that has duplicates\\n            if (prev.next != null && prev.next.next != null && prev.next.val == prev.next.next.val)\\n            {\\n                var duplicateValue = prev.next.val;\\n                while (prev.next != null && prev.next.val == duplicateValue) prev.next = prev.next.next;\\n            }\\n            else prev = prev.next;\\n        }\\n\\n        return dummyHead.next;\\n    }\\n```",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode DeleteDuplicates(ListNode head) {\\n        var dummyHead = new ListNode(0, head);\\n        var prev = dummyHead;\\n        \\n        while (prev != null)\\n        {\\n            // Found value that has duplicates\\n            if (prev.next != null && prev.next.next != null && prev.next.val == prev.next.next.val)\\n            {\\n                var duplicateValue = prev.next.val;\\n                while (prev.next != null && prev.next.val == duplicateValue) prev.next = prev.next.next;\\n            }\\n            else prev = prev.next;\\n        }\\n\\n        return dummyHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509136,
                "title": "great-explanation-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n   /*\\n   # concept: \\n     @ to delete all duplicate number, we must need to know dup node\\'s previous node to connect with \\n         the next unique node\\n\\n         1)if head node contains dup, then need to make the next unique node to prev.\\n           1->1->2\\n          here, cur node will be 2nd 1, so we will make cur = cur->next and  head = cur;\\n\\n          1)if other node contains dup, then need to make the next unique node to prev.\\n           0->2->2->3\\n          here, cur node will be 2nd 2, so we will make  prev->next = cur->next  and  cur = cur->next;\\n\\n    @ if node don\\'t contains dup, then need to make the node to prev..\\n      prev = curr;\\n     curr = curr->next\\n\\n   */\\n    \\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    //this condition satisfy the condition if(head==NUll or head->next==NULL) return head\\n    //so we don\\'t mention this condition first\\n    while(curr != NULL && curr->next != NULL) {\\n        if(curr->val == curr->next->val) {\\n            //tricky part, as we are comparing two nodes, it must need to check that 2 nodes are avaible \\n            //to check that curr->next != NULL \\n            while(curr->next != NULL && curr->val == curr->next->val) {\\n                curr = curr->next;\\n            }\\n            if(prev != NULL) { //if head not don\\'t contain duplicate\\n                prev->next = curr->next;\\n                curr = curr->next;    \\n            }else { // if head node contain deplicate & no need to change prev\\n                curr = curr->next;  \\n                head = curr;\\n                 \\n            }\\n        }else { //if  all node are unique\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n    }\\n    return head;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n   /*\\n   # concept: \\n     @ to delete all duplicate number, we must need to know dup node\\'s previous node to connect with \\n         the next unique node\\n\\n         1)if head node contains dup, then need to make the next unique node to prev.\\n           1->1->2\\n          here, cur node will be 2nd 1, so we will make cur = cur->next and  head = cur;\\n\\n          1)if other node contains dup, then need to make the next unique node to prev.\\n           0->2->2->3\\n          here, cur node will be 2nd 2, so we will make  prev->next = cur->next  and  cur = cur->next;\\n\\n    @ if node don\\'t contains dup, then need to make the node to prev..\\n      prev = curr;\\n     curr = curr->next\\n\\n   */\\n    \\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    //this condition satisfy the condition if(head==NUll or head->next==NULL) return head\\n    //so we don\\'t mention this condition first\\n    while(curr != NULL && curr->next != NULL) {\\n        if(curr->val == curr->next->val) {\\n            //tricky part, as we are comparing two nodes, it must need to check that 2 nodes are avaible \\n            //to check that curr->next != NULL \\n            while(curr->next != NULL && curr->val == curr->next->val) {\\n                curr = curr->next;\\n            }\\n            if(prev != NULL) { //if head not don\\'t contain duplicate\\n                prev->next = curr->next;\\n                curr = curr->next;    \\n            }else { // if head node contain deplicate & no need to change prev\\n                curr = curr->next;  \\n                head = curr;\\n                 \\n            }\\n        }else { //if  all node are unique\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n    }\\n    return head;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462736,
                "title": "simple-c-solution-using-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *t1=head,*t2;\\n        if(t1==NULL || t1->next==NULL)\\n        {\\n            return head;\\n        }\\n        while(t1!=NULL)\\n        {\\n            if(t1!=NULL && t1->next!=NULL && t1->val==t1->next->val)\\n           {\\n            int x1=t1->val;\\n            while(head!=NULL && head->val==x1)\\n            {\\n                head=head->next;\\n            }\\n            t1=head;\\n          }\\n            else if(t1->next!=NULL && t1->next->next!=NULL &&      t1->next->next->val==t1->next->val)\\n            {\\n                t2=t1->next;\\n                int x=t1->next->val;\\n                while(t2!=NULL && t2->val==x)\\n                {\\n                    t2=t2->next;\\n                }\\n                t1->next=t2;\\n            }\\n            else\\n            {\\n                t1=t1->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *t1=head,*t2;\\n        if(t1==NULL || t1->next==NULL)\\n        {\\n            return head;\\n        }\\n        while(t1!=NULL)\\n        {\\n            if(t1!=NULL && t1->next!=NULL && t1->val==t1->next->val)\\n           {\\n            int x1=t1->val;\\n            while(head!=NULL && head->val==x1)\\n            {\\n                head=head->next;\\n            }\\n            t1=head;\\n          }\\n            else if(t1->next!=NULL && t1->next->next!=NULL &&      t1->next->next->val==t1->next->val)\\n            {\\n                t2=t1->next;\\n                int x=t1->next->val;\\n                while(t2!=NULL && t2->val==x)\\n                {\\n                    t2=t2->next;\\n                }\\n                t1->next=t2;\\n            }\\n            else\\n            {\\n                t1=t1->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457663,
                "title": "82-remove-duplicates-from-sorted-list-ii-java",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode help=new ListNode(); \\n        ListNode prev=help;\\n        help.next=head;\\n        while(head!=null)\\n        {\\n            if(head.next!=null&&head.val==head.next.val)\\n            {\\n                while(head.next!=null&&head.val==head.next.val)\\n                head=head.next;\\n                prev.next=head.next;\\n            }\\n            else\\n            prev=prev.next;\\n            head=head.next;\\n        }\\n        return help.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode help=new ListNode(); \\n        ListNode prev=help;\\n        help.next=head;\\n        while(head!=null)\\n        {\\n            if(head.next!=null&&head.val==head.next.val)\\n            {\\n                while(head.next!=null&&head.val==head.next.val)\\n                head=head.next;\\n                prev.next=head.next;\\n            }\\n            else\\n            prev=prev.next;\\n            head=head.next;\\n        }\\n        return help.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444232,
                "title": "easy-c-code-using-maps",
                "content": "\\n# Approach\\nFirstly use a map to calculate frequencies of each element.\\nCreate a new linked list and insert elements into linked list if the element frequency is equal to 1.\\nWe will obtain a new linked list with no duplicate elements in it. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int>mp;\\n        ListNode *p=head;\\n        while(p){\\n            mp[p->val]++;\\n            p=p->next;\\n        }\\n        ListNode *ans=new ListNode();\\n        ListNode *ans1=ans;\\n        for(auto it:mp){\\n            if(it.second==1){\\n                ans1->next=new ListNode(it.first);\\n                ans1=ans1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int>mp;\\n        ListNode *p=head;\\n        while(p){\\n            mp[p->val]++;\\n            p=p->next;\\n        }\\n        ListNode *ans=new ListNode();\\n        ListNode *ans1=ans;\\n        for(auto it:mp){\\n            if(it.second==1){\\n                ans1->next=new ListNode(it.first);\\n                ans1=ans1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1800490,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1566621,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1865337,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1997794,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1567737,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1946391,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1935798,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1848436,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1811576,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1793403,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1800490,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1566621,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1865337,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1997794,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1567737,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1946391,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1935798,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1848436,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1811576,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1793403,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            }
        ]
    },
    {
        "title": "Duplicate Emails",
        "question_content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report all the duplicate emails. Note that it&#39;s guaranteed that the email&nbsp;field is not NULL.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n<strong>Output:</strong> \n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n<strong>Explanation:</strong> a@b.com is repeated two times.\n</pre>\n",
        "solutions": [
            {
                "id": 53528,
                "title": "i-have-this-simple-approach-anybody-has-some-other-way",
                "content": "select Email \\nfrom Person \\ngroup by Email \\nhaving count(*) > 1",
                "solutionTags": [],
                "code": "select Email \\nfrom Person \\ngroup by Email \\nhaving count(*) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2385937,
                "title": "3-different-solutions-easy-to-understand",
                "content": "```\\n# Please upvote, if you like my solution\\n# 1\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n\\n# 2.\\nSELECT DISTINCT(p1.email) from Person p1, Person p2\\nwhere p1.id <> p2.id AND p1.email = p2.email;\\n\\n#3. \\nSELECT DISTINCT(p1.email) from \\nPerson p1 JOIN Person p2 ON\\np1.email = p2.email AND p1.id <> p2.id;\\n# feel free to ask anything, if have any doubts\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Please upvote, if you like my solution\\n# 1\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n\\n# 2.\\nSELECT DISTINCT(p1.email) from Person p1, Person p2\\nwhere p1.id <> p2.id AND p1.email = p2.email;\\n\\n#3. \\nSELECT DISTINCT(p1.email) from \\nPerson p1 JOIN Person p2 ON\\np1.email = p2.email AND p1.id <> p2.id;\\n# feel free to ask anything, if have any doubts\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827277,
                "title": "100-easy-fast-clean-solution",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT P1.Email FROM Person P1,Person P2 \\n\\nWHERE P1.id <> P2.id AND P1.Email=P2.Email\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/50510b0c-779b-4cac-99da-f40f9ee9f70e_1690526377.4372673.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT P1.Email FROM Person P1,Person P2 \\n\\nWHERE P1.id <> P2.id AND P1.Email=P2.Email\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53553,
                "title": "my-simple-accepted-solution",
                "content": "    select Email\\n    from Person\\n    group by Email\\n    having count(*)>1;",
                "solutionTags": [],
                "code": "    select Email\\n    from Person\\n    group by Email\\n    having count(*)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 53531,
                "title": "a-solution-using-a-group-by-and-another-one-using-a-self-join",
                "content": "914 ms\\n\\n    SELECT Email from Person\\n    Group By Email\\n    Having Count(*) > 1;\\n\\n933 ms\\n\\n    SELECT distinct p1.Email from Person p1\\n    INNER JOIN Person p2\\n    ON p1.Email = p2.Email\\n    WHERE p1.Id <> p2.Id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "914 ms\\n\\n    SELECT Email from Person\\n    Group By Email\\n    Having Count(*) > 1;\\n\\n933 ms\\n\\n    SELECT distinct p1.Email from Person p1\\n    INNER JOIN Person p2\\n    ON p1.Email = p2.Email\\n    WHERE p1.Id <> p2.Id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1538675,
                "title": "simple-accepted-solution",
                "content": "```\\nSELECT email as Email\\nFROM Person \\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```\\n\\n**Like it ? lease upvote !**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email as Email\\nFROM Person \\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53557,
                "title": "share-my-solution",
                "content": "    Select Email\\n    From Person\\n    GROUP BY Email\\n    Having count(Email)>1",
                "solutionTags": [],
                "code": "    Select Email\\n    From Person\\n    GROUP BY Email\\n    Having count(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 53548,
                "title": "simple-solution-use-group-by",
                "content": "    select Email from Person group by Email having count(Email) > 1;",
                "solutionTags": [],
                "code": "    select Email from Person group by Email having count(Email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 3214788,
                "title": "182-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nTo solve this problem, we need to group the records by email and select only those that have more than one occurrence. We can use the GROUP BY clause and HAVING clause to do this. Here\\'s the SQL query:\\n\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```\\nThis will select all the duplicate emails from the Person table. The GROUP BY clause groups the records by email, and the HAVING clause selects only those groups that have more than one record, which means that the email is duplicated.",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027577,
                "title": "mysql-one-line-soln",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849247,
                "title": "easiest-solution-mysql-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct x.email from Person x,Person y where x.email=y.email and x.id>y.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct x.email from Person x,Person y where x.email=y.email and x.id>y.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478870,
                "title": "mysql-3-solutions-faster-than-99-71-having-join",
                "content": "\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F Hello, here are my solutions to the problem.\\nPlease upvote to motivate me post future solutions. HAPPY CODING \\u2764\\uFE0F\\nAny suggestions and improvements are always welcome.\\nSolution 1: Join, long, not good \\uD83E\\uDD26\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n\\u2705 Runtime: 396 ms, faster than 61.66% of MySQL.\\n```\\nselect distinct a.email Email\\nfrom Person as a \\njoin Person as b \\non a.email = b.email and a.id != b.id\\n```\\nSolution 2: Where clause, long, not good \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n\\u2705 Runtime: 588 ms, faster than 32.98% of MySQL.\\n\\n```\\nselect distinct a.email Email \\nfrom Person a, Person b\\nwhere a.email = b.email \\nand a.id <> b.id\\n```\\nSolution 3: Group by and having clause \\uD83C\\uDFAF\\n\\u2705 Runtime: 274 ms, faster than 99.71% of MySQL.\\n\\n```\\nselect email Email\\nfrom Person \\ngroup by email \\nhaving count(*) > 1\\n```\\nIf you like the solutions, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.email Email\\nfrom Person as a \\njoin Person as b \\non a.email = b.email and a.id != b.id\\n```\n```\\nselect distinct a.email Email \\nfrom Person a, Person b\\nwhere a.email = b.email \\nand a.id <> b.id\\n```\n```\\nselect email Email\\nfrom Person \\ngroup by email \\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942961,
                "title": "easy-beginner-solution-using-loc-and-duplicated",
                "content": "# Intuition\\nWe want select all values that are duplicated in our email column and return those as a dataframe, ensuring that we only report each email value once. \\n\\n# Approach\\nThis is a straightforward problem using .loc(), .duplicated(), and .drop_cuplicates().\\n\\n1. We create a new dataFrame called results\\n2. We use .loc to find all elements of the person dataframe whos emails are duplicated using the .duplicated() method. This will populate our results dataframe with each duplicated email. \\n3. We then use drop_duplicates to remove any duplicated values from our results dataFrame since some entries may be duplicated more than once. \\n\\nPlease upvote and happy coding :) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n    results = pd.DataFrame()\\n\\n    results = person.loc[person.duplicated(subset=[\\'email\\']), [\\'email\\']]\\n    \\n    return results.drop_duplicates()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n    results = pd.DataFrame()\\n\\n    results = person.loc[person.duplicated(subset=[\\'email\\']), [\\'email\\']]\\n    \\n    return results.drop_duplicates()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 53546,
                "title": "simple-solution-not-bad",
                "content": "    select distinct(p.Email) \\n    from Person p, Person p1\\n    where (p.Id <> p1.Id and p.Email = p1.Email);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    select distinct(p.Email) \\n    from Person p, Person p1\\n    where (p.Id <> p1.Id and p.Email = p1.Email);",
                "codeTag": "Unknown"
            },
            {
                "id": 2996406,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email having count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967813,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```\\nThe **HAVING** clause was added to SQL because the **WHERE** keyword cannot be used with aggregate functions.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582141,
                "title": "very-easy-mysql-solution-20",
                "content": "```\\nselect email from person group by email having count(id) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email from person group by email having count(id) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1885738,
                "title": "simple-and-elegant-multiple-solutions",
                "content": "**JOIN (Slow)**:\\n```\\nSELECT DISTINCT P1.Email\\nFROM Person P1\\nJOIN Person P2 ON P1.Email = P2.Email\\nWHERE P1.Id <> P2.Id\\n```\\n\\n**Sub-query**:\\n```\\nSELECT EMAIL FROM\\n    (SELECT Email, COUNT(Email) AS EmailCount\\n     FROM Person GROUP BY Email) Q\\nWHERE EmailCount >= 2\\n```\\n\\n**HAVING**:\\n```\\nSELECT Email FROM Person\\nGROUP BY Email\\nHAVING COUNT(Email) >= 2\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nSELECT DISTINCT P1.Email\\nFROM Person P1\\nJOIN Person P2 ON P1.Email = P2.Email\\nWHERE P1.Id <> P2.Id\\n```\n```\\nSELECT EMAIL FROM\\n    (SELECT Email, COUNT(Email) AS EmailCount\\n     FROM Person GROUP BY Email) Q\\nWHERE EmailCount >= 2\\n```\n```\\nSELECT Email FROM Person\\nGROUP BY Email\\nHAVING COUNT(Email) >= 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802338,
                "title": "sql-easy-peasy",
                "content": "```\\nSELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING count(*)>=2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING count(*)>=2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274978,
                "title": "easy-to-understand-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271110,
                "title": "mysql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533631,
                "title": "oracle-plsql-3-different-solution",
                "content": "**Using Subquery**\\n```\\nSELECT EMAIL FROM \\n(SELECT EMAIL,COUNT(EMAIL) AS C FROM PERSON GROUP BY EMAIL ) TEMP \\nWHERE TEMP.C>1;\\n```\\n**Using Having Keyword**\\n*Note - Just as the **WHERE** clause can be used to select and reject the individual rows that participate in a query, the **HAVING** clause can be used to select and reject row groups.*\\n```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```\\n**Using Self Join**\\n```\\nSELECT DISTINCT P1.EMAIL FROM PERSON P1 JOIN PERSON P2 ON P1.EMAIL = P2.EMAIL AND P1.ID <> P2.ID;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT EMAIL FROM \\n(SELECT EMAIL,COUNT(EMAIL) AS C FROM PERSON GROUP BY EMAIL ) TEMP \\nWHERE TEMP.C>1;\\n```\n```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```\n```\\nSELECT DISTINCT P1.EMAIL FROM PERSON P1 JOIN PERSON P2 ON P1.EMAIL = P2.EMAIL AND P1.ID <> P2.ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451415,
                "title": "having-and-count-simple",
                "content": "`select email from Person group By email having count(email)>1 `",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "`select email from Person group By email having count(email)>1 `",
                "codeTag": "Unknown"
            },
            {
                "id": 2421000,
                "title": "mysql-2-different-approach-one-line-solution-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```\\n__________________________________\\n***Approach 2***:\\n\\n```\\nSELECT Email FROM Person GROUP BY Email HAVING  COUNT(*)>1\\n```\\n______________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```\n```\\nSELECT Email FROM Person GROUP BY Email HAVING  COUNT(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803853,
                "title": "best-easiest-mysql-2-approaches-182-duplicate-emails",
                "content": "```\\n#below are 2 mysql solutions for this question\\n\\n#First solution\\nselect email from Person \\ngroup by email\\nhaving count(email)>1;\\n\\n\\n#second solution\\nselect email from\\n(select email, count(email) as c from Person group by email) as temp\\nwhere c>1\\n\\n\\n#pls upvote if you find solution easy ...Thanks..!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#below are 2 mysql solutions for this question\\n\\n#First solution\\nselect email from Person \\ngroup by email\\nhaving count(email)>1;\\n\\n\\n#second solution\\nselect email from\\n(select email, count(email) as c from Person group by email) as temp\\nwhere c>1\\n\\n\\n#pls upvote if you find solution easy ...Thanks..!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1765981,
                "title": "mysql-forever-group-by",
                "content": "```\\nSELECT Email FROM Person group by Email having count(Email) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Email FROM Person group by Email having count(Email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1757753,
                "title": "simple-2-lines-with-explanation-you-ll-love-it-guaranteed",
                "content": "If you\\'ve Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\nHere my appraoch is using SELF JOINS. if you don\\'t have an idea what it is you can check out my answer https://leetcode.com/problems/employees-earning-more-than-their-managers/discuss/1757621/Simple-3-Lines-with-explanation.-(-You\\'ll-love-it-guaranteed.)\\nYou\\'ll get the basic idea what is SELF JOIN.\\n\\nchecking whether the same table has same emails with different ids.\\nif there are, then using DISTINCT keyword to only show unique emails to show on screen. \\n(we don\\'t want to show all them if there are thousand duplicate emails. we want only one)\\n\\n```\\nSELECT DISTINCT p1.email AS Email FROM Person p1\\nJOIN Person p2 ON p1.id != p2.id AND p1.email = p2.email\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT p1.email AS Email FROM Person p1\\nJOIN Person p2 ON p1.id != p2.id AND p1.email = p2.email\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527877,
                "title": "easy-self-join-only",
                "content": "```\\nselect distinct a.Email from Person as a, Person as b where a.Email=b.Email and a.Id<>b.Id",
                "solutionTags": [],
                "code": "```\\nselect distinct a.Email from Person as a, Person as b where a.Email=b.Email and a.Id<>b.Id",
                "codeTag": "Unknown"
            },
            {
                "id": 53550,
                "title": "standard-solution-with-distinct",
                "content": "    SELECT DISTINCT Person.Email \\n    FROM Person \\n    GROUP BY Person.Email\\n    HAVING COUNT(Person.Email) > 1",
                "solutionTags": [],
                "code": "    SELECT DISTINCT Person.Email \\n    FROM Person \\n    GROUP BY Person.Email\\n    HAVING COUNT(Person.Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 53551,
                "title": "a-simple-straightforward-solution",
                "content": "    select Email from Person group by Email having count(Id) > 1",
                "solutionTags": [],
                "code": "    select Email from Person group by Email having count(Id) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 53560,
                "title": "my-first-accepted-sql-solution-using-group-by-in-845-ms-thank-god",
                "content": "    # Write your MySQL query statement below\\n    select email \\n    from( \\n         select \\n               email, \\n               count(*) as c\\n         from Person\\n         group by email\\n    ) a\\n    where a.c > 1;\\nWe should review and think over other guys' solution frequently, especially for beginners. I think it's significantly helpful~~",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    # Write your MySQL query statement below\\n    select email \\n    from( \\n         select \\n               email, \\n               count(*) as c\\n         from Person\\n         group by email\\n    ) a\\n    where a.c > 1;\\nWe should review and think over other guys' solution frequently, especially for beginners. I think it's significantly helpful~~",
                "codeTag": "Unknown"
            },
            {
                "id": 3939489,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525493,
                "title": "mysql-solution-for-duplicate-emails-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe query aims to identify email addresses that are duplicated in the Person table and retrieve those addresses along with their counts.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The query uses the group by clause to group the records in the Person table based on the Email column.\\n2. The having clause is used to filter the groups and include only those groups where the count of email addresses (count(Email)) is greater than 1.\\n3. The select statement select Email retrieves the email addresses from the qualifying groups.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the SQL query depends on the size of the Person table and the efficiency of the database engine\\'s query optimization and execution. Assuming proper indexing and optimization, the time complexity can vary but is typically in the order of O(n log n) or O(n), where n is the number of rows in the Person table.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the SQL query is determined by the memory required to store the result set, which in this case is the email addresses that appear more than once. The space complexity is proportional to the number of rows returned by the query.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect Email from Person group by Email having count(Email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect Email from Person group by Email having count(Email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458408,
                "title": "3-line-code-beats-80",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(email)>1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3329405,
                "title": "very-simple-solution-using-having-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  email from person\\ngroup by email \\nhaving count(*) >1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  email from person\\ngroup by email \\nhaving count(*) >1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218260,
                "title": "mysql-easy-approach",
                "content": "Here is my MYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877331,
                "title": "mysql-simple-having-clause",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING count(email) > 1; \\n```\\n\\n### HAVING count(email) > 1 \\nMainly use the last line to filter out those records which appear more than one in the database.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING count(email) > 1; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652011,
                "title": "mysql-solution-memory-usage-0b",
                "content": "```\\nSELECT EMAIL FROM Person GROUP BY EMAIL HAVING COUNT(*)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT EMAIL FROM Person GROUP BY EMAIL HAVING COUNT(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406578,
                "title": "mysql-using-count",
                "content": "SELECT Email FROM Person \\nGROUP by Email HAVING count(*)>1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT Email FROM Person \\nGROUP by Email HAVING count(*)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2291486,
                "title": "mysql-simple-mysql-solution-using-count-having-clause",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 322 ms, faster than 84.35% of MySQL online submissions for Duplicate Emails.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Duplicate Emails.\\n\\n\\tSELECT EMAIL FROM PERSON\\n\\tGROUP BY EMAIL\\n\\tHAVING COUNT(EMAIL) > 1\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 322 ms, faster than 84.35% of MySQL online submissions for Duplicate Emails.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Duplicate Emails.\\n\\n\\tSELECT EMAIL FROM PERSON\\n\\tGROUP BY EMAIL\\n\\tHAVING COUNT(EMAIL) > 1\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2226726,
                "title": "a-trick-to-solve-duplicate-values-in-sql-using-aggregate-function-and-group-by-mysql-solution",
                "content": "We have to display the duplicate values of email which means display all the mail whose occurence is greater than 1.\\n\\nNow for occurence  we use an aggregate function called as : **count()**\\n\\nA trick to solve Duplicate values in SQL:\\n\\n1.) Using the GROUP BY clause to group all rows by the target column(s) \\u2013 i.e. the column(s) you want to check for duplicate values on.<br>\\n2.) Using the COUNT function in the HAVING clause to check if any of the groups have more than 1 entry; those would be the duplicate values.<br>\\n\\n**MySQL Solution :**\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030358,
                "title": "simple-solution",
                "content": "SELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT (email) >= 2;\\n#please upvote :)",
                "solutionTags": [],
                "code": "SELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT (email) >= 2;\\n#please upvote :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1728735,
                "title": "sql-easy-4-line-group-by-duplicate-emails",
                "content": "```\\nSELECT email \\nFROM person\\nGROUP BY email \\nHAVING count(email) > 1;\\n```\\nPlease **UpVote**, if you understood the problem.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email \\nFROM person\\nGROUP BY email \\nHAVING count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581930,
                "title": "simple-mysql",
                "content": "select email from person\\ngroup by email\\nhaving count(email) > 1",
                "solutionTags": [],
                "code": "select email from person\\ngroup by email\\nhaving count(email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1562445,
                "title": "simple-mysql-solution-faster-than-85",
                "content": "```sql\\nSELECT \\n    email\\nFROM\\n    Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\\n\\nGuess it\\'s pretty straight forward w/o needing explanation. Keep your good work up.",
                "solutionTags": [],
                "code": "```sql\\nSELECT \\n    email\\nFROM\\n    Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1178366,
                "title": "simple-solution-easy-understand",
                "content": "SELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING COUNT(Email)>1",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING COUNT(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 1134229,
                "title": "mysql-2-solutions-easy-to-understand",
                "content": "```\\n#Using Sub Query\\nselect email from Person group by Email having count(Email)>=2;\\n\\n#Using Self Join\\nselect distinct P1.Email from Person as P1, Person as P2 where P1.Email=P2.Email and P1.Id<>P2.Id;\\n```",
                "solutionTags": [],
                "code": "```\\n#Using Sub Query\\nselect email from Person group by Email having count(Email)>=2;\\n\\n#Using Self Join\\nselect distinct P1.Email from Person as P1, Person as P2 where P1.Email=P2.Email and P1.Id<>P2.Id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876543,
                "title": "by-group-by-and-having-clause",
                "content": "SELECT Email\\nFROM Person\\nGROUP BY Email \\nHAVING count(Email)>1;",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM Person\\nGROUP BY Email \\nHAVING count(Email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 170685,
                "title": "group-by-having-most-efficient-solution",
                "content": "```\\nSELECT email \\nFROM   person \\nGROUP  BY email \\nHAVING Count(email) > 1 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email \\nFROM   person \\nGROUP  BY email \\nHAVING Count(email) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53555,
                "title": "my-solution",
                "content": "    SELECT Email FROM Person\\n    GROUP BY Email\\n    HAVING COUNT(Email) > 1",
                "solutionTags": [],
                "code": "    SELECT Email FROM Person\\n    GROUP BY Email\\n    HAVING COUNT(Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 4055225,
                "title": "pandas-easy-duplicate-emails",
                "content": "First Approach:\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051666715/)\\n\\n```\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Let\\'s first, self-join to find distinct duplicated emails\\n    merged_emails_inner = person.merge(person, on=\\'email\\', how=\\'inner\\')\\n\\n    # In the next step, rows where the IDs are not equal are filtered out\\n    filtered_equal_id = merged_emails_inner[merged_emails_inner[\\'id_x\\'] != merged_emails_inner[\\'id_y\\']]\\n\\n    # Then select distinct email addresses\\n    unique_id = filtered_equal_id[\\'email\\'].unique()\\n\\n    # Finally, we can create a new DataFrame with the distinct email addresses\\n    result_df = pd.DataFrame({\\'email\\': unique_id})\\n\\n    return result_df\\n```\\n\\t\\nSecond Approach:\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051679673/)\\n```\\n\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# 1) First, we group by \\'email\\' and filtering using the `HAVING` clause\\n\\t\\tgrouped_emails = person.groupby(\\'email\\')\\n\\n\\t\\t# 2) Then, we can filter the groups based on the condition that the count of each group (i.e., the number of occurrences of each unique email) should be greater than 1.\\n\\t\\tfiltered_emails = grouped_emails.filter(lambda group: len(group) > 1)\\n\\n\\t\\t# 3) in the next step, the unique email addresses from the filtered Series are extracted\\n\\t\\tunique_emails = filtered_emails[\\'email\\'].unique()\\n\\n\\t\\t# 4) Then, we create a DataFrame with the unique email addresses\\n\\t\\tresult_df = pd.DataFrame({\\'email\\': unique_emails})\\n\\n\\t\\treturn result_df\\n```\\n\\nThird Appraoch\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051685938/)\\n\\n```\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# First, we group by \\'email\\' and counting occurrences\\n\\t\\temail_counts = person.groupby(\\'email\\').size()\\n\\n\\t\\t# Next, only emails with counts greater than 1 are filtered\\n\\t\\tresult_df = pd.DataFrame({\\'Email\\': email_counts[email_counts > 1].index})\\n\\n\\t\\treturn result_df\\n```\\n\\n**SQL**\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1061389573/)\\n\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\\n\\n```\\n-- Select the \\'email\\' column from the \\'Person\\' table\\n-- This query is focused on retrieving email addresses.\\n\\nSELECT email\\n\\n-- Specify the source table for the query as \\'Person\\'\\n-- The data is being retrieved from the \\'Person\\' table.\\n\\nFROM Person\\n\\n-- Use the GROUP BY clause to group the data based on the \\'email\\' column\\n-- This groups rows with the same email address together.\\n\\nGROUP BY email\\n\\n-- The HAVING clause filters the grouped results.\\n-- It selects groups (email addresses) where the count of occurrences is greater than 1.\\n-- This identifies email addresses that appear more than once in the \\'Person\\' table.\\n\\nHAVING COUNT(email) > 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/de333cff-f88a-4d35-a3a5-e0b8d0cc2c19_1695221934.7114468.jpeg)\\n",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Let\\'s first, self-join to find distinct duplicated emails\\n    merged_emails_inner = person.merge(person, on=\\'email\\', how=\\'inner\\')\\n\\n    # In the next step, rows where the IDs are not equal are filtered out\\n    filtered_equal_id = merged_emails_inner[merged_emails_inner[\\'id_x\\'] != merged_emails_inner[\\'id_y\\']]\\n\\n    # Then select distinct email addresses\\n    unique_id = filtered_equal_id[\\'email\\'].unique()\\n\\n    # Finally, we can create a new DataFrame with the distinct email addresses\\n    result_df = pd.DataFrame({\\'email\\': unique_id})\\n\\n    return result_df\\n```\n```\\n\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# 1) First, we group by \\'email\\' and filtering using the `HAVING` clause\\n\\t\\tgrouped_emails = person.groupby(\\'email\\')\\n\\n\\t\\t# 2) Then, we can filter the groups based on the condition that the count of each group (i.e., the number of occurrences of each unique email) should be greater than 1.\\n\\t\\tfiltered_emails = grouped_emails.filter(lambda group: len(group) > 1)\\n\\n\\t\\t# 3) in the next step, the unique email addresses from the filtered Series are extracted\\n\\t\\tunique_emails = filtered_emails[\\'email\\'].unique()\\n\\n\\t\\t# 4) Then, we create a DataFrame with the unique email addresses\\n\\t\\tresult_df = pd.DataFrame({\\'email\\': unique_emails})\\n\\n\\t\\treturn result_df\\n```\n```\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# First, we group by \\'email\\' and counting occurrences\\n\\t\\temail_counts = person.groupby(\\'email\\').size()\\n\\n\\t\\t# Next, only emails with counts greater than 1 are filtered\\n\\t\\tresult_df = pd.DataFrame({\\'Email\\': email_counts[email_counts > 1].index})\\n\\n\\t\\treturn result_df\\n```\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\n```\\n-- Select the \\'email\\' column from the \\'Person\\' table\\n-- This query is focused on retrieving email addresses.\\n\\nSELECT email\\n\\n-- Specify the source table for the query as \\'Person\\'\\n-- The data is being retrieved from the \\'Person\\' table.\\n\\nFROM Person\\n\\n-- Use the GROUP BY clause to group the data based on the \\'email\\' column\\n-- This groups rows with the same email address together.\\n\\nGROUP BY email\\n\\n-- The HAVING clause filters the grouped results.\\n-- It selects groups (email addresses) where the count of occurrences is greater than 1.\\n-- This identifies email addresses that appear more than once in the \\'Person\\' table.\\n\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3934435,
                "title": "very-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM PERSON GROUP BY EMAIL HAVING COUNT(*)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM PERSON GROUP BY EMAIL HAVING COUNT(*)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813525,
                "title": "an-easy-to-understand-solution-in-oracle",
                "content": "# Code\\n```\\nSELECT p2.email FROM Person p2 GROUP BY p2.email having count(*) > 1\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT p2.email FROM Person p2 GROUP BY p2.email having count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539763,
                "title": "fully-simple-for-beginners",
                "content": "\\n\\n# Code\\n```\\nSELECT \\nemail as Email \\nFROM PERSON \\nGROUP BY email HAVING count(email) > 1;  \\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT \\nemail as Email \\nFROM PERSON \\nGROUP BY email HAVING count(email) > 1;  \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506209,
                "title": "using-group-by-having-and-count-to-identify-duplicate-values",
                "content": "# Intuition\\nMy first thought was to find all values that are not unique, but I wasn\\'t able to have that work. So then I looked into the GROUP BY and HAVING clause. \\n\\n# Approach\\nUsing the GROUP BY clause, I grouped all the email values and used the HAVING clause to identify emails that had a count greater than 1. This would mean there were duplicate values. \\n\\n# Code\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING(COUNT(email)>1)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING(COUNT(email)>1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501208,
                "title": "simplest-solution",
                "content": "# Intuition\\nThere is a fairly straightforward solution to this problem. To group the results by Email, we simply select the Email column from the Person table. Using the HAVING clause, we filter the groups to include only those with a count greater than one (i.e., those that appear more than once). Consequently, the Person table contains a list of emails that appear more than once.\\n\\nBecause this solution relies on SQL\\'s built-in GROUP BY and HAVING functions, which are optimized for this type of operation, it is efficient. It is not necessary to write any custom functions or loops to iterate over the table data.\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT email as Email\\nFROM Person\\nGROUP BY email\\nHAVING count(*) > 1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT email as Email\\nFROM Person\\nGROUP BY email\\nHAVING count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478941,
                "title": "nested-queries",
                "content": "\\n# Code\\n```\\nSELECT email AS Email FROM (SELECT COUNT(email) AS EmailCount, email FROM Person \\nGROUP BY email) AS Temp WHERE EmailCount > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM (SELECT COUNT(email) AS EmailCount, email FROM Person \\nGROUP BY email) AS Temp WHERE EmailCount > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466076,
                "title": "3-best-approach-to-solve-mysql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n1. select email from person group by email having count(email)>1 ;\\n\\n2. select distinct p1.email from person p1 ,person p2 where p1.id != p2.id and p1.email=p2.email;\\n\\n3. select distinct p1.email from person as p1 join person as p2 on p1.id != p2.id and p1.email=p2.email;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n1. select email from person group by email having count(email)>1 ;\\n\\n2. select distinct p1.email from person p1 ,person p2 where p1.id != p2.id and p1.email=p2.email;\\n\\n3. select distinct p1.email from person as p1 join person as p2 on p1.id != p2.id and p1.email=p2.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409375,
                "title": "super-easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306922,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3294457,
                "title": "mysql-easy-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264077,
                "title": "group-by-and-having",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3121252,
                "title": "simple-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100725,
                "title": "simple-query-duplicate-emails",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100505,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\n\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2917417,
                "title": "duplicate-emails-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING Count(Email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING Count(Email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2699614,
                "title": "mysql-group-by-count",
                "content": "# Write your MySQL query statement below\\n```\\nSELECT DISTINCT email AS Email  FROM Person\\nWHERE email IN\\n(SELECT CASE WHEN COUNT(id)>1 THEN email\\nEND\\nFROM Person\\nGROUP BY email);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT email AS Email  FROM Person\\nWHERE email IN\\n(SELECT CASE WHEN COUNT(id)>1 THEN email\\nEND\\nFROM Person\\nGROUP BY email);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646313,
                "title": "simple-and-easy-explained",
                "content": "Use**GROUP BY**clause to group all the rows by selecting the particular column (*email*);\\nnext use **COUNT()** in the **HAVING** clause to check if any *email* is repeated more than once.\\n\\n```\\nselect email as Email from Person group by email having count(email) > 1;\\n```\\n\\neasy, no? cheers",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580520,
                "title": "using-distinct",
                "content": "**Upvote if you feel it easy :)**\\n```\\nSELECT DISTINCT p1.email\\nFROM Person p1 INNER JOIN person p2 ON p1.email = p2.email AND p1.id <> p2.id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT DISTINCT p1.email\\nFROM Person p1 INNER JOIN person p2 ON p1.email = p2.email AND p1.id <> p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539583,
                "title": "mysql-easy-solution",
                "content": "```\\nselect email from \\n    person \\n    group by email\\n    having count(id)>1\\n```",
                "solutionTags": [],
                "code": "```\\nselect email from \\n    person \\n    group by email\\n    having count(id)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2412013,
                "title": "mysql-easy",
                "content": "\\tselect email from Person group by email having count(*)>1",
                "solutionTags": [],
                "code": "\\tselect email from Person group by email having count(*)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2115544,
                "title": "one-line-solution-easy",
                "content": "**Duplicate Emails Solution :**\\n--------------------------------\\n**In MySQL**\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY 1 \\n            HAVING COUNT(1) > 1\\n```\\n\\n**In Oracle**\\n```\\n# Write your MySQL query statement below\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY email \\n            HAVING COUNT(email) > 1 \\n```\\n\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY 1 \\n            HAVING COUNT(1) > 1\\n```\n```\\n# Write your MySQL query statement below\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY email \\n            HAVING COUNT(email) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021517,
                "title": "easy-to-understand-solution",
                "content": "```\\nselect distinct(u1.email) as Email\\nfrom Person u1,Person u2\\nwhere u1.email=u2.email and u1.id!=u2.id;\\n```\\n\\n**Please Upvote to keep me motivated  :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct(u1.email) as Email\\nfrom Person u1,Person u2\\nwhere u1.email=u2.email and u1.id!=u2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786364,
                "title": "faster-than-94-47-of-the-submissions",
                "content": "\\n```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744478,
                "title": "simple-solution-for-182-duplicate-emails-using-having-and-group-by",
                "content": "```\\nselect email as Email \\nfrom person\\ngroup by email\\nhaving count(email)>1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as Email \\nfrom person\\ngroup by email\\nhaving count(email)>1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597376,
                "title": "mysql-with-explaination",
                "content": "```\\nselect email from person\\ngroup by email\\nhaving count(email) > 1;\\n```\\n\\nHere we have use group by clause which will group all the repeating and non-repeating emails disticnctly and then applying having clause in combination with aggregate function count.",
                "solutionTags": [],
                "code": "```\\nselect email from person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513698,
                "title": "ms-sql",
                "content": "#### Question\\n```\\n182. Duplicate Emails\\n\\nSQL Schema\\nTable: Person\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Email       | varchar |\\n+-------------+---------+\\nId is the primary key column for this table.\\nEach row of this table contains an email. The emails will not contain uppercase letters.\\n \\n\\nWrite an SQL query to report all the duplicate emails.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nPerson table:\\n+----+---------+\\n| Id | Email   |\\n+----+---------+\\n| 1  | a@b.com |\\n| 2  | c@d.com |\\n| 3  | a@b.com |\\n+----+---------+\\nOutput: \\n+---------+\\n| Email   |\\n+---------+\\n| a@b.com |\\n+---------+\\nExplanation: a@b.com is repeated two times.\\n```\\n\\n#### Answer\\n```SQL\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(*) > 1",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n182. Duplicate Emails\\n\\nSQL Schema\\nTable: Person\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Email       | varchar |\\n+-------------+---------+\\nId is the primary key column for this table.\\nEach row of this table contains an email. The emails will not contain uppercase letters.\\n \\n\\nWrite an SQL query to report all the duplicate emails.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nPerson table:\\n+----+---------+\\n| Id | Email   |\\n+----+---------+\\n| 1  | a@b.com |\\n| 2  | c@d.com |\\n| 3  | a@b.com |\\n+----+---------+\\nOutput: \\n+---------+\\n| Email   |\\n+---------+\\n| a@b.com |\\n+---------+\\nExplanation: a@b.com is repeated two times.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1510657,
                "title": "duplicate-emails-mssql-server",
                "content": "select \\nEmail\\nfrom Person\\ngroup by Email\\nhaving count(Email) > 1\\norder by Email asc",
                "solutionTags": [],
                "code": "select \\nEmail\\nfrom Person\\ngroup by Email\\nhaving count(Email) > 1\\norder by Email asc",
                "codeTag": "Unknown"
            },
            {
                "id": 1437686,
                "title": "very-simple-mysql",
                "content": "```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342332,
                "title": "simple-solution-with-group-by-and-having",
                "content": "select email from person \\ngroup by email having count(email) > 1;",
                "solutionTags": [],
                "code": "select email from person \\ngroup by email having count(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1175726,
                "title": "simple-sql-query",
                "content": "Here,\\nCheck if Ids are not equal and if email ids are equal, so the are duplicates !\\n\\n```\\nSELECT DISTINCT p1.Email\\nfrom Person p1,Person p2\\nwhere p1.Id <> p2.Id \\nand p1.Email = p2.Email\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT p1.Email\\nfrom Person p1,Person p2\\nwhere p1.Id <> p2.Id \\nand p1.Email = p2.Email\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1083314,
                "title": "using-having-clause",
                "content": "```\\nSelect Email from Person\\nGroup by Email\\nHaving count(*) > 1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSelect Email from Person\\nGroup by Email\\nHaving count(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069005,
                "title": "i-believe-simple-and-human-readable-answer-is-the-best",
                "content": "SELECT Email\\nFROM PERSON\\nGROUP BY EMAIL\\nHAVING COUNT(EMAIL) > 1",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM PERSON\\nGROUP BY EMAIL\\nHAVING COUNT(EMAIL) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 912151,
                "title": "mysql-use-group-by-and-count",
                "content": "```\\nSELECT email from Person GROUP by email HAVING COUNT(email) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email from Person GROUP by email HAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745392,
                "title": "mysql-using-group-by",
                "content": "If you found the solution helpful, kindly upvote :)\\n\\n```\\n# Write your MySQL query statement below\\nSELECT email FROM person group by email having count(email)>1; \\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email FROM person group by email having count(email)>1; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 621389,
                "title": "simplest-question-on-leetcode",
                "content": "select email from person group by email having(count(id)>1)",
                "solutionTags": [],
                "code": "select email from person group by email having(count(id)>1)",
                "codeTag": "Unknown"
            },
            {
                "id": 488546,
                "title": "faster-than-99-36-of-ms-sql-server",
                "content": "SELECT Email FROM Person\\nGROUP BY Email\\nHaving count(Email)>1",
                "solutionTags": [],
                "code": "SELECT Email FROM Person\\nGROUP BY Email\\nHaving count(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 53538,
                "title": "i-am-a-newbie-on-sql-share-my-solution-no-having-no-join",
                "content": "```\\nSELECT CountTable.Email FROM (\\nSELECT Person.Email,COUNT(Person.Email) AS CountNum\\n\\tFROM Person\\n\\tGROUP BY Person.Email\\n) AS CountTable WHERE CountTable.CountNum>1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT CountTable.Email FROM (\\nSELECT Person.Email,COUNT(Person.Email) AS CountNum\\n\\tFROM Person\\n\\tGROUP BY Person.Email\\n) AS CountTable WHERE CountTable.CountNum>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53556,
                "title": "min-and-max-a-different-way-to-find-duplicate",
                "content": "Just for sharing. It can also find the `duplicate` emails.\\n\\n    SELECT email \\n    FROM (  SELECT email, MIN(id) minid, MAX(id) maxid\\n            FROM Person \\n            GROUP by email ) minmax\\n    WHERE minid <> maxid\\nIf change the where condition, we can get the `unique` ones.\\n\\n    WHERE minid = maxid",
                "solutionTags": [],
                "code": "Just for sharing. It can also find the `duplicate` emails.\\n\\n    SELECT email \\n    FROM (  SELECT email, MIN(id) minid, MAX(id) maxid\\n            FROM Person \\n            GROUP by email ) minmax\\n    WHERE minid <> maxid\\nIf change the where condition, we can get the `unique` ones.\\n\\n    WHERE minid = maxid",
                "codeTag": "Unknown"
            },
            {
                "id": 4043257,
                "title": "extracting-duplicate-rows-from-a-dataframe-object-and-returning-these-rows-in-a-new-dataframe",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires extracting rows from the person DataFrame that have duplicate email addresses and returning these rows in a new DataFrame. The intuition is to use the .duplicated() method to identify rows with duplicate email addresses and then create a new DataFrame containing these rows.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use the .duplicated() method with keep=\\'first\\' to identify rows with duplicate email addresses while keeping the first occurrence.\\n- Create a new DataFrame, duplicate_df, by filtering the rows from the person DataFrame using the boolean result from the .duplicated() operation.\\nRename the \\'email\\' column in the duplicate_df DataFrame to \\'Email\\'.\\n- Use .drop_duplicates(subset=[\\'Email\\']) to remove duplicate rows based on the \\'Email\\' column and keep only one instance of each duplicate email address.\\n- Return the resulting output_df DataFrame containing one instance of each duplicate email address.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of rows in the person DataFrame. The time complexity is dominated by the operations to identify duplicates and filter the DataFrame, which is proportional to the number of rows in the person DataFrame.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n\\n- Space complexity: O(k), where k is the number of unique duplicate email addresses in the person DataFrame. The space complexity is determined by the space required to store the duplicate_df and output_df DataFrames. Both DataFrames will have the same number of rows as the number of duplicate email addresses. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\'\\'\\'\\n    @param: DataFrame object named person \\n    @return: DataFrame object with 1 column label Email and each row is a repeated email \\n    \\'\\'\\'\\n\\n    # The .duplicated() method in pandas returns a Boolean Series that indicates whether each row in a DataFrame is a duplicate of a previous row. The resulting Series has the same number of rows as the original DataFrame, where each element is True if the corresponding row is a duplicate and False otherwise.\\n\\n\\n    # output_df = pd.DataFrame(columns=[\\'Email\\']) # Initialise an empty dataframe object \\n    duplicate_df = person[person.duplicated(subset=[\\'email\\'], keep= \\'first\\')] # Create a new dataframe with rows from the person DF\\n    # print(type(duplicate_df))\\n\\n    # extract the required columns \\n    output_df = duplicate_df.rename(columns={\\'email\\':\\'Email\\'})[[\\'Email\\']].drop_duplicates(subset=[\\'Email\\'])\\n    return output_df\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\'\\'\\'\\n    @param: DataFrame object named person \\n    @return: DataFrame object with 1 column label Email and each row is a repeated email \\n    \\'\\'\\'\\n\\n    # The .duplicated() method in pandas returns a Boolean Series that indicates whether each row in a DataFrame is a duplicate of a previous row. The resulting Series has the same number of rows as the original DataFrame, where each element is True if the corresponding row is a duplicate and False otherwise.\\n\\n\\n    # output_df = pd.DataFrame(columns=[\\'Email\\']) # Initialise an empty dataframe object \\n    duplicate_df = person[person.duplicated(subset=[\\'email\\'], keep= \\'first\\')] # Create a new dataframe with rows from the person DF\\n    # print(type(duplicate_df))\\n\\n    # extract the required columns \\n    output_df = duplicate_df.rename(columns={\\'email\\':\\'Email\\'})[[\\'Email\\']].drop_duplicates(subset=[\\'Email\\'])\\n    return output_df\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3820302,
                "title": "duplicate-emails-mysql-solution-code",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550320,
                "title": "easy-sql-code-group-by-having-clause-used",
                "content": "# Intuition\\nSimply **GROUP BY-HAVING** Clause is used.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506152,
                "title": "mysql-mega-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDon\\'t forget to write the commands in order\\n\\n# Code\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336670,
                "title": "duplicate-emails",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(*)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281912,
                "title": "sql-simple-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct p1.email as Email from person as p1 join person as p2 \\nwhere p1.email=p2.email and p1.id!=p2.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct p1.email as Email from person as p1 join person as p2 \\nwhere p1.email=p2.email and p1.id!=p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167019,
                "title": "easiest-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect email as Email from Person group by email having count(email)>=2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect email as Email from Person group by email having count(email)>=2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3104694,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*)>1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2951670,
                "title": "easiest-way-using-self-join-and-groupby",
                "content": "**UPVOTE IF U FOUND IT HELPFUL :-)**\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct(p1.email) as Email\\nfrom Person p1,Person p2\\nwhere p1.email=p2.email and p1.id<>p2.id\\n```\\n\\n```\\nselect email as Email from Person\\nGroup by email\\nhaving count(email)>1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(p1.email) as Email\\nfrom Person p1,Person p2\\nwhere p1.email=p2.email and p1.id<>p2.id\\n```\n```\\nselect email as Email from Person\\nGroup by email\\nhaving count(email)>1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2813349,
                "title": "93-faster",
                "content": "![image](https://assets.leetcode.com/users/images/e946c37a-0515-4063-bd50-d6a0605dd695_1668416616.1929512.png)\\n\\n\\n```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2660507,
                "title": "simple-self-join",
                "content": "```\\nselect Distinct a.email as Email\\nfrom \\nPerson as a,\\nPerson as  b\\nwhere \\na.id <> b.id\\nand\\na.email = b.email\\n",
                "solutionTags": [],
                "code": "```\\nselect Distinct a.email as Email\\nfrom \\nPerson as a,\\nPerson as  b\\nwhere \\na.id <> b.id\\nand\\na.email = b.email\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2616318,
                "title": "easy-count-solution-with-explanation-2-approaches",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING  count(*) > 1;\\n```\\n\\nFor more detail please ref:\\n*(Note: You can bookmark it for your future ref)*\\nhttps://leet-codes.blogspot.com/2022/09/182-duplicate-emails.html",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING  count(*) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588859,
                "title": "using-group-by-clause-easy-one",
                "content": "Select email from Person\\ngroup by email\\nhaving count(email)>1;",
                "solutionTags": [],
                "code": "Select email from Person\\ngroup by email\\nhaving count(email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2563211,
                "title": "mysql-better-than-100-memory-and-58-time",
                "content": "SELECT email FROM Person GROUP BY email having count(email)>1",
                "solutionTags": [],
                "code": "SELECT email FROM Person GROUP BY email having count(email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2562037,
                "title": "simple-soln-using-inner-join",
                "content": "select distinct p1.email as Email from person p1 inner join person p2\\nwhere p1.email= p2.email and p1.id<>p2.id;",
                "solutionTags": [],
                "code": "select distinct p1.email as Email from person p1 inner join person p2\\nwhere p1.email= p2.email and p1.id<>p2.id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2558738,
                "title": "mysql-fundamental-approach",
                "content": "\\tSELECT Email FROM\\n    (SELECT Email, COUNT(Email) AS c\\n    FROM Person\\n    GROUP BY Email) AS Tem\\n    WHERE c > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT Email FROM\\n    (SELECT Email, COUNT(Email) AS c\\n    FROM Person\\n    GROUP BY Email) AS Tem\\n    WHERE c > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2556848,
                "title": "simplest-solution-mysql-having-clause",
                "content": "select email from Person group by email\\nhaving count(*) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select email from Person group by email\\nhaving count(*) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2545091,
                "title": "sql-solution-using-window-function",
                "content": "```\\nselect email as \"Email\" from(select distinct email, count(p.email) over(partition by p.email) as \"count\" from person p) x where x.count>1\\n```\\n\\nPlease upvote!!!",
                "solutionTags": [],
                "code": "```\\nselect email as \"Email\" from(select distinct email, count(p.email) over(partition by p.email) as \"count\" from person p) x where x.count>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541900,
                "title": "ms-sql-solution",
                "content": "select email from Person group by email having count(*) > 1;\\n",
                "solutionTags": [],
                "code": "select email from Person group by email having count(*) > 1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2537096,
                "title": "mysql-solution-simple",
                "content": "```\\n# Write your MySQL query statement below\\n    #Using group by and having\\n    SELECT email AS \\'Email\\'\\n    FROM Person\\n    GROUP BY email\\n    HAVING COUNT(email)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n    #Using group by and having\\n    SELECT email AS \\'Email\\'\\n    FROM Person\\n    GROUP BY email\\n    HAVING COUNT(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528677,
                "title": "mysql-easy-solution-group-by",
                "content": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2514308,
                "title": "mysql-duplicate-emails-sol-324-ms",
                "content": "```\\nselect email Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505270,
                "title": "easy-mysql-short-and-concise-check-it",
                "content": "```\\nselect email\\nfrom person \\ngroup by email\\nhaving count(*) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email\\nfrom person \\ngroup by email\\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2476510,
                "title": "with-explanation-comments-time-323-ms-85-63-space-0b-100-00",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\n#select all elements from the coulmn \"Email\"\\nSELECT Email\\n#from the Person table\\nFROM Person\\n#groupped by the Email field\\nGROUP BY Email\\n#having a value more than 1\\nHAVING COUNT(*) > 1;\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\n#select all elements from the coulmn \"Email\"\\nSELECT Email\\n#from the Person table\\nFROM Person\\n#groupped by the Email field\\nGROUP BY Email\\n#having a value more than 1\\nHAVING COUNT(*) > 1;\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2468168,
                "title": "mysql-solution-easy-understanding-group-by-having",
                "content": "```\\nselect email as \\'Email\\'\\nfrom Person \\nGROUP BY email\\nHAVING COUNT(email) > 1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as \\'Email\\'\\nfrom Person \\nGROUP BY email\\nHAVING COUNT(email) > 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456284,
                "title": "faster-than-70-89-using-having-and-count-easy-to-understand",
                "content": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2386383,
                "title": "mysql-3-ways-super-easy",
                "content": "* **SELF JOIN**\\n```sql\\nSELECT DISTINCT A.email FROM Person A,Person B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```\\n\\n* **Having and Group By Clause**\\n```sql\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1;\\n```\\n\\n* **Having, Group By, Temperoary Table**\\n```sql\\nSELECT email FROM (\\n    SElECT email,count(email) as EmailCount FROM Person GROUP BY email\\n) as emailData WHERE EmailCount > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT DISTINCT A.email FROM Person A,Person B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```\n```sql\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1;\\n```\n```sql\\nSELECT email FROM (\\n    SElECT email,count(email) as EmailCount FROM Person GROUP BY email\\n) as emailData WHERE EmailCount > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356926,
                "title": "can-anyone-explain-why-group-by-is-needed",
                "content": "My initial code was \\n\\n```\\nselect Email\\nfrom Person\\nhaving count(email) > 1\\n```\\nbut this only passed the test case and did not pass the submission. The submission test case wanted me to return an empty value since there are no duplicates. After looking at the discussion board, the top solution is:\\n\\n```\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*) > 1\\n```\\nThis does pass the submission test case but I dont understand why. \\n\\nI am trying to fully understand so maybe I am thinking to hard about it but;\\nCan anyone explain why the \\'Group By\\' allows the query to return an empty value?\\n\\n",
                "solutionTags": [],
                "code": "```\\nselect Email\\nfrom Person\\nhaving count(email) > 1\\n```\n```\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356055,
                "title": "solution-you-thought-first",
                "content": "```\\nSELECT EMAIL FROM PERSON\\nGROUP BY EMAIL \\nHAVING COUNT(EMAIL) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT EMAIL FROM PERSON\\nGROUP BY EMAIL \\nHAVING COUNT(EMAIL) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2337509,
                "title": "using-having-and-group-by",
                "content": "```\\n# Write your MySQL query statement below\\n\\nSELECT email FROM Person \\nGROUP BY email \\nHAVING COUNT(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT email FROM Person \\nGROUP BY email \\nHAVING COUNT(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329912,
                "title": "simple-group-by-with-having",
                "content": "select email from person group by email having count(*)>=2",
                "solutionTags": [],
                "code": "select email from person group by email having count(*)>=2",
                "codeTag": "Unknown"
            },
            {
                "id": 2319719,
                "title": "simple-mysql-solution-easy-to-understand-group-by",
                "content": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270479,
                "title": "faster-than-95-simple-mysql-solution",
                "content": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251545,
                "title": "without-group-by",
                "content": "\\'\\'\\'\\nselect distinct p1.email from person as p1,person as p2 where p1.email=p2.email and p1.id!=p2.id;\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nselect distinct p1.email from person as p1,person as p2 where p1.email=p2.email and p1.id!=p2.id;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2247548,
                "title": "one-line-oracle-solution-80-efficient",
                "content": "select distinct a.email from Person a inner join Person b on a.email=b.email where a.id<>b.id",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select distinct a.email from Person a inner join Person b on a.email=b.email where a.id<>b.id",
                "codeTag": "Unknown"
            },
            {
                "id": 2179813,
                "title": "easy-solution-using-count-and-group-by",
                "content": "select email as Email\\nfrom Person \\ngroup by 1\\nhaving count(1)>1",
                "solutionTags": [],
                "code": "select email as Email\\nfrom Person \\ngroup by 1\\nhaving count(1)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2146501,
                "title": "simple-to-understand-solution",
                "content": "select email from person\\ngroup by email\\nhaving count(email)>1;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select email from person\\ngroup by email\\nhaving count(email)>1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2135537,
                "title": "mssql-grop-by-having",
                "content": "```\\nselect email\\nfrom Person\\ngroup by email\\nhaving count(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect email\\nfrom Person\\ngroup by email\\nhaving count(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105397,
                "title": "mysql-easiest-solution",
                "content": "**Pls Upvote if you lke the Solution!**\\n```\\nSELECT DISTINCT(p1.email) \\nFROM Person p1 JOIN Person p2 \\nON p1.email=p2.email AND p1.id<>p2.id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Pls Upvote if you lke the Solution!**\\n```\\nSELECT DISTINCT(p1.email) \\nFROM Person p1 JOIN Person p2 \\nON p1.email=p2.email AND p1.id<>p2.id",
                "codeTag": "Unknown"
            },
            {
                "id": 2095226,
                "title": "sql-easy-simple-solution",
                "content": "**All suggestions are welcome.\\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n\\n```\\nselect distinct p1.email from Person p1, Person  p2 where p1.email=p2.email and p1.id > p2.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct p1.email from Person p1, Person  p2 where p1.email=p2.email and p1.id > p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2092836,
                "title": "easy-solution",
                "content": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089925,
                "title": "simple-mysql-query-based-on-delete-duplicate-emails-192",
                "content": "[Solution](https://leetcode.com/problems/delete-duplicate-emails/discuss/55553/Simple-Solution) using which this one was developed\\n```\\nselect distinct p1.email\\nFROM Person p1, Person p2\\nWHERE p1.Email = p2.Email AND\\np1.Id > p2.Id\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct p1.email\\nFROM Person p1, Person p2\\nWHERE p1.Email = p2.Email AND\\np1.Id > p2.Id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058479,
                "title": "simplest-answer-dont-search-for-complex-one",
                "content": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email) > 1 ;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email) > 1 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2005850,
                "title": "mysql-100-less-memory",
                "content": "Select Email\\nFrom Person\\nGroup By Email\\nHaving Count(Email) > 1",
                "solutionTags": [],
                "code": "Select Email\\nFrom Person\\nGroup By Email\\nHaving Count(Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1994343,
                "title": "extremely-simple-and-fast-solution",
                "content": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING  COUNT(email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING  COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986789,
                "title": "easy-sql-solution",
                "content": "```\\nSelect DISTINCT email AS \\'Email\\'\\nFROM Person p\\nWHERE email IN (SELECT email FROM Person p1 WHERE p.id <> p1.id)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/be4a4d08-73c1-4d66-840a-f0302643c79e_1651073127.4433901.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect DISTINCT email AS \\'Email\\'\\nFROM Person p\\nWHERE email IN (SELECT email FROM Person p1 WHERE p.id <> p1.id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973590,
                "title": "used-distinct-and-select-2-tables-71-72-time-100-00-space",
                "content": "```\\n# Write your MySQL query statement below\\nselect DISTINCT p.email as email from Person P \\nwhere P.email in (select email from Person P2 where p2.id <> p.id);  \\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect DISTINCT p.email as email from Person P \\nwhere P.email in (select email from Person P2 where p2.id <> p.id);  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969130,
                "title": "mysql-easy-implementation",
                "content": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960555,
                "title": "mysql-93-faster-one-line-group-by",
                "content": "```\\nselect email from Person group by 1 having count(id) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nselect email from Person group by 1 having count(id) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959553,
                "title": "mysql-simple-solution-faster-than-93",
                "content": "```\\n# Write your MySQL query statement below\\nselect email from person group by email having count(email) > 1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from person group by email having count(email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1911436,
                "title": "ms-sql",
                "content": "Runtime: 756 ms, faster than 96.81% of MS SQL Server online submissions for Duplicate Emails.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Duplicate Emails.\\n```\\nwith cte as\\n(SELECT email, count(id) cnt\\nfrom Person\\ngroup by email)\\nselect email from cte\\nwhere cnt > 1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nwith cte as\\n(SELECT email, count(id) cnt\\nfrom Person\\ngroup by email)\\nselect email from cte\\nwhere cnt > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891919,
                "title": "ms-sql-server-solution",
                "content": "Runtime: 1059 ms, faster than 59.13% of MS SQL Server online submissions for Duplicate Emails.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Duplicate Emails.\\n\\n```\\n/* Write your T-SQL query statement below */\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884959,
                "title": "simple-sql-solution-using-2-approaches-self-join-and-group-by",
                "content": "```\\n# Using Group by and having clause\\nselect Email from person group by email having count(*) > 1\\n\\n# Using self join\\nselect distinct p1.Email from person p1 join person p2\\non p1.email = p2.email and p1.id != p2.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Using Group by and having clause\\nselect Email from person group by email having count(*) > 1\\n\\n# Using self join\\nselect distinct p1.Email from person p1 join person p2\\non p1.email = p2.email and p1.id != p2.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882698,
                "title": "faster-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect distinct(email) from Person where email in (select email from Person  group by email having count(email)>1)\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(email) from Person where email in (select email from Person  group by email having count(email)>1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849980,
                "title": "beats-88-2-runtime-and-beats-100-memory-utilization",
                "content": "select distinct(p.email) from person p where p.email in (select s.email from person s where s.id != p.id)",
                "solutionTags": [],
                "code": "select distinct(p.email) from person p where p.email in (select s.email from person s where s.id != p.id)",
                "codeTag": "Unknown"
            },
            {
                "id": 1790478,
                "title": "easy-solution",
                "content": "select email from person group by email having count(email) > 1;",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "select email from person group by email having count(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1720147,
                "title": "mysql-solution-using-having",
                "content": "```\\nSELECT email\\nFROM   person\\nGROUP  BY email\\nHAVING Count(*) > 1 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email\\nFROM   person\\nGROUP  BY email\\nHAVING Count(*) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710053,
                "title": "sql-count",
                "content": "select email\\nfrom person\\ngroup by email\\nhaving count(email)>1;",
                "solutionTags": [],
                "code": "select email\\nfrom person\\ngroup by email\\nhaving count(email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1681421,
                "title": "mysql-simple-solution",
                "content": "```\\nselect distinct p1.email as \\'Email\\' from Person p1, Person p2\\nwhere p1.id != p2.id and p1.email = p2.email;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct p1.email as \\'Email\\' from Person p1, Person p2\\nwhere p1.id != p2.id and p1.email = p2.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1645168,
                "title": "easy-solution-without-using-group-by",
                "content": "```\\nSELECT DISTINCT A.email\\nFROM Person AS A, Person AS B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT A.email\\nFROM Person AS A, Person AS B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631615,
                "title": "mysql-easy",
                "content": "```\\nSelect email As Email\\nFrom Person\\nGroup By email\\nHaving Count(*) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect email As Email\\nFrom Person\\nGroup By email\\nHaving Count(*) > 1\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575016,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576972,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1571389,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1568481,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1570505,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574508,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1573320,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576741,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576150,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575521,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575016,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576972,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1571389,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1568481,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1570505,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574508,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1573320,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576741,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576150,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575521,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574345,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1576215,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1575485,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1574455,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2076978,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2064868,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2022928,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1964590,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1896547,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1893963,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1881442,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1845451,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1839695,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1812094,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1808987,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1803586,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1802766,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1797654,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1797262,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1792261,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1783597,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1777337,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1776030,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1774127,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1751993,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1731142,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1724819,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716892,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716838,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716295,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            }
        ]
    },
    {
        "title": "Expression Add Operators",
        "question_content": "<p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>\n\n<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;, target = 6\n<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]\n<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;232&quot;, target = 8\n<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]\n<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 71895,
                "title": "java-standard-backtrace-ac-solutoin-short-and-clear",
                "content": "This problem has a lot of edge cases to be considered:\\n\\n1. overflow: we use a long type once it is larger than Integer.MAX_VALUE or minimum, we get over it. \\n2. 0 sequence: because we can't have numbers with multiple digits started with zero, we have to deal with it too.\\n3. a little trick is that we should save the value that is to be multiplied in the next recursion.\\n\\n---\\n\\n    public class Solution {\\n        public List<String> addOperators(String num, int target) {\\n            List<String> rst = new ArrayList<String>();\\n            if(num == null || num.length() == 0) return rst;\\n            helper(rst, \"\", num, target, 0, 0, 0);\\n            return rst;\\n        }\\n        public void helper(List<String> rst, String path, String num, int target, int pos, long eval, long multed){\\n            if(pos == num.length()){\\n                if(target == eval)\\n                    rst.add(path);\\n                return;\\n            }\\n            for(int i = pos; i < num.length(); i++){\\n                if(i != pos && num.charAt(pos) == '0') break;\\n                long cur = Long.parseLong(num.substring(pos, i + 1));\\n                if(pos == 0){\\n                    helper(rst, path + cur, num, target, i + 1, cur, cur);\\n                }\\n                else{\\n                    helper(rst, path + \"+\" + cur, num, target, i + 1, eval + cur , cur);\\n                    \\n                    helper(rst, path + \"-\" + cur, num, target, i + 1, eval -cur, -cur);\\n                    \\n                    helper(rst, path + \"*\" + cur, num, target, i + 1, eval - multed + multed * cur, multed * cur );\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> addOperators(String num, int target) {\\n            List<String> rst = new ArrayList<String>();\\n            if(num == null || num.length() == 0) return rst;\\n            helper(rst, \"\", num, target, 0, 0, 0);\\n            return rst;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 572099,
                "title": "c-java-python-backtracking-evaluate-on-the-fly-clean-concise",
                "content": "**\\u2714\\uFE0F Approach 1: Backtracking & Evaluate Expression**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- Then write a function `evaluate(string expression)` to evaluate a string expression, if the evaluated result is equal to `target`, we add that expression string to our answer.\\n<details>\\n<summary>Click to see the implementation!</summary>\\n\\n<iframe src=\"https://leetcode.com/playground/6KRPJGSj/shared\" frameBorder=\"0\" width=\"100%\" height=\"1200\"></iframe>\\n</details>\\n\\n---\\n\\n**\\u2714\\uFE0F Approach 2: Backtracking & Evaluate on the fly (Best Solution)**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- There is no priority since there are no parentheses `(` and `)` in our `s` string, so we can evaluate the expression on the fly to save time.\\n- There are total 3 operators:\\n\\t- `+` operator: `newResult = resSoFar + num`\\n\\t- `-` operator: `newResult = resSoFar - num`.\\n\\t- `*` operator: We need to keep the `prevNum` so that to calculate `newResult` we need to minus `prevNum` then plus with `prevNum * num`. So `newResult = resSoFar - prevNum + prevNum * num`.\\n<iframe src=\"https://leetcode.com/playground/J8AiipGK/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Approach 1: Backtracking & Evaluate Expression**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- Then write a function `evaluate(string expression)` to evaluate a string expression, if the evaluated result is equal to `target`, we add that expression string to our answer.\\n<details>\\n<summary>Click to see the implementation!</summary>\\n\\n<iframe src=\"https://leetcode.com/playground/6KRPJGSj/shared\" frameBorder=\"0\" width=\"100%\" height=\"1200\"></iframe>\\n</details>\\n\\n---\\n\\n**\\u2714\\uFE0F Approach 2: Backtracking & Evaluate on the fly (Best Solution)**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- There is no priority since there are no parentheses `(` and `)` in our `s` string, so we can evaluate the expression on the fly to save time.\\n- There are total 3 operators:\\n\\t- `+` operator: `newResult = resSoFar + num`\\n\\t- `-` operator: `newResult = resSoFar - num`.\\n\\t- `*` operator: We need to keep the `prevNum` so that to calculate `newResult` we need to minus `prevNum` then plus with `prevNum * num`. So `newResult = resSoFar - prevNum + prevNum * num`.\\n<iframe src=\"https://leetcode.com/playground/J8AiipGK/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 71968,
                "title": "clean-python-dfs-with-comments",
                "content": "dfs() parameters:  \\nnum:   remaining num string  \\ntemp:  temporally string with operators added  \\ncur:     current result of \"temp\" string  \\nlast:     last multiply-level number in \"temp\". if next operator is \"multiply\", \"cur\" and \"last\" will be updated  \\nres:      result to return\\n\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "dfs() parameters:  \\nnum:   remaining num string  \\ntemp:  temporally string with operators added  \\ncur:     current result of \"temp\" string  \\nlast:     last multiply-level number in \"temp\". if next operator is \"multiply\", \"cur\" and \"last\" will be updated  \\nres:      result to return\\n\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)",
                "codeTag": "Python3"
            },
            {
                "id": 71898,
                "title": "17-lines-solution-dfs-c",
                "content": "    class Solution {\\n    private:\\n        // cur: {string} expression generated so far.\\n        // pos: {int}    current visiting position of num.\\n        // cv:  {long}   cumulative value so far.\\n        // pv:  {long}   previous operand value.\\n        // op:  {char}   previous operator used.\\n        void dfs(std::vector<string>& res, const string& num, const int target, string cur, int pos, const long cv, const long pv, const char op) {\\n            if (pos == num.size() && cv == target) {\\n                res.push_back(cur);\\n            } else {\\n                for (int i=pos+1; i<=num.size(); i++) {\\n                    string t = num.substr(pos, i-pos);\\n                    long now = stol(t);\\n                    if (to_string(now).size() != t.size()) continue;\\n                    dfs(res, num, target, cur+'+'+t, i, cv+now, now, '+');\\n                    dfs(res, num, target, cur+'-'+t, i, cv-now, now, '-');\\n                    dfs(res, num, target, cur+'*'+t, i, (op == '-') ? cv+pv - pv*now : ((op == '+') ? cv-pv + pv*now : pv*now), pv*now, op);\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> res;\\n            if (num.empty()) return res;\\n            for (int i=1; i<=num.size(); i++) {\\n                string s = num.substr(0, i);\\n                long cur = stol(s);\\n                if (to_string(cur).size() != s.size()) continue;\\n                dfs(res, num, target, s, i, cur, cur, '#');         // no operator defined.\\n            }\\n    \\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        // cur: {string}",
                "codeTag": "Java"
            },
            {
                "id": 71897,
                "title": "java-ac-solution-19ms-beat-100-00",
                "content": "I am surprised that it beats 100.00% other solutions, so i have to share this.\\n\\n    void dfs(List<String> ret, char[] path, int len, long left, long cur, char[] digits, int pos, int target) {\\n        if (pos == digits.length) {\\n            if (left + cur == target) ret.add(new String(path, 0, len));\\n            return;\\n        }\\n        long n = 0;\\n        int j = len + 1;\\n        for (int i = pos; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[j++] = digits[i];\\n            path[len] = '+';\\n            dfs(ret, path, j, left + cur, n, digits, i + 1, target);\\n            path[len] = '-';\\n            dfs(ret, path, j, left + cur, -n, digits, i + 1, target);\\n            path[len] = '*';\\n            dfs(ret, path, j, left, cur * n, digits, i + 1, target);\\n            if (digits[pos] == '0') break; \\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ret = new LinkedList<>();\\n        if (num.length() == 0) return ret;\\n        char[] path = new char[num.length() * 2 - 1];\\n        char[] digits = num.toCharArray();\\n        long n = 0;\\n        for (int i = 0; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[i] = digits[i];\\n            dfs(ret, path, i + 1, 0, n, digits, i + 1, target);\\n            if (n == 0) break;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "I am surprised that it beats 100.00% other solutions, so i have to share this.\\n\\n    void dfs(List<String> ret, char[] path, int len, long left, long cur, char[] digits, int pos, int target) {\\n        if (pos == digits.length) {\\n            if (left + cur == target) ret.add(new String(path, 0, len));\\n            return;\\n        }\\n        long n = 0;\\n        int j = len + 1;\\n        for (int i = pos; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[j++] = digits[i];\\n            path[len] = '+';\\n            dfs(ret, path, j, left + cur, n, digits, i + 1, target);\\n            path[len] = '-';\\n            dfs(ret, path, j, left + cur, -n, digits, i + 1, target);\\n            path[len] = '*';\\n            dfs(ret, path, j, left, cur * n, digits, i + 1, target);\\n            if (digits[pos] == '0') break; \\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ret = new LinkedList<>();\\n        if (num.length() == 0) return ret;\\n        char[] path = new char[num.length() * 2 - 1];\\n        char[] digits = num.toCharArray();\\n        long n = 0;\\n        for (int i = 0; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[i] = digits[i];\\n            dfs(ret, path, i + 1, 0, n, digits, i + 1, target);\\n            if (n == 0) break;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1470156,
                "title": "python-dfs-with-stack-of-monomials-explained",
                "content": "Quite diffucult problem, which is similar to Basic Calculators problem (**0224**, **0227**). Let us consider `dfs` with the following parameters:\\n\\n1. `idx` is the index of current element we traverse in `num`.\\n2. `path` is the string built so far.\\n3. `value` is current value of created path.\\n4. `last` is the value of the last monomial.\\n\\nHere we use idea of stack of monomials: imagine, that we have expression `1*2 + 3*4*5`, then we have the following steps: `[1], [2], [2, 3], [2,12], [2,60]`: each time we have `+` or `-` we add one element to the end of stack; each time we have `*` we update the last element in stack.\\n\\nThen when we traverse our string, we can have several options: each time we need to create `tmp = int(num[idx: i])` and make sure that this is valid number: `tmp` will be the next number we are going to use. Then if `last == None`, we have only one option. If `last != None`, we can have `3` options which symbol we can take: if it is `+` or `-`, we just update `value` and sign of `tmp`. If it is multiplication, we need to update both `value` and `last` should be multiplied by `tmp`.\\n\\n#### Complexity\\nIt is potentially `O(4^n * n)`, because on each step we have `4` options: `+`, `-`, `*` or no sign. Space complexity potentially the same.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def addOperators(self, num, target):\\n        def dfs(idx, path, value, last):            \\n            if idx == n and value == target:\\n                ans.append(path)\\n            \\n            for i in range(idx + 1, n + 1):\\n                tmp = int(num[idx: i])\\n                if i == idx + 1 or (i > idx + 1 and num[idx] != \"0\"):\\n                    if last is None :\\n                        dfs(i, num[idx: i], tmp, tmp)\\n                    else:\\n                        dfs(i, path + \\'+\\' + num[idx: i], value + tmp, tmp)\\n                        dfs(i, path + \\'-\\' + num[idx: i], value - tmp, -tmp)\\n                        dfs(i, path + \\'*\\' + num[idx: i], value - last + last*tmp, last*tmp)\\n        \\n        ans, n = [], len(num)\\n        dfs(0, \"\", 0, None)\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num, target):\\n        def dfs(idx, path, value, last):            \\n            if idx == n and value == target:\\n                ans.append(path)\\n            \\n            for i in range(idx + 1, n + 1):\\n                tmp = int(num[idx: i])\\n                if i == idx + 1 or (i > idx + 1 and num[idx] != \"0\"):\\n                    if last is None :\\n                        dfs(i, num[idx: i], tmp, tmp)\\n                    else:\\n                        dfs(i, path + \\'+\\' + num[idx: i], value + tmp, tmp)\\n                        dfs(i, path + \\'-\\' + num[idx: i], value - tmp, -tmp)\\n                        dfs(i, path + \\'*\\' + num[idx: i], value - last + last*tmp, last*tmp)\\n        \\n        ans, n = [], len(num)\\n        dfs(0, \"\", 0, None)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71921,
                "title": "java-simple-solution-beats-96-56",
                "content": "Inspired by [this great solution][1]. \\n\\nWhat's different is, I use backtracking with `StringBuilder` instead of directly String addition.\\n\\nThis increase speed by `20%`.\\n\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n       \\tStringBuilder sb = new StringBuilder();\\n        dfs(res, sb, num, 0, target, 0, 0);\\n        return res;\\n        \\n    }\\n    public void dfs(List<String> res, StringBuilder sb, String num, int pos, int target, long prev, long multi) { \\n    \\tif(pos == num.length()) {\\n    \\t\\tif(target == prev) res.add(sb.toString());\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor(int i = pos; i < num.length(); i++) {\\n    \\t\\tif(num.charAt(pos) == '0' && i != pos) break;\\n    \\t\\tlong curr = Long.parseLong(num.substring(pos, i + 1));\\n    \\t\\tint len = sb.length();\\n    \\t\\tif(pos == 0) {\\n    \\t\\t\\tdfs(res, sb.append(curr), num, i + 1, target, curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t} else {\\n    \\t\\t\\tdfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/58614/java-standard-backtrace-ac-solutoin-short-and-clear",
                "solutionTags": [
                    "Java"
                ],
                "code": "Inspired by [this great solution][1]. \\n\\nWhat's different is, I use backtracking with `StringBuilder` instead of directly String addition.\\n\\nThis increase speed by `20%`.\\n\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n       \\tStringBuilder sb = new StringBuilder();\\n        dfs(res, sb, num, 0, target, 0, 0);\\n        return res;\\n        \\n    }\\n    public void dfs(List<String> res, StringBuilder sb, String num, int pos, int target, long prev, long multi) { \\n    \\tif(pos == num.length()) {\\n    \\t\\tif(target == prev) res.add(sb.toString());\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor(int i = pos; i < num.length(); i++) {\\n    \\t\\tif(num.charAt(pos) == '0' && i != pos) break;\\n    \\t\\tlong curr = Long.parseLong(num.substring(pos, i + 1));\\n    \\t\\tint len = sb.length();\\n    \\t\\tif(pos == 0) {\\n    \\t\\t\\tdfs(res, sb.append(curr), num, i + 1, target, curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t} else {\\n    \\t\\t\\tdfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/58614/java-standard-backtrace-ac-solutoin-short-and-clear",
                "codeTag": "Unknown"
            },
            {
                "id": 352605,
                "title": "explanation-and-way-to-make-it-efficient-from-134-ms-to-9-ms-to-beat-100",
                "content": "A war against each other [ String con Vs string builder vs char [] ]\\n\\nWhole code is commented well to understand;\\n\\nAll version are same, its just the usage of String , String builder and char [] to build the expression is differ. \\n\\n\\nUsing strings connectinations \\n---------------------\\n<details>\\nRuntime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\nMemory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n/**\\n * Explanation: https://leetcode.com/articles/expression-add-operators/\\n * <p>\\n * Our choices:\\n * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n * 2. we can choose only one operator between two operands\\n * <p>\\n * Our Constraints:\\n * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n * 2. We can\\'t take more operators then available in input\\n * 3. We can choose only one operator once\\n * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n * <p>\\n * Out Goal:\\n * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n * 2. if not, we discard\\n * <p>\\n * <p>\\n * Runtime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingString {\\n\\n\\n//    char ops[] = {\\'+\\', \\'-\\', \\'*\\'};\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, \"\", expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, String expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression);\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression + currentDigitsValue, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression + \"+\" + currentDigitsValue, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression + \"-\" + currentDigitsValue, result);\\n\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression + \"*\" + currentDigitsValue, result);\\n\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n\\n</details>\\n\\nUsing StringBuilder \\n---------------\\n<details>\\n\\nRuntime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\nMemory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n\\n/**\\n * Instead of using String concatenation we\\'ll use strinbuilder\\n * Runtime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n * <p>\\n * StringBuilder boost it performance from 84ms to 81ms.\\n */\\nclass AddOperatorsBacktrackingStringBuilder {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, new StringBuilder(), expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, StringBuilder expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression.toString());\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n            int len = expression.length();\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression.append(currentDigitsValue), result);\\n                expression.setLength(len); // This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression.append(\"+\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression.append(\"-\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression.append(\"*\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n</details>\\n\\n\\nUsing Char [] Array\\n-------------\\n<details>\\nRuntime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\nMemory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n/**\\n * Instead of using String concatenation Or strinbuilder, we\\'ll use char array\\n * Runtime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingCharArray {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num, target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num.charAt(i) - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n</details>\\n\\nUsing Char [] for both input and intermiddate expression\\n------------------------------------\\n\\n<details>\\n Runtime: **9 ms, faster than 99.28%** of Java online submissions for Expression Add Operators.\\n Memory Usage: 39.5 MB, less than 94.79% of Java online submissions for Expression Add Operators.\\n \\n ```\\n \\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num.toCharArray(), target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(char num[], int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length; i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num[index] == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num[i] - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n ```\\n\\n\\n<details>",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * Explanation: https://leetcode.com/articles/expression-add-operators/\\n * <p>\\n * Our choices:\\n * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n * 2. we can choose only one operator between two operands\\n * <p>\\n * Our Constraints:\\n * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n * 2. We can\\'t take more operators then available in input\\n * 3. We can choose only one operator once\\n * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n * <p>\\n * Out Goal:\\n * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n * 2. if not, we discard\\n * <p>\\n * <p>\\n * Runtime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingString {\\n\\n\\n//    char ops[] = {\\'+\\', \\'-\\', \\'*\\'};\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, \"\", expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, String expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression);\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression + currentDigitsValue, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression + \"+\" + currentDigitsValue, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression + \"-\" + currentDigitsValue, result);\\n\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression + \"*\" + currentDigitsValue, result);\\n\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n\\n\\n/**\\n * Instead of using String concatenation we\\'ll use strinbuilder\\n * Runtime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n * <p>\\n * StringBuilder boost it performance from 84ms to 81ms.\\n */\\nclass AddOperatorsBacktrackingStringBuilder {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, new StringBuilder(), expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, StringBuilder expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression.toString());\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n            int len = expression.length();\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression.append(currentDigitsValue), result);\\n                expression.setLength(len); // This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression.append(\"+\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression.append(\"-\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression.append(\"*\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n\\n/**\\n * Instead of using String concatenation Or strinbuilder, we\\'ll use char array\\n * Runtime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingCharArray {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num, target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num.charAt(i) - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n \\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num.toCharArray(), target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(char num[], int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length; i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num[index] == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num[i] - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 71971,
                "title": "accepted-c-solution",
                "content": "    void addOperators(vector<string>& result, string nums, string t, long long last, long long curVal, int target) {\\n\\t\\tif (nums.length() == 0) {\\n\\t\\t\\tif (curVal == target)\\n\\t\\t\\t\\tresult.push_back(t);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i<=nums.length(); i++) {\\n\\t\\t\\tstring num = nums.substr(0, i);\\n\\t\\t\\tif(num.length() > 1 && num[0] == '0')\\n\\t\\t\\t    return;\\n\\t\\t\\t\\n\\t\\t\\tstring nextNum = nums.substr(i);\\n\\n\\t\\t\\tif (t.length() > 0) {\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"+\" + num, stoll(num), curVal + stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"-\" + num, -stoll(num), curVal - stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"*\" + num, last * stoll(num), (curVal - last) + (last * stoll(num)), target);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t\\taddOperators(result, nextNum, num, stoll(num), stoll(num), target);\\n\\t\\t}\\n\\t}\\n\\n\\tvector<string> addOperators(string num, int target) {\\n\\t\\tvector<string> result;\\n\\t\\taddOperators(result, num, \"\", 0, 0, target);\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    void addOperators(vector<string>& result, string nums, string t, long long last, long long curVal, int target) {\\n\\t\\tif (nums.length() == 0) {\\n\\t\\t\\tif (curVal == target)\\n\\t\\t\\t\\tresult.push_back(t);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i<=nums.length(); i++) {\\n\\t\\t\\tstring num = nums.substr(0, i);\\n\\t\\t\\tif(num.length() > 1 && num[0] == '0')\\n\\t\\t\\t    return;\\n\\t\\t\\t\\n\\t\\t\\tstring nextNum = nums.substr(i);\\n\\n\\t\\t\\tif (t.length() > 0) {\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"+\" + num, stoll(num), curVal + stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"-\" + num, -stoll(num), curVal - stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"*\" + num, last * stoll(num), (curVal - last) + (last * stoll(num)), target);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t\\taddOperators(result, nextNum, num, stoll(num), stoll(num), target);\\n\\t\\t}\\n\\t}\\n\\n\\tvector<string> addOperators(string num, int target) {\\n\\t\\tvector<string> result;\\n\\t\\taddOperators(result, num, \"\", 0, 0, target);\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 310707,
                "title": "clean-python-dfs-solution",
                "content": "Please see and vote for my solutions for these similar problems\\n[224. Basic Calculator](https://leetcode.com/problems/basic-calculator/discuss/429098/Python3-solution-after-tokenization-(60ms-beat-99.75))\\n[227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/discuss/429100/Python3-solution-after-tokenization-(56ms-beat-99.92))\\n[282. Expression Add Operators](https://leetcode.com/problems/expression-add-operators/discuss/310707/Clean-Python-DFS-solution)\\n[772. Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/discuss/429132/Python3-solution-after-tokenization-(40ms-beat-93.59))\\n\\n```\\n    def addOperators(self, num, target):\\n        def dfs(l, r, expr, cur, last, res):\\n            if l == r:\\n                if cur == target:\\n                    res.append(expr)\\n                return\\n            for i in range(l + 1, r + 1):\\n                if i == l + 1 or (i > l + 1 and num[l] != \"0\"): # prevent \"00\"\\n                    s, x = num[l:i], int(num[l:i])\\n                    if last == None:\\n                        dfs(i, r, s, x, x, res)\\n                    else:\\n                        dfs(i, r, expr+\"+\"+s, cur + x, x, res)\\n                        dfs(i, r, expr+\"-\"+s, cur - x, -x, res)\\n                        dfs(i, r, expr+\"*\"+s, cur-last+last*x, last*x, res)\\n        \\n        res = []\\n        dfs(0, len(num), \\'\\', 0, None, res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def addOperators(self, num, target):\\n        def dfs(l, r, expr, cur, last, res):\\n            if l == r:\\n                if cur == target:\\n                    res.append(expr)\\n                return\\n            for i in range(l + 1, r + 1):\\n                if i == l + 1 or (i > l + 1 and num[l] != \"0\"): # prevent \"00\"\\n                    s, x = num[l:i], int(num[l:i])\\n                    if last == None:\\n                        dfs(i, r, s, x, x, res)\\n                    else:\\n                        dfs(i, r, expr+\"+\"+s, cur + x, x, res)\\n                        dfs(i, r, expr+\"-\"+s, cur - x, -x, res)\\n                        dfs(i, r, expr+\"*\"+s, cur-last+last*x, last*x, res)\\n        \\n        res = []\\n        dfs(0, len(num), \\'\\', 0, None, res)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71975,
                "title": "some-thoughts-on-the-algorithm-slr-1-and-optimization-meet-in-the-middle-spatial-data-structure",
                "content": "Share some thoughts of mine.\\n\\nThis algorithm resembles a SLR(1) parser.\\n\\nEach parse tree can be represented by 3 semantic values: add+mul*last.\\nWhile adding a symbol and a digit on the right side, the right spine of the parse tree may change. This process resembles the linear construction algorithm of a Cartesian tree.\\n\\nIn the figure below, the 3 trees on the right are derived from the leftmost.\\n\\n      +         +         +           +\\n     / \\\\       / \\\\       / \\\\         / \\\\\\n    2   *     2   *     2   *       +   6\\n       / \\\\       / \\\\       / \\\\     / \\\\\\n      3   @     3   @     *   6   2   *\\n         / \\\\       / \\\\   / \\\\         / \\\\\\n        4   5     @   6 3   @       3   @\\n                 / \\\\       / \\\\         / \\\\\\n                4   5     4   5       4   5\\n\\nNeglecting the leading zero issue (which can be easily rectified in a recursive parser), the grammar is:\\n\\n    E ::= E \"+\" F | E \"-\" F\\n    F ::= F \"*\" L\\n    L ::= \"0\" | ... | \"9\" | L \"0\" | ... | L \"9\"\\n\\nEach production contributes one node in the right spine of the parse tree, and these productions are hierarchical, that is, a lower-priority symbol cannot occur in the subtree of a higher-priority symbol. Thus the longest distance of the rightmost node to the root is 3. On the other hand, the LR(0) item sets are acyclic and the longest distance is 3.\\n\\n`-` can be seen as `+` if we regard the following digit as the opposite number. Addition and multiplication have units, so we can attach a `+`/`*` node if there is none. Juxtaposition has the highest priority so we can reduce them immediately. Thus 3 leaves and 2 inner nodes can represent a parse tree. That is why there are 3 semantic values in most solutions.\\n\\nState sets of each position can be represented by semantic values to minimize the space consumption.\\nFor each prefix of the enumerated expression in question, the rightmost node of the partial syntax tree represents current symbol and it has no more than 3 ancestors. For each ancestor `v`, we keep the semantic value of its left subtree, thus 3 integers are sufficient to represent the state.\\n\\nThis process can also be applied from right to left, so we can use a meet-in-the-middle algorithm to accelerate. We enumerate symbols in the right half and get many suffixes, each of which contributes 3 semantic values. The sum is indispensable, the first addend is necessary if we take account of multiplication. The first number in the first addend is necessary if we take in to account juxtaposition.\\n\\nIf we combine the partial results from the left side and the right side with `+` or `-`, the enumeration is `O(4^(n/2)*2^(n/2)) = O(2^(1.5n))`, better than brute-force `O(4^n) = O(2^(2n))`.\\nThe combination of `*` is tough, as it takes 2 semantic values (juxtaposition requires 3 which is unsolvable). How can be combine `a+b` from the left with `*c+d` from the right, and let the result `a+b*c+d=result` ? We can handle it with geometry method.\\n'c,d' from the right represents a line: `y=c*x+d`, the point (b, target-a) is on the line iff `target-a=c*b+d <=> a+b*c+d=target`. We turn the problem into: given `O(4^(n/2))` points and `O(4^(n/2))` lines, for each point, find the lines passing through it.\\nOrganize those points into a spatial data structure like quad-tree may be helpful. \\n\\nIf you can read Chinese, see [http://maskray.me/blog/2015-10-16-leetcode-expression-add-operators][1] , where I have written these thoughts in detail . It also gives some examples demonstrating the limit of the length of the right spine. \\n\\n    \\n    typedef long long ll;\\n    class Solution {\\n      string a;\\n      int n, nn, target;\\n      vector<multimap<ll, string>> e_plus, e_minus;\\n      vector<string> res;\\n      void backward(int k, string s, ll add, ll mul, ll last, ll ten) {\\n        if (k < nn) return;\\n        int x = a[k-1]-'0';\\n        ll ten2 = 10*ten, sum = add+mul*last;\\n        backward(k-1, string(1, a[k-1])+s, add, mul, last+ten2*x, ten2);\\n        if (ten == 1 || last >= ten) { // `last` has no leading zero\\n          backward(k-1, string(1, a[k-1])+'*'+s, add, mul*last, x, 1);\\n          backward(k-1, string(1, a[k-1])+'+'+s, sum, 1, x, 1);\\n          backward(k-1, string(1, a[k-1])+'-'+s, add-mul*last, 1, x, 1);\\n          e_plus[k].insert(make_pair(sum, s));\\n          e_minus[k].insert(make_pair(add-mul*last, s));\\n        }\\n      }\\n      void forward(int k, string s, ll add, ll mul, ll last) {\\n        ll sum = add+mul*last;\\n        if (k == n) {\\n          if (sum == target)\\n            res.push_back(s);\\n          return;\\n        }\\n        int x = a[k]-'0';\\n        if (last) // no leading zero\\n          forward(k+1, s+a[k], add, mul, last*10+x);\\n        forward(k+1, s+'*'+a[k], add, mul*last, x);\\n        if (k < nn) {\\n          forward(k+1, s+'+'+a[k], sum, 1, x);\\n          forward(k+1, s+'-'+a[k], sum, -1, x);\\n        } else {\\n          auto rg = e_plus[k].equal_range(target-sum);\\n          for (auto it = rg.first; it != rg.second; ++it)\\n            res.push_back(s+'+'+it->second);\\n          rg = e_minus[k].equal_range(target-sum);\\n          for (auto it = rg.first; it != rg.second; ++it)\\n            res.push_back(s+'-'+it->second);\\n        }\\n      }\\n    public:\\n      vector<string> addOperators(string num, int target) {\\n        a = num;\\n        n = a.size();\\n        if (n) {\\n          nn = n/2; // 0 < nn < n\\n          this->target = target;\\n          e_plus.resize(n);\\n          e_minus.resize(n);\\n          backward(n-1, string(1, a[n-1]), 0, 1, a[n-1]-'0', 1);\\n          forward(1, string(1, a[0]), 0, 1, a[0]-'0');\\n        }\\n        return res;\\n      }\\n    };\\n\\n\\n  [1]: http://maskray.me/blog/2015-10-16-leetcode-expression-add-operators",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n      string a;\\n      int n, nn, target;\\n      vector<multimap<ll, string>> e_plus, e_minus;\\n      vector<string> res;\\n      void backward(int k, string s, ll add, ll mul, ll last, ll ten) {\\n        if (k < nn) return;\\n        int x = a[k-1]-'0';\\n        ll ten2 = 10*ten, sum = add+mul*last;\\n        backward(k-1, string(1, a[k-1])+s, add, mul, last+ten2*x, ten2);\\n        if (ten == 1 || last >= ten) { // `last` has no leading zero\\n          backward(k-1, string(1, a[k-1])+'*'+s, add, mul*last, x, 1);\\n          backward(k-1, string(1, a[k-1])+'+'+s, sum, 1, x, 1);\\n          backward(k-1, string(1, a[k-1])+'-'+s, add-mul*last, 1, x, 1);\\n          e_plus[k].insert(make_pair(sum, s));\\n          e_minus[k].insert(make_pair(add-mul*last, s));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 792406,
                "title": "super-clean-python-backtracking-soution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n\\t\\t\\t\\n        num_len = len(num)\\n        res = []\\n        \\n        def dfs(idx, path):\\n            if idx == num_len - 1:\\n                # num_len - 1 to prevent situations like (1+2+) or (1*3*) etc..\\n                path = path + num[idx] \\n                if eval(path) == target:\\n                    res.append(path)\\n                return\\n            \\n            dfs(idx+1, path + num[idx] + \"+\") \\n            dfs(idx+1, path + num[idx] + \"-\")\\n            dfs(idx+1, path + num[idx] + \"*\")\\n            if (path and path[-1] not in [\\'+\\', \\'-\\', \\'*\\'] and num[idx] == \\'0\\') or num[idx] != \\'0\\':\\n                \\n                # Prevent cases such as (2+05) which cannot be evaluated using the eval function\\n                # Cases such as 12+104 should be acceptable, but not 121+04\\n                \\n                dfs(idx+1, path + num[idx])\\n            \\n        dfs(0, \"\")\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n\\t\\t\\t\\n        num_len = len(num)\\n        res = []\\n        \\n        def dfs(idx, path):\\n            if idx == num_len - 1:\\n                # num_len - 1 to prevent situations like (1+2+) or (1*3*) etc..\\n                path = path + num[idx] \\n                if eval(path) == target:\\n                    res.append(path)\\n                return\\n            \\n            dfs(idx+1, path + num[idx] + \"+\") \\n            dfs(idx+1, path + num[idx] + \"-\")\\n            dfs(idx+1, path + num[idx] + \"*\")\\n            if (path and path[-1] not in [\\'+\\', \\'-\\', \\'*\\'] and num[idx] == \\'0\\') or num[idx] != \\'0\\':\\n                \\n                # Prevent cases such as (2+05) which cannot be evaluated using the eval function\\n                # Cases such as 12+104 should be acceptable, but not 121+04\\n                \\n                dfs(idx+1, path + num[idx])\\n            \\n        dfs(0, \"\")\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 354772,
                "title": "c-concise-dfs",
                "content": "```cpp\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tdfs(num, 0, target, \"\", 0, 0, res);\\n\\treturn res;\\n}\\n\\nvoid dfs(string &num, int start, int target, string path, long prev, long cur, vector<string> &res) {\\n\\tif(start == num.size() && prev + cur == target) res.push_back(path);\\n\\n\\tfor(int i = 1; start + i <= num.size(); i++) {\\n\\t\\tstring s = num.substr(start, i);\\n\\t\\tlong n = stoll(s);\\n\\t\\tif(to_string(n).size() != s.size()) return;\\n\\t\\tif(!start) dfs(num, i, target, s, 0, n, res);\\n\\t\\telse {\\n\\t\\t\\tdfs(num, start + i, target, path + \"+\" + s, prev + cur, n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"-\" + s, prev + cur, -n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"*\" + s, prev, cur * n, res);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tdfs(num, 0, target, \"\", 0, 0, res);\\n\\treturn res;\\n}\\n\\nvoid dfs(string &num, int start, int target, string path, long prev, long cur, vector<string> &res) {\\n\\tif(start == num.size() && prev + cur == target) res.push_back(path);\\n\\n\\tfor(int i = 1; start + i <= num.size(); i++) {\\n\\t\\tstring s = num.substr(start, i);\\n\\t\\tlong n = stoll(s);\\n\\t\\tif(to_string(n).size() != s.size()) return;\\n\\t\\tif(!start) dfs(num, i, target, s, 0, n, res);\\n\\t\\telse {\\n\\t\\t\\tdfs(num, start + i, target, path + \"+\" + s, prev + cur, n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"-\" + s, prev + cur, -n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"*\" + s, prev, cur * n, res);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140390,
                "title": "a-recursive-algorithm-with-detailed-explanation-and-proof-of-correctness",
                "content": "## Remarks\\nI think the algorithm becomes quite easy to understand once you understand the **definition and properties** I\\'ve listed below. Everything else is implementation formalities.\\n\\n## Definition\\nThe following definition and notation will help simplify the proof of correctness later\\n\\n**Eval** : Exp -> N  \\nIt\\'s a function that takes in a string of the form \"23-3\\\\*7+50\". Basically *Exp* resembles the a viable arrangement of operators (** \\\\*, +, - only**) and digits as the problem specifies. It\\'s behaves just like how we would manually calculate *Exp*.\\n\\nExample:  \\n\\n* Eval(\"5\") = 5.  \\n\\n* Eval(\"3+2*7-4\") = 13\\n\\n## Property\\nWe assume the following properties of *Eval*, and we will use them later to verify the correctness of our algorithm. I think they are all very intuitive, but I don\\'t know how to formally prove them.  \\n\\nA and B will be arbitrary *Exp*, *+* will append the two adjacent strings.\\n\\n### P1\\n    Eval(A + \\'+\\' + B) = Eval(A) + Eval(B)\\nExample:  \\nEval(\"4\\\\*3+3-2\") = Eval(\"4\\\\*3\") + Eval(\"3-2\")\\n\\n### P2\\n    Eval(A + \\'-\\' + B) = Eval(A) + Eval(\\'-1*\\' + B)\\nExample:  \\nEval(\"4\\\\*3-3-2\") = Eval(\"4\\\\*3\") + Eval(\"-1*3-2\")\\n\\n### P3\\n    Eval(A + \\'*\\' + B + \\'*\\' + C) = Eval(str(Eval(A + \\'*\\' + B)) + \\'*\\' + C)\\n\\nNote: *str* turns a number into its string representation.\\nExample:  \\nEval(\\'4\\\\*3\\\\*3+2\\') = Eval(str(Eval(4\\\\*3)) + \\'\\\\*\\' + \\'3+2\\') = Eval(\\'12\\\\*3+2\\')\\n\\n\\n### P4\\n    Eval(\\'1*\\' + A) = Eval(A)\\n\\nNote: This can be easily derived by case analysis (on A) and the previous three properties.  \\nExample:  \\nEval(\\'5+7\\') = Eval(\\'1\\\\*5+7\\')\\n\\n\\n## Algorithm\\nConsider a slightly modified version of this problem:  \\nGiven a number X, and a list of numbers lon = [N1, N2, ..., Nk], and a target number  \\n\\n**F(X, lon, target)** returns the combinations of \"X \\\\* N1N2N3\" that yields target, where the rules for inserting operator between digits is the same as problem described above  \\n\\nThe only difference being there is a multiplication operator inserted after X already.  \\n\\nOur **original problem** asks for all possible arrangements of input *lon* such that each arrangement *E* satisfies **Eval(E) = target**. Well, by property 4, that is just a special case of the more generalized **F**, namely, **F(1, lon, target)**.\\n\\nWe will show how to recursively apply **F** to compute the desired output. We do this by enumerating all cases based on the input.  \\n**Note:** We denote lon as [N1, N2, ..., Nk]. Thus len(lon) = k\\n\\n\\n### Base case\\nWhen *k == 1*, by definition of **F**, if *X \\\\* N1 == target*, this arrangement is qualified, and we return its string representation: *str(X) + \\'\\\\*\\' + str(N1)*  \\n\\n### Recursive cases\\nRemember we can either insert one of the three operators, or not insert anything. Thus we have 4 cases:\\n\\n### Insert nothing\\nWe keep N1 and N2 together in this case, but this only works if N1 is not \\'0\\', since something like \\'07\\' will not be a valid NumberString.  \\nAssume that, and by definition of **F**, we can recursively compute the output as \\n\\n**F(X, [N1 \\\\* 10 + N2, N3, ..., Nk], target)**\\n\\n### Insert +\\nThe final arrangement will look like **\\'X \\\\* N1 + E\\'**, where *E* is whatever arrangement the rest of the lon ([N2, N3, ..., Nk]) came out to be.  \\nThus, we want this string to evaluate to *target*, meaning that,  \\n**Eval(\\'X * N1\\' + \\'+\\' +  E) = target**. By property 1 we have:  \\n**target = Eval(\\'X \\\\* N1\\') + Eval(E) = X \\\\* N1 + Eval(E)**  \\nIn other words, we want **Eval(E) = target - X \\\\* N1**  \\nWhat are the possible arrangements for that? That is precisely a subproblem to the original problem, thus the answer for that is \\n\\n**F(1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n### Insert -\\nThis is similar to the case with \\'+\\' above, because we can use property 2 to transform \\'-\\'.  \\nWe want **Eval(\\'X * N1\\' + \\'-\\' +  E) = target**. By property 2 we have:\\n**target = Eval(\\'X \\\\* N1\\') + Eval(\\'-1\\\\*\\' + E) = X \\\\* N1 + Eval(\\'-1\\\\*\\' + E)**  \\nIn other words, we want **Eval(\\'-1\\\\*\\' + E) = target - X \\\\* N1**  \\nTo solve this subproblem, we need to utilize the definition for **F**, which suggests that the answer is \\n\\n**F(-1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n\\n### Insert *\\nThis follows the same pattern as the above cases.  \\nWe want **Eval(\\'X \\\\* N1\\' + \\'\\\\*\\' +  E) = target**. By property 3 we have:  \\n**target = Eval(str(Eval(\\'X \\\\* N1\\')) + \\'\\\\*\\' + E)**  \\nBy definition of **F**, we can derived the answer easily:\\n\\n**F(X \\\\* N1, [N2, N3, ..., Nk], target**\\n\\n\\n## Code\\nThe following is my implementation of the algorithm in Python3. It\\'s exactly like what I described above. \\n\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        lon = list(map(int, num))\\n        answer = []\\n\\n        # F is exactly like what we defined above, except it has\\n        # an extra argument to keep track of the partial string arrangement (including \\'X*\\')\\n        # already determined as it recurs down the search\\n        # Also lon is represented as lon[start:]\\n        # Viable arrangement will be appened into @answer in string form\\n        def F(x, start, targ, prevArrangement):\\n\\t\\t\\t\\t\\n            # notice that start increments on every recursive call, so termination is ensured. \\n            if start == len(lon) - 1:\\n                if x * lon[start] == targ:\\n                    answer.append(prevArrangement + str(lon[start]))\\n                return\\n\\n            #  case 1 (no operator insertion)\\n            # we have to modify the value of lon[start + 1]\\n            # so we restore its value after the function returns\\n            if lon[start] != 0:\\n                lon[start + 1] += lon[start] * 10\\n                F(x, start + 1, targ, prevArrangement)\\n                lon[start + 1] -= lon[start] * 10\\n\\n            # case 2, insert \\'+\\'\\n            F(1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'+\\')\\n\\n            # case 3, insert \\'-\\'\\n            F(-1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'-\\')\\n\\n            # case 4, insert \\'*\\'\\n            F(x * lon[start], start + 1, targ, prevArrangement + str(lon[start]) + \\'*\\')\\n\\n\\n        # since we don\\'t want to keep the \"1*\" in the front, we initialize\\n        # prevArrangement to be empty string. \\n        F(1, 0, target, \"\")\\n        return answer\\n\\n\\n",
                "solutionTags": [],
                "code": "## Remarks\\nI think the algorithm becomes quite easy to understand once you understand the **definition and properties** I\\'ve listed below. Everything else is implementation formalities.\\n\\n## Definition\\nThe following definition and notation will help simplify the proof of correctness later\\n\\n**Eval** : Exp -> N  \\nIt\\'s a function that takes in a string of the form \"23-3\\\\*7+50\". Basically *Exp* resembles the a viable arrangement of operators (** \\\\*, +, - only**) and digits as the problem specifies. It\\'s behaves just like how we would manually calculate *Exp*.\\n\\nExample:  \\n\\n* Eval(\"5\") = 5.  \\n\\n* Eval(\"3+2*7-4\") = 13\\n\\n## Property\\nWe assume the following properties of *Eval*, and we will use them later to verify the correctness of our algorithm. I think they are all very intuitive, but I don\\'t know how to formally prove them.  \\n\\nA and B will be arbitrary *Exp*, *+* will append the two adjacent strings.\\n\\n### P1\\n    Eval(A + \\'+\\' + B) = Eval(A) + Eval(B)\\nExample:  \\nEval(\"4\\\\*3+3-2\") = Eval(\"4\\\\*3\") + Eval(\"3-2\")\\n\\n### P2\\n    Eval(A + \\'-\\' + B) = Eval(A) + Eval(\\'-1*\\' + B)\\nExample:  \\nEval(\"4\\\\*3-3-2\") = Eval(\"4\\\\*3\") + Eval(\"-1*3-2\")\\n\\n### P3\\n    Eval(A + \\'*\\' + B + \\'*\\' + C) = Eval(str(Eval(A + \\'*\\' + B)) + \\'*\\' + C)\\n\\nNote: *str* turns a number into its string representation.\\nExample:  \\nEval(\\'4\\\\*3\\\\*3+2\\') = Eval(str(Eval(4\\\\*3)) + \\'\\\\*\\' + \\'3+2\\') = Eval(\\'12\\\\*3+2\\')\\n\\n\\n### P4\\n    Eval(\\'1*\\' + A) = Eval(A)\\n\\nNote: This can be easily derived by case analysis (on A) and the previous three properties.  \\nExample:  \\nEval(\\'5+7\\') = Eval(\\'1\\\\*5+7\\')\\n\\n\\n## Algorithm\\nConsider a slightly modified version of this problem:  \\nGiven a number X, and a list of numbers lon = [N1, N2, ..., Nk], and a target number  \\n\\n**F(X, lon, target)** returns the combinations of \"X \\\\* N1N2N3\" that yields target, where the rules for inserting operator between digits is the same as problem described above  \\n\\nThe only difference being there is a multiplication operator inserted after X already.  \\n\\nOur **original problem** asks for all possible arrangements of input *lon* such that each arrangement *E* satisfies **Eval(E) = target**. Well, by property 4, that is just a special case of the more generalized **F**, namely, **F(1, lon, target)**.\\n\\nWe will show how to recursively apply **F** to compute the desired output. We do this by enumerating all cases based on the input.  \\n**Note:** We denote lon as [N1, N2, ..., Nk]. Thus len(lon) = k\\n\\n\\n### Base case\\nWhen *k == 1*, by definition of **F**, if *X \\\\* N1 == target*, this arrangement is qualified, and we return its string representation: *str(X) + \\'\\\\*\\' + str(N1)*  \\n\\n### Recursive cases\\nRemember we can either insert one of the three operators, or not insert anything. Thus we have 4 cases:\\n\\n### Insert nothing\\nWe keep N1 and N2 together in this case, but this only works if N1 is not \\'0\\', since something like \\'07\\' will not be a valid NumberString.  \\nAssume that, and by definition of **F**, we can recursively compute the output as \\n\\n**F(X, [N1 \\\\* 10 + N2, N3, ..., Nk], target)**\\n\\n### Insert +\\nThe final arrangement will look like **\\'X \\\\* N1 + E\\'**, where *E* is whatever arrangement the rest of the lon ([N2, N3, ..., Nk]) came out to be.  \\nThus, we want this string to evaluate to *target*, meaning that,  \\n**Eval(\\'X * N1\\' + \\'+\\' +  E) = target**. By property 1 we have:  \\n**target = Eval(\\'X \\\\* N1\\') + Eval(E) = X \\\\* N1 + Eval(E)**  \\nIn other words, we want **Eval(E) = target - X \\\\* N1**  \\nWhat are the possible arrangements for that? That is precisely a subproblem to the original problem, thus the answer for that is \\n\\n**F(1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n### Insert -\\nThis is similar to the case with \\'+\\' above, because we can use property 2 to transform \\'-\\'.  \\nWe want **Eval(\\'X * N1\\' + \\'-\\' +  E) = target**. By property 2 we have:\\n**target = Eval(\\'X \\\\* N1\\') + Eval(\\'-1\\\\*\\' + E) = X \\\\* N1 + Eval(\\'-1\\\\*\\' + E)**  \\nIn other words, we want **Eval(\\'-1\\\\*\\' + E) = target - X \\\\* N1**  \\nTo solve this subproblem, we need to utilize the definition for **F**, which suggests that the answer is \\n\\n**F(-1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n\\n### Insert *\\nThis follows the same pattern as the above cases.  \\nWe want **Eval(\\'X \\\\* N1\\' + \\'\\\\*\\' +  E) = target**. By property 3 we have:  \\n**target = Eval(str(Eval(\\'X \\\\* N1\\')) + \\'\\\\*\\' + E)**  \\nBy definition of **F**, we can derived the answer easily:\\n\\n**F(X \\\\* N1, [N2, N3, ..., Nk], target**\\n\\n\\n## Code\\nThe following is my implementation of the algorithm in Python3. It\\'s exactly like what I described above. \\n\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        lon = list(map(int, num))\\n        answer = []\\n\\n        # F is exactly like what we defined above, except it has\\n        # an extra argument to keep track of the partial string arrangement (including \\'X*\\')\\n        # already determined as it recurs down the search\\n        # Also lon is represented as lon[start:]\\n        # Viable arrangement will be appened into @answer in string form\\n        def F(x, start, targ, prevArrangement):\\n\\t\\t\\t\\t\\n            # notice that start increments on every recursive call, so termination is ensured. \\n            if start == len(lon) - 1:\\n                if x * lon[start] == targ:\\n                    answer.append(prevArrangement + str(lon[start]))\\n                return\\n\\n            #  case 1 (no operator insertion)\\n            # we have to modify the value of lon[start + 1]\\n            # so we restore its value after the function returns\\n            if lon[start] != 0:\\n                lon[start + 1] += lon[start] * 10\\n                F(x, start + 1, targ, prevArrangement)\\n                lon[start + 1] -= lon[start] * 10\\n\\n            # case 2, insert \\'+\\'\\n            F(1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'+\\')\\n\\n            # case 3, insert \\'-\\'\\n            F(-1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'-\\')\\n\\n            # case 4, insert \\'*\\'\\n            F(x * lon[start], start + 1, targ, prevArrangement + str(lon[start]) + \\'*\\')\\n\\n\\n        # since we don\\'t want to keep the \"1*\" in the front, we initialize\\n        # prevArrangement to be empty string. \\n        F(1, 0, target, \"\")\\n        return answer\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1068461,
                "title": "javascript-simple-backtracking-solution",
                "content": "```javascript\\nvar addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470556,
                "title": "c-backtracking-beginner-explained-easy-to-understand-clean",
                "content": "# ***Approach***\\n```\\n    This problem is a pretty good backtracking problem\\n    You can easily apply dfs to find all possible expressions , but the main problem is in evaluating that expression simultaneously!!!\\n    \\n    Points to remember:\\n        (1) First number of expression is operatorless[meaning no operator is before it]\\n        (2) string path stores : expression for a branch\\n        (3) res : it stores the result calculated so far!!!\\n        (4) prev : stores the last number of expression\\n        (5) sub_string : holds number for [index to i] , take example , index = 0 , i = 2 , num = \"1234\" then  sub_string = \"123\"\\n                take example\\n                    2 + 3 * 3\\n                    if path = \"2+3\" , prev = 3\\n                take another example\\n                    2 + 3 * 4 * 2\\n                    if path = \"2+3*4\" , prev = 12\\n                NOTE : when we pick * as operator we pick prev = prev * number\\n                \\n----------------------------------------------------------------------------------------------------------------------\\n\\n    Logic Simplified:\\n        if(index == num.size() and res is target)\\n            push path to expression and then return\\n            \\n        run loop from[index to end]\\n        {\\n            form sub_string , simultaneously form number\\n            \\n            if(a number with leading 0 is formed as sub_string)\\n                break;\\n            \\n            if(we are forming first number of expression)\\n                pick no operator and apply dfs\\n            else\\n            {\\n                pick + operator and apply dfs , prev = number\\n                pick - operator and apply dfs , prev = -number\\n                pick * operator and apply dfs , prev = prev * number [while evaluating res we first subtract prev_val because it is attached or connected to next val]\\n            }\\n        }\\n----------------------------------------------------------------------------------------------------------------------        \\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```\\n# ***If you liked the solution , Please Upvote :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n    This problem is a pretty good backtracking problem\\n    You can easily apply dfs to find all possible expressions , but the main problem is in evaluating that expression simultaneously!!!\\n    \\n    Points to remember:\\n        (1) First number of expression is operatorless[meaning no operator is before it]\\n        (2) string path stores : expression for a branch\\n        (3) res : it stores the result calculated so far!!!\\n        (4) prev : stores the last number of expression\\n        (5) sub_string : holds number for [index to i] , take example , index = 0 , i = 2 , num = \"1234\" then  sub_string = \"123\"\\n                take example\\n                    2 + 3 * 3\\n                    if path = \"2+3\" , prev = 3\\n                take another example\\n                    2 + 3 * 4 * 2\\n                    if path = \"2+3*4\" , prev = 12\\n                NOTE : when we pick * as operator we pick prev = prev * number\\n                \\n----------------------------------------------------------------------------------------------------------------------\\n\\n    Logic Simplified:\\n        if(index == num.size() and res is target)\\n            push path to expression and then return\\n            \\n        run loop from[index to end]\\n        {\\n            form sub_string , simultaneously form number\\n            \\n            if(a number with leading 0 is formed as sub_string)\\n                break;\\n            \\n            if(we are forming first number of expression)\\n                pick no operator and apply dfs\\n            else\\n            {\\n                pick + operator and apply dfs , prev = number\\n                pick - operator and apply dfs , prev = -number\\n                pick * operator and apply dfs , prev = prev * number [while evaluating res we first subtract prev_val because it is attached or connected to next val]\\n            }\\n        }\\n----------------------------------------------------------------------------------------------------------------------        \\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71967,
                "title": "elegant-java-solution",
                "content": "    public class Solution {\\n    List<String> result =new ArrayList<String>();\\n    public List<String> addOperators(String num, int target) {\\n        for(int i=1;i<=num.length();i++){\\n            if(i>=2 && num.charAt(0)=='0') continue;\\n            bfs(num.substring(i),num.substring(0,i),target,0,Long.parseLong(num.substring(0,i)),true);\\n        }\\n        return result;\\n    }\\n    \\n    public void bfs(String s,String trace,int target,long pre,long current,boolean sign){\\n        long sum = sign? pre+current:pre-current;\\n        if(s.length()==0){\\n            if(sum==(long) target) result.add(trace);\\n            return;\\n        }\\n        for(int i=1;i<=s.length();i++){\\n            if(i>=2 && s.charAt(0)=='0') continue;\\n            int number = Integer.parseInt(s.substring(0,i));\\n            bfs(s.substring(i),trace+\"+\"+number,target,sum,number,true);\\n            bfs(s.substring(i),trace+\"-\"+number,target,sum,number,false);\\n            bfs(s.substring(i),trace+\"*\"+number,target,pre,current*number,sign);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    List<String> result =new ArrayList<String>();\\n    public List<String> addOperators(String num, int target) {\\n        for(int i=1;i<=num.length();i++){\\n            if(i>=2 && num.charAt(0)=='0') continue;\\n            bfs(num.substring(i),num.substring(0,i),target,0,Long.parseLong(num.substring(0,i)),true);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71947,
                "title": "16ms-c-solution",
                "content": "The idea is to cut a value from the left of the string and then for each of operations '+', '-', '*' repeat the procedure recursively. The trick is to pass the sum of all left summands and the product of rightmost factors. This allows to calculate the left sum and the right product on the next step depending on the next chosen operation.\\n\\n    class Solution {\\n        typedef long long int i64;\\n        \\n        string myS;\\n        const char* s;\\n        i64 target;\\n        int slen;\\n        \\n    public:\\n      \\n        vector<string> addOperators(const string& num, int t) {\\n            myS = num;\\n            slen = myS.size();\\n            s = myS.c_str();\\n            target = t;\\n            \\n            vector<string> res;\\n            char buf[slen*2+1];\\n            \\n            int lmax = (s[0] == '0' ? 1 : slen);\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[l-1];\\n                v = v*10 + (c-'0');   // add next digit\\n                buf[l-1] = c;  // only need to append the last digit\\n                processTail(0, v, l, buf, l, res);\\n            }\\n            return res;\\n        }\\n    \\n        void processTail(i64 prevsum, i64 last, int pos, char* buf, int bufpos, vector<string>& res) {\\n            if (pos == slen) {\\n                // end of string\\n                // check the value and save\\n                if (prevsum+last == target) {\\n                    buf[bufpos] = 0;\\n                    res.push_back(buf);\\n                }\\n                return;\\n            }\\n            \\n            int lmax = (s[pos] == '0' ? 1 : slen-pos); // don't allow multichar intergers starting from a '0'\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[pos+l-1];\\n                v = v*10 + (c-'0');     // add next digit to v\\n    \\n                buf[bufpos] = '+';\\n                buf[bufpos+l] = c;      // only need to append the last digit of v\\n                processTail(prevsum+last, v, pos+l, buf, bufpos+l+1, res);\\n    \\n                buf[bufpos] = '-'; \\n                processTail(prevsum+last, -v, pos+l, buf, bufpos+l+1, res);\\n    \\n                buf[bufpos] = '*'; \\n                processTail(prevsum, last*v, pos+l, buf, bufpos+l+1, res);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        typedef long long int i64;\\n        \\n        string myS;\\n        const char* s;\\n        i64 target;\\n        int slen;\\n        \\n    public:\\n      \\n        vector<string> addOperators(const string& num, int t) {\\n            myS = num;\\n            slen = myS.size();\\n            s = myS.c_str();\\n            target = t;\\n            \\n            vector<string> res;\\n            char buf[slen*2+1];\\n            \\n            int lmax = (s[0] == '0' ? 1 : slen);\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[l-1];\\n                v = v*10 + (c-'0');   // add next digit\\n                buf[l-1] = c;  // only need to append the last digit\\n                processTail(0, v, l, buf, l, res);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3742718,
                "title": "c-hinglish-easy-explanation-backtracking-interview-prep",
                "content": "# Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n   \\t1. Numbers ke beech mein operators dalna hain +,-,*.\\n   \\t2. Teeno ko baari baari se try karna hain jisse target achieve ho to backtracking use karenge hi.\\n   \\t3. Ab isme dhyan rakhna hain ki koi \\n   \\t- leading 0 na ho \\n   \\t- BODMAS rules are followed\\n   \\t4. Subtraction and Addition rules to aasani se follow ho jayenge\\n   \\t5. Multiplication mein hame previous operation ko hatana padega jaise agar prev operation sum that to vo operation hatake multiplication dalenge.\\n   \\t6. First index pe hain to aage bad jayenge \\n   \\t7. Recursive Calls mein we will keep track of index in num,sumPath,sum,prev.\\n\\n//==============================================================================================================================\\n    public:\\n        void recursiveCall(int i, string sumPath, long sum, long prev, string num, int target, vector<string> &result)\\n        {\\n           \\t// If we have reached the end of \\'num\\'\\n            if (i == num.size())\\n            {\\n                if (sum == target)\\n                {\\n                   \\t// If the target is achieved, add the path to the result\\n                    result.push_back(sumPath);\\n                }\\n                return;\\n            }\\n\\n            for (int j = i; j < num.size(); j++)\\n            {\\n                if (j > i && num[i] == \\'0\\')\\n                {\\n                   \\t// Avoid leading zeros in the number\\n                    break;\\n                }\\n\\n                long number = stol(num.substr(i, j - i + 1));\\n               \\t// Convert the substring to a long number\\n                string tempPath = num.substr(i, j - i + 1);\\n               \\t// Temporary substring representing the path we have traversed so far\\n\\n                if (i == 0)\\n                {\\n                   \\t// If we are on the first index of \\'num\\', start a new path\\n                    recursiveCall(j + 1, tempPath, number, number, num, target, result);\\n                }\\n                else\\n                {\\n                   \\t// Addition operation\\n                    recursiveCall(j + 1, sumPath + \\'+\\' + tempPath, sum + number, number, num, target, result);\\n                   \\t// Subtraction operation\\n                    recursiveCall(j + 1, sumPath + \\'-\\' + tempPath, sum - number, -number, num, target, result);\\n                   \\t// Multiplication operation\\n                    recursiveCall(j + 1, sumPath + \\'*\\' + tempPath, sum - prev + (prev *number), prev *number, num, target, result);\\n                   \\t// While doing the multiplication operation, we remove the previous operation and update it with the multiplication operation\\n                   \\t// This is done to follow the BODMAS rules for correct precedence\\n                }\\n            }\\n        }\\n\\n    vector<string> addOperators(string num, int target)\\n    {\\n        vector<string> result;\\n        recursiveCall(0, \"\", 0, 0, num, target, result);\\n    //recursiveCall(CurrentIndex,Path,sum,prev,num,target,result)\\n        return result;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $O(3^n)$ where `n is num size` and `3 are our operations` on each char of num.\\n\\n- Space complexity: $O(n^3)$ Worst Case Scenario where `n is num size`.\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution\\n{\\n   \\t1. Numbers ke beech mein operators dalna hain +,-,*.\\n   \\t2. Teeno ko baari baari se try karna hain jisse target achieve ho to backtracking use karenge hi.\\n   \\t3. Ab isme dhyan rakhna hain ki koi \\n   \\t- leading 0 na ho \\n   \\t- BODMAS rules are followed\\n   \\t4. Subtraction and Addition rules to aasani se follow ho jayenge\\n   \\t5. Multiplication mein hame previous operation ko hatana padega jaise agar prev operation sum that to vo operation hatake multiplication dalenge.\\n   \\t6. First index pe hain to aage bad jayenge \\n   \\t7. Recursive Calls mein we will keep track of index in num,sumPath,sum,prev.\\n\\n//==============================================================================================================================\\n    public:\\n        void recursiveCall(int i, string sumPath, long sum, long prev, string num, int target, vector<string> &result)\\n        {\\n           \\t// If we have reached the end of \\'num\\'\\n            if (i == num.size())\\n            {\\n                if (sum == target)\\n                {\\n                   \\t// If the target is achieved, add the path to the result\\n                    result.push_back(sumPath);\\n                }\\n                return;\\n            }\\n\\n            for (int j = i; j < num.size(); j++)\\n            {\\n                if (j > i && num[i] == \\'0\\')\\n                {\\n                   \\t// Avoid leading zeros in the number\\n                    break;\\n                }\\n\\n                long number = stol(num.substr(i, j - i + 1));\\n               \\t// Convert the substring to a long number\\n                string tempPath = num.substr(i, j - i + 1);\\n               \\t// Temporary substring representing the path we have traversed so far\\n\\n                if (i == 0)\\n                {\\n                   \\t// If we are on the first index of \\'num\\', start a new path\\n                    recursiveCall(j + 1, tempPath, number, number, num, target, result);\\n                }\\n                else\\n                {\\n                   \\t// Addition operation\\n                    recursiveCall(j + 1, sumPath + \\'+\\' + tempPath, sum + number, number, num, target, result);\\n                   \\t// Subtraction operation\\n                    recursiveCall(j + 1, sumPath + \\'-\\' + tempPath, sum - number, -number, num, target, result);\\n                   \\t// Multiplication operation\\n                    recursiveCall(j + 1, sumPath + \\'*\\' + tempPath, sum - prev + (prev *number), prev *number, num, target, result);\\n                   \\t// While doing the multiplication operation, we remove the previous operation and update it with the multiplication operation\\n                   \\t// This is done to follow the BODMAS rules for correct precedence\\n                }\\n            }\\n        }\\n\\n    vector<string> addOperators(string num, int target)\\n    {\\n        vector<string> result;\\n        recursiveCall(0, \"\", 0, 0, num, target, result);\\n    //recursiveCall(CurrentIndex,Path,sum,prev,num,target,result)\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447209,
                "title": "clean-python3-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        L = len(num)\\n        ans = set()\\n        \\n        def backtrack(i, total, last, expr):\\n            if i == L:\\n                if total == target:\\n                    ans.add(expr)\\n                return\\n            \\n            for j in range(i, L):\\n                n = int(num[i:j+1])\\n                if i == 0:\\n                    backtrack(j+1, n, n, str(n))\\n                else:\\n                    backtrack(j+1, total + n, n, expr + \\'+\\' + str(n))\\n                    backtrack(j+1, total - n, -n, expr + \\'-\\' + str(n))\\n                    backtrack(j+1, total - last + last * n, last * n, expr + \\'*\\' + str(n))\\n                if n == 0:\\n                    break\\n                    \\n        backtrack(0, 0, 0, \\'\\')\\n        return list(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        L = len(num)\\n        ans = set()\\n        \\n        def backtrack(i, total, last, expr):\\n            if i == L:\\n                if total == target:\\n                    ans.add(expr)\\n                return\\n            \\n            for j in range(i, L):\\n                n = int(num[i:j+1])\\n                if i == 0:\\n                    backtrack(j+1, n, n, str(n))\\n                else:\\n                    backtrack(j+1, total + n, n, expr + \\'+\\' + str(n))\\n                    backtrack(j+1, total - n, -n, expr + \\'-\\' + str(n))\\n                    backtrack(j+1, total - last + last * n, last * n, expr + \\'*\\' + str(n))\\n                if n == 0:\\n                    break\\n                    \\n        backtrack(0, 0, 0, \\'\\')\\n        return list(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470847,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(int i, string path, long resSoFar, long prevNum, const string &s, const int &target){\\n        if(i==s.size() and resSoFar==target){\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        string curNumStr = \"\";\\n        long curNum=0;\\n        for(int j=i;j<s.size();++j){\\n            if(j>i and s[i]==\\'0\\') break; //leading zero not allowed\\n            //eg:105 --> 1*05=5(but 05 is now allowed)\\n            curNumStr.push_back(s[j]);\\n            curNum = (curNum*10)+(s[j]-\\'0\\');\\n            if(i==0){\\n                dfs(j+1, path+curNumStr, curNum, curNum, s, target);\\n            }else{\\n                dfs(j+1, path+\"+\"+curNumStr, resSoFar+curNum, curNum, s, target);\\n                dfs(j+1, path+\"-\"+curNumStr, resSoFar-curNum, -curNum, s, target);\\n                dfs(j+1, path+\"*\"+curNumStr, resSoFar-prevNum+(curNum*prevNum), prevNum*curNum, s, target);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    vector<string> addOperators(string &num, int target) {\\n        dfs(0,\"\",0,0,num,target);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(int i, string path, long resSoFar, long prevNum, const string &s, const int &target){\\n        if(i==s.size() and resSoFar==target){\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        string curNumStr = \"\";\\n        long curNum=0;\\n        for(int j=i;j<s.size();++j){\\n            if(j>i and s[i]==\\'0\\') break; //leading zero not allowed\\n            //eg:105 --> 1*05=5(but 05 is now allowed)\\n            curNumStr.push_back(s[j]);\\n            curNum = (curNum*10)+(s[j]-\\'0\\');\\n            if(i==0){\\n                dfs(j+1, path+curNumStr, curNum, curNum, s, target);\\n            }else{\\n                dfs(j+1, path+\"+\"+curNumStr, resSoFar+curNum, curNum, s, target);\\n                dfs(j+1, path+\"-\"+curNumStr, resSoFar-curNum, -curNum, s, target);\\n                dfs(j+1, path+\"*\"+curNumStr, resSoFar-prevNum+(curNum*prevNum), prevNum*curNum, s, target);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    vector<string> addOperators(string &num, int target) {\\n        dfs(0,\"\",0,0,num,target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142357,
                "title": "backtracking",
                "content": "> Factors to be enumerated:\\n- num can be divided into arbitrary numbers, each number can be arbitrary length, represented by `num.substring(start, end)`\\n- preceding operator of each number can be  \\'+\\', \\'-\\',  or \\'x\\'\\n```\\nTake num = \"12\" for example, state tree is as blow:\\n root\\n   /\\\\\\n  1 12 --level 1\\n /|\\\\\\n+ - *\\n| | |\\n2 2 2 -- level 2\\n```\\n\\n> If we specify an `element = num.substring(start, end)`, with any possible operator in front, we get a new value. `start` increases in next round, the problem becomes smaller.\\n\\n> The base case is: start == num.length()\\n> The special case is: the first operand doesn\\'t have`preceding operator`\\n\\n> Note: if `preceding operator` is `*`, value of current expression should be re-evaluated by restoring the `difference` first\\n```\\nTake 1 + 2 * 3 for example,\\n  val = 1 + 2 = 3\\n  diff = 2\\n// when start = 2, i.e. we meet curNum = 3\\n  val = val - diff + diff * curNum\\n      = 3 - 2 + 2 * 3 = 7\\n```\\n****\\n```\\nclass Solution {\\n    private List<String> result;\\n    \\n    public List<String> addOperators(String num, int target) {\\n        result = new ArrayList<>();\\n        addOperators(num, target, 0, 0, \"\", 0);\\n        return result;\\n    }\\n    \\n    /* \\n    @param: num\\n    @param: target\\n    @param: start  start index in num\\n    @param: val  current value of expr\\n    @param: expr  expression\\n    @param: diff  difference\\n    */\\n    private void addOperators(String num, int target, int start, long val, String expr, long diff) {\\n        if (start == num.length()) {\\n            \\n            if (target == val) {\\n                result.add(expr);\\n            } \\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= num.length(); end++) {\\n            String cur = num.substring(start, end);\\n            \\n            if (cur.charAt(0) == \\'0\\' && cur.length() > 1) {\\n                // Invalid number\\n                continue;\\n            }\\n            \\n            long curNum = Long.parseLong(cur);\\n            \\n            if (start == 0) {\\n                // The first number\\n                addOperators(num, target, end, curNum, cur, curNum);\\n            } else {\\n                // + in front\\n                addOperators(num, target, end, val + curNum, expr + \"+\" + cur, curNum);\\n            \\n                // - in front\\n                addOperators(num, target, end, val - curNum, expr + \"-\" + cur, -curNum);\\n        \\n                // * in front\\n                addOperators(num, target, end, val - diff + diff * curNum, expr + \"*\" + cur, diff * curNum);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTake num = \"12\" for example, state tree is as blow:\\n root\\n   /\\\\\\n  1 12 --level 1\\n /|\\\\\\n+ - *\\n| | |\\n2 2 2 -- level 2\\n```\n```\\nTake 1 + 2 * 3 for example,\\n  val = 1 + 2 = 3\\n  diff = 2\\n// when start = 2, i.e. we meet curNum = 3\\n  val = val - diff + diff * curNum\\n      = 3 - 2 + 2 * 3 = 7\\n```\n```\\nclass Solution {\\n    private List<String> result;\\n    \\n    public List<String> addOperators(String num, int target) {\\n        result = new ArrayList<>();\\n        addOperators(num, target, 0, 0, \"\", 0);\\n        return result;\\n    }\\n    \\n    /* \\n    @param: num\\n    @param: target\\n    @param: start  start index in num\\n    @param: val  current value of expr\\n    @param: expr  expression\\n    @param: diff  difference\\n    */\\n    private void addOperators(String num, int target, int start, long val, String expr, long diff) {\\n        if (start == num.length()) {\\n            \\n            if (target == val) {\\n                result.add(expr);\\n            } \\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= num.length(); end++) {\\n            String cur = num.substring(start, end);\\n            \\n            if (cur.charAt(0) == \\'0\\' && cur.length() > 1) {\\n                // Invalid number\\n                continue;\\n            }\\n            \\n            long curNum = Long.parseLong(cur);\\n            \\n            if (start == 0) {\\n                // The first number\\n                addOperators(num, target, end, curNum, cur, curNum);\\n            } else {\\n                // + in front\\n                addOperators(num, target, end, val + curNum, expr + \"+\" + cur, curNum);\\n            \\n                // - in front\\n                addOperators(num, target, end, val - curNum, expr + \"-\" + cur, -curNum);\\n        \\n                // * in front\\n                addOperators(num, target, end, val - diff + diff * curNum, expr + \"*\" + cur, diff * curNum);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71984,
                "title": "ac-solution-c-short",
                "content": "    class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n    \\t\\tvector<string> ret;\\n    \\t\\tif (num.length() == 0) return ret;\\n    \\t\\thelp(num, target, ret, num[0] - '0', num.substr(0, 1), 1, 1);\\n    \\t\\treturn ret;\\n    \\t}\\n    \\n    \\tvoid help(const string num, int target, vector<string> & v, long long last, string s, int idx, int left) {\\n    \\t\\tif (target == last*left && idx == num.length())\\n    \\t\\t{\\n    \\t\\t\\tv.push_back(s);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\telse if (idx == num.length()) return;\\n    \\t\\telse {\\n    \\t\\t\\tif(last!=0) help(num, target, v, last * 10 + num[idx] - '0', s + num.substr(idx, 1), idx + 1, left);\\n    \\t\\t\\thelp(num, target, v, num[idx] - '0', s + '*' + num.substr(idx, 1), idx + 1, last*left);\\n    \\t\\t\\thelp(num, target - left*last, v, num[idx] - '0', s + '+' + num.substr(idx, 1), idx + 1, 1);\\n    \\t\\t\\thelp(num, target - left*last, v, num[idx] - '0', s + '-' + num.substr(idx, 1), idx + 1, -1);\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n    \\t\\tvector<string> ret;\\n    \\t\\tif (num.length() == 0) return ret;\\n    \\t\\thelp(num, target, ret, num[0] - '0', num.substr(0, 1), 1, 1);\\n    \\t\\treturn ret;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1830287,
                "title": "java-recursion-backtracking",
                "content": "Here i have used two recursions.\\n1) one recursion for splitting the string\\n2) one recusion for adding operators in between\\n```\\nclass Solution {\\n    String s;\\n    List<String>result;\\n    int target;\\n    public void operator(int i,int prev,long prod,long mid,String exp,List<Long>l){\\n        if(i==l.size()){\\n            if(mid+prod==target)\\n                result.add(exp);\\n            return;\\n        }\\n        if(prev==-1){\\n            operator(i+1,0,-1*l.get(i)*l.get(i-1),mid+l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else if(prev==1){\\n            operator(i+1,0,l.get(i)*l.get(i-1),mid-l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else{\\n            operator(i+1,0,prod*l.get(i),mid,exp+\"*\"+l.get(i),l);\\n        }\\n        operator(i+1,-1,0,mid+prod-l.get(i),exp+\"-\"+l.get(i),l);\\n        operator(i+1,1,0,mid+prod+l.get(i),exp+\"+\"+l.get(i),l);\\n    }\\n    public void rec(int in,List<Long>l){\\n        if(in==s.length()){\\n            operator(1,1,0,l.get(0),l.get(0)+\"\",l);\\n            return;\\n        }\\n        if(s.charAt(in)==\\'0\\'){\\n            l.add(0L);\\n            rec(in+1,l);\\n            l.remove(l.size()-1);\\n        }else{\\n            for(int i=in;i<s.length();i++){\\n                l.add(Long.parseLong(s.substring(in,i+1)));\\n                rec(i+1,l);\\n                l.remove(l.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        result=new ArrayList<>();\\n        this.s=num;\\n        this.target=target;\\n        rec(0,new ArrayList<>(30));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    String s;\\n    List<String>result;\\n    int target;\\n    public void operator(int i,int prev,long prod,long mid,String exp,List<Long>l){\\n        if(i==l.size()){\\n            if(mid+prod==target)\\n                result.add(exp);\\n            return;\\n        }\\n        if(prev==-1){\\n            operator(i+1,0,-1*l.get(i)*l.get(i-1),mid+l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else if(prev==1){\\n            operator(i+1,0,l.get(i)*l.get(i-1),mid-l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else{\\n            operator(i+1,0,prod*l.get(i),mid,exp+\"*\"+l.get(i),l);\\n        }\\n        operator(i+1,-1,0,mid+prod-l.get(i),exp+\"-\"+l.get(i),l);\\n        operator(i+1,1,0,mid+prod+l.get(i),exp+\"+\"+l.get(i),l);\\n    }\\n    public void rec(int in,List<Long>l){\\n        if(in==s.length()){\\n            operator(1,1,0,l.get(0),l.get(0)+\"\",l);\\n            return;\\n        }\\n        if(s.charAt(in)==\\'0\\'){\\n            l.add(0L);\\n            rec(in+1,l);\\n            l.remove(l.size()-1);\\n        }else{\\n            for(int i=in;i<s.length();i++){\\n                l.add(Long.parseLong(s.substring(in,i+1)));\\n                rec(i+1,l);\\n                l.remove(l.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        result=new ArrayList<>();\\n        this.s=num;\\n        this.target=target;\\n        rec(0,new ArrayList<>(30));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71951,
                "title": "very-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        void DFS(string num, long sum, string path, int pos, long pre, int val)\\n        {\\n            pre = pre*10 + num[pos]-'0';\\n            if(pre > INT_MAX) return;\\n            if(sum+pre*val ==0 && pos== num.size()-1) result.push_back(path+num[pos]);\\n            if(pos== num.size()-1) return;\\n            if(pre) DFS(num, sum, path+num[pos], pos+1, pre, val);\\n            DFS(num, sum+pre*val, path+num[pos]+'+', pos+1, 0, 1);\\n            DFS(num, sum+pre*val, path+num[pos]+'-', pos+1, 0, -1);\\n            DFS(num, sum, path+num[pos]+'*', pos+1, 0, val*pre);\\n        }\\n    \\n        vector<string> addOperators(string num, int target) {\\n            if(num.size() ==0) return {};\\n            DFS(num, -target, \"\", 0, 0, 1);\\n            return result;\\n        }\\n    private:\\n        vector<string> result;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void DFS(string num, long sum, string path, int pos, long pre, int val)\\n        {\\n            pre = pre*10 + num[pos]-'0';\\n            if(pre > INT_MAX) return;\\n            if(sum+pre*val ==0 && pos== num.size()-1) result.push_back(path+num[pos]);\\n            if(pos== num.size()-1) return;\\n            if(pre) DFS(num, sum, path+num[pos], pos+1, pre, val);\\n            DFS(num, sum+pre*val, path+num[pos]+'+', pos+1, 0, 1);\\n            DFS(num, sum+pre*val, path+num[pos]+'-', pos+1, 0, -1);\\n            DFS(num, sum, path+num[pos]+'*', pos+1, 0, val*pre);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71986,
                "title": "17-line-accepted-c-dfs-solution",
                "content": "    public IList<string> AddOperators(string num, int target) {\\n        IList<string> result = new List<string>();\\n        dfs(result, \"\", 0, 0, num, target);\\n        return result;\\n    }\\n    private void dfs(IList<string> result, string curStr, long curSum, long curHead, string curNum, long target){\\n        if(curNum.Length == 0 && target - curSum - curHead == 0) result.Add(curStr);\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string strNum = curNum.Substring(0, i); long lNum = Convert.ToInt64(strNum);\\n            if(lNum > int.MaxValue || curHead > int.MaxValue) break;\\n            if(curStr.Length == 0) dfs(result, strNum, 0, lNum, curNum.Substring(i), target);\\n            else{\\n                dfs(result, curStr + \"*\" + strNum, curSum, curHead * lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"+\" + strNum, curSum + curHead, lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"-\" + strNum, curSum + curHead, -lNum, curNum.Substring(i), target);\\n            }\\n            if(lNum == 0) break; // avoid result of \"000\"/\"012\" etc\\n        }\\n    }\\n\\nThe first version accepted here.\\n\\n    public IList<string> AddOperators(string num, int target) {\\n        IList<long> curList = new List<long>();\\n        IList<string> result = new List<string>();\\n        if(num.Length == 0) return result;\\n        for(int i = 1; i < 11 && i <= num.Length; i++){\\n            string curStr = num.Substring(0, i);\\n            if(Convert.ToInt64(curStr) <= int.MaxValue){\\n                curList.Add(Convert.ToInt64(curStr));\\n                dfs(result, curStr, curList, num.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(curStr == \"0\") break;\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(IList<string> result, string curStr, IList<long> curList, string curNum, long target){\\n        if(curNum.Length == 0){\\n            foreach(int i in curList) target -= i;\\n            if(target == 0) result.Add(curStr);\\n            return;\\n        }\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string tmpNum = curNum.Substring(0, i);\\n            long lNum = Convert.ToInt64(tmpNum);\\n            if(lNum <= int.MaxValue){\\n                long tmp = curList[curList.Count - 1];\\n                curList[curList.Count - 1] *= lNum;\\n                if(Math.Abs(curList[curList.Count - 1]) <= int.MaxValue)\\n                    dfs(result, curStr + \"*\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = tmp;\\n\\n                curList.Add(lNum);\\n                dfs(result, curStr + \"+\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = -lNum;\\n                dfs(result, curStr + \"-\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(lNum == 0) break;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public IList<string> AddOperators(string num, int target) {\\n        IList<string> result = new List<string>();\\n        dfs(result, \"\", 0, 0, num, target);\\n        return result;\\n    }\\n    private void dfs(IList<string> result, string curStr, long curSum, long curHead, string curNum, long target){\\n        if(curNum.Length == 0 && target - curSum - curHead == 0) result.Add(curStr);\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string strNum = curNum.Substring(0, i); long lNum = Convert.ToInt64(strNum);\\n            if(lNum > int.MaxValue || curHead > int.MaxValue) break;\\n            if(curStr.Length == 0) dfs(result, strNum, 0, lNum, curNum.Substring(i), target);\\n            else{\\n                dfs(result, curStr + \"*\" + strNum, curSum, curHead * lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"+\" + strNum, curSum + curHead, lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"-\" + strNum, curSum + curHead, -lNum, curNum.Substring(i), target);\\n            }\\n            if(lNum == 0) break; // avoid result of \"000\"/\"012\" etc\\n        }\\n    }\\n\\nThe first version accepted here.\\n\\n    public IList<string> AddOperators(string num, int target) {\\n        IList<long> curList = new List<long>();\\n        IList<string> result = new List<string>();\\n        if(num.Length == 0) return result;\\n        for(int i = 1; i < 11 && i <= num.Length; i++){\\n            string curStr = num.Substring(0, i);\\n            if(Convert.ToInt64(curStr) <= int.MaxValue){\\n                curList.Add(Convert.ToInt64(curStr));\\n                dfs(result, curStr, curList, num.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(curStr == \"0\") break;\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(IList<string> result, string curStr, IList<long> curList, string curNum, long target){\\n        if(curNum.Length == 0){\\n            foreach(int i in curList) target -= i;\\n            if(target == 0) result.Add(curStr);\\n            return;\\n        }\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string tmpNum = curNum.Substring(0, i);\\n            long lNum = Convert.ToInt64(tmpNum);\\n            if(lNum <= int.MaxValue){\\n                long tmp = curList[curList.Count - 1];\\n                curList[curList.Count - 1] *= lNum;\\n                if(Math.Abs(curList[curList.Count - 1]) <= int.MaxValue)\\n                    dfs(result, curStr + \"*\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = tmp;\\n\\n                curList.Add(lNum);\\n                dfs(result, curStr + \"+\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = -lNum;\\n                dfs(result, curStr + \"-\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(lNum == 0) break;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1482147,
                "title": "java-backtracking-template-explained",
                "content": "**Idea:**\\n* Use backtracking to generate all possibilities\\n* If start = 0, there is no operand before current and no operation can be done with single operand, so just append to expression\\n* Else form the expression and calculate on the fly\\n* Multiplication is a special case because it has higher precedence over `+/-`. So subtract the previous number from the value of expression yet, then add the result to the product of previousNumber and current\\n* Calculate expression on the fly. Calculating after the genertion of complete expression is inefficient.\\n* Edge cases: \\n\\t* take` long` for calculations as the result can overflow\\n\\t* Only 0 can have a leading zero, every other number with a leading zero would be invalid (the break case)\\n\\n![image](https://assets.leetcode.com/users/images/e3298cec-e3b2-47a4-bd67-7cd9a7abcf2e_1632447794.322304.png)\\n**T/S:** O(n4\\u207F)/O(n), where n = size(num)\\n```\\npublic List<String> addOperators(String num, int target) {\\n\\tvar result = new ArrayList<String>();\\n\\taddOperators(num, target, 0, result, \"\", 0, 0);\\n\\treturn result;\\n}\\n\\nprivate void addOperators(String num, int target, int start, List<String> result, String expression, long valueYet, long previousNumber) {\\n\\tif (start == num.length() && valueYet == target)\\n\\t\\tresult.add(expression);\\n\\telse\\n\\t\\t// for each choice\\n\\t\\tfor (var i = start; i < num.length(); i++) {\\n\\t\\t\\tif (i != start && num.charAt(start) == \\'0\\')\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tvar current = Long.parseLong(num.substring(start, i + 1));\\n\\t\\n\\t\\t\\t// choose-explore-unchoose\\n\\t\\t\\tif (start == 0) {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + current, current, current);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"+\" + current, valueYet + current, current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"-\" + current, valueYet - current, -current);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar newValue = (valueYet - previousNumber) + (previousNumber * current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"*\" + current, newValue, previousNumber * current);\\n\\t\\t\\t}\\n\\t\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic List<String> addOperators(String num, int target) {\\n\\tvar result = new ArrayList<String>();\\n\\taddOperators(num, target, 0, result, \"\", 0, 0);\\n\\treturn result;\\n}\\n\\nprivate void addOperators(String num, int target, int start, List<String> result, String expression, long valueYet, long previousNumber) {\\n\\tif (start == num.length() && valueYet == target)\\n\\t\\tresult.add(expression);\\n\\telse\\n\\t\\t// for each choice\\n\\t\\tfor (var i = start; i < num.length(); i++) {\\n\\t\\t\\tif (i != start && num.charAt(start) == \\'0\\')\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tvar current = Long.parseLong(num.substring(start, i + 1));\\n\\t\\n\\t\\t\\t// choose-explore-unchoose\\n\\t\\t\\tif (start == 0) {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + current, current, current);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"+\" + current, valueYet + current, current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"-\" + current, valueYet - current, -current);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar newValue = (valueYet - previousNumber) + (previousNumber * current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"*\" + current, newValue, previousNumber * current);\\n\\t\\t\\t}\\n\\t\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1473359,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893132,
                "title": "faster-than-100-twice-optimization-explanation",
                "content": "Inspired by some great writers and code, \\nthis post is approximately faster than \\nprevious fastest DFS by 4x and previous fastest BFS by 2x. \\nIt makes time complexity from 4^(N) to 4^1/2(N). [(some ideas and analysis from MaskRay)](https://leetcode.com/problems/expression-add-operators/discuss/71975/Some-thoughts-on-the-algorithm%3A-SLR(1)-and-optimization%3A-meet-in-the-middle-(-spatial-data-structure))\\n\\nI\\'d like to share the surprising result and ideas to inspire others in simple words. \\n\\nThe basic solution is using DFS to tracking the results of each operator because the given string is not long. \\nMost writers\\' code is very short and quite understandable. \\nI suppose you have been very familiar with it. \\n\\nBut if the string is longer than current and old fashion can\\'t work well, \\nwe finally must optimize it. \\nMaybe you have found the runtime distribution is a wide range. (40ms ~7000+)\\n\\nIn short, \\nwe can ***use DP and symmetry as possible.***\\n\\nAs some posts mentioned, we can ***divide the string into first half and second half*** \\nbecause we can use operator + and -  to combine these two parts\\' results and decrease the search space. \\nIn other words, the results of the first half +(-) second half must be the target.\\nFor example, \\n(1+2) **+ (3-1)** = 5 or (1+2) **- (3-1)** = 5 is true.\\n\\nBesides, if we use DP meanwhile, it also can help ***combine some found results first.***\\n\\nAfter some attemps, I found BFS is more efficient in this task than DFS. (although using DFS is easier)\\nAt first look, I also think DFS is better. But when I tried to optimize, I found \\n***DFS is harder to deal with split concisely and manipulate index than BFS***, \\nespecially we need to create a DP table by indexes and split.\\n\\nAs for DP table, we reuse the same main function\\nto ***extract the second half\\'s results from the middle to the end*** for later check and combination. \\nAnd we ***only need to extract the results of positive +\"string\"*** because the negative -\"string\" is reverse of +\"string\".\\nFor example, \\n(1+2) **+ (3-1+2)**  and (1+2) **- (3-1+2)**, \\nbold parts\\' values are respectively +4 and -4, but combinations are the same.\\n\\nBesides, we also can use multiplication \\nbecause ***known partial result + current possible maximal operation(multiplication) must be greater than target***, \\notherwise we can\\'t use operator + or - to achieve the target afterwards. \\nThis can help us decrease the search space a lot.\\n\\nCode with clear comments step by step as below.\\nDP table, **preview**, is a nested hashmap, \\nstoring **{key string: { combination value: possible combination}}**\\n\\n```\\nclass Solution(object): # BFS, best 40 ms, most posts\\' results are around 700~6000+ ms\\n\\n    def addOperators(self, num, target):\\n        if not num: return []\\n\\n        # set the boolean for reusing the func(main search and creating DP)\\n        def BFS(num, cutEdge = False):\\n            firstValue = int(num[0])\\n            # (pre-result, pre-Sum, pre-operation, pre-Number\\'s value)\\n            queue = [(num[0], firstValue, firstValue, firstValue)]\\n\\n            for i, c in enumerate(num):\\n                if i == 0: continue\\n                newQ, v = [], int(c)\\n                for preString, preSum, preOP, preNum in queue:\\n                    # combine with previous num without operator\\n                    if preString[-1] != \\'0\\' or (len(preString) > 1 and preString[-2] not in (\\'-\\', \\'+\\', \\'*\\')):\\n                    # preOP / preNum * v: extract pre-operation to operate with current value\\n                        curOP = preOP * 10 + preOP / preNum * v\\n                        curSum = preSum - preOP + curOP\\n                        curVal = preNum * 10 + v\\n                        newQ.append([preString + c, curSum, curOP, curVal])\\n\\n                    # if current maximal possible num is less than remaining sum,\\n                    # there\\'s no result because only multiplication can create maximal num.\\n                    # use this line when main search, not creating DP\\n                    if not cutEdge and max(1, abs(preOP)) * int(num[i:]) < abs(target - preSum):\\n                        continue\\n\\n                    # new search of \"*\", \"+\", \"-\"\\n                    newQ.append([preString + \\'*\\' + c, preSum - preOP + preOP * v, preOP * v, v])\\n                    if num[i:] not in preview:\\n                        newQ.append([preString + \\'+\\' + c, preSum + v, v, v])   \\n                        newQ.append([preString + \\'-\\' + c, preSum - v, -v, v])\\n                    \\n                    # check and combine second part\\'s results of \"+\" and \"-\" when main search\\n                    if not cutEdge and i >= len(num)-half:\\n                        restSum = target - preSum\\n                        # if able to achieve target, + second part\\'s result directly\\n                        if restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][restSum]:\\n                                parseResult.append(preString + \"+\" + parse)\\n                        # we can reverse the results in DP for \"-\",\\n                        if -restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][-restSum]:\\n                                parse = parse.replace(\"-\", \" \").replace(\"+\", \"-\").replace(\" \", \"+\")\\n                                parseResult.append(preString + \"-\" + parse)\\n                queue = newQ\\n\\n            # collect cut edge results(DP) \\n            if cutEdge:\\n                result = defaultdict(list)\\n                for element in queue:\\n                    result[element[1]].append(element[0])\\n                return result\\n\\n            # main BFS\\'s result\\n            else: return queue         \\n        \\n        # cut string into two halves for preview(DP table)\\n        # { key string: { combination value: possible combination} } \\n        preview = {} \\n        half = len(num)//2 + 1\\n        for i in range(-half, 0):\\n            preview[num[i:]] = BFS(num[i:], True)\\n\\n        parseResult = [] \\n        return [e[0] for e in BFS(num) if e[1] == target] + parseResult\\n```\\nSome ideas are also from [bairongdong1](https://leetcode.com/problems/expression-add-operators/discuss/703797/Python-beat-100-84ms)\\n\\nThe method is similar to bidirectional BFS and works better than DFS \\nbecause we can use the partial results in the middle of the string to largely decrease the search space.\\n\\nIf we have concern about the memory, \\nwe also can adapt the DP preview, \\njust store the combinations\\' values, not including combinations. \\nIt still works well.\\n\\nBy the way,\\nSome people used eval() with string.\\nBut that\\'s less helpful.\\n```\\neval(\"1+2+3\")\\n100000 loops, best of 3: 4.6 \\xB5s per loop\\nint(\"1\")+int(\"2\")+int(\"3\")\\n1000000 loops, best of 3: 474 ns per loop\\n```\\n\\nWelcome suggestion, question and comments.\\nIf helpful, ***please upvote! Thanks a lot!***",
                "solutionTags": [],
                "code": "```\\nclass Solution(object): # BFS, best 40 ms, most posts\\' results are around 700~6000+ ms\\n\\n    def addOperators(self, num, target):\\n        if not num: return []\\n\\n        # set the boolean for reusing the func(main search and creating DP)\\n        def BFS(num, cutEdge = False):\\n            firstValue = int(num[0])\\n            # (pre-result, pre-Sum, pre-operation, pre-Number\\'s value)\\n            queue = [(num[0], firstValue, firstValue, firstValue)]\\n\\n            for i, c in enumerate(num):\\n                if i == 0: continue\\n                newQ, v = [], int(c)\\n                for preString, preSum, preOP, preNum in queue:\\n                    # combine with previous num without operator\\n                    if preString[-1] != \\'0\\' or (len(preString) > 1 and preString[-2] not in (\\'-\\', \\'+\\', \\'*\\')):\\n                    # preOP / preNum * v: extract pre-operation to operate with current value\\n                        curOP = preOP * 10 + preOP / preNum * v\\n                        curSum = preSum - preOP + curOP\\n                        curVal = preNum * 10 + v\\n                        newQ.append([preString + c, curSum, curOP, curVal])\\n\\n                    # if current maximal possible num is less than remaining sum,\\n                    # there\\'s no result because only multiplication can create maximal num.\\n                    # use this line when main search, not creating DP\\n                    if not cutEdge and max(1, abs(preOP)) * int(num[i:]) < abs(target - preSum):\\n                        continue\\n\\n                    # new search of \"*\", \"+\", \"-\"\\n                    newQ.append([preString + \\'*\\' + c, preSum - preOP + preOP * v, preOP * v, v])\\n                    if num[i:] not in preview:\\n                        newQ.append([preString + \\'+\\' + c, preSum + v, v, v])   \\n                        newQ.append([preString + \\'-\\' + c, preSum - v, -v, v])\\n                    \\n                    # check and combine second part\\'s results of \"+\" and \"-\" when main search\\n                    if not cutEdge and i >= len(num)-half:\\n                        restSum = target - preSum\\n                        # if able to achieve target, + second part\\'s result directly\\n                        if restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][restSum]:\\n                                parseResult.append(preString + \"+\" + parse)\\n                        # we can reverse the results in DP for \"-\",\\n                        if -restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][-restSum]:\\n                                parse = parse.replace(\"-\", \" \").replace(\"+\", \"-\").replace(\" \", \"+\")\\n                                parseResult.append(preString + \"-\" + parse)\\n                queue = newQ\\n\\n            # collect cut edge results(DP) \\n            if cutEdge:\\n                result = defaultdict(list)\\n                for element in queue:\\n                    result[element[1]].append(element[0])\\n                return result\\n\\n            # main BFS\\'s result\\n            else: return queue         \\n        \\n        # cut string into two halves for preview(DP table)\\n        # { key string: { combination value: possible combination} } \\n        preview = {} \\n        half = len(num)//2 + 1\\n        for i in range(-half, 0):\\n            preview[num[i:]] = BFS(num[i:], True)\\n\\n        parseResult = [] \\n        return [e[0] for e in BFS(num) if e[1] == target] + parseResult\\n```\n```\\neval(\"1+2+3\")\\n100000 loops, best of 3: 4.6 \\xB5s per loop\\nint(\"1\")+int(\"2\")+int(\"3\")\\n1000000 loops, best of 3: 474 ns per loop\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230225,
                "title": "python-solution",
                "content": "Time complexity: `O(n^2*3^n)`, space complexity: `O(n^2*3^n)`.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def recurse(idx, val, prev_val, ops):\\n            if idx == len(num):\\n                if val == target:\\n                    res.append(\"\".join(ops))\\n            else:\\n                curr_val = 0\\n                for i in range(idx, len(num)):\\n                    curr_val = 10*curr_val + int(num[i])\\n                    if idx == 0:\\n                        recurse(i+1, curr_val, curr_val, ops+[str(curr_val)])\\n                    else:\\n                        v = val - prev_val\\n                        recurse(i+1, v+prev_val*curr_val, prev_val*curr_val, ops+[\"*\"+str(curr_val)])\\n                        recurse(i+1, val+curr_val, curr_val, ops+[\"+\"+str(curr_val)])\\n                        recurse(i+1, val-curr_val, -curr_val, ops+[\"-\"+str(curr_val)])\\n                    if num[idx] == \"0\":\\n                        break\\n        res = []\\n        recurse(0, 0, 0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def recurse(idx, val, prev_val, ops):\\n            if idx == len(num):\\n                if val == target:\\n                    res.append(\"\".join(ops))\\n            else:\\n                curr_val = 0\\n                for i in range(idx, len(num)):\\n                    curr_val = 10*curr_val + int(num[i])\\n                    if idx == 0:\\n                        recurse(i+1, curr_val, curr_val, ops+[str(curr_val)])\\n                    else:\\n                        v = val - prev_val\\n                        recurse(i+1, v+prev_val*curr_val, prev_val*curr_val, ops+[\"*\"+str(curr_val)])\\n                        recurse(i+1, val+curr_val, curr_val, ops+[\"+\"+str(curr_val)])\\n                        recurse(i+1, val-curr_val, -curr_val, ops+[\"-\"+str(curr_val)])\\n                    if num[idx] == \"0\":\\n                        break\\n        res = []\\n        recurse(0, 0, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71899,
                "title": "swift-implementation-with-docs-and-full-comments",
                "content": "This is a variation on some solutions in this forum but written in Swift. This problem has a large number of permutations which I attempt to capture in the comments.\\n```\\nclass Solution {\\n    \\n    // Recursion \\n    // - Parameters:\\n    //     - results: String array of valid math operation strings to return\\n    //     - result: String with current operation string being constructed\\n    //     - digits: Int array with the individual digits\\n    //     - target: Int with the target operation final value\\n    //     - offset: Current position in the digits array\\n    //     - mr:     MR like a calculator holding the result of the last operation\\n    //     - prior:  Special param to help multiplication which is backward looking due to order of operations (BOMDAS)\\n    func dfs(_ results: inout [String], _ result: String, _ digits: [Int], _ target: Int, _ offset: Int, _ mr: Int, _ prior: Int) {\\n        \\n        // if we're evaluated all the digits, we're at the end of the recrusion\\n        if offset == digits.count {\\n            // save the result string if the MR value equal to our target\\n            if target == mr {\\n                results.append(result)\\n            }\\n            return\\n        }\\n        \\n        // walk the down digit array from the current offset\\n        for i in offset..<digits.count {\\n            // zeros are handled slightly differently\\n            // to account for 10, if we see a zero but we're not at the\\n            // current offset, we need to treat it like a 10\\n            // (the question is vague about this but it's in the examples)\\n            if i != offset && digits[offset] == 0 {\\n                break\\n            }\\n\\n            // build the current number from the digits\\n            var val = 0\\n            // i+1 is not bounded, so make sure we\\n            // don't exceed the digit array bounds\\n            for x in offset..<i+1 where x < digits.count {\\n                // increase the existing value of val by a power of 10 on each iteration\\n                val *= 10\\n                val += digits[x]\\n            }\\n            \\n            // if we're at the first digit, there's no operation possible\\n            if offset == 0 {\\n                // the first digit is simple, initialize the string and MR is digit\\n                dfs(&results, result + String(val), digits, target, i + 1, val, val)\\n            } else {\\n                // addition: add the digit to the string and add it to MR, track it in case we mul next\\n                dfs(&results, result + \"+\" + String(val), digits, target, i + 1, mr + val, val)\\n                // substraction: add the digit to the string and minus it from MR, track it in case we mul next\\n                dfs(&results, result + \"-\" + String(val), digits, target, i + 1, mr - val, -val)\\n                // multiplication: add the digit to the string, but we have an order of operations to deal with\\n                // BOMDAS, so minus the prior value and add the multiplied value to MR, track the multiplied value in prior\\n                dfs(&results, result + \"*\" + String(val), digits, target, i + 1, mr - prior + (prior * val), prior * val)\\n            }\\n        }\\n    }\\n    \\n    // the problem description is a bit vague, but we don't just\\n    // care about single digits, it's all possible numbers comprised \\n    // of those digits, this greatly increases the number of permutations\\n    // to O(n^2)\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var results: [String] = []\\n        \\n        // ensure we have evaluatble input\\n        if num.count == 0 {\\n            return results\\n        }\\n        \\n        // split the string into an array of digits\\n        let digits = Array(num).map({Int(String($0))!})\\n        \\n        // recurse from index zero\\n        dfs(&results, \"\", digits, target, 0, 0, 0)\\n        \\n        return results\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Recursion \\n    // - Parameters:\\n    //     - results: String array of valid math operation strings to return\\n    //     - result: String with current operation string being constructed\\n    //     - digits: Int array with the individual digits\\n    //     - target: Int with the target operation final value\\n    //     - offset: Current position in the digits array\\n    //     - mr:     MR like a calculator holding the result of the last operation\\n    //     - prior:  Special param to help multiplication which is backward looking due to order of operations (BOMDAS)\\n    func dfs(_ results: inout [String], _ result: String, _ digits: [Int], _ target: Int, _ offset: Int, _ mr: Int, _ prior: Int) {\\n        \\n        // if we're evaluated all the digits, we're at the end of the recrusion\\n        if offset == digits.count {\\n            // save the result string if the MR value equal to our target\\n            if target == mr {\\n                results.append(result)\\n            }\\n            return\\n        }\\n        \\n        // walk the down digit array from the current offset\\n        for i in offset..<digits.count {\\n            // zeros are handled slightly differently\\n            // to account for 10, if we see a zero but we're not at the\\n            // current offset, we need to treat it like a 10\\n            // (the question is vague about this but it's in the examples)\\n            if i != offset && digits[offset] == 0 {\\n                break\\n            }\\n\\n            // build the current number from the digits\\n            var val = 0\\n            // i+1 is not bounded, so make sure we\\n            // don't exceed the digit array bounds\\n            for x in offset..<i+1 where x < digits.count {\\n                // increase the existing value of val by a power of 10 on each iteration\\n                val *= 10\\n                val += digits[x]\\n            }\\n            \\n            // if we're at the first digit, there's no operation possible\\n            if offset == 0 {\\n                // the first digit is simple, initialize the string and MR is digit\\n                dfs(&results, result + String(val), digits, target, i + 1, val, val)\\n            } else {\\n                // addition: add the digit to the string and add it to MR, track it in case we mul next\\n                dfs(&results, result + \"+\" + String(val), digits, target, i + 1, mr + val, val)\\n                // substraction: add the digit to the string and minus it from MR, track it in case we mul next\\n                dfs(&results, result + \"-\" + String(val), digits, target, i + 1, mr - val, -val)\\n                // multiplication: add the digit to the string, but we have an order of operations to deal with\\n                // BOMDAS, so minus the prior value and add the multiplied value to MR, track the multiplied value in prior\\n                dfs(&results, result + \"*\" + String(val), digits, target, i + 1, mr - prior + (prior * val), prior * val)\\n            }\\n        }\\n    }\\n    \\n    // the problem description is a bit vague, but we don't just\\n    // care about single digits, it's all possible numbers comprised \\n    // of those digits, this greatly increases the number of permutations\\n    // to O(n^2)\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var results: [String] = []\\n        \\n        // ensure we have evaluatble input\\n        if num.count == 0 {\\n            return results\\n        }\\n        \\n        // split the string into an array of digits\\n        let digits = Array(num).map({Int(String($0))!})\\n        \\n        // recurse from index zero\\n        dfs(&results, \"\", digits, target, 0, 0, 0)\\n        \\n        return results\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71960,
                "title": "shortest-c-solution",
                "content": "    //cur: current position in s\\n    //cnum: number formed by s[position of previous op...cur]\\n    //num: result of a1*a2*a3... before previous op\\n    //res: result of previous calculation, not including num\\n    //str: current string\\n    //s:   original string\\n    //when we add an op at cur:\\n    //\\t\\t1) +: num=1, res=res+num*cnum\\n    //\\t\\t2) -: num=-1, res=res+num*cnum\\n    //\\t\\t3) *: num=num*cnum, res=res\\n\\n    class Solution {\\n    public:\\n    \\tvector<string>ans;\\n    \\tvoid dfs(int cur, long long cnum, long long num, long long res, string str, string s){\\n    \\t\\tcnum = cnum * 10 + s[cur] - '0';\\n    \\t\\tif (cur+1 == s.size()){\\n    \\t\\t\\tif (res + num*cnum == 0)ans.push_back(str + s[cur]);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (cnum != 0)dfs(cur + 1, cnum, num, res, str + s[cur], s);//no op here and no leading 0\\n    \\t\\tdfs(cur + 1, 0, 1, res + num*cnum, str + s[cur] + '+', s);//+\\n    \\t\\tdfs(cur + 1, 0, -1, res + num*cnum, str + s[cur] + '-', s);//-\\n    \\t\\tdfs(cur + 1, 0, num*cnum, res, str + s[cur] + '*', s);//* \\n    \\t}\\n    \\tvector<string> addOperators(string num, int target) {\\n    \\t\\tif (num.size() > 0)dfs(0, 0, 1, -(long long)target, \"\", num);\\n    \\t\\treturn ans;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<string>ans;\\n    \\tvoid dfs(int cur, long long cnum, long long num, long long res, string str, string s){\\n    \\t\\tcnum = cnum * 10 + s[cur] - '0';\\n    \\t\\tif (cur+1 == s.size()){\\n    \\t\\t\\tif (res + num*cnum == 0)ans.push_back(str + s[cur]);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 71980,
                "title": "accepted-java-solution-use-the-function-in-basic-calculateii",
                "content": "**The basic idea is to generate all possible expressions using backtrace.**\\n\\n    public List<String> addOperators(String num, int target) {\\n        if(num.length() == 0) return new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        ArrayList<String> ops = new  ArrayList<String>();\\n        ops.add(\"+\");ops.add(\"-\");ops.add(\"*\");ops.add(\"\");\\n        gen(num,0,\"\",res,ops,target,num.charAt(0) == '0');\\n        return res;\\n    }\\n    // the last digit in num is treated separately,beacase we can not add operator after the last digit\\n    public void gen(String num,int index,String cur,List<String> res,ArrayList<String> operators,int target,boolean flag){\\n        if(index == num.length()-1){\\n            String tmp = new String(cur+num.charAt(index));\\n            // when the situation is 10+01 this is not valid, and 100+1 is valid, special case. \\n            if( (cur.length() == 0 ||  (!flag && Character.isDigit(cur.charAt(cur.length()-1))) || !Character.isDigit(cur.charAt(cur.length()-1)) )&&calculate(tmp) == target){\\n                res.add(tmp);\\n            }\\n        }else {\\n            for(int j=0;j<operators.size();j++){\\n                // the last element in operators is \"\" .If the situation is 123+03\\n                // this is not valid , but 123+10003 is valid, if the index point to last '0'\\n                // flag is used to determine whether we can use concat operator\\n                if(flag && j == operators.size()-1) continue;\\n                // set the flag if we use \"+\",\"-\",\"*\" operator\\n                gen(num,index+1,cur+num.charAt(index)+operators.get(j),res,operators,target, j== operators.size()-1 ? flag:num.charAt(index+1) == '0' );\\n            }\\n        }\\n    }\\n    //use long to pass the special case \\n    public int calculate(String s) {\\n        s = s+\"+\";\\n        long res = 0;\\n        long val = 0;\\n        char sign = '+';\\n        Stack<Long> st = new Stack<Long>();\\n        for(int i=0;i<s.length();i++){\\n            if(Character.isDigit(s.charAt(i))){\\n                val = val*10+s.charAt(i)-'0';\\n            }else if(s.charAt(i) !=' '){\\n                switch(sign){\\n                    case '+':\\n                        st.push(val);\\n                        break;\\n                    case '-':\\n                        st.push(-val);\\n                        break;\\n                    case '*':\\n                        st.push(st.pop()*val);\\n                        break;\\n                    case '/':\\n                        st.push(st.pop()/val);\\n                        break;\\n                }\\n                val = 0;\\n                sign = s.charAt(i);\\n            }\\n        }\\n        for(long x:st) res+=x;\\n        return res > Integer.MAX_VALUE ? Integer.MAX_VALUE:(int) res;\\n    }",
                "solutionTags": [],
                "code": "**The basic idea is to generate all possible expressions using backtrace.**\\n\\n    public List<String> addOperators(String num, int target) {\\n        if(num.length() == 0) return new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        ArrayList<String> ops = new  ArrayList<String>();\\n        ops.add(\"+\");ops.add(\"-\");ops.add(\"*\");ops.add(\"\");\\n        gen(num,0,\"\",res,ops,target,num.charAt(0) == '0');\\n        return res;\\n    }\\n    // the last digit in num is treated separately,beacase we can not add operator after the last digit\\n    public void gen(String num,int index,String cur,List<String> res,ArrayList<String> operators,int target,boolean flag){\\n        if(index == num.length()-1){\\n            String tmp = new String(cur+num.charAt(index));\\n            // when the situation is 10+01 this is not valid, and 100+1 is valid, special case. \\n            if( (cur.length() == 0 ||  (!flag && Character.isDigit(cur.charAt(cur.length()-1))) || !Character.isDigit(cur.charAt(cur.length()-1)) )&&calculate(tmp) == target){\\n                res.add(tmp);\\n            }\\n        }else {\\n            for(int j=0;j<operators.size();j++){\\n                // the last element in operators is \"\" .If the situation is 123+03\\n                // this is not valid , but 123+10003 is valid, if the index point to last '0'\\n                // flag is used to determine whether we can use concat operator\\n                if(flag && j == operators.size()-1) continue;\\n                // set the flag if we use \"+\",\"-\",\"*\" operator\\n                gen(num,index+1,cur+num.charAt(index)+operators.get(j),res,operators,target, j== operators.size()-1 ? flag:num.charAt(index+1) == '0' );\\n            }\\n        }\\n    }\\n    //use long to pass the special case \\n    public int calculate(String s) {\\n        s = s+\"+\";\\n        long res = 0;\\n        long val = 0;\\n        char sign = '+';\\n        Stack<Long> st = new Stack<Long>();\\n        for(int i=0;i<s.length();i++){\\n            if(Character.isDigit(s.charAt(i))){\\n                val = val*10+s.charAt(i)-'0';\\n            }else if(s.charAt(i) !=' '){\\n                switch(sign){\\n                    case '+':\\n                        st.push(val);\\n                        break;\\n                    case '-':\\n                        st.push(-val);\\n                        break;\\n                    case '*':\\n                        st.push(st.pop()*val);\\n                        break;\\n                    case '/':\\n                        st.push(st.pop()/val);\\n                        break;\\n                }\\n                val = 0;\\n                sign = s.charAt(i);\\n            }\\n        }\\n        for(long x:st) res+=x;\\n        return res > Integer.MAX_VALUE ? Integer.MAX_VALUE:(int) res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2799103,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        recursion(ans, num, target, \"\", 0, 0, 0 );\\n        return ans;\\n    }\\n    \\n    void recursion(vector<string>& ans, const string& num, const int& target, string expression, int idx, int prevNum, long long curTotal){\\n        int n = num.size();\\n        if(idx==n){\\n            if(curTotal==target){\\n                ans.push_back(expression);\\n            }\\n            return;\\n        }\\n        string curNumStr = \"\";\\n        long long curNum = 0;\\n        for(int i = idx; i<n; i++){\\n            if(i>idx && num[idx]==\\'0\\')break;\\n            curNumStr+=num[i];\\n            curNum = curNum*10+(num[i]-\\'0\\');\\n            // 2345\\n            if(idx==0){\\n                recursion(ans, num, target, expression+curNumStr, i+1, curNum, curTotal+curNum);\\n            }\\n            else{\\n                recursion(ans, num, target, expression+\"+\"+curNumStr, i+1, curNum, curTotal+curNum);\\n                recursion(ans, num, target, expression+\"-\"+curNumStr, i+1, -curNum, curTotal-curNum);\\n                recursion(ans, num, target, expression+\"*\"+curNumStr, i+1, prevNum*curNum, curTotal-prevNum+prevNum*curNum);\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        recursion(ans, num, target, \"\", 0, 0, 0 );\\n        return ans;\\n    }\\n    \\n    void recursion(vector<string>& ans, const string& num, const int& target, string expression, int idx, int prevNum, long long curTotal){\\n        int n = num.size();\\n        if(idx==n){\\n            if(curTotal==target){\\n                ans.push_back(expression);\\n            }\\n            return;\\n        }\\n        string curNumStr = \"\";\\n        long long curNum = 0;\\n        for(int i = idx; i<n; i++){\\n            if(i>idx && num[idx]==\\'0\\')break;\\n            curNumStr+=num[i];\\n            curNum = curNum*10+(num[i]-\\'0\\');\\n            // 2345\\n            if(idx==0){\\n                recursion(ans, num, target, expression+curNumStr, i+1, curNum, curTotal+curNum);\\n            }\\n            else{\\n                recursion(ans, num, target, expression+\"+\"+curNumStr, i+1, curNum, curTotal+curNum);\\n                recursion(ans, num, target, expression+\"-\"+curNumStr, i+1, -curNum, curTotal-curNum);\\n                recursion(ans, num, target, expression+\"*\"+curNumStr, i+1, prevNum*curNum, curTotal-prevNum+prevNum*curNum);\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71950,
                "title": "typical-backtracking-solution-with-detailed-explanation-in-c",
                "content": "### Solution\\n\\n#### Analysis\\nTypical backtracking problem as it is. Try to split the string into small blocks and then meantime try different operators among them.\\n\\n- from a starting position, we can try different valid length for the current number but if the length is bigger than 1 and the first digit is zero then just stop;\\n- using different operators to connect the current number, calculate and then store them in a temporary string for the next number till the end;\\n- but when we try `*`, we have to be more careful since multiplier will associate its previous number and has higher precedence, so we as a result have to record its previous number; but this will require us to handle it delicately when we are inserting `+ or -`, as for `+` we can just put the number as previous but as to `-`, we will need to set `-number` as previous; because we have to subtract the previous number first when inserting `*` - inserting means we are do the calculation with the current number here;\\n- since the target is an `int`, so when the number is larger than INT_MAX, we should just stop there.\\n\\n#### Improvements\\n- there will be numbers collected larger than INT_MAX, so we have to adopt `long` - long long here is unnecessary;\\n- collecting the number one character at a time is more efficient to convert the substring directly to integer using `stol`;\\n- using temporary substring to replace `to_string(number)` will save lots of converting time;\\n- actually we can just use one temporary string and append the digit instead of retrieving the substring each time.\\n\\nThe whole solution in C++ is as follows.\\n\\n```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    void traverse(const string s, int pos, long current, long pre, int sum, string path, vector<string>& v)\\n    {\\n        if(sLen == pos) { if(current == sum) v.push_back(path); return ; }\\n        long num = 0;\\n        string t;\\n        for(int i = pos; i < sLen; ++i)\\n        {\\n            if(i-pos>0 && s[pos]=='0') return ;\\n            t += s[i];\\n            num = 10*num + s[i]-'0';\\n            if(num > INT_MAX) return ;\\n            if(pos == 0) traverse(s, i+1, num, num, sum, t, v);\\n            else\\n            {\\n                traverse(s, i+1, current+num, num, sum, path+\"+\"+t, v);\\n                traverse(s, i+1, current-num, -num, sum, path+\"-\"+t, v);\\n                traverse(s, i+1, current-pre+pre*num, pre*num, sum, path+\"*\"+t, v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> addOperators(string s, int target) {\\n        sLen = s.length();\\n        vector<string> v;\\n        traverse(s, 0, 0, 0, target, \"\", v);\\n        return v;\\n    }\\n};\\n```\\n\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    void traverse(const string s, int pos, long current, long pre, int sum, string path, vector<string>& v)\\n    {\\n        if(sLen == pos) { if(current == sum) v.push_back(path); return ; }\\n        long num = 0;\\n        string t;\\n        for(int i = pos; i < sLen; ++i)\\n        {\\n            if(i-pos>0 && s[pos]=='0') return ;\\n            t += s[i];\\n            num = 10*num + s[i]-'0';\\n            if(num > INT_MAX) return ;\\n            if(pos == 0) traverse(s, i+1, num, num, sum, t, v);\\n            else\\n            {\\n                traverse(s, i+1, current+num, num, sum, path+\"+\"+t, v);\\n                traverse(s, i+1, current-num, -num, sum, path+\"-\"+t, v);\\n                traverse(s, i+1, current-pre+pre*num, pre*num, sum, path+\"*\"+t, v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> addOperators(string s, int target) {\\n        sLen = s.length();\\n        vector<string> v;\\n        traverse(s, 0, 0, 0, target, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236396,
                "title": "282-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStep-by-step explanation:\\n\\n1. The input to the function is a string num and an integer target, representing the number to be expressed and the target value to be achieved, respectively.\\n2. The function initializes an empty list ans to store all possible expressions that evaluate to the target value.\\n3. The function defines a DFS (depth-first search) function dfs to generate all possible expressions.\\n4. The DFS function takes four parameters: start represents the current index in the string num, prev represents the previous operand value, eval represents the current evaluated value, and path represents the list of operands and operators that form the current expression.\\n5. The DFS function uses recursion to generate all possible expressions. At each recursive call, it evaluates the expression formed so far, and if the evaluation equals the target value, it adds the expression to the answer list.\\n6. The DFS function iterates over all possible operands starting from the current index start, and for each operand, it iterates over all possible operators (+, -, *) and generates new expressions by appending the current operand and operator to the current path, and updating the previous operand value, evaluated value, and current index accordingly.\\n7. The DFS function terminates when the current index reaches the end of the string num.\\n8. The main function addOperators starts the DFS with initial parameters start=0, prev=0, eval=0, and path=[], and\\n# Complexity\\n- Time complexity:\\n87.49%\\n\\n- Space complexity:\\n78.86%\\n\\n# Code\\n```\\nclass Solution:\\n  def addOperators(self, num: str, target: int) -> List[str]:\\n    ans = [] # list to store all possible expressions that evaluate to the target\\n\\n    # DFS function to generate all possible expressions\\n    # start: current index in num\\n    # prev: previous operand value\\n    # eval: current evaluated value\\n    # path: list to store current expression\\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\\n      # base case: reached end of num\\n      if start == len(num):\\n        # check if current evaluation equals target\\n        if eval == target:\\n          # add current expression to the answer list\\n          ans.append(\\'\\'.join(path))\\n        return\\n\\n      # iterate over all possible operands from current index\\n      for i in range(start, len(num)):\\n        # special case: ignore operands starting with 0, except 0 itself\\n        if i > start and num[start] == \\'0\\':\\n          return\\n        s = num[start:i + 1]\\n        curr = int(s)\\n        # special case: first operand, simply add it to the path and evaluate\\n        if start == 0:\\n          path.append(s)\\n          dfs(i + 1, curr, curr, path)\\n          path.pop()\\n        # general case: iterate over all possible operators and operands\\n        else:\\n          for op in [\\'+\\', \\'-\\', \\'*\\']:\\n            path.append(op + s)\\n            # addition: add current operand to evaluated value\\n            if op == \\'+\\':\\n              dfs(i + 1, curr, eval + curr, path)\\n            # subtraction: subtract current operand from evaluated value\\n            elif op == \\'-\\':\\n              dfs(i + 1, -curr, eval - curr, path)\\n            # multiplication: multiply current operand with previous operand and update evaluated value\\n            else:\\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\\n            path.pop()\\n\\n    # start DFS with initial parameters\\n    dfs(0, 0, 0, [])\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n  def addOperators(self, num: str, target: int) -> List[str]:\\n    ans = [] # list to store all possible expressions that evaluate to the target\\n\\n    # DFS function to generate all possible expressions\\n    # start: current index in num\\n    # prev: previous operand value\\n    # eval: current evaluated value\\n    # path: list to store current expression\\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\\n      # base case: reached end of num\\n      if start == len(num):\\n        # check if current evaluation equals target\\n        if eval == target:\\n          # add current expression to the answer list\\n          ans.append(\\'\\'.join(path))\\n        return\\n\\n      # iterate over all possible operands from current index\\n      for i in range(start, len(num)):\\n        # special case: ignore operands starting with 0, except 0 itself\\n        if i > start and num[start] == \\'0\\':\\n          return\\n        s = num[start:i + 1]\\n        curr = int(s)\\n        # special case: first operand, simply add it to the path and evaluate\\n        if start == 0:\\n          path.append(s)\\n          dfs(i + 1, curr, curr, path)\\n          path.pop()\\n        # general case: iterate over all possible operators and operands\\n        else:\\n          for op in [\\'+\\', \\'-\\', \\'*\\']:\\n            path.append(op + s)\\n            # addition: add current operand to evaluated value\\n            if op == \\'+\\':\\n              dfs(i + 1, curr, eval + curr, path)\\n            # subtraction: subtract current operand from evaluated value\\n            elif op == \\'-\\':\\n              dfs(i + 1, -curr, eval - curr, path)\\n            # multiplication: multiply current operand with previous operand and update evaluated value\\n            else:\\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\\n            path.pop()\\n\\n    # start DFS with initial parameters\\n    dfs(0, 0, 0, [])\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471816,
                "title": "10-lines-clean-and-easy-to-understand-solution-in-c",
                "content": "General idea would be the same as most solution but the code is much more clean, concise and easier to understand than most of the top voted solution. \\n\\nKey idea to make everything more concise is to separate the multiplier accumulated using a variable.\\n\\n```\\nclass Solution {\\nprivate:\\n    string num;\\n    int target;\\n    vector<string> allAnswer;\\n    \\npublic:\\n\\t/*\\n\\t\\ti:          current index of num to operates on\\n\\t\\texpression: current expression so far\\n\\t\\tsum:        the partial sum before the last \\'+\\' or \\'-\\' operators\\n\\t\\tcurNum:     the last operand\\n\\t\\tmultiplier: the multiplier to the last operand\\n\\t*/\\n    void add(int i, string expression, long long sum, long long curNum, long long multiplier) {\\n        if(i == num.size()) {\\n            if(sum + multiplier * curNum == target)\\n                allAnswer.push_back(expression);\\n            return;\\n        }\\n        \\n        if(curNum != 0)\\n            add(i+1, expression + num[i], sum, curNum * 10 + (num[i]-\\'0\\'), multiplier);\\n        \\n        add(i+1, expression + \"+\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', 1);\\n        add(i+1, expression + \"-\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', -1);\\n        add(i+1, expression + \"*\" + num[i], sum, num[i]-\\'0\\', multiplier * curNum);\\n    };\\n    \\n    vector<string> addOperators(string num, int target) {\\n        this->num = num;\\n        this->target = target;\\n        \\n        add(1, num.substr(0, 1), 0, num[0]-\\'0\\', 1);\\n        return allAnswer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    string num;\\n    int target;\\n    vector<string> allAnswer;\\n    \\npublic:\\n\\t/*\\n\\t\\ti:          current index of num to operates on\\n\\t\\texpression: current expression so far\\n\\t\\tsum:        the partial sum before the last \\'+\\' or \\'-\\' operators\\n\\t\\tcurNum:     the last operand\\n\\t\\tmultiplier: the multiplier to the last operand\\n\\t*/\\n    void add(int i, string expression, long long sum, long long curNum, long long multiplier) {\\n        if(i == num.size()) {\\n            if(sum + multiplier * curNum == target)\\n                allAnswer.push_back(expression);\\n            return;\\n        }\\n        \\n        if(curNum != 0)\\n            add(i+1, expression + num[i], sum, curNum * 10 + (num[i]-\\'0\\'), multiplier);\\n        \\n        add(i+1, expression + \"+\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', 1);\\n        add(i+1, expression + \"-\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', -1);\\n        add(i+1, expression + \"*\" + num[i], sum, num[i]-\\'0\\', multiplier * curNum);\\n    };\\n    \\n    vector<string> addOperators(string num, int target) {\\n        this->num = num;\\n        this->target = target;\\n        \\n        add(1, num.substr(0, 1), 0, num[0]-\\'0\\', 1);\\n        return allAnswer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470261,
                "title": "python3-a-super-easy-cheat-solution-a-general-approach-for-all-languages",
                "content": "Using the `eval` function makes this question from hard to medium.\\n- `i` is the current index\\n- `s` is the current temporary string\\n- leading is the leading character, right after \\n\\t- the start, or,\\n\\t- an operator like `+` or `-` or `*`\\n\\n`leading` is important since it let\\'s us skip over sequences starting from 0, as in `05` or `009`. And the rest is classic recursion.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if eval(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```\\n\\nWe can do a manual computation for `eval` and write our own function\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def evaluate(s):\\n            a = []\\n            temp = \"\"\\n            for c in s:\\n                if \\'0\\' <= c <= \\'9\\': \\n                    temp += c\\n                else:\\n                    a.append(int(temp))\\n                    a.append(c)\\n                    temp = \"\"\\n            a.append(int(temp))\\n            \\n            total = a[0]\\n            prev = a[0]\\n            for i in range(len(a)-1):\\n                item = a[i]\\n                if item == \\'+\\':\\n                    total = total + a[i+1]\\n                    prev = a[i+1]\\n                elif item == \\'-\\':\\n                    total = total - a[i+1]\\n                    prev = -a[i+1]\\n                elif item == \\'*\\':\\n                    total = total - prev + prev * a[i+1]\\n                    prev = prev * a[i+1]\\n            return total\\n        \\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if evaluate(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n            \\n        \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if eval(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def evaluate(s):\\n            a = []\\n            temp = \"\"\\n            for c in s:\\n                if \\'0\\' <= c <= \\'9\\': \\n                    temp += c\\n                else:\\n                    a.append(int(temp))\\n                    a.append(c)\\n                    temp = \"\"\\n            a.append(int(temp))\\n            \\n            total = a[0]\\n            prev = a[0]\\n            for i in range(len(a)-1):\\n                item = a[i]\\n                if item == \\'+\\':\\n                    total = total + a[i+1]\\n                    prev = a[i+1]\\n                elif item == \\'-\\':\\n                    total = total - a[i+1]\\n                    prev = -a[i+1]\\n                elif item == \\'*\\':\\n                    total = total - prev + prev * a[i+1]\\n                    prev = prev * a[i+1]\\n            return total\\n        \\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if evaluate(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n            \\n        \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275613,
                "title": "recursive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> result;\\n\\n    vector<string> addOperators(string num, int target) \\n    {     \\n        solve(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n    \\n    void solve(string num, int target, int start, string str, long sum, long last)\\n    {\\n        if(num.size() == start)\\n        {\\n            if(target == sum)\\n                result.push_back(str);\\n            return;\\n        }\\n        \\n        long x = 0;\\n        string ret = \"\";\\n        \\n        for(int i=start; i<num.size(); ++i)\\n        {\\n            x = x*10 + num[i]-\\'0\\';\\n            ret += num[i]; \\n            \\n            if(start == 0)\\n                solve(num, target, i+1, str+ret, x, x);\\n            \\n            else\\n            {\\n                solve(num, target, i+1, str+\"*\"+ret, sum-last+x*last, x*last);\\n                solve(num, target, i+1, str+\"+\"+ret, sum+x, x);\\n                solve(num, target, i+1, str+\"-\"+ret, sum-x, -x);\\n            } \\n            \\n            if(x == 0)\\n                break; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> result;\\n\\n    vector<string> addOperators(string num, int target) \\n    {     \\n        solve(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n    \\n    void solve(string num, int target, int start, string str, long sum, long last)\\n    {\\n        if(num.size() == start)\\n        {\\n            if(target == sum)\\n                result.push_back(str);\\n            return;\\n        }\\n        \\n        long x = 0;\\n        string ret = \"\";\\n        \\n        for(int i=start; i<num.size(); ++i)\\n        {\\n            x = x*10 + num[i]-\\'0\\';\\n            ret += num[i]; \\n            \\n            if(start == 0)\\n                solve(num, target, i+1, str+ret, x, x);\\n            \\n            else\\n            {\\n                solve(num, target, i+1, str+\"*\"+ret, sum-last+x*last, x*last);\\n                solve(num, target, i+1, str+\"+\"+ret, sum+x, x);\\n                solve(num, target, i+1, str+\"-\"+ret, sum-x, -x);\\n            } \\n            \\n            if(x == 0)\\n                break; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395651,
                "title": "python-solution-with-step-by-step-inline-explanation",
                "content": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:        \\n        def recurse(i, pre, cur, val, eq):\\n            \"\"\"\\n            There are four types of operations:\\n                1. Digit concatenation to form a number\\n                2. Addition\\n                3. Subtraction\\n                4. Multiplication\\n\\n            i int: cursor\\n            pre int: previous operand\\n            cur int: current operand\\n            val int: final result so far\\n            eq list: equation components\\n            \"\"\"\\n            # when the cursor reaches to the end of the given string\\n            if i == len(num):\\n                # we check:\\n                #   1. if the final result is equal to the target\\n                #   2. if the current operand is already evaluated\\n                # if both requirements met, the equation is qualified\\n                if val == target and cur == 0:\\n                    res.append(\\'\\'.join(map(str, eq[1:])))\\n                return\\n            \\n            # append the new digit to the current operand\\n            cur = cur * 10 + int(num[i])\\n            i += 1\\n\\n            # 1. Digit concatenation\\n            # it is only possible when the current operand is greater than 0, in \\n            # which case the operand is led by a non-zero digit. \\n            if cur > 0:\\n                # by concatenating digits, the previous operand, final result and \\n                # equation remain the same, while the current operand is updated \\n                # but yet evaluated\\n                recurse(i, pre, cur, val, eq)\\n            \\n            # For the rest operations, the current operand will be evaluated w/ \\n            # different operators, and the result will be reflected in the final \\n            # result and the equation. Meanwhile, the current operand will be \\n            # used as the previous operand for the next recursion\\n\\n            # 2. Addition\\n            # append the addition sign and current operand to the equation\\n            eq += [\\'+\\', cur]\\n            # add the current operand to the final result, use it as the \\n            # previous operand and clear the current operand for the next \\n            # recursion\\n            recurse(i, cur, 0, val + cur, eq)\\n            # pop out the previous oprand and operator to reuse the equation \\n            # list\\n            eq.pop()\\n            eq.pop()\\n            \\n            # note that the first operand in the equation is treated as being \\n            # added to 0. So for the first operand, only addition is available. \\n            # When the equation is empty, it means the first operand is being \\n            # dealt with, and we should stop here\\n            if not eq:\\n                return\\n            \\n            # 3. Subtraction\\n            eq += [\\'-\\', cur]\\n            # similar to addition, but we subtract the current operand from the \\n            # final result, and use the reverse of the current operand as the \\n            # previous operand for the next recursion\\n            recurse(i, -cur, 0, val - cur, eq)\\n            eq.pop()\\n            eq.pop()\\n            \\n            # 4. Multiplication\\n            eq += [\\'*\\', cur]\\n            # the key difference is that multiplication has the priority over \\n            # additions and subtractions, and it is commutative (i.e. the order \\n            # of the operands doesn\\'t matter). Hence, regardless of the type of \\n            # operation done previously, we always reverse it and prioritize the \\n            # evaluation of the current one, since it enforces the priority if \\n            # the previous operation is addition or subtraction, but do no harm \\n            # if multiplication (`a*b*c` will becomes `c*b*a`, which gives the \\n            # same result)\\n            cur *= pre \\n            # in practice, we subtract the previous operand from the final \\n            # result to reverse the previous operation and multiply it with the \\n            # current one. Then we add the result to the final result. \\n            recurse(i, cur, 0, val - pre + cur, eq)\\n            eq.pop()\\n            eq.pop()\\n        \\n        res = []\\n        recurse(0, 0, 0, 0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:        \\n        def recurse(i, pre, cur, val, eq):\\n            \"\"\"\\n            There are four types of operations:\\n                1. Digit concatenation to form a number\\n                2. Addition\\n                3. Subtraction\\n                4. Multiplication\\n\\n            i int: cursor\\n            pre int: previous operand\\n            cur int: current operand\\n            val int: final result so far\\n            eq list: equation components\\n            \"\"\"\\n            # when the cursor reaches to the end of the given string\\n            if i == len(num):\\n                # we check:\\n                #   1. if the final result is equal to the target\\n                #   2. if the current operand is already evaluated\\n                # if both requirements met, the equation is qualified\\n                if val == target and cur == 0:\\n                    res.append(\\'\\'.join(map(str, eq[1:])))\\n                return\\n            \\n            # append the new digit to the current operand\\n            cur = cur * 10 + int(num[i])\\n            i += 1\\n\\n            # 1. Digit concatenation\\n            # it is only possible when the current operand is greater than 0, in \\n            # which case the operand is led by a non-zero digit. \\n            if cur > 0:\\n                # by concatenating digits, the previous operand, final result and \\n                # equation remain the same, while the current operand is updated \\n                # but yet evaluated\\n                recurse(i, pre, cur, val, eq)\\n            \\n            # For the rest operations, the current operand will be evaluated w/ \\n            # different operators, and the result will be reflected in the final \\n            # result and the equation. Meanwhile, the current operand will be \\n            # used as the previous operand for the next recursion\\n\\n            # 2. Addition\\n            # append the addition sign and current operand to the equation\\n            eq += [\\'+\\', cur]\\n            # add the current operand to the final result, use it as the \\n            # previous operand and clear the current operand for the next \\n            # recursion\\n            recurse(i, cur, 0, val + cur, eq)\\n            # pop out the previous oprand and operator to reuse the equation \\n            # list\\n            eq.pop()\\n            eq.pop()\\n            \\n            # note that the first operand in the equation is treated as being \\n            # added to 0. So for the first operand, only addition is available. \\n            # When the equation is empty, it means the first operand is being \\n            # dealt with, and we should stop here\\n            if not eq:\\n                return\\n            \\n            # 3. Subtraction\\n            eq += [\\'-\\', cur]\\n            # similar to addition, but we subtract the current operand from the \\n            # final result, and use the reverse of the current operand as the \\n            # previous operand for the next recursion\\n            recurse(i, -cur, 0, val - cur, eq)\\n            eq.pop()\\n            eq.pop()\\n            \\n            # 4. Multiplication\\n            eq += [\\'*\\', cur]\\n            # the key difference is that multiplication has the priority over \\n            # additions and subtractions, and it is commutative (i.e. the order \\n            # of the operands doesn\\'t matter). Hence, regardless of the type of \\n            # operation done previously, we always reverse it and prioritize the \\n            # evaluation of the current one, since it enforces the priority if \\n            # the previous operation is addition or subtraction, but do no harm \\n            # if multiplication (`a*b*c` will becomes `c*b*a`, which gives the \\n            # same result)\\n            cur *= pre \\n            # in practice, we subtract the previous operand from the final \\n            # result to reverse the previous operation and multiply it with the \\n            # current one. Then we add the result to the final result. \\n            recurse(i, cur, 0, val - pre + cur, eq)\\n            eq.pop()\\n            eq.pop()\\n        \\n        res = []\\n        recurse(0, 0, 0, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191083,
                "title": "python-backtracking-solution-beating-95-with-time-complexity-proof",
                "content": "```python\\nclass Solution(object):\\n    ans = []\\n    \\n    def addOperators(self, num, target):\\n        \"\"\"\\n        This is one clarification in this question i.e. a number can\\'t start with 0. Like if we are given 105 and target\\n        5, 1 X 05 is not possible. It\\'s a simple backtracking algorithm without any optimization or DP.\\n        \\n        Proof Of Runtime is given in is given below i.e.\\n        \\n        T(N) = Total Number of Valid Expressions = 3 * 4^(N - 2) so that\\'s why runtime is O(4^N). \\n        \\n\\tRun Time complexity can also been proved by following intuitive approach.\\n\\t\\t\\t\\t\\n        If we just allow single digits so each digit can have 3 possible operators before it i.e. +, -, *\\n        which means total number of combinations to be checked are O(3^N). If we allow non-single digits as well then\\n        each digit has 4 possible values before it i.e. +, -, *, None. None means we don\\'t have any operations before\\n        digit and current digit is considered part of previous digit and they both form a number. So total combinations\\n        to be checked are O(4^N)\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.ans = []\\n        num = list(map(int, list(num)))\\n        \\n        def __addOperators(exp_val=0, last_val=0, index=0, prefix=\"\"):\\n            if index < len(num):\\n                number = 0\\n                prev_index = index\\n                while index < len(num):\\n                    number *= 10\\n                    number += num[index]\\n                    \\n                    if not prefix:\\n                        __addOperators(exp_val + number, number, index + 1, str(number))\\n                    else:\\n                        new_prefix = prefix + \\'{}\\' + str(number)\\n                        __addOperators(exp_val + number, number, index + 1, new_prefix.format(\\'+\\'))\\n                        __addOperators(exp_val - number, -1 * number, index + 1, new_prefix.format(\\'-\\'))\\n\\n                        multiply_val = exp_val + last_val * (number - 1)\\n                        __addOperators(multiply_val, last_val * number, index + 1, new_prefix.format(\\'*\\'))\\n                    \\n                    if prev_index == index and number == 0:\\n                        break\\n                    else:\\n                        index += 1\\n            elif exp_val == target:\\n                self.ans.append(prefix)\\n                \\n        \\n        if num:\\n            __addOperators()\\n        \\n        print(len(self.ans))\\n        return self.ans\\n        \\n```\\n\\n\\n#### Run Time\\n\\nTotal number of valid expressions as per author are O(N^2 x 3^N). But following proof says otherwise.\\n\\nT(N) = Total Number of Valid Expressions\\n\\nT(N) = 3T(N - 1) + 3T(N - 2) + 3T(N - 3) + .... 3T(0)\\n\\nIf we use first digit as an operand, total number of valid expressions would be T(N - 1) x 3. Three accounts\\nfor our three operations. If we use first two digits as an operand, total number of valid expressions would be T(N - 2) x 3 and so on.\\n\\nNow T(N - 1) = 3T(N - 2) + 3T(N - 3) + 3T(N - 4) + .... 3T(0)\\n\\nif we put T(N - 1) in T(N) we\\'ll get\\n\\nT(N) = 3 x 4 ( T(N - 2) + T(N - 3) + T(N - 4) + .... T(0) )\\n\\nIf we put T(N - 2) in T(N) we\\'ll get\\n\\nT(N) = 3 x 4^2 ( T(N - 3) + T(N - 4) + T(N - 5) + .... T(0) )\\n\\nIf we generalize it, we\\'ll get\\n\\nT(N) = 3 x 4^k ( T(N - (k + 1)) + T(N - (k + 2)) + .... T(0))\\n\\nIf we put k = N - 1, we\\'ll get\\n\\nT(N) = 3 x 4^(N - 1) (T(0)) = O(4^N)\\n\\nSo Total valid expressions are O(4^N). Not sure how author deduced O(N^2 x 3^N)\\n\\nFor the worst case of an array of 0s and target 0, length of our output would be O(4^N). I\\'m not sure then how author is claiming a O(N^2 x 3^N) runtime.\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    ans = []\\n    \\n    def addOperators(self, num, target):\\n        \"\"\"\\n        This is one clarification in this question i.e. a number can\\'t start with 0. Like if we are given 105 and target\\n        5, 1 X 05 is not possible. It\\'s a simple backtracking algorithm without any optimization or DP.\\n        \\n        Proof Of Runtime is given in is given below i.e.\\n        \\n        T(N) = Total Number of Valid Expressions = 3 * 4^(N - 2) so that\\'s why runtime is O(4^N). \\n        \\n\\tRun Time complexity can also been proved by following intuitive approach.\\n\\t\\t\\t\\t\\n        If we just allow single digits so each digit can have 3 possible operators before it i.e. +, -, *\\n        which means total number of combinations to be checked are O(3^N). If we allow non-single digits as well then\\n        each digit has 4 possible values before it i.e. +, -, *, None. None means we don\\'t have any operations before\\n        digit and current digit is considered part of previous digit and they both form a number. So total combinations\\n        to be checked are O(4^N)\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.ans = []\\n        num = list(map(int, list(num)))\\n        \\n        def __addOperators(exp_val=0, last_val=0, index=0, prefix=\"\"):\\n            if index < len(num):\\n                number = 0\\n                prev_index = index\\n                while index < len(num):\\n                    number *= 10\\n                    number += num[index]\\n                    \\n                    if not prefix:\\n                        __addOperators(exp_val + number, number, index + 1, str(number))\\n                    else:\\n                        new_prefix = prefix + \\'{}\\' + str(number)\\n                        __addOperators(exp_val + number, number, index + 1, new_prefix.format(\\'+\\'))\\n                        __addOperators(exp_val - number, -1 * number, index + 1, new_prefix.format(\\'-\\'))\\n\\n                        multiply_val = exp_val + last_val * (number - 1)\\n                        __addOperators(multiply_val, last_val * number, index + 1, new_prefix.format(\\'*\\'))\\n                    \\n                    if prev_index == index and number == 0:\\n                        break\\n                    else:\\n                        index += 1\\n            elif exp_val == target:\\n                self.ans.append(prefix)\\n                \\n        \\n        if num:\\n            __addOperators()\\n        \\n        print(len(self.ans))\\n        return self.ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 146166,
                "title": "swift-4-1-2",
                "content": "```\\nclass Solution {\\n    \\n    var res = [String]()\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        guard num.count != 0 else { return [] }\\n        search(num, num.startIndex, \"\", target, 0, 0)\\n        return res\\n    }\\n    \\n    func search(_ num: String, _ start: String.Index, _ path: String, _ target: Int, _ sum: Int, _ last: Int) {\\n        \\n        if start == num.endIndex {\\n            if target == sum {\\n                res.append(path)\\n            }\\n            return\\n        }\\n        \\n        var index = start\\n        while index < num.endIndex {\\n            let x = Int(String(num[start...index]))!\\n            \\n            if start == num.startIndex {\\n                search(num, num.index(after: index), String(x), target, x, x)\\n            }\\n            else {\\n                search(num, num.index(after: index), path + \"*\" + String(x), target, sum - last + last * x, last * x)\\n                search(num, num.index(after: index), path + \"+\" + String(x), target, sum + x, x)\\n                search(num, num.index(after: index), path + \"-\" + String(x), target, sum - x, -x)\\n            }\\n            \\n            if x == 0 {\\n                break\\n            }\\n            \\n            index = num.index(after: index)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    var res = [String]()\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        guard num.count != 0 else { return [] }\\n        search(num, num.startIndex, \"\", target, 0, 0)\\n        return res\\n    }\\n    \\n    func search(_ num: String, _ start: String.Index, _ path: String, _ target: Int, _ sum: Int, _ last: Int) {\\n        \\n        if start == num.endIndex {\\n            if target == sum {\\n                res.append(path)\\n            }\\n            return\\n        }\\n        \\n        var index = start\\n        while index < num.endIndex {\\n            let x = Int(String(num[start...index]))!\\n            \\n            if start == num.startIndex {\\n                search(num, num.index(after: index), String(x), target, x, x)\\n            }\\n            else {\\n                search(num, num.index(after: index), path + \"*\" + String(x), target, sum - last + last * x, last * x)\\n                search(num, num.index(after: index), path + \"+\" + String(x), target, sum + x, x)\\n                search(num, num.index(after: index), path + \"-\" + String(x), target, sum - x, -x)\\n            }\\n            \\n            if x == 0 {\\n                break\\n            }\\n            \\n            index = num.index(after: index)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128460,
                "title": "simple-python-dfs-that-beats-100",
                "content": "Scan number in num one by one. Each time seeing a new number we have 4 options:\\n1. add a +\\n2. add a - \\n3. add a *\\n4. append it to end of previous number\\nFor example, if current expression is 20+2 and we encounter 1, we can construct:\\n(1) 20+2+1\\n(2) 20+2-1\\n(3) 20+2*1\\n(4) 20+21\\nAll expressions can be expressed as the sum of another expression and a product of one or multiple numbers\\nExpr = Expr\\' + product, where Expr\\' can be null.\\n\\n```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        if not num:\\n            return []\\n        if len(num) == 1:\\n            if int(num) == target:\\n                return [num]\\n            return []\\n\\n        nums = [int(i) for i in num]\\n        res = []\\n        \\n        def dfs(i, expr, prod, prevSum, curr):\\n            \"\"\"\\n            previous result can be interpreted as: a product of a sequence of numbers + a prevous result\\n            :param i: position in num\\n            :param expr: current expression\\n            :param prod: current product, e.g. 2*1*3 for \\'2*4+0+2*1*3\\'\\n            :param prevSum: value of expression before product, e.g. 2*4+0=0 for \\'2*4+0+2*1*3\\'\\n            :param curr: most recent number, e.g. 21 in expression \\'20+21\\' \\n            \"\"\"\\n            if i == len(nums)-1:\\n                if prevSum + prod + nums[i] == target:\\n                    res.append(expr + \\'+\\' + str(nums[i]))\\n                if prevSum + prod - nums[i] == target:\\n                    res.append(expr + \\'-\\' + str(nums[i]))\\n                if prevSum + prod*nums[i] == target:\\n                    res.append(expr + \\'*\\' + str(nums[i]))\\n                # prod = prevProd*curr; \\n                # new_prod = prevProd*(curr*10+nums[i]) = 10*prod + prod//curr*nums[i]\\n                if curr and 10*prod + prod//curr*nums[i] + prevSum == target:\\n                    res.append(expr+str(nums[i]))\\n            else:\\n                dfs(i+1, expr+\\'+\\'+str(nums[i]), nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'-\\'+str(nums[i]), -nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'*\\'+str(nums[i]), nums[i]*prod, prevSum, nums[i])\\n                if curr:\\n                    # append nums[i] directly to last number, impossible when last number is 0\\n                    dfs(i+1, expr+str(nums[i]), 10*prod + prod//curr*nums[i], prevSum, 10*curr+nums[i])\\n        \\n        dfs(1, str(nums[0]), nums[0], 0, nums[0])\\n        return res\\n```\\n\\nRun time: 417ms(100%)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        if not num:\\n            return []\\n        if len(num) == 1:\\n            if int(num) == target:\\n                return [num]\\n            return []\\n\\n        nums = [int(i) for i in num]\\n        res = []\\n        \\n        def dfs(i, expr, prod, prevSum, curr):\\n            \"\"\"\\n            previous result can be interpreted as: a product of a sequence of numbers + a prevous result\\n            :param i: position in num\\n            :param expr: current expression\\n            :param prod: current product, e.g. 2*1*3 for \\'2*4+0+2*1*3\\'\\n            :param prevSum: value of expression before product, e.g. 2*4+0=0 for \\'2*4+0+2*1*3\\'\\n            :param curr: most recent number, e.g. 21 in expression \\'20+21\\' \\n            \"\"\"\\n            if i == len(nums)-1:\\n                if prevSum + prod + nums[i] == target:\\n                    res.append(expr + \\'+\\' + str(nums[i]))\\n                if prevSum + prod - nums[i] == target:\\n                    res.append(expr + \\'-\\' + str(nums[i]))\\n                if prevSum + prod*nums[i] == target:\\n                    res.append(expr + \\'*\\' + str(nums[i]))\\n                # prod = prevProd*curr; \\n                # new_prod = prevProd*(curr*10+nums[i]) = 10*prod + prod//curr*nums[i]\\n                if curr and 10*prod + prod//curr*nums[i] + prevSum == target:\\n                    res.append(expr+str(nums[i]))\\n            else:\\n                dfs(i+1, expr+\\'+\\'+str(nums[i]), nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'-\\'+str(nums[i]), -nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'*\\'+str(nums[i]), nums[i]*prod, prevSum, nums[i])\\n                if curr:\\n                    # append nums[i] directly to last number, impossible when last number is 0\\n                    dfs(i+1, expr+str(nums[i]), 10*prod + prod//curr*nums[i], prevSum, 10*curr+nums[i])\\n        \\n        dfs(1, str(nums[0]), nums[0], 0, nums[0])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631886,
                "title": "python-3-282-expression-add-operators-t-m-87-88",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\n        def dfs(num: str, tmp: str, curr:int, prev:int) -> None:\\n            nonlocal target\\n            if not num:\\n                if curr == target:\\n                    ans.append(tmp)\\n                return\\n\\n            for i in range(len(num)):\\n                pref, suff = num[i+1:], num[:i+1]\\n                if i == 0 or i > 0 and num[0] != \"0\":\\n                    dfs(pref, tmp + \"+\" + suff, curr+int(suff), int(suff))\\n                    dfs(pref, tmp + \"-\" + suff, curr-int(suff), -int(suff))\\n                    dfs(pref, tmp + \"*\" + suff, curr-prev+prev*int(suff), prev*int(suff))\\n            return\\n\\n        ans, target = [], target\\n\\n        for i in range(len(num)):\\n            if i == 0 or i > 0 and num[0] != \\'0\\':\\n                dfs(num[i+1:], num[:i+1], int(num[:i+1]), int(num[:i+1]))\\n\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/809999125/](http://)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\n        def dfs(num: str, tmp: str, curr:int, prev:int) -> None:\\n            nonlocal target\\n            if not num:\\n                if curr == target:\\n                    ans.append(tmp)\\n                return\\n\\n            for i in range(len(num)):\\n                pref, suff = num[i+1:], num[:i+1]\\n                if i == 0 or i > 0 and num[0] != \"0\":\\n                    dfs(pref, tmp + \"+\" + suff, curr+int(suff), int(suff))\\n                    dfs(pref, tmp + \"-\" + suff, curr-int(suff), -int(suff))\\n                    dfs(pref, tmp + \"*\" + suff, curr-prev+prev*int(suff), prev*int(suff))\\n            return\\n\\n        ans, target = [], target\\n\\n        for i in range(len(num)):\\n            if i == 0 or i > 0 and num[0] != \\'0\\':\\n                dfs(num[i+1:], num[:i+1], int(num[:i+1]), int(num[:i+1]))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726419,
                "title": "short-python-solution-using-backtracking-and-on-the-fly-evaluation",
                "content": "The idea is to iterate through the number string, form a number out of the digits encountered till that point, and test all three signs with that and the accumulated list of numbers, called the trace.\\n\\nI have tried to add comprehensive comments. However, if there is any lack of clarity or possible improvement, please feel free to comment.\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\n        # Initializing the resulting list\\n        res = []\\n\\t\\t\\n        def backtrack(num, path, trace):\\n            nonlocal res\\n\\t\\t\\t\\n            # Here, we have reached the end of the number string, i.e., there is no digit left\\n            if not num:\\n                # Our trace contains only +ve/-ve numbers that can simply be summed up to get the evaluated value.\\n                # If the sum is equal to the target, we add the path (expression string) to the result list.\\n                if sum(trace) == target: res.append(path)\\n                return\\n\\t\\t\\t\\t\\n            # curr is the current value of the candidate integer\\n            # i is the position in the number string\\n            # Since we are passing only the remaining part of the String to the next recursive call, i starts from 0\\n            # rlim is the range which handles the case where we don\\'t include numbers with leading zeros like 05, 012 etc\\n            curr, i, rlim = 0, 0, len(num) if num[0] != \\'0\\' else 1\\n\\t\\t\\t\\n            # This loop iterates through the number string and includes a new digit into the candidate number at each iteration\\n            # This would ensure that we are trying 1, 12, 123 for a string that starts with \"123\"\\n            while i < rlim:\\n\\t\\t\\t\\n                curr = curr*10 + int(num[i])\\n                i += 1\\n\\t\\t\\t\\t\\n                # If we have already got some numbers, we enter this condition\\n                if trace:\\n                    # If the operation is simple \\'+\\' or \\'-\\', we can add the number with the sign to the trace\\n                    backtrack(num[i:], path+\\'+\\'+num[:i], trace+[curr])\\n                    backtrack(num[i:], path+\\'-\\'+num[:i], trace+[-curr])\\n                    # If the sign is *, we have to pick up the last element of the trace, multiply it with the current number, and append it back to the trace\\n                    backtrack(num[i:], path+\\'*\\'+num[:i], trace[:-1]+[curr*trace[-1]])\\n\\t\\t\\t\\t\\t\\n                # If there is no trace, we simply have to add the positive number to the same\\n                else:\\n                    backtrack(num[i:], num[:i], [curr])\\n\\t\\t\\t\\t\\t\\n        backtrack(num, \\'\\', [])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\n        # Initializing the resulting list\\n        res = []\\n\\t\\t\\n        def backtrack(num, path, trace):\\n            nonlocal res\\n\\t\\t\\t\\n            # Here, we have reached the end of the number string, i.e., there is no digit left\\n            if not num:\\n                # Our trace contains only +ve/-ve numbers that can simply be summed up to get the evaluated value.\\n                # If the sum is equal to the target, we add the path (expression string) to the result list.\\n                if sum(trace) == target: res.append(path)\\n                return\\n\\t\\t\\t\\t\\n            # curr is the current value of the candidate integer\\n            # i is the position in the number string\\n            # Since we are passing only the remaining part of the String to the next recursive call, i starts from 0\\n            # rlim is the range which handles the case where we don\\'t include numbers with leading zeros like 05, 012 etc\\n            curr, i, rlim = 0, 0, len(num) if num[0] != \\'0\\' else 1\\n\\t\\t\\t\\n            # This loop iterates through the number string and includes a new digit into the candidate number at each iteration\\n            # This would ensure that we are trying 1, 12, 123 for a string that starts with \"123\"\\n            while i < rlim:\\n\\t\\t\\t\\n                curr = curr*10 + int(num[i])\\n                i += 1\\n\\t\\t\\t\\t\\n                # If we have already got some numbers, we enter this condition\\n                if trace:\\n                    # If the operation is simple \\'+\\' or \\'-\\', we can add the number with the sign to the trace\\n                    backtrack(num[i:], path+\\'+\\'+num[:i], trace+[curr])\\n                    backtrack(num[i:], path+\\'-\\'+num[:i], trace+[-curr])\\n                    # If the sign is *, we have to pick up the last element of the trace, multiply it with the current number, and append it back to the trace\\n                    backtrack(num[i:], path+\\'*\\'+num[:i], trace[:-1]+[curr*trace[-1]])\\n\\t\\t\\t\\t\\t\\n                # If there is no trace, we simply have to add the positive number to the same\\n                else:\\n                    backtrack(num[i:], num[:i], [curr])\\n\\t\\t\\t\\t\\t\\n        backtrack(num, \\'\\', [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324527,
                "title": "worst-problem-i-have-seen-on-lc-took-me-3-hours-to-ac-java-backtracking",
                "content": "1. Just backtrack every possible combination\\n2. Maintain a set of outputs to avoid duplicacy\\n3. Keep track of previous operator and operand. This will help you reverse the previous action when you will encounter * operation.\\n\\nHappy to explain.\\n\\n```\\nclass Solution {\\n    final char[] operators = {\\'+\\', \\'-\\', \\'*\\'};\\n    public List<String> addOperators(String num, int target) {\\n        Set<String> result = new HashSet<>();\\n        util(result, new StringBuilder(), num, target, -1, 0, num.length(), 3, 0, true);\\n        return result.stream().collect(Collectors.toList());\\n    }\\n    \\n    private void util(Set<String> result, StringBuilder sb, String num, int target, int current, int start, int len, int operatorLen, int prev, boolean isPositive) {\\n        if(current == target && start == len) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n        for(int i = start; i < len; ++i) {\\n            String tempStr = num.substring(start, i + 1);\\n            if(tempStr.length() > 1 && tempStr.charAt(0) == \\'0\\') continue;\\n            if(Long.parseLong(tempStr) > Integer.MAX_VALUE) continue;\\n            int currentNum = Integer.parseInt(tempStr);\\n            for(int j = 0; j < operatorLen; ++j) {\\n                int sbLen = sb.length();\\n                int prevCurrent = current;\\n                int prevPrev = prev;\\n                boolean prevIsPositive = isPositive;\\n                if(sbLen > 0) {\\n                    sb.append(operators[j]);\\n                    switch(operators[j]) {\\n                        case \\'+\\':\\n                            current += currentNum;\\n                            prev = currentNum;\\n                            isPositive = true;\\n                            break;\\n                        case \\'-\\':\\n                            current -= currentNum;\\n                            prev = currentNum;\\n                            isPositive = false;\\n                            break;\\n                        case \\'*\\':\\n                            if(isPositive) {\\n                                current -= prev;\\n                                prev *= currentNum;\\n                                current += (prev);\\n                            } else {\\n                                current += prev;\\n                                prev *= currentNum;\\n                                current -= (prev);\\n                            }\\n                            break;\\n                    }\\n                } else {\\n                    current = currentNum;\\n                    prev = currentNum;\\n                }\\n                sb.append(tempStr);\\n                util(result, sb, num, target, current, i + 1, len, operatorLen, prev, isPositive);\\n                sb.setLength(sbLen);\\n                current = prevCurrent;\\n                prev = prevPrev;\\n                isPositive = prevIsPositive;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    final char[] operators = {\\'+\\', \\'-\\', \\'*\\'};\\n    public List<String> addOperators(String num, int target) {\\n        Set<String> result = new HashSet<>();\\n        util(result, new StringBuilder(), num, target, -1, 0, num.length(), 3, 0, true);\\n        return result.stream().collect(Collectors.toList());\\n    }\\n    \\n    private void util(Set<String> result, StringBuilder sb, String num, int target, int current, int start, int len, int operatorLen, int prev, boolean isPositive) {\\n        if(current == target && start == len) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n        for(int i = start; i < len; ++i) {\\n            String tempStr = num.substring(start, i + 1);\\n            if(tempStr.length() > 1 && tempStr.charAt(0) == \\'0\\') continue;\\n            if(Long.parseLong(tempStr) > Integer.MAX_VALUE) continue;\\n            int currentNum = Integer.parseInt(tempStr);\\n            for(int j = 0; j < operatorLen; ++j) {\\n                int sbLen = sb.length();\\n                int prevCurrent = current;\\n                int prevPrev = prev;\\n                boolean prevIsPositive = isPositive;\\n                if(sbLen > 0) {\\n                    sb.append(operators[j]);\\n                    switch(operators[j]) {\\n                        case \\'+\\':\\n                            current += currentNum;\\n                            prev = currentNum;\\n                            isPositive = true;\\n                            break;\\n                        case \\'-\\':\\n                            current -= currentNum;\\n                            prev = currentNum;\\n                            isPositive = false;\\n                            break;\\n                        case \\'*\\':\\n                            if(isPositive) {\\n                                current -= prev;\\n                                prev *= currentNum;\\n                                current += (prev);\\n                            } else {\\n                                current += prev;\\n                                prev *= currentNum;\\n                                current -= (prev);\\n                            }\\n                            break;\\n                    }\\n                } else {\\n                    current = currentNum;\\n                    prev = currentNum;\\n                }\\n                sb.append(tempStr);\\n                util(result, sb, num, target, current, i + 1, len, operatorLen, prev, isPositive);\\n                sb.setLength(sbLen);\\n                current = prevCurrent;\\n                prev = prevPrev;\\n                isPositive = prevIsPositive;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031229,
                "title": "python-simple-heavily-commented-and-accepted-recursive-solution",
                "content": "Simple and easy to understand solution. This solution evaluates the expression on the fly so it saves additonal computation of evaluating the value in the end\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        exprs = []\\n        \\n        def recurse(idx, value, delta, exp):\\n            # base case here\\n            if idx == len(num):\\n                if value == target:\\n                    exprs.append(\"\".join(exp))\\n            \\n            # the loop will create the current operand and recursively call\\n            # the next set of actions to be executed\\n            for i in range(idx, len(num)):\\n                # this is to avoid cases where the operand starts with a 0\\n                # we need to have a case with just the 0 but not something like\\n                # 05, so the condition will return early if we find such cases\\n                if num[idx] == \\'0\\' and i > idx:\\n                    return\\n                \\n                curr = int(num[idx:i+1])\\n                curr_str = num[idx:i+1]\\n                \\n                # when we start the problem we dont have a preceding operator or operand\\n                if idx == 0:\\n                    recurse(i+1, curr, curr, exp + [curr_str])\\n                else:\\n                    # We need to do 3 different recursions for each operator\\n                    # value stores the running value of the expression evaluated so far\\n                    # the crux of the logic lies in how we use and pass delta\\n                    # when the operation is \\'+\\' or \\'-\\' we don\\'t care much about it and can just\\n                    # add or subtract it from the value \\n                    # when \\'*\\' is involved, we need to follow the precedence relation,\\n                    # but we have already evaluated the previous operator. We know the\\n                    # previous operation that was performed and how much it contributed to the value i.e., delta\\n                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication\\n                    recurse(i+1, value+curr, curr, exp + [\\'+\\', curr_str])\\n                    recurse(i+1, value-curr, -curr, exp + [\\'-\\', curr_str])\\n                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + [\\'*\\', curr_str])\\n                            \\n        recurse(0, 0, 0, [])\\n        return exprs\\n                            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        exprs = []\\n        \\n        def recurse(idx, value, delta, exp):\\n            # base case here\\n            if idx == len(num):\\n                if value == target:\\n                    exprs.append(\"\".join(exp))\\n            \\n            # the loop will create the current operand and recursively call\\n            # the next set of actions to be executed\\n            for i in range(idx, len(num)):\\n                # this is to avoid cases where the operand starts with a 0\\n                # we need to have a case with just the 0 but not something like\\n                # 05, so the condition will return early if we find such cases\\n                if num[idx] == \\'0\\' and i > idx:\\n                    return\\n                \\n                curr = int(num[idx:i+1])\\n                curr_str = num[idx:i+1]\\n                \\n                # when we start the problem we dont have a preceding operator or operand\\n                if idx == 0:\\n                    recurse(i+1, curr, curr, exp + [curr_str])\\n                else:\\n                    # We need to do 3 different recursions for each operator\\n                    # value stores the running value of the expression evaluated so far\\n                    # the crux of the logic lies in how we use and pass delta\\n                    # when the operation is \\'+\\' or \\'-\\' we don\\'t care much about it and can just\\n                    # add or subtract it from the value \\n                    # when \\'*\\' is involved, we need to follow the precedence relation,\\n                    # but we have already evaluated the previous operator. We know the\\n                    # previous operation that was performed and how much it contributed to the value i.e., delta\\n                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication\\n                    recurse(i+1, value+curr, curr, exp + [\\'+\\', curr_str])\\n                    recurse(i+1, value-curr, -curr, exp + [\\'-\\', curr_str])\\n                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + [\\'*\\', curr_str])\\n                            \\n        recurse(0, 0, 0, [])\\n        return exprs\\n                            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 71923,
                "title": "some-thougths",
                "content": "The following DFS is similar to top solutions.\\n* c++\\n```\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> exp;\\n        string cur;\\n        dfs(0,0,0,target,cur,num,exp);\\n        return exp;\\n    }\\n    void dfs(int p, int prod, long res, int target, string& cur, string &num,vector<string>& exp) {\\n        int n = num.size();\\n        if(p==n && res==target) exp.push_back(cur);\\n        long v = 0;\\n        int sz = cur.size(); \\n        string s;\\n        for(int i=p;i<n;i++) {\\n            v=v*10+num[i]-\\'0\\';\\n            s+=num[i];\\n            if(cur.empty()) dfs(i+1,v,res+v,target,cur+=s,num,exp);\\n            else {\\n                dfs(i+1,v,res+v,target,cur+=\\'+\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,-v,res-v,target,cur+=\\'-\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,prod*v,res-prod+prod*v,target,cur+=\\'*\\'+s,num,exp);\\n            }\\n            cur.resize(sz);\\n            if(!v) return;\\n        }\\n    }\\n``` \\n* java\\n```\\n\\tList<String> res;\\n    public List<String> addOperators(String num, int target) {\\n        res=new ArrayList<>();\\n        dfs(0,0,0,target,num,new StringBuilder());\\n        return res;\\n    }\\n    private void dfs(int p, long eval, long mult, int target, String num, StringBuilder sb) {\\n        int n=num.length();\\n        if(p==n) {\\n            if(eval==target) {\\n                res.add(sb.toString());\\n            }\\n        }\\n        int len=sb.length();\\n        long number=0;\\n        for(int i=p;i<n;i++) {\\n            number = number*10 + num.charAt(i)-\\'0\\';\\n            if(p==0) {//no sign before first number\\n                dfs(i+1,number,number,target,num,sb.append(number));\\n                sb.setLength(len);\\n            } else {\\n                dfs(i+1,eval+number,number,target,num,sb.append(\\'+\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-number,-number,target,num,sb.append(\\'-\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-mult+mult*number,mult*number,target,num,sb.append(\\'*\\').append(number));\\n                sb.setLength(len);\\n            }\\n            if(num.charAt(p)==\\'0\\') { //01 is invalid\\n                return;\\n            }\\n        }\\n    }\\n```\\nTime complexity O(4^n)\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1);\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1);\\nThus T(n) = 4T(n-1);\\n\\nSpace complexity O(n)\\nIgnoring the large output, space complexity is depth of the recursion.\\n\\nMost recursions can be speeded up by memorization. How about this one? No, because there is no duplicate states.\\n\\nHow about BFS? If a problem can be solved by one, we can solve it by the other. DFS has much lower memory requirements than BFS because it is not necessary to store all the children at each level. The search space is exponential so BFS space complexity is exponential which makes it not acceptable.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> exp;\\n        string cur;\\n        dfs(0,0,0,target,cur,num,exp);\\n        return exp;\\n    }\\n    void dfs(int p, int prod, long res, int target, string& cur, string &num,vector<string>& exp) {\\n        int n = num.size();\\n        if(p==n && res==target) exp.push_back(cur);\\n        long v = 0;\\n        int sz = cur.size(); \\n        string s;\\n        for(int i=p;i<n;i++) {\\n            v=v*10+num[i]-\\'0\\';\\n            s+=num[i];\\n            if(cur.empty()) dfs(i+1,v,res+v,target,cur+=s,num,exp);\\n            else {\\n                dfs(i+1,v,res+v,target,cur+=\\'+\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,-v,res-v,target,cur+=\\'-\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,prod*v,res-prod+prod*v,target,cur+=\\'*\\'+s,num,exp);\\n            }\\n            cur.resize(sz);\\n            if(!v) return;\\n        }\\n    }\\n```\n```\\n\\tList<String> res;\\n    public List<String> addOperators(String num, int target) {\\n        res=new ArrayList<>();\\n        dfs(0,0,0,target,num,new StringBuilder());\\n        return res;\\n    }\\n    private void dfs(int p, long eval, long mult, int target, String num, StringBuilder sb) {\\n        int n=num.length();\\n        if(p==n) {\\n            if(eval==target) {\\n                res.add(sb.toString());\\n            }\\n        }\\n        int len=sb.length();\\n        long number=0;\\n        for(int i=p;i<n;i++) {\\n            number = number*10 + num.charAt(i)-\\'0\\';\\n            if(p==0) {//no sign before first number\\n                dfs(i+1,number,number,target,num,sb.append(number));\\n                sb.setLength(len);\\n            } else {\\n                dfs(i+1,eval+number,number,target,num,sb.append(\\'+\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-number,-number,target,num,sb.append(\\'-\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-mult+mult*number,mult*number,target,num,sb.append(\\'*\\').append(number));\\n                sb.setLength(len);\\n            }\\n            if(num.charAt(p)==\\'0\\') { //01 is invalid\\n                return;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71959,
                "title": "c-solution-with-explanation",
                "content": "We can consider a number \"12\" or a product of numbers \"1*2\" as a subset, '+' or '-' will be the separator for subsets. Whenever we inserts a '+' or '-', product will be reset to be 1. \\n\\n\\n    Pattern: \\n    sumSofar + sign(1/-1) * [product * concatenate(lastNum, num[pos]) operator]\\n\\ne.g. num: \"1142356\" \\n    \\n    One possible sequence till position 5:    1+142*35[*/-/+/none]\\n    Before position 5:\\n    sumSofar = 1, product = 142, lastNum = 3, curNum = 35, sign = 1\\n    Now, so here, one of the three operators '*', '-', '+' or none of them can be inserted after 3.\\n    '*':  path-> `1+142*35*`, lastNum -> 0, product -> 142 * 35 * 1\\n    '+':  path-> `1+142*35+`, lastNum -> 0, product -> 1, sumSofar += 142 * 35 * 1, sign -> 1 \\n    '-':  path-> `1+142*35-`, lastNum -> 0, product -> 1, sumSofar += 142 * 35 * 1, sign -> -1\\n    none: path-> `1+142*35`, lastNum -> curNum = 35 \\n\\n \\n\\n\\nCode\\n\\n    class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> answer;\\n            if(num.size()) dfs(num, 0, target, 0, 1, 0, \"\", answer, 1); // pos: next to process position num[pos]\\n            return answer;\\n        }\\n        \\n        void dfs(string &num, int pos, int target, long long lastNum, long long product, long long sumSofar, string path, vector<string> &answer, int sign){\\n            \\n            long long curNum = lastNum * 10 + num[pos] - '0'; \\n            if(pos + 1 == num.size()){\\n                if(sumSofar + product * curNum * sign == target)\\n                    answer.push_back(path + num[pos]);\\n                return; \\n            }\\n            // for pos < num.size() - 1, \\u201c*\\u201d / \\u201c+\\u201d / \\u201c-\\u201d / no op / can be inserted after num[pos]\\n            dfs(num, pos + 1, target, 0, product * curNum, sumSofar, path + num[pos] + \"*\", answer, sign); // *\\n            dfs(num, pos + 1, target, 0, 1, sumSofar + product * curNum * sign, path + num[pos] + \"+\", answer, 1); // +\\n            dfs(num, pos + 1, target, 0, 1, sumSofar + product * curNum * sign, path + num[pos] + \"-\", answer, -1); // -\\n            if(curNum != 0) dfs(num, pos + 1, target, curNum, product, sumSofar, path + num[pos], answer, sign); // no operator\\n        } \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> answer;\\n            if(num.size()) dfs(num, 0, target, 0, 1, 0, \"\", answer, 1); // pos: next to process position num[pos]\\n            return answer;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71966,
                "title": "my-20ms-c-dfs-solution",
                "content": "    typedef long long int Int64;\\n    \\n    class Solution {\\n    private:\\n        const char *numstr;\\n        Int64 target64;\\n        int n;\\n        \\n        void dfs(Int64 prev, Int64 curr, int next, char* buffer, int buffernext, vector<string>& res)\\n        {\\n            if(next == n)\\n            {\\n                buffer[buffernext] = '\\\\0';\\n                if(prev+curr == target64)\\n                {\\n                    string s = buffer;\\n                    res.push_back(s);\\n                }\\n                return;\\n            }\\n            \\n            int lm;\\n            if(numstr[next] == '0')\\n                lm = next+1;\\n            else\\n                lm = n;\\n            \\n            int l;\\n            Int64 v=0;\\n            for(l=next; l<lm; l++)\\n            {\\n                buffer[buffernext+l-next+1] = numstr[l];\\n                v = v*10 + (numstr[l] - '0');\\n                \\n                buffer[buffernext] = '+';\\n                dfs(prev+curr, v, l+1, buffer, buffernext+l-next+2, res);\\n                \\n                buffer[buffernext] = '-';\\n                dfs(prev+curr, -v, l+1, buffer, buffernext+l-next+2, res);\\n                \\n                buffer[buffernext] = '*';\\n                dfs(prev, curr*v, l+1, buffer, buffernext+l-next+2, res);\\n            }\\n        }\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> result;\\n            \\n            n = num.size();\\n            target64 = (Int64) target;\\n            numstr = num.c_str();\\n            \\n            char buf[2*n];\\n            int lmax;\\n            if(numstr[0] == '0') // A number starts with '0' must be 0\\n                lmax = 1;\\n            else\\n                lmax = n;\\n            int i;\\n            Int64 previous = 0;\\n            Int64 current = 0;\\n            for(i=0; i<lmax; i++)\\n            {\\n                current = current*10 + (numstr[i] - '0');\\n                buf[i] = numstr[i];\\n                dfs(previous, current, i+1, buf, i+1, result);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        const char *numstr;\\n        Int64 target64;\\n        int n;\\n        \\n        void dfs(Int64 prev, Int64 curr, int next, char* buffer, int buffernext, vector<string>& res)\\n        {\\n            if(next == n)\\n            {\\n                buffer[buffernext] = '\\\\0';\\n                if(prev+curr == target64)\\n                {\\n                    string s = buffer;\\n                    res.push_back(s);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3330455,
                "title": "well-explained-python-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addOperators(self, s: str, target: int) -> List[str]:\\n        # need to traverse through s\\n        # backtrack each case of  start index and then +,*,-\\n        # need empty array ofcourse\\n        # need curidx = i\\n        # need the str path to append to the arr if my --> cur_num == target\\n        # need the prevNum access for multiplication\\n        # 1 2 3 4 5 --> 1 + 2 + 3 + 4 * 5\\n        #               ^ ^ ^ ^ ^ ^ ^ == 10 but we wanna do 4*5 so ---\\n        # just do 1 + 2 + 3 + 4 + (- 4) + (4 * 5)\\n        # return ans\\n        \\n        res = []\\n\\n        def dfs(i, path, cur_num, prevNum):\\n            if i == len(s):\\n                if cur_num == target:\\n                    res.append(path)\\n                return\\n            \\n            for j in range(i, len(s)):\\n                # starting with zero?\\n                if j > i and s[i] == \\'0\\':\\n                    break\\n                num = int(s[i:j+1])\\n\\n                # if cur index is 0 then simple add that number\\n                if i == 0:\\n                    dfs(j + 1, path + str(num), cur_num + num, num)\\n                else:\\n                    dfs(j + 1, path + \"+\" + str(num), cur_num + num, num)\\n                    dfs(j + 1, path + \"-\" + str(num), cur_num - num, -num)\\n                    dfs(j + 1, path + \"*\" + str(num), cur_num - prevNum + prevNum * num, prevNum * num)\\n        \\n        dfs(0, \"\", 0, 0)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, s: str, target: int) -> List[str]:\\n        # need to traverse through s\\n        # backtrack each case of  start index and then +,*,-\\n        # need empty array ofcourse\\n        # need curidx = i\\n        # need the str path to append to the arr if my --> cur_num == target\\n        # need the prevNum access for multiplication\\n        # 1 2 3 4 5 --> 1 + 2 + 3 + 4 * 5\\n        #               ^ ^ ^ ^ ^ ^ ^ == 10 but we wanna do 4*5 so ---\\n        # just do 1 + 2 + 3 + 4 + (- 4) + (4 * 5)\\n        # return ans\\n        \\n        res = []\\n\\n        def dfs(i, path, cur_num, prevNum):\\n            if i == len(s):\\n                if cur_num == target:\\n                    res.append(path)\\n                return\\n            \\n            for j in range(i, len(s)):\\n                # starting with zero?\\n                if j > i and s[i] == \\'0\\':\\n                    break\\n                num = int(s[i:j+1])\\n\\n                # if cur index is 0 then simple add that number\\n                if i == 0:\\n                    dfs(j + 1, path + str(num), cur_num + num, num)\\n                else:\\n                    dfs(j + 1, path + \"+\" + str(num), cur_num + num, num)\\n                    dfs(j + 1, path + \"-\" + str(num), cur_num - num, -num)\\n                    dfs(j + 1, path + \"*\" + str(num), cur_num - prevNum + prevNum * num, prevNum * num)\\n        \\n        dfs(0, \"\", 0, 0)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511436,
                "title": "python-recursive-dfs-step-by-step-walkthrough-long-post",
                "content": "**Intuition**\\n\\n1. We start off the problem by enumerating all possible ways to split up our numbers:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    # for every position in between digits\\n\\t\\t\\t# we add a break\\n\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t```\\n\\t\\n2. Not too bad so far. Then we add our operators:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\t# we are at the beginning of the num\\n\\t\\t\\t\\t# we cannot add operators before any\\n\\t\\t\\t\\t# digits\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\t```\\n\\n3. You will notice that the above doesn\\'t account for numbers with leading zeroes. So we add that edge case check in our DFS:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\t# we have a leading zero, only allow a single DFS call\\n\\t\\t\\t\\t# then break\\n\\t\\t\\t\\tbreak\\n\\t```\\n\\n4. If the problem is a bit easier, we might get away with calling `eval(expr)` once we generate the permutations. However Python is slow and the problem is LC Hard for a reason. So we need to evaluate our expression on-the-fly\\n\\n5. Let\\'s imagine we ONLY had \"+\" and \"-\". We might evaluate our values like so:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str], val):\\n\\t\\tif i == n:\\n            if val == target:\\n\\t\\t\\t    res.append(\"\".join(expr))\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    operand_str = num[i:j + 1]\\n\\t\\t\\toperand = int(operand_str)\\n\\t\\t\\t\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [operand_str])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [operand_str], val + operand)\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [operand_str], val - operand)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# let\\'s ignore multiplying for now\\n\\t\\t\\t\\t# dfs(j + 1, expr + [\"*\"] + [operand_str])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\tbreak\\n\\t```\\n\\n6. Almost there! But what about multiplication? It takes precedence over add/subtract. Imagine if we have: `A+B*D`. Using our method in step #5, we might end up with `(A+B)*D`. How do we correct this?\\n\\n7. Let\\'s assume we are stuck with `(A+B)`. Algebraically, we would need to \"undo\" the previous addition like so:\\n\\t```\\n\\t(A + B) - B + B * D = A + (B * D)\\n\\t```\\n\\n8. With this new observation, we have our final DFS implementation:\\n\\n**Solution**\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        res = []\\n        \\n        def dfs(i: int, expr: List[str], val, prev):\\n            if i == n:\\n                if val == target:\\n                    res.append(\"\".join(expr))\\n                return\\n        \\n            for j in range(i, n):\\n                operand_s = num[i:j + 1]\\n                operand_i = int(operand_s)\\n                \\n                if not expr:\\n                    # we are reading the first number\\n                    # so we do not add any operators yet\\n                    dfs(j + 1, [operand_s], operand_i, operand_i)\\n                    \\n                else:\\n                    dfs(j + 1, expr + [\"+\"] + [operand_s], val + operand_i, operand_i)\\n                    dfs(j + 1, expr + [\"-\"] + [operand_s], val - operand_i, -operand_i)\\n                    \\n                    # when we DFS with a multiply, we need to \"undo\" a previous calculation\\n                    dfs(j + 1, expr + [\"*\"] + [operand_s], val - prev + operand_i * prev, operand_i * prev)\\n                    \\n                if num[i] == \"0\":\\n                    # we only want to dfs ONCE if we are\\n                    # currently reading a zero.\\n                    #\\n                    # for example 0 + 0 + 1 is valid\\n                    # however, 00 + 1 is not valid\\n                    break\\n        \\n        dfs(0, [], 0, 0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    # for every position in between digits\\n\\t\\t\\t# we add a break\\n\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\t# we are at the beginning of the num\\n\\t\\t\\t\\t# we cannot add operators before any\\n\\t\\t\\t\\t# digits\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\t# we have a leading zero, only allow a single DFS call\\n\\t\\t\\t\\t# then break\\n\\t\\t\\t\\tbreak\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str], val):\\n\\t\\tif i == n:\\n            if val == target:\\n\\t\\t\\t    res.append(\"\".join(expr))\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    operand_str = num[i:j + 1]\\n\\t\\t\\toperand = int(operand_str)\\n\\t\\t\\t\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [operand_str])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [operand_str], val + operand)\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [operand_str], val - operand)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# let\\'s ignore multiplying for now\\n\\t\\t\\t\\t# dfs(j + 1, expr + [\"*\"] + [operand_str])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\tbreak\\n\\t```\n```\\n\\t(A + B) - B + B * D = A + (B * D)\\n\\t```\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        res = []\\n        \\n        def dfs(i: int, expr: List[str], val, prev):\\n            if i == n:\\n                if val == target:\\n                    res.append(\"\".join(expr))\\n                return\\n        \\n            for j in range(i, n):\\n                operand_s = num[i:j + 1]\\n                operand_i = int(operand_s)\\n                \\n                if not expr:\\n                    # we are reading the first number\\n                    # so we do not add any operators yet\\n                    dfs(j + 1, [operand_s], operand_i, operand_i)\\n                    \\n                else:\\n                    dfs(j + 1, expr + [\"+\"] + [operand_s], val + operand_i, operand_i)\\n                    dfs(j + 1, expr + [\"-\"] + [operand_s], val - operand_i, -operand_i)\\n                    \\n                    # when we DFS with a multiply, we need to \"undo\" a previous calculation\\n                    dfs(j + 1, expr + [\"*\"] + [operand_s], val - prev + operand_i * prev, operand_i * prev)\\n                    \\n                if num[i] == \"0\":\\n                    # we only want to dfs ONCE if we are\\n                    # currently reading a zero.\\n                    #\\n                    # for example 0 + 0 + 1 is valid\\n                    # however, 00 + 1 is not valid\\n                    break\\n        \\n        dfs(0, [], 0, 0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910325,
                "title": "expression-add-operators-solution-java",
                "content": "class Solution {\\n  public List<String> addOperators(String num, int target) {\\n    List<String> ans = new ArrayList<>();\\n    dfs(num, target, 0, 0, 0, new StringBuilder(), ans);\\n    return ans;\\n  }\\n\\n  private void dfs(String num, int target, int s, long prev, long eval, StringBuilder sb,\\n                   List<String> ans) {\\n    if (s == num.length()) {\\n      if (eval == target)\\n        ans.add(sb.toString());\\n      return;\\n    }\\n\\n    for (int i = s; i < num.length(); ++i) {\\n      if (i > s && num.charAt(s) == \\'0\\')\\n        return;\\n      final long curr = Long.parseLong(num.substring(s, i + 1));\\n      final int length = sb.length();\\n      if (s == 0) { // first num\\n        dfs(num, target, i + 1, curr, curr, sb.append(curr), ans);\\n        sb.setLength(length);\\n      } else {\\n        dfs(num, target, i + 1, curr, eval + curr, sb.append(\"+\").append(curr), ans);\\n        sb.setLength(length);\\n        dfs(num, target, i + 1, -curr, eval - curr, sb.append(\"-\").append(curr), ans);\\n        sb.setLength(length);\\n        dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr, sb.append(\"*\").append(curr),\\n            ans);\\n        sb.setLength(length);\\n      }\\n    }\\n  }\\n}\\n",
                "solutionTags": [
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "class Solution {\\n  public List<String> addOperators(String num, int target) {\\n    List<String> ans = new ArrayList<>();\\n    dfs(num, target, 0, 0, 0, new StringBuilder(), ans);\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1449082,
                "title": "simple-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new ArrayList<>();\\n        addOperators(num, target, result, 0, 0, 0, \"\");\\n        return result;\\n    }\\n    \\n    private void addOperators(String num, int target, List<String> result, int index, long value, long previous, String current) {\\n        if(index == num.length()) {\\n            if(value + previous == target) {\\n                result.add(current);\\n            }\\n            return;\\n        }\\n        \\n        int end = num.length();\\n        if(num.charAt(index) == \\'0\\') {\\n            end = index + 1;\\n        }\\n        \\n        for(int i = index + 1; i <= end; i ++) {\\n            long currentValue = Long.valueOf(num.substring(index, i));\\n            \\n            if(index == 0) {\\n                addOperators(num, target, result, i, 0, currentValue, String.valueOf(currentValue));\\n                continue;\\n            } \\n            \\n            // Add +\\n            addOperators(num, target, result, i, value + previous, currentValue, current + \"+\" + currentValue);\\n            // Add -\\n            addOperators(num, target, result, i, value + previous, -currentValue, current + \"-\" + currentValue);\\n            // Add *\\n            addOperators(num, target, result, i, value, previous * currentValue, current + \"*\" + currentValue);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new ArrayList<>();\\n        addOperators(num, target, result, 0, 0, 0, \"\");\\n        return result;\\n    }\\n    \\n    private void addOperators(String num, int target, List<String> result, int index, long value, long previous, String current) {\\n        if(index == num.length()) {\\n            if(value + previous == target) {\\n                result.add(current);\\n            }\\n            return;\\n        }\\n        \\n        int end = num.length();\\n        if(num.charAt(index) == \\'0\\') {\\n            end = index + 1;\\n        }\\n        \\n        for(int i = index + 1; i <= end; i ++) {\\n            long currentValue = Long.valueOf(num.substring(index, i));\\n            \\n            if(index == 0) {\\n                addOperators(num, target, result, i, 0, currentValue, String.valueOf(currentValue));\\n                continue;\\n            } \\n            \\n            // Add +\\n            addOperators(num, target, result, i, value + previous, currentValue, current + \"+\" + currentValue);\\n            // Add -\\n            addOperators(num, target, result, i, value + previous, -currentValue, current + \"-\" + currentValue);\\n            // Add *\\n            addOperators(num, target, result, i, value, previous * currentValue, current + \"*\" + currentValue);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356498,
                "title": "python-recursive-with-stack",
                "content": "It\\'s the same idea as the basic calculator implementation using stack.\\n\\n* if the operator is `+` or `-`, push to stack as is.\\n* if the operator is `*` , pop the stack and multiplly it by the current number, then push the result to the stack\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        size = len(num)\\n        \\n        def solve(index: int, stack: list = None, built: str = None) -> List[str]:\\n            if index >= size:\\n                if sum(stack) == target:\\n                    return [built]\\n                else:\\n                    return []\\n            \\n            res = []\\n            \\n            for i in range(index + 1, size + 1):\\n                ns = num[index: i]\\n                if ns[0] == \\'0\\' and i - index > 1:\\n                    break\\n                    \\n                n = int(ns)\\n                \\n                if index == 0:\\n                    res += solve(i, stack=[n], built=ns)\\n                else:\\n                    res += solve(i, stack=stack + [n], built=built + \\'+\\' + ns)\\n                    res += solve(i, stack=stack + [-n], built=built + \\'-\\' + ns)\\n                    res += solve(i, stack=stack[:-1] + [stack[-1] * n], built=built + \\'*\\' + ns)\\n                \\n            return res\\n        \\n        return solve(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        size = len(num)\\n        \\n        def solve(index: int, stack: list = None, built: str = None) -> List[str]:\\n            if index >= size:\\n                if sum(stack) == target:\\n                    return [built]\\n                else:\\n                    return []\\n            \\n            res = []\\n            \\n            for i in range(index + 1, size + 1):\\n                ns = num[index: i]\\n                if ns[0] == \\'0\\' and i - index > 1:\\n                    break\\n                    \\n                n = int(ns)\\n                \\n                if index == 0:\\n                    res += solve(i, stack=[n], built=ns)\\n                else:\\n                    res += solve(i, stack=stack + [n], built=built + \\'+\\' + ns)\\n                    res += solve(i, stack=stack + [-n], built=built + \\'-\\' + ns)\\n                    res += solve(i, stack=stack[:-1] + [stack[-1] * n], built=built + \\'*\\' + ns)\\n                \\n            return res\\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325327,
                "title": "c-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    \\n    void solve(string str, int idx, string temp, long long last, long long  value, int target) {\\n        \\n        if(idx == str.length()) {\\n            if(value == target)\\n                res.push_back(temp);\\n            return;\\n        }\\n        \\n        \\n        for(int i=idx; i<str.length(); i++) {\\n            \\n            string s = str.substr(idx, i - idx + 1);\\n            \\n            if(s.length() > 1 and s[0] == \\'0\\')\\n                return;\\n            \\n            long long curr = stoll(s);\\n            \\n            if(temp.empty()) {\\n                solve(str, i+1, temp + s, curr, curr, target);\\n            }\\n\\n            else {\\n                solve(str, i+1, temp + \"+\" + s, curr, value + curr, target);\\n                solve(str, i+1, temp + \"-\" + s, -curr, value - curr, target);\\n                solve(str, i+1, temp + \"*\" + s, curr*last, (value - last) + (curr*last) , target);                \\n            }\\n        }\\n    }\\n        \\n        \\n    vector<string> addOperators(string str, int target) {\\n        \\n        solve(str,0,\"\",0,0,target);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    \\n    void solve(string str, int idx, string temp, long long last, long long  value, int target) {\\n        \\n        if(idx == str.length()) {\\n            if(value == target)\\n                res.push_back(temp);\\n            return;\\n        }\\n        \\n        \\n        for(int i=idx; i<str.length(); i++) {\\n            \\n            string s = str.substr(idx, i - idx + 1);\\n            \\n            if(s.length() > 1 and s[0] == \\'0\\')\\n                return;\\n            \\n            long long curr = stoll(s);\\n            \\n            if(temp.empty()) {\\n                solve(str, i+1, temp + s, curr, curr, target);\\n            }\\n\\n            else {\\n                solve(str, i+1, temp + \"+\" + s, curr, value + curr, target);\\n                solve(str, i+1, temp + \"-\" + s, -curr, value - curr, target);\\n                solve(str, i+1, temp + \"*\" + s, curr*last, (value - last) + (curr*last) , target);                \\n            }\\n        }\\n    }\\n        \\n        \\n    vector<string> addOperators(string str, int target) {\\n        \\n        solve(str,0,\"\",0,0,target);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070001,
                "title": "why-do-i-get-tle-again-starting-from-examples-cpp-solution-with-analysis",
                "content": "Key point: store temp value & move terms to the right( why don\\'t we change the value right of \"=\")\\nFor those who only needs the solution, go to part IV directly. \\nIf you have any questions or suggestions, feel free to write below.\\n\\n**I. Introduction**\\n\\tTo better explain what I did, please allow me to introduce a new operator \"~\", which means literally combine two numbers. For instance, 1~3 = 13, 67~89 = 6789, -7~8 = -78( pay extra attention to this! ). Noticed that it\\'s different from x*10+y, we need to write a specific function implementing this operator, see function \"combine\" for details.\\n\\t\\n![image](https://assets.leetcode.com/users/images/86455c2f-4687-435e-8aaa-dd19737bdf3d_1619089354.4731524.png)\\n\\n\\nSo for a string containing n digits, there are n-1 blanks to fill and there are 4 possibilities for every blank, so the total possibilities is 4^(n-1). \\n\\n**II. A Straight-forward solution and why it results in TLE**\\nTo try all the possibilities, we can easily devise a solution using recursion: try + - * ~ one by one in each blank and move forward. Unfortunately, this solution give you TLE because you only calculate the value after you fully build the expression, which involves too much redundant calculation. \\n\\nTo get some intuition, take this half finished equation (left part) as an example\\n\\n![image](https://assets.leetcode.com/users/images/080acc6f-780f-45f4-8821-e8a2aff181c3_1619089502.8828244.png)\\n\\n\\nThere\\'re two blanks left, so there\\'re 4^2=16 possibilities left. So1*2+3~4 would be calculate 16 times. \\n\\n\\n\\n**III. A revised solution**\\nShown as above, redundant computation gives you TLE in return. A naive approach is to calculate the \\u201Cpartial answer\\u201D or \\u201Cvalue so far\\u201D, that is, the output of the part we have finished. \\n\\n\\nFor instance, in the equation given above, we could directly compute the value of 1*2+34 = 36 and use this \"value so far\" for future attempts. \\n\\n![image](https://assets.leetcode.com/users/images/a94b1185-1682-4c51-80be-cf5cc1135f03_1619089538.4591494.png)\\n\\n\\n\\nActaully, why don\\'t we move this 36 to the right part since no matter what operator between 5 and 8 is, the \"value so far\" is fixed.\\n![image](https://assets.leetcode.com/users/images/5c55a2e1-9b0d-4a9c-a350-d4e8b918f0b2_1619089570.8583777.png)\\n\\n\\nFurther look at the following equation, we find that once we decide to use \"+\" between two digits, the value of the part left of \"+\" is always fixed and we should move this part to the right.\\n![image](https://assets.leetcode.com/users/images/ed0d13c0-ed78-45b6-b1e2-b774b5e29e63_1619081561.0559442.png)\\n![image](https://assets.leetcode.com/users/images/069edc53-a92a-4e29-a330-1b9e799df708_1619081714.311086.png)\\n\\nActually, we can also do this when we decide to use \"-\" for the same reason. The only thing we need to care is to keep the \"-\" inside of the right part.\\n\\n![image](https://assets.leetcode.com/users/images/44b5ae95-82a8-450d-bd36-3d4b16286ec1_1619082005.560652.png)\\n\\nThen the question come: what if we decide to use * between two digits?\\nIndeed, we cannot move the left part to the right in this circumstance, what\\'s worse, we cannot even calculate the left part because of \"~\". \\n![image](https://assets.leetcode.com/users/images/d154422f-a2bd-4c07-97dd-7f6100bd2ef1_1619082782.6420016.png)\\n\\n\\nAssume we merge \"5*8\" into 40, just like the picture shows. If we decide to use \"~\" between 8 and 9, them the 40 would be  meaningless and there\\'s no way to fix it (the solution leetcode gives couldn\\'t handle this). In order to handle this, some special tricks are used. The following content talks about how to handle * and ~.\\n\\nWe utilize two \"registers\" reg1, reg2 (reg1 is set to be the first digit and reg2 is initialized to 1) to the save two factors and a special \"pointer\" pointing at one of them, telling us which one is \"active\". The pointer points to reg1 from the begining. Let\\'s start with an example:\\nFrom the very begining, reg1 = the first digit = 5, reg2 = 1, ptr = reg1. \\n\\nFirst blank:\\n![image](https://assets.leetcode.com/users/images/cde1f912-6be2-46aa-8b55-99c98b167770_1619084518.2493339.png)\\nWe decide to use \"*\" between 5 and 8: we update the two registers in a fixed way: reg1 = reg1 * reg2, reg2 = next digits. Change the ptr to reg2. Now the reg1 = 5 * 1 = 5,  reg2 = 8,  ptr = reg2\\n\\n\\nSecond blank:\\n![image](https://assets.leetcode.com/users/images/050361bf-df4a-48c9-a281-97857ec75bc6_1619084858.448591.png)\\nIn the second blank, we choose * anew. Again, update two registers with the same rule and change the ptr to 2(not changed). After that, \\nreg1 = 5 * 8 = 40    reg2 = 9  ptr = reg2\\n\\n\\nThrid blank:\\n![image](https://assets.leetcode.com/users/images/a4037de7-6378-4a5e-8306-10119c915ecc_1619086227.804287.png)\\nHere we decide to use \"-\". As we said before, move the left part to the right and the left part is given by reg1 * reg2 = 360. Then we change reg1 to next digit -6; set reg2 = 1, and set ptr back to reg1. The equation becomes:\\n![image](https://assets.leetcode.com/users/images/d7a86855-04fe-41a5-82f1-77320ad01271_1619086504.715896.png)\\n\\n\\nFifth blank:\\n![image](https://assets.leetcode.com/users/images/fe1c4598-a9db-424a-bf42-ec64182b48ad_1619086668.9973226.png)\\nIf we choose \"~\" for this blank, we need to merge the next digit (2 here) with the register pointer by ptr, that is, reg1.\\nThen we have: reg1=  -62  reg2 = 1  ptr = reg1.\\n\\n...\\n\\nSo in a nutshell, \\nwhen we use \"+\" or \"-\", we should move the left part to the right by set right -= reg1 * reg2, and set reg1=reg2=1, ptr = reg1;\\nwhen we use \"*\", set reg1 *= reg2, and reg2 = next digits, ptr = reg2;\\nwhen we use \"~\", set the reg? pointed by ptr to combine(reg?, next digit).\\n\\nIn the end, if we find reg1 * reg2 = right, this combination of operators is valid.\\n\\n**IV. The final solution**\\n\\tThis solution owns nice performance.\\n\\t![image](https://assets.leetcode.com/users/images/f79db340-220c-45e8-9511-d9215c8c31ce_1613575140.6618643.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n\\n    long long combine(long long a, long long b){\\n        /**\\n         * you need to make sure: a ! = 0\\n         * combine(54,8) = 548 combine(-42,8) = -428\\n        */\\n        bool negative = (a<0);\\n        a = abs(a);\\n        return (negative)? -(a*10 + b) : (a*10 + b);\\n    }\\n\\n    void handle(const string& num, const long long& target, const int& index, \\n\\t\\t\\t\\tconst long long B1, const long long B2,const int ptr, char* op_rec){\\n        if(index == num.size()-1){\\n            // reach the end\\n            if(target - B1*B2 == 0){\\n                // this is a feasible solution! Store it in res.\\n                string temp = to_string(num[0]-\\'0\\');\\n                for(int i=0;i<num.size()-1;++i){\\n                    if(op_rec[i] == \\'~\\')\\n                        temp += num[i+1];\\n                    else {\\n                        temp += op_rec[i];\\n                        temp += num[i+1];  \\n                    }\\n                }\\n                res.push_back(temp);\\n            }\\n            // nope, do nothing.\\n            return;\\n        }\\n        long long next_target;\\n        int digit = num[index + 1] - \\'0\\';\\n        // not the end\\n        // \"+\"\\n        op_rec[index] = \\'+\\';\\n        next_target = target - B1 * B2;\\n        handle(num,next_target,index+1,digit,1,1,op_rec);\\n\\n        // \"-\"\\n        op_rec[index] = \\'-\\';\\n        //next_target = target - B1 * B2; same as above\\n        handle(num,next_target,index+1,-digit,1,1,op_rec);\\n\\n        // \"*\"\\n        op_rec[index] = \\'*\\';\\n        handle(num,target,index+1,B1*B2,digit,2,op_rec);\\n\\n        // \"~\"\\n        op_rec[index] = \\'~\\';\\n        long long B1_copy = B1;\\n        long long B2_copy = B2;\\n        if(ptr == 1 && B1 != 0)\\n            // you cannot combine 0 and 9 to 09\\n            B1_copy = combine(B1_copy,digit);\\n        else if(ptr == 2 & B2 != 0)\\n            B2_copy = combine(B2_copy,digit);\\n        else\\n            return;\\n        handle(num,target,index+1,B1_copy,B2_copy,ptr,op_rec);\\n    }\\n\\n    vector<string> addOperators(string num, int target) {\\n        if(num.empty())\\n            return res;\\n        char *op_rec = new char[num.size()-1];\\n        int index = 0;\\n        long long B1 = num[0] - \\'0\\', B2 = 1;\\n        int ptr = 1;\\n\\n        handle(num,target,index,B1,B2,ptr,op_rec);\\n        delete[] op_rec;\\n        return res;\\n    }\\n    \\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n\\n    long long combine(long long a, long long b){\\n        /**\\n         * you need to make sure: a ! = 0\\n         * combine(54,8) = 548 combine(-42,8) = -428\\n        */\\n        bool negative = (a<0);\\n        a = abs(a);\\n        return (negative)? -(a*10 + b) : (a*10 + b);\\n    }\\n\\n    void handle(const string& num, const long long& target, const int& index, \\n\\t\\t\\t\\tconst long long B1, const long long B2,const int ptr, char* op_rec){\\n        if(index == num.size()-1){\\n            // reach the end\\n            if(target - B1*B2 == 0){\\n                // this is a feasible solution! Store it in res.\\n                string temp = to_string(num[0]-\\'0\\');\\n                for(int i=0;i<num.size()-1;++i){\\n                    if(op_rec[i] == \\'~\\')\\n                        temp += num[i+1];\\n                    else {\\n                        temp += op_rec[i];\\n                        temp += num[i+1];  \\n                    }\\n                }\\n                res.push_back(temp);\\n            }\\n            // nope, do nothing.\\n            return;\\n        }\\n        long long next_target;\\n        int digit = num[index + 1] - \\'0\\';\\n        // not the end\\n        // \"+\"\\n        op_rec[index] = \\'+\\';\\n        next_target = target - B1 * B2;\\n        handle(num,next_target,index+1,digit,1,1,op_rec);\\n\\n        // \"-\"\\n        op_rec[index] = \\'-\\';\\n        //next_target = target - B1 * B2; same as above\\n        handle(num,next_target,index+1,-digit,1,1,op_rec);\\n\\n        // \"*\"\\n        op_rec[index] = \\'*\\';\\n        handle(num,target,index+1,B1*B2,digit,2,op_rec);\\n\\n        // \"~\"\\n        op_rec[index] = \\'~\\';\\n        long long B1_copy = B1;\\n        long long B2_copy = B2;\\n        if(ptr == 1 && B1 != 0)\\n            // you cannot combine 0 and 9 to 09\\n            B1_copy = combine(B1_copy,digit);\\n        else if(ptr == 2 & B2 != 0)\\n            B2_copy = combine(B2_copy,digit);\\n        else\\n            return;\\n        handle(num,target,index+1,B1_copy,B2_copy,ptr,op_rec);\\n    }\\n\\n    vector<string> addOperators(string num, int target) {\\n        if(num.empty())\\n            return res;\\n        char *op_rec = new char[num.size()-1];\\n        int index = 0;\\n        long long B1 = num[0] - \\'0\\', B2 = 1;\\n        int ptr = 1;\\n\\n        handle(num,target,index,B1,B2,ptr,op_rec);\\n        delete[] op_rec;\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954157,
                "title": "simple-go-solution-with-backtracking",
                "content": "```golang\\nimport (\\n    \"strconv\"\\n)\\n\\n\\nfunc addOperators(num string, target int) []string {\\n    out := []string{}\\n    \\n    var backtrack func(string, string, int, int)\\n    \\n    backtrack = func(num, prefix string, val, last int) {\\n        if len(num) == 0 {\\n            if val == target {\\n                out = append(out, prefix)\\n            }\\n            return\\n        }\\n        \\n        for i := 1; i <= len(num); i++ {\\n            str := num[:i]\\n            digit, _ := strconv.Atoi(str)\\n            \\n\\t\\t\\t// prevent numbers starting with 0 except the number 0 itself\\n            if num[0] == \\'0\\'&& i != 1 {\\n                continue\\n            }\\n            \\n\\t\\t\\t// for the first call\\n            if prefix == \"\" {\\n                backtrack(num[i:], str, digit, digit)\\n            } else {\\n                backtrack(num[i:], prefix + \"+\" + str, val + digit, digit)\\n                backtrack(num[i:], prefix + \"-\" + str, val - digit, -digit)\\n                backtrack(num[i:], prefix + \"*\" + str, val - last + last * digit, last * digit)\\n            }\\n        }\\n    }\\n    \\n    backtrack(num, \"\", 0, 0)\\n    \\n    return out\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nimport (\\n    \"strconv\"\\n)\\n\\n\\nfunc addOperators(num string, target int) []string {\\n    out := []string{}\\n    \\n    var backtrack func(string, string, int, int)\\n    \\n    backtrack = func(num, prefix string, val, last int) {\\n        if len(num) == 0 {\\n            if val == target {\\n                out = append(out, prefix)\\n            }\\n            return\\n        }\\n        \\n        for i := 1; i <= len(num); i++ {\\n            str := num[:i]\\n            digit, _ := strconv.Atoi(str)\\n            \\n\\t\\t\\t// prevent numbers starting with 0 except the number 0 itself\\n            if num[0] == \\'0\\'&& i != 1 {\\n                continue\\n            }\\n            \\n\\t\\t\\t// for the first call\\n            if prefix == \"\" {\\n                backtrack(num[i:], str, digit, digit)\\n            } else {\\n                backtrack(num[i:], prefix + \"+\" + str, val + digit, digit)\\n                backtrack(num[i:], prefix + \"-\" + str, val - digit, -digit)\\n                backtrack(num[i:], prefix + \"*\" + str, val - last + last * digit, last * digit)\\n            }\\n        }\\n    }\\n    \\n    backtrack(num, \"\", 0, 0)\\n    \\n    return out\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 887544,
                "title": "c-simple",
                "content": "```\\n vector<string> arr;\\n    \\n    void helper(string & num, int target, int start, int end, long sum, string s, int last){\\n        if(target == sum && start == num.length()){\\n            arr.push_back(s);\\n            return;\\n        }\\n        if(start <= end){\\n            string temp = \"\";\\n            for(int i=start;i<=end;i++){\\n                if(i!=start && num[start] == \\'0\\')\\n                    break;\\n                temp+=num[i];\\n                long n = stol(temp);\\n                if(start == 0)\\n                    helper(num, target, i+1, end, n, temp, n);\\n                else{\\n                    helper(num, target, i+1, end, sum+n,  s+\"+\"+temp, n);\\n                    helper(num, target, i+1, end, sum-n,  s+\"-\"+temp, -1*n);\\n                    helper(num, target, i+1, end, sum - last +last*n,  s+\"*\"+temp, last*n);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) {\\n        helper(num, target, 0, num.length()-1, 0, \"\", 0);\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<string> arr;\\n    \\n    void helper(string & num, int target, int start, int end, long sum, string s, int last){\\n        if(target == sum && start == num.length()){\\n            arr.push_back(s);\\n            return;\\n        }\\n        if(start <= end){\\n            string temp = \"\";\\n            for(int i=start;i<=end;i++){\\n                if(i!=start && num[start] == \\'0\\')\\n                    break;\\n                temp+=num[i];\\n                long n = stol(temp);\\n                if(start == 0)\\n                    helper(num, target, i+1, end, n, temp, n);\\n                else{\\n                    helper(num, target, i+1, end, sum+n,  s+\"+\"+temp, n);\\n                    helper(num, target, i+1, end, sum-n,  s+\"-\"+temp, -1*n);\\n                    helper(num, target, i+1, end, sum - last +last*n,  s+\"*\"+temp, last*n);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) {\\n        helper(num, target, 0, num.length()-1, 0, \"\", 0);\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797728,
                "title": "python-dfs-intuitive-no-helper-function",
                "content": "We store such information in each node: next_index to add in our path, current path and if our current expression has a leading zero.\\n\\nSince we can not have expressions like (1+05), we need to keep track of if our current path has a leading zero. This can be done by judging if num[index] is zero because we are adding path+ops+num[index] to the stack.\\n\\nHowever, my implementation is very slow, any suggestions to improve would be appreciated. Current implementation is O(N^4) because in between each number we have to decide among +, -, * and no operator (4 possible chocies). And there are n-1 such decisions we have to make since there are n numbers. I don\\'t think we can get around this amount of cost. However, I do believe there might be some ways to optimize from implementation point of view.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n        stack = [(1, num[0], num[0]==\\'0\\')] # next_index, path, has_leading_zero\\n        ans = []\\n        while stack:\\n            index, path, zero = stack.pop()\\n            if index == len(num):\\n                if eval(path) == target:\\n                    ans.append(path)\\n            if index < len(num):\\n                if not zero:\\n                    stack.append((index+1, path+num[index], zero))\\n                stack.append((index+1, path+\\'+\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'-\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'*\\'+num[index], num[index]==\\'0\\'))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n        stack = [(1, num[0], num[0]==\\'0\\')] # next_index, path, has_leading_zero\\n        ans = []\\n        while stack:\\n            index, path, zero = stack.pop()\\n            if index == len(num):\\n                if eval(path) == target:\\n                    ans.append(path)\\n            if index < len(num):\\n                if not zero:\\n                    stack.append((index+1, path+num[index], zero))\\n                stack.append((index+1, path+\\'+\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'-\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'*\\'+num[index], num[index]==\\'0\\'))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696519,
                "title": "python-backtracking-very-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. Draw backtracking tree starting with \"\" and 1st level being number for num 123: its 1 or 12 or 123 (attach *, -, + and send for dfs)\\n\\t\\t#\\t2. When you are the last digit, donot send for dfs, compute the result\\n        #   3. Check out for some interesting edge cases, interviewer is looking for those you to solve.\\n\\t\\t# edge cases : 105 5, 100009 9, 569 45\\n        \\n        ## TIME COMPLEXICITY : O(4^N) ## (each level you are creating 4 branches)\\n\\t\\t## SPACE COMPLEXICITY : O(4^N) ##\\n        \\n        def dfs( curr, num ):\\n            if curr in visited:\\n                return\\n            visited.add(curr)\\n            for i, ch in enumerate(num):\\n                if i == len(num) - 1:     # when you are at last digit, calculate the result\\n                    if eval(curr + num) == target:\\n                        result.append(curr + num)\\n                else:\\n                    dfs( curr + num[:i+1] + \"*\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"-\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"+\", num[i+1:])\\n                \\n                if num[:i+1] == \"0\":     # edge case, in the number you are sending in if the first digit is 0, donot send further. ex: 105, send 0 but not 05.\\n                    break\\n        result = []\\n        visited = set()\\n        dfs( \"\", num )\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. Draw backtracking tree starting with \"\" and 1st level being number for num 123: its 1 or 12 or 123 (attach *, -, + and send for dfs)\\n\\t\\t#\\t2. When you are the last digit, donot send for dfs, compute the result\\n        #   3. Check out for some interesting edge cases, interviewer is looking for those you to solve.\\n\\t\\t# edge cases : 105 5, 100009 9, 569 45\\n        \\n        ## TIME COMPLEXICITY : O(4^N) ## (each level you are creating 4 branches)\\n\\t\\t## SPACE COMPLEXICITY : O(4^N) ##\\n        \\n        def dfs( curr, num ):\\n            if curr in visited:\\n                return\\n            visited.add(curr)\\n            for i, ch in enumerate(num):\\n                if i == len(num) - 1:     # when you are at last digit, calculate the result\\n                    if eval(curr + num) == target:\\n                        result.append(curr + num)\\n                else:\\n                    dfs( curr + num[:i+1] + \"*\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"-\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"+\", num[i+1:])\\n                \\n                if num[:i+1] == \"0\":     # edge case, in the number you are sending in if the first digit is 0, donot send further. ex: 105, send 0 but not 05.\\n                    break\\n        result = []\\n        visited = set()\\n        dfs( \"\", num )\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441680,
                "title": "accepted-c-backtracking-solution-easy-to-understand-w-comments-fast-93-14-memory-100",
                "content": "\\npublic class Solution \\n{\\n\\n    private List<string> answers;\\n    private string num;\\n    private int target;\\n    \\n    public IList<string> AddOperators(string num, int target) {        \\n        if (num == null || num.Length == 0)\\n            return new List<string>();\\n        \\n        // class member usage for readability\\n        this.num = num;\\n        this.target = target;\\n        this.answers = new List<string>();        \\n        \\n        process(0, 0, 0, 0, new StringBuilder());\\n        \\n        return answers;\\n    }\\n    \\n    // Retrieving answers during recursive procedure call\\n    // Type long is used to avoid integer overflows\\n    // StringBuilder is used to speed up the execution and reduce memory consumption\\n    private void process(int index, long previousOperand, long currentOperand, long value, StringBuilder expression)\\n    {\\n        if (index == num.Length)\\n        {\\n            // new answer found\\n            // value 0 is used for expression validation\\n            if (value == target && currentOperand == 0)\\n                answers.Add(expression.ToString());\\n            return;\\n        }\\n                \\n        // Case 0 - create multi-digit number\\n        currentOperand = currentOperand * 10 + int.Parse(num[index].ToString());\\n        string sop = currentOperand.ToString();\\n\\n        if (currentOperand > 0)\\n        {\\n            // Case 1 - proceed with no operation only if it does not start with 0 e.g. 05\\n            process(index + 1, previousOperand, currentOperand, value, expression);\\n        }\\n         \\n        if (expression.Length == 0)\\n        {\\n            // Case 2 - proceed with first number\\n            process(index + 1, currentOperand, 0, currentOperand, expression.Append(sop));\\n            expression.Length = expression.Length - sop.Length;\\n        }\\n        else\\n        {\\n            // Case 3 - proceed with addition\\n            process(index + 1, currentOperand, 0, value + currentOperand, expression.Append(\"+\").Append(sop));\\n            expression.Length = expression.Length - sop.Length - 1;\\n\\n            // Case 4 - proceed with subtraction\\n            process(index + 1, -currentOperand, 0, value - currentOperand, expression.Append(\"-\").Append(sop));\\n            expression.Length = expression.Length - sop.Length - 1;\\n\\n            // Case 5 - proceed with multiplication\\n            process(index + 1, previousOperand * currentOperand, 0, value - previousOperand + (previousOperand * currentOperand), expression.Append(\"*\").Append(sop));            \\n            expression.Length = expression.Length - sop.Length - 1;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n\\n    private List<string> answers;\\n    private string num;\\n    private int target;\\n    \\n    public IList<string> AddOperators(string num, int target) {        \\n        if (num == null || num.Length == 0)\\n            return new List<string>();\\n        \\n        // class member usage for readability\\n        this.num = num;\\n        this.target = target;\\n        this.answers = new List<string>();        \\n        \\n        process(0, 0, 0, 0, new StringBuilder());\\n        \\n        return answers;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 404755,
                "title": "c-easy-to-understand-backtracking",
                "content": "```C++\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tstring cur = \"\";\\n\\taddOperators(num, 0, target, 0, 1, cur, res);\\n\\treturn res;\\n}\\n\\nvoid addOperators(string num, int index, int target, long val, long mult, string &cur,\\n\\t\\t\\t\\t  vector<string> &res) {\\n\\tif (index == num.length()) {\\n\\t\\tif (val == target) {\\n\\t\\t\\tres.push_back(cur);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tint len = cur.size();\\n\\tfor (int i = index; i < num.length(); i++) {\\n\\t\\tstring sVal = num.substr(index, i - index + 1);\\n\\t\\tlong n = stol(sVal);\\n\\t\\tif (index == 0) {\\n\\t\\t\\tcur += sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t} else {\\n\\t\\t\\t// +\\n\\t\\t\\tcur += \"+\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val + n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// -\\n\\t\\t\\tcur += \"-\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - n, -n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// *\\n\\t\\t\\tcur += \"*\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - mult + mult * n, mult * n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t}\\n\\t\\tif (n == 0) return;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tstring cur = \"\";\\n\\taddOperators(num, 0, target, 0, 1, cur, res);\\n\\treturn res;\\n}\\n\\nvoid addOperators(string num, int index, int target, long val, long mult, string &cur,\\n\\t\\t\\t\\t  vector<string> &res) {\\n\\tif (index == num.length()) {\\n\\t\\tif (val == target) {\\n\\t\\t\\tres.push_back(cur);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tint len = cur.size();\\n\\tfor (int i = index; i < num.length(); i++) {\\n\\t\\tstring sVal = num.substr(index, i - index + 1);\\n\\t\\tlong n = stol(sVal);\\n\\t\\tif (index == 0) {\\n\\t\\t\\tcur += sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t} else {\\n\\t\\t\\t// +\\n\\t\\t\\tcur += \"+\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val + n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// -\\n\\t\\t\\tcur += \"-\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - n, -n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// *\\n\\t\\t\\tcur += \"*\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - mult + mult * n, mult * n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t}\\n\\t\\tif (n == 0) return;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 385450,
                "title": "python-solution-320ms-18-lines-with-easy-to-understand-variable-names-and-explanation",
                "content": "Reference: https://leetcode.com/problems/expression-add-operators/discuss/128460/simple-Python-DFS-that-beats-100\\n```\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num: return []\\n        res = []\\n\\n        def helper(start, expr, val, prev):\\n            if val == target and start == len(num):\\n                res.append(expr); return\\n\\t\\t\\tif start < len(num) and max(1, abs(prev)) * (int(num[start:])) < abs(target - val): return   # target not reachable\\n            for i in range(start, len(num)):\\n                curr = num[start: i+1]\\n                if len(curr) != len(str(int(curr))): break   # prevent \\'00\\',\\'01\\',... treated as one number\\n                if start == 0:\\n                    helper(i+1, curr, int(curr), int(curr))\\n                else:\\n                    helper(i+1, expr+\\'+\\'+curr, val+int(curr), int(curr))\\n                    helper(i+1, expr+\\'-\\'+curr, val-int(curr), -int(curr))   # -curr is interpreted as +(-curr)\\n                    helper(i+1, expr+\\'*\\'+curr, val-prev+prev*int(curr), prev*int(curr))   # since * has precedence over + we have to roll back +prev\\n        \\n        helper(0, \\'\\', 0, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num: return []\\n        res = []\\n\\n        def helper(start, expr, val, prev):\\n            if val == target and start == len(num):\\n                res.append(expr); return\\n\\t\\t\\tif start < len(num) and max(1, abs(prev)) * (int(num[start:])) < abs(target - val): return   # target not reachable\\n            for i in range(start, len(num)):\\n                curr = num[start: i+1]\\n                if len(curr) != len(str(int(curr))): break   # prevent \\'00\\',\\'01\\',... treated as one number\\n                if start == 0:\\n                    helper(i+1, curr, int(curr), int(curr))\\n                else:\\n                    helper(i+1, expr+\\'+\\'+curr, val+int(curr), int(curr))\\n                    helper(i+1, expr+\\'-\\'+curr, val-int(curr), -int(curr))   # -curr is interpreted as +(-curr)\\n                    helper(i+1, expr+\\'*\\'+curr, val-prev+prev*int(curr), prev*int(curr))   # since * has precedence over + we have to roll back +prev\\n        \\n        helper(0, \\'\\', 0, 0)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 317731,
                "title": "java-dfs-139-ms-faster-than-20-95-61-1-mb-less-than-40-86",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(String num, int target, int pos, String str, long sum, long last, List<String> res) {\\n        if (pos == num.length()) {\\n            if (sum == target) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n        for (int i = pos; i < num.length(); ++i) {\\n            long x = Long.valueOf(num.substring(pos, i + 1));\\n            if (pos == 0) {\\n                dfs(num, target, i + 1, str + x, x, x, res);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + x, sum - last + last * x, last * x, res);\\n                dfs(num, target, i + 1, str + \"-\" + x, sum - x, -x, res);\\n                dfs(num, target, i + 1, str + \"+\" + x, sum + x, x, res);\\n            }\\n            if (x == 0) {\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(String num, int target, int pos, String str, long sum, long last, List<String> res) {\\n        if (pos == num.length()) {\\n            if (sum == target) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n        for (int i = pos; i < num.length(); ++i) {\\n            long x = Long.valueOf(num.substring(pos, i + 1));\\n            if (pos == 0) {\\n                dfs(num, target, i + 1, str + x, x, x, res);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + x, sum - last + last * x, last * x, res);\\n                dfs(num, target, i + 1, str + \"-\" + x, sum - x, -x, res);\\n                dfs(num, target, i + 1, str + \"+\" + x, sum + x, x, res);\\n            }\\n            if (x == 0) {\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71906,
                "title": "c-backtracking",
                "content": "C++ version of this [solution](https://discuss.leetcode.com/topic/24523/java-standard-backtrace-ac-solutoin-short-and-clear/12).\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string>res;\\n        backtrack(res, num, target, 0, 0, 0, \"\");\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string num, int target, int pos, long sum, long multiply, string path){\\n        if(pos == num.size()){\\n            if(target == sum) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < num.size(); i++){\\n            if(i != pos && num[pos] == '0') break;\\n            long cur = stol(num.substr(pos, i - pos + 1));\\n            if(pos == 0){\\n                backtrack(res, num, target, i + 1, cur, cur, path + to_string(cur));\\n            }\\n            else{\\n                backtrack(res, num, target, i + 1, sum + cur, cur, path + \"+\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - cur, -cur, path + \"-\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - multiply + multiply * cur, multiply * cur, path + \"*\" + to_string(cur));    \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string>res;\\n        backtrack(res, num, target, 0, 0, 0, \"\");\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string num, int target, int pos, long sum, long multiply, string path){\\n        if(pos == num.size()){\\n            if(target == sum) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < num.size(); i++){\\n            if(i != pos && num[pos] == '0') break;\\n            long cur = stol(num.substr(pos, i - pos + 1));\\n            if(pos == 0){\\n                backtrack(res, num, target, i + 1, cur, cur, path + to_string(cur));\\n            }\\n            else{\\n                backtrack(res, num, target, i + 1, sum + cur, cur, path + \"+\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - cur, -cur, path + \"-\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - multiply + multiply * cur, multiply * cur, path + \"*\" + to_string(cur));    \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71930,
                "title": "clean-c-dfs-solution-beating-96",
                "content": "Base on Basic Calculator II, the handling for * is that, we keep a prev variable to keep track of the previous addition or subtraction operation, when we what to use * operator, we can do:\\n\\ncurrent_sum = current_sum - prev + prev * operand,\\nprev = prev * operand\\n\\nThen we just need to use DFS to enumerate all possibilities of adding multiplication, addition, subtraction operators at each possible positions.\\n\\nOne thing we need to pay attention is that if the current number has more than 1 digits, and it's starting with a 0, then this is not a valid case.\\n\\n```\\n    vector<string> addOperators(string num, int target) {\\n        string path;\\n        vector<string> result;\\n        dfs(num, 0, 0, target, 0, path, result);\\n        return result;\\n    }\\n    \\n    void dfs(const string& num, int pos, long long sum, int target, long long prev, string& path, vector<string>& result) {\\n        if (pos >= num.size()) {\\n            if (sum == target) result.push_back(path);\\n            return;\\n        }\\n        \\n        long long left = 0;\\n        int size = path.size();\\n        string buffer;\\n        for (int i=pos; i<num.size(); i++) {\\n            left = left * 10 + num[i] - '0';\\n            buffer.push_back(num[i]);\\n            if (pos == 0) {\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n            } else {\\n                path += \"+\";\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n                \\n                path += \"-\";\\n                path += buffer;\\n                dfs(num, i+1, sum-left, target, -left, path, result);\\n                path.resize(size);\\n                \\n                path += \"*\";\\n                path += buffer;\\n                dfs(num, i+1, sum-prev+prev*left, target, prev*left, path, result);\\n                path.resize(size);\\n            }\\n            if (num[pos] == '0') break;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> addOperators(string num, int target) {\\n        string path;\\n        vector<string> result;\\n        dfs(num, 0, 0, target, 0, path, result);\\n        return result;\\n    }\\n    \\n    void dfs(const string& num, int pos, long long sum, int target, long long prev, string& path, vector<string>& result) {\\n        if (pos >= num.size()) {\\n            if (sum == target) result.push_back(path);\\n            return;\\n        }\\n        \\n        long long left = 0;\\n        int size = path.size();\\n        string buffer;\\n        for (int i=pos; i<num.size(); i++) {\\n            left = left * 10 + num[i] - '0';\\n            buffer.push_back(num[i]);\\n            if (pos == 0) {\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n            } else {\\n                path += \"+\";\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n                \\n                path += \"-\";\\n                path += buffer;\\n                dfs(num, i+1, sum-left, target, -left, path, result);\\n                path.resize(size);\\n                \\n                path += \"*\";\\n                path += buffer;\\n                dfs(num, i+1, sum-prev+prev*left, target, prev*left, path, result);\\n                path.resize(size);\\n            }\\n            if (num[pos] == '0') break;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71931,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Expression Add Operators** https://leetcode.com/problems/expression-add-operators/\\n\\n**Recursion and Backtracking**\\n1. Make sure you understand the problem: 1234 does not mean adding brackets, we just need to add operators.\\n2. 1234 = Processed \"12\" and now handle the substring \"34\".\\n3. We could have processed \"12\" in many ways. But when we reach the part of \"34\", we just care about the value computed so far and the immediate prev value.\\n4. For example: \"1+2\", \"1-2\", \"1\\\\*2\" would have a so_far value as 3,-1,2 and previous value as 2,-2,2.\\n5. When we reach \"34\", we would have arrived from one of the paths like \"1+2\", \"1-2\", \"1\\\\*2\". We therefore know the prev value. This is needed for multiplication part since (1+2)\\\\*3 should be really 1+2\\\\*3 since we dont have any brackets. Hence we do 1+2-2+2\\\\*3\\n```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(0, num, 0, 0, \"\", target, results)\\n        return results\\n    \\n    def helper(self, k, num, ssum, prev, e, t, res):\\n        if k == len(num):\\n            if ssum == t:\\n                res.append(\"\".join([x for x in e]))\\n        else:\\n            for i in range(k, len(num)):\\n                left = num[k:i+1]\\n                ileft = int(left)\\n                if left[0] == \"0\" and len(left) > 1: ### IGNORE INPUT LIKE \"00\", \"005\", \"0006\"\\n                    continue\\n                if k == 0:\\n                    self.helper(i+1, num, ileft, ileft, left, t, res)\\n                else:\\n                    self.helper(i+1, num, ssum+ileft, ileft, e+\"+\"+left, t, res)\\n                    self.helper(i+1, num, ssum-ileft, ileft*-1, e+\"-\"+left, t, res)\\n                    self.helper(i+1, num, ssum-prev+ileft*prev, ileft*prev, e+\"*\"+left, t, res)\\n            return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(0, num, 0, 0, \"\", target, results)\\n        return results\\n    \\n    def helper(self, k, num, ssum, prev, e, t, res):\\n        if k == len(num):\\n            if ssum == t:\\n                res.append(\"\".join([x for x in e]))\\n        else:\\n            for i in range(k, len(num)):\\n                left = num[k:i+1]\\n                ileft = int(left)\\n                if left[0] == \"0\" and len(left) > 1: ### IGNORE INPUT LIKE \"00\", \"005\", \"0006\"\\n                    continue\\n                if k == 0:\\n                    self.helper(i+1, num, ileft, ileft, left, t, res)\\n                else:\\n                    self.helper(i+1, num, ssum+ileft, ileft, e+\"+\"+left, t, res)\\n                    self.helper(i+1, num, ssum-ileft, ileft*-1, e+\"-\"+left, t, res)\\n                    self.helper(i+1, num, ssum-prev+ileft*prev, ileft*prev, e+\"*\"+left, t, res)\\n            return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71987,
                "title": "my-short-python-accepted-code",
                "content": "    class Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def solve(target, pos, negate, prod):\\n            expr = []\\n\\n            for i in xrange(pos, len(num)):\\n                if i > pos and num[pos] == \"0\":\\n                    break\\n\\n                if i == len(num) -1:\\n                    if negate * prod * int(num[pos:i+1]) == target:\\n                        expr.extend([num[pos:i+1]])\\n                    break\\n                \\n                add_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, 1, 1)\\n                expr.extend([num[pos:i+1] + \"+\" + e for e in add_expr])\\n\\n                sub_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, -1, 1)     \\n                expr.extend([num[pos:i+1] + \"-\" + e for e in sub_expr])\\n\\n                mul_expr = solve(target, i+1, 1, prod * negate * long(num[pos:i+1]))\\n                expr.extend([num[pos:i+1] + \"*\" + e for e in mul_expr])\\n\\n            return expr\\n        \\n        return solve(target, 0, 1, 1)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def solve(target, pos, negate, prod):\\n            expr = []\\n\\n            for i in xrange(pos, len(num)):\\n                if i > pos and num[pos] == \"0\":\\n                    break\\n\\n                if i == len(num) -1:\\n                    if negate * prod * int(num[pos:i+1]) == target:\\n                        expr.extend([num[pos:i+1]])\\n                    break\\n                \\n                add_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, 1, 1)\\n                expr.extend([num[pos:i+1] + \"+\" + e for e in add_expr])\\n\\n                sub_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, -1, 1)     \\n                expr.extend([num[pos:i+1] + \"-\" + e for e in sub_expr])\\n\\n                mul_expr = solve(target, i+1, 1, prod * negate * long(num[pos:i+1]))\\n                expr.extend([num[pos:i+1] + \"*\" + e for e in mul_expr])\\n\\n            return expr\\n        \\n        return solve(target, 0, 1, 1)",
                "codeTag": "Java"
            },
            {
                "id": 2449863,
                "title": "c-code-for-beginners-backtracking-evaluate-on-the-fly-simple-code",
                "content": "```\\nclass Solution {\\npublic:    \\n    void generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){  // n-curr is the remaining length of the string num\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){  // can not be having leading zeroes in size>1\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n); // ADD\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);  //SUBTRACT\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);  \\n\\t\\t\\t// MULTIPLY, Notice:- the previous Number is currNum*prevNumber, this is because a multiplication will take the previous number with it, and then proceed\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){  // n-curr is the remaining length of the string num\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){  // can not be having leading zeroes in size>1\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n); // ADD\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);  //SUBTRACT\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);  \\n\\t\\t\\t// MULTIPLY, Notice:- the previous Number is currNum*prevNumber, this is because a multiplication will take the previous number with it, and then proceed\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092254,
                "title": "c-concise-recursive-solution",
                "content": "**[C++] Solution for finding expressions with operators that gives target as result:**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        addOperatorsAndEvaluate(num, target, 0, \"\", 0, 0);\\n        return expressions;\\n    }\\n    \\nprivate:\\n    vector<string> expressions;\\n    void addOperatorsAndEvaluate(string& nums, int& target, int index, string exp, long value, long prev) {\\n        if (index==nums.size()) {\\n            if (value == target) {\\n                expressions.push_back(exp);\\n            }\\n            return;\\n        }\\n        \\n        string numStr = \"\";\\n        long num = 0;\\n        for(int j=index; j<nums.size(); j++) {\\n            // Handling the case for avoiding numbers with leading 0\\n            if (j>index && nums[index]==\\'0\\') break;\\n            \\n            numStr += nums[j];\\n            num = num*10 + (nums[j]-\\'0\\');\\n            \\n            if (exp.size()==0) {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+numStr, num, num);\\n            } else {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'+\\'+numStr, value+num, num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'-\\'+numStr, value-num, -num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'*\\'+numStr, (value-prev)+(prev*num), prev*num);\\n            }\\n        }\\n    }\\n};\\n```\\n\\nPlease do **upvote** if you find this helpful.\\nFeel free to add your comments or ask queries.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        addOperatorsAndEvaluate(num, target, 0, \"\", 0, 0);\\n        return expressions;\\n    }\\n    \\nprivate:\\n    vector<string> expressions;\\n    void addOperatorsAndEvaluate(string& nums, int& target, int index, string exp, long value, long prev) {\\n        if (index==nums.size()) {\\n            if (value == target) {\\n                expressions.push_back(exp);\\n            }\\n            return;\\n        }\\n        \\n        string numStr = \"\";\\n        long num = 0;\\n        for(int j=index; j<nums.size(); j++) {\\n            // Handling the case for avoiding numbers with leading 0\\n            if (j>index && nums[index]==\\'0\\') break;\\n            \\n            numStr += nums[j];\\n            num = num*10 + (nums[j]-\\'0\\');\\n            \\n            if (exp.size()==0) {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+numStr, num, num);\\n            } else {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'+\\'+numStr, value+num, num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'-\\'+numStr, value-num, -num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'*\\'+numStr, (value-prev)+(prev*num), prev*num);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963629,
                "title": "easy-to-understand-c-code",
                "content": "* ***Using Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    void helper(string str, int target, int i, string curr, long long res_so_far, long long prev_num)\\n    {\\n        if(i == str.size())\\n        {\\n            if(res_so_far == target)\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(int j = i; j < str.size(); j++)\\n        {\\n            if(j > i && str[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            \\n            string curr_str = str.substr(i, j - i + 1);\\n            \\n            long long curr_num = stoll(curr_str);\\n            \\n            if(i == 0)\\n            {\\n                helper(str, target, j + 1, curr + curr_str, curr_num, curr_num);\\n            }\\n            else\\n            {\\n                helper(str, target, j + 1, curr + \"+\" + curr_str, res_so_far + curr_num, curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"-\" + curr_str, res_so_far - curr_num, -curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"*\" + curr_str, res_so_far - prev_num + prev_num * curr_num, prev_num * curr_num);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string str, int target) {\\n        \\n        int n = str.size();\\n        \\n        helper(str, target, 0, \"\", 0, 0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    void helper(string str, int target, int i, string curr, long long res_so_far, long long prev_num)\\n    {\\n        if(i == str.size())\\n        {\\n            if(res_so_far == target)\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(int j = i; j < str.size(); j++)\\n        {\\n            if(j > i && str[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            \\n            string curr_str = str.substr(i, j - i + 1);\\n            \\n            long long curr_num = stoll(curr_str);\\n            \\n            if(i == 0)\\n            {\\n                helper(str, target, j + 1, curr + curr_str, curr_num, curr_num);\\n            }\\n            else\\n            {\\n                helper(str, target, j + 1, curr + \"+\" + curr_str, res_so_far + curr_num, curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"-\" + curr_str, res_so_far - curr_num, -curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"*\" + curr_str, res_so_far - prev_num + prev_num * curr_num, prev_num * curr_num);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string str, int target) {\\n        \\n        int n = str.size();\\n        \\n        helper(str, target, 0, \"\", 0, 0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897046,
                "title": "c-back-tracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(const string& s, int idx, long long curr, long long val, int target, string& expr, vector<string>& res) {\\n        if (idx == s.size()) {\\n            if (curr == target) {\\n                res.push_back(expr);\\n            }\\n            return;\\n        }\\n        \\n        size_t sz = expr.size();\\n        long long int v = 0;\\n        for (int i = idx; i < s.size(); ++i) {\\n            v = v * 10 + s[i] - \\'0\\';\\n            \\n            string&& sub = s.substr(idx, i - idx + 1);\\n            if (idx == 0) {\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n            } else {\\n                expr += \\'+\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'-\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - v, -v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'*\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - val + v * val, v * val, target, expr, res);\\n                expr.resize(sz);\\n            }\\n            \\n            if (!v) {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        string expr;\\n        vector<string> res;\\n        dfs(num, 0, 0, 0, target, expr, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(const string& s, int idx, long long curr, long long val, int target, string& expr, vector<string>& res) {\\n        if (idx == s.size()) {\\n            if (curr == target) {\\n                res.push_back(expr);\\n            }\\n            return;\\n        }\\n        \\n        size_t sz = expr.size();\\n        long long int v = 0;\\n        for (int i = idx; i < s.size(); ++i) {\\n            v = v * 10 + s[i] - \\'0\\';\\n            \\n            string&& sub = s.substr(idx, i - idx + 1);\\n            if (idx == 0) {\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n            } else {\\n                expr += \\'+\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'-\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - v, -v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'*\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - val + v * val, v * val, target, expr, res);\\n                expr.resize(sz);\\n            }\\n            \\n            if (!v) {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        string expr;\\n        vector<string> res;\\n        dfs(num, 0, 0, 0, target, expr, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888167,
                "title": "java-dsf-solution",
                "content": "```\\n\\tpublic List<String> addOperators(String num, int target) {\\n        result = new ArrayList<String>();\\n        helper(num,0,0,\"\",target,0);\\n        return result;\\n    }\\n    private void helper(String num,int index,long soFar,String temp,int target,long prev){\\n        if(index == num.length()){\\n            if(soFar == target){\\n                result.add(temp);    \\n            }\\n        } else {\\n            for(int i = index; i < num.length(); i ++){\\n                if(i != index && num.charAt(index) == \\'0\\') break;//Any other number can not start with 0\\n                \\n                long curr = Long.valueOf(num.substring(index,i+1));\\n                if(index == 0){//If its first, no need to calculate\\n                    helper(num,i+1,curr,temp+curr,target,curr);\\n                } else {\\n                    long plusValue = curr;\\n                    helper(num,i+1,soFar+plusValue,temp+\"+\"+curr,target,plusValue);\\n                    \\n                    long minusValue = -curr;\\n                    helper(num,i+1,soFar+minusValue,temp+\"-\"+curr,target,minusValue);\\n                    \\n                    long mulValue = prev*curr;\\n                    //subtract previously added value from mulValue\\n                    helper(num,i+1,soFar+mulValue - prev,temp+\"*\"+curr,target,mulValue);\\n                }\\n            }\\n        }\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<String> addOperators(String num, int target) {\\n        result = new ArrayList<String>();\\n        helper(num,0,0,\"\",target,0);\\n        return result;\\n    }\\n    private void helper(String num,int index,long soFar,String temp,int target,long prev){\\n        if(index == num.length()){\\n            if(soFar == target){\\n                result.add(temp);    \\n            }\\n        } else {\\n            for(int i = index; i < num.length(); i ++){\\n                if(i != index && num.charAt(index) == \\'0\\') break;//Any other number can not start with 0\\n                \\n                long curr = Long.valueOf(num.substring(index,i+1));\\n                if(index == 0){//If its first, no need to calculate\\n                    helper(num,i+1,curr,temp+curr,target,curr);\\n                } else {\\n                    long plusValue = curr;\\n                    helper(num,i+1,soFar+plusValue,temp+\"+\"+curr,target,plusValue);\\n                    \\n                    long minusValue = -curr;\\n                    helper(num,i+1,soFar+minusValue,temp+\"-\"+curr,target,minusValue);\\n                    \\n                    long mulValue = prev*curr;\\n                    //subtract previously added value from mulValue\\n                    helper(num,i+1,soFar+mulValue - prev,temp+\"*\"+curr,target,mulValue);\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846436,
                "title": "python-bfs-not-the-fastest-but-easy-to-understand",
                "content": "Disclaimer: I\\'m using the `eval()` built-in. Feel free to replace it with your solution in https://leetcode.com/problems/basic-calculator/\\n\\n#### Idea\\n\\n- Iterate all character `n` in `num`. Between each digit, we can either insert an operater `+`, `-`, `*`, or do nothing.\\n- Keep expanding the list of all possible formula\\n- At the end of the iteration, evaluate each formula, and keep the ones that are equal to `target`\\n \\n```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        candidates = deque()\\n        candidates.append(num[0])\\n        for i in range(1, len(num)):\\n            size = len(candidates)\\n            next_char = num[i]\\n            for _ in range(size):\\n                c = candidates.popleft()\\n                for op in [\"+\", \"-\", \"*\"]:\\n                    candidates.append(c + op + next_char)\\n                if c.endswith(\"0\") and (len(c) == 1 or not c[-2].isnumeric()):\\n                    continue\\n                candidates.append(c + next_char)\\n        return [c for c in candidates if eval(c) == target]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        candidates = deque()\\n        candidates.append(num[0])\\n        for i in range(1, len(num)):\\n            size = len(candidates)\\n            next_char = num[i]\\n            for _ in range(size):\\n                c = candidates.popleft()\\n                for op in [\"+\", \"-\", \"*\"]:\\n                    candidates.append(c + op + next_char)\\n                if c.endswith(\"0\") and (len(c) == 1 or not c[-2].isnumeric()):\\n                    continue\\n                candidates.append(c + next_char)\\n        return [c for c in candidates if eval(c) == target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791871,
                "title": "python-soln-backtrack",
                "content": "\\tclass Solution:\\n\\t\\tdef addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\t\\t# Time O(4^n), Space O(n)\\n\\t\\t\\tdef backtrack(idx, prev,curr,value,s):\\n\\t\\t\\t\\tif idx == n:\\n\\t\\t\\t\\t\\tif value == target and curr == 0:\\n\\t\\t\\t\\t\\t\\tself.result.append(s)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tcurr = curr * 10 + int(num[idx])\\n\\n\\t\\t\\t\\tif curr > 0:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev,curr,value,s)\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, str(curr))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, s+\"+\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, -curr, 0, value-curr, s+\"-\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev*curr, 0, value-prev+prev*curr, s+\"*\"+str(curr))\\n\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tself.result = []\\n\\t\\t\\tbacktrack(0,0,0,0,\"\")\\n\\n\\t\\t\\treturn self.result",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\t\\t# Time O(4^n), Space O(n)\\n\\t\\t\\tdef backtrack(idx, prev,curr,value,s):\\n\\t\\t\\t\\tif idx == n:\\n\\t\\t\\t\\t\\tif value == target and curr == 0:\\n\\t\\t\\t\\t\\t\\tself.result.append(s)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tcurr = curr * 10 + int(num[idx])\\n\\n\\t\\t\\t\\tif curr > 0:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev,curr,value,s)\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, str(curr))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, s+\"+\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, -curr, 0, value-curr, s+\"-\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev*curr, 0, value-prev+prev*curr, s+\"*\"+str(curr))\\n\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tself.result = []\\n\\t\\t\\tbacktrack(0,0,0,0,\"\")\\n\\n\\t\\t\\treturn self.result",
                "codeTag": "Java"
            },
            {
                "id": 1566064,
                "title": "c-clean-and-concise-code",
                "content": "class Solution {\\npublic:\\n    \\n    void func(vector<string>&res,string curExp,string input,long long target,long long pos,long long curVal,long long last){\\n        \\n        if(pos==input.length()){\\n            \\n            if(curVal==target){\\n                res.push_back(curExp);\\n            }\\n            \\n            return;\\n            \\n        }\\n        \\n        for(int i=pos;i<input.length();i++){\\n            \\n            if(i!=pos && input[pos]==\\'0\\'){\\n                break;\\n            }\\n            \\n            string part=input.substr(pos,i+1-pos);\\n            \\n            long long curr=stoll(part);\\n            \\n            if(pos==0){\\n                \\n                func(res,curExp+part,input,target,i+1,curr,curr);\\n                \\n            }\\n            \\n            \\n            else{\\n                \\n                \\n                 func(res,curExp+\"+\"+part,input,target,i+1,curVal+curr,curr);\\n                \\n                 func(res,curExp+\"-\"+part,input,target,i+1,curVal-curr,-curr);\\n                \\n                 func(res,curExp+\"*\"+part,input,target,i+1,curVal-last+last*curr,last*curr);\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        vector<string>res;\\n        \\n        func(res,\"\",num,target,0,0,0);\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void func(vector<string>&res,string curExp,string input,long long target,long long pos,long long curVal,long long last){\\n        \\n        if(pos==input.length()){\\n            \\n            if(curVal==target){\\n                res.push_back(curExp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1541067,
                "title": "python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        res = []\\n        \\n        def recurse(sidx, path, result_so_far, prev_num):\\n            if sidx == len(num):\\n                if result_so_far == target:\\n                    res.append(path[:]) \\n                return\\n            \\n            for i in range(sidx, len(num)):\\n                prefix = num[sidx:i+1]\\n                curr_num = int(prefix)\\n                \\n                if len(prefix) > 1 and prefix[0] == \"0\": return # don\\'t process if there is a leading 0. \\n                \\n                if prev_num is None:\\n                    recurse(i+1, path + prefix, result_so_far + curr_num, curr_num)\\n                else:\\n                    # consider +\\n                    recurse(i+1, path+\\'+\\'+prefix, result_so_far + curr_num, curr_num)\\n                    # consider -\\n                    recurse(i+1, path+\\'-\\'+prefix, result_so_far - curr_num, -curr_num)\\n                    # consider *\\n                    #temp = result_so_far - prev_num\\n                    #result_so_far = temp + curr_num * prev_num\\n                    #prev_num = (curr_num * prev_num) THIS IS THE CRUX of this Problem\\n                    recurse(i+1, path+\\'*\\'+prefix, result_so_far - prev_num + (curr_num * prev_num), (curr_num * prev_num))\\n\\n        recurse(0,\"\", 0, None)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        res = []\\n        \\n        def recurse(sidx, path, result_so_far, prev_num):\\n            if sidx == len(num):\\n                if result_so_far == target:\\n                    res.append(path[:]) \\n                return\\n            \\n            for i in range(sidx, len(num)):\\n                prefix = num[sidx:i+1]\\n                curr_num = int(prefix)\\n                \\n                if len(prefix) > 1 and prefix[0] == \"0\": return # don\\'t process if there is a leading 0. \\n                \\n                if prev_num is None:\\n                    recurse(i+1, path + prefix, result_so_far + curr_num, curr_num)\\n                else:\\n                    # consider +\\n                    recurse(i+1, path+\\'+\\'+prefix, result_so_far + curr_num, curr_num)\\n                    # consider -\\n                    recurse(i+1, path+\\'-\\'+prefix, result_so_far - curr_num, -curr_num)\\n                    # consider *\\n                    #temp = result_so_far - prev_num\\n                    #result_so_far = temp + curr_num * prev_num\\n                    #prev_num = (curr_num * prev_num) THIS IS THE CRUX of this Problem\\n                    recurse(i+1, path+\\'*\\'+prefix, result_so_far - prev_num + (curr_num * prev_num), (curr_num * prev_num))\\n\\n        recurse(0,\"\", 0, None)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536328,
                "title": "python3-strightforward-and-consice",
                "content": "Similar idea with \\'calculators\\' problems, we record previous value for the multiply and check every possible symble/number combinations.\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        prev = None\\n        def dfs(i, val, path, prev):\\n            if i == len(num):\\n                if val == target:\\n                    res.append(path)\\n                return\\n            cur_val = 0\\n            for j in range(i, len(num)):\\n                cur_val = cur_val * 10 + int(num[j])\\n                if prev == None:\\n                    dfs(j+1, val+cur_val, path+num[i:j+1],cur_val)\\n                else:\\n                    dfs(j+1, val+cur_val,path+\\'+\\'+num[i:j+1],cur_val)\\n                    dfs(j+1, val-cur_val,path+\\'-\\'+num[i:j+1],-cur_val)\\n                    dfs(j+1, val+cur_val*prev-prev,path+\\'*\\'+num[i:j+1],cur_val*prev)\\n                \\n                if num[i] == \\'0\\':#prevent leading zeros\\n                    break\\n        dfs(0, 0, \\'\\', None)\\n        return res\\n                ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        prev = None\\n        def dfs(i, val, path, prev):\\n            if i == len(num):\\n                if val == target:\\n                    res.append(path)\\n                return\\n            cur_val = 0\\n            for j in range(i, len(num)):\\n                cur_val = cur_val * 10 + int(num[j])\\n                if prev == None:\\n                    dfs(j+1, val+cur_val, path+num[i:j+1],cur_val)\\n                else:\\n                    dfs(j+1, val+cur_val,path+\\'+\\'+num[i:j+1],cur_val)\\n                    dfs(j+1, val-cur_val,path+\\'-\\'+num[i:j+1],-cur_val)\\n                    dfs(j+1, val+cur_val*prev-prev,path+\\'*\\'+num[i:j+1],cur_val*prev)\\n                \\n                if num[i] == \\'0\\':#prevent leading zeros\\n                    break\\n        dfs(0, 0, \\'\\', None)\\n        return res\\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 1471556,
                "title": "javascript-backtracking-99-93",
                "content": "![image](https://assets.leetcode.com/users/images/55b2671b-75dc-4252-ac72-e6c0a1d38e2e_1632000773.7629488.png)\\n\\nNot even going to lie to you, this one\\'s Hard.  See LC solution tab for basic approach.\\n\\n```\\nvar addOperators = function(num, target) {\\n  const res = [];\\n  backtrack();\\n  return res;\\n  \\n  function backtrack(ind = 0, tot = 0, exp = \\'\\', curNum = 0, befMult = 0) {\\n    //If at end and curNum is still a value or we didn\\'t find the total\\n    //Return because it\\'s not a correct solution path.\\n    if (ind === num.length && (curNum || tot !== target)) return;\\n\\t\\n    //If at end and total === target, push answer and return.\\n    if (ind === num.length && tot === target) return res.push(exp);\\n\\t\\n    //num[ind]-0 converts string at current index to a number.\\n    //*10 grow cur.  Two lines below just give possible number permutations.\\n    //Note that all recursive calls other than this one set curNum = 0.\\n    //This one calls with curNum = next.  What is next though?\\n    //First time this runs, next = 0 * 10 + (num[ind]-0).  Let\\'s say we get 1 in num[ind],\\n    //0*10 + 1 = 1.  Then we invoke backtrack again, but we only increment index and \\n    //pass in our 1.  Now, next time, next = 1 * 10 + num[idx].  Let\\'s say 5 this time.\\n    //This sets next to 15.  In this way, we have built up 15 from 1,5.  Combinations\\n    //of all the above are now in recursive paths.  The if(next) ensures we aren\\'t recursing\\n\\t//down erroneous paths - Ie. \\'10122\\' could lead us to build up \\'01\\', \\'012\\', \\'0122\\' which \\n\\t//just turns out to be the same as if we skipped the 0 and started building up at the 1.\\n    const next = curNum * 10 + (num[ind]-0);\\n    if (next) backtrack(ind+1, tot, exp, next, befMult);\\n\\t\\n    //Here we add.  We start with adding because if expression is empty (as in when invoked),\\n    //we can\\'t just subtract or multiply out of the gate.  We need to get at least one number in expression\\n    //before doing those operations, else \\'-5\\' or \\'*5\\' is going to end up at the start of our exp.\\n    //Here, we can check if there\\'s expression length or not, if not, we just add next num as a string (+\\'\\').\\n    //This is allowed because 0 + num still equals the num.  0 - 5 doesn\\'t equal the original num, and 0*5\\n    //certainly doesn\\'t either.  Ergo, we have to add first in order to attain a valid starting number to recurse on.\\n\\t//If total = -5 or 0 after just having a \\'5\\' in expression, our expression and total are out of sync.  Adding first\\n\\t//avoids this issue.\\n    backtrack(ind+1, tot + next, exp.length ? exp+\"+\"+next : next + \\'\\', 0, next);\\n\\t\\n    //If we are in a recursion level After initial invocation, there will be exp.length.\\n    //Now that we know we already have at least one num in the exp, we can use\\n    //the other operators to alter total / expression.\\n    if (exp.length) {\\n      backtrack(ind+1, tot - next, exp+\"-\"+next, 0, -next);\\n\\t\\t\\n      //This is the trickiest part of the problem imo.  If you could just use eval(exp) every time to \\n      //calculate total not on-the-fly, it\\'s Way easier.  Butttttt, I suppose when you get a number\\n      //like 999879687348598, and have expressions like \\'9+9*9-8*7-9+6-8*3-4-8*5+9-8\\'...\\n      //and you\\'re evaluating on Every permutation / recursion level... That is a little taxing.  \\n      //Keeping track of the total Before multiplying last is very clever and definitely the right way \\n      //to do it, but that\\'s not an easy intuitive leap to make imo.  Hopefully my future interviewer\\'s fine \\n      //with the terrible eval() runtime or generous with the hints. lol...  Because I\\'m not sure I\\'d get\\n      //this without at least a nudge.\\n      backtrack(ind+1, tot - befMult + (befMult * next), exp+\"*\"+next, 0, (befMult * next));\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addOperators = function(num, target) {\\n  const res = [];\\n  backtrack();\\n  return res;\\n  \\n  function backtrack(ind = 0, tot = 0, exp = \\'\\', curNum = 0, befMult = 0) {\\n    //If at end and curNum is still a value or we didn\\'t find the total\\n    //Return because it\\'s not a correct solution path.\\n    if (ind === num.length && (curNum || tot !== target)) return;\\n\\t\\n    //If at end and total === target, push answer and return.\\n    if (ind === num.length && tot === target) return res.push(exp);\\n\\t\\n    //num[ind]-0 converts string at current index to a number.\\n    //*10 grow cur.  Two lines below just give possible number permutations.\\n    //Note that all recursive calls other than this one set curNum = 0.\\n    //This one calls with curNum = next.  What is next though?\\n    //First time this runs, next = 0 * 10 + (num[ind]-0).  Let\\'s say we get 1 in num[ind],\\n    //0*10 + 1 = 1.  Then we invoke backtrack again, but we only increment index and \\n    //pass in our 1.  Now, next time, next = 1 * 10 + num[idx].  Let\\'s say 5 this time.\\n    //This sets next to 15.  In this way, we have built up 15 from 1,5.  Combinations\\n    //of all the above are now in recursive paths.  The if(next) ensures we aren\\'t recursing\\n\\t//down erroneous paths - Ie. \\'10122\\' could lead us to build up \\'01\\', \\'012\\', \\'0122\\' which \\n\\t//just turns out to be the same as if we skipped the 0 and started building up at the 1.\\n    const next = curNum * 10 + (num[ind]-0);\\n    if (next) backtrack(ind+1, tot, exp, next, befMult);\\n\\t\\n    //Here we add.  We start with adding because if expression is empty (as in when invoked),\\n    //we can\\'t just subtract or multiply out of the gate.  We need to get at least one number in expression\\n    //before doing those operations, else \\'-5\\' or \\'*5\\' is going to end up at the start of our exp.\\n    //Here, we can check if there\\'s expression length or not, if not, we just add next num as a string (+\\'\\').\\n    //This is allowed because 0 + num still equals the num.  0 - 5 doesn\\'t equal the original num, and 0*5\\n    //certainly doesn\\'t either.  Ergo, we have to add first in order to attain a valid starting number to recurse on.\\n\\t//If total = -5 or 0 after just having a \\'5\\' in expression, our expression and total are out of sync.  Adding first\\n\\t//avoids this issue.\\n    backtrack(ind+1, tot + next, exp.length ? exp+\"+\"+next : next + \\'\\', 0, next);\\n\\t\\n    //If we are in a recursion level After initial invocation, there will be exp.length.\\n    //Now that we know we already have at least one num in the exp, we can use\\n    //the other operators to alter total / expression.\\n    if (exp.length) {\\n      backtrack(ind+1, tot - next, exp+\"-\"+next, 0, -next);\\n\\t\\t\\n      //This is the trickiest part of the problem imo.  If you could just use eval(exp) every time to \\n      //calculate total not on-the-fly, it\\'s Way easier.  Butttttt, I suppose when you get a number\\n      //like 999879687348598, and have expressions like \\'9+9*9-8*7-9+6-8*3-4-8*5+9-8\\'...\\n      //and you\\'re evaluating on Every permutation / recursion level... That is a little taxing.  \\n      //Keeping track of the total Before multiplying last is very clever and definitely the right way \\n      //to do it, but that\\'s not an easy intuitive leap to make imo.  Hopefully my future interviewer\\'s fine \\n      //with the terrible eval() runtime or generous with the hints. lol...  Because I\\'m not sure I\\'d get\\n      //this without at least a nudge.\\n      backtrack(ind+1, tot - befMult + (befMult * next), exp+\"*\"+next, 0, (befMult * next));\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470697,
                "title": "python-dfs-solution-for-loop-clear",
                "content": "Idea:\\n- We start with the first digit then add other digits with operators `\\'+\\',\\'-\\',\\'*\\',\\'\\'` in front. \\n- We need empty operator to add more digits to the digit. At the end we evall all the operations in stack and if it\\'s equal to target we return it.\\n\\n- The trickiest part is to avoid making oprations like \\'1+00\\'. The way to slove that if previous number is \\'0\\' and operator is \\'\\' we go back until we can and meet non \\'0\\' or operators `\\'+\\',\\'-\\',\\'*\\'`. Depending on the way we stopped we proceed with adding more 0s or skip.\\n\\n\\n```python\\nclass Solution:\\n    def addOperators(self, S: str, target: int) -> List[str]:\\n        q = [S[0]]\\n        \\n        for n in S[1:]:\\n            updated_q = []\\n            while q:\\n                node = q.pop()\\n                for o in {\\'*\\',\\'+\\',\\'-\\',\\'\\'}:\\n                    # check if node before == 0 \\n                    # then we need to force adding operator if number is \\'0\\' to avoid \\'00\\'\\n                    # otherwise if number ends with 0 but starts with other digit like 1 (\\'1000\\') we are fine\\n                    if node[-1] == \\'0\\' and o == \\'\\':\\n                        i = len(node)-1\\n                        while i >= 0 and node[i] == \\'0\\':\\n                            i -= 1\\n                        if i < 0 or node[i] in {\\'*\\',\\'+\\',\\'-\\'}:\\n                            continue\\n                            \\n                    updated_q.append(node + o + n)\\n            q = updated_q[:]\\n        \\n        return [e for e in q if eval(e) == target]       \\n```\\nTime coplexity: `O(N 4^N)`\\nSpace: `O(4 ^ N)`",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, S: str, target: int) -> List[str]:\\n        q = [S[0]]\\n        \\n        for n in S[1:]:\\n            updated_q = []\\n            while q:\\n                node = q.pop()\\n                for o in {\\'*\\',\\'+\\',\\'-\\',\\'\\'}:\\n                    # check if node before == 0 \\n                    # then we need to force adding operator if number is \\'0\\' to avoid \\'00\\'\\n                    # otherwise if number ends with 0 but starts with other digit like 1 (\\'1000\\') we are fine\\n                    if node[-1] == \\'0\\' and o == \\'\\':\\n                        i = len(node)-1\\n                        while i >= 0 and node[i] == \\'0\\':\\n                            i -= 1\\n                        if i < 0 or node[i] in {\\'*\\',\\'+\\',\\'-\\'}:\\n                            continue\\n                            \\n                    updated_q.append(node + o + n)\\n            q = updated_q[:]\\n        \\n        return [e for e in q if eval(e) == target]       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402499,
                "title": "backtracking-c-solution",
                "content": "Here\\'s my solution. It gives correct results but also produces duplicate strings. Can anybody please tell me how to prevent the duplicacy?\\n```\\nclass Solution {\\npublic:\\n    void solve(unordered_set<string> &res, string num, int target, int ind, int n, string temp){\\n        if(ind == n){\\n            temp.pop_back();\\n            int a = temp[0]-\\'0\\', op;\\n            for(int i = 1; i < temp.length(); i++){\\n                if(temp[i] != \\'+\\' && temp[i] != \\'-\\' && temp[i] != \\'*\\'){\\n                    if(op == \\'+\\'){\\n                        a += (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'*\\'){\\n                        a *= (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'-\\'){\\n                        a -= (temp[i]-\\'0\\');\\n                    }\\n                }\\n                else{\\n                    op = temp[i];\\n                }\\n            }\\n            if(a == target){\\n                res.insert(temp);\\n            }\\n            return;\\n        }\\n        \\n        temp += num.substr(ind, 1) + \"+\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"-\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"*\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        unordered_set<string> res;\\n        vector<string> ans;\\n        int n = num.length();\\n        \\n        solve(res, num, target, 0, n, \"\");\\n        \\n        for(auto i : res){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(unordered_set<string> &res, string num, int target, int ind, int n, string temp){\\n        if(ind == n){\\n            temp.pop_back();\\n            int a = temp[0]-\\'0\\', op;\\n            for(int i = 1; i < temp.length(); i++){\\n                if(temp[i] != \\'+\\' && temp[i] != \\'-\\' && temp[i] != \\'*\\'){\\n                    if(op == \\'+\\'){\\n                        a += (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'*\\'){\\n                        a *= (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'-\\'){\\n                        a -= (temp[i]-\\'0\\');\\n                    }\\n                }\\n                else{\\n                    op = temp[i];\\n                }\\n            }\\n            if(a == target){\\n                res.insert(temp);\\n            }\\n            return;\\n        }\\n        \\n        temp += num.substr(ind, 1) + \"+\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"-\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"*\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        unordered_set<string> res;\\n        vector<string> ans;\\n        int n = num.length();\\n        \\n        solve(res, num, target, 0, n, \"\");\\n        \\n        for(auto i : res){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193048,
                "title": "swift-clean-code",
                "content": "```swift\\nclass Solution {\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var res = [String]()\\n        let sArr = Array(num)\\n        func dfs(_ path: String, _ index: Int, _ value: Int, _ multed: Int) {\\n            if index == sArr.endIndex {\\n                if value == target {\\n                    res.append(path)    \\n                }\\n                return\\n            }\\n            var curr = 0\\n            for i in index..<sArr.endIndex {\\n                if i != index && sArr[index] == \"0\" {break}\\n                curr = curr*10 + Int(String(sArr[i]))!\\n                if index == 0 {\\n                    dfs(path+\"\\\\(curr)\", i+1, curr, curr)\\n                } else {\\n                    dfs(path+\"+\\\\(curr)\", i+1, value + curr, curr)\\n                    dfs(path+\"-\\\\(curr)\", i+1, value - curr, -curr)\\n                    dfs(path+\"*\\\\(curr)\", i+1, value - multed + multed * curr, multed * curr)\\n                }\\n            }\\n        }\\n        dfs(\"\",0,0,0)\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var res = [String]()\\n        let sArr = Array(num)\\n        func dfs(_ path: String, _ index: Int, _ value: Int, _ multed: Int) {\\n            if index == sArr.endIndex {\\n                if value == target {\\n                    res.append(path)    \\n                }\\n                return\\n            }\\n            var curr = 0\\n            for i in index..<sArr.endIndex {\\n                if i != index && sArr[index] == \"0\" {break}\\n                curr = curr*10 + Int(String(sArr[i]))!\\n                if index == 0 {\\n                    dfs(path+\"\\\\(curr)\", i+1, curr, curr)\\n                } else {\\n                    dfs(path+\"+\\\\(curr)\", i+1, value + curr, curr)\\n                    dfs(path+\"-\\\\(curr)\", i+1, value - curr, -curr)\\n                    dfs(path+\"*\\\\(curr)\", i+1, value - multed + multed * curr, multed * curr)\\n                }\\n            }\\n        }\\n        dfs(\"\",0,0,0)\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041628,
                "title": "c-using-backtracking-template-with-explaination",
                "content": "I have used standard backtracking template to solve the problem with optimizations to calculate the value of expressiom on the fly.\\nindex variable is the starting point of second operand, except when index == 0 (as first operator has not been selected yet).\\n\\nThere are 3 operators that can be applied to second operand: +, - , *\\nWe take care of concatenating digits when calculating operand.\\n\\nThe idea here is to reduce the expression as a + b. We are storing 2 varibales for calculations. Add denotes a, and Mul denotes b.\\nAs * has higher precedence over + and -, we want to store operand, if next operator is *\\nMul dentotes operand if next operator is *\\nAdd denotes operand for +\\n\\nTotal value for expression = add + mul\\n\\n```\\ne.g. 1 * 2 + 5 - 3 * 4 * 3 + 1\\n\\t\\t\\t\\t   A          M\\n1                  0          1\\n1*2                0          2\\n1*2+5              2          5 (If * is next operator, it will get multiplied to 5 only, so we apply + operator, Add = Mul + Add)\\n1*2+5-3            7         -3 (similarly, for * to be next operator, -3 will be first operand, so Add = Add + Mul)\\n1*2+5-3*4          7         -12 (If * is next operator, it should get multiplied to -3*4) \\n1*2+5-3*4*3        7         -36\\n1*2+5-3*4*3+1     -31         1\\n```\\n\\n```\\nclass Solution {\\n    vector<string> result;\\n    int target;\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        this->target = target;\\n        string s = \"\";\\n        getComb(num, 0, 0, 0, s);\\n        return result;\\n    }\\n    \\n    void getComb(string& num, int index, long add, long mul, string s) {\\n        if (add > INT_MAX || mul > INT_MAX) {\\n            return;\\n        }\\n        \\n        if (index == num.size()) {\\n            if (add + mul == target) {\\n                result.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.size(); i++) {\\n            if (num.at(index) == \\'0\\' && i > index) {\\n                return;\\n            }\\n            \\n            long x = stol(num.substr(index, i - index + 1));\\n            if (index == 0) {\\n                getComb(num, i + 1, 0, x, s + to_string(x));\\n                continue;\\n            }\\n            \\n            getComb(num, i + 1, add + mul, x, s + \"+\" + to_string(x));\\n            getComb(num, i + 1, add + mul, -x, s + \"-\" + to_string(x));            \\n            getComb(num, i + 1, add, mul * x, s + \"*\" + to_string(x));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\ne.g. 1 * 2 + 5 - 3 * 4 * 3 + 1\\n\\t\\t\\t\\t   A          M\\n1                  0          1\\n1*2                0          2\\n1*2+5              2          5 (If * is next operator, it will get multiplied to 5 only, so we apply + operator, Add = Mul + Add)\\n1*2+5-3            7         -3 (similarly, for * to be next operator, -3 will be first operand, so Add = Add + Mul)\\n1*2+5-3*4          7         -12 (If * is next operator, it should get multiplied to -3*4) \\n1*2+5-3*4*3        7         -36\\n1*2+5-3*4*3+1     -31         1\\n```\n```\\nclass Solution {\\n    vector<string> result;\\n    int target;\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        this->target = target;\\n        string s = \"\";\\n        getComb(num, 0, 0, 0, s);\\n        return result;\\n    }\\n    \\n    void getComb(string& num, int index, long add, long mul, string s) {\\n        if (add > INT_MAX || mul > INT_MAX) {\\n            return;\\n        }\\n        \\n        if (index == num.size()) {\\n            if (add + mul == target) {\\n                result.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.size(); i++) {\\n            if (num.at(index) == \\'0\\' && i > index) {\\n                return;\\n            }\\n            \\n            long x = stol(num.substr(index, i - index + 1));\\n            if (index == 0) {\\n                getComb(num, i + 1, 0, x, s + to_string(x));\\n                continue;\\n            }\\n            \\n            getComb(num, i + 1, add + mul, x, s + \"+\" + to_string(x));\\n            getComb(num, i + 1, add + mul, -x, s + \"-\" + to_string(x));            \\n            getComb(num, i + 1, add, mul * x, s + \"*\" + to_string(x));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992834,
                "title": "c-solution-beats-80",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n\\n    vector<string> addOperators(string &num, int target) {\\n        dfs(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n\\n    void dfs(string &num, int target, int start, string str, long long sum, long long last) {\\n        if (num.size() == start) {\\n            if (target == sum) result.push_back(str);\\n            return;\\n        }\\n        \\n        long long x = 0;\\n        string ret = \"\";\\n        \\n        for (int i = start; i < num.size(); ++i) {\\n            x = x * 10 + num[i] - \\'0\\';\\n            ret += num[i];\\n            \\n            if (start == 0) {\\n                dfs(num, target, i + 1, str + ret, x, x);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + ret, sum - last + x * last, x * last);\\n                dfs(num, target, i + 1, str + \"+\" + ret, sum + x, x);\\n                dfs(num, target, i + 1, str + \"-\" + ret, sum - x, -x);\\n            }\\n            \\n            if (x == 0) break;            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n\\n    vector<string> addOperators(string &num, int target) {\\n        dfs(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n\\n    void dfs(string &num, int target, int start, string str, long long sum, long long last) {\\n        if (num.size() == start) {\\n            if (target == sum) result.push_back(str);\\n            return;\\n        }\\n        \\n        long long x = 0;\\n        string ret = \"\";\\n        \\n        for (int i = start; i < num.size(); ++i) {\\n            x = x * 10 + num[i] - \\'0\\';\\n            ret += num[i];\\n            \\n            if (start == 0) {\\n                dfs(num, target, i + 1, str + ret, x, x);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + ret, sum - last + x * last, x * last);\\n                dfs(num, target, i + 1, str + \"+\" + ret, sum + x, x);\\n                dfs(num, target, i + 1, str + \"-\" + ret, sum - x, -x);\\n            }\\n            \\n            if (x == 0) break;            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962682,
                "title": "simplified-python-solution-backtracking-w-o-eval",
                "content": "Example by leetcode was excessively complicated, so simplified\\n\\n````\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n\\n        def backtrack(idx,prev,value,path):\\n            nonlocal res\\n\\n            if idx == len(num):\\n                if value == target:\\n\\t\\t\\t\\t\\t# trim first char as it will be +\\n                    res.append(path[1:])\\n                return\\n\\n            curr = 0\\n            curr_s = \\'\\'\\n\\n            # create all prefixes e.g. 1, 12, 123\\n            for i in range(idx,len(num)):\\n                curr *= 10\\n                curr += int(num[i])  \\n                curr_s += num[i]\\n\\n                # add to current total\\n                backtrack(i+1, curr, value + curr, path + \\'+\\' + curr_s)\\n\\n                if path:\\n                    # minus from current total\\n                    backtrack(i+1, -curr, value - curr, path + \\'-\\' + curr_s)\\n                    \\n                    # multiply is a special case\\n                    # as * has precedence we need\\n                    # to remove the previous value\\n                    # and multiply with the current\\n                    backtrack(i+1, prev * curr, value - prev + prev * curr, path + \\'*\\' + curr_s)\\n\\n                # nothing else can be created as prefix is 0 (01)\\n                if curr == 0:\\n                    break\\n\\n        backtrack(0,0,0,\\'\\')\\n        return res\\n```",
                "solutionTags": [],
                "code": "````\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n\\n        def backtrack(idx,prev,value,path):\\n            nonlocal res\\n\\n            if idx == len(num):\\n                if value == target:\\n\\t\\t\\t\\t\\t# trim first char as it will be +\\n                    res.append(path[1:])\\n                return\\n\\n            curr = 0\\n            curr_s = \\'\\'\\n\\n            # create all prefixes e.g. 1, 12, 123\\n            for i in range(idx,len(num)):\\n                curr *= 10\\n                curr += int(num[i])  \\n                curr_s += num[i]\\n\\n                # add to current total\\n                backtrack(i+1, curr, value + curr, path + \\'+\\' + curr_s)\\n\\n                if path:\\n                    # minus from current total\\n                    backtrack(i+1, -curr, value - curr, path + \\'-\\' + curr_s)\\n                    \\n                    # multiply is a special case\\n                    # as * has precedence we need\\n                    # to remove the previous value\\n                    # and multiply with the current\\n                    backtrack(i+1, prev * curr, value - prev + prev * curr, path + \\'*\\' + curr_s)\\n\\n                # nothing else can be created as prefix is 0 (01)\\n                if curr == 0:\\n                    break\\n\\n        backtrack(0,0,0,\\'\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837116,
                "title": "simple-and-easy-python-solution-backtracking",
                "content": "```\\nclass Solution:\\n    def Util(self, num, target, ind, l, mem, exp):\\n        if ind == l - 1:\\n            exp += num[ind]\\n            if eval(exp) == target:\\n                return [exp]\\n        if ind >= l:\\n            return []\\n        ret1 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'+\\')\\n        ret2 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'-\\')\\n        ret3 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'*\\')\\n        if (exp and exp[-1].isdigit() is True and num[ind] == \\'0\\') or num[ind] != \\'0\\':\\n            ret4 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]))\\n            ret = ret1 + ret2 + ret3 + ret4\\n        else:\\n            ret = ret1 + ret2 + ret3\\n        return ret\\n        \\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        return self.Util(num, target, 0, len(num), dict(), \\'\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def Util(self, num, target, ind, l, mem, exp):\\n        if ind == l - 1:\\n            exp += num[ind]\\n            if eval(exp) == target:\\n                return [exp]\\n        if ind >= l:\\n            return []\\n        ret1 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'+\\')\\n        ret2 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'-\\')\\n        ret3 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'*\\')\\n        if (exp and exp[-1].isdigit() is True and num[ind] == \\'0\\') or num[ind] != \\'0\\':\\n            ret4 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]))\\n            ret = ret1 + ret2 + ret3 + ret4\\n        else:\\n            ret = ret1 + ret2 + ret3\\n        return ret\\n        \\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        return self.Util(num, target, 0, len(num), dict(), \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724989,
                "title": "bfs-and-dfs-with-intuitive-figure-and-explanations-python3",
                "content": "the example figure for DFS, input is \\'123\\' and target=6\\n![image](https://assets.leetcode.com/users/images/115f3d0f-c186-4ce4-822c-21e4fea6cf2e_1594172504.141081.png)\\n\\nspecial case:\\n![image](https://assets.leetcode.com/users/images/558c2bf1-4c09-47e2-a094-6c2806b77549_1594523624.2076805.png)\\n\\n\\n\\n```\\nclass Solution:\\n    \\n    # bfs\\n    def addOperators_bfs(self, numstr, target):\\n        res = []\\n        q = collections.deque() # try to use deque here, if use [], it will be too slow to pass OJ\\n        for i in range(1, len(numstr)+1):\\n            if i == 1 or (i>1 and numstr[0] != \\'0\\'):\\n                q.append([numstr[i:], numstr[:i], int(numstr[:i]), int(numstr[:i])]) \\n                # remain str, current formula, the value of current formula, the last.vale of the formula\\n        \\n        while q:\\n            qsize = len(q)\\n            for i in range(qsize):\\n                atuple = q.popleft() # collections.deque() or popleft() is also fine\\n                remainstr, fstr, fval, flast = atuple[0], atuple[1], atuple[2], atuple[3]\\n                if len(remainstr) == 0 and fval == target:\\n                    res.append(fstr)\\n                    continue\\n                \\n                for j in range(1, len(remainstr)+1):\\n                    if j==1 or (j>1 and remainstr[0] != \\'0\\'):\\n                        # +, -, *\\n                        val = remainstr[:j]\\n                        q.append([remainstr[j:], fstr + \\'+\\' + val, fval + int(val), int(val)])\\n                        q.append([remainstr[j:], fstr + \\'-\\' + val, fval - int(val), -int(val)])\\n                        q.append([remainstr[j:], fstr + \\'*\\' + val, fval - flast + flast*int(val), flast*int(val)])\\n        return res\\n    \\n    # dfs\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        self.target = target\\n        \\n        for i in range(1, len(num) + 1):\\n            if i==1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res)\\n        return res\\n    \\n    def dfs(self, num, fstr, fval, flast, res):\\n        # fstr = string of current formula\\n        # fval = value of current formula\\n        # flast = last value for +- and last computing result for * in formula. For example, if fstr=2+3, then flast=3, if fstr=2-3, then flast=-3, if fstr=2+3*4, then flast=3*4=12\\n        if not num:\\n            if fval == self.target:\\n                res.append(fstr)\\n            return\\n        \\n        for i in range(1, len(num)+1):\\n            val=num[:i]\\n            if i == 1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], fstr + \\'+\\' + val, fval + int(val), int(val), res)\\n                self.dfs(num[i:], fstr + \\'-\\' + val, fval - int(val), -int(val), res)\\n                self.dfs(num[i:], fstr + \\'*\\' + val, fval-flast+flast*int(val), flast*int(val), res)\\n               \\n            # 2+3*2: currently coming is *2, current formula = 2+3, its value is 5, the last vale of this formula is 3, thus: 5-3+3*2 is fine\\n            # 2-3*5: currently coming is *5, current formula = 2-3, its value is -1, the last vale of this formula is -3, thus: -1-(-3) + (-3)*5 = -1+3-15=-13\\n            # 3*5*2: currently coming is *2, current formula = 3*5, its value is 15, the last vale of this formula is 3*5=15!, thus: 15-15+15*2=30, result is okay as well\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    # bfs\\n    def addOperators_bfs(self, numstr, target):\\n        res = []\\n        q = collections.deque() # try to use deque here, if use [], it will be too slow to pass OJ\\n        for i in range(1, len(numstr)+1):\\n            if i == 1 or (i>1 and numstr[0] != \\'0\\'):\\n                q.append([numstr[i:], numstr[:i], int(numstr[:i]), int(numstr[:i])]) \\n                # remain str, current formula, the value of current formula, the last.vale of the formula\\n        \\n        while q:\\n            qsize = len(q)\\n            for i in range(qsize):\\n                atuple = q.popleft() # collections.deque() or popleft() is also fine\\n                remainstr, fstr, fval, flast = atuple[0], atuple[1], atuple[2], atuple[3]\\n                if len(remainstr) == 0 and fval == target:\\n                    res.append(fstr)\\n                    continue\\n                \\n                for j in range(1, len(remainstr)+1):\\n                    if j==1 or (j>1 and remainstr[0] != \\'0\\'):\\n                        # +, -, *\\n                        val = remainstr[:j]\\n                        q.append([remainstr[j:], fstr + \\'+\\' + val, fval + int(val), int(val)])\\n                        q.append([remainstr[j:], fstr + \\'-\\' + val, fval - int(val), -int(val)])\\n                        q.append([remainstr[j:], fstr + \\'*\\' + val, fval - flast + flast*int(val), flast*int(val)])\\n        return res\\n    \\n    # dfs\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        self.target = target\\n        \\n        for i in range(1, len(num) + 1):\\n            if i==1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res)\\n        return res\\n    \\n    def dfs(self, num, fstr, fval, flast, res):\\n        # fstr = string of current formula\\n        # fval = value of current formula\\n        # flast = last value for +- and last computing result for * in formula. For example, if fstr=2+3, then flast=3, if fstr=2-3, then flast=-3, if fstr=2+3*4, then flast=3*4=12\\n        if not num:\\n            if fval == self.target:\\n                res.append(fstr)\\n            return\\n        \\n        for i in range(1, len(num)+1):\\n            val=num[:i]\\n            if i == 1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], fstr + \\'+\\' + val, fval + int(val), int(val), res)\\n                self.dfs(num[i:], fstr + \\'-\\' + val, fval - int(val), -int(val), res)\\n                self.dfs(num[i:], fstr + \\'*\\' + val, fval-flast+flast*int(val), flast*int(val), res)\\n               \\n            # 2+3*2: currently coming is *2, current formula = 2+3, its value is 5, the last vale of this formula is 3, thus: 5-3+3*2 is fine\\n            # 2-3*5: currently coming is *5, current formula = 2-3, its value is -1, the last vale of this formula is -3, thus: -1-(-3) + (-3)*5 = -1+3-15=-13\\n            # 3*5*2: currently coming is *2, current formula = 3*5, its value is 15, the last vale of this formula is 3*5=15!, thus: 15-15+15*2=30, result is okay as well\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632105,
                "title": "java-backtrack-just-brutal-force-dfs",
                "content": "Orig: https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    long m, t;\\n    String num;\\n    public List<String> addOperators(String num, int target) {\\n        this.num = num;\\n        if (num == null || num.length() == 0) return res;\\n        m = num.length();\\n        t = target;\\n        dfs(\"\", 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(String s, int idx, long sum, long mul) {\\n        if (idx == m) {\\n            if (sum == t) res.add(s);\\n            return;\\n        }\\n        for (int i = idx; i < m; i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') break;  //invalid number format, for example, \"03\".\\n            long n = Long.parseLong(num.substring(idx, i+1));  // must use long to avoid overflow\\n            if (idx == 0) {    // first must be \"+\"\\n                dfs(n + \"\", i + 1, n, n);\\n                continue;\\n            }\\n            dfs(s + \"+\" + n, i + 1, sum + n, n);\\n            dfs(s + \"-\" + n, i + 1, sum - n, -n);\\n            dfs(s + \"*\" + n, i + 1, sum - mul + mul * n, mul * n);\\n            // if (i == idx && num.charAt(idx) == \\'0\\') break;  // must put before \"if (idx == 0) {\"\"\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    long m, t;\\n    String num;\\n    public List<String> addOperators(String num, int target) {\\n        this.num = num;\\n        if (num == null || num.length() == 0) return res;\\n        m = num.length();\\n        t = target;\\n        dfs(\"\", 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(String s, int idx, long sum, long mul) {\\n        if (idx == m) {\\n            if (sum == t) res.add(s);\\n            return;\\n        }\\n        for (int i = idx; i < m; i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') break;  //invalid number format, for example, \"03\".\\n            long n = Long.parseLong(num.substring(idx, i+1));  // must use long to avoid overflow\\n            if (idx == 0) {    // first must be \"+\"\\n                dfs(n + \"\", i + 1, n, n);\\n                continue;\\n            }\\n            dfs(s + \"+\" + n, i + 1, sum + n, n);\\n            dfs(s + \"-\" + n, i + 1, sum - n, -n);\\n            dfs(s + \"*\" + n, i + 1, sum - mul + mul * n, mul * n);\\n            // if (i == idx && num.charAt(idx) == \\'0\\') break;  // must put before \"if (idx == 0) {\"\"\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482137,
                "title": "self-explanatory-beats-96-submissions",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        res = []\\n        n = len(num)\\n        def dfs(currIndex,prevVal,currVal,expr):\\n          if currIndex==n:\\n            if currVal==target:\\n              res.append(expr)\\n            return\\n          for i in range(currIndex,n):\\n            operand = num[currIndex:i+1]\\n            if len(operand)>1 and operand[0]==\\'0\\':\\n              break\\n            integerOp = int(operand)\\n            if currIndex==0:\\n              dfs(i+1,integerOp,integerOp,operand)\\n            else:\\n              #addition\\n              dfs(i+1,integerOp,currVal+integerOp,expr+\\'+\\'+operand)\\n              #substraction\\n              dfs(i+1,-integerOp,currVal-integerOp,expr+\\'-\\'+operand)\\n              #multiply\\n              dfs(i+1, prevVal*integerOp,\\n                  (currVal-prevVal)+(prevVal*integerOp),\\n                 expr+\\'*\\'+operand)\\n              \\n        dfs(0,0,0,\"\")\\n        # print res\\n        return res\\n    ```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        res = []\\n        n = len(num)\\n        def dfs(currIndex,prevVal,currVal,expr):\\n          if currIndex==n:\\n            if currVal==target:\\n              res.append(expr)\\n            return\\n          for i in range(currIndex,n):\\n            operand = num[currIndex:i+1]\\n            if len(operand)>1 and operand[0]==\\'0\\':\\n              break\\n            integerOp = int(operand)\\n            if currIndex==0:\\n              dfs(i+1,integerOp,integerOp,operand)\\n            else:\\n              #addition\\n              dfs(i+1,integerOp,currVal+integerOp,expr+\\'+\\'+operand)\\n              #substraction\\n              dfs(i+1,-integerOp,currVal-integerOp,expr+\\'-\\'+operand)\\n              #multiply\\n              dfs(i+1, prevVal*integerOp,\\n                  (currVal-prevVal)+(prevVal*integerOp),\\n                 expr+\\'*\\'+operand)\\n              \\n        dfs(0,0,0,\"\")\\n        # print res\\n        return res\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 359405,
                "title": "easy-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(res, 0, 0, 0, \"\", num, target);\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> res, int idx, long bufVal, long sum,\\n                     String path, String num, int target) {\\n        if (idx == num.length()) {\\n            if (sum + bufVal == target) {\\n                res.add(path);\\n            }\\n            return;\\n        } \\n        \\n        for (int i = idx; i < num.length(); i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') {\\n                break;\\n            }\\n            \\n            long cur = Long.parseLong(num.substring(idx, i + 1));\\n            if (idx == 0) {\\n                dfs(res, i + 1, cur, sum, path + cur, num, target);   \\n            } else {\\n                dfs(res, i + 1, cur, sum + bufVal, path + \"+\" + cur, num, target);\\n                dfs(res, i + 1, -cur, sum + bufVal, path + \"-\" + cur, num, target);\\n                dfs(res, i + 1, bufVal * cur, sum, path + \"*\" + cur, num, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(res, 0, 0, 0, \"\", num, target);\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> res, int idx, long bufVal, long sum,\\n                     String path, String num, int target) {\\n        if (idx == num.length()) {\\n            if (sum + bufVal == target) {\\n                res.add(path);\\n            }\\n            return;\\n        } \\n        \\n        for (int i = idx; i < num.length(); i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') {\\n                break;\\n            }\\n            \\n            long cur = Long.parseLong(num.substring(idx, i + 1));\\n            if (idx == 0) {\\n                dfs(res, i + 1, cur, sum, path + cur, num, target);   \\n            } else {\\n                dfs(res, i + 1, cur, sum + bufVal, path + \"+\" + cur, num, target);\\n                dfs(res, i + 1, -cur, sum + bufVal, path + \"-\" + cur, num, target);\\n                dfs(res, i + 1, bufVal * cur, sum, path + \"*\" + cur, num, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225907,
                "title": "python-backtracking-dfs",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.N = len(num)\\n        self.target = target\\n        self.num = num\\n        self.ans = []\\n        self.dfs(0, 0, 0, \\'\\')\\n        return self.ans\\n        \\n    def dfs(self, idx, total_val, prev_num, path):\\n        if idx == self.N:\\n            if total_val == self.target:\\n                self.ans.append(path)\\n            return\\n        \\n        cur_num = 0\\n        for i in range(idx, self.N):\\n            cur_num = cur_num * 10 + int(self.num[i])\\n            if idx == 0:\\n                self.dfs(i+1, cur_num, cur_num, path + str(cur_num))\\n            else:\\n                val = total_val - prev_num\\n                self.dfs(i+1, val + prev_num * cur_num, prev_num * cur_num, path + \\'*\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num + cur_num, cur_num, path + \\'+\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num - cur_num, -cur_num, path + \\'-\\' + str(cur_num))\\n            \\n            if self.num[idx] == \\'0\\':\\n                break\\n       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.N = len(num)\\n        self.target = target\\n        self.num = num\\n        self.ans = []\\n        self.dfs(0, 0, 0, \\'\\')\\n        return self.ans\\n        \\n    def dfs(self, idx, total_val, prev_num, path):\\n        if idx == self.N:\\n            if total_val == self.target:\\n                self.ans.append(path)\\n            return\\n        \\n        cur_num = 0\\n        for i in range(idx, self.N):\\n            cur_num = cur_num * 10 + int(self.num[i])\\n            if idx == 0:\\n                self.dfs(i+1, cur_num, cur_num, path + str(cur_num))\\n            else:\\n                val = total_val - prev_num\\n                self.dfs(i+1, val + prev_num * cur_num, prev_num * cur_num, path + \\'*\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num + cur_num, cur_num, path + \\'+\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num - cur_num, -cur_num, path + \\'-\\' + str(cur_num))\\n            \\n            if self.num[idx] == \\'0\\':\\n                break\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 161121,
                "title": "slow-but-easy-understand-python-code",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(num, 0, target, 0, 0, \"\", results)\\n        return results\\n    \\n    def helper(self, string, start, target, sum_so_far, last, path, results):\\n        if start == len(string) and sum_so_far == target:\\n            results.append(path)\\n        \\n        for end in range(start+1, len(string)+1):\\n            sub_string = string[start:end]\\n            if len(sub_string) > 1 and sub_string[0] == \\'0\\':\\n                break\\n            cur = int(sub_string)\\n            if start == 0:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + sub_string, results)\\n            else:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + \"+\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - cur, -cur, path + \"-\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - last + cur * last, cur * last, path + \"*\" + sub_string, results)\\n                \\n   ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(num, 0, target, 0, 0, \"\", results)\\n        return results\\n    \\n    def helper(self, string, start, target, sum_so_far, last, path, results):\\n        if start == len(string) and sum_so_far == target:\\n            results.append(path)\\n        \\n        for end in range(start+1, len(string)+1):\\n            sub_string = string[start:end]\\n            if len(sub_string) > 1 and sub_string[0] == \\'0\\':\\n                break\\n            cur = int(sub_string)\\n            if start == 0:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + sub_string, results)\\n            else:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + \"+\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - cur, -cur, path + \"-\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - last + cur * last, cur * last, path + \"*\" + sub_string, results)\\n                \\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 159507,
                "title": "easy-to-understand-kotlin-solution",
                "content": "The only language you use should be Kotlin\\n\\n```\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val goodList : MutableList<String> = mutableListOf()\\n        fun eval(s : String, output : String, acc : Long, lastTerm : Long, start : Boolean) {\\n            if(s.isEmpty()) {\\n                if(acc + lastTerm == target.toLong()) {\\n                    goodList.add(output)\\n                }\\n                return\\n            }\\n            for (i in (1..s.length)) {\\n                val firstString = s.substring(0, i)\\n                if(firstString.length > 1 && firstString[0] == \\'0\\') {\\n                    return\\n                }\\n                val first = firstString.toLong()\\n                val rest = s.drop(i)\\n                //Case one, add the first int\\n                eval(rest, \"$output+$firstString\", acc + lastTerm, first, false)\\n                if(!start) {\\n                    eval(rest, \"$output-$firstString\", acc + lastTerm, -first, false)\\n                    eval(rest, \"$output*$firstString\", acc, lastTerm * first, false)\\n                }\\n            }\\n        }\\n        eval(num, \"\", 0, 0, true)\\n        return goodList.map {it.drop(1)}.toList()\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val goodList : MutableList<String> = mutableListOf()\\n        fun eval(s : String, output : String, acc : Long, lastTerm : Long, start : Boolean) {\\n            if(s.isEmpty()) {\\n                if(acc + lastTerm == target.toLong()) {\\n                    goodList.add(output)\\n                }\\n                return\\n            }\\n            for (i in (1..s.length)) {\\n                val firstString = s.substring(0, i)\\n                if(firstString.length > 1 && firstString[0] == \\'0\\') {\\n                    return\\n                }\\n                val first = firstString.toLong()\\n                val rest = s.drop(i)\\n                //Case one, add the first int\\n                eval(rest, \"$output+$firstString\", acc + lastTerm, first, false)\\n                if(!start) {\\n                    eval(rest, \"$output-$firstString\", acc + lastTerm, -first, false)\\n                    eval(rest, \"$output*$firstString\", acc, lastTerm * first, false)\\n                }\\n            }\\n        }\\n        eval(num, \"\", 0, 0, true)\\n        return goodList.map {it.drop(1)}.toList()\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 121113,
                "title": "why-simple-dfs-is-so-slow-python",
                "content": "Consider two solutions:\\n```\\n# solution 1\\ndef addOperators(self, num, target):\\n    \\n    def dfs(tail, path, tot, prev):\\n        if not tail and tot == target:\\n            paths.append(path)\\n        else:\\n            for i in range(1, len(tail) + 1):\\n                if i == 1 or tail[0] != \\'0\\':\\n                    val = int(tail[:i])\\n                    dfs(tail[i:], path + \\'+\\' + tail[:i], tot + val, val)\\n                    dfs(tail[i:], path + \\'-\\' + tail[:i], tot - val, -val)\\n                    dfs(tail[i:], path + \\'*\\' + tail[:i], tot - prev + prev * val, prev * val)\\n\\n    paths = []\\n    for i in range(1, len(num) + 1):\\n        if i == 1 or num[0] != \\'0\\':\\n            head = int(num[:i])\\n            dfs(num[i:], num[:i], head, head)\\n\\n    return paths\\n```\\nand\\n```\\n# solution 2\\ndef addOperators(self, num, target):\\n    if not num: \\n        return []\\n    \\n    def dfs(path, s):\\n        if not s :\\n            if eval(path) == target:\\n                paths.append(path)\\n        else:\\n            ops = [\\'+\\', \\'-\\', \\'*\\'] if s[0] == \\'0\\' else [\\'+\\', \\'-\\', \\'*\\', \\'\\']\\n            for op in ops:\\n                dfs(path + op + s[0], s[1:])\\n\\n    paths = []\\n    dfs(num[0], num[1:])\\n\\n    return paths\\n```\\n\\nI think the time complexity are both O(N^4):\\nFor solution1: T(N) = 3*(T(N-1) + T(N-2) + ...), T(N-1) = 3*(T(N-2)+ ...) => T(N) = 4T(N-1) => O(N^4)\\nFor solution2: T(N) = 4T(N-1) => O(N^4)\\nBoth solution requires string slicing, in fact, more slicing operations in solution1. I don\\'t see any significant differences on time complexity in the both solution.\\n\\nBut in reality: the run time for the following test cases are:\\n(\"3456237\", 10000): 38ms vs 80ms\\n(\"34562374\", 10000): 54ms vs 229ms\\n(\"345623749\", 10000): 127ms vs 986ms\\nwhich clearly shows solution1 and solution2 is vastly different. \\nWhat are the operation overhead in solution2 make it so slow?",
                "solutionTags": [],
                "code": "```\\n# solution 1\\ndef addOperators(self, num, target):\\n    \\n    def dfs(tail, path, tot, prev):\\n        if not tail and tot == target:\\n            paths.append(path)\\n        else:\\n            for i in range(1, len(tail) + 1):\\n                if i == 1 or tail[0] != \\'0\\':\\n                    val = int(tail[:i])\\n                    dfs(tail[i:], path + \\'+\\' + tail[:i], tot + val, val)\\n                    dfs(tail[i:], path + \\'-\\' + tail[:i], tot - val, -val)\\n                    dfs(tail[i:], path + \\'*\\' + tail[:i], tot - prev + prev * val, prev * val)\\n\\n    paths = []\\n    for i in range(1, len(num) + 1):\\n        if i == 1 or num[0] != \\'0\\':\\n            head = int(num[:i])\\n            dfs(num[i:], num[:i], head, head)\\n\\n    return paths\\n```\n```\\n# solution 2\\ndef addOperators(self, num, target):\\n    if not num: \\n        return []\\n    \\n    def dfs(path, s):\\n        if not s :\\n            if eval(path) == target:\\n                paths.append(path)\\n        else:\\n            ops = [\\'+\\', \\'-\\', \\'*\\'] if s[0] == \\'0\\' else [\\'+\\', \\'-\\', \\'*\\', \\'\\']\\n            for op in ops:\\n                dfs(path + op + s[0], s[1:])\\n\\n    paths = []\\n    dfs(num[0], num[1:])\\n\\n    return paths\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71900,
                "title": "18-line-clean-python-solution-dfs-with-comment",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        def dfs(remain, curr_str, curr, prev):\\n            if not remain and curr == target:\\n                res.append(curr_str)\\n                \\n            for i in range(1, len(remain) + 1):\\n                if len(curr_str) == 0:   #avoid generate str begin with +-*\\n                    if not (i > 1 and remain[0] == '0'):   # avoid '0X' case be counted\\n                        dfs(remain[i:], remain[:i], int(remain[:i]), int(remain[:i]))\\n                else:\\n                    if not (i > 1 and remain[0] == '0'):\\n                        dfs(remain[i:], curr_str + '+' + remain[:i], curr + int(remain[:i]), int(remain[:i]))\\n                        dfs(remain[i:], curr_str + '-' + remain[:i], curr - int(remain[:i]), -int(remain[:i]))\\n                        # need take extra care for '*' case, a+b*c = a+b-b+b*c\\n                        dfs(remain[i:], curr_str + '*' + remain[:i], curr - prev + prev * int(remain[:i]), prev * int(remain[:i]))\\n            \\n        res = []\\n        dfs(num, '', 0, 0)\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        def dfs(remain, curr_str, curr, prev):\\n            if not remain and curr == target:\\n                res.append(curr_str)\\n                \\n            for i in range(1, len(remain) + 1):\\n                if len(curr_str) == 0:   #avoid generate str begin with +-*\\n                    if not (i > 1 and remain[0] == '0'):   # avoid '0X' case be counted\\n                        dfs(remain[i:], remain[:i], int(remain[:i]), int(remain[:i]))\\n                else:\\n                    if not (i > 1 and remain[0] == '0'):\\n                        dfs(remain[i:], curr_str + '+' + remain[:i], curr + int(remain[:i]), int(remain[:i]))\\n                        dfs(remain[i:], curr_str + '-' + remain[:i], curr - int(remain[:i]), -int(remain[:i]))\\n                        # need take extra care for '*' case, a+b*c = a+b-b+b*c\\n                        dfs(remain[i:], curr_str + '*' + remain[:i], curr - prev + prev * int(remain[:i]), prev * int(remain[:i]))\\n            \\n        res = []\\n        dfs(num, '', 0, 0)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71926,
                "title": "my-brilliant-solution-different-and-easy-to-understand-with-explanation",
                "content": "Suppose that our input string is \"1234\". The length is 4.\\nthere are 3 spots between these 4 digits: 1_2_3_4.\\n\\non each spot, we can either put one of the operator s ( -, +, * ) or put nothing. For example, if I put ' * ' in the first spot, + in the second spot and nothing in the third spot, I will have: 1*2+34.\\nSo each spot can have 4 options. So overall, there can be 4^3 choices.\\n\\nDon't you think there is a reason behind not having ' / ' as an option? There is a reason: we can show any of our choices as a binary from 0 to 3:\\n\\n00: put nothing between two numbers\\n01: put '+' between two numbers\\n10: put '*' between two numbers\\n11: put '-' between two numbers\\n\\nNow I can iterate between 0 to 4^3 and decide for each spot which number I should choose. For example, for the expression discussed above (1*2+34) the generated code to choose operators looks like this:\\n100100\\n\\n(I actually start from 1, because 0 is: 000000 which will give me: 1234 which doesn't have any operator)\\n\\nThen I can read through the code and decide which operator to put and form a string called expression. Then I will send the expression to a calculator which is simply a 'Expression calculator' and check if the result of the current expression equals to target. If yes, I will add it to the result list.\\n\\nSo let's make it for n. If the length of the input string is n, we have n-1 spots, so 4^n-1 choices.\\nWe iterate between 1 to 4^n-1 and parse the number to binary and if it has leading zeros, make sure to include the zeros in our operators string. Then check the operators string 2 by to and add the operator (or don't add anything) by comparing the number to its corresponding operator.\\n\\n```\\nstatic List<string> AddOperators(string num, int target, List<string> total_strings)\\n        {\\n            int n = num.Length;\\n            for (int i = 1; i < Math.Pow(4, n - 1); i++)\\n            {\\n\\t\\t//parsing to binary, then add leading zeros until we have enough length. for example, if n=4, we have 3 spots to fill\\n\\t\\t//if the current number code is 000011, we make sure to include 4 leading zeros to our string.\\n                string operators = Convert.ToString(i, 2).PadLeft((n - 1) * 2, '0'); \\n                string expression = num[0].ToString();\\n                for (int j = 1; j <= n-1 ; j ++)\\n                {\\n                    string Operator = operators.Substring((j-1)*2, 2);\\n                    //if (Operator == \"00\") SKIP; //not necessary\\n                    if (Operator == \"01\") expression += '+';\\n                    if (Operator == \"10\") expression += '*';\\n                    if (Operator == \"11\") expression += '-';\\n                    expression += num[j];\\n                }\\n                if (Calculator(expression) == target)\\n                    total_strings.Add(expression);\\n\\n            }\\n            return total_strings;\\n        }\\n        static int Calculator(string exp)\\n        {\\n            Stack<int> st = new Stack<int>();\\n            int current_num = 0;\\n            char sign = '+';\\n            int result = 0;\\n\\n            for(int i=0; i<exp.Length; i++)\\n            {\\n                if (char.IsDigit(exp[i]))\\n                    current_num = current_num * 10 +int.Parse(exp[i].ToString());\\n                if(!char.IsDigit(exp[i]) || i==exp.Length-1)\\n                {\\n                    if (sign == '+')\\n                        st.Push(current_num);\\n                    if (sign == '-')\\n                        st.Push(-1 * current_num);\\n                    if(sign=='*')\\n                    {\\n                        int temp = st.Pop();\\n                        st.Push(temp * current_num);\\n                    }\\n                    sign = exp[i];\\n                    current_num = 0;\\n                }\\n            }\\n            while(st.Any())\\n            {\\n                result += st.Pop();\\n            }\\n            return result;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nstatic List<string> AddOperators(string num, int target, List<string> total_strings)\\n        {\\n            int n = num.Length;\\n            for (int i = 1; i < Math.Pow(4, n - 1); i++)\\n            {\\n\\t\\t//parsing to binary, then add leading zeros until we have enough length. for example, if n=4, we have 3 spots to fill\\n\\t\\t//if the current number code is 000011, we make sure to include 4 leading zeros to our string.\\n                string operators = Convert.ToString(i, 2).PadLeft((n - 1) * 2, '0'); \\n                string expression = num[0].ToString();\\n                for (int j = 1; j <= n-1 ; j ++)\\n                {\\n                    string Operator = operators.Substring((j-1)*2, 2);\\n                    //if (Operator == \"00\") SKIP; //not necessary\\n                    if (Operator == \"01\") expression += '+';\\n                    if (Operator == \"10\") expression += '*';\\n                    if (Operator == \"11\") expression += '-';\\n                    expression += num[j];\\n                }\\n                if (Calculator(expression) == target)\\n                    total_strings.Add(expression);\\n\\n            }\\n            return total_strings;\\n        }\\n        static int Calculator(string exp)\\n        {\\n            Stack<int> st = new Stack<int>();\\n            int current_num = 0;\\n            char sign = '+';\\n            int result = 0;\\n\\n            for(int i=0; i<exp.Length; i++)\\n            {\\n                if (char.IsDigit(exp[i]))\\n                    current_num = current_num * 10 +int.Parse(exp[i].ToString());\\n                if(!char.IsDigit(exp[i]) || i==exp.Length-1)\\n                {\\n                    if (sign == '+')\\n                        st.Push(current_num);\\n                    if (sign == '-')\\n                        st.Push(-1 * current_num);\\n                    if(sign=='*')\\n                    {\\n                        int temp = st.Pop();\\n                        st.Push(temp * current_num);\\n                    }\\n                    sign = exp[i];\\n                    current_num = 0;\\n                }\\n            }\\n            while(st.Any())\\n            {\\n                result += st.Pop();\\n            }\\n            return result;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71937,
                "title": "simple-and-straight-forward-ruby-solution",
                "content": "uncomment the line for 'puts' to see the output per recursion.\\n````\\ndef add_operators(num, target)\\n    @sets = []\\n    @num = num\\n    @target = target\\n    add_forward(\"\", nil, nil, 0)\\n    @sets\\nend\\n\\ndef add_forward(expression_str, expression_val, mult, counter)\\n    #puts \"counter: #{counter}, expression_str: #{expression_str}, #{eval(expression_str)}\"\\n    if counter == @num.length && expression_val == @target\\n        @sets << expression_str\\n        return\\n    end\\n    size = @num[counter] == \"0\" ? counter + 1 : @num.length\\n    for i in (counter+1)..size\\n        current_num = @num[counter...i].to_i\\n        if expression_str == \"\"\\n            add_forward(current_num.to_s, current_num, current_num, i)\\n            next\\n        end\\n\\n        add_forward(expression_str+\"+\"+current_num.to_s, expression_val+current_num, current_num, i)\\n        add_forward(expression_str+\"-\"+current_num.to_s, expression_val-current_num, -current_num, i)\\n        add_forward(expression_str+\"*\"+current_num.to_s, (expression_val-mult)+(mult*current_num), (mult*current_num), i)\\n    end\\nend\\n````",
                "solutionTags": [],
                "code": "````\\ndef add_operators(num, target)\\n    @sets = []\\n    @num = num\\n    @target = target\\n    add_forward(\"\", nil, nil, 0)\\n    @sets\\nend\\n\\ndef add_forward(expression_str, expression_val, mult, counter)\\n    #puts \"counter: #{counter}, expression_str: #{expression_str}, #{eval(expression_str)}\"\\n    if counter == @num.length && expression_val == @target\\n        @sets << expression_str\\n        return\\n    end\\n    size = @num[counter] == \"0\" ? counter + 1 : @num.length\\n    for i in (counter+1)..size\\n        current_num = @num[counter...i].to_i\\n        if expression_str == \"\"\\n            add_forward(current_num.to_s, current_num, current_num, i)\\n            next\\n        end\\n\\n        add_forward(expression_str+\"+\"+current_num.to_s, expression_val+current_num, current_num, i)\\n        add_forward(expression_str+\"-\"+current_num.to_s, expression_val-current_num, -current_num, i)\\n        add_forward(expression_str+\"*\"+current_num.to_s, (expression_val-mult)+(mult*current_num), (mult*current_num), i)\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71938,
                "title": "python-dfs-beats-98",
                "content": "I didn't look at other solutions so not sure if others are better, but here's what I came up with. Basically it does a DFS on the search space of all the possible combinations of arithmetic expressions, building the expression string as it goes along. To handle the higher operator precedence of multiplication I keep a running total of the previous left and right operands, so that the current result isn't calculated prematurely.  Below is my code.  Comments and suggestions appreciated\\n\\n```\\nclass Solution(object):\\n    def search(self,left,right, si,num,target,expr,res):\\n        if si >= len(num):\\n            if left+right == target:\\n                res.append(expr)\\n            return\\n        curr = 0\\n        for i in xrange(si,len(num)):\\n            curr = curr*10 + ord(num[i])-ord('0')\\n            currNum = num[si:i+1]\\n            if currNum[0]=='0' and len(currNum) > 1:\\n                continue # skip numbers with leading zeroes\\n            if si==0:\\n                self.search(0,curr,i+1,num,target,currNum,res)\\n            else:\\n                self.search(left+right,curr,i+1,num,target,expr+'+'+currNum,res) # plus\\n                self.search(left+right,-curr,i+1,num,target,expr+'-'+currNum,res) # minus\\n                self.search(left,right*curr,i+1,num,target,expr+'*'+currNum,res) # multiply\\n            \\n    def addOperators(self, num, target):\\n        res = []\\n        self.search(0,0,0,num,target,\"\",res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def search(self,left,right, si,num,target,expr,res):\\n        if si >= len(num):\\n            if left+right == target:\\n                res.append(expr)\\n            return\\n        curr = 0\\n        for i in xrange(si,len(num)):\\n            curr = curr*10 + ord(num[i])-ord('0')\\n            currNum = num[si:i+1]\\n            if currNum[0]=='0' and len(currNum) > 1:\\n                continue # skip numbers with leading zeroes\\n            if si==0:\\n                self.search(0,curr,i+1,num,target,currNum,res)\\n            else:\\n                self.search(left+right,curr,i+1,num,target,expr+'+'+currNum,res) # plus\\n                self.search(left+right,-curr,i+1,num,target,expr+'-'+currNum,res) # minus\\n                self.search(left,right*curr,i+1,num,target,expr+'*'+currNum,res) # multiply\\n            \\n    def addOperators(self, num, target):\\n        res = []\\n        self.search(0,0,0,num,target,\"\",res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71948,
                "title": "short-java-solution-without-loop",
                "content": "Maintain three numbers: **sum, mulL, mulR**. Attempt to reach the point that **sum + mulL * mulR == target**\\nStringBuilder is not used, because String is shorter and the solution is fast enough to fit the time limit.\\n\\n```\\npublic class Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ans = new ArrayList<>();\\n        search(ans, num, target, \"\", 0, 0, 1, 0);\\n        return ans;\\n    }\\n    private void search(List<String> ans, String num, int target, String literal, int idx, long sum, long mulL, long mulR) {\\n        if (idx < num.length()) {\\n            int digit = num.charAt(idx) - '0';\\n            if (idx > 0) {\\n                search(ans, num, target, literal + \"+\" + digit, idx + 1, sum + mulL * mulR, 1, digit);\\n                search(ans, num, target, literal + \"-\" + digit, idx + 1, sum + mulL * mulR, 1, -digit);\\n                search(ans, num, target, literal + \"*\" + digit, idx + 1, sum, mulL * mulR, digit);\\n            }\\n            if (idx == 0 || mulR != 0) {\\n                search(ans, num, target, literal + digit, idx + 1, sum, mulL, mulR * 10 + (mulR >= 0 ? digit : -digit));\\n            }\\n        } else if (sum + mulL * mulR == target) {\\n            ans.add(literal);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ans = new ArrayList<>();\\n        search(ans, num, target, \"\", 0, 0, 1, 0);\\n        return ans;\\n    }\\n    private void search(List<String> ans, String num, int target, String literal, int idx, long sum, long mulL, long mulR) {\\n        if (idx < num.length()) {\\n            int digit = num.charAt(idx) - '0';\\n            if (idx > 0) {\\n                search(ans, num, target, literal + \"+\" + digit, idx + 1, sum + mulL * mulR, 1, digit);\\n                search(ans, num, target, literal + \"-\" + digit, idx + 1, sum + mulL * mulR, 1, -digit);\\n                search(ans, num, target, literal + \"*\" + digit, idx + 1, sum, mulL * mulR, digit);\\n            }\\n            if (idx == 0 || mulR != 0) {\\n                search(ans, num, target, literal + digit, idx + 1, sum, mulL, mulR * 10 + (mulR >= 0 ? digit : -digit));\\n            }\\n        } else if (sum + mulL * mulR == target) {\\n            ans.add(literal);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71952,
                "title": "clear-c-solution-with-some-explanations",
                "content": "    vector<string> addOperators(string num, int target) {\\n    \\tvector<string> res;\\n    \\thelp(res, num, target, 0, \"\", 0);\\n    \\treturn res;\\n    }\\n    //use long long to avoid overflow\\n    void help(vector<string> &res, string num, long long target, int pos, string pre, long long last) {   \\n    \\tif (pos == num.size() && target == 0) {\\n    \\t\\tres.push_back(pre);\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor (int i = pos; i < num.size(); i++) {\\n    \\t\\tif (num[pos] == '0' && i > pos)                  //strings like \"05\" are not correct expression \\n    \\t\\t\\tbreak;\\n    \\t\\tstring temp = num.substr(pos, i - pos + 1);\\n    \\t\\tlong long cur = stoll(temp);                  \\n    \\t\\tif (pos == 0)\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, temp, cur);\\n    \\t\\telse {\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, pre + \"+\" + temp, cur);\\n    \\t\\t\\thelp(res, num, target + cur, i + 1, pre + \"-\" + temp, -cur);\\n    \\t\\t\\thelp(res, num, target + last - last*cur, i + 1, pre + \"*\" + temp, last*cur);\\n                //'*'is not same to '+-', we should plus \"last\" that we shouldn't have + or -.(* with high priority)\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\nThis is not a difficult problem but it really confuses me a lot.",
                "solutionTags": [],
                "code": "    vector<string> addOperators(string num, int target) {\\n    \\tvector<string> res;\\n    \\thelp(res, num, target, 0, \"\", 0);\\n    \\treturn res;\\n    }\\n    //use long long to avoid overflow\\n    void help(vector<string> &res, string num, long long target, int pos, string pre, long long last) {   \\n    \\tif (pos == num.size() && target == 0) {\\n    \\t\\tres.push_back(pre);\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor (int i = pos; i < num.size(); i++) {\\n    \\t\\tif (num[pos] == '0' && i > pos)                  //strings like \"05\" are not correct expression \\n    \\t\\t\\tbreak;\\n    \\t\\tstring temp = num.substr(pos, i - pos + 1);\\n    \\t\\tlong long cur = stoll(temp);                  \\n    \\t\\tif (pos == 0)\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, temp, cur);\\n    \\t\\telse {\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, pre + \"+\" + temp, cur);\\n    \\t\\t\\thelp(res, num, target + cur, i + 1, pre + \"-\" + temp, -cur);\\n    \\t\\t\\thelp(res, num, target + last - last*cur, i + 1, pre + \"*\" + temp, last*cur);\\n                //'*'is not same to '+-', we should plus \"last\" that we shouldn't have + or -.(* with high priority)\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\nThis is not a difficult problem but it really confuses me a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 71961,
                "title": "far-beating-all-submissions-in-c-accepted-with-16ms-well-explained",
                "content": "Always recursive method will a nice choice to handle this kind of DFS problem but meantime we should record some variables to move to the next round (in each round we will store the operator and then the selected number):\\n\\n- the current result -> sum;\\n- the previous number or partial result -> we need to handle <font color=\"#ff0000\">multiplication</font> unlike addition or subtraction it should be handled separately -> this is the <font color=\"#ff0000\">only reason</font> why we need this variable -> pre;\\n\\nOthers will be easily understood, I think with the help of the detailed comments in code.\\n\\nB.T.W. the complexity analysis is not quite easy here, but in a rough way:\\n\\n- space cost O(n^2)\\n- time cost O(2^n)\\n\\nIf some one gets some clear idea of this, please share with me. Thanks in advance!\\n\\n----------\\n\\n\\n       void helper(char* num, int len, int start, int target, long long sum, long long pre, char* stack, int top, char*** arr, int* returnSize)\\n    {\\n        if(start == len) //end of the string;\\n        {\\n            if(target == sum) //check whether it's valid;\\n            {\\n                stack[++top] = '\\\\0'; //terminate the string;\\n                *returnSize += 1; \\n                *arr = (char**)realloc(*arr, sizeof(char*)*(*returnSize));\\n                (*arr)[*returnSize-1] = (char*)malloc(sizeof(char)*(top+1));\\n                for(int i = 0; i <= top; i++)\\n                    (*arr)[*returnSize-1][i] = stack[i];\\n            }\\n            return ; \\n        }\\n        long long val = 0; //in case of INT_MAX or INT_MIN;\\n        int index = top+1; //record the index for the operator;\\n        for(int i = start; i < len; i++)\\n        {\\n            val = 10*val + num[i] - '0'; //collect the number;\\n            if(start == 0) //if it's the first number, no operator should be added;\\n            {\\n                stack[top+1] = num[i];\\n                helper(num, len, i+1, target, val, val, stack, top+1, arr, returnSize);\\n            }\\n            else\\n            {\\n                stack[top+2] = num[i];\\n                stack[index] = '-'; //get the sum directly by sum-val and record -1*val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-val, -1*val, stack, top+2, arr, returnSize);\\n                stack[index] = '+'; //store val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum+val, val, stack, top+2, arr, returnSize);\\n                stack[index] = '*'; //we have to delete the pre first and then add the product of pre and var and then store pre*val in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-pre+pre*val, pre*val, stack, top+2, arr, returnSize);\\n            }\\n            if(num[start] == '0') break; //no number starts with 0;\\n            top++;\\n        }\\n    }\\n    char** addOperators(char* num, int target, int* returnSize)\\n    {\\n        char** arr = (char**)malloc(sizeof(char*));\\n        *returnSize = 0;\\n        int len = strlen(num);\\n        if(len == 0) return arr;\\n        char* stack = (char*)malloc(sizeof(char)*2*len);\\n        int top = -1;\\n        helper(num, len, 0, target, 0, 0, stack, top, &arr, returnSize);\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "Always recursive method will a nice choice to handle this kind of DFS problem but meantime we should record some variables to move to the next round (in each round we will store the operator and then the selected number):\\n\\n- the current result -> sum;\\n- the previous number or partial result -> we need to handle <font color=\"#ff0000\">multiplication</font> unlike addition or subtraction it should be handled separately -> this is the <font color=\"#ff0000\">only reason</font> why we need this variable -> pre;\\n\\nOthers will be easily understood, I think with the help of the detailed comments in code.\\n\\nB.T.W. the complexity analysis is not quite easy here, but in a rough way:\\n\\n- space cost O(n^2)\\n- time cost O(2^n)\\n\\nIf some one gets some clear idea of this, please share with me. Thanks in advance!\\n\\n----------\\n\\n\\n       void helper(char* num, int len, int start, int target, long long sum, long long pre, char* stack, int top, char*** arr, int* returnSize)\\n    {\\n        if(start == len) //end of the string;\\n        {\\n            if(target == sum) //check whether it's valid;\\n            {\\n                stack[++top] = '\\\\0'; //terminate the string;\\n                *returnSize += 1; \\n                *arr = (char**)realloc(*arr, sizeof(char*)*(*returnSize));\\n                (*arr)[*returnSize-1] = (char*)malloc(sizeof(char)*(top+1));\\n                for(int i = 0; i <= top; i++)\\n                    (*arr)[*returnSize-1][i] = stack[i];\\n            }\\n            return ; \\n        }\\n        long long val = 0; //in case of INT_MAX or INT_MIN;\\n        int index = top+1; //record the index for the operator;\\n        for(int i = start; i < len; i++)\\n        {\\n            val = 10*val + num[i] - '0'; //collect the number;\\n            if(start == 0) //if it's the first number, no operator should be added;\\n            {\\n                stack[top+1] = num[i];\\n                helper(num, len, i+1, target, val, val, stack, top+1, arr, returnSize);\\n            }\\n            else\\n            {\\n                stack[top+2] = num[i];\\n                stack[index] = '-'; //get the sum directly by sum-val and record -1*val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-val, -1*val, stack, top+2, arr, returnSize);\\n                stack[index] = '+'; //store val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum+val, val, stack, top+2, arr, returnSize);\\n                stack[index] = '*'; //we have to delete the pre first and then add the product of pre and var and then store pre*val in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-pre+pre*val, pre*val, stack, top+2, arr, returnSize);\\n            }\\n            if(num[start] == '0') break; //no number starts with 0;\\n            top++;\\n        }\\n    }\\n    char** addOperators(char* num, int target, int* returnSize)\\n    {\\n        char** arr = (char**)malloc(sizeof(char*));\\n        *returnSize = 0;\\n        int len = strlen(num);\\n        if(len == 0) return arr;\\n        char* stack = (char*)malloc(sizeof(char)*2*len);\\n        int top = -1;\\n        helper(num, len, 0, target, 0, 0, stack, top, &arr, returnSize);\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71964,
                "title": "there-seems-not-any-c-solution-post-share-mine",
                "content": "    void ao( char* num, int cur, double left, double sum, char* sol, char*** res, int* resEnd, int* resCap, int target ){\\n        if( cur == strlen(num) && left * sum == target ){\\n            if( *resEnd == *resCap ){\\n                *resCap *= 2;\\n                *res = realloc( *res, (*resCap) * sizeof( **res ) );\\n            }\\n            ( *res )[ *resEnd ] = sol;\\n            ( *resEnd )++;\\n            return;\\n        }\\n        \\n        if( cur == strlen(num) ){\\n            return;\\n        }\\n        \\n        int oldLen = strlen( sol );\\n        if( sum != 0 ){\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = num[cur];\\n            ao( num, cur+1, left, sum * 10 + ( num[ cur ] - '0' ), newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '*';\\n            newSol[ oldLen + 1 ] = num[cur];\\n            ao( num, cur+1, left * sum, num[ cur ] - '0', newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '+';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, 1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '-';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, -1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        \\n        free( sol );\\n    } \\n    \\n    char** addOperators(char* num, int target, int* returnSize) {\\n        int resCap = 16;\\n        char** res = calloc( resCap, sizeof( *res ) );\\n        int resEnd = 0; // 0 .. resEnd-1 is the current result we have\\n    \\n        int n = strlen( num );\\n    \\n        if( n== 0 ){\\n            return res;\\n        }\\n        \\n        char* sol = calloc( 2 * n - 1, sizeof( *sol ) );\\n        memset( sol, '\\\\0', 2 * n - 1);\\n        sol[0] = num[0];\\n        \\n        ao( num, 1, 1, num[0] - '0', sol, &res, &resEnd, &resCap, target );\\n        \\n        *returnSize = resEnd;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    void ao( char* num, int cur, double left, double sum, char* sol, char*** res, int* resEnd, int* resCap, int target ){\\n        if( cur == strlen(num) && left * sum == target ){\\n            if( *resEnd == *resCap ){\\n                *resCap *= 2;\\n                *res = realloc( *res, (*resCap) * sizeof( **res ) );\\n            }\\n            ( *res )[ *resEnd ] = sol;\\n            ( *resEnd )++;\\n            return;\\n        }\\n        \\n        if( cur == strlen(num) ){\\n            return;\\n        }\\n        \\n        int oldLen = strlen( sol );\\n        if( sum != 0 ){\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = num[cur];\\n            ao( num, cur+1, left, sum * 10 + ( num[ cur ] - '0' ), newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '*';\\n            newSol[ oldLen + 1 ] = num[cur];\\n            ao( num, cur+1, left * sum, num[ cur ] - '0', newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '+';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, 1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '-';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, -1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        \\n        free( sol );\\n    } \\n    \\n    char** addOperators(char* num, int target, int* returnSize) {\\n        int resCap = 16;\\n        char** res = calloc( resCap, sizeof( *res ) );\\n        int resEnd = 0; // 0 .. resEnd-1 is the current result we have\\n    \\n        int n = strlen( num );\\n    \\n        if( n== 0 ){\\n            return res;\\n        }\\n        \\n        char* sol = calloc( 2 * n - 1, sizeof( *sol ) );\\n        memset( sol, '\\\\0', 2 * n - 1);\\n        sol[0] = num[0];\\n        \\n        ao( num, 1, 1, num[0] - '0', sol, &res, &resEnd, &resCap, target );\\n        \\n        *returnSize = resEnd;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3817648,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\nvoid generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n);\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n          vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n);\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n          vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696293,
                "title": "c-expression-evaluation-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApproach is to use a backtracking technique with memoization. We can recursively build the expressions by trying out different operators at each step and keeping track of the current sum. The memoization technique can help avoid redundant calculations and improve efficiency by storing intermediate results. This approach would require careful handling of operators and their precedence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAddition: We make a recursive call with the updated currentSum by adding the current number and the updated currentExpr by appending the \\'+\\' operator and the current number.\\n\\nSubtraction: We make a recursive call with the updated currentSum by subtracting the current number and the updated currentExpr by appending the \\'-\\' operator and the current number.\\n\\nMultiplication: We make a recursive call with the updated currentSum by subtracting the previous number and adding the product of the previous number and the current number. We also update the currentExpr accordingly.\\n\\nWhen considering the multiplication operation, we need to take into account its precedence over addition and subtraction. In other words, multiplication should be evaluated before addition and subtraction in the expression.\\n\\nTo incorporate multiplication into our backtracking algorithm, we need to keep track of the previous number (operand) and update the current sum accordingly when encountering the multiplication operator.\\n\\n# Complexity\\n- Time complexity:\\nthe number of possible expressions can be approximated as 3^(n-1) since each digit (except the first one) can be preceded by three different operators. Therefore, the time complexity of the backtracking algorithm can be considered as O(3^(n-1)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace complexity due to the recursive stack is O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> memo;\\n    vector<string> result;\\n    \\n    void backtrack(string num, int target, int index, long currentSum, long prevNum, string currentExpr) {\\n        if (index == num.length()) {\\n            if (currentSum == target) {\\n                result.push_back(currentExpr);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.length(); i++) {\\n            string currentStr = num.substr(index, i - index + 1);\\n            \\n            if (currentStr.length() > 1 && currentStr[0] == \\'0\\') {\\n                // Avoid leading zeros\\n                break;\\n            }\\n            \\n            long currentNum = stol(currentStr);\\n            \\n            if (index == 0) {\\n                backtrack(num, target, i + 1, currentNum, currentNum, currentExpr + currentStr);\\n            } else {\\n                // \\'+\\'\\n                backtrack(num, target, i + 1, currentSum + currentNum, currentNum, currentExpr + \"+\" + currentStr);\\n                \\n                // \\'-\\'\\n                backtrack(num, target, i + 1, currentSum - currentNum, -currentNum, currentExpr + \"-\" + currentStr);\\n                \\n                // \\'*\\'\\n                backtrack(num, target, i + 1, currentSum - prevNum + prevNum * currentNum, prevNum * currentNum, currentExpr + \"*\" + currentStr);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        backtrack(num, target, 0, 0, 0, \"\");\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> memo;\\n    vector<string> result;\\n    \\n    void backtrack(string num, int target, int index, long currentSum, long prevNum, string currentExpr) {\\n        if (index == num.length()) {\\n            if (currentSum == target) {\\n                result.push_back(currentExpr);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.length(); i++) {\\n            string currentStr = num.substr(index, i - index + 1);\\n            \\n            if (currentStr.length() > 1 && currentStr[0] == \\'0\\') {\\n                // Avoid leading zeros\\n                break;\\n            }\\n            \\n            long currentNum = stol(currentStr);\\n            \\n            if (index == 0) {\\n                backtrack(num, target, i + 1, currentNum, currentNum, currentExpr + currentStr);\\n            } else {\\n                // \\'+\\'\\n                backtrack(num, target, i + 1, currentSum + currentNum, currentNum, currentExpr + \"+\" + currentStr);\\n                \\n                // \\'-\\'\\n                backtrack(num, target, i + 1, currentSum - currentNum, -currentNum, currentExpr + \"-\" + currentStr);\\n                \\n                // \\'*\\'\\n                backtrack(num, target, i + 1, currentSum - prevNum + prevNum * currentNum, prevNum * currentNum, currentExpr + \"*\" + currentStr);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        backtrack(num, target, 0, 0, 0, \"\");\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636686,
                "title": "backtracking-solution-without-pruning-easy-to-understand-go-solution",
                "content": "# Intuition\\nBack track to form all the possible expressions. Don\\'t prune as it might elminate possible solutions. Use stack to evaluate the expression.\\n\\n# Approach\\n* multiplication operation has higher precedence than addion(+) or substraction(-)\\n\\n# Code\\n```\\nimport \"strconv\"\\nimport \"strings\"\\n// -1 = +\\n// -2 = -\\n// -3 = *\\n\\nfunc addOperators(num string, target int) []string {\\n\\tfinalResults := []string{}\\n\\tnumber, _ := strconv.Atoi(num)\\n\\texpr := make([]int, len(num))\\n\\tl := len(num) - 1\\n\\tfor number != 0 {\\n\\t\\texpr[l] = number % 10\\n\\t\\tl--\\n\\t\\t//expr = append(expr, number%10)\\n\\t\\tnumber = number / 10\\n\\t}\\n\\t//reverse := func(s string) string {\\n\\t//\\trns := []rune(s) // convert to rune\\n\\t//\\tfor i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {\\n\\t//\\n\\t//\\t\\t// swap the letters of the string,\\n\\t//\\t\\t// like first with last and so on.\\n\\t//\\t\\trns[i], rns[j] = rns[j], rns[i]\\n\\t//\\t}\\n\\t//\\n\\t//\\t// return the reversed string.\\n\\t//\\treturn string(rns)\\n\\t//}\\n\\taddToResults := func(expression []int) {\\n\\t\\tvar r strings.Builder\\n\\t\\tfor _, v := range expression {\\n\\t\\t\\tif v == -1 {\\n\\t\\t\\t\\tr.WriteString(\"+\")\\n\\t\\t\\t} else if v == -2 {\\n\\t\\t\\t\\tr.WriteString(\"-\")\\n\\t\\t\\t} else if v == -3 {\\n\\t\\t\\t\\tr.WriteString(\"*\")\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr.WriteString(strconv.Itoa(v))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinalResults = append(finalResults, r.String())\\n\\t}\\n\\n\\tvalidExpression := func(expression []int, target int) int {\\n\\t\\tstack := []int{}\\n\\t\\t//fmt.Println(\"Expression : \", expression)\\n\\t\\tfor _, val := range expression {\\n\\t\\t\\tif val >= 0 && len(stack) > 0 && stack[len(stack)-1] == -3 {\\n\\t\\t\\t\\tstack[len(stack)-2] = val * stack[len(stack)-2]\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstack = append(stack, val)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(stack) > 1 {\\n\\t\\t\\tresult := stack[0]\\n\\t\\t\\toperation := stack[1]\\n\\t\\t\\tfor i := 2; i < len(stack); i++ {\\n\\t\\t\\t\\tif stack[i] > 0 {\\n\\t\\t\\t\\t\\tif operation == -1 {\\n\\t\\t\\t\\t\\t\\tresult = result + stack[i]\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult = result - stack[i]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\toperation = stack[i]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//fmt.Println(\"Result: \", result)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t\\t//fmt.Println(\"Result: \", stack[0])\\n\\t\\treturn stack[0]\\n\\t}\\n\\n\\tvar add func([]int, []int, int, int)\\n\\tadd = func(num []int, expression []int, target int, index int) {\\n\\t\\tif index == len(num) {\\n\\t\\t\\tif validExpression(expression, target) == target {\\n\\t\\t\\t\\taddToResults(expression)\\n\\t\\t\\t}\\n\\t\\t} else {\\n            // Add\\n            copyExp := make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -1)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n\\t\\t\\tadd(num, copyExp, target, index+1)\\n\\n            //Substract\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -2)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Multiplication\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -3)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Combine current digit with last operand\\n            if expression[len(expression)-1] != 0 {\\n                expression[len(expression)-1] = (expression[len(expression)-1]*10)+num[index];\\n                add(num, expression,target, index+1)\\n            }\\n\\n\\t\\t}\\n\\t}\\n\\tadd(expr, []int{expr[0]}, target, 1)\\n\\treturn finalResults\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\nimport \"strconv\"\\nimport \"strings\"\\n// -1 = +\\n// -2 = -\\n// -3 = *\\n\\nfunc addOperators(num string, target int) []string {\\n\\tfinalResults := []string{}\\n\\tnumber, _ := strconv.Atoi(num)\\n\\texpr := make([]int, len(num))\\n\\tl := len(num) - 1\\n\\tfor number != 0 {\\n\\t\\texpr[l] = number % 10\\n\\t\\tl--\\n\\t\\t//expr = append(expr, number%10)\\n\\t\\tnumber = number / 10\\n\\t}\\n\\t//reverse := func(s string) string {\\n\\t//\\trns := []rune(s) // convert to rune\\n\\t//\\tfor i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {\\n\\t//\\n\\t//\\t\\t// swap the letters of the string,\\n\\t//\\t\\t// like first with last and so on.\\n\\t//\\t\\trns[i], rns[j] = rns[j], rns[i]\\n\\t//\\t}\\n\\t//\\n\\t//\\t// return the reversed string.\\n\\t//\\treturn string(rns)\\n\\t//}\\n\\taddToResults := func(expression []int) {\\n\\t\\tvar r strings.Builder\\n\\t\\tfor _, v := range expression {\\n\\t\\t\\tif v == -1 {\\n\\t\\t\\t\\tr.WriteString(\"+\")\\n\\t\\t\\t} else if v == -2 {\\n\\t\\t\\t\\tr.WriteString(\"-\")\\n\\t\\t\\t} else if v == -3 {\\n\\t\\t\\t\\tr.WriteString(\"*\")\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr.WriteString(strconv.Itoa(v))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinalResults = append(finalResults, r.String())\\n\\t}\\n\\n\\tvalidExpression := func(expression []int, target int) int {\\n\\t\\tstack := []int{}\\n\\t\\t//fmt.Println(\"Expression : \", expression)\\n\\t\\tfor _, val := range expression {\\n\\t\\t\\tif val >= 0 && len(stack) > 0 && stack[len(stack)-1] == -3 {\\n\\t\\t\\t\\tstack[len(stack)-2] = val * stack[len(stack)-2]\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstack = append(stack, val)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(stack) > 1 {\\n\\t\\t\\tresult := stack[0]\\n\\t\\t\\toperation := stack[1]\\n\\t\\t\\tfor i := 2; i < len(stack); i++ {\\n\\t\\t\\t\\tif stack[i] > 0 {\\n\\t\\t\\t\\t\\tif operation == -1 {\\n\\t\\t\\t\\t\\t\\tresult = result + stack[i]\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult = result - stack[i]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\toperation = stack[i]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//fmt.Println(\"Result: \", result)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t\\t//fmt.Println(\"Result: \", stack[0])\\n\\t\\treturn stack[0]\\n\\t}\\n\\n\\tvar add func([]int, []int, int, int)\\n\\tadd = func(num []int, expression []int, target int, index int) {\\n\\t\\tif index == len(num) {\\n\\t\\t\\tif validExpression(expression, target) == target {\\n\\t\\t\\t\\taddToResults(expression)\\n\\t\\t\\t}\\n\\t\\t} else {\\n            // Add\\n            copyExp := make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -1)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n\\t\\t\\tadd(num, copyExp, target, index+1)\\n\\n            //Substract\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -2)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Multiplication\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -3)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Combine current digit with last operand\\n            if expression[len(expression)-1] != 0 {\\n                expression[len(expression)-1] = (expression[len(expression)-1]*10)+num[index];\\n                add(num, expression,target, index+1)\\n            }\\n\\n\\t\\t}\\n\\t}\\n\\tadd(expr, []int{expr[0]}, target, 1)\\n\\treturn finalResults\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2518924,
                "title": "share-my-c-ac-code",
                "content": "```cpp\\nclass Solution {\\n  public:\\n    vector<string> addOperators(string num, int target) {\\n      string prev;\\n      vector<string> ans;\\n      foo(num, 0, 0, target, prev, ans);\\n      return ans;\\n    }\\n    void eval(long long a, char op, long long b, long long& res, long long& mul_res) {\\n      switch(op) {\\n        case \\'+\\':\\n          res = a + b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'-\\':\\n          res = a - b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'*\\':\\n          //don\\'t know previous sign, deal in calling function\\n          //if (mul_res == 0) mul_res = a;\\n          mul_res *= b;\\n          res += mul_res;\\n          break;\\n        case \\' \\':\\n          res = b;\\n          break;\\n        default:\\n          cerr << \"invalid operator\\\\n\";\\n          exit(1);\\n      }\\n      \\n    }\\n    void foo(string nums, long long cur, long long mul_cur, int target, string& prev, vector<string>& ans) {\\n      char last_op = prev.empty() ? \\' \\' : prev.back();\\n      if (nums.length() == 1 || nums[0] != \\'0\\') { //except leading zero\\n        long long num = stol(nums);\\n        long long tmp = cur, mul_tmp = mul_cur;\\n        eval(cur, last_op, num, tmp, mul_tmp);\\n        //cout << prev  << nums << \" == \" << tmp << \" #\" << cur << \" \" << mul_cur << \" \" << target << endl; //use python eval to test\\n        if (tmp == target) ans.push_back(prev + nums);\\n      }\\n      const size_t nums_len = nums.length();\\n      if (nums.length() < 2) return;\\n      \\n      const size_t cur_prev_len = prev.length();\\n      for (size_t i = 1; i < nums_len; i++) {\\n        string fronts = nums.substr(0, i);\\n        if (i > 1 && nums[0] == \\'0\\') break;//leading zero\\n        string backs = nums.substr(i);\\n        long long front = stol(fronts);\\n        long long new_cur = cur, new_mul = mul_cur;\\n        eval(cur, last_op, front, new_cur, new_mul);\\n        \\n        prev += fronts;\\n        prev.push_back(\\'+\\');\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'-\\';\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'*\\';\\n        if (last_op != \\'*\\') //last_op is not \\'*\\'\\n          new_mul = ((last_op == \\'-\\') * -2 + 1) * front;\\n        foo(backs, cur, new_mul, target, prev, ans);\\n        \\n        prev.resize(cur_prev_len);\\n      }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n  public:\\n    vector<string> addOperators(string num, int target) {\\n      string prev;\\n      vector<string> ans;\\n      foo(num, 0, 0, target, prev, ans);\\n      return ans;\\n    }\\n    void eval(long long a, char op, long long b, long long& res, long long& mul_res) {\\n      switch(op) {\\n        case \\'+\\':\\n          res = a + b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'-\\':\\n          res = a - b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'*\\':\\n          //don\\'t know previous sign, deal in calling function\\n          //if (mul_res == 0) mul_res = a;\\n          mul_res *= b;\\n          res += mul_res;\\n          break;\\n        case \\' \\':\\n          res = b;\\n          break;\\n        default:\\n          cerr << \"invalid operator\\\\n\";\\n          exit(1);\\n      }\\n      \\n    }\\n    void foo(string nums, long long cur, long long mul_cur, int target, string& prev, vector<string>& ans) {\\n      char last_op = prev.empty() ? \\' \\' : prev.back();\\n      if (nums.length() == 1 || nums[0] != \\'0\\') { //except leading zero\\n        long long num = stol(nums);\\n        long long tmp = cur, mul_tmp = mul_cur;\\n        eval(cur, last_op, num, tmp, mul_tmp);\\n        //cout << prev  << nums << \" == \" << tmp << \" #\" << cur << \" \" << mul_cur << \" \" << target << endl; //use python eval to test\\n        if (tmp == target) ans.push_back(prev + nums);\\n      }\\n      const size_t nums_len = nums.length();\\n      if (nums.length() < 2) return;\\n      \\n      const size_t cur_prev_len = prev.length();\\n      for (size_t i = 1; i < nums_len; i++) {\\n        string fronts = nums.substr(0, i);\\n        if (i > 1 && nums[0] == \\'0\\') break;//leading zero\\n        string backs = nums.substr(i);\\n        long long front = stol(fronts);\\n        long long new_cur = cur, new_mul = mul_cur;\\n        eval(cur, last_op, front, new_cur, new_mul);\\n        \\n        prev += fronts;\\n        prev.push_back(\\'+\\');\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'-\\';\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'*\\';\\n        if (last_op != \\'*\\') //last_op is not \\'*\\'\\n          new_mul = ((last_op == \\'-\\') * -2 + 1) * front;\\n        foo(backs, cur, new_mul, target, prev, ans);\\n        \\n        prev.resize(cur_prev_len);\\n      }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2394320,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        answer = set()\\n        \\n        def dp(idx, total, path, last_number):\\n            if idx == len(num) and total == target:\\n                answer.add(path)\\n                \\n            if idx >= len(num):\\n                return\\n            \\n            for i in range(idx, len(num)):\\n                if len(num[idx:i+1]) > 1 and num[idx:i+1][0] == \"0\":\\n                    continue\\n                    \\n                tmp_number = num[idx:i+1]\\n                \\n                if last_number == \"\":\\n                    dp(i + 1, int(tmp_number), tmp_number, tmp_number)\\n                else:\\n                    # addition\\n                    dp(i + 1,total + int(tmp_number), path + \"+\" + tmp_number, tmp_number)\\n                    \\n                    # subtraction\\n                    dp(i + 1,total - int(tmp_number), path + \"-\" + tmp_number, \"-\" + tmp_number)\\n                    \\n                    # multiplication\\n                    dp(i + 1, total-int(last_number) + (int(last_number) * int(tmp_number)), path + \"*\" + tmp_number, str(int(tmp_number) * int(last_number)))\\n\\n        dp(0,-1,\"\", \"\")\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        answer = set()\\n        \\n        def dp(idx, total, path, last_number):\\n            if idx == len(num) and total == target:\\n                answer.add(path)\\n                \\n            if idx >= len(num):\\n                return\\n            \\n            for i in range(idx, len(num)):\\n                if len(num[idx:i+1]) > 1 and num[idx:i+1][0] == \"0\":\\n                    continue\\n                    \\n                tmp_number = num[idx:i+1]\\n                \\n                if last_number == \"\":\\n                    dp(i + 1, int(tmp_number), tmp_number, tmp_number)\\n                else:\\n                    # addition\\n                    dp(i + 1,total + int(tmp_number), path + \"+\" + tmp_number, tmp_number)\\n                    \\n                    # subtraction\\n                    dp(i + 1,total - int(tmp_number), path + \"-\" + tmp_number, \"-\" + tmp_number)\\n                    \\n                    # multiplication\\n                    dp(i + 1, total-int(last_number) + (int(last_number) * int(tmp_number)), path + \"*\" + tmp_number, str(int(tmp_number) * int(last_number)))\\n\\n        dp(0,-1,\"\", \"\")\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301093,
                "title": "python3",
                "content": "class Solution:\\n\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        result = []\\n        \\n        def Helper(i,prev,curr,val,expr):\\n            if i == n:\\n                if val == target and curr==0:\\n                    result.append(expr)\\n                return\\n            \\n            curr = curr*10 + int(num[i])\\n            \\n            if curr>0:\\n                Helper(i+1,prev,curr,val,expr)\\n                \\n            if not expr:\\n                Helper(i+1,curr,0,val+curr,str(curr))\\n            else:\\n                Helper(i+1,curr,0,val+curr,expr+\\'+\\'+str(curr))\\n                Helper(i+1,-curr,0,val-curr,expr+\\'-\\'+str(curr))\\n                Helper(i+1,prev*curr,0,val-prev+prev*curr,expr+\\'*\\'+str(curr))\\n           \\n        Helper(0,0,0,0,\"\")\\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        result = []\\n        \\n        def Helper(i,prev,curr,val,expr):\\n            if i == n:\\n                if val == target and curr==0:\\n                    result.append(expr)\\n                return\\n            \\n            curr = curr*10 + int(num[i])\\n            \\n            if curr>0:\\n                Helper(i+1,prev,curr,val,expr)\\n                \\n            if not expr:\\n                Helper(i+1,curr,0,val+curr,str(curr))\\n            else:\\n                Helper(i+1,curr,0,val+curr,expr+\\'+\\'+str(curr))\\n                Helper(i+1,-curr,0,val-curr,expr+\\'-\\'+str(curr))\\n                Helper(i+1,prev*curr,0,val-prev+prev*curr,expr+\\'*\\'+str(curr))\\n           \\n        Helper(0,0,0,0,\"\")\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2210626,
                "title": "c-backtrack-clean-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> res;\\n\\t\\tstring s;\\n\\t\\tint target, n;\\n\\t\\tvoid solve(int it,  string path, long long resSoFar, long long prev){\\n\\t\\t\\tif(it == n){\\n\\t\\t\\t\\tif(resSoFar == target) res.push_back(path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tlong long num = 0;\\n\\t\\t\\tstring tmp;\\n\\n\\t\\t\\tfor(auto j = it; j < n; j++){\\n\\t\\t\\t\\tif(j > it && s[it] == \\'0\\') break;\\n\\n\\t\\t\\t\\tnum = num * 10 + (s[j] - \\'0\\');\\n\\t\\t\\t\\ttmp.push_back(s[j]);\\n\\n\\t\\t\\t\\tif(it == 0) solve(j + 1, tmp, num, num);\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \"+\" + tmp, resSoFar + num, num);\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \\'-\\' + tmp, resSoFar - num, -num);\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \\'*\\' + tmp, resSoFar - prev + prev * num, prev * num);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tvector<string> addOperators(string num, int target) {\\n\\t\\t\\tthis -> target = target;\\n\\t\\t\\ts = num, n = num.size();\\n\\n\\t\\t\\tsolve(0, \"\", 0, 0);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> res;\\n\\t\\tstring s;\\n\\t\\tint target, n;\\n\\t\\tvoid solve(int it,  string path, long long resSoFar, long long prev){\\n\\t\\t\\tif(it == n){\\n\\t\\t\\t\\tif(resSoFar == target) res.push_back(path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2157952,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    string num;\\n    int target;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        this->num = num;\\n        \\n        this->target = target;\\n        \\n        backtrack( 0, \"\", 0, 0);\\n        \\n        return ans;\\n    }\\n    void backtrack(int i, const string& path, long resSoFar, long prevNum) {\\n        \\n        if (i == num.size()) {\\n            \\n            if (resSoFar == target)   \\n            {\\n                ans.push_back(path);\\n                \\n            }\\n            \\n            return;\\n        \\n        }\\n        \\n        string numStr;\\n        \\n        long num1 = 0;\\n        \\n        for (int j = i; j < num.length(); j++) {\\n            \\n            if (j > i && num[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            numStr += num[j];\\n            \\n            num1 = num1 * 10 + num[j] - \\'0\\';\\n            \\n            if (i == 0) {\\n                \\n                backtrack(j + 1, path + numStr, num1, num1);\\n                \\n            } else {\\n                \\n                backtrack(j + 1, path + \"+\" + numStr, resSoFar + num1, num1);\\n                \\n                backtrack(j + 1, path + \"-\" + numStr, resSoFar - num1, -num1);\\n                \\n                backtrack(j + 1, path + \"*\" + numStr, resSoFar - prevNum + prevNum * num1, prevNum * num1);\\n            }\\n        }\\n    }\\n};    \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    string num;\\n    int target;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        this->num = num;\\n        \\n        this->target = target;\\n        \\n        backtrack( 0, \"\", 0, 0);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2109805,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)        \\n\\t\\t\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)        \\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1999699,
                "title": "python-naive-recursion",
                "content": "Can pass. Although it is slow. but the code cleaner. Replace - with +-, so that the final string will only have + and * two operations. \\nFirst split by + to get all parts. \\nThen split by * to get each part value. Super clean to code.\\nAlso, each part split by + can be cached to avoid duplicate calculation.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        ans = []\\n        \\n        @cache\\n        def subcheck(s):            \\n            parts = s.split(\\'*\\')\\n            res = int(parts[0])\\n            for p in parts[1:]:\\n                res *= int(p)\\n            return res\\n        \\n        def check(s):      \\n            ss = \\'\\'.join(s)\\n            # print(s)\\n            parts = ss.split(\\'+\\')\\n            sumv = sum(map(subcheck, parts))\\n            if sumv == target:\\n                ss = ss.replace(\\'+-\\', \\'-\\')\\n                ans.append(ss)\\n        \\n        def bt(cur, i):\\n            if i == n:\\n                check(cur)\\n                return\\n            if i == 0:\\n                bt(cur + [num[i]], i + 1)\\n            else:\\n                if cur[-1] == \\'0\\' and (len(cur)< 2 or (not (\\'0\\'<= cur[-2] <= \\'9\\'))): # for leading 0\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)\\n                else:\\n                    bt(cur + [num[i]], i + 1)\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)            \\n            \\n        bt([], 0)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        ans = []\\n        \\n        @cache\\n        def subcheck(s):            \\n            parts = s.split(\\'*\\')\\n            res = int(parts[0])\\n            for p in parts[1:]:\\n                res *= int(p)\\n            return res\\n        \\n        def check(s):      \\n            ss = \\'\\'.join(s)\\n            # print(s)\\n            parts = ss.split(\\'+\\')\\n            sumv = sum(map(subcheck, parts))\\n            if sumv == target:\\n                ss = ss.replace(\\'+-\\', \\'-\\')\\n                ans.append(ss)\\n        \\n        def bt(cur, i):\\n            if i == n:\\n                check(cur)\\n                return\\n            if i == 0:\\n                bt(cur + [num[i]], i + 1)\\n            else:\\n                if cur[-1] == \\'0\\' and (len(cur)< 2 or (not (\\'0\\'<= cur[-2] <= \\'9\\'))): # for leading 0\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)\\n                else:\\n                    bt(cur + [num[i]], i + 1)\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)            \\n            \\n        bt([], 0)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940237,
                "title": "python-code",
                "content": "```\\n    def addOperators(self, num: str, T: int) -> List[str]:\\n\\n\\t\\tdef f(i, exp, prev, expval):\\n\\n\\t\\t\\tif i == len(num):\\n\\t\\t\\t\\tif expval == T:\\n\\t\\t\\t\\t\\tself.res.append(exp)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor j in range(i, len(num)):\\n\\t\\t\\t\\tcur = int(num[i:j+1])\\n\\t\\t\\t\\tif num[i] == \\'0\\' and i < j: # 1* 05 = 1*5 is not allowed so 05 has to be skipped. IMP\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tf(j+1, str(cur), cur, cur) # IMP: 1st number will not use any operators. Each subsequent number will be <op> num\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'+\\' + str(cur), cur, expval+cur)\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'-\\' + str(cur), -cur, expval-cur) # IMP: -cur is passed to reverse this calulation on encountering \\'*\\'\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'*\\' + str(cur), prev*cur, expval - prev + prev*cur) #IMP\\n\\n\\t\\tself.res = []\\n\\t\\tf(0, \"\", 0, 0)\\n\\t\\treturn self.res\\n\\n# To tackle the problem of order of evalution (calculating the product before sum), we always calculate sum but change the exp val when we encounter the \\'*\\'\\n```",
                "solutionTags": [],
                "code": "```\\n    def addOperators(self, num: str, T: int) -> List[str]:\\n\\n\\t\\tdef f(i, exp, prev, expval):\\n\\n\\t\\t\\tif i == len(num):\\n\\t\\t\\t\\tif expval == T:\\n\\t\\t\\t\\t\\tself.res.append(exp)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor j in range(i, len(num)):\\n\\t\\t\\t\\tcur = int(num[i:j+1])\\n\\t\\t\\t\\tif num[i] == \\'0\\' and i < j: # 1* 05 = 1*5 is not allowed so 05 has to be skipped. IMP\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tf(j+1, str(cur), cur, cur) # IMP: 1st number will not use any operators. Each subsequent number will be <op> num\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'+\\' + str(cur), cur, expval+cur)\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'-\\' + str(cur), -cur, expval-cur) # IMP: -cur is passed to reverse this calulation on encountering \\'*\\'\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'*\\' + str(cur), prev*cur, expval - prev + prev*cur) #IMP\\n\\n\\t\\tself.res = []\\n\\t\\tf(0, \"\", 0, 0)\\n\\t\\treturn self.res\\n\\n# To tackle the problem of order of evalution (calculating the product before sum), we always calculate sum but change the exp val when we encounter the \\'*\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1926405,
                "title": "java-99-fast-solution-with-full-detailed-explanations",
                "content": "```\\nclass Solution\\n{\\n    public List<String> addOperators(String num, int target)\\n    {\\n        List<String> result = new ArrayList<>();\\n        if (target == Integer.MIN_VALUE) return result;\\n        \\n        // using char array to avoid more space consuming by string\\n        char[] originalChars = num.toCharArray();\\n        int len = num.length();\\n        \\n        // the maximum length of the new string with operators is 2 * len - 1(1 + 1 + 2)\\n        // add an operator in between each character\\n        char[] newChars = new char[len + len - 1];\\n        \\n        // originalIndex: the index we use to track in original num.\\n        int originalIndex = 0;\\n        \\n        // newIndex: the index we use to track in new formed string with operators.\\n        int newIndex = 0;\\n        \\n        int currentValue = 0;   // the current operand value.\\n        \\n        long targetL = target;  // avoid overflow.\\n        \\n        // The first operand is without operator before it.\\n        for (int i = 0; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            // using helper function formOperator to process the rest (recursion)\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, 0, currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // can only has single digit: 0 if value == 0, no need to calculate multiple digits.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // ......pre_preSum (+) preValue <operator> currentValue;\\n    // if (+) is (-), the preValue will be -preValue;\\n    // if <operator> is (*), then pre_presSum stays, first calculate preValue * currentValue;\\n    \\n    private void formOperator(List<String> result, char[] originalChars, char[] newChars, \\n                              int originalIndex, int newIndex, int len,\\n                              long pre_preSum, long preValue, long targetL)\\n    {\\n        // already reach to the end of the original chars.\\n        if (originalIndex == len)\\n        {\\n            if (pre_preSum + preValue == targetL)\\n            {\\n                result.add(new String(newChars, 0, newIndex));\\n            }\\n            \\n            return;\\n        }\\n        \\n        long currentValue = 0;\\n        int operatorIndex = newIndex++;\\n        \\n        for (int i = originalIndex; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            newChars[operatorIndex] = \\'+\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'-\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, -currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'*\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum, preValue * currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // no leading zeros(multiple digits).\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution\\n{\\n    public List<String> addOperators(String num, int target)\\n    {\\n        List<String> result = new ArrayList<>();\\n        if (target == Integer.MIN_VALUE) return result;\\n        \\n        // using char array to avoid more space consuming by string\\n        char[] originalChars = num.toCharArray();\\n        int len = num.length();\\n        \\n        // the maximum length of the new string with operators is 2 * len - 1(1 + 1 + 2)\\n        // add an operator in between each character\\n        char[] newChars = new char[len + len - 1];\\n        \\n        // originalIndex: the index we use to track in original num.\\n        int originalIndex = 0;\\n        \\n        // newIndex: the index we use to track in new formed string with operators.\\n        int newIndex = 0;\\n        \\n        int currentValue = 0;   // the current operand value.\\n        \\n        long targetL = target;  // avoid overflow.\\n        \\n        // The first operand is without operator before it.\\n        for (int i = 0; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            // using helper function formOperator to process the rest (recursion)\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, 0, currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // can only has single digit: 0 if value == 0, no need to calculate multiple digits.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // ......pre_preSum (+) preValue <operator> currentValue;\\n    // if (+) is (-), the preValue will be -preValue;\\n    // if <operator> is (*), then pre_presSum stays, first calculate preValue * currentValue;\\n    \\n    private void formOperator(List<String> result, char[] originalChars, char[] newChars, \\n                              int originalIndex, int newIndex, int len,\\n                              long pre_preSum, long preValue, long targetL)\\n    {\\n        // already reach to the end of the original chars.\\n        if (originalIndex == len)\\n        {\\n            if (pre_preSum + preValue == targetL)\\n            {\\n                result.add(new String(newChars, 0, newIndex));\\n            }\\n            \\n            return;\\n        }\\n        \\n        long currentValue = 0;\\n        int operatorIndex = newIndex++;\\n        \\n        for (int i = originalIndex; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            newChars[operatorIndex] = \\'+\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'-\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, -currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'*\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum, preValue * currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // no leading zeros(multiple digits).\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883703,
                "title": "c-dfs-solution-very-easy-to-understand-with-comment",
                "content": "Many thanks to this post, I was inspired and fully understand the process after thinking it through\\nhttps://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n\\n\\n\\n    \\n\\n    \\n    public class Solution {\\n    List<string> result;\\n    string s;\\n    int target;\\n\\t// inspired from this post https://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        result = new List<string>();\\n        this.s=num;\\n        this.target=target;\\n        \\n        dfs(0, string.Empty, 0, 0);\\n        return result;\\n    }\\n    \\n    public void dfs(int startIndex, string temp, long prev, long curResult)\\n    {\\n        if(startIndex == s.Length)\\n        {\\n            if(prev+curResult == target)\\n                result.Add(temp);  \\n            return;\\n        }\\n        \\n        // start from startIndex again for next number\\n        for(int i=startIndex; i < s.Length; i++)\\n        {\\n            // i+1 - startIndex was length from startIndex\\n            // get every substring from startIndex\\n            var cur = s.Substring(startIndex, i+1-startIndex);\\n            \\n            // leading 0\\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curNum = Int64.Parse(cur);\\n            \\n            if(startIndex == 0)\\n                dfs(i+1, cur, curNum, 0);\\n            else\\n            {\\n                // please refer to 227. Basic Calculator II\\'s optimal solution about defered calculation \\n                    //  \\'*\\')\\n                        dfs(i+1, temp + \"*\" + cur, prev*curNum, curResult);\\n                    // \\'+\\')\\n                        dfs(i+1, temp + \"+\" + cur, curNum,  curResult + prev);\\n                    // \\'-\\')\\n                        dfs(i+1, temp + \"-\" + cur, -curNum, curResult + prev);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    List<string> result;\\n    string s;\\n    int target;\\n\\t// inspired from this post https://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        result = new List<string>();\\n        this.s=num;\\n        this.target=target;\\n        \\n        dfs(0, string.Empty, 0, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1832360,
                "title": "c-learning-opportunities",
                "content": "March 8, 2022\\n**Introduction**\\nIt is a hard level algorithm. The tip is to learn how to handle multiplication and put it\\'s precedence before \"+\" and \"-\". \\n\\n**Case study I** \\nFor example, if you have a sequence of 12345 and you have proceeded to 1 + 2 + 3, now your eval is 6 right? If you want to add a * between 3 and 4, you would take 3 as the digit to be multiplied, so you want to take it out from the existing eval. You have 1 + 2 + 3 * 4 and the eval now is (1 + 2 + 3) - 3 + (3 * 4). \\n\\n**Case study II**\\nWe need to maintain the value of consecutive * result, if we want to do another * operation, just minus consecutive * result, and use that to multiply the new number.\\n\\nfor 1 + 2 * 3 if we want to *4, so it should 1 + 2 * 3 - 2 * 3 + 2 * 3  *  4\\n\\nThe following code uses the above idea to handle multiplication. Try to debug second test case and see if it is true to have -2 * 3, followed by 2 * 3 * 4. \\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _228_epxression_and_operator_B\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n            var result = test.AddOperators(\"123\", 6);\\n        }\\n\\n        public IList<string> AddOperators(string num, int target)\\n        {           \\n            if (num == null || num.Length == 0)\\n            {\\n                return new List<string>();\\n            }\\n\\n            var result = new List<string>();\\n\\n            runDFS(result, \"\", num, target, 0, 0, 0);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n        /// </summary>\\n        /// <param name=\"expressions\"></param>\\n        /// <param name=\"path\"></param>\\n        /// <param name=\"num\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <param name=\"pos\"></param>\\n        /// <param name=\"eval\"></param>\\n        /// <param name=\"multed\"></param>\\n        private void runDFS(List<string> expressions, string path, string num, int target, int pos, long eval, long multed)\\n        {\\n            if (pos == num.Length)\\n            {\\n                if (target == eval)\\n                {\\n                    expressions.Add(path);\\n                }\\n\\n                return;\\n            }\\n\\n            for (int i = pos; i < num.Length; i++)\\n            {\\n                if (i != pos && num[pos] == \\'0\\')\\n                {\\n                    break;\\n                }\\n\\n                long operand = Convert.ToInt64(num.Substring(pos, i - pos + 1));\\n\\n                if (pos == 0)\\n                {\\n                    runDFS(expressions, path + operand, num, target, i + 1, operand, operand);\\n                }\\n                else\\n                {\\n                    runDFS(expressions, path + \"+\" + operand, num, target, i + 1, eval + operand, operand);\\n                    runDFS(expressions, path + \"-\" + operand, num, target, i + 1, eval - operand, -operand);\\n                    runDFS(expressions, path + \"*\" + operand, num, target, i + 1, eval - multed + multed * operand, multed * operand);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _228_epxression_and_operator_B\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n            var result = test.AddOperators(\"123\", 6);\\n        }\\n\\n        public IList<string> AddOperators(string num, int target)\\n        {           \\n            if (num == null || num.Length == 0)\\n            {\\n                return new List<string>();\\n            }\\n\\n            var result = new List<string>();\\n\\n            runDFS(result, \"\", num, target, 0, 0, 0);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n        /// </summary>\\n        /// <param name=\"expressions\"></param>\\n        /// <param name=\"path\"></param>\\n        /// <param name=\"num\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <param name=\"pos\"></param>\\n        /// <param name=\"eval\"></param>\\n        /// <param name=\"multed\"></param>\\n        private void runDFS(List<string> expressions, string path, string num, int target, int pos, long eval, long multed)\\n        {\\n            if (pos == num.Length)\\n            {\\n                if (target == eval)\\n                {\\n                    expressions.Add(path);\\n                }\\n\\n                return;\\n            }\\n\\n            for (int i = pos; i < num.Length; i++)\\n            {\\n                if (i != pos && num[pos] == \\'0\\')\\n                {\\n                    break;\\n                }\\n\\n                long operand = Convert.ToInt64(num.Substring(pos, i - pos + 1));\\n\\n                if (pos == 0)\\n                {\\n                    runDFS(expressions, path + operand, num, target, i + 1, operand, operand);\\n                }\\n                else\\n                {\\n                    runDFS(expressions, path + \"+\" + operand, num, target, i + 1, eval + operand, operand);\\n                    runDFS(expressions, path + \"-\" + operand, num, target, i + 1, eval - operand, -operand);\\n                    runDFS(expressions, path + \"*\" + operand, num, target, i + 1, eval - multed + multed * operand, multed * operand);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724667,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        # required = is there a leading 0 to the current expression?\\n        def backtracking(solution, pos, num, target, expression, required):\\n            if pos == len(num):\\n                S = 0\\n                operators = []\\n                for c in expression:\\n                    if not c.isnumeric():\\n                        operators.append(c)\\n                \\n                if len(operators) == 0:\\n                    if target == int(expression):\\n                        solution.append(expression)\\n                else:\\n                    oldExp = expression\\n                    for o in \"*+-\":\\n                        expression = expression.replace(o, \" \")\\n                    \\n                    values = expression.split()\\n                    j = len(values) - 1\\n                    k = len(operators) - 1\\n                    while j > 0: # and k >= 0:\\n                        if operators[k] == \\'+\\':\\n                            S += int(values[j])\\n                        elif operators[k] == \\'-\\':\\n                            S -= int(values[j])\\n                        else:\\n                            P = int(values[j])\\n                            k -= 1\\n                            j -= 1\\n                            while j > 0 and operators[k] == \\'*\\': # and k >= 0 :\\n                                P *= int(values[j])\\n                                j -= 1\\n                                k -= 1\\n                            P *= int(values[j])\\n                            if j == 0:\\n                                S += P\\n                            else:\\n                                if operators[k] == \\'-\\':\\n                                    S -= P\\n                                else:\\n                                    S += P\\n                        j -= 1\\n                        k -= 1\\n                    if j == 0:\\n                        S += int(values[0])\\n                    if S == target:\\n                        solution.append(oldExp)\\n            else:\\n                r = False\\n                if num[pos] == \\'0\\':\\n                    r = True\\n                \\n                if required == False:\\n                    backtracking(solution, pos + 1, num, target, expression + num[pos], False)\\n                backtracking(solution, pos + 1, num, target, expression + \\'+\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'-\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'*\\' + num[pos], r)\\n                \\n        \\n        solution = []\\n        if num[0] == \\'0\\':\\n            backtracking(solution, 1, num, target, num[0], True)\\n        else:\\n            backtracking(solution, 1, num, target, num[0], False)\\n        \\n        return solution\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        # required = is there a leading 0 to the current expression?\\n        def backtracking(solution, pos, num, target, expression, required):\\n            if pos == len(num):\\n                S = 0\\n                operators = []\\n                for c in expression:\\n                    if not c.isnumeric():\\n                        operators.append(c)\\n                \\n                if len(operators) == 0:\\n                    if target == int(expression):\\n                        solution.append(expression)\\n                else:\\n                    oldExp = expression\\n                    for o in \"*+-\":\\n                        expression = expression.replace(o, \" \")\\n                    \\n                    values = expression.split()\\n                    j = len(values) - 1\\n                    k = len(operators) - 1\\n                    while j > 0: # and k >= 0:\\n                        if operators[k] == \\'+\\':\\n                            S += int(values[j])\\n                        elif operators[k] == \\'-\\':\\n                            S -= int(values[j])\\n                        else:\\n                            P = int(values[j])\\n                            k -= 1\\n                            j -= 1\\n                            while j > 0 and operators[k] == \\'*\\': # and k >= 0 :\\n                                P *= int(values[j])\\n                                j -= 1\\n                                k -= 1\\n                            P *= int(values[j])\\n                            if j == 0:\\n                                S += P\\n                            else:\\n                                if operators[k] == \\'-\\':\\n                                    S -= P\\n                                else:\\n                                    S += P\\n                        j -= 1\\n                        k -= 1\\n                    if j == 0:\\n                        S += int(values[0])\\n                    if S == target:\\n                        solution.append(oldExp)\\n            else:\\n                r = False\\n                if num[pos] == \\'0\\':\\n                    r = True\\n                \\n                if required == False:\\n                    backtracking(solution, pos + 1, num, target, expression + num[pos], False)\\n                backtracking(solution, pos + 1, num, target, expression + \\'+\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'-\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'*\\' + num[pos], r)\\n                \\n        \\n        solution = []\\n        if num[0] == \\'0\\':\\n            backtracking(solution, 1, num, target, num[0], True)\\n        else:\\n            backtracking(solution, 1, num, target, num[0], False)\\n        \\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714422,
                "title": "20-lines-ez-to-understand-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        self.add_helper(num, 0, \"\", 0, target, result, 0)\\n        return result\\n    \\n    def add_helper(self, num, cur_idx, candidate, value, target, result, last):\\n\\t    # add to result when proceeding the whole string and value equals to target\\n        if value == target and cur_idx == len(num):\\n            result.append(candidate)\\n            return\\n        \\n        # slice a number between current position to the end of string\\n        for i in range(cur_idx, len(num)):\\n            # if number is not a single digit 0 (0 at current index but have numbers in the following), just dont slice any more\\n            if num[cur_idx] == \"0\" and i != cur_idx:\\n                break\\n            cur_num = num[cur_idx : i + 1]\\n            \\n            # if it\\'s slicing number from beginning\\n            if cur_idx == 0:\\n                self.add_helper(num, i + 1, cur_num, value + int(cur_num), target, result, int(cur_num))\\n            else:\\n                # use last to record last number proceeded\\n                self.add_helper(num, i + 1, candidate + \"+\" + cur_num, value + int(cur_num), target, result, int(cur_num))\\n                self.add_helper(num, i + 1, candidate + \"-\" + cur_num, value - int(cur_num), target, result, -int(cur_num))                \\n                self.add_helper(num, i + 1, candidate + \"*\" + cur_num, value - last + last * int(cur_num), target, result, last * int(cur_num))\\n\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        self.add_helper(num, 0, \"\", 0, target, result, 0)\\n        return result\\n    \\n    def add_helper(self, num, cur_idx, candidate, value, target, result, last):\\n\\t    # add to result when proceeding the whole string and value equals to target\\n        if value == target and cur_idx == len(num):\\n            result.append(candidate)\\n            return\\n        \\n        # slice a number between current position to the end of string\\n        for i in range(cur_idx, len(num)):\\n            # if number is not a single digit 0 (0 at current index but have numbers in the following), just dont slice any more\\n            if num[cur_idx] == \"0\" and i != cur_idx:\\n                break\\n            cur_num = num[cur_idx : i + 1]\\n            \\n            # if it\\'s slicing number from beginning\\n            if cur_idx == 0:\\n                self.add_helper(num, i + 1, cur_num, value + int(cur_num), target, result, int(cur_num))\\n            else:\\n                # use last to record last number proceeded\\n                self.add_helper(num, i + 1, candidate + \"+\" + cur_num, value + int(cur_num), target, result, int(cur_num))\\n                self.add_helper(num, i + 1, candidate + \"-\" + cur_num, value - int(cur_num), target, result, -int(cur_num))                \\n                self.add_helper(num, i + 1, candidate + \"*\" + cur_num, value - last + last * int(cur_num), target, result, last * int(cur_num))\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688637,
                "title": "python3-naive-way-backtrack-with-eval",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        ans = []\\n        \\n        def backtrack(start, path):\\n            if len(path) == 1 and path == \"0\":\\n                return\\n            if len(path) >= 2 and path[-2:] in [\"+0\", \"-0\", \"*0\"]:\\n                return\\n            if start == len(num) - 1:\\n                if eval(path+num[-1]) == target:\\n                    ans.append(path+num[-1])\\n                return\\n            backtrack(start+1, path+num[start]+\"*\")\\n            backtrack(start+1, path+num[start]+\"+\")\\n            backtrack(start+1, path+num[start]+\"-\")\\n            backtrack(start+1, path+num[start])\\n\\n            \\n        backtrack(0, \"\")\\n        \\n        return ans\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        ans = []\\n        \\n        def backtrack(start, path):\\n            if len(path) == 1 and path == \"0\":\\n                return\\n            if len(path) >= 2 and path[-2:] in [\"+0\", \"-0\", \"*0\"]:\\n                return\\n            if start == len(num) - 1:\\n                if eval(path+num[-1]) == target:\\n                    ans.append(path+num[-1])\\n                return\\n            backtrack(start+1, path+num[start]+\"*\")\\n            backtrack(start+1, path+num[start]+\"+\")\\n            backtrack(start+1, path+num[start]+\"-\")\\n            backtrack(start+1, path+num[start])\\n\\n            \\n        backtrack(0, \"\")\\n        \\n        return ans\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685789,
                "title": "python-straightforward-w-explanation",
                "content": "This problem involves some basic recursion however the challenge arises from following order of operations. For instance, take the following expression: `4 + 2 * 5`. The way our program would calculate without following order of ops would be: `4 + 2 * 5 = 6 * 5 = 30` which is obviously wrong. \\n\\nWhat we need to do when we see a multiplication is reverse our previous operation and then do the multiplication. For instance, `4 + 2 * 5 => 6 * 5 => (6 - 2) + 2 * 5 = 14`. What we did is keep track of the previous number that would help us reverse the previous operation. When we subtract that number from the current result, we get the value of the previous expression and then we can simply add the product. \\n\\nIn the above example, at the multiplication step, the previous value was `2`. When `2` was subtracted from the current sum of `6`, we got our previous sum of `4` to which we could add `2 * 5`. If the expression to evaluate were instead `4 - 2 * 5`, we would store `-2` as our previous value as that would allow us to reverse the subtraction: `4 - 2 * 5 => 2 * 5 => (2 - -2) + -2 * 5 = -6`.\\n\\nIf the expression were `4 * 2 * 5`, we would just store the current number times the previous number: `4 * 2 * 5 = 8 * 5 = 40`.\\n\\nTo skip leading zeroes, we check if the first digit at the current index is a 0 and if so, we can stop after the first iteration of the loop.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        \\n        def recurse(curIdx=0, curExpr=[], curSum=0, prevNum=0):\\n            if curIdx >= len(num):\\n                if curSum == target:\\n                    res.append(\\'\\'.join(curExpr))\\n                return\\n            \\n            for i in range(curIdx, len(num)):\\n                curNum = int(num[curIdx:i+1])\\n                if not curExpr:\\n                    recurse(i + 1, [str(curNum)], curNum, curNum)\\n                else:\\n                    recurse(i + 1, [*curExpr, \\'+\\', str(curNum)], curSum + curNum, curNum)\\n                    recurse(i + 1, [*curExpr, \\'-\\', str(curNum)], curSum - curNum, -curNum)\\n                    \\n                    prevSum = curSum - prevNum\\n                    recurse(i + 1, [*curExpr, \\'*\\', str(curNum)], \\n                            prevSum + curNum * prevNum, curNum * prevNum)\\n                \\n                if num[curIdx] == \\'0\\':\\n                    break\\n        \\n        recurse()\\n        return res",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "This problem involves some basic recursion however the challenge arises from following order of operations. For instance, take the following expression: `4 + 2 * 5`. The way our program would calculate without following order of ops would be: `4 + 2 * 5 = 6 * 5 = 30` which is obviously wrong. \\n\\nWhat we need to do when we see a multiplication is reverse our previous operation and then do the multiplication. For instance, `4 + 2 * 5 => 6 * 5 => (6 - 2) + 2 * 5 = 14`. What we did is keep track of the previous number that would help us reverse the previous operation. When we subtract that number from the current result, we get the value of the previous expression and then we can simply add the product. \\n\\nIn the above example, at the multiplication step, the previous value was `2`. When `2` was subtracted from the current sum of `6`, we got our previous sum of `4` to which we could add `2 * 5`. If the expression to evaluate were instead `4 - 2 * 5`, we would store `-2` as our previous value as that would allow us to reverse the subtraction: `4 - 2 * 5 => 2 * 5 => (2 - -2) + -2 * 5 = -6`.\\n\\nIf the expression were `4 * 2 * 5`, we would just store the current number times the previous number: `4 * 2 * 5 = 8 * 5 = 40`.\\n\\nTo skip leading zeroes, we check if the first digit at the current index is a 0 and if so, we can stop after the first iteration of the loop.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        \\n        def recurse(curIdx=0, curExpr=[], curSum=0, prevNum=0):\\n            if curIdx >= len(num):\\n                if curSum == target:\\n                    res.append(\\'\\'.join(curExpr))\\n                return\\n            \\n            for i in range(curIdx, len(num)):\\n                curNum = int(num[curIdx:i+1])\\n                if not curExpr:\\n                    recurse(i + 1, [str(curNum)], curNum, curNum)\\n                else:\\n                    recurse(i + 1, [*curExpr, \\'+\\', str(curNum)], curSum + curNum, curNum)\\n                    recurse(i + 1, [*curExpr, \\'-\\', str(curNum)], curSum - curNum, -curNum)\\n                    \\n                    prevSum = curSum - prevNum\\n                    recurse(i + 1, [*curExpr, \\'*\\', str(curNum)], \\n                            prevSum + curNum * prevNum, curNum * prevNum)\\n                \\n                if num[curIdx] == \\'0\\':\\n                    break\\n        \\n        recurse()\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1621590,
                "title": "python-backtracking",
                "content": "* at every digit, we have an option of either adding it to the prev no, or use it with some operand\\n* in total we have 4 different operations which we have to accomplish, +, - , * and adding cur digit to prev digit\\n```\\n def addOperators(self, num: \\'str\\', target: \\'int\\') -> \\'List[str]\\':\\n        N = len(num)\\n        answers = []\\n        def recurse(idx, prev, cur, value, path):\\n            if idx == N:\\n                if value == target and cur == 0:\\n                    answers.append(\"\".join(path[1:]))\\n                return\\n            cur = cur*10 + int(num[idx])\\n            str_op = str(cur)\\n            if cur > 0:\\n\\t\\t\\t\\t# Add nothing to path, since added digit to cur\\n                recurse(idx + 1, prev, cur, value, path)\\n\\t\\t\\t# Perform addition \\n            recurse(idx + 1, cur, 0, value + cur, path +[\"+\", str_op])\\n\\t\\t\\t# can only perform subtraction, multiplication when our path not empty\\n            if path:\\n\\t\\t\\t\\t# Perform subtraction \\n                recurse(idx + 1, -cur, 0, value - cur, path +[\\'-\\', str_op])\\n\\t\\t\\t\\t# Perform multiplication\\n                recurse(idx + 1, cur * prev, 0, value - prev + (cur * prev), path +[\\'*\\', str_op])\\n                \\n        recurse(0, 0, 0, 0, [])    \\n        return answers\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n def addOperators(self, num: \\'str\\', target: \\'int\\') -> \\'List[str]\\':\\n        N = len(num)\\n        answers = []\\n        def recurse(idx, prev, cur, value, path):\\n            if idx == N:\\n                if value == target and cur == 0:\\n                    answers.append(\"\".join(path[1:]))\\n                return\\n            cur = cur*10 + int(num[idx])\\n            str_op = str(cur)\\n            if cur > 0:\\n\\t\\t\\t\\t# Add nothing to path, since added digit to cur\\n                recurse(idx + 1, prev, cur, value, path)\\n\\t\\t\\t# Perform addition \\n            recurse(idx + 1, cur, 0, value + cur, path +[\"+\", str_op])\\n\\t\\t\\t# can only perform subtraction, multiplication when our path not empty\\n            if path:\\n\\t\\t\\t\\t# Perform subtraction \\n                recurse(idx + 1, -cur, 0, value - cur, path +[\\'-\\', str_op])\\n\\t\\t\\t\\t# Perform multiplication\\n                recurse(idx + 1, cur * prev, 0, value - prev + (cur * prev), path +[\\'*\\', str_op])\\n                \\n        recurse(0, 0, 0, 0, [])    \\n        return answers\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1611458,
                "title": "javascript-clean-concise-code-backtracking",
                "content": "```\\nvar addOperators = function(num, target) {\\n    let ans = [];\\n    \\n    const backtracking = (index, left, right, string) => {\\n        if (index === num.length) {\\n            if (left + right === target)\\n                ans.push(string); \\n            return;\\n        }\\n\\n        let val = 0;\\n        for (let i = index; i < num.length; i++) {\\n            val = val * 10 + Number(num[i]);\\n            backtracking(i + 1, left + right, val, string + \"+\" + val);\\n            backtracking(i + 1, left + right, -val, string + \"-\" + val);\\n            backtracking(i + 1, left, right * val, string + \"*\" + val);\\n            if (num[index] === \"0\")\\n                break;\\n        }  \\n    };\\n\\n    let val = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        val = val * 10 + Number(num[i]);\\n        backtracking(i + 1, 0, val, val.toString());\\n        if (num[0] === \"0\")\\n            break;\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar addOperators = function(num, target) {\\n    let ans = [];\\n    \\n    const backtracking = (index, left, right, string) => {\\n        if (index === num.length) {\\n            if (left + right === target)\\n                ans.push(string); \\n            return;\\n        }\\n\\n        let val = 0;\\n        for (let i = index; i < num.length; i++) {\\n            val = val * 10 + Number(num[i]);\\n            backtracking(i + 1, left + right, val, string + \"+\" + val);\\n            backtracking(i + 1, left + right, -val, string + \"-\" + val);\\n            backtracking(i + 1, left, right * val, string + \"*\" + val);\\n            if (num[index] === \"0\")\\n                break;\\n        }  \\n    };\\n\\n    let val = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        val = val * 10 + Number(num[i]);\\n        backtracking(i + 1, 0, val, val.toString());\\n        if (num[0] === \"0\")\\n            break;\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596238,
                "title": "clean-commented-dfs-python-beats-98-time-78-memory",
                "content": "# Initially\\n0th index, prev is 0, val is 0 and expression string is empty\\nAt each step:-\\n## Addition\\ncur become prev, \\nadd cur to sum, \\nadd info to expression\\n## Subtraction\\n-cur become prev,\\nsubtract cur from sum,\\nadd info to expression \\n## Multiplication\\ncur\\\\*prev becomes prev,\\nsubtract prev from sum(to undo what was done by adding prev) & add cur*prev,\\nadd info to expression \\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        \\n        def dfs(start,prev_operand,expr_val,expr_str):\\n            if start==n:\\n                if expr_val==target:\\n                    ans.append(expr_str[1:]) # remove + sign at start\\n                return\\n            \\n            # To handle leading zeros condition\\n            endPtr = n+1 if num[start]!=\\'0\\' else start+2\\n            \\n            for end in range(start+1,endPtr):\\n                cur_operand_str = num[start:end]\\n                cur_operand = int(cur_operand_str)\\n                dfs(end,cur_operand,expr_val+cur_operand,expr_str+\\'+\\'+cur_operand_str) # addition\\n                if expr_str: # sub & mult only possible if previous operand\\n                    dfs(end,-cur_operand,expr_val-cur_operand,expr_str+\\'-\\'+cur_operand_str) # subtraction\\n                    product = cur_operand*prev_operand\\n                    dfs(end,product,expr_val-prev_operand+product, expr_str+\\'*\\'+cur_operand_str) # multiplication\\n        \\n        dfs(0,0,0,\\'\\' )\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        \\n        def dfs(start,prev_operand,expr_val,expr_str):\\n            if start==n:\\n                if expr_val==target:\\n                    ans.append(expr_str[1:]) # remove + sign at start\\n                return\\n            \\n            # To handle leading zeros condition\\n            endPtr = n+1 if num[start]!=\\'0\\' else start+2\\n            \\n            for end in range(start+1,endPtr):\\n                cur_operand_str = num[start:end]\\n                cur_operand = int(cur_operand_str)\\n                dfs(end,cur_operand,expr_val+cur_operand,expr_str+\\'+\\'+cur_operand_str) # addition\\n                if expr_str: # sub & mult only possible if previous operand\\n                    dfs(end,-cur_operand,expr_val-cur_operand,expr_str+\\'-\\'+cur_operand_str) # subtraction\\n                    product = cur_operand*prev_operand\\n                    dfs(end,product,expr_val-prev_operand+product, expr_str+\\'*\\'+cur_operand_str) # multiplication\\n        \\n        dfs(0,0,0,\\'\\' )\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579560,
                "title": "simple-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &ans,string currstr,string input,int t,int pos,long long currval,long long last)\\n    {\\n        if(pos==input.length())\\n        {\\n            if(currval==t)\\n                ans.push_back(currstr);\\n            return;\\n        }\\n        for(int i=pos;i<input.length();i++)\\n        {\\n            if(pos!=i && input[pos]==\\'0\\')\\n                break;\\n            string part=input.substr(pos,i+1-pos);\\n            long long curr=stoll(part);\\n            if(pos==0)\\n            {\\n                solve(ans,currstr+part,input,t,i+1,curr,curr);\\n            }\\n            else\\n            {\\n                solve(ans,currstr+\"+\"+part,input,t,i+1,currval+curr,curr);\\n                solve(ans,currstr+\"-\"+part,input,t,i+1,currval-curr,-curr);\\n                solve(ans,currstr+\"*\"+part,input,t,i+1,currval-last+last*curr,last*curr);\\n            }\\n        }\\n    }\\n    vector<string> addOperators(string num, int t) {\\n        vector<string> ans;\\n        solve(ans,\"\",num,t,0,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &ans,string currstr,string input,int t,int pos,long long currval,long long last)\\n    {\\n        if(pos==input.length())\\n        {\\n            if(currval==t)\\n                ans.push_back(currstr);\\n            return;\\n        }\\n        for(int i=pos;i<input.length();i++)\\n        {\\n            if(pos!=i && input[pos]==\\'0\\')\\n                break;\\n            string part=input.substr(pos,i+1-pos);\\n            long long curr=stoll(part);\\n            if(pos==0)\\n            {\\n                solve(ans,currstr+part,input,t,i+1,curr,curr);\\n            }\\n            else\\n            {\\n                solve(ans,currstr+\"+\"+part,input,t,i+1,currval+curr,curr);\\n                solve(ans,currstr+\"-\"+part,input,t,i+1,currval-curr,-curr);\\n                solve(ans,currstr+\"*\"+part,input,t,i+1,currval-last+last*curr,last*curr);\\n            }\\n        }\\n    }\\n    vector<string> addOperators(string num, int t) {\\n        vector<string> ans;\\n        solve(ans,\"\",num,t,0,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553905,
                "title": "c-dfs-easy-to-understand",
                "content": "Got the idea for calculating the value on the fly from \\nhttps://leetcode.com/problems/expression-add-operators/discuss/441680/Accepted-C-backtracking-solution%3A-Easy-to-understand-w-comments-fast-93.14-memory-100\\n\\n```\\npublic class Solution \\n{\\n    List<char> ops;\\n    IList<string> lst;\\n    \\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        ops = new List<char>();\\n        lst = new List<string>();\\n        ops.Add(\\'+\\');\\n        ops.Add(\\'-\\');\\n        ops.Add(\\'*\\');\\n        dfs(num, 0, \"\", 0, 0, target);\\n        return lst;\\n    }\\n    \\n    public void dfs(string s, int index, string calc, long prev, long sofar, int target)\\n    {\\n        if(index == s.Length)\\n        {\\n            if(sofar == target)\\n                lst.Add(calc);\\n            \\n            return;\\n        }\\n        \\n        int count = 1;\\n        for(int i = index; i < s.Length; i++)\\n        {\\n            var nextindex = index + count;\\n            var cur = s.Substring(index, count);\\n            \\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curnum = Convert.ToInt64(cur);\\n            \\n            if(index == 0)\\n            {\\n                dfs(s, nextindex, cur, curnum, curnum, target);\\n            }\\n            else\\n            {\\n                foreach(var op in ops)\\n                {\\n                    if(op == \\'*\\')\\n                        dfs(s, nextindex, calc + \"*\" + cur, curnum*prev, ((sofar - prev) + prev * curnum), target);\\n                    else if(op == \\'+\\')\\n                        dfs(s, nextindex, calc + \"+\" + cur, curnum, sofar + curnum, target);\\n                    else if(op == \\'-\\')\\n                        dfs(s, nextindex, calc + \"-\" + cur, -curnum, sofar - curnum, target);\\n                } \\n            }\\n            \\n            count++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    List<char> ops;\\n    IList<string> lst;\\n    \\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        ops = new List<char>();\\n        lst = new List<string>();\\n        ops.Add(\\'+\\');\\n        ops.Add(\\'-\\');\\n        ops.Add(\\'*\\');\\n        dfs(num, 0, \"\", 0, 0, target);\\n        return lst;\\n    }\\n    \\n    public void dfs(string s, int index, string calc, long prev, long sofar, int target)\\n    {\\n        if(index == s.Length)\\n        {\\n            if(sofar == target)\\n                lst.Add(calc);\\n            \\n            return;\\n        }\\n        \\n        int count = 1;\\n        for(int i = index; i < s.Length; i++)\\n        {\\n            var nextindex = index + count;\\n            var cur = s.Substring(index, count);\\n            \\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curnum = Convert.ToInt64(cur);\\n            \\n            if(index == 0)\\n            {\\n                dfs(s, nextindex, cur, curnum, curnum, target);\\n            }\\n            else\\n            {\\n                foreach(var op in ops)\\n                {\\n                    if(op == \\'*\\')\\n                        dfs(s, nextindex, calc + \"*\" + cur, curnum*prev, ((sofar - prev) + prev * curnum), target);\\n                    else if(op == \\'+\\')\\n                        dfs(s, nextindex, calc + \"+\" + cur, curnum, sofar + curnum, target);\\n                    else if(op == \\'-\\')\\n                        dfs(s, nextindex, calc + \"-\" + cur, -curnum, sofar - curnum, target);\\n                } \\n            }\\n            \\n            count++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539532,
                "title": "python-using-eval",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n    \\n        def backtrack(index,stack):\\n            \\n            if index == len(num)-1:\\n                stack.append(num[index])\\n                expres = \"\".join(stack[:])\\n                if eval(expres) == target:\\n                    out.append(expres)\\n                return\\n            \\n            leadZero = False\\n            \\n            if not (stack and stack[-1].isdigit()) and num[index] == \\'0\\':\\n                \\n                leadZero = True\\n                \\n            stack.append(num[index])\\n            \\n            for op in [\"+\",\"-\",\"*\"]:\\n                stack.append(op)  \\n                backtrack(index+1,stack[:])\\n                stack.pop()\\n            \\n            if not leadZero:\\n                \\n                backtrack(index+1,stack[:])\\n        \\n        out = []\\n        \\n        backtrack(0,[])\\n        \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n    \\n        def backtrack(index,stack):\\n            \\n            if index == len(num)-1:\\n                stack.append(num[index])\\n                expres = \"\".join(stack[:])\\n                if eval(expres) == target:\\n                    out.append(expres)\\n                return\\n            \\n            leadZero = False\\n            \\n            if not (stack and stack[-1].isdigit()) and num[index] == \\'0\\':\\n                \\n                leadZero = True\\n                \\n            stack.append(num[index])\\n            \\n            for op in [\"+\",\"-\",\"*\"]:\\n                stack.append(op)  \\n                backtrack(index+1,stack[:])\\n                stack.pop()\\n            \\n            if not leadZero:\\n                \\n                backtrack(index+1,stack[:])\\n        \\n        out = []\\n        \\n        backtrack(0,[])\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498795,
                "title": "js-simple-dfs",
                "content": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    \\n    const dfs = (pos, exp, result, prevNum) => {\\n        \\n        if(pos >= num.length) {\\n            if (result == target) {\\n                res.push(exp);\\n            }\\n            return;\\n        }\\n        for(let i=pos;i<num.length;i++) {\\n            if (i > pos &&  num[pos] == \\'0\\') break;\\n            const n = parseInt(num.substring(pos, i+1));\\n            if (pos == 0) {\\n                dfs(i+1, n+\"\", n, n);\\n            } else {\\n                dfs(i+1, exp+\\'+\\'+n, result+n, n);\\n                dfs(i+1, exp+\\'-\\'+n, result-n, -n);\\n                dfs(i+1, exp+\\'*\\'+n, result-prevNum+prevNum *n  , prevNum * n);\\n                \\n            }\\n        }\\n    }\\n    \\n    dfs(0, \\'\\', 0, 0);\\n       \\n    return res;\\n      \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    \\n    const dfs = (pos, exp, result, prevNum) => {\\n        \\n        if(pos >= num.length) {\\n            if (result == target) {\\n                res.push(exp);\\n            }\\n            return;\\n        }\\n        for(let i=pos;i<num.length;i++) {\\n            if (i > pos &&  num[pos] == \\'0\\') break;\\n            const n = parseInt(num.substring(pos, i+1));\\n            if (pos == 0) {\\n                dfs(i+1, n+\"\", n, n);\\n            } else {\\n                dfs(i+1, exp+\\'+\\'+n, result+n, n);\\n                dfs(i+1, exp+\\'-\\'+n, result-n, -n);\\n                dfs(i+1, exp+\\'*\\'+n, result-prevNum+prevNum *n  , prevNum * n);\\n                \\n            }\\n        }\\n    }\\n    \\n    dfs(0, \\'\\', 0, 0);\\n       \\n    return res;\\n      \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479596,
                "title": "javascript-dfs-116ms-89-74",
                "content": "```\\nlet s, n, t;\\nconst addOperators = (num, target) => {\\n    s = num, n = s.length, t = target;\\n    let res = [];\\n    dfs(0, \\'\\', 0, 0, res);\\n    return res;\\n};\\n\\nconst dfs = (pos, exp, pre, cur, res) => {\\n    if (pos == n) {\\n        if (cur == t) return res.push(exp);\\n    }\\n    for (let i = 1; i <= n - pos; i++) {\\n        let tmp = s.substr(pos, i);\\n        if (tmp[0] == \\'0\\' && tmp.length > 1) break;\\n        let x = tmp - \\'0\\';\\n        if (pos == 0) {\\n            dfs(i, tmp, x, x, res);\\n            continue;\\n        }\\n        dfs(pos + i, exp + \\'+\\' + tmp, x, cur + x, res);\\n        dfs(pos + i, exp + \\'-\\' + tmp, -x, cur - x, res);\\n        dfs(pos + i, exp + \\'*\\' + tmp, pre * x, cur - pre + pre * x, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet s, n, t;\\nconst addOperators = (num, target) => {\\n    s = num, n = s.length, t = target;\\n    let res = [];\\n    dfs(0, \\'\\', 0, 0, res);\\n    return res;\\n};\\n\\nconst dfs = (pos, exp, pre, cur, res) => {\\n    if (pos == n) {\\n        if (cur == t) return res.push(exp);\\n    }\\n    for (let i = 1; i <= n - pos; i++) {\\n        let tmp = s.substr(pos, i);\\n        if (tmp[0] == \\'0\\' && tmp.length > 1) break;\\n        let x = tmp - \\'0\\';\\n        if (pos == 0) {\\n            dfs(i, tmp, x, x, res);\\n            continue;\\n        }\\n        dfs(pos + i, exp + \\'+\\' + tmp, x, cur + x, res);\\n        dfs(pos + i, exp + \\'-\\' + tmp, -x, cur - x, res);\\n        dfs(pos + i, exp + \\'*\\' + tmp, pre * x, cur - pre + pre * x, res);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479092,
                "title": "python-iterative-solution-beats-96",
                "content": "There are plenty of recursive solutions, but I found an iterative approach to be quite intuitive as well.\\n\\n1. Iterate over each digit\\n2. Maintain a list of all possible states from the previous digit\\n3. Create a list of all possible states after using this digit\\n\\t4. Concatenate the digits together (\"...12\")\\n\\t5. Addition (\"...1+2\")\\n\\t6. Subtraction (\"...1-2\")\\n\\t7. Multiplication (\"...1*2)\\n\\nOur state has 4 components\\n\\n1. Digits since the last operation (123 in \"9-99+123...\" or -123 in \"9-99-123...\")\\n2. Multiplier since the last +/- (value 6 in \"9-99+1\\\\*2\\\\*3...\")\\n3. Sum up to the previous +/- (value -90 in \"9-99+1\\\\*2\\\\*3...\")\\n4. String representation (\"9-99+123\")\\n\\nFor some reason this solution exceeds the time limit with C++, but beats 96% with Python. I guess recursion is just that inefficient with Python?\\n\\n```py\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        # digits since last +/-/*, multiplier, sum up to previous +/-, string representation\\n        states = [(int(num[0]), 1, 0, num[0])]\\n        \\n        for d in num[1:]:\\n            d = int(d)\\n            next_states = []\\n            \\n            for last_digits, multiplier, sum_before, s in states:\\n                # concatenate with last_digits\\n                if last_digits > 0:\\n                    next_states.append((last_digits*10+d, multiplier, sum_before, f\"{s}{d}\"))\\n                elif last_digits < 0:\\n                    next_states.append((last_digits*10-d, multiplier, sum_before, f\"{s}{d}\"))\\n\\t\\t\\t\\t# ignore 0 to avoid leading zeros\\n                    \\n                # addition sign\\n                next_states.append((d, 1, sum_before+last_digits*multiplier, f\"{s}+{d}\"))\\n                # subtraction sign\\n                next_states.append((-d, 1, sum_before+last_digits*multiplier, f\"{s}-{d}\"))\\n                # multiplication sign\\n                next_states.append((d, last_digits*multiplier, sum_before, f\"{s}*{d}\"))\\n                \\n            states = next_states\\n\\n        result = []\\n        for last_digits, multiplier, sum_before, s in states:\\n            val = sum_before + multiplier * last_digits\\n            if val == target:\\n                result.append(s)\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        # digits since last +/-/*, multiplier, sum up to previous +/-, string representation\\n        states = [(int(num[0]), 1, 0, num[0])]\\n        \\n        for d in num[1:]:\\n            d = int(d)\\n            next_states = []\\n            \\n            for last_digits, multiplier, sum_before, s in states:\\n                # concatenate with last_digits\\n                if last_digits > 0:\\n                    next_states.append((last_digits*10+d, multiplier, sum_before, f\"{s}{d}\"))\\n                elif last_digits < 0:\\n                    next_states.append((last_digits*10-d, multiplier, sum_before, f\"{s}{d}\"))\\n\\t\\t\\t\\t# ignore 0 to avoid leading zeros\\n                    \\n                # addition sign\\n                next_states.append((d, 1, sum_before+last_digits*multiplier, f\"{s}+{d}\"))\\n                # subtraction sign\\n                next_states.append((-d, 1, sum_before+last_digits*multiplier, f\"{s}-{d}\"))\\n                # multiplication sign\\n                next_states.append((d, last_digits*multiplier, sum_before, f\"{s}*{d}\"))\\n                \\n            states = next_states\\n\\n        result = []\\n        for last_digits, multiplier, sum_before, s in states:\\n            val = sum_before + multiplier * last_digits\\n            if val == target:\\n                result.append(s)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475043,
                "title": "c-282-expression-add-operators",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        int n = num.size(); \\n        vector<string> ans; \\n        \\n        function<void(int, long, long, string)> fn = [&](int i, long total, long last, string expr) {\\n            if (i == n) {\\n                if (total == target) ans.push_back(expr); \\n            } else {\\n                for (int ii = i; ii < (num[i] == \\'0\\' ? i+1 : n); ++ii) {\\n                    string ss = num.substr(i, ii-i+1); \\n                    long val = stol(ss); \\n                    if (i == 0) fn(ii+1, val, val, ss); \\n                    else {\\n                        fn(ii+1, total - last + last * val, last * val, expr + \"*\" + ss); \\n                        fn(ii+1, total + val, val, expr + \"+\" + ss); \\n                        fn(ii+1, total - val, -val, expr + \"-\" + ss); \\n                    }\\n                }\\n            }\\n        }; \\n        \\n        fn(0, 0, 0, \"\"); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        int n = num.size(); \\n        vector<string> ans; \\n        \\n        function<void(int, long, long, string)> fn = [&](int i, long total, long last, string expr) {\\n            if (i == n) {\\n                if (total == target) ans.push_back(expr); \\n            } else {\\n                for (int ii = i; ii < (num[i] == \\'0\\' ? i+1 : n); ++ii) {\\n                    string ss = num.substr(i, ii-i+1); \\n                    long val = stol(ss); \\n                    if (i == 0) fn(ii+1, val, val, ss); \\n                    else {\\n                        fn(ii+1, total - last + last * val, last * val, expr + \"*\" + ss); \\n                        fn(ii+1, total + val, val, expr + \"+\" + ss); \\n                        fn(ii+1, total - val, -val, expr + \"-\" + ss); \\n                    }\\n                }\\n            }\\n        }; \\n        \\n        fn(0, 0, 0, \"\"); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474313,
                "title": "python3-recursion",
                "content": "```\\nclass Solution:\\n    \\n    def solve(self, i, cur):\\n        if i == self.n:\\n            if eval(cur) == self.v:\\n                self.ans.append(cur)\\n            return\\n        if self.s[i] == \\'0\\':    # No leading zeros\\n            if i == self.n-1:\\n                self.solve(i+1, cur + \"0\")\\n            else:\\n                self.solve(i+1, cur + \"0*\")\\n                self.solve(i+1, cur + \"0+\")\\n                self.solve(i+1, cur + \"0-\")\\n            return\\n        s = \"\"\\n        for j in range(i, self.n - 1):\\n            s += self.s[j]\\n            self.solve(j+1, cur + s + \"*\")\\n            self.solve(j+1, cur + s + \"+\")\\n            self.solve(j+1, cur + s + \"-\")\\n        if self.s[i] != \\'0\\':\\n            self.solve(self.n, cur + self.s[i:])\\n        \\n    def addOperators(self, s: str, v: int) -> List[str]:\\n        self.v = v\\n        self.s = s\\n        self.n = len(s)\\n        self.ans = []\\n        self.solve(0, \"\")\\n        # print(self.ans)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def solve(self, i, cur):\\n        if i == self.n:\\n            if eval(cur) == self.v:\\n                self.ans.append(cur)\\n            return\\n        if self.s[i] == \\'0\\':    # No leading zeros\\n            if i == self.n-1:\\n                self.solve(i+1, cur + \"0\")\\n            else:\\n                self.solve(i+1, cur + \"0*\")\\n                self.solve(i+1, cur + \"0+\")\\n                self.solve(i+1, cur + \"0-\")\\n            return\\n        s = \"\"\\n        for j in range(i, self.n - 1):\\n            s += self.s[j]\\n            self.solve(j+1, cur + s + \"*\")\\n            self.solve(j+1, cur + s + \"+\")\\n            self.solve(j+1, cur + s + \"-\")\\n        if self.s[i] != \\'0\\':\\n            self.solve(self.n, cur + self.s[i:])\\n        \\n    def addOperators(self, s: str, v: int) -> List[str]:\\n        self.v = v\\n        self.s = s\\n        self.n = len(s)\\n        self.ans = []\\n        self.solve(0, \"\")\\n        # print(self.ans)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473865,
                "title": "java-easy-to-understand-solution-with-comments",
                "content": "Tried to explain all the cases and situations, let me know if anything is unclear or wrong. Hope it helps! :) \\n\\n```\\nclass Solution {\\n    String num;\\n    int len;\\n    List<String> ans;\\n    int target;\\n    \\n    public void dfs_helper(String build, long prev_no, long total, int pos){\\n        if(pos == len)\\n        {\\n            if(total == target)\\n                ans.add(build);\\n            return;\\n        }\\n        for(int i = pos;i<len;i++)\\n        {\\n            if(i>pos && num.charAt(pos) == \\'0\\')\\n                break; // needed to avoid cases like 00* (leading 0\\'s)\\n            // if you dont do this lets take an example\\n            // 105\\n            // 1 is added, string build = 1 and then we are at 0, i.e, pos == 1\\n            // if we go to i = 2 for pos and implement without this\\n            // we will get 1*5 as an answer which is wrong, as curr_num will be parsed as 5!\\n            // \"05\" will be 5!\\n            long curr_num = Long.parseLong(num.substring(pos,i+1)); // get the number\\n            if(pos == 0)\\n            {\\n                // have to add the 1st number to start the recursion.\\n                String to_send = build+curr_num;\\n                dfs_helper(to_send,curr_num,curr_num,i+1);\\n            }\\n            else\\n            {\\n                String to_send = build+\"+\"+curr_num;\\n                long t = total+curr_num;\\n                dfs_helper(to_send,curr_num,t,i+1);\\n                \\n                to_send = build+\"-\"+curr_num;\\n                t = total-curr_num;\\n                dfs_helper(to_send,(-1)*curr_num,t,i+1);\\n                // add and subtract are simple cases\\n                to_send = build+\"*\"+curr_num;\\n                t = total-prev_no+prev_no*curr_num;\\n                dfs_helper(to_send,curr_num*prev_no,t,i+1);\\n                // this is a tricky one lets say you have 1+2*3-5\\n                // if you do 2*3 then effective current number is 6 (consider it as 6 and pass it on)\\n                // to calculate the value now (total val) undo the effect of previous op by total-prev_no\\n                // and add the new evaluated val [prev_no*curr_num]\\n            }\\n        }\\n    }\\n    \\n    public List<String> addOperators(String num, int target) {\\n        /**\\n        Inputs that are req. for rec fn:\\n        a) string so far: 1+2*3\\n        b) prev number: 1+2*3 ==> prev number for next call from 3 will be 3\\n        c) value till that point: 1+2*3 ==> val till that point will be 7 [long]\\n        d) return list which will have the final output [make this global]\\n        e) postion pointer\\n        f) target to compare [make this global]\\n        g) length of total num string [make this global]\\n        h) the num string [make this global]\\n        */\\n        this.ans = new ArrayList<> ();\\n        this.len = num.length();\\n        this.target = target;\\n        this.num = num;\\n        dfs_helper(\"\",0,0,0);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String num;\\n    int len;\\n    List<String> ans;\\n    int target;\\n    \\n    public void dfs_helper(String build, long prev_no, long total, int pos){\\n        if(pos == len)\\n        {\\n            if(total == target)\\n                ans.add(build);\\n            return;\\n        }\\n        for(int i = pos;i<len;i++)\\n        {\\n            if(i>pos && num.charAt(pos) == \\'0\\')\\n                break; // needed to avoid cases like 00* (leading 0\\'s)\\n            // if you dont do this lets take an example\\n            // 105\\n            // 1 is added, string build = 1 and then we are at 0, i.e, pos == 1\\n            // if we go to i = 2 for pos and implement without this\\n            // we will get 1*5 as an answer which is wrong, as curr_num will be parsed as 5!\\n            // \"05\" will be 5!\\n            long curr_num = Long.parseLong(num.substring(pos,i+1)); // get the number\\n            if(pos == 0)\\n            {\\n                // have to add the 1st number to start the recursion.\\n                String to_send = build+curr_num;\\n                dfs_helper(to_send,curr_num,curr_num,i+1);\\n            }\\n            else\\n            {\\n                String to_send = build+\"+\"+curr_num;\\n                long t = total+curr_num;\\n                dfs_helper(to_send,curr_num,t,i+1);\\n                \\n                to_send = build+\"-\"+curr_num;\\n                t = total-curr_num;\\n                dfs_helper(to_send,(-1)*curr_num,t,i+1);\\n                // add and subtract are simple cases\\n                to_send = build+\"*\"+curr_num;\\n                t = total-prev_no+prev_no*curr_num;\\n                dfs_helper(to_send,curr_num*prev_no,t,i+1);\\n                // this is a tricky one lets say you have 1+2*3-5\\n                // if you do 2*3 then effective current number is 6 (consider it as 6 and pass it on)\\n                // to calculate the value now (total val) undo the effect of previous op by total-prev_no\\n                // and add the new evaluated val [prev_no*curr_num]\\n            }\\n        }\\n    }\\n    \\n    public List<String> addOperators(String num, int target) {\\n        /**\\n        Inputs that are req. for rec fn:\\n        a) string so far: 1+2*3\\n        b) prev number: 1+2*3 ==> prev number for next call from 3 will be 3\\n        c) value till that point: 1+2*3 ==> val till that point will be 7 [long]\\n        d) return list which will have the final output [make this global]\\n        e) postion pointer\\n        f) target to compare [make this global]\\n        g) length of total num string [make this global]\\n        h) the num string [make this global]\\n        */\\n        this.ans = new ArrayList<> ();\\n        this.len = num.length();\\n        this.target = target;\\n        this.num = num;\\n        dfs_helper(\"\",0,0,0);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472505,
                "title": "easy-to-understand",
                "content": "If the operands were only single digits then it would be so much easier!\\n*But they aren\\'t*\\nOkay, then what if we already knew what the operands would be? Then we would only have to check for the 3 possible operators between every 2 operands which would be 3^(number of operands-1)\\n*How to get these pre-decided operands then..*\\nBit-Manipulation to the rescue:-\\n\\tWe only have to divide num into all possible operands and for each of these divisions check all the possible expressions it makes.\\n```\\nFinding all possible operand divisions from num and store them in a list -> 2^(length of num-1){\\n\\tchecking all the expressions these operands make -> 3^(size of the list of operands-1)\\n}\\nI dont know how to find the exact complexity but it would be something like ->\\n2^(length(num)-1) * 3^(m) where m ranges from [0,length(num)-1]\\n```\\n\\nJava Implementation : \\n```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        int n = num.length()-1;\\n        t = target;\\n        list = new ArrayList<>();\\n        outer : for(int i=0;i<(1<<n);i++){\\n            List<Long> arr = new ArrayList<>();\\n            long cur = num.charAt(0)-\\'0\\';\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    arr.add(cur);\\n                    cur = num.charAt(j+1)-\\'0\\';\\n                }   \\n                else{\\n                    if(cur==0) continue outer;\\n                    cur = cur*10 + (num.charAt(j+1)-\\'0\\');\\n                }\\n            }\\n            arr.add(cur);\\n            rec(arr.get(0),1,arr.get(0),arr.size(),\"\"+arr.get(0),0,arr);\\n        }\\n        return list;\\n    }\\n    \\n    public void rec(long eval, int i, long prev, int n, String exp, int type, List<Long> num){\\n        if(i==n){\\n            if(eval==t) list.add(exp);\\n            return;\\n        }\\n        long cur = num.get(i);\\n        rec(eval+cur,i+1,cur,n,exp+(\"+\"+cur),0,num);\\n        rec(eval-cur,i+1,cur,n,exp+(\"-\"+cur),1,num);\\n        if(type==0) rec(eval-prev+prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),0,num);\\n        else rec(eval+prev-prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),1,num); \\n    }\\n    \\n    public List<String> list;\\n    public int t;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFinding all possible operand divisions from num and store them in a list -> 2^(length of num-1){\\n\\tchecking all the expressions these operands make -> 3^(size of the list of operands-1)\\n}\\nI dont know how to find the exact complexity but it would be something like ->\\n2^(length(num)-1) * 3^(m) where m ranges from [0,length(num)-1]\\n```\n```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        int n = num.length()-1;\\n        t = target;\\n        list = new ArrayList<>();\\n        outer : for(int i=0;i<(1<<n);i++){\\n            List<Long> arr = new ArrayList<>();\\n            long cur = num.charAt(0)-\\'0\\';\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    arr.add(cur);\\n                    cur = num.charAt(j+1)-\\'0\\';\\n                }   \\n                else{\\n                    if(cur==0) continue outer;\\n                    cur = cur*10 + (num.charAt(j+1)-\\'0\\');\\n                }\\n            }\\n            arr.add(cur);\\n            rec(arr.get(0),1,arr.get(0),arr.size(),\"\"+arr.get(0),0,arr);\\n        }\\n        return list;\\n    }\\n    \\n    public void rec(long eval, int i, long prev, int n, String exp, int type, List<Long> num){\\n        if(i==n){\\n            if(eval==t) list.add(exp);\\n            return;\\n        }\\n        long cur = num.get(i);\\n        rec(eval+cur,i+1,cur,n,exp+(\"+\"+cur),0,num);\\n        rec(eval-cur,i+1,cur,n,exp+(\"-\"+cur),1,num);\\n        if(type==0) rec(eval-prev+prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),0,num);\\n        else rec(eval+prev-prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),1,num); \\n    }\\n    \\n    public List<String> list;\\n    public int t;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472173,
                "title": "c-dfs-backtracking",
                "content": "```\\nclass Solution {\\n    private:vector<string> ans;\\npublic:\\n    void dfs(int i,string path,long ressofar,long prevno,string s,int target)\\n    {\\n        if (i==s.length())\\n        {\\n            if (ressofar==target)  ans.push_back(path);\\n            \\n            return ;\\n        }\\n        long  no=0;\\n        for (int j=i;j<s.length();j++)\\n        {\\n            if (j>i && s[i]==\\'0\\')  break;\\n            no=no*10+(s[j]-48);\\n            //cout<<no<<\\' \\';\\n            int len= j-i+1;\\n            string subpath=s.substr(i,len);\\n            if (i==0)\\n            {\\n                dfs(j+1,path+subpath,no,no,s,target);\\n            }\\n            else\\n            {\\n                dfs(j+1,path + \"+\" + subpath,ressofar+no,no,s,target);\\n                 dfs(j+1,path + \"-\" + subpath,ressofar-no,-1* no,s,target);\\n                 dfs(j+1,path + \"*\" + subpath,ressofar-prevno+prevno*no,prevno*no,s,target);\\n            }\\n            \\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n     \\n        dfs(0,\"\",0,0,num,target);\\n          return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    private:vector<string> ans;\\npublic:\\n    void dfs(int i,string path,long ressofar,long prevno,string s,int target)\\n    {\\n        if (i==s.length())\\n        {\\n            if (ressofar==target)  ans.push_back(path);\\n            \\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1471696,
                "title": "python-clean-simple",
                "content": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        results = []\\n        n = len(num)\\n        \\n        def dfs(i: int, expression: str, value: int, last: Optional[int]):\\n            if i == n and value == target:\\n                results.append(expression)\\n            \\n            for j in range(i+1, n+1):\\n                itoj = num[i:j]\\n                curr = int(itoj)\\n                if j == i + 1 or not itoj.startswith(\\'0\\'):\\n                    if last is None:\\n                        dfs(j, itoj, curr, curr)\\n                    else:\\n                        dfs(j, f\\'{expression}+{itoj}\\', value + curr, curr)\\n                        dfs(j, f\\'{expression}-{itoj}\\', value - curr, -curr)\\n                        dfs(j, f\\'{expression}*{itoj}\\', value - last + last * curr, last * curr)\\n        \\n        dfs(0, \\'\\', 0, None)\\n        return results\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        results = []\\n        n = len(num)\\n        \\n        def dfs(i: int, expression: str, value: int, last: Optional[int]):\\n            if i == n and value == target:\\n                results.append(expression)\\n            \\n            for j in range(i+1, n+1):\\n                itoj = num[i:j]\\n                curr = int(itoj)\\n                if j == i + 1 or not itoj.startswith(\\'0\\'):\\n                    if last is None:\\n                        dfs(j, itoj, curr, curr)\\n                    else:\\n                        dfs(j, f\\'{expression}+{itoj}\\', value + curr, curr)\\n                        dfs(j, f\\'{expression}-{itoj}\\', value - curr, -curr)\\n                        dfs(j, f\\'{expression}*{itoj}\\', value - last + last * curr, last * curr)\\n        \\n        dfs(0, \\'\\', 0, None)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471638,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public IList<string> AddOperators(string num, int target) {\\n        \\n        List<string> res = new List<string>();\\n        if(string.IsNullOrEmpty(num))\\n            return res;\\n        \\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(string num, int target, int idx, string expression, long expressionVal, long lastMonomial, List<string> res)\\n    {\\n        if(idx == num.Length)\\n        {\\n            if(expressionVal == target)\\n                res.Add(expression);\\n            return;\\n        }\\n        \\n        for(int i = idx; i < num.Length; i++)\\n        {\\n            string currStr = num.Substring(idx, i - idx + 1);\\n            \\n            if(currStr.Length > 1 && num[idx] == \\'0\\') break;  \\n            long currVal = long.Parse(currStr);\\n            \\n            if(idx == 0)\\n            {\\n                dfs(num, target, i + 1, expression + currStr, currVal, currVal, res);\\n            }\\n            else\\n            {\\n                // \\'+\\' and \\'-\\'\\n                dfs(num, target, i + 1, expression + \"+\" + currStr, expressionVal + currVal, currVal, res);\\n                dfs(num, target, i + 1, expression + \"-\" + currStr, expressionVal - currVal, -currVal, res);\\n\\n                // \\'*\\'\\n                dfs(num, target, i + 1, expression + \"*\" + currStr, expressionVal - lastMonomial + lastMonomial * currVal, lastMonomial* currVal, res);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> AddOperators(string num, int target) {\\n        \\n        List<string> res = new List<string>();\\n        if(string.IsNullOrEmpty(num))\\n            return res;\\n        \\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(string num, int target, int idx, string expression, long expressionVal, long lastMonomial, List<string> res)\\n    {\\n        if(idx == num.Length)\\n        {\\n            if(expressionVal == target)\\n                res.Add(expression);\\n            return;\\n        }\\n        \\n        for(int i = idx; i < num.Length; i++)\\n        {\\n            string currStr = num.Substring(idx, i - idx + 1);\\n            \\n            if(currStr.Length > 1 && num[idx] == \\'0\\') break;  \\n            long currVal = long.Parse(currStr);\\n            \\n            if(idx == 0)\\n            {\\n                dfs(num, target, i + 1, expression + currStr, currVal, currVal, res);\\n            }\\n            else\\n            {\\n                // \\'+\\' and \\'-\\'\\n                dfs(num, target, i + 1, expression + \"+\" + currStr, expressionVal + currVal, currVal, res);\\n                dfs(num, target, i + 1, expression + \"-\" + currStr, expressionVal - currVal, -currVal, res);\\n\\n                // \\'*\\'\\n                dfs(num, target, i + 1, expression + \"*\" + currStr, expressionVal - lastMonomial + lastMonomial * currVal, lastMonomial* currVal, res);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471275,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<String> res = new ArrayList<>();\\n    public List<String> addOperators(String num, int target) {\\n        backtracking(num, 0, target, \"\", 0, 0);\\n        return res;\\n    }\\n    \\n    public void backtracking(String num, int ind, long target, String temp, long tot, long pre) {\\n        if (ind == num.length() && tot == target) {\\n            res.add(temp);\\n            return;\\n        }\\n        long cur = 0;\\n        for (int end = ind; end < num.length(); end++) {\\n            if (end > ind && num.charAt(ind) == \\'0\\') return;\\n            cur = cur * 10 + num.charAt(end) - \\'0\\';\\n            String sub = num.substring(ind, end + 1);\\n            if (ind == 0) {\\n                backtracking(num, end + 1, target, sub, cur, cur);\\n                continue;\\n            }\\n            backtracking(num, end + 1, target, temp + \"+\" + sub, tot + cur, cur);\\n            backtracking(num, end + 1, target, temp + \"-\" + sub, tot - cur, -cur);\\n            backtracking(num, end + 1, target, temp + \"*\" + sub, tot + (cur - 1) * pre, cur * pre);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> res = new ArrayList<>();\\n    public List<String> addOperators(String num, int target) {\\n        backtracking(num, 0, target, \"\", 0, 0);\\n        return res;\\n    }\\n    \\n    public void backtracking(String num, int ind, long target, String temp, long tot, long pre) {\\n        if (ind == num.length() && tot == target) {\\n            res.add(temp);\\n            return;\\n        }\\n        long cur = 0;\\n        for (int end = ind; end < num.length(); end++) {\\n            if (end > ind && num.charAt(ind) == \\'0\\') return;\\n            cur = cur * 10 + num.charAt(end) - \\'0\\';\\n            String sub = num.substring(ind, end + 1);\\n            if (ind == 0) {\\n                backtracking(num, end + 1, target, sub, cur, cur);\\n                continue;\\n            }\\n            backtracking(num, end + 1, target, temp + \"+\" + sub, tot + cur, cur);\\n            backtracking(num, end + 1, target, temp + \"-\" + sub, tot - cur, -cur);\\n            backtracking(num, end + 1, target, temp + \"*\" + sub, tot + (cur - 1) * pre, cur * pre);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470576,
                "title": "c-simple-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long result,int &target,string expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            calc(num,i+1,val,result+val,target,index==0?expression+subStr:expression+\"+\"+subStr);\\n            if(index!=0)\\n            {\\n                calc(num,i+1,-1*val,result-val,target,expression+\"-\"+subStr);\\n                calc(num,i+1,last*val,result-last+last*val,target,expression+\"*\"+subStr);\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        calc(num,0,0,0,target,\"\");\\n        return ValidExp;\\n    }\\n};\\n```\\n\\n***Little complex but much optimised solution***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long &result,int &target,string &expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            long newResult=result+val;\\n            expression+=index==0?subStr:\"+\"+subStr;\\n            calc(num,i+1,val,newResult,target,expression);\\n            index==0?expression.erase():expression.erase(expression.length()-(i-index+2)); \\n            if(index!=0)\\n            {\\n                newResult=result-val;\\n                expression+=\"-\"+subStr;\\n                calc(num,i+1,-1*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n                newResult=result-last+last*val;\\n                expression+=\"*\"+subStr;\\n                calc(num,i+1,last*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        string exp;\\n        long result=0;\\n        calc(num,0,0,result,target,exp);\\n        return ValidExp;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long result,int &target,string expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            calc(num,i+1,val,result+val,target,index==0?expression+subStr:expression+\"+\"+subStr);\\n            if(index!=0)\\n            {\\n                calc(num,i+1,-1*val,result-val,target,expression+\"-\"+subStr);\\n                calc(num,i+1,last*val,result-last+last*val,target,expression+\"*\"+subStr);\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        calc(num,0,0,0,target,\"\");\\n        return ValidExp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long &result,int &target,string &expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            long newResult=result+val;\\n            expression+=index==0?subStr:\"+\"+subStr;\\n            calc(num,i+1,val,newResult,target,expression);\\n            index==0?expression.erase():expression.erase(expression.length()-(i-index+2)); \\n            if(index!=0)\\n            {\\n                newResult=result-val;\\n                expression+=\"-\"+subStr;\\n                calc(num,i+1,-1*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n                newResult=result-last+last*val;\\n                expression+=\"*\"+subStr;\\n                calc(num,i+1,last*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        string exp;\\n        long result=0;\\n        calc(num,0,0,result,target,exp);\\n        return ValidExp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470358,
                "title": "javascript-backtracking-commented-solution-with-explanation",
                "content": "**Idea** \\nwe want to do backtracking and calculate the the sum of the expression on the fly so when we get to the end of num array we will have sum ready and calculated, so we know if it is equal to target and we want to insert it to result array.\\n\\nwe have 4 options when we backtrack:\\n1. we don\\'t want to proccess the number yet, we want to enlarge it, create a new number with more than one digit \"124\", so we backtrack with the new number we created and we don\\'t calculate the expression yet, so we just send `newNumToAdd` to the backtracking func and do nothing.\\n2. we want to proccess the number with Addtion.\\n3. we want to proccess the number with Substraction.\\n4. we want to proccess the number with Multiplication, this is the tricky part:\\nTo be able to calculate the multiplications expression on the fly, to do that we keep track of the previous number  (`prevExp`) we proccessed and if we want to do a multiplication we do `sum - prevExp + (prevExp * newNumToAdd)`\\n\\n```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    backtracking(num, target, 0, 0, \"\", 0, 0, res);\\n    return res;\\n};\\n\\nvar backtracking = function(num, target, index, sum, expression, currNumToAdd, prevExp, res) {\\n\\tif(index > num.length) {\\n        return;\\n    }\\n    // If we are at end of num AND the final value == target expected AND no currNumToAdd is left unprocessed\\n    if(index === num.length && sum === target && currNumToAdd === 0) {\\n        res.push(expression.slice(1));\\n        return;\\n    }\\n    const newNumToAdd = currNumToAdd*10 + (+num[index]);\\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n    // valid operand. Hence this check. we only create number with more than 1 digit if (newNumToAdd > 0)\\n    if(newNumToAdd > 0) {\\n        backtracking(num, target, index+1, sum, expression, newNumToAdd, prevExp, res);\\n    }\\n    // ADDITION\\n    backtracking(num, target, index+1, sum + newNumToAdd, expression+\"+\"+newNumToAdd, 0, +newNumToAdd, res);\\n    // to avoid SUBTRACTION/MULTIPLICATION on first numToAdd when expression is empty(we asume we can only add)\\n    if(expression.length > 0) {\\n        // SUBTRACTION\\n        backtracking(num, target, index+1, sum - newNumToAdd, expression+\"-\"+newNumToAdd, 0, -newNumToAdd, res);\\n        // MULTIPLICATION\\n        const multSum = sum - prevExp + (prevExp * newNumToAdd);\\n        backtracking(num, target, index+1, multSum, expression+\"*\"+newNumToAdd, 0, (prevExp * newNumToAdd), res);\\n    }\\n    return;\\n}\\n\\n```\\n\\n**time comp**: O(4^N), where N length of num. O(4^N) because for every step in backtracking we have 4 paths.\\n**space comp**: O(N) for expression\\'s length string. also recursive stack space is O(N).",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    backtracking(num, target, 0, 0, \"\", 0, 0, res);\\n    return res;\\n};\\n\\nvar backtracking = function(num, target, index, sum, expression, currNumToAdd, prevExp, res) {\\n\\tif(index > num.length) {\\n        return;\\n    }\\n    // If we are at end of num AND the final value == target expected AND no currNumToAdd is left unprocessed\\n    if(index === num.length && sum === target && currNumToAdd === 0) {\\n        res.push(expression.slice(1));\\n        return;\\n    }\\n    const newNumToAdd = currNumToAdd*10 + (+num[index]);\\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n    // valid operand. Hence this check. we only create number with more than 1 digit if (newNumToAdd > 0)\\n    if(newNumToAdd > 0) {\\n        backtracking(num, target, index+1, sum, expression, newNumToAdd, prevExp, res);\\n    }\\n    // ADDITION\\n    backtracking(num, target, index+1, sum + newNumToAdd, expression+\"+\"+newNumToAdd, 0, +newNumToAdd, res);\\n    // to avoid SUBTRACTION/MULTIPLICATION on first numToAdd when expression is empty(we asume we can only add)\\n    if(expression.length > 0) {\\n        // SUBTRACTION\\n        backtracking(num, target, index+1, sum - newNumToAdd, expression+\"-\"+newNumToAdd, 0, -newNumToAdd, res);\\n        // MULTIPLICATION\\n        const multSum = sum - prevExp + (prevExp * newNumToAdd);\\n        backtracking(num, target, index+1, multSum, expression+\"*\"+newNumToAdd, 0, (prevExp * newNumToAdd), res);\\n    }\\n    return;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470337,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    enum class Operator {\\n        NONE, ADD, SUB, MUL\\n    }\\n    data class Result(\\n        val resValue: Long, \\n        val resString: String, \\n        val lastBlockMultiplier: Long,\\n        val lastNumber: Long) {\\n        \\n        private val lastBlockRes: Long = lastBlockMultiplier * lastNumber\\n        \\n        fun add(op: Operator, num: Long): Result? {\\n            return when (op) {\\n                Operator.ADD -> Result(resValue + num, \"$resString+$num\", 1, num)\\n                Operator.SUB -> Result(resValue - num, \"$resString-$num\", -1, num)\\n                Operator.MUL -> Result(resValue - lastBlockRes + lastBlockRes * num,\\n                                       \"$resString*$num\", lastBlockRes, num)\\n                Operator.NONE -> if (lastNumber == 0L) { null } else {\\n                    Result(resValue - lastBlockRes + lastBlockMultiplier * (lastNumber * 10 + num),\\n                           \"$resString$num\", lastBlockMultiplier, lastNumber * 10 + num)\\n                }\\n            }\\n        }\\n    }\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val res = mutableListOf<String>()\\n        \\n        fun addOperatorBefore(index: Int, prevResult: Result) {\\n            if (index == num.length) {\\n                if (prevResult.resValue == target.toLong()) {\\n                    res.add(prevResult.resString)\\n                }\\n                return\\n            }\\n            val digitNum = (num[index] - \\'0\\').toLong()\\n            val results = Operator.values().fold(mutableListOf<Result>()) { acc, op ->\\n                acc.apply { prevResult.add(op, digitNum)?.let { add(it) } }\\n            }\\n            results.forEach {\\n                addOperatorBefore(index + 1, it)\\n            }\\n        }\\n        \\n        val digitNum = (num[0] - \\'0\\').toLong()\\n        addOperatorBefore(1, Result(digitNum, \"${num[0]}\", 1L, digitNum))\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    enum class Operator {\\n        NONE, ADD, SUB, MUL\\n    }\\n    data class Result(\\n        val resValue: Long, \\n        val resString: String, \\n        val lastBlockMultiplier: Long,\\n        val lastNumber: Long) {\\n        \\n        private val lastBlockRes: Long = lastBlockMultiplier * lastNumber\\n        \\n        fun add(op: Operator, num: Long): Result? {\\n            return when (op) {\\n                Operator.ADD -> Result(resValue + num, \"$resString+$num\", 1, num)\\n                Operator.SUB -> Result(resValue - num, \"$resString-$num\", -1, num)\\n                Operator.MUL -> Result(resValue - lastBlockRes + lastBlockRes * num,\\n                                       \"$resString*$num\", lastBlockRes, num)\\n                Operator.NONE -> if (lastNumber == 0L) { null } else {\\n                    Result(resValue - lastBlockRes + lastBlockMultiplier * (lastNumber * 10 + num),\\n                           \"$resString$num\", lastBlockMultiplier, lastNumber * 10 + num)\\n                }\\n            }\\n        }\\n    }\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val res = mutableListOf<String>()\\n        \\n        fun addOperatorBefore(index: Int, prevResult: Result) {\\n            if (index == num.length) {\\n                if (prevResult.resValue == target.toLong()) {\\n                    res.add(prevResult.resString)\\n                }\\n                return\\n            }\\n            val digitNum = (num[index] - \\'0\\').toLong()\\n            val results = Operator.values().fold(mutableListOf<Result>()) { acc, op ->\\n                acc.apply { prevResult.add(op, digitNum)?.let { add(it) } }\\n            }\\n            results.forEach {\\n                addOperatorBefore(index + 1, it)\\n            }\\n        }\\n        \\n        val digitNum = (num[0] - \\'0\\').toLong()\\n        addOperatorBefore(1, Result(digitNum, \"${num[0]}\", 1L, digitNum))\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465105,
                "title": "java-solution-backtracking",
                "content": "class Solution {\\n\\n    List<String> sol;\\n     public List<String> addOperators(String num, int target) {\\n        sol = new ArrayList<>();\\n\\n         if(Long.parseLong(num) > Integer.MAX_VALUE) return sol;\\n        \\n        recursion(num, target, 0, new StringBuilder());\\n        return sol;\\n    }\\n    \\n    \\n    public void recursion(String num, int target, int start, StringBuilder sb) {        \\n        if(start == num.length()) {\\n            // calculate opeartaion from String \\n            if(Integer.compare(calculate(sb.toString()), target) == 0) sol.add(sb.toString());\\n            return;\\n        }\\n          \\n        for(int i = start; i < num.length(); i++) {\\n            \\n            if(i-start> 0 && num.charAt(start) == \\'0\\') continue;  // number like: \"05\", \"00\".. \\n            \\n            if(start == 0 ) {\\n                sb.append(num.substring(start,i+1)+\"\"); // First number, example:  -> (1) + 2 + 3\\n                recursion(num, target, i + 1, sb);\\n                \\n            } else{\\n                // Addition (add the \"x\" and number)\\n                sb.append(\"+\");\\n                sb.append(num.substring(start,i+1)+\"\");\\n                recursion(num, target, i + 1, sb);\\n\\n                // Substraction (change \"+\" to \"-\")\\n                sb.replace(sb.length()-2-(i-start),sb.length()-1-(i-start), \"-\");\\n                recursion(num, target, i + 1, sb);\\n\\n                //Multiplication (change \"-\" to \"*\")\\n                sb.replace(sb.length()-2-(i-start),sb.length()-1-(i-start), \"*\");\\n                recursion(num, target, i + 1, sb);\\n            }\\n            //delete the added elements to backtrack\\n            if(sb.length()-2-(i-start) >= 0) sb.delete(sb.length()-2-(i-start),sb.length());\\n            else sb.delete(0, sb.length());\\n        }\\n        \\n    }\\n    \\n    \\n    \\n    public int calculate(String expression) {\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        boolean isMultiplication = false;\\n        int pointer = 0;\\n        int sign = 1;\\n        int number = 0;\\n        \\n        while(pointer < expression.length()) {\\n\\n            if(expression.charAt(pointer) == \\'*\\') {\\n                isMultiplication = true;\\n                pointer++;\\n            }\\n            if(expression.charAt(pointer) == \\'-\\') {\\n                sign = -1;\\n                pointer++;\\n            } \\n            if(expression.charAt(pointer) == \\'+\\') {\\n                sign = 1;\\n                pointer++;\\n            } \\n            while(pointer < expression.length() && expression.charAt(pointer) >= \\'0\\' \\n                  && expression.charAt(pointer) <= \\'9\\') {\\n                number = number * 10 + Integer.parseInt(expression.charAt(pointer) + \"\");\\n                pointer++;\\n            }\\n            if(isMultiplication) {\\n                number *= stack.pop();\\n                isMultiplication = false;\\n            } \\n            stack.add(number*sign);\\n            number = 0;\\n            sign = 1;\\n        }\\n        \\n        int result = 0;\\n        for(int x: stack) result += x;\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    List<String> sol;\\n     public List<String> addOperators(String num, int target) {\\n        sol = new ArrayList<>();\\n\\n         if(Long.parseLong(num) > Integer.MAX_VALUE) return sol;\\n        \\n        recursion(num, target, 0, new StringBuilder());\\n        return sol;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1414131,
                "title": "python-simple-and-clear-dfs-solution-with-detailed-comments-beating-97",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        n = len(num)\\n        \\n        def dfs(pos, path, val, last_operand):\\n            if pos == n:\\n                if val == target:\\n                    result.append(path)\\n            else:\\n                for i in range(pos, n):\\n                    # try [pos..i] as an operand\\n                    if num[pos] == \\'0\\' and i != pos:\\n                        # For example \"0555\", Only consider \"0\" as possible operand\\n                        break\\n                    s = num[pos : i + 1]\\n                    v = int(s)\\n                    if pos == 0:\\n                        # no possible left operand\\n                        dfs(i + 1, s, v, v)\\n                    else:\\n                        dfs(i + 1, path + \\'+\\' + s, val + v, v)\\n                        dfs(i + 1, path + \\'-\\' + s, val - v, -v)\\n                        dfs(i + 1, path + \\'*\\' + s, val - last_operand + last_operand * v, last_operand * v)\\n        \\n        dfs(0, \\'\\', 0, 0)\\n        return result",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        n = len(num)\\n        \\n        def dfs(pos, path, val, last_operand):\\n            if pos == n:\\n                if val == target:\\n                    result.append(path)\\n            else:\\n                for i in range(pos, n):\\n                    # try [pos..i] as an operand\\n                    if num[pos] == \\'0\\' and i != pos:\\n                        # For example \"0555\", Only consider \"0\" as possible operand\\n                        break\\n                    s = num[pos : i + 1]\\n                    v = int(s)\\n                    if pos == 0:\\n                        # no possible left operand\\n                        dfs(i + 1, s, v, v)\\n                    else:\\n                        dfs(i + 1, path + \\'+\\' + s, val + v, v)\\n                        dfs(i + 1, path + \\'-\\' + s, val - v, -v)\\n                        dfs(i + 1, path + \\'*\\' + s, val - last_operand + last_operand * v, last_operand * v)\\n        \\n        dfs(0, \\'\\', 0, 0)\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1404761,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new LinkedList<String>();\\n        helper(num, target, 0, 0, \\'!\\', 0, \"\", result);\\n        return result;\\n    }\\n    \\n    private void helper(String num, int target, long curSum, long prevNum, char prevOp, int pos, String local, List<String> result) {\\n        if (pos == num.length()) {\\n            if (curSum == (long)target) result.add(local);\\n            return ;\\n        }\\n        \\n        long curNum = 0;\\n        for(int i = pos; i < num.length(); i++) {\\n            if (i == pos || curNum > 0) {\\n                curNum = curNum*10 + Integer.valueOf(num.charAt(i)-\\'0\\');  \\n                if (pos == 0) {\\n                    helper(num, target, curNum, curNum, prevOp, i+1, String.valueOf(curNum), result);\\n                } else {\\n                    // +\\n                    helper(num, target, curSum+curNum, curNum, \\'+\\', i+1, local+\"+\"+curNum, result);\\n                    // -\\n                    helper(num, target, curSum-curNum, curNum, \\'-\\', i+1, local+\"-\"+curNum, result);\\n                    // *\\n                    if (prevOp == \\'-\\') {\\n                        helper(num, target, curSum+prevNum-(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else if (prevOp == \\'+\\') {\\n                        helper(num, target, curSum-prevNum+(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else {\\n                        helper(num, target, curSum*curNum, curNum, prevOp, i+1, local+\"*\"+curNum, result);    \\n                    }\\n                }   \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new LinkedList<String>();\\n        helper(num, target, 0, 0, \\'!\\', 0, \"\", result);\\n        return result;\\n    }\\n    \\n    private void helper(String num, int target, long curSum, long prevNum, char prevOp, int pos, String local, List<String> result) {\\n        if (pos == num.length()) {\\n            if (curSum == (long)target) result.add(local);\\n            return ;\\n        }\\n        \\n        long curNum = 0;\\n        for(int i = pos; i < num.length(); i++) {\\n            if (i == pos || curNum > 0) {\\n                curNum = curNum*10 + Integer.valueOf(num.charAt(i)-\\'0\\');  \\n                if (pos == 0) {\\n                    helper(num, target, curNum, curNum, prevOp, i+1, String.valueOf(curNum), result);\\n                } else {\\n                    // +\\n                    helper(num, target, curSum+curNum, curNum, \\'+\\', i+1, local+\"+\"+curNum, result);\\n                    // -\\n                    helper(num, target, curSum-curNum, curNum, \\'-\\', i+1, local+\"-\"+curNum, result);\\n                    // *\\n                    if (prevOp == \\'-\\') {\\n                        helper(num, target, curSum+prevNum-(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else if (prevOp == \\'+\\') {\\n                        helper(num, target, curSum-prevNum+(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else {\\n                        helper(num, target, curSum*curNum, curNum, prevOp, i+1, local+\"*\"+curNum, result);    \\n                    }\\n                }   \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388352,
                "title": "very-simple-python-dfs-solution",
                "content": "start: start index\\nl: path\\ntot: sum\\nprev: previous value\\n\\n```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \\n        res = []\\n        \\n        def dfs(start = 0, l = \"\", tot = 0, prev = 0):\\n            if start == len(num):\\n                if tot == target:\\n                    res.append(l)\\n                return\\n            \\n            for i in range(start, len(num)):\\n                \\n                if i - start and int(num[start]) == 0:\\n                    continue\\n                \\n                cur = int(num[start:i + 1])\\n                if start == 0:\\n                    dfs(i + 1, l + str(cur), tot + cur, cur)\\n                else:\\n                    dfs(i + 1, l + \"+\" + str(cur), tot + cur, cur)\\n                    dfs(i + 1, l + \"-\" + str(cur), tot - cur, -cur)\\n                    dfs(i + 1, l + \"*\" + str(cur), tot - prev + prev * cur, prev * cur)\\n        \\n        dfs()\\n        \\n        return res\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \\n        res = []\\n        \\n        def dfs(start = 0, l = \"\", tot = 0, prev = 0):\\n            if start == len(num):\\n                if tot == target:\\n                    res.append(l)\\n                return\\n            \\n            for i in range(start, len(num)):\\n                \\n                if i - start and int(num[start]) == 0:\\n                    continue\\n                \\n                cur = int(num[start:i + 1])\\n                if start == 0:\\n                    dfs(i + 1, l + str(cur), tot + cur, cur)\\n                else:\\n                    dfs(i + 1, l + \"+\" + str(cur), tot + cur, cur)\\n                    dfs(i + 1, l + \"-\" + str(cur), tot - cur, -cur)\\n                    dfs(i + 1, l + \"*\" + str(cur), tot - prev + prev * cur, prev * cur)\\n        \\n        dfs()\\n        \\n        return res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1284423,
                "title": "java-clean-code-dfs",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        ArrayList<String> res = new ArrayList<>();\\n        dfs(0,0,0,0,num, target,\"\",res);\\n        return res;\\n    }\\n    \\n    void dfs(int ci, long val, long prev, long cur, String num,long target, String str, ArrayList<String> res){\\n        if(ci == num.length()){\\n            if(val == target && cur == 0) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n\\n        int cd= num.charAt(ci) - \\'0\\';\\n        cur = 10 * cur; \\n        cur += cd;\\n\\n        //no op\\n        if(cur > 0)\\n            dfs(ci+1, val, prev, cur, num, target, str , res );\\n        \\n        // + \\n        if(str.equals(\"\")) {\\n             dfs(ci+1, val+cur, cur, 0, num, target, str + cur, res );\\n            return;\\n        }\\n         dfs(ci+1, val+cur, cur, 0, num, target, str +\"+\" + cur, res );\\n          // -\\n        dfs(ci+1, val -cur, -cur, 0, num, target, str +\"-\" + cur, res );\\n\\n        // *\\n        dfs(ci+1, val -prev + (prev * cur), prev * cur, 0, num, target, str +\"*\" + cur, res );\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        ArrayList<String> res = new ArrayList<>();\\n        dfs(0,0,0,0,num, target,\"\",res);\\n        return res;\\n    }\\n    \\n    void dfs(int ci, long val, long prev, long cur, String num,long target, String str, ArrayList<String> res){\\n        if(ci == num.length()){\\n            if(val == target && cur == 0) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n\\n        int cd= num.charAt(ci) - \\'0\\';\\n        cur = 10 * cur; \\n        cur += cd;\\n\\n        //no op\\n        if(cur > 0)\\n            dfs(ci+1, val, prev, cur, num, target, str , res );\\n        \\n        // + \\n        if(str.equals(\"\")) {\\n             dfs(ci+1, val+cur, cur, 0, num, target, str + cur, res );\\n            return;\\n        }\\n         dfs(ci+1, val+cur, cur, 0, num, target, str +\"+\" + cur, res );\\n          // -\\n        dfs(ci+1, val -cur, -cur, 0, num, target, str +\"-\" + cur, res );\\n\\n        // *\\n        dfs(ci+1, val -prev + (prev * cur), prev * cur, 0, num, target, str +\"*\" + cur, res );\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245293,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def dfs(pos, cur, pre, exp):\\n\\n            if pos == n:\\n                if cur == target:\\n                    res.append(exp)\\n                return\\n        \\n            for right in range(pos + 1, n + 1):\\n                tmp = num[pos:right]\\n                if tmp[0] == \\'0\\' and len(tmp) > 1:\\n                    break\\n                    \\n                val = int(tmp)\\n                if pos == 0:\\n                    dfs(right, val, val, tmp)\\n                else:\\n                    dfs(right, cur + val, val, exp + \"+\" + tmp)\\n                    dfs(right, cur - val, -val, exp + \"-\" + tmp)\\n                    dfs(right, cur - pre + pre * val, pre * val, exp + \"*\" + tmp)\\n            \\n        \\n        res = list()\\n        if not num or len(num) == 0:\\n            return res\\n        n = len(num)\\n        dfs(0, 0, 0, \"\")\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def dfs(pos, cur, pre, exp):\\n\\n            if pos == n:\\n                if cur == target:\\n                    res.append(exp)\\n                return\\n        \\n            for right in range(pos + 1, n + 1):\\n                tmp = num[pos:right]\\n                if tmp[0] == \\'0\\' and len(tmp) > 1:\\n                    break\\n                    \\n                val = int(tmp)\\n                if pos == 0:\\n                    dfs(right, val, val, tmp)\\n                else:\\n                    dfs(right, cur + val, val, exp + \"+\" + tmp)\\n                    dfs(right, cur - val, -val, exp + \"-\" + tmp)\\n                    dfs(right, cur - pre + pre * val, pre * val, exp + \"*\" + tmp)\\n            \\n        \\n        res = list()\\n        if not num or len(num) == 0:\\n            return res\\n        n = len(num)\\n        dfs(0, 0, 0, \"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238289,
                "title": "c-clean-and-concise-beats-98-28",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string buf;\\n    long t;\\n    int last;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        buf.resize(20);\\n        t = target;\\n        last = num.size()-1;\\n        \\n        dfs(num, 0, 0, 0, 0, \\'+\\');\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string& num, int i, int j, long sum, long sumtmp, char prevop){                \\n        long v = 0;\\n        \\n        for (int k = i ; ; k++){\\n            v *= 10;\\n            v += long(num[k]-\\'0\\');\\n            buf[j] = num[k];\\n            j++;\\n            \\n            long sumtmptmp = (prevop == \\'*\\'?sumtmp*v: (prevop == \\'+\\'?sumtmp+v:sumtmp-v));\\n            \\n            if (k == last){\\n                if (sum+sumtmptmp == t) ans.push_back(buf.substr(0, j));\\n\\n                return;\\n            }\\n            \\n            buf[j] = \\'*\\';\\n            dfs(num, k+1, j+1, sum, sumtmptmp, \\'*\\');\\n            buf[j] = \\'+\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'+\\');\\n            buf[j] = \\'-\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'-\\');\\n            \\n            if (!v) return;\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string buf;\\n    long t;\\n    int last;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        buf.resize(20);\\n        t = target;\\n        last = num.size()-1;\\n        \\n        dfs(num, 0, 0, 0, 0, \\'+\\');\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string& num, int i, int j, long sum, long sumtmp, char prevop){                \\n        long v = 0;\\n        \\n        for (int k = i ; ; k++){\\n            v *= 10;\\n            v += long(num[k]-\\'0\\');\\n            buf[j] = num[k];\\n            j++;\\n            \\n            long sumtmptmp = (prevop == \\'*\\'?sumtmp*v: (prevop == \\'+\\'?sumtmp+v:sumtmp-v));\\n            \\n            if (k == last){\\n                if (sum+sumtmptmp == t) ans.push_back(buf.substr(0, j));\\n\\n                return;\\n            }\\n            \\n            buf[j] = \\'*\\';\\n            dfs(num, k+1, j+1, sum, sumtmptmp, \\'*\\');\\n            buf[j] = \\'+\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'+\\');\\n            buf[j] = \\'-\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'-\\');\\n            \\n            if (!v) return;\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069896,
                "title": "clean-python-solution",
                "content": "The trick of this solution is to record the `last` calculated value for current  multiple (`*`) operation.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ret = []\\n        def dfs(subtotal, last, path, start):\\n            if start == len(num):\\n                if subtotal == target:\\n                    ret.append(\\'\\'.join(path))\\n                return\\n            for i in range(start, len(num)):\\n                ch = num[start:i + 1]\\n                if len(ch) > 1 and ch[0] == \\'0\\':\\n                    continue\\n                integer = int(ch)\\n                if not path:\\n                    dfs( integer, integer, [ch], i + 1 )\\n                else:\\n                    dfs( subtotal + integer, integer, path + [\\'+\\', ch], i + 1 )\\n                    dfs( subtotal - integer, -integer, path + [\\'-\\', ch],i + 1 )\\n\\t\\t\\t\\t\\t# the most interesting part:\\n\\t\\t\\t\\t\\t# e.g. 1+2*3, we record last as 2, so: 3-2+2*3 = 7\\n                    dfs( subtotal - last + last * integer, last * integer, path + [\\'*\\', ch], i + 1 ) \\n        dfs(0, 0, [], 0)\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ret = []\\n        def dfs(subtotal, last, path, start):\\n            if start == len(num):\\n                if subtotal == target:\\n                    ret.append(\\'\\'.join(path))\\n                return\\n            for i in range(start, len(num)):\\n                ch = num[start:i + 1]\\n                if len(ch) > 1 and ch[0] == \\'0\\':\\n                    continue\\n                integer = int(ch)\\n                if not path:\\n                    dfs( integer, integer, [ch], i + 1 )\\n                else:\\n                    dfs( subtotal + integer, integer, path + [\\'+\\', ch], i + 1 )\\n                    dfs( subtotal - integer, -integer, path + [\\'-\\', ch],i + 1 )\\n\\t\\t\\t\\t\\t# the most interesting part:\\n\\t\\t\\t\\t\\t# e.g. 1+2*3, we record last as 2, so: 3-2+2*3 = 7\\n                    dfs( subtotal - last + last * integer, last * integer, path + [\\'*\\', ch], i + 1 ) \\n        dfs(0, 0, [], 0)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044199,
                "title": "java-basic-calculator-ii",
                "content": "This takes the Solution 2 of Basic Calculator II and modifies it. \\nThe idea is that we generate the string we are evaluating on the previous call and evaluate it in the next call. So basically Basic Calculator II + generate the next part of the string and call again Basic Calculator II.\\n\\n```\\n\\tint target;\\n    List<String> answer = new ArrayList<>();\\n    \\n    public List<String> addOperators(String num, int target) {\\n        this.target = target;\\n        addOp(num, 0, new StringBuilder(), 0, 0, \\'+\\', 0);\\n        return answer;\\n    }\\n    \\n    public void addOp(String num, int i, StringBuilder sb, long lOp, long rOp, char prevOp, long sum) {\\n        int numLen = num.length();\\n        int resLen = sb.length();\\n        \\n        // Get the current char of the result\\n        char c = resLen > 0 ? sb.charAt(resLen - 1) : \\'+\\';\\n        \\n        // Have this because we have multiple calls\\n        boolean isDigit = Character.isDigit(c);\\n        \\n        // Check this here in case we reach i==numLen and there is still a digit we haven\\'t added to rOp\\n        if(isDigit) {\\n            rOp = rOp * 10 + (c - \\'0\\');\\n        }\\n         \\n        // We want to to this once before ending at i==numLen\\n        if(resLen == 0 || i == numLen || c == \\'*\\' || c == \\'+\\' || c == \\'-\\') {\\n            if(prevOp == \\'+\\') {\\n                sum += lOp;\\n                lOp = rOp;\\n            } else if(prevOp == \\'-\\') {\\n                sum += lOp;\\n                lOp = -rOp;\\n            } else {\\n                lOp = lOp * rOp;\\n            }\\n            rOp = 0;\\n            prevOp = c;            \\n        } else if(isDigit) {           \\n            // Add operations and evaluate\\n            addOp(num, i, new StringBuilder(sb).append(\\'+\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'-\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'*\\'), lOp, rOp, prevOp, sum);                \\n        }\\n        \\n        // If we havent reached the end, we try NOT adding an operation.\\n        if(i < numLen) {\\n            // This prevent 05, 00. Catches leading zeros.\\n            if(!isDigit || (isDigit && (rOp != 0))) {\\n                addOp(num, i+1, sb.append(num.charAt(i)), lOp, rOp, prevOp, sum);                \\n            }            \\n        } else {\\n            // Base case is here. When we reached the end but already did all operations above.\\n            long result = sum + lOp;\\n            if(result == this.target) {\\n                this.answer.add(sb.toString());\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint target;\\n    List<String> answer = new ArrayList<>();\\n    \\n    public List<String> addOperators(String num, int target) {\\n        this.target = target;\\n        addOp(num, 0, new StringBuilder(), 0, 0, \\'+\\', 0);\\n        return answer;\\n    }\\n    \\n    public void addOp(String num, int i, StringBuilder sb, long lOp, long rOp, char prevOp, long sum) {\\n        int numLen = num.length();\\n        int resLen = sb.length();\\n        \\n        // Get the current char of the result\\n        char c = resLen > 0 ? sb.charAt(resLen - 1) : \\'+\\';\\n        \\n        // Have this because we have multiple calls\\n        boolean isDigit = Character.isDigit(c);\\n        \\n        // Check this here in case we reach i==numLen and there is still a digit we haven\\'t added to rOp\\n        if(isDigit) {\\n            rOp = rOp * 10 + (c - \\'0\\');\\n        }\\n         \\n        // We want to to this once before ending at i==numLen\\n        if(resLen == 0 || i == numLen || c == \\'*\\' || c == \\'+\\' || c == \\'-\\') {\\n            if(prevOp == \\'+\\') {\\n                sum += lOp;\\n                lOp = rOp;\\n            } else if(prevOp == \\'-\\') {\\n                sum += lOp;\\n                lOp = -rOp;\\n            } else {\\n                lOp = lOp * rOp;\\n            }\\n            rOp = 0;\\n            prevOp = c;            \\n        } else if(isDigit) {           \\n            // Add operations and evaluate\\n            addOp(num, i, new StringBuilder(sb).append(\\'+\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'-\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'*\\'), lOp, rOp, prevOp, sum);                \\n        }\\n        \\n        // If we havent reached the end, we try NOT adding an operation.\\n        if(i < numLen) {\\n            // This prevent 05, 00. Catches leading zeros.\\n            if(!isDigit || (isDigit && (rOp != 0))) {\\n                addOp(num, i+1, sb.append(num.charAt(i)), lOp, rOp, prevOp, sum);                \\n            }            \\n        } else {\\n            // Base case is here. When we reached the end but already did all operations above.\\n            long result = sum + lOp;\\n            if(result == this.target) {\\n                this.answer.add(sb.toString());\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564924,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1565668,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1747503,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1576894,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1568041,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570495,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569873,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569747,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569054,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570615,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1564924,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1565668,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1747503,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1576894,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1568041,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570495,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569873,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569747,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569054,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570615,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1861633,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1575220,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1574526,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1572513,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571989,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571525,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571526,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 2040002,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1994199,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1979861,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            }
        ]
    },
    {
        "title": "Linked List Random Node",
        "question_content": "<p>Given a singly linked list, return a random node&#39;s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(ListNode head)</code> Initializes the object with the head of the singly-linked list <code>head</code>.</li>\n\t<li><code>int getRandom()</code> Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg\" style=\"width: 302px; height: 62px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>Output</strong>\n[null, 1, 3, 2, 2, 3]\n\n<strong>Explanation</strong>\nSolution solution = new Solution([1, 2, 3]);\nsolution.getRandom(); // return 1\nsolution.getRandom(); // return 3\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 3\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the linked list will be in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>getRandom</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What if the linked list is extremely large and its length is unknown to you?</li>\n\t<li>Could you solve this efficiently without using extra space?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 85659,
                "title": "brief-explanation-for-reservoir-sampling",
                "content": "This problem can be solved easily. You don\\'t have to use reservoir sampling at all. You just need to:\\n\\n1. calculate the length of the list\\n1. randomly draw a number from `1 ~ length` (let\\'s say `i`), then return the `ith` element, and it\\'s done. \\n\\nBut if you want to know more about reservoir sampling, take a looking at the following part.\\n\\n\\n\\n\\n### Problem Desciption\\n\\n- Choose `k` entries from `n` numbers. Make sure each number is selected with the probability of `k/n`\\n- This problem is the special case where `k=1`\\n\\n\\n\\n### Basic idea\\n\\n- Choose `1, 2, 3, ..., k` first and put them into the reservoir.\\n- For the next `k+1` element, pick it with a probability of `k/(k+1)`, and randomly replace a number in the reservoir.\\n- Same as above, for the following `k+i` element, pick it with a probability of `k/(k+i)`, and randomly replace a number in the reservoir.\\n- Repeat until `k+i` reaches `n`\\n\\n\\n\\n### Proof\\n\\n- For `k+i`, the probability that it is selected and will replace a number in the reservoir is `k/(k+i)` (As we defined above)\\n\\n- For a number in the reservoir before (let\\'s say `X`), the probability that it keeps staying in the reservoir is\\n\\n  - `P(X was in the reservoir last time)` \\xD7 `P(X is not replaced by k+i)`\\n  - = `P(X was in the reservoir last time)` \\xD7 (`1` - `P(k+i is selected and replaces X)`)\\n  - = `k/(k+i-1)` \\xD7 \\uFF08`1` - `k/(k+i)` \\xD7 `1/k`\\uFF09\\n  - = `k/(k+i)`\\n\\n- When `k+i` reaches `n`, the probability of each number staying in the reservoir is `k/n`\\n\\n\\n\\n### Examples\\n\\n**Example1: Choose `3` numbers from `[111, 222, 333, 444]`. Each number should be selected with a probability of `3/4`**\\n\\n1. Choose `[111, 222, 333]` as the initial reservior\\n2. Then choose `444` with a probability of `3/4`\\n3. For `111`, it stays with a probability of\\n   - `P(444 is not selected)` + `P(444 is selected but it replaces 222 or 333)`\\n   - = `1/4` + `3/4`*`2/3`\\n   - = `3/4`\\n4. The same case with `222` and `333`\\n5. Now all the numbers have the probability of `3/4` to be picked\\n\\n\\n\\n\\n\\n**Example2: Choose `1` number from `[111, 222, 333]`. Each number should be selected with a probability of `1/3`**\\n\\n1. Choose `[111]` as the initial reservior\\n2. Now we iterate to `222`, choose it with the probility of `1/2`\\n   1. if it is chosen (`1/2` probility), we replace `111` with `222 ` . In this case, `222` is picked with the probility of `1/2`\\n   2. if it is not chosen (another `1/2` probility), `111` stays. In this case, `111` stays with the probility of `1/2`\\n   3. Combine the above 2 cases, both `111` and `222` have the probility of `1/2`\\n3. Now we iterate to `333`, choose it with the probility of `1/3`\\n   1. if it is chosen (`1/3` probility), we replace the result of last iteration to `333`. In this case, `333` is picked with the probility of `1/3`\\n   2. if it is not chosen (`2/3` probility), the result of last iteration stays, and in last iteration, both `111` and `222` have the probility of `1/2`. In this round, their probability become `2/3 * 1/2 = 1/3`. \\n   3. Now all the nums `111, 222, 333` have the probility of `1/3` to be picked\\n\\n\\n\\n### Sample Code\\n\\n```go\\nfunc (this *Solution) GetRandom() int {\\n    res, n := 0, 0               // res: reservoir, n: counter\\n    for h := this.Head; h != nil; h = h.Next {\\n        n++\\n        if rand.Intn(n) == 0 {   // rand.Intn(n) draws from [0 ~ n-1], so it has a probability of 1/n to equals 0.\\n            res = h.Val          // If it equals, means it is chosen and should replace the reservoir\\n        }\\n    }\\n    return res\\n}\\n```\\n\\n\\n\\n\\n\\n### Related Problems\\n\\n- [382. Linked List Random Node (this problem)](https://leetcode.com/problems/linked-list-random-node/)\\n- [384. Shuffle an Array](https://leetcode.com/problems/shuffle-an-array)",
                "solutionTags": [
                    "Reservoir Sampling"
                ],
                "code": "```go\\nfunc (this *Solution) GetRandom() int {\\n    res, n := 0, 0               // res: reservoir, n: counter\\n    for h := this.Head; h != nil; h = h.Next {\\n        n++\\n        if rand.Intn(n) == 0 {   // rand.Intn(n) draws from [0 ~ n-1], so it has a probability of 1/n to equals 0.\\n            res = h.Val          // If it equals, means it is chosen and should replace the reservoir\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85662,
                "title": "java-solution-with-cases-explain",
                "content": "When I first got this question, I went through some articles, but it is painful for me to understand abstract notations like i, k, m, n, n-1, k+1...\\n\\nAfter I read this one: [http://blog.jobbole.com/42550/](http://blog.jobbole.com/42550), it comes with a simple example and I understood suddenly, and write the code by myself. I translate it to English, so more people can benefit from it.\\n\\nStart...\\nWhen we read the first node ```head```, if the stream ```ListNode``` stops here, we can just return the ```head.val```. The possibility is ```1/1```.\\n\\nWhen we read the second node, we can decide if we replace the result ```r``` or not. The possibility is ```1/2```. So we just generate a random number between ```0``` and ```1```, and check if it is equal to ```1```. If it is ```1```, replace ```r``` as the value of the current node, otherwise we don't touch ```r```, so its value is still the value of head.\\n\\nWhen we read the third node, now the result ```r``` is one of value in the head or second node. We just decide if we replace ```the value of r``` as ```the value of current node(third node)```. The possibility of replacing it is ```1/3```, namely the possibility of we don't touch ```r``` is ```2/3```. So we just generate a random number between ```0 ~ 2```, and if the result is ```2``` we replace ```r```.\\n\\nWe can continue to do like this until the end of stream ```ListNode```.\\n\\nHere is the Java code:\\n```\\npublic class Solution {\\n    \\n    ListNode head;\\n    Random random;\\n    \\n    public Solution(ListNode h) {\\n        head = h;       \\n        random = new Random();        \\n    }\\n    \\n    public int getRandom() {\\n        \\n        ListNode c = head;\\n        int r = c.val;\\n        for(int i=1;c.next != null;i++){\\n            \\n            c = c.next;\\n            if(random.nextInt(i + 1) == i) r = c.val;                        \\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```head```\n```ListNode```\n```head.val```\n```1/1```\n```r```\n```1/2```\n```0```\n```1```\n```1```\n```1```\n```r```\n```r```\n```r```\n```the value of r```\n```the value of current node(third node)```\n```1/3```\n```r```\n```2/3```\n```0 ~ 2```\n```2```\n```r```\n```ListNode```\n```\\npublic class Solution {\\n    \\n    ListNode head;\\n    Random random;\\n    \\n    public Solution(ListNode h) {\\n        head = h;       \\n        random = new Random();        \\n    }\\n    \\n    public int getRandom() {\\n        \\n        ListNode c = head;\\n        int r = c.val;\\n        for(int i=1;c.next != null;i++){\\n            \\n            c = c.next;\\n            if(random.nextInt(i + 1) == i) r = c.val;                        \\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672358,
                "title": "c-python-java-reservoir-sampling-prove-step-by-step-image",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n\\n**3 Solutions:**\\n* **convert linked list to an array, randomly choose a node from array**\\n* **Pre-Count the length of linked list, randomly generate an index i, traverse the linked list from head to tail to find out the value of i-th node**\\n* **Reservoir sampling and K == 1**\\n\\n\\n\\n**Solution 3: Reservoir sampling and K == 1**\\n[**Reservoir sampling Wikipedia**](https://en.wikipedia.org/wiki/Reservoir_sampling)\\n\\nthis is a **conditional probability problem**.\\n* The key point is before we process the N-th element, the probability of each previous N-1 element is equal to each other. **This is very important.**\\n* so after processing N-th element, the probability of each previous N-1 element is **still equal to each other**.\\n* At this time, the probability of N-th element is 1/N with no doubt, and the rest `(1 -  1 / N) = (N - 1) / N` will be shared equally by previous `N - 1` elements, that is `(1 - 1 / N) / (N - 1) = K(N - 1) / N / (N - 1) = 1 / N`\\n* cost O(N) for getRandom every time\\n* You may wonder since the time complexity is still O(N), why do we have to spend so much. \\n\\t* **In the case of streaming data, we cannot traverse all the data to obtain the length, and then traverse the data again**.\\n\\n\\n![image](https://assets.leetcode.com/users/images/32378933-4a92-4db0-8712-2d9c9dc56e19_1641533644.221645.png)\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def __init__(self, head):\\n        self.head = head\\n\\n    # Reservoir sampling and K == 1\\n    def getRandom(self):  # cost O(n) Time\\n        ans = 0\\n        p, i = self.head, 0\\n        while p:\\n            if random.randint(0, i) == 0: # capacity of the reservoir is 1, because we just need to return a single num\\n                ans = p.val  # replace ans with i-th node.val with probability 1/i\\n            p = p.next\\n\\t\\t\\ti += 1\\n        return ans\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode *head = NULL;\\n    \\n    Solution(ListNode* head) {\\n        this->head = head;\\n    }\\n    \\n    int getRandom() {\\n        int ans = 0, i = 1;\\n        ListNode *p = this->head;\\n        while (p) {\\n            if (rand() % i == 0) ans = p->val; // replace ans with i-th node.val with probability 1/i\\n            i ++;\\n            p = p->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    int N = 0;\\n    ListNode head = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode p = this.head;\\n        int i = 1, ans = 0;\\n        while (p != null) {\\n            if (Math.random() * i < 1) ans = p.val; // replace ans with i-th node.val with probability 1/i\\n            p = p.next;\\n            i ++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Solution 1: convert linked list to a list**\\n* convert linked list to a list, cost O(N) Space and O(N) Time\\n* Randomly generate an index of list, cost O(1)\\n* return the value at the random index\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def __init__(self, head):\\n        self.nodes = []  # convert linked list to a list, cost O(N) Space and O(N) Time\\n        while head:\\n            self.nodes.append(head.val)\\n            head = head.next\\n\\n    def getRandom(self):  # cost O(1) Time\\n        return random.choice(self.nodes)\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    Solution(ListNode* head) {\\n        while (head != NULL) {\\n            nodes.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int i = rand() % this->nodes.size();\\n        return this->nodes[i];\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    ArrayList<Integer> nodes = new ArrayList<Integer>();\\n    public Solution(ListNode head) {\\n        while (head != null) {\\n            nodes.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int i = (int)(Math.random() * this.nodes.size());\\n        return this.nodes.get(i);\\n    }\\n}\\n```\\n\\n\\n**Solution 2: Pre-Count the length of linked list**\\n* Pre-Count the length of linked list, O(N)\\n* Randomly generate an index of list, O(N)\\n* traverse the linked list from head and find the value at the random index \\n\\n**Python**\\n```\\nclass Solution(object):\\n    def __init__(self, head):\\n        self.N = 0  # find out the length of linked list, cost O(1) Space and O(N) Time\\n        self.head = head\\n        while head:\\n            self.N += 1\\n            head = head.next\\n\\n    def getRandom(self):  # cost O(n) Time\\n        n = random.randint(0, self.N - 1)  # randomly choose an index of the list\\n        p = self.head\\n        while n > 0:\\n            p = p.next\\n            n -= 1\\n        return p.val\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int N = 0;\\n    ListNode *head = NULL;\\n    \\n    Solution(ListNode* head) {\\n        this->head = head;\\n        while (head != NULL) {\\n            this->N ++;\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int i = rand() % this->N;\\n        ListNode *p = this->head;\\n        while (i) {\\n            p = p->next;\\n            i -= 1;\\n        }\\n        return p->val;\\n    }\\n};\\n\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    int N = 0;\\n    ListNode head = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        while (head != null) {\\n            this.N ++;\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int i = (int)(Math.random() * this.N);\\n        ListNode p = this.head;\\n        while (i > 0) { \\n            p = p.next;\\n            i -= 1;\\n        }\\n        return p.val;\\n    }\\n}\\n```\\n\\n\\n\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution(object):\\n    def __init__(self, head):\\n        self.head = head\\n\\n    # Reservoir sampling and K == 1\\n    def getRandom(self):  # cost O(n) Time\\n        ans = 0\\n        p, i = self.head, 0\\n        while p:\\n            if random.randint(0, i) == 0: # capacity of the reservoir is 1, because we just need to return a single num\\n                ans = p.val  # replace ans with i-th node.val with probability 1/i\\n            p = p.next\\n\\t\\t\\ti += 1\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *head = NULL;\\n    \\n    Solution(ListNode* head) {\\n        this->head = head;\\n    }\\n    \\n    int getRandom() {\\n        int ans = 0, i = 1;\\n        ListNode *p = this->head;\\n        while (p) {\\n            if (rand() % i == 0) ans = p->val; // replace ans with i-th node.val with probability 1/i\\n            i ++;\\n            p = p->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int N = 0;\\n    ListNode head = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode p = this.head;\\n        int i = 1, ans = 0;\\n        while (p != null) {\\n            if (Math.random() * i < 1) ans = p.val; // replace ans with i-th node.val with probability 1/i\\n            p = p.next;\\n            i ++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def __init__(self, head):\\n        self.nodes = []  # convert linked list to a list, cost O(N) Space and O(N) Time\\n        while head:\\n            self.nodes.append(head.val)\\n            head = head.next\\n\\n    def getRandom(self):  # cost O(1) Time\\n        return random.choice(self.nodes)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    Solution(ListNode* head) {\\n        while (head != NULL) {\\n            nodes.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int i = rand() % this->nodes.size();\\n        return this->nodes[i];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    ArrayList<Integer> nodes = new ArrayList<Integer>();\\n    public Solution(ListNode head) {\\n        while (head != null) {\\n            nodes.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int i = (int)(Math.random() * this.nodes.size());\\n        return this.nodes.get(i);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def __init__(self, head):\\n        self.N = 0  # find out the length of linked list, cost O(1) Space and O(N) Time\\n        self.head = head\\n        while head:\\n            self.N += 1\\n            head = head.next\\n\\n    def getRandom(self):  # cost O(n) Time\\n        n = random.randint(0, self.N - 1)  # randomly choose an index of the list\\n        p = self.head\\n        while n > 0:\\n            p = p.next\\n            n -= 1\\n        return p.val\\n```\n```\\nclass Solution {\\npublic:\\n    int N = 0;\\n    ListNode *head = NULL;\\n    \\n    Solution(ListNode* head) {\\n        this->head = head;\\n        while (head != NULL) {\\n            this->N ++;\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int i = rand() % this->N;\\n        ListNode *p = this->head;\\n        while (i) {\\n            p = p->next;\\n            i -= 1;\\n        }\\n        return p->val;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    int N = 0;\\n    ListNode head = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        while (head != null) {\\n            this.N ++;\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int i = (int)(Math.random() * this.N);\\n        ListNode p = this.head;\\n        while (i > 0) { \\n            p = p.next;\\n            i -= 1;\\n        }\\n        return p.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278159,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo select a random node from a singly linked list, one way is to traverse the list and count the number of nodes. Then, we can generate a random number between 1 and the count and traverse the list again, selecting the node at the index equal to the random number. This approach requires two traversals of the list, which can be inefficient for a large list.\\n\\nA better approach is to traverse the list only once and select a random node during the traversal. We can use reservoir sampling to select a random node with equal probability. The idea is to keep track of the current randomly selected node and replace it with a new node with probability 1/i, where i is the index of the current node. At the end of the traversal, the current randomly selected node is the one we want to return.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the head of the linked list in the constructor of the `Solution` class.\\n2. Traverse the linked list, keeping track of the current randomly selected node.\\n3. At each node, generate a random number between 1 and the index of the node (inclusive).\\n4. If the random number is equal to 1, update the current randomly selected node to be the current node.\\n5. Return the value of the current randomly selected node at the end of the traversal.\\n\\n# Complexity\\n- Time complexity: The solution traverses the entire linked list once, and generates a random number at each node, which takes $$O(1)$$ time. Therefore, the time complexity of the `getRandom` function is $$O(N)$$, where N is the number of nodes in the linked list.\\n- Space complexity: The solution only uses constant extra space to store the current randomly selected node, the current node, and the index of the current node. Therefore, the space complexity of the `Solution` class is $$O(1)$$.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n\\nclass Solution {\\n    private ListNode head;\\n    private Random random;\\n\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        random = new Random();\\n    }\\n\\n    public int getRandom() {\\n        int count = 0;\\n        int result = 0;\\n        ListNode curr = head;\\n\\n        while (curr != null) {\\n            count++;\\n            // generate a random number between 1 and the count\\n            // if the random number is 1, update the result with the current node\\'s value\\n            if (random.nextInt(count) == 0) {\\n                result = curr.val;\\n            }\\n            curr = curr.next;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```\\n```Python []\\n\\n\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        \"\"\"\\n        self.head = head\\n\\n    def getRandom(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        result = None\\n        curr = self.head\\n\\n        while curr:\\n            count += 1\\n            # generate a random number between 1 and the count\\n            # if the random number is 1, update the result with the current node\\'s value\\n            if random.randint(1, count) == 1:\\n                result = curr.val\\n            curr = curr.next\\n\\n        return result\\n\\n```\\n```C++ []\\n\\n\\nclass Solution {\\nprivate:\\n    ListNode* head;\\n    \\npublic:\\n    Solution(ListNode* head) {\\n        this->head = head;\\n        std::srand(std::time(0)); // seed the random number generator\\n    }\\n    \\n    int getRandom() {\\n        int count = 0;\\n        int result = 0;\\n        ListNode* curr = head;\\n        \\n        while (curr) {\\n            count++;\\n            // generate a random number between 1 and the count\\n            // if the random number is 1, update the result with the current node\\'s value\\n            if (std::rand() % count == 0) {\\n                result = curr->val;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List",
                    "Randomized"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n\\nclass Solution {\\n    private ListNode head;\\n    private Random random;\\n\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        random = new Random();\\n    }\\n\\n    public int getRandom() {\\n        int count = 0;\\n        int result = 0;\\n        ListNode curr = head;\\n\\n        while (curr != null) {\\n            count++;\\n            // generate a random number between 1 and the count\\n            // if the random number is 1, update the result with the current node\\'s value\\n            if (random.nextInt(count) == 0) {\\n                result = curr.val;\\n            }\\n            curr = curr.next;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```\n```Python []\\n\\n\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        \"\"\"\\n        self.head = head\\n\\n    def getRandom(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        result = None\\n        curr = self.head\\n\\n        while curr:\\n            count += 1\\n            # generate a random number between 1 and the count\\n            # if the random number is 1, update the result with the current node\\'s value\\n            if random.randint(1, count) == 1:\\n                result = curr.val\\n            curr = curr.next\\n\\n        return result\\n\\n```\n```C++ []\\n\\n\\nclass Solution {\\nprivate:\\n    ListNode* head;\\n    \\npublic:\\n    Solution(ListNode* head) {\\n        this->head = head;\\n        std::srand(std::time(0)); // seed the random number generator\\n    }\\n    \\n    int getRandom() {\\n        int count = 0;\\n        int result = 0;\\n        ListNode* curr = head;\\n        \\n        while (curr) {\\n            count++;\\n            // generate a random number between 1 and the count\\n            // if the random number is 1, update the result with the current node\\'s value\\n            if (std::rand() % count == 0) {\\n                result = curr->val;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672070,
                "title": "c-easy-to-solve-beginner-friendly-with-few-imp-notes",
                "content": "**Reframing the question:-**\\n> **Return a random node from linked list. Each node should have same probability to get chosen .**\\n \\n<mark>**NOTE:** I think this question has some missing information .Let\\'s discuss them at the end of post for better understanding. Don\\'t skip the middle part ;)</mark>\\n***\\n**Intuition :-**\\n* One way to solve this question can be that, we first traverse the entire linkedlist and thus we get to know the length of linkedlist .After ths we just call a random node with the help of `rand( )%length` .\\n* The second way is not something that comes with intuition it\\'s something that needs to be informed and this method is the famous **reservoir sampling method .** \\n***\\n**The Reservoir sampling method:-**\\n> It\\'s not a tough algo it\\'s just that we usually don\\'t know this . So before starting let\\'s discuss a bit about probability . \\n* When we read the first node head, if the stream ListNode stops here, we can just return the head->val. The probability of picking here is 1/1 .\\n* When we goto second node we can decide if we replace the `result r` or not. The possibility is 1/2. So now we need to genereate a random number between 0 & 1 and if it is equals to 1 replace r with the current node else we don\\'t traumantize r, so it\\'s value is till the value of head .\\n* Now let\\'s goto third node and we can decide if we can replace the `result r or not` . The probability of picking the third node will be 1/3 . and not picking up will be 2/3 . So now we generate a random number between 0-to-2 if the result is 2 then we replace r with the `value of indexed node 2`\\n* We need to continue this till the end of list node .\\n* *To conclude, if we have n different balls than the equal probability of picking any one of them will be 1/n .* \\n* Now that\\'s it, this is what reservoir sampling method looks like, told you its easy ;)\\n***\\n**Code:-**\\n* why rand()%len is used? `creddit @archdevil`\\n>rand() % len will be 0 only if rand() returns 0 or some multiple of len. For both these events, the probability is 1/len which makes it a valid random choice!!!      `credit @ziner`\\n```\\nclass Solution {\\npublic:\\n    //Note : head is guaranteed to be not null, so it contains at least one node.\\n    ListNode* HeadNode;\\n    Solution(ListNode* head) {\\n       HeadNode = head;\\n    }\\n    //returns value of a random node\\n    int getRandom() {\\n        int res, len = 1;\\n        ListNode* x = HeadNode;\\n        while(x){\\n            if(rand() % len == 0){\\n                res = x->val;\\n            }\\n            len++;\\n            x = x->next;\\n        }\\n        return res;\\n    }\\n};\\n```\\n***\\n**Time Complexity:** *`O(n)`*\\n**Space Complexity:** *`O(1)`*\\n***\\n***\\n**A brute force approach code :- Special thanks to @Bahubali**\\n* We take a orderedmap in which the key is index and the value is linkednodes\\n* Then we traverse the whole linkedlist and store the nodes values inside the map. and then we search random with the help of `mp[rand()%n]->val;`\\n* **Advantage / Disadvantage :-** This approach is a good fit for static data where we know the total number of nodes but is not a good fit where there is dynammic data, such as some online streaming data where the nodes continues to get added and relinked with the user commands .\\n```\\nclass Solution {\\npublic:\\n    map<int,ListNode*> mp;\\n    Solution(ListNode* head) \\n    {\\n        ListNode *temp = head;\\n        int i=0;\\n        while(temp)\\n        {\\n           mp[i++]=temp;\\n           temp=temp->next;\\n        }    \\n    }\\n\\n    int getRandom() \\n    {\\n        int n = mp.size();\\n        return mp[rand()%n]->val;    \\n    }\\n};\\n```\\n**Time and Space :** *`O(n) [Where n is the number of nodes]`*\\n***\\n***\\nSome **important points:-**\\n**There are some flaws with this question, to be precise many missing informations :-**\\n1. How can we say it has equal probability without having a chance to visit till the last node?\\n> ***My point of view:-*** I saw many solutions including mine which checked the length in runtime of linkedlist[Inside the getRandom() functon]. But i felt it\\'s defying  the purspose of this question\\n\\n2. The nature of data should have been mentioned in the question, don\\'t you think?\\n* If we are considering an static data then it would be better to know the length of linkedlist than do the randomize search .\\n* If we are considering an Dynamic online data streaming which increases or decrease on the basis of user then reservior sampling is a good choice .\\n***\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote ;)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Note : head is guaranteed to be not null, so it contains at least one node.\\n    ListNode* HeadNode;\\n    Solution(ListNode* head) {\\n       HeadNode = head;\\n    }\\n    //returns value of a random node\\n    int getRandom() {\\n        int res, len = 1;\\n        ListNode* x = HeadNode;\\n        while(x){\\n            if(rand() % len == 0){\\n                res = x->val;\\n            }\\n            len++;\\n            x = x->next;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<int,ListNode*> mp;\\n    Solution(ListNode* head) \\n    {\\n        ListNode *temp = head;\\n        int i=0;\\n        while(temp)\\n        {\\n           mp[i++]=temp;\\n           temp=temp->next;\\n        }    \\n    }\\n\\n    int getRandom() \\n    {\\n        int n = mp.size();\\n        return mp[rand()%n]->val;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956872,
                "title": "python-reservoir-sampling-follow-up-explained",
                "content": "Let us solve this question for follow-up question: we do not want to use additional memory here. There is specific method for this, whith is called **reservoir sampling** (actually, special case of it), which I am going to explain now. Imagine, that we have only `3` nodes in our linked list, then we do the following logic:\\n1. On the first step we either stay in first node with probability `1/2` or go to the next one also with probability `1/2`.\\n2. On the second step, we do the following: if we are in node number **1**, then we stay in this node with probability `2/3` and go to node number **2** with probability `1/3`. If we in node number **2**, then we stay in it with probability `1/3` and go to node number **3** with probability `2/3`. Why everything will be OK? There is only one way, how you can stay in node **1**, and probability is `1/2 * 2/3`. There are two cases, how you can go to node number **2**: stay on first step and go on second and go on first step and stay on second: probability will be `1/2*1/3 + 1/2*1/3 = 1/3`. Finally, probability to be in node **3** is also `1/3`.\\n\\nNow, imagine, that we already covered `n` nodes and we have probabilites: `1/n, 1/n, ..., 1/n`. Then we need to make one more step and have probabilites `1/(n+1), 1/(n+1), ... , 1/(n+1)`. How we can do it?\\n   1. If we are in the first node, we stay in it with probability `n/(n+1)` and go next with probability `1/(n+1)`.\\n\\n   2. If we are in the second node, we stay in it with probability `(n-1)/(n+1)` and go next with probability `2/(n+1)`.\\n\\n      n. If we are in node `n`, we stai in it with probability `1/(n+1)` and go next with probability `n/(n+1)`.\\n\\nWhy it is working? There is only one way how you can be in node **1**: with probability `1/n* n/(n+1) = 1/(n+1)`. There is two options for node **2**, with probability `1/n*(n-1)/(n+1) + 1/n* 1/(n+1) = 1/(n+1)` and so on.\\n\\nFinally, let us go to the code: we keep `n` and `k` values: `n` is number of nodes we count in list so far and `k` is current node we are in. Each moment of time we decide if we go to next node or rest in current. If we go to next, we increase `k` by one and change our `ans` node. Increase `n` in any case.\\n\\n**Complexity**: time compexity is `O(n)` and you can not really do anything with if you are not allowed to use extra memory. Space complexity however only `O(1)`, if we do not count our input.\\n\\n```\\nclass Solution:\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        n, k = 1, 1\\n        head, ans = self.head, self.head\\n        while head.next:\\n            n += 1\\n            head = head.next\\n            if random.random() < k/n:\\n                ans = ans.next\\n                k += 1\\n                \\n        return ans.val\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        n, k = 1, 1\\n        head, ans = self.head, self.head\\n        while head.next:\\n            n += 1\\n            head = head.next\\n            if random.random() < k/n:\\n                ans = ans.next\\n                k += 1\\n                \\n        return ans.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85690,
                "title": "using-reservoir-sampling-o-1-space-o-n-time-complexity-uff0cc",
                "content": "according  to the wiki https://en.wikipedia.org/wiki/Reservoir_sampling\\nhere is sudo code for k size reservoir:\\n```\\n/*\\n  S has items to sample, R will contain the result\\n*/\\nReservoirSample(S[1..n], R[1..k])\\n  // fill the reservoir array\\n  for i = 1 to k\\n      R[i] := S[i]\\n\\n  // replace elements with gradually decreasing probability\\n  for i = k+1 to n\\n    j := random(1, i)   // important: inclusive range\\n    if j <= k\\n        R[j] := S[i]\\n```\\nyou need to remember  the range [ 0, i ] should be inclusive.\\n```\\nclass Solution {\\nprivate:\\n    ListNode* head;\\npublic:\\n    /** @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        this->head = head;\\n    }\\n    \\n    /** Returns a random node's value. */\\n    int getRandom() {\\n        int res = head->val;\\n        ListNode* node = head->next;\\n        int i = 2;\\n        while(node){\\n            int j = rand()%i;\\n            if(j==0)\\n                res = node->val;\\n            i++;\\n            node = node->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n  S has items to sample, R will contain the result\\n*/\\nReservoirSample(S[1..n], R[1..k])\\n  // fill the reservoir array\\n  for i = 1 to k\\n      R[i] := S[i]\\n\\n  // replace elements with gradually decreasing probability\\n  for i = k+1 to n\\n    j := random(1, i)   // important: inclusive range\\n    if j <= k\\n        R[j] := S[i]\\n```\n```\\nclass Solution {\\nprivate:\\n    ListNode* head;\\npublic:\\n    /** @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        this->head = head;\\n    }\\n    \\n    /** Returns a random node's value. */\\n    int getRandom() {\\n        int res = head->val;\\n        ListNode* node = head->next;\\n        int i = 2;\\n        while(node){\\n            int j = rand()%i;\\n            if(j==0)\\n                res = node->val;\\n            i++;\\n            node = node->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278243,
                "title": "java-using-reservoir-sampling",
                "content": "**Using Extra Space (T.C :- O(N) and S.C :- O(N))**\\n```\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        double rand=Math.random()*list.size();\\n        return list.get((int)rand);\\n    }\\n}\\n```\\n**Without using Extra Space (T.C :- O(N) and S.C :- O(1))**\\n**You can read about Reservoir Sampling from here :- https://en.wikipedia.org/wiki/Reservoir_sampling**\\n```\\nclass Solution {\\n    ListNode head;\\n    public Solution(ListNode head) {\\n        this.head=head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode node=head;\\n        int counter=0, res=0;\\n        while (node!=null){\\n            // R. Algo: k/k+counter probablity to be put into reservoir. where k is the size of reservoir=1\\n            counter++;\\n            if ((int)(Math.random()*counter)==0) res=node.val;\\n            node=node.next;\\n        }\\n        return res;       \\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/12a4846d-1ee7-4ef1-82fc-045947f75751_1678410976.6868176.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        double rand=Math.random()*list.size();\\n        return list.get((int)rand);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    ListNode head;\\n    public Solution(ListNode head) {\\n        this.head=head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode node=head;\\n        int counter=0, res=0;\\n        while (node!=null){\\n            // R. Algo: k/k+counter probablity to be put into reservoir. where k is the size of reservoir=1\\n            counter++;\\n            if ((int)(Math.random()*counter)==0) res=node.val;\\n            node=node.next;\\n        }\\n        return res;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966810,
                "title": "valid-mountain-array-o-n-time-space-o-1-4-lines-code",
                "content": "**If you llike my solution please upvote it it will inspire me.**\\n```\\nclass Solution {\\n    public boolean validMountainArray(int[] arr) {\\n        int i=0,j=arr.length-1;     //i forward pointer ,j backward\\n        while(i<arr.length-1&&arr[i]<arr[i+1])  i++;    //increase i untill the next value is decreased\\n        while(j>0&&arr[j-1]>arr[j]) j--;    //decrease j untill the next value is decreased from back\\n        return i>0&&j<arr.length-1&&i==j;   //return if i and j are equal\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validMountainArray(int[] arr) {\\n        int i=0,j=arr.length-1;     //i forward pointer ,j backward\\n        while(i<arr.length-1&&arr[i]<arr[i+1])  i++;    //increase i untill the next value is decreased\\n        while(j>0&&arr[j-1]>arr[j]) j--;    //decrease j untill the next value is decreased from back\\n        return i>0&&j<arr.length-1&&i==j;   //return if i and j are equal\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671967,
                "title": "2-ways-java-c-python-javascript-easy-for-mind-to-accept-it",
                "content": "**First of all understand the problem:**\\n* Given a data stream, the data stream length N is very large, how to randomly select k data from it, and ensure that each data is extracted with the same probability.\\nAttention: Data stream length N is large, memory may not load all data\\n\\n\\n**Solution 1: Brute {Using Array}**\\n\\n*`Remember this is a solution which uses extra space ** BUT ** it is easier to implement`*\\n\\n**Explaination:**\\nSo here we are doing something really simple,\\n\\nIn the constructor function we just add all the items in the Linked List to a public Array called **\\'res\\'**.\\nNow, within the getRandom() function, we just make use of this **\\'res\\'** array and use the **Math library.**\\n\\nHere, **Math.random() generates random numbers between 0 and 1.**\\n\\nFor **further part**, read according to your **Specific Language**\\n\\n* `Java Only` ***Different language user can even read as well. To get more better understanding***\\nWe can restrict this to generating the random numbers between 0 and 3 (say for example the length of the arrayList is 4, the index in the array will be from 0 to 3 for 4 List elements stored inside it).\\nWe just need to **multiply the length of the array(list) to Math.random() to generate random numbers between 0 and 3.**\\nBut this multiplication between Math.random() and length of the list will ca**use decimal(floating point) numbers,** for which we use **typecasting of int** in the beginning to **remove this decimal and round off the number to the lower whole number.**\\n\\n* `For C++`\\nNow take **modulo** of LinkedList size with Array size. So, the **range become 0 to n - 1**\\nWhy we doing that as we have to **return array value**\\n\\n* `For Python`\\nThe choices() method returns a list with the randomly selected element from the **specified sequence**\\nAs we want in **range of 0 to n - 1**\\n\\n* `For JavaScript`\\nThe multiplication between Math.random() and length of the list will **cause decimal(floating point) numbers**, for which we use **Math.floor()** in the end to remove this decimal and **round off the number to the lower whole number.**\\n\\n**Java**\\n```\\nclass Solution {\\n    ArrayList<Integer> res = new ArrayList<>(); \\n    public Solution(ListNode head) { \\n        while(head != null){ // Storing all the values by iterating over the LinkedList\\n            res.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    // \\n    public int getRandom() { \\n        //Math.random() will generate a random number b/w 0 & 1.\\n        //then multiply it with the array size, as i have all the value in the list, i know the size of the list\\n        //take only the integer part which is a random index.\\n        //return the element at that random index.\\n        return res.get((int)(Math.random() * res.size()));\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> res; \\n    Solution(ListNode* head) { \\n        while(head){ // Storing all the values by iterating over the LinkedList\\n            res.push_back(head->val);\\n            head=head->next;\\n        }\\n    }\\n    \\n    int getRandom() { \\n        //rand() will generate a random number b/w 0 & RAND_MAX\\n        //then take modulo of LinkedList size with Array size. So, the range become 0 to n - 1\\n        //why we doing that as we have to return array value\\n        return res[rand()%res.size()];\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n\\n\\tdef __init__(self, head: Optional[ListNode]): \\n\\t\\tself.list = head\\n\\t\\tres = [] \\n\\t\\tnode = self.list\\n\\t\\twhile (node): # Storing all the values by iterating over the LinkedList\\n\\t\\t\\tres.append(node.val)\\n\\t\\t\\tnode = node.next  \\n\\t\\tself.res = res\\n\\n\\tdef getRandom(self) -> int:\\n        # The choices() method returns a list with the randomly selected element from the specified sequence.\\n        # As we want in range of 0 to n - 1\\n\\t\\treturn random.choice(self.res)\\n\\n```\\n**JavaScript**\\n```\\nvar Solution = function(head) {\\n        this.res = []; \\n        let curr = head;  \\n        \\n        while(curr !== null) {\\n            this.res.push(curr)\\n            curr = curr.next;\\n        }\\n        this.length = this.res.length; \\n};\\n\\nSolution.prototype.getRandom = function() {\\n    //Math.random() will generate a random number b/w 0 & 1.\\n    //then multiply it with the array size, as i have all the value in the list, i know the size of the list\\n    //take only the integer part which is a random index.\\n    //return the element at that random index.\\n    return this.res[Math.floor(Math.random() * this.length)].val\\n};\\n```\\nOverall Complexity Analysis :\\n* **Time Complexity :-** BigO(N) for `intialisation` ; BigO(1) for `getRandom`\\n\\n* **Space Complexity :-** BigO(N)\\n\\n\\n```\\nBut What if ! the linked list is extremely large and its length is unknown to you?\\nAs, in that scenario the memory it consumes will be very great.\\n```\\n\\n`*So, in order to remove extra space usage we will Use an Concept called*` **Reservoir Sampling**\\n\\n**Solution 2 : Optimal {Reservoir Sampling}**\\n\\n**Explaination:**\\n\\n![image](https://assets.leetcode.com/users/images/54460a3d-204a-4462-8c38-e1fca5c3240b_1641520910.056722.png)\\n\\n![image](https://assets.leetcode.com/users/images/d39c9292-8b75-4cd5-867c-e725a65ec486_1641520932.0541327.png)\\n\\n```\\nProbability of selecting k from i items = k / i\\nOnce, we have calculated that probability we will keep it side & move to the next element i.e. 4\\n```\\n![image](https://assets.leetcode.com/users/images/a7d86fc6-ba73-40e0-bf1e-f0ae817a7385_1641521009.9354758.png)\\n\\n* `Thus, Probability of this item replacing value in reservoir = 1 / k`\\n* `Probability to selecting a value from i + 1 values and that replacing the value in reservoir = k / i + 1 * 1 / k = 1 / i + 1`\\n* `And the Probability to selecting a value from i + 1 values and that not replacing the value in reservoir = 1 - (1 / i + 1) = i / i + 1`\\n* `So, now all the values in reservoir are the values which were selected and not replaced. SO, k / i * i / i + 1 = k / i + 1`\\n* Which is an equal probability for all values to  be the part of reservoir.\\n\\n* `The highest value in above example of i = 9, so i + 1 becomes 10 i.e. N & k = 3.`\\n* `So, probability of every value becomes 3 / 10.`\\n* The question we have can use reservoir sampling, because we can consider the reservoir to be 1 when the value of k is 1, the probability of each value selected is equal.\\n\\n*Now, let\\'s code it!*\\n\\n**Java**\\n```\\nclass Solution {\\n    ListNode head = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode curr = head;\\n        int index = 1;\\n        int res = 0;\\n        while(curr != null){\\n            if(Math.random() < 1.0 / index){\\n                // take this value\\n                res = curr.val;\\n            }\\n            index++;\\n            curr = curr.next;\\n        }\\n        return res;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* u;\\n    Solution(ListNode* head) {\\n        u = head;\\n    }\\n    \\n    int getRandom() {\\n        int index = 1;\\n        int res = 0;\\n        ListNode* curr = u;\\n        while(curr){\\n            if(rand() % index == 0){\\n                res = curr->val;\\n            }\\n            index++;\\n            curr = curr->next;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Python**\\n```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        \\n        # Note that the head is guaranteed to be not null, so it contains at least one node.\\n\\n        self.head = head\\n\\n    def getRandom(self) -> int:\\n       \\n        # Returns a random node\\'s value.\\n        \\n        curr = self.head\\n        res = 0\\n        index = 1\\n        \\n        while curr:\\n            if random.random() < (1/index):\\n                res = curr.val\\n            \\n            index += 1\\n            curr = curr.next\\n        \\n        return res\\n```\\nOverall Complexity Analysis :\\n* **Time Complexity :-** BigO(1) for `initalisation` ; BigO(N) for `getRandom`\\n\\n* **Space Complexity :-** BigO(1)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<Integer> res = new ArrayList<>(); \\n    public Solution(ListNode head) { \\n        while(head != null){ // Storing all the values by iterating over the LinkedList\\n            res.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    // \\n    public int getRandom() { \\n        //Math.random() will generate a random number b/w 0 & 1.\\n        //then multiply it with the array size, as i have all the value in the list, i know the size of the list\\n        //take only the integer part which is a random index.\\n        //return the element at that random index.\\n        return res.get((int)(Math.random() * res.size()));\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> res; \\n    Solution(ListNode* head) { \\n        while(head){ // Storing all the values by iterating over the LinkedList\\n            res.push_back(head->val);\\n            head=head->next;\\n        }\\n    }\\n    \\n    int getRandom() { \\n        //rand() will generate a random number b/w 0 & RAND_MAX\\n        //then take modulo of LinkedList size with Array size. So, the range become 0 to n - 1\\n        //why we doing that as we have to return array value\\n        return res[rand()%res.size()];\\n    }\\n};\\n```\n```\\nclass Solution:\\n\\n\\tdef __init__(self, head: Optional[ListNode]): \\n\\t\\tself.list = head\\n\\t\\tres = [] \\n\\t\\tnode = self.list\\n\\t\\twhile (node): # Storing all the values by iterating over the LinkedList\\n\\t\\t\\tres.append(node.val)\\n\\t\\t\\tnode = node.next  \\n\\t\\tself.res = res\\n\\n\\tdef getRandom(self) -> int:\\n        # The choices() method returns a list with the randomly selected element from the specified sequence.\\n        # As we want in range of 0 to n - 1\\n\\t\\treturn random.choice(self.res)\\n\\n```\n```\\nvar Solution = function(head) {\\n        this.res = []; \\n        let curr = head;  \\n        \\n        while(curr !== null) {\\n            this.res.push(curr)\\n            curr = curr.next;\\n        }\\n        this.length = this.res.length; \\n};\\n\\nSolution.prototype.getRandom = function() {\\n    //Math.random() will generate a random number b/w 0 & 1.\\n    //then multiply it with the array size, as i have all the value in the list, i know the size of the list\\n    //take only the integer part which is a random index.\\n    //return the element at that random index.\\n    return this.res[Math.floor(Math.random() * this.length)].val\\n};\\n```\n```\\nBut What if ! the linked list is extremely large and its length is unknown to you?\\nAs, in that scenario the memory it consumes will be very great.\\n```\n```\\nProbability of selecting k from i items = k / i\\nOnce, we have calculated that probability we will keep it side & move to the next element i.e. 4\\n```\n```\\nclass Solution {\\n    ListNode head = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode curr = head;\\n        int index = 1;\\n        int res = 0;\\n        while(curr != null){\\n            if(Math.random() < 1.0 / index){\\n                // take this value\\n                res = curr.val;\\n            }\\n            index++;\\n            curr = curr.next;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* u;\\n    Solution(ListNode* head) {\\n        u = head;\\n    }\\n    \\n    int getRandom() {\\n        int index = 1;\\n        int res = 0;\\n        ListNode* curr = u;\\n        while(curr){\\n            if(rand() % index == 0){\\n                res = curr->val;\\n            }\\n            index++;\\n            curr = curr->next;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        \\n        # Note that the head is guaranteed to be not null, so it contains at least one node.\\n\\n        self.head = head\\n\\n    def getRandom(self) -> int:\\n       \\n        # Returns a random node\\'s value.\\n        \\n        curr = self.head\\n        res = 0\\n        index = 1\\n        \\n        while curr:\\n            if random.random() < (1/index):\\n                res = curr.val\\n            \\n            index += 1\\n            curr = curr.next\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85701,
                "title": "o-n-time-o-1-space-java-solution",
                "content": "```\\nimport java.util.*;\\npublic class Solution {\\n\\n    /** @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. */\\n    ListNode head = null;\\n    Random randomGenerator = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        this.randomGenerator = new Random();\\n\\n    }\\n    \\n    /** Returns a random node's value. */\\n    public int getRandom() {\\n        ListNode result = null;\\n        ListNode current = head;\\n        \\n        for(int n = 1; current!=null; n++) {\\n            if (randomGenerator.nextInt(n) == 0) {\\n                result = current;\\n            }\\n            current = current.next;\\n        }\\n        \\n        return result.val;\\n        \\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\npublic class Solution {\\n\\n    /** @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. */\\n    ListNode head = null;\\n    Random randomGenerator = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        this.randomGenerator = new Random();\\n\\n    }\\n    \\n    /** Returns a random node's value. */\\n    public int getRandom() {\\n        ListNode result = null;\\n        ListNode current = head;\\n        \\n        for(int n = 1; current!=null; n++) {\\n            if (randomGenerator.nextInt(n) == 0) {\\n                result = current;\\n            }\\n            current = current.next;\\n        }\\n        \\n        return result.val;\\n        \\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671889,
                "title": "python3-reservoir-sampling-explained",
                "content": "In the follow-up, the problem asks us to find an algorithm for an extremely large list and with no additional space. This immediately recalls us about reservoir sampling - an online algorithm for uniformly choosing `k` random elements from a stream. In our case, `k` is equal to 1 (we need to sample just one element). We create a reservoir and put there the first node. Then iterate over nodes and replace the node in the reservoir with the current one with probability `1/i`, where `i` is the index of the current node. In the end, we end up with the reservoir containing a node chosen with the uniform probability `1/n`, where `n` is the number of nodes.\\n\\n<img src=\"https://assets.leetcode.com/users/images/062defda-d542-4aec-9708-126a21f3fd26_1641516842.6092827.jpeg\" width=\"500\">\\n\\nWhy does it work? Intuitively we can see that elements from the start of the list can get to the reservoir relatively easily since the probability is pretty high at the beginning. But to stay there they have to survive the whole list of elements in front of them. The actual math proof can be found in this article https://florian.github.io/reservoir-sampling/\\n\\nTime: **O(n)** - scan\\nSpace: **O(1)** - nothing is stored\\n\\nRuntime: 80 ms, faster than **71.58%** of Python3 online submissions for Linked List Random Node.\\nMemory Usage: 17.2 MB, less than **85.41%** of Python3 online submissions for Linked List Random Node.\\n\\n```\\nclass Solution:\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head = head\\n        \\n    def getRandom(self) -> int:\\n        reservoir = self.head.val\\n        \\n        i = 2\\n        next = self.head.next\\n        while next:\\n            if random.random() < 1/i:\\n                reservoir = next.val\\n                \\n            i += 1\\n            next = next.next\\n            \\n        return reservoir\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head = head\\n        \\n    def getRandom(self) -> int:\\n        reservoir = self.head.val\\n        \\n        i = 2\\n        next = self.head.next\\n        while next:\\n            if random.random() < 1/i:\\n                reservoir = next.val\\n                \\n            i += 1\\n            next = next.next\\n            \\n        return reservoir\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85718,
                "title": "python-reservoir-sampling-solution-when-the-length-of-linked-list-changes-dynamically",
                "content": "The problem is a little ambiguous. In the interview, you should ask clearly whether the list length is unknown but static or it is unknown and dynamically changing. In the first case, you can simply precompute the length and generate random indices based on that. It is faster than the reservior sampling solution.\\n\\nIf the list length changes dynamically, reservior sampling is a good choice. If you are not familiar with it, check [here](http://www.geeksforgeeks.org/reservoir-sampling/).\\n\\n```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        result, node, index = self.head, self.head.next, 1\\n        while node:\\n            if random.randint(0, index) is 0:\\n                result = node\\n            node = node.next\\n            index += 1\\n        return result.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        result, node, index = self.head, self.head.next, 1\\n        while node:\\n            if random.randint(0, index) is 0:\\n                result = node\\n            node = node.next\\n            index += 1\\n        return result.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980929,
                "title": "smallest-range-ii-python-5loc-with-pictorial-explanation-o-n-log-n-time-memory-beats-99-40",
                "content": "First sort `a` in ascending order. Then the best strategy is to flip the direction from `+k` to `-k` at certain point going from the smallest to the largest element. \\n\\nWe can go through the sorted array and enumerate all the possible changing point. At each adjacent numbers `x` and `y`, the numbers that will affect the range are `cands = [a[0]+k, x+k, y-k, a[-1]-k]`. We can simply compute `max(cands) - min(cands)`, or, to be a little bit smarter, notice that `a[0]+k < x+k` and `y-k < a[-1]-k` and thus only `a[0]+k` or `y-k` could be the min and only `x+k` and `a[-1]-k` could be the max.\\n\\nDon\\'t forget the possibility of `+k` (or `-k`) for all the elements in `a`, which will give `max(a) - min(a)`, or when `a` is sorted, just `a[-1] - a[0]`. \\n\\nBelow we show pictorial explanations for two sample cases where 1) `a=[1,4,8,10]`, `k=3`, flipping between `4` and `8`; and 2) `a=[2,2,4,7,8]`, `k=5`, flipping between `4` and `7`.\\n\\n<!--![image](https://assets.leetcode.com/users/images/b88c54f2-6322-4a4e-9317-af4bcbe93626_1608587613.589505.png)-->\\n<!--![image](https://assets.leetcode.com/users/images/5159a0f3-fdf9-4304-a9cc-0e1892864870_1608587613.4293087.png)-->\\n<img src=\"https://assets.leetcode.com/users/images/b88c54f2-6322-4a4e-9317-af4bcbe93626_1608587613.589505.png\" width=45%>\\n<img src=\"https://assets.leetcode.com/users/images/5159a0f3-fdf9-4304-a9cc-0e1892864870_1608587613.4293087.png\" width=45%>\\n\\n\\n```python\\nclass Solution:\\n    def smallestRangeII(self, a: List[int], k: int) -> int:\\n        a.sort()\\n        ans = a[-1] - a[0]\\n        for x, y in zip(a, a[1:]):\\n            ans = min(ans, max(a[-1]-k, x+k) - min(a[0]+k, y-k))\\n        return ans\\n```\\n\\nComplexity: n being the length of `a`. Sorting costs O(n log n) time. Looping through sorted `a` costs O(n) time. In total, it costs O(n log n) time. Extra space is O(1) -- just `ans` (and `x`, `y` if strict).\\n\\n---\\nIf you find this helpful, please consider **upvote**. It will encourage me to write more explanations like this. Thank you! \\uD83E\\uDD17\\n\\n[20201222] You can find a justification for the strategy in [this comment](https://leetcode.com/discuss/explore/december-leetcoding-challenge/980929/Smallest-Range-II%3A-Python-5LoC-with-Pictorial-Explanation-O(n-log-n)-Time-Memory-Beats-99.40/796292).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestRangeII(self, a: List[int], k: int) -> int:\\n        a.sort()\\n        ans = a[-1] - a[0]\\n        for x, y in zip(a, a[1:]):\\n            ans = min(ans, max(a[-1]-k, x+k) - min(a[0]+k, y-k))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85673,
                "title": "buffered-reservoir-sampling",
                "content": "As I pointed out [earlier](https://discuss.leetcode.com/topic/53795/reservoir-sampling-seems-inefficient), reservoir sampling can seem inefficient presumably due to the many requests to the random number generator. My naive count+pick took about 180 ms, much faster than the reservoir sampling solutions taking about 400 ms or more. So I created a buffered way, where I update the random pick only every 100 nodes. Takes about 200 ms now. So still slower than the naive count+pick, but might be advantageous in some situations because it doesn't traverse the list twice.\\n```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        node = self.head\\n        before = 0\\n        buffer = [None] * 100\\n        while node:\\n            now = 0\\n            while node and now < 100:\\n                buffer[now] = node\\n                node = node.next\\n                now += 1\\n            r = random.randrange(now + before)\\n            if r < now:\\n                pick = buffer[r]\\n            before += now\\n        return pick.val\\n```\\n\\n**C++ version:** (takes about 61 ms)\\n```\\nclass Solution {\\npublic:\\n    Solution(ListNode* head) : head(head) {}\\n    \\n    int getRandom() {\\n        ListNode *node = head, *buffer[100], *pick;\\n        for (int before=0; node; before+=100) {\\n            int now = 0;\\n            while (node && now < 100) {\\n                buffer[now++] = node;\\n                node = node->next;\\n            }\\n            int r = rand() % (now + before);\\n            if (r < now)\\n                pick = buffer[r];\\n        }\\n        return pick->val;\\n    }\\nprivate:\\n    ListNode* head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        node = self.head\\n        before = 0\\n        buffer = [None] * 100\\n        while node:\\n            now = 0\\n            while node and now < 100:\\n                buffer[now] = node\\n                node = node.next\\n                now += 1\\n            r = random.randrange(now + before)\\n            if r < now:\\n                pick = buffer[r]\\n            before += now\\n        return pick.val\\n```\n```\\nclass Solution {\\npublic:\\n    Solution(ListNode* head) : head(head) {}\\n    \\n    int getRandom() {\\n        ListNode *node = head, *buffer[100], *pick;\\n        for (int before=0; node; before+=100) {\\n            int now = 0;\\n            while (node && now < 100) {\\n                buffer[now++] = node;\\n                node = node->next;\\n            }\\n            int r = rand() % (now + before);\\n            if (r < now)\\n                pick = buffer[r];\\n        }\\n        return pick->val;\\n    }\\nprivate:\\n    ListNode* head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278231,
                "title": "basic-probability-to-advanced-random-sampling",
                "content": "# Intuition\\nA random node has to be returned everytime, with each node having an equal probability of getting selected. If we consider the length of the linked list, generate a number between it\\'s length, and return the node at that position, we will have fulfilled all the constraints\\n\\n# Approach\\nStore the list elements into an ArrayList for quick access, generate a random number and use it as the index.\\n\\n```\\nint i = (int)(Math.random() * this.nodes.size());\\n```\\nSelf-explanatory step, generate the number i randomly, use it as index and return the node at that index.\\n\\n**Time:$$O(N)$$**\\n**Space: $$O(N)$$**\\nN-> Size of the list\\n\\n# Code\\n\\n\\n\\n```Java []\\nclass Solution {\\n    ArrayList<Integer> nodes = new ArrayList<Integer>();\\n    public Solution(ListNode head) {\\n        while (head != null) {\\n            nodes.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int i = (int)(Math.random() * this.nodes.size());\\n        return this.nodes.get(i);\\n    }\\n}\\n\\n\\n```\\n```C++ []\\nclass Solution {\\n    private:\\n        vector<int> nodes;\\n    public:\\n        Solution(ListNode* head) {\\n            while (head != nullptr) {\\n                nodes.push_back(head->val);\\n                head = head->next;\\n            }\\n        }\\n        \\n        int getRandom() {\\n            int i = rand() % nodes.size();\\n            return nodes[i];\\n        }\\n};\\n\\n```\\n```python []\\n\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        self.nodes = []\\n        while head:\\n            self.nodes.append(head.val)\\n            head = head.next\\n\\n    def getRandom(self) -> int:\\n        i = random.randint(0, len(self.nodes) - 1)\\n        return self.nodes[i]\\n\\n```\\n\\n\\n---\\n\\n\\n\\n\\n\\n\\n# Advanced Approach\\nTo select a random element from a data stream with unknown length, we use $$random$$ $$sampling$$. \\n\\n# Approach\\nThink about reservior sampling as this lottery contest where everybody has equal chance of winning. How do we formulate such a method?\\nLet\\'s do with the basics:\\n\\n# Reservior Sampling:\\n**The probability by which you decide if you should select the $$k-th$$ element or not is $$1/k$$. This ensures that everyone has the same probability of getting selected.**\\n\\nSuppose you have to select a random number between a,b,c,d,e.\\n**Steps:**\\n1. Start by selecting the first element, here $$a$$\\n2. Iterate through the remaining elements. (say) For the $$4th$$ element, $$d$$, generate a number between $$1$$ and $$4$$. If you get $$1$$, discard the current alphabet you\\'re holding and select $$d$$ instead.\\n    Why?\\n    The probability of selecting $$d$$ is $$1/4$$.\\n $$success=[1]$$ \\n$$samples=[1,2,3,4]$$\\nOr $$1/4$$\\n\\n    3.Repeat the process until the end.\\n\\nThinking about this problem from the perspective of ***\"Should I select the newest element or not\"*** is intuitive. Next step is to breakdown how it ensures fairity. Let\\'s get back to $$[a,b,c,d,e]$$\\n\\n- The probability of $$a$$ getting  selected at the start is $$1$$`(1/k, where k=1)`\\n- When we observe $$b$$, it is selected with a probability of $$1/2$$, that also means $$a$$ will be rejected when we observe  $$b$$ with a probability of $$1/2$$. B or fairness. But doesn\\'t that mean $$b$$ won\\'t be selected with a probability of $$1/2$$ ? And $$a$$ will remain our choice with a 1/2 probability? Or fairness?\\n- When we observe the next element $$c$$, it is either added to the reservoir with probability $$1/3$$. That means probability of $$c$$ not being selected is $$2/3$$\\n- In the previous step, $$a$$ had a $$50$$ percent chance of remaining our selection. As our selections are independant, chances of $$\\'a\\'$$ remaining our selection are:\\n$$50$$ % *of* $$2/3$$, or $$1/3$$\\n- Same logic is followed for further steps.\\n\\n\\n\\n\\n\\n# Code\\n```Java []\\nclass Solution {\\n    private ListNode head;\\n    private Random rand;\\n\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        this.rand = new Random();\\n    }\\n    \\n    public int getRandom() {\\n        ListNode curr = this.head;\\n        int val = curr.val;\\n        for (int i = 1; curr.next != null; i++) {\\n            curr = curr.next;\\n            if (rand.nextInt(i + 1) == 1) {\\n//generate a number between [0,i]. compare it with 1 \\n//as test condition\\n                val = curr.val;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\nprivate:\\n    ListNode* head;\\npublic:\\n    Solution(ListNode* head) {\\n        this->head = head;\\n    }\\n    \\n    int getRandom() {\\n        int count = 0, result;\\n        ListNode* curr = head;\\n        while (curr) {\\n            count++;\\n            if (rand() % count == 0) {\\n                result = curr->val;\\n            }\\n            curr = curr->next;\\n        }\\n        return result;\\n    }\\n};\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def __init__(self, head: ListNode):\\n        self.head = head\\n        \\n    def getRandom(self) -> int:\\n        curr = self.head\\n        val = curr.val\\n        i = 1\\n        while curr.next:\\n            curr = curr.next\\n            i += 1\\n            if random.randint(1, i) == 1:\\n                val = curr.val\\n        return val\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nint i = (int)(Math.random() * this.nodes.size());\\n```\n```Java []\\nclass Solution {\\n    ArrayList<Integer> nodes = new ArrayList<Integer>();\\n    public Solution(ListNode head) {\\n        while (head != null) {\\n            nodes.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int i = (int)(Math.random() * this.nodes.size());\\n        return this.nodes.get(i);\\n    }\\n}\\n\\n\\n```\n```C++ []\\nclass Solution {\\n    private:\\n        vector<int> nodes;\\n    public:\\n        Solution(ListNode* head) {\\n            while (head != nullptr) {\\n                nodes.push_back(head->val);\\n                head = head->next;\\n            }\\n        }\\n        \\n        int getRandom() {\\n            int i = rand() % nodes.size();\\n            return nodes[i];\\n        }\\n};\\n\\n```\n```python []\\n\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        self.nodes = []\\n        while head:\\n            self.nodes.append(head.val)\\n            head = head.next\\n\\n    def getRandom(self) -> int:\\n        i = random.randint(0, len(self.nodes) - 1)\\n        return self.nodes[i]\\n\\n```\n```Java []\\nclass Solution {\\n    private ListNode head;\\n    private Random rand;\\n\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        this.rand = new Random();\\n    }\\n    \\n    public int getRandom() {\\n        ListNode curr = this.head;\\n        int val = curr.val;\\n        for (int i = 1; curr.next != null; i++) {\\n            curr = curr.next;\\n            if (rand.nextInt(i + 1) == 1) {\\n//generate a number between [0,i]. compare it with 1 \\n//as test condition\\n                val = curr.val;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    ListNode* head;\\npublic:\\n    Solution(ListNode* head) {\\n        this->head = head;\\n    }\\n    \\n    int getRandom() {\\n        int count = 0, result;\\n        ListNode* curr = head;\\n        while (curr) {\\n            count++;\\n            if (rand() % count == 0) {\\n                result = curr->val;\\n            }\\n            curr = curr->next;\\n        }\\n        return result;\\n    }\\n};\\n\\n```\n```Python3 []\\nclass Solution:\\n    def __init__(self, head: ListNode):\\n        self.head = head\\n        \\n    def getRandom(self) -> int:\\n        curr = self.head\\n        val = curr.val\\n        i = 1\\n        while curr.next:\\n            curr = curr.next\\n            i += 1\\n            if random.randint(1, i) == 1:\\n                val = curr.val\\n        return val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85705,
                "title": "java-two-solutions-easy-to-understand",
                "content": "The first solution is the trivial one, \\n\\nwe just count the length of the list, and then return a random number \"r\" between 0 and length,\\n\\nthen we traverse the list again and stop at\"r\" steps and then return the value of that ListNode.\\n\\n```\\npublic class Solution {\\n\\n    /** @param head The linked list's head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    int count = 0;\\n    ListNode head;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        ListNode tem = head;\\n        while(tem != null) {\\n            count++;\\n            tem = tem.next;\\n        }\\n    }\\n    \\n    /** Returns a random node's value. */\\n    public int getRandom() {\\n        ListNode fakehead = head;\\n        Random r = new Random();\\n        int random = r.nextInt(count);\\n        for (int i = 0; i < random; i++) {\\n            fakehead = fakehead.next;\\n        }\\n        return fakehead.val;\\n    }\\n}\\n```\\nAnother one only traverse the list once, and we don't need to know the length of the list.\\n```\\npublic class Solution {\\n\\n    /** @param head The linked list's head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    ListNode head;\\n    Random random;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        random = new Random();\\n    }\\n    \\n    /** Returns a random node's value. */\\n    public int getRandom() {\\n        int count = 0;\\n        int result = -1;\\n        ListNode dummyhead = head;\\n        while(dummyhead != null) {\\n            if(random.nextInt(++count) == 0) {\\n                result = dummyhead.val;\\n            }\\n            dummyhead = dummyhead.next;\\n        }\\n        return result;\\n    }\\n}\\n```\\nprof: for example: we have 3 numbers : 1,2,3.\\nstep 1:  we pick 1 probability 1/1 .\\nstep 2: we have 1/2 probability to pick 2, so there are 1/2 chance we return 1 and 1/2 chance return 2.\\nstep 3: we have 1/3 probability to pick 3, and the probability that we return 2 is that we pick 2 in step 2 and don't pick 3 and step 3, so the probability of returning 2 is 1/2 * (1- 1/3) = 1/3.  so in step 3 we have 1/3 chance to return 1, 1/3 chance to return 2, and 1/3 chance to return 3.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    /** @param head The linked list's head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    int count = 0;\\n    ListNode head;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        ListNode tem = head;\\n        while(tem != null) {\\n            count++;\\n            tem = tem.next;\\n        }\\n    }\\n    \\n    /** Returns a random node's value. */\\n    public int getRandom() {\\n        ListNode fakehead = head;\\n        Random r = new Random();\\n        int random = r.nextInt(count);\\n        for (int i = 0; i < random; i++) {\\n            fakehead = fakehead.next;\\n        }\\n        return fakehead.val;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n\\n    /** @param head The linked list's head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    ListNode head;\\n    Random random;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        random = new Random();\\n    }\\n    \\n    /** Returns a random node's value. */\\n    public int getRandom() {\\n        int count = 0;\\n        int result = -1;\\n        ListNode dummyhead = head;\\n        while(dummyhead != null) {\\n            if(random.nextInt(++count) == 0) {\\n                result = dummyhead.val;\\n            }\\n            dummyhead = dummyhead.next;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990580,
                "title": "reach-a-number-python-o-1-time-with-explanation",
                "content": "The optimal moves for the first few targets look like this:\\n\\n| Target | Moves |\\n| - | - |\\n| 1 | +1 |\\n| 2 | +1 -2 + 3 |\\n| 3 | +1 +2 |\\n| 4 | -1 +2 +3 |\\n| 5 | +1 +2 +3 +4 -5 |\\n| 6 | +1 +2 +3 |\\n| 7 | +1 +2 +3 -4 +5 |\\n| 8 | -1 +2 +3 +4 |\\n| 9 | +1 +2 -3 +4 +5 |\\n| 10 | +1 +2 +3 +4 |\\n| 11 | +1 -2 +3 +4 +5 |\\n| 13 | -1 +2 +3 +4 +5 |\\n| 15 | +1 +2 +3 +4 +5 |\\n\\nTo get the moves for negative numbers, flip the signs.\\n\\nThe rule goes like following. The furthest you can reach by `n` steps is limited by the sum ![image](https://assets.leetcode.com/users/images/86e4fda9-eb84-4856-9e23-e27fc80d4176_1609161424.6557984.png). To get to a number below it, the only thing you can do is to flip some `+` to `-`, but by doing so, the parity remains the same, because the difference between `+x` and `-x` is `2x` -- an even number. That means you can only get to the target by decrease from the closest  `S(n) >= target` with the same parity as the target (`(S(n) - target) % 2 == 0`).\\n\\nWe could enumerate `n` from 1 all the way up to the one that satisfy the above condition, which will finish in O(sqrt(n)) time. Given `target` is no greater than `10^9`, this is fine. However, we can get our starting point much closer by using some math.\\n\\nLet ![image](https://assets.leetcode.com/users/images/f326a549-c806-4d66-8491-25ba6dce8108_1609186639.9289124.png). Note that we have\\n![image](https://assets.leetcode.com/users/images/b8234c59-5389-4ade-a017-a1b722145417_1609160202.2642846.png);\\n![image](https://assets.leetcode.com/users/images/082cfb46-168f-47ea-a712-181ceec5416e_1609160225.8650758.png).\\nThat means `n` should be at least greater than `q-1` to be able to cover `target`.\\n\\nAfter there, we at most need to try 4 different `n`s to find the right one that yields the same parity. This can be proved by checking all the possible values of `n` mod 4.\\n| `n % 4` | `S(n) % 2` |\\n| - | - |\\n| 0 | 0 |\\n| 1 | 1 |\\n| 2 | 1 |\\n| 3 | 0 |\\n\\nThus, we get the below O(1) time solution.\\n\\n```python\\nclass Solution:\\n    def reachNumber(self, target: int) -> int:\\n        target = abs(target)\\n        n = ceil(sqrt(2*target)-1) # n = 1 gives O(sqrt(target)) solution\\n        while True:\\n            upper = n * (n+1) // 2\\n            if upper >= target and (upper - target) % 2 == 0:\\n                break\\n            n += 1\\n        return n\\n```\\n\\nNote: `target=0` is not a problem as it is excluded from inputs.\\n\\n---\\nIf you find this helpful, please **upvote**! It will motivate me to write more explanations like this. Thank you! \\uD83E\\uDD17",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reachNumber(self, target: int) -> int:\\n        target = abs(target)\\n        n = ceil(sqrt(2*target)-1) # n = 1 gives O(sqrt(target)) solution\\n        while True:\\n            upper = n * (n+1) // 2\\n            if upper >= target and (upper - target) % 2 == 0:\\n                break\\n            n += 1\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297969,
                "title": "python-beats-90-never-using-length",
                "content": "\\nBy going through each node and \\'updating\\' the random value to be returned you can iterate through the linked list only once, without ever needing to know the length of the array.\\n\\nIt works by having the probability of node N\\'s value replacing the current random value be 1/N (indexed at 1).  Factoring in the probability that it could again be changed by nodes later in the linked list, this gives each node equal probability of being chosen.  \\n\\n\\n```\\nfrom random import random\\n\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        self.head = head        \\n\\n    def getRandom(self) -> int:\\n        cur_node = self.head\\n        counter = 1\\n        choice = -1\\n    \\n        while not cur_node is None:\\n            if random() < 1/counter:\\n                choice = cur_node.val\\n            cur_node = cur_node.next\\n            counter += 1\\n        return choice\\n```",
                "solutionTags": [],
                "code": "```\\nfrom random import random\\n\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        self.head = head        \\n\\n    def getRandom(self) -> int:\\n        cur_node = self.head\\n        counter = 1\\n        choice = -1\\n    \\n        while not cur_node is None:\\n            if random() < 1/counter:\\n                choice = cur_node.val\\n            cur_node = cur_node.next\\n            counter += 1\\n        return choice\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85663,
                "title": "reservoir-sampling-seems-inefficient",
                "content": "> **\"What if the linked list is extremely large and its length is unknown to you?\"**\\n\\nWell, then I simply count first. Silly question :-P\\n\\nThe solution below takes about 180 ms while the \"reservoir sampling\" Python solutions posted by others all take about 400 ms or more, presumably due to the many costly requests to the random number generator. So they seem rather inefficient.\\n```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        n = 0\\n        node = self.head\\n        while node:\\n            n += 1\\n            node = node.next\\n        node = self.head\\n        for _ in xrange(random.randrange(n)):\\n            node = node.next\\n        return node.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        n = 0\\n        node = self.head\\n        while node:\\n            n += 1\\n            node = node.next\\n        node = self.head\\n        for _ in xrange(random.randrange(n)):\\n            node = node.next\\n        return node.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278519,
                "title": "c-using-srand-and-time-function-easy",
                "content": "# Code\\n```\\nclass Solution\\n{\\n    vector<int> v;\\n    int n;\\n\\npublic:\\n    Solution(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        while (ptr)\\n        {\\n            v.push_back(ptr->val);\\n            ptr = ptr->next;\\n        }\\n        n = v.size();\\n    }\\n\\n    int getRandom()\\n    {\\n        static int i = 0;\\n        if (i == 0)\\n        {\\n            srand(time(NULL));\\n            i++;\\n        }\\n        return v[rand() % n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    vector<int> v;\\n    int n;\\n\\npublic:\\n    Solution(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        while (ptr)\\n        {\\n            v.push_back(ptr->val);\\n            ptr = ptr->next;\\n        }\\n        n = v.size();\\n    }\\n\\n    int getRandom()\\n    {\\n        static int i = 0;\\n        if (i == 0)\\n        {\\n            srand(time(NULL));\\n            i++;\\n        }\\n        return v[rand() % n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977871,
                "title": "cherry-pickup-ii-solution-with-explanation-c",
                "content": "\\n# Approach : Dynamic Programming (Top Down)\\n\\nLet\\'s define the DP state as (row1, col1, row2, col2), where (row1, col1) represents the location of robot1, and (row2, col2) represents the location of robot2.\\nThe maximum cherries robots can pick in the future would be the max  9 movements, which is the maximum of dp(row+1, new_col1, new_col2), where new_col1 can be col1, col1+1, or col1-1, and new_col2 can be col2, col2+1, or col2-1.\\n\\n![image](https://assets.leetcode.com/users/images/c011384b-bbc9-465a-ae1a-a1d8afc17910_1608388651.7900875.png)\\n\\n\\n**Algorithm**\\n\\nDefine a dp function that takes three integers row, col1, and col2 as input.\\n(row, col1) represents the location of robot1, and (row, col2) represents the location of robot2.\\nThe dp function returns the maximum cherries we can pick if robot1 starts at (row, col1) and robot2 starts at (row, col2).\\n\\nIn the dp function:\\n* Collect the cherry at (row, col1) and (row, col2). Do not double count if col1 == col2. \\n* If we do not reach the last row, we need to add the maximum cherries we can pick in the future.\\n* The maximum cherries we can pick in the future is the maximum of dp(row+1, new_col1, new_col2), where new_col1 can be col1, col1+1, or col1-1, and new_col2 can be col2, col2+1, or col2-1.\\n* Return the total cherries we can pick.\\n\\nFinally, return dp(row=0, col1=0, col2=last_column) in the main function.\\n\\n\\n**Implementation**\\n```\\n\\nclass Solution {\\npublic:\\n    //initisling max size to 3D array\\n    int arr[70][70][70];\\n    \\n    int dp( int row,int col1,int col2, vector<vector<int>>& grid)\\n    {\\n        // if out of bound\\n       if(col1 < 0 || col1 >=grid[0].size() || col2<0 || col2>=grid[0].size()) \\n            return 0;\\n        \\n        //check arr \\n        if(arr[row][col1][col2] != -1)\\n            return arr[row][col1][col2];\\n        \\n        int res=0;\\n        res += grid [row][col1] + grid [row][col2];\\n        \\n        // if both robot at same position\\n        if(col1 == col2)\\n            res -=grid[row][col1];\\n        \\n        //all transition to find max cherry by check all possbile cases\\n        \\n        if(row != grid.size() -1)\\n        {\\n            int mxx = 0;\\n            for (int j1 = col1 - 1; j1 <= col1 + 1; j1++)\\n            {\\n                for (int j2 = col2 - 1; j2 <= col2 + 1; j2++)\\n                {\\n                    mxx = max(mxx, dp(row + 1, j1, j2, grid));\\n                }\\n            }\\n            // adding max of all combinations\\n            res += mxx;\\n        }\\n        \\n        arr[row][col1][col2] = res;\\n        return res;\\n    }\\n    \\n    int cherryPickup(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n       \\n        // initial all elements to -1 to mark unseen\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                for (int k = 0; k < m; k++) {\\n                    arr[i][j][k] = -1;\\n                }\\n            }\\n        }\\n        \\n        return dp(0,0,m-1,grid);\\n    }\\n};\\n```\\n**Complexity Analysis**\\n\\nLet N be the number of rows in grid and M be the number of columns in grid.\\n\\nTime Complexity: O(NM^2) \\nSpace Complexity:  O (NM^2)\\n\\n**PS** : Please UPvote if you find this usefull \\uD83D\\uDE0A",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    //initisling max size to 3D array\\n    int arr[70][70][70];\\n    \\n    int dp( int row,int col1,int col2, vector<vector<int>>& grid)\\n    {\\n        // if out of bound\\n       if(col1 < 0 || col1 >=grid[0].size() || col2<0 || col2>=grid[0].size()) \\n            return 0;\\n        \\n        //check arr \\n        if(arr[row][col1][col2] != -1)\\n            return arr[row][col1][col2];\\n        \\n        int res=0;\\n        res += grid [row][col1] + grid [row][col2];\\n        \\n        // if both robot at same position\\n        if(col1 == col2)\\n            res -=grid[row][col1];\\n        \\n        //all transition to find max cherry by check all possbile cases\\n        \\n        if(row != grid.size() -1)\\n        {\\n            int mxx = 0;\\n            for (int j1 = col1 - 1; j1 <= col1 + 1; j1++)\\n            {\\n                for (int j2 = col2 - 1; j2 <= col2 + 1; j2++)\\n                {\\n                    mxx = max(mxx, dp(row + 1, j1, j2, grid));\\n                }\\n            }\\n            // adding max of all combinations\\n            res += mxx;\\n        }\\n        \\n        arr[row][col1][col2] = res;\\n        return res;\\n    }\\n    \\n    int cherryPickup(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n       \\n        // initial all elements to -1 to mark unseen\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                for (int k = 0; k < m; k++) {\\n                    arr[i][j][k] = -1;\\n                }\\n            }\\n        }\\n        \\n        return dp(0,0,m-1,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85667,
                "title": "c-using-reservoir-sampling-with-explanation",
                "content": "The pseudocode of reservoir sampling with pool size 1 is:\\n```\\nfor ith element in stream\\n    t <- random()\\n    if(t%i==0)  // each element is selected with a probability of 1/i\\n        res <- ith element\\n```\\n\\nWe need to proof the each element has a probability of 1/N to be selected where N is the length of stream.\\nProof:\\n1. N = 1. Only one element in the stream, the probability is 1;\\n2. N = 2. Obviously, probabilities of each element to be selected are 1/2;\\n3. N = n. Suppose the probabilities of each element to be selected are 1/n, considering N = n + 1. For (n+1)th element, the probability that (n+1)th is selected is 1/(n+1).  For 1,2,3..n elements, the probability is (1-1/(n+1))*(1/n)=1(n+1). Therefore, for N = n+1, the assumption maintains. \\n\\n------------------------------------------------------\\nAccepted Code:\\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* u;\\n    Solution(ListNode* head) {\\n        u = head;\\n    }\\n    \\n    int getRandom() {\\n        int res, len = 1;\\n        ListNode* v = u;\\n        while(v){\\n            if(rand() % len == 0){\\n                res = v->val;\\n            }\\n            len++;\\n            v = v->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfor ith element in stream\\n    t <- random()\\n    if(t%i==0)  // each element is selected with a probability of 1/i\\n        res <- ith element\\n```\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* u;\\n    Solution(ListNode* head) {\\n        u = head;\\n    }\\n    \\n    int getRandom() {\\n        int res, len = 1;\\n        ListNode* v = u;\\n        while(v){\\n            if(rand() % len == 0){\\n                res = v->val;\\n            }\\n            len++;\\n            v = v->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990531,
                "title": "reach-a-number-using-c-using-simple-loop",
                "content": "Thinking :-\\n\"Let say in minimum **\\'n\\'** steps it reaches the **target(t)** so , at each of his step either he had taken left(-)or right(+)\\nSo his final location can be represented as:- *(- or +)**1** + (- or +)**2**+............(- or +)**n***\\nIf we have taken all steps to right then final location is [**n\\\\*(n+1)/2**]\\nbut lets say to reach the target we want some steps(a,b,c,d.........) in left direction\\nSo we need to reduce this steps twice from the case in which we will move all steps towards right,that is:-\\n      **[n\\\\*(n+1)/2]  -  2\\\\*(a+b+c+d+e......)=target**;\\nNow we have,\\n**2\\\\*(a+b+c+.....)= [n\\\\*(n+1)/2] - target**\\nwhich means if we get a **\\'n\\'** for which **[n\\\\*(n+1)/2] - target**  is divisble by 2 then in **n** steps we can reach our target\\n\\nSo we will iterate all possible \\'n\\'// \\n\\nI hope you like this explanation , for any doubt drop a comment on it\\n```\\n #define lli long long int\\n #define rep(i,a,b) for(lli i=a;i<b;i++)\\nclass Solution {\\npublic:\\n    int reachNumber(int t) {\\n        t=abs(t);\\n        lli x;\\n        rep(n,0,100005)\\n        {\\n            x=((n+1)*n)/2;\\n            if(x>=t)\\n            {\\n                if((x-t)%2==0)\\n                {\\n                    return n;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n #define lli long long int\\n #define rep(i,a,b) for(lli i=a;i<b;i++)\\nclass Solution {\\npublic:\\n    int reachNumber(int t) {\\n        t=abs(t);\\n        lli x;\\n        rep(n,0,100005)\\n        {\\n            x=((n+1)*n)/2;\\n            if(x>=t)\\n            {\\n                if((x-t)%2==0)\\n                {\\n                    return n;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971203,
                "title": "burst-balloons-recursion-with-memorization",
                "content": "At first I thought i will try for recursive approach then add memorization to it but I have done a mistake I used arraylist and ost the track of index it is recursively correct but time limit exceeded because of O(n!) time complexity then I have changed my storing metho and done simple recursively with memorization.\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for(int i :nums)\\n            arr.add(i);\\n        return getMaxCoins(arr,0);\\n    }\\n\\n    public int getMaxCoins(ArrayList<Integer> arr,int ans){\\n        if(arr.size()==0)\\n            return ans;\\n        int max=0;\\n        for(int i=0;i<arr.size();i++){\\n            int mul=1,val=arr.get(i);\\n            if(i!=0) mul*=arr.get(i-1);\\n            if(i<arr.size()-1) mul*=arr.get(i+1);\\n            int sum=ans+val*mul;\\n            arr.remove(i);\\n            max=Math.max(max,getMaxCoins(arr,sum));\\n            arr.add(i,val);\\n        }\\n        return max;\\n    }\\n}\\n```\\nCode below is recursion with memorization simple as possible.\\nFor the above soln we have `nums[i-1]*nums[i]*nums[i+1]` for the below soln we have `nums[-1]*nums[i]*nums[n].` .there are n balloons and `i ` will be the last one to burst.\\n\\nWe can see that the balloons is again separated into 2 sections. But this time since the balloon `i ` is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other.\\n\\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n=nums.length;\\n        int []extended=new int[n+2];\\n        extended[0]=extended[n+1]=1;\\n        for(int i=1;i<n+1;i++)\\n            extended[i]=nums[i-1];\\n        \\n        int [][]memoriz=new int[n+2][n+2];\\n        return getMaxCoins(extended,memoriz,0,n+1);\\n    }\\n\\n    public int getMaxCoins(int []extended,int [][]memoriz,int left,int right){\\n        if(left==right) return 0;\\n        if(memoriz[left][right]>0) return memoriz[left][right];\\n        int max=0;    \\n        for(int i=left+1;i<right;i++)\\n            max=Math.max(max,extended[left]*extended[i]*extended[right]+getMaxCoins(extended,memoriz,left,i)\\n                         +getMaxCoins(extended ,memoriz,i,right));\\n        \\n        memoriz[left][right]=max;\\n        return max;\\n    }\\n}\\n```\\nThe below statement is crux of whole solution `extended[left]*extended[i]*extended[right]` this will account for last step where we have 1 as boundaries. Think in this way we break big problem into two small problems, take an example for n=5 elements **loop will be for 1-5** At `i =1` get ans of 0-1  ->`getMaxCoins(extended,memoriz,left,i)` and 1-5->`getMaxCoins(extended ,memoriz,i,right)` and add them as whole and find the maximum of all taking i=1,2,3,4,5..n as first step and boom we got the ans and in intermediate steps we store values into array for duplicate steps.\\n```\\nmax=Math.max(max,extended[left]*extended[i]*extended[right]+getMaxCoins(extended,memoriz,left,i)\\n                         +getMaxCoins(extended ,memoriz,i,right));\\n```\\nHere is dp solution too with same intution same explanation with a slider that is used for filling 2D matrix diagonally .DP soln is bit complex if you jump previous parts I had visualize how values are filling in  matrix in memorization and then able to wrote DP soln .\\n```\\nclass Solution {\\n   public int maxCoins(int[] nums) {\\n\\tint n=nums.length;\\n    int []extended=new int[n+2];\\n     extended[0]=extended[n+1]=1;\\n     for(int i=1;i<n+1;i++)\\n         extended[i]=nums[i-1];\\n        \\n    int[][] dp = new int[n+2][n+2];\\n    for (int slider = 2; slider < n+ 2; slider++){\\n        for (int left = 0; left < n +2 - slider; left++) {\\n            int right = left + slider;\\n            for (int i = left + 1; i < right; i++)\\n                dp[left][right] = Math.max(dp[left][right],extended[left] * extended[i] * extended[right] \\n                                           + dp[left][i] + dp[i][right]);\\n            \\n        }\\n    }\\n\\n    return dp[0][n +1];\\n    }\\n}\\n```\\n**If you like my explaination and hardwork please upvote it,will motivate and inspire me.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for(int i :nums)\\n            arr.add(i);\\n        return getMaxCoins(arr,0);\\n    }\\n\\n    public int getMaxCoins(ArrayList<Integer> arr,int ans){\\n        if(arr.size()==0)\\n            return ans;\\n        int max=0;\\n        for(int i=0;i<arr.size();i++){\\n            int mul=1,val=arr.get(i);\\n            if(i!=0) mul*=arr.get(i-1);\\n            if(i<arr.size()-1) mul*=arr.get(i+1);\\n            int sum=ans+val*mul;\\n            arr.remove(i);\\n            max=Math.max(max,getMaxCoins(arr,sum));\\n            arr.add(i,val);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxCoins(int[] nums) {\\n        int n=nums.length;\\n        int []extended=new int[n+2];\\n        extended[0]=extended[n+1]=1;\\n        for(int i=1;i<n+1;i++)\\n            extended[i]=nums[i-1];\\n        \\n        int [][]memoriz=new int[n+2][n+2];\\n        return getMaxCoins(extended,memoriz,0,n+1);\\n    }\\n\\n    public int getMaxCoins(int []extended,int [][]memoriz,int left,int right){\\n        if(left==right) return 0;\\n        if(memoriz[left][right]>0) return memoriz[left][right];\\n        int max=0;    \\n        for(int i=left+1;i<right;i++)\\n            max=Math.max(max,extended[left]*extended[i]*extended[right]+getMaxCoins(extended,memoriz,left,i)\\n                         +getMaxCoins(extended ,memoriz,i,right));\\n        \\n        memoriz[left][right]=max;\\n        return max;\\n    }\\n}\\n```\n```\\nmax=Math.max(max,extended[left]*extended[i]*extended[right]+getMaxCoins(extended,memoriz,left,i)\\n                         +getMaxCoins(extended ,memoriz,i,right));\\n```\n```\\nclass Solution {\\n   public int maxCoins(int[] nums) {\\n\\tint n=nums.length;\\n    int []extended=new int[n+2];\\n     extended[0]=extended[n+1]=1;\\n     for(int i=1;i<n+1;i++)\\n         extended[i]=nums[i-1];\\n        \\n    int[][] dp = new int[n+2][n+2];\\n    for (int slider = 2; slider < n+ 2; slider++){\\n        for (int left = 0; left < n +2 - slider; left++) {\\n            int right = left + slider;\\n            for (int i = left + 1; i < right; i++)\\n                dp[left][right] = Math.max(dp[left][right],extended[left] * extended[i] * extended[right] \\n                                           + dp[left][i] + dp[i][right]);\\n            \\n        }\\n    }\\n\\n    return dp[0][n +1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964476,
                "title": "pairs-of-songs-c-very-easy-understanding-solution-explained",
                "content": "i hold the modulos in mods vector\\n```\\nvector<int> mods(60,0);\\n```\\nthey want (time[i] + time[j]) % 60 = 0\\nit means time[i]%60 + time[j]%60 is 0 or 60\\n```\\nfor(int i = 0;i < time.size();i++){\\n            ans += mods[(60  - (time[i]%60)) % 60];\\n            mods[time[i]%60]++;\\n        }\\n```\\n60 - (time[i]%60) = time[j]\\nthe next line i increase mods[time[i]%60] because we have them \\n\\nthe full code:\\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> mods(60,0);\\n        int  ans = 0;\\n        for(int i = 0;i < time.size();i++){\\n            ans += mods[(60  - (time[i]%60)) % 60];\\n            mods[time[i]%60]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n(Sorry for my poor english)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> mods(60,0);\\n```\n```\\nfor(int i = 0;i < time.size();i++){\\n            ans += mods[(60  - (time[i]%60)) % 60];\\n            mods[time[i]%60]++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    int numPairsDivisibleBy60(vector<int>& time) {\\n        vector<int> mods(60,0);\\n        int  ans = 0;\\n        for(int i = 0;i < time.size();i++){\\n            ans += mods[(60  - (time[i]%60)) % 60];\\n            mods[time[i]%60]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278668,
                "title": "easy-peasy-java-solution-few-lines-code",
                "content": "# JAVA Code\\n``` JAVA []\\nclass Solution {\\n    ArrayList<Integer>list=new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        double random=Math.random()*list.size();\\n        return list.get((int)random);\\n    }\\n}\\n```\\n\\n![upvote_me.jpeg](https://assets.leetcode.com/users/images/ff106328-6937-4fd2-997a-e2898231838b_1678423039.4785175.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    ArrayList<Integer>list=new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        double random=Math.random()*list.size();\\n        return list.get((int)random);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975315,
                "title": "4sum-ii-o-n-2-10-lines-of-code-simple",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n            for(int j=0;j<B.length;j++){\\n                map.putIfAbsent(A[i]+B[j],0);\\n                map.compute(A[i]+B[j],(key,val)->val+1);\\n            }\\n        int count=0;\\n        for(int i=0;i<C.length;i++)\\n            for(int j=0;j<D.length;j++)\\n                if(map.containsKey(-(C[i]+D[j])))\\n                    count+=map.get(-(C[i]+D[j]));\\n        return count;\\n    }\\n}\\n```\\n\\n**if you stuck somewhere or any questions let me know .If you like it please upvote It inspires me .Thank You**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n            for(int j=0;j<B.length;j++){\\n                map.putIfAbsent(A[i]+B[j],0);\\n                map.compute(A[i]+B[j],(key,val)->val+1);\\n            }\\n        int count=0;\\n        for(int i=0;i<C.length;i++)\\n            for(int j=0;j<D.length;j++)\\n                if(map.containsKey(-(C[i]+D[j])))\\n                    count+=map.get(-(C[i]+D[j]));\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956917,
                "title": "c-crazy-simple-short-solution-o-n-time-o-1-space-faster-than-99",
                "content": "We just keep the length of the linked list.\\nThen we can randomize easily a number between 0 and len, and get the value in that index.\\n**Like it? please upvote!!!**\\n```\\nclass Solution {\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        list = head;\\n        ListNode* ptr = head;\\n        while (ptr) {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        int rand_index = rand()%len;\\n        ListNode* ptr = list;\\n        for (int i=0; i<rand_index; i++) {\\n            ptr = ptr->next;\\n        }\\n        return ptr->val;\\n    }\\n\\nprivate:\\n    int len = 0;\\n    ListNode* list;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        list = head;\\n        ListNode* ptr = head;\\n        while (ptr) {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        int rand_index = rand()%len;\\n        ListNode* ptr = list;\\n        for (int i=0; i<rand_index; i++) {\\n            ptr = ptr->next;\\n        }\\n        return ptr->val;\\n    }\\n\\nprivate:\\n    int len = 0;\\n    ListNode* list;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987092,
                "title": "decode-ways-c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n=s.length();\\n        if(s[0]==\\'0\\'){\\n            return 0;\\n        }\\n        \\n        vector<int> dp(n+1,0);\\n        \\n        dp[0]=1;\\n        //only one character available\\n        dp[1]=1;\\n        \\n        //dp[i] denotes number of ways possible with i length string\\n        \\n        for(int i=2;i<=n;i++){\\n            \\n            //check if previous character is greater than zero\\n            if(s[i-1]-\\'0\\'>0){\\n                dp[i]=dp[i-1];\\n            }\\n            \\n            //taking 2 characters at once \\n            if(s[i-2]==\\'1\\' || (s[i-2]-\\'0\\'==2 && s[i-1]-\\'0\\'<7)){\\n                dp[i]+=dp[i-2];\\n            }   \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n=s.length();\\n        if(s[0]==\\'0\\'){\\n            return 0;\\n        }\\n        \\n        vector<int> dp(n+1,0);\\n        \\n        dp[0]=1;\\n        //only one character available\\n        dp[1]=1;\\n        \\n        //dp[i] denotes number of ways possible with i length string\\n        \\n        for(int i=2;i<=n;i++){\\n            \\n            //check if previous character is greater than zero\\n            if(s[i-1]-\\'0\\'>0){\\n                dp[i]=dp[i-1];\\n            }\\n            \\n            //taking 2 characters at once \\n            if(s[i-2]==\\'1\\' || (s[i-2]-\\'0\\'==2 && s[i-1]-\\'0\\'<7)){\\n                dp[i]+=dp[i-2];\\n            }   \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672002,
                "title": "c-easy-to-understand-using-rand-function",
                "content": "**First approach**\\n```\\nclass Solution {\\nprivate:\\n    ListNode* root;\\npublic:\\n    Solution(ListNode* head) {\\n        root=head;\\n    }\\n    \\n    int getRandom() {\\n       int len=0;\\n       ListNode* temp=root;\\n       vector<int> v;\\n       while(temp)\\n       {\\n           len++;\\n           v.push_back(temp->val);\\n           temp=temp->next;\\n       }\\n       return v[rand()%len];\\n    }\\n};\\n```\\n**Second approach**\\n```\\nclass Solution {\\nprivate:\\n    ListNode* root;\\npublic:\\n    Solution(ListNode* head) {\\n        root=head;\\n    }\\n    \\n    int getRandom() {\\n       int len=0;\\n       ListNode* temp=root;\\n       while(temp)\\n       {\\n           len++;\\n           temp=temp->next;\\n       }\\n       int randomLen=rand()%len; \\n       temp=root;\\n       while(randomLen--)\\n       {\\n           temp=temp->next;\\n       }\\n       return temp->val;\\n    }\\n};\\n```\\n**Third approach\\nusing reservoir sampling**\\n```\\nclass Solution {\\npublic:\\n    ListNode* root;\\n    Solution(ListNode* head) {\\n        root = head;\\n    }\\n    int getRandom() {\\n        int index = 1;\\n        int ans = 0;\\n        ListNode* temp=root;\\n        while(temp){\\n            if(rand() % index == 0){\\n                ans=temp->val;\\n            }\\n            index++;\\n            temp=temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    ListNode* root;\\npublic:\\n    Solution(ListNode* head) {\\n        root=head;\\n    }\\n    \\n    int getRandom() {\\n       int len=0;\\n       ListNode* temp=root;\\n       vector<int> v;\\n       while(temp)\\n       {\\n           len++;\\n           v.push_back(temp->val);\\n           temp=temp->next;\\n       }\\n       return v[rand()%len];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    ListNode* root;\\npublic:\\n    Solution(ListNode* head) {\\n        root=head;\\n    }\\n    \\n    int getRandom() {\\n       int len=0;\\n       ListNode* temp=root;\\n       while(temp)\\n       {\\n           len++;\\n           temp=temp->next;\\n       }\\n       int randomLen=rand()%len; \\n       temp=root;\\n       while(randomLen--)\\n       {\\n           temp=temp->next;\\n       }\\n       return temp->val;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* root;\\n    Solution(ListNode* head) {\\n        root = head;\\n    }\\n    int getRandom() {\\n        int index = 1;\\n        int ans = 0;\\n        ListNode* temp=root;\\n        while(temp){\\n            if(rand() % index == 0){\\n                ans=temp->val;\\n            }\\n            index++;\\n            temp=temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956871,
                "title": "python-reservoir-sampling",
                "content": "Reservoir sampling is a trick used in many applications. One such application field is machine learning, and in particular online learning.\\n\\nOnline learning is a branch of machine learning where an algorithm is expected to learn from a sequence, typically on the fly. Many applications require maintaining a sketch of the training samples (a uniformly subsampled set of samples). In this case typically reservoir sampling is used with a size of `s`. This problem is a special case where `s=1`. The implementation is straightforward. At node `1` you choose the value in this node. At node `2` you replace this value with probability `1/2`, at node you replace with probability `1/3` and so on. It is easy to show that the returned sample has `(1/n)` probability of being chosen.\\n\\nExtra: If we know the length `n` instead we can also sample from a (modified) geometric distribution. We return the first element with probability `p := 1/n`, if not we return the second element with probability `p/(1-p)`, the third with `p/(1-p)^2` and so on. The returned sample then has `1/n` probability of being chosen.\\n\\nTime: `O(n)` (per random draw)\\nSpace: `O(1)`\\n\\nAlso note that uniform sampling will have `O(n)` time complexity as long as we don\\'t store the linked list as an array, since the expectation of a discrete uniform distribution over `1,...,n` is `n/2`. \\n\\n```python\\nimport random\\nclass Solution:\\n    def __init__(self, head):\\n        self.head = head\\n        \\n\\n    def getRandom(self):\\n        ans = self.head.val\\n        node, n = self.head.next, 2\\n        while node:\\n            u = random.random()\\n            if u<1/n:\\n                ans = node.val\\n            node, n = node.next, n+1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nimport random\\nclass Solution:\\n    def __init__(self, head):\\n        self.head = head\\n        \\n\\n    def getRandom(self):\\n        ans = self.head.val\\n        node, n = self.head.next, 2\\n        while node:\\n            u = random.random()\\n            if u<1/n:\\n                ans = node.val\\n            node, n = node.next, n+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85755,
                "title": "reservoir-sampling-java-solution",
                "content": "```\\nimport java.util.Random;\\n\\npublic class Solution {\\n    ListNode head;\\n    Random random;\\n    /** @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. */\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        random = new Random();\\n    }\\n    \\n    /** Returns a random node's value. */\\n    public int getRandom() {\\n        ListNode result = head;\\n        ListNode cur = head;\\n        int size = 1;\\n        while (cur != null) {\\n            if (random.nextInt(size) == 0) {\\n                result = cur;\\n            }\\n            size++;\\n            cur = cur.next;\\n        }\\n        \\n        return result.val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Random;\\n\\npublic class Solution {\\n    ListNode head;\\n    Random random;\\n    /** @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. */\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        random = new Random();\\n    }\\n    \\n    /** Returns a random node's value. */\\n    public int getRandom() {\\n        ListNode result = head;\\n        ListNode cur = head;\\n        int size = 1;\\n        while (cur != null) {\\n            if (random.nextInt(size) == 0) {\\n                result = cur;\\n            }\\n            size++;\\n            cur = cur.next;\\n        }\\n        \\n        return result.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866853,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n    int len= 0;\\n    ListNode* headNode;\\n\\npublic:\\n    Solution(ListNode* head) {\\n        headNode= head;\\n        ListNode* temp= headNode;\\n\\n        while(temp){\\n            len++;\\n            temp= temp->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int rand_idx= rand()%len;\\n        ListNode* temp= headNode;\\n\\n        for(int i=0; i<rand_idx; i++){\\n            temp= temp->next;\\n        }\\n\\n        return temp->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int len= 0;\\n    ListNode* headNode;\\n\\npublic:\\n    Solution(ListNode* head) {\\n        headNode= head;\\n        ListNode* temp= headNode;\\n\\n        while(temp){\\n            len++;\\n            temp= temp->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int rand_idx= rand()%len;\\n        ListNode* temp= headNode;\\n\\n        for(int i=0; i<rand_idx; i++){\\n            temp= temp->next;\\n        }\\n\\n        return temp->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975332,
                "title": "4-sum-ii-c-map-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n    \\n      \\n      unordered_map<int,int> umap1,umap2;\\n      \\n      int n=A.size(),count=0;\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n        for(int j=0;j<n;j++)\\n        {\\n          umap1[A[i]+B[j]]++;\\n          umap2[C[i]+D[j]]++;\\n          \\n        }\\n      }\\n      \\n      for(auto x : umap1)\\n      {\\n        int num=x.first;\\n        \\n        if(umap2.find(-1*num)!=umap2.end())\\n          count+=x.second*umap2[-1*num];\\n         \\n      }\\n            \\n      return count;\\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n    \\n      \\n      unordered_map<int,int> umap1,umap2;\\n      \\n      int n=A.size(),count=0;\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n        for(int j=0;j<n;j++)\\n        {\\n          umap1[A[i]+B[j]]++;\\n          umap2[C[i]+D[j]]++;\\n          \\n        }\\n      }\\n      \\n      for(auto x : umap1)\\n      {\\n        int num=x.first;\\n        \\n        if(umap2.find(-1*num)!=umap2.end())\\n          count+=x.second*umap2[-1*num];\\n         \\n      }\\n            \\n      return count;\\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544153,
                "title": "javascript-reservoir-sampling-solution",
                "content": "```js\\nvar Solution = function(head) {\\n       this.head = head\\n};\\nSolution.prototype.getRandom = function() {\\n       let i = 2;\\n       let cur = this.head.next;\\n       let val = this.head.val;\\n       while(cur) {\\n              const ratio = 1/i\\n              if(Math.random() <= ratio ) val = cur.val;\\n              i++;\\n              cur = cur.next;\\n       }\\n       return val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar Solution = function(head) {\\n       this.head = head\\n};\\nSolution.prototype.getRandom = function() {\\n       let i = 2;\\n       let cur = this.head.next;\\n       let val = this.head.val;\\n       while(cur) {\\n              const ratio = 1/i\\n              if(Math.random() <= ratio ) val = cur.val;\\n              i++;\\n              cur = cur.next;\\n       }\\n       return val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3278468,
                "title": "easiest-solution-5-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int ans = (int)(Math.random()*list.size());\\n        return list.get(ans);  \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head = head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3278461,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        double rand=Math.random()*list.size();\\n        return list.get((int)rand);\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        double rand=Math.random()*list.size();\\n        return list.get((int)rand);\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278179,
                "title": "why-doesn-t-simple-solution-work",
                "content": "Why doesn\\'t the First Solution Work...We evenly return all elements one by one\\n# Code Not Accepted\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *Head,*current;\\n    bool firsttime=true;\\n\\n    Solution(ListNode* head) \\n    {\\n        Head=head;\\n    }\\n\\n    int getRandom() {\\n        if(firsttime)\\n        {\\n            current=Head;\\n            firsttime=false;\\n        }\\n        int x=current->val;\\n        if(current->next==NULL)\\n        {\\n            current=Head;\\n        }\\n        else\\n        {\\n            current=current->next;\\n        }\\n        return x;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\n```\\n# Code Accepted\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *Head;\\n    vector<int>values;\\n\\n    Solution(ListNode* head) \\n    {\\n        Head=head;\\n        while(head!=NULL)\\n        {\\n            values.push_back(head->val);\\n            head=head->next;\\n        }\\n    }\\n\\n    int getRandom() {\\n        return values[rand()%values.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Randomized"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *Head,*current;\\n    bool firsttime=true;\\n\\n    Solution(ListNode* head) \\n    {\\n        Head=head;\\n    }\\n\\n    int getRandom() {\\n        if(firsttime)\\n        {\\n            current=Head;\\n            firsttime=false;\\n        }\\n        int x=current->val;\\n        if(current->next==NULL)\\n        {\\n            current=Head;\\n        }\\n        else\\n        {\\n            current=current->next;\\n        }\\n        return x;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *Head;\\n    vector<int>values;\\n\\n    Solution(ListNode* head) \\n    {\\n        Head=head;\\n        while(head!=NULL)\\n        {\\n            values.push_back(head->val);\\n            head=head->next;\\n        }\\n    }\\n\\n    int getRandom() {\\n        return values[rand()%values.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992298,
                "title": "c-pseudo-palindromic-paths-in-a-binary-tree-recursion-w-bitset",
                "content": "\\n\\tclass Solution {\\n\\t\\t int ans = 0;\\n\\tpublic:\\n\\t\\tint pseudoPalindromicPaths(TreeNode* root) {\\n\\t\\t\\ttraverse(root, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tvoid traverse(TreeNode* root, int bit) {\\n\\t\\t\\tif(!root) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tbit ^= (1 << root->val);\\n\\t\\t\\tif(!root->left && !root->right) {\\n\\t\\t\\t\\tbitset<32> b(bit);\\n\\t\\t\\t\\tif(b.count() <= 1)\\n\\t\\t\\t\\t\\t++ans;\\n\\t\\t\\t}\\n\\t\\t\\ttraverse(root->left, bit);\\n\\t\\t\\ttraverse(root->right, bit);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t int ans = 0;\\n\\tpublic:\\n\\t\\tint pseudoPalindromicPaths(TreeNode* root) {\\n\\t\\t\\ttraverse(root, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 985709,
                "title": "diagonal-traverse-java-o-row-col-solution-beats-100-solutions",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new int[0];\\n        \\n        int r = matrix.length, c = matrix[0].length, i =0, j =0;\\n        int[] ans = new int[r*c];\\n        \\n        for(int k=0; k<ans.length; k++){\\n            ans[k] = matrix[i][j];\\n            \\n            if((i+j)%2 == 0){\\n                if(j == c-1)\\n                    i++;\\n                else if(i == 0)\\n                    j++;\\n                else{\\n                    i--;\\n                    j++;\\n                }\\n            }else{\\n                if(i == r-1)\\n                    j++;\\n                else if(j == 0)\\n                    i++;\\n                else{\\n                    i++;\\n                    j--;\\n                }\\n                \\n            }\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new int[0];\\n        \\n        int r = matrix.length, c = matrix[0].length, i =0, j =0;\\n        int[] ans = new int[r*c];\\n        \\n        for(int k=0; k<ans.length; k++){\\n            ans[k] = matrix[i][j];\\n            \\n            if((i+j)%2 == 0){\\n                if(j == c-1)\\n                    i++;\\n                else if(i == 0)\\n                    j++;\\n                else{\\n                    i--;\\n                    j++;\\n                }\\n            }else{\\n                if(i == r-1)\\n                    j++;\\n                else if(j == 0)\\n                    i++;\\n                else{\\n                    i++;\\n                    j--;\\n                }\\n                \\n            }\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983439,
                "title": "next-greater-element-iii-python-implementing-next-permutation",
                "content": "This solution is based on the protocol of [C++ `next_permutation()`](https://en.cppreference.com/w/cpp/algorithm/next_permutation), which permutes the array into the next permutation in lexicographical order with respect to `<`. It returns `True` if such a next permutation exists. \\n\\n[@Ritik26](https://leetcode.com/Ritik26) has a good explaination on how `next_permutation()` works in [this post](https://leetcode.com/discuss/explore/december-leetcoding-challenge/983321/Next-Greater-Element-III-U-will-get-understand-in-one-look). The code below is a more condensed implementation of the same idea, where `i` is where the first element smaller than the right, `j == i + 1`, `k` is where `l[k]` is \"just greater than\" `l[i]`. We don\\'t need to sort but just reverse `l[j:]` because we know it is already in descending order.\\n\\n```python\\ndef next_permutation(l):\\n    \"\"\"implementing C++ <algorithm> next_permutation().\"\"\"\\n    n = len(l)\\n    if n <= 1:\\n        return False\\n    i = n - 1\\n    while True:\\n        j = i\\n        i -= 1  \\n        if l[i] < l[j]:\\n            k = n - 1\\n            while not (l[i] < l[k]):  \\n                k -= 1\\n            l[i], l[k] = l[k], l[i]\\n            l[j:] = reversed(l[j:])\\n            return True\\n        if i == 0:  \\n                l.reverse()\\n                return False \\n\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        l = list(str(n))\\n        has_next = next_permutation(l)\\n        ans = int(\\'\\'.join(l))\\n        return ans if has_next and ans < 2 ** 31 else -1\\n```\\n\\n---\\nIf you find this helpful, please consider **upvote**. Thank you! \\uD83E\\uDD17",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef next_permutation(l):\\n    \"\"\"implementing C++ <algorithm> next_permutation().\"\"\"\\n    n = len(l)\\n    if n <= 1:\\n        return False\\n    i = n - 1\\n    while True:\\n        j = i\\n        i -= 1  \\n        if l[i] < l[j]:\\n            k = n - 1\\n            while not (l[i] < l[k]):  \\n                k -= 1\\n            l[i], l[k] = l[k], l[i]\\n            l[j:] = reversed(l[j:])\\n            return True\\n        if i == 0:  \\n                l.reverse()\\n                return False \\n\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        l = list(str(n))\\n        has_next = next_permutation(l)\\n        ans = int(\\'\\'.join(l))\\n        return ans if has_next and ans < 2 ** 31 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972966,
                "title": "squares-of-a-sorted-array-java-o-n-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length, i= 0, j = n-1, idx = n-1;\\n        \\n        int[] ans = new int[n];\\n        \\n        while(idx >= 0){\\n            if(Math.abs(nums[i]) > Math.abs(nums[j])){\\n                ans[idx] = nums[i]*nums[i];\\n                i++;\\n            }else{\\n                ans[idx] = nums[j]*nums[j];\\n                j--;\\n            } \\n            idx--;\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length, i= 0, j = n-1, idx = n-1;\\n        \\n        int[] ans = new int[n];\\n        \\n        while(idx >= 0){\\n            if(Math.abs(nums[i]) > Math.abs(nums[j])){\\n                ans[idx] = nums[i]*nums[i];\\n                i++;\\n            }else{\\n                ans[idx] = nums[j]*nums[j];\\n                j--;\\n            } \\n            idx--;\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964721,
                "title": "pair-of-songs-o-n-time-complexity-fastest-and-easiest-with-comments",
                "content": "**If you like the soln please upvote it ,really helpfull**\\n```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int count=0;\\n        for(int i=0;i<time.length;i++){\\n            time[i]=time[i]%60;     //make all values in range 60\\n        }\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<time.length;i++){\\n            map.computeIfAbsent(time[i],key->0);\\n            map.compute(time[i],(key,val)->val+1);  //add them in map\\n        }\\n        for(int i=0;i<time.length;i++){\\n            int num=(60-time[i])%60; \\n            map.compute(time[i],(key,val)->val-1);  //delete the current element\\n            if(map.containsKey(num)){\\n                count+=map.get(num);//if element present in map, frequency greater then 0 then add to count \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numPairsDivisibleBy60(int[] time) {\\n        int count=0;\\n        for(int i=0;i<time.length;i++){\\n            time[i]=time[i]%60;     //make all values in range 60\\n        }\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<time.length;i++){\\n            map.computeIfAbsent(time[i],key->0);\\n            map.compute(time[i],(key,val)->val+1);  //add them in map\\n        }\\n        for(int i=0;i<time.length;i++){\\n            int num=(60-time[i])%60; \\n            map.compute(time[i],(key,val)->val-1);  //delete the current element\\n            if(map.containsKey(num)){\\n                count+=map.get(num);//if element present in map, frequency greater then 0 then add to count \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957399,
                "title": "php-javascript-swift-o-n-time-o-1-space-reservoir-sampling",
                "content": "PHP:\\n```\\nclass Solution\\n{\\n    private $head;\\n\\n    function __construct($head)\\n    {\\n        $this->head = $head;\\n    }\\n\\n    function getRandom()\\n    {\\n        $i = $val = 0;\\n        $node = $this->head;\\n\\n        while ($node) {\\n            if (rand(1, ++$i) == $i) $val = $node->val;\\n            $node = $node->next;\\n        }\\n\\n        return $val;\\n    }\\n}\\n```\\n\\nJavaScript:\\n```\\nvar Solution = function (head) {\\n    this.head = head;\\n};\\n\\nSolution.prototype.getRandom = function () {\\n    let i = 0, val;\\n    let node = this.head;\\n\\n    while (node) {\\n        i++;\\n        if (Math.floor(Math.random() * i) + 1 === i) val = node.val;\\n        node = node.next;\\n    }\\n\\n    return val;\\n};\\n```\\n\\nSwift:\\n```\\nclass Solution {\\n\\n    private let head: ListNode?\\n\\n    init(_ head: ListNode?) {\\n        self.head = head\\n    }\\n\\n    func getRandom() -> Int {\\n        var i: Int = 0\\n        var val: Int?\\n        var node: ListNode? = self.head\\n\\n        while(node !== nil) {\\n            i += 1\\n            if Int.random(in: 1...i) == i {\\n                val = node!.val\\n            }\\n            node = node!.next\\n        }\\n\\n        return val!\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Swift",
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n    private $head;\\n\\n    function __construct($head)\\n    {\\n        $this->head = $head;\\n    }\\n\\n    function getRandom()\\n    {\\n        $i = $val = 0;\\n        $node = $this->head;\\n\\n        while ($node) {\\n            if (rand(1, ++$i) == $i) $val = $node->val;\\n            $node = $node->next;\\n        }\\n\\n        return $val;\\n    }\\n}\\n```\n```\\nvar Solution = function (head) {\\n    this.head = head;\\n};\\n\\nSolution.prototype.getRandom = function () {\\n    let i = 0, val;\\n    let node = this.head;\\n\\n    while (node) {\\n        i++;\\n        if (Math.floor(Math.random() * i) + 1 === i) val = node.val;\\n        node = node.next;\\n    }\\n\\n    return val;\\n};\\n```\n```\\nclass Solution {\\n\\n    private let head: ListNode?\\n\\n    init(_ head: ListNode?) {\\n        self.head = head\\n    }\\n\\n    func getRandom() -> Int {\\n        var i: Int = 0\\n        var val: Int?\\n        var node: ListNode? = self.head\\n\\n        while(node !== nil) {\\n            i += 1\\n            if Int.random(in: 1...i) == i {\\n                val = node!.val\\n            }\\n            node = node!.next\\n        }\\n\\n        return val!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280167,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nRuntime\\n21 ms\\nBeats\\n79.24%\\nAccepted Solutions Runtime Distribution (%)\\n----Ashish Madhup\\n\\n- Space complexity:\\nMemory\\n16.7 MB\\nBeats\\n26.59%\\nAccepted Solutions Memory Distribution (%)\\n----Ashish Madhup\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>list;\\n    Solution(ListNode* head)\\n     {\\n        ListNode * tmp = head;\\n        while(tmp)\\n        {\\n            list.push_back(tmp->val);\\n            tmp = tmp->next;\\n        }\\n    } \\n    int getRandom() \\n    {\\n        int n = list.size();\\n        int ind = rand()%n;\\n        return list[ind];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>list;\\n    Solution(ListNode* head)\\n     {\\n        ListNode * tmp = head;\\n        while(tmp)\\n        {\\n            list.push_back(tmp->val);\\n            tmp = tmp->next;\\n        }\\n    } \\n    int getRandom() \\n    {\\n        int n = list.size();\\n        int ind = rand()%n;\\n        return list[ind];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279881,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution\\n{\\n    vector<int> v;\\n    int n;\\n\\npublic:\\n    Solution(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        while (ptr)\\n        {\\n            v.push_back(ptr->val);\\n            ptr = ptr->next;\\n        }\\n        n = v.size();\\n    }\\n\\n    int getRandom()\\n    {\\n        static int i = 0;\\n        if (i == 0)\\n        {\\n            srand(time(NULL));\\n            i++;\\n        }\\n        return v[rand() % n];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution\\n{\\n    vector<int> v;\\n    int n;\\n\\npublic:\\n    Solution(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        while (ptr)\\n        {\\n            v.push_back(ptr->val);\\n            ptr = ptr->next;\\n        }\\n        n = v.size();\\n    }\\n\\n    int getRandom()\\n    {\\n        static int i = 0;\\n        if (i == 0)\\n        {\\n            srand(time(NULL));\\n            i++;\\n        }\\n        return v[rand() % n];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278454,
                "title": "easiest-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def __init__(self, head: Optional[ListNode]):\\n        self.ll=[]\\n        while head:\\n            self.ll.append(head.val)\\n            head=head.next\\n    def getRandom(self) -> int:\\n        return self.ll[randint(0, len(self.ll)-1)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, head: Optional[ListNode]):\\n        self.ll=[]\\n        while head:\\n            self.ll.append(head.val)\\n            head=head.next\\n    def getRandom(self) -> int:\\n        return self.ll[randint(0, len(self.ll)-1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672832,
                "title": "very-very-easy-c-rand-5-lines",
                "content": "**Basically we are asked to return a number which lies in the linkedlist it can be any **\\n**So firstly we will build a vector and insert the node->val in that vector and we will use same vector and retutn a random element from array by using rand()%v.size() which will basically give any number within the the vector**\\n\\n\\n```\\n```\\n```\\nclass Solution {\\nprivate : \\n    vector<int>v;\\npublic:\\n    Solution(ListNode* head) {      //constructor is called and parameterized constructor so user will give us linkedlist and we will clone linkedlist in vector\\n        while(head!=nullptr)\\n        {   \\n            v.push_back(head->val);\\n            head=head->next;\\n           \\n        }\\n    }\\n    \\n    int getRandom() {\\n        int q =rand()%v.size();  //generating a random index\\n        return v[q];   //retuning a element at that index\\n    }\\n};\\n```\\n```\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n```\n```\\nclass Solution {\\nprivate : \\n    vector<int>v;\\npublic:\\n    Solution(ListNode* head) {      //constructor is called and parameterized constructor so user will give us linkedlist and we will clone linkedlist in vector\\n        while(head!=nullptr)\\n        {   \\n            v.push_back(head->val);\\n            head=head->next;\\n           \\n        }\\n    }\\n    \\n    int getRandom() {\\n        int q =rand()%v.size();  //generating a random index\\n        return v[q];   //retuning a element at that index\\n    }\\n};\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672185,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    Solution(ListNode* head) { \\n        while(head!=NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    Solution(ListNode* head) { \\n        while(head!=NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671949,
                "title": "python3-simple-fast-explained",
                "content": "This is a very interesting problem. We have a linked list and we need to implement a function that returns randomly the value of a node.\\nAll the nodes have the same probability to be chosen.\\n\\nWe can use randint that returns a random integer in a range with the same probability.  The range, for our problem, is going to be 0 to the list length. So first, we need to know the length of the list, how many nodes we have to calculate the probability for each node.\\n\\nWe need to iterate all the lists for calculating  the length, if it\\'s not explicitly designed to be O(1). If we are going to traverse all the list, maybe it\\'s wise to have a pointer to each node that can relate node-position in the list. This is going to be needed for returning the value of the node at position i in O(1). In Python, we don\\'t have pointers. So a solution could be a little naive. We can just save all the nodes in an array to access in O(1) to each node by index (another solution could be to save only the values of each node). \\n\\nThis solution duplicates the space complexity to O(2n) but for simplification, is going to be O(n) in the infinite anyway.\\nBecause the list is iterated only once, the time complexity is O(n) is worst case.\\nNotice that getRandom is only O(1)  and this is important because the method could be called many times.\\n\\nSo here is my first solution, I hope it helps.\\n\\n```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n            self.nodes_array = self.buildArray(head)\\n            self.n = len(self.nodes_array)\\n        \\n    def buildArray(self, head):\\n            nodes_array = list()\\n        \\n            ptr = head\\n            while ptr is not None:\\n                    nodes_array.append(ptr)\\n                    ptr = ptr.next\\n           \\n            return nodes_array\\n            \\n        \\n    def getRandom(self) -> int:\\n            i = random.randint(0, (self.n)-1)\\n            return self.nodes_array[i].val\\n\\n```\\n\\nHave fun solving and sharing problems!! Best\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n            self.nodes_array = self.buildArray(head)\\n            self.n = len(self.nodes_array)\\n        \\n    def buildArray(self, head):\\n            nodes_array = list()\\n        \\n            ptr = head\\n            while ptr is not None:\\n                    nodes_array.append(ptr)\\n                    ptr = ptr.next\\n           \\n            return nodes_array\\n            \\n        \\n    def getRandom(self) -> int:\\n            i = random.randint(0, (self.n)-1)\\n            return self.nodes_array[i].val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981308,
                "title": "smallest-range-ii-simple-approach-all-language-solution",
                "content": "**Algorithm**\\n\\nWe can formalize the above concept: if A[i] < A[j], we don\\'t need to consider when A[i] goes down while A[j] goes up. This is because the interval (A[i] + K, A[j] - K) is a subset of (A[i] - K, A[j] + K) (here, (a, b) for a > b denotes (b, a) instead.)\\n\\nThat means that it is never worse to choose (up, down) instead of (down, up). We can prove this claim that one interval is a subset of another, by showing both A[i] + K and A[j] - K are between A[i] - K and A[j] + K.\\n\\nFor sorted A, say A[i] is the largest element for 0<= i <n  that goes up. Then A[0] + K, A[i] + K, A[i+1] - K, A[A.length - 1] - K are the only relevant values for calculating the answer: every other value is between one of these extremal values.\\n\\n* **C++**\\n```\\nclass Solution {\\npublic:\\n    int smallestRangeII(vector<int>& A, int k) {\\n        int n = A.size();\\n        sort(A.begin(),A.end());\\n        int ans = A[n-1] - A[0];\\n        int a,b;\\n        int high,low;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            a=A[i],b=A[i+1];\\n            int high = max(A[n-1]-k,a+k);\\n            int low = min(A[0]+k,b-k);\\n            ans = min(ans,high-low);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n* **JAVA**\\n```\\n\\nclass Solution {\\n    public int smallestRangeII(int[] A, int K) {\\n        int N = A.length;\\n        Arrays.sort(A);\\n        int ans = A[N-1] - A[0];\\n\\n        for (int i = 0; i < A.length - 1; ++i) {\\n            int a = A[i], b = A[i+1];\\n            int high = Math.max(A[N-1] - K, a + K);\\n            int low = Math.min(A[0] + K, b - K);\\n            ans = Math.min(ans, high - low);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n* **Python**\\n```\\nclass Solution(object):\\n    def smallestRangeII(self, A, K):\\n        A.sort()\\n        mi, ma = A[0], A[-1]\\n        ans = ma - mi\\n        for i in xrange(len(A) - 1):\\n            a, b = A[i], A[i+1]\\n            ans = min(ans, max(ma-K, a+K) - min(mi+K, b-K))\\n        return ans\\n```\\n\\n**Complexity Analysis**\\n\\n**Time Complexity:** O(NlogN), where N is the length of the A.\\n\\n**Space complexity** : O(N) / O(logN)\\n\\nThe space complexity of the sorting algorithm depends on the implementation of each program language.\\n\\nplease upvote if you find this helful it motived me to write more :D\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallestRangeII(vector<int>& A, int k) {\\n        int n = A.size();\\n        sort(A.begin(),A.end());\\n        int ans = A[n-1] - A[0];\\n        int a,b;\\n        int high,low;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            a=A[i],b=A[i+1];\\n            int high = max(A[n-1]-k,a+k);\\n            int low = min(A[0]+k,b-k);\\n            ans = min(ans,high-low);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\n    public int smallestRangeII(int[] A, int K) {\\n        int N = A.length;\\n        Arrays.sort(A);\\n        int ans = A[N-1] - A[0];\\n\\n        for (int i = 0; i < A.length - 1; ++i) {\\n            int a = A[i], b = A[i+1];\\n            int high = Math.max(A[N-1] - K, a + K);\\n            int low = Math.min(A[0] + K, b - K);\\n            ans = Math.min(ans, high - low);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def smallestRangeII(self, A, K):\\n        A.sort()\\n        mi, ma = A[0], A[-1]\\n        ans = ma - mi\\n        for i in xrange(len(A) - 1):\\n            a, b = A[i], A[i+1]\\n            ans = min(ans, max(ma-K, a+K) - min(mi+K, b-K))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963937,
                "title": "spiral-matrix-ii-python-o-n2-simple-offset",
                "content": "The following solution keeps track of an x-y position (location in the resulting array) and an offset (used to move spiral toward the center).\\n\\n```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        spiral = [[0]*n for i in range(n)]\\n        x, y, off = 0, 0, 0\\n        \\n        for i in range(1, n*n +1):\\n            spiral[y][x] = i\\n      \\n            if x == (n-1-off) and y < (n-1-off): y += 1 # Right Edge\\n            elif y == (n-1-off) and x > off: x -=1 # Bottom Edge\\n            elif x == off and y > off: # Left Edge\\n                y -= 1\\n                if y == off+1: off += 1\\n            else: x += 1 # Top Edge\\n\\n        return spiral\\n```\\n\\nThe above solution runs in *`O(n2)`* time. \\nThe above solution takes *`O(n2)`* space.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        spiral = [[0]*n for i in range(n)]\\n        x, y, off = 0, 0, 0\\n        \\n        for i in range(1, n*n +1):\\n            spiral[y][x] = i\\n      \\n            if x == (n-1-off) and y < (n-1-off): y += 1 # Right Edge\\n            elif y == (n-1-off) and x > off: x -=1 # Bottom Edge\\n            elif x == off and y > off: # Left Edge\\n                y -= 1\\n                if y == off+1: off += 1\\n            else: x += 1 # Top Edge\\n\\n        return spiral\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85726,
                "title": "c-equal-possibility-without-knowing-length",
                "content": "    class Solution {\\n    public:\\n    Solution(ListNode* head) {\\n        h = head;\\n    }\\n    \\n    /** Returns a random node's value. */\\n    int getRandom() {\\n        int rd = 1;\\n        ListNode* tmp = h;\\n        ListNode* res = NULL;\\n        while(tmp){\\n            if(rand()%rd==0)\\n                res = tmp;\\n            tmp = tmp->next;\\n            rd++;\\n        }\\n        return res->val;\\n    }\\n\\n    private:\\n    ListNode* h;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    Solution(ListNode* head) {\\n        h = head;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3280742,
                "title": "c-simple-efficient-easy-to-understand-code-using-rand",
                "content": "# Intuition\\nWe can store the elements of the linked list somewhere, and return any random one from them, since indexing through linked list is costly.\\n\\n# Approach\\nWe can maintain a vector that stores the elements, and randomly generate an index less than the size of the array, using rand() function, that returns the element at that index.\\n\\n# Complexity\\n- **Time complexity:**\\n**O(1)**\\n\\n- **Space complexity:**\\n**O(n)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    Solution(ListNode* head) {\\n        for(ListNode* temp=head;temp!=NULL;temp=temp->next){\\n            nodes.push_back(temp->val);\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return nodes[rand()%nodes.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    Solution(ListNode* head) {\\n        for(ListNode* temp=head;temp!=NULL;temp=temp->next){\\n            nodes.push_back(temp->val);\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return nodes[rand()%nodes.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279651,
                "title": "c-typescript-javascript-very-easy-soultion-no-extra-space-no-recursion",
                "content": "##### This solution focuses on the memory complexity rather than the time complexity.\\n\\n# Intuition\\nTo select a random node in a linked list we have to generate a random nubmer which represents the node to be selected (It has to be greater than or equal zero and less than the list length). Hence we need to get the list length when an object is created, So we call `countListLength()`. This function iterates through the list and count its length. In the `getRandom()` we generate a new random index and iterate through the list till we find and return it.\\n\\n# Approach\\n1. Initialize the head of the linked list\\n2. Calling the `countListLength()` to count list length \\n3. Calling `srand()` to Set a different starting point using `time(0)`\\n4. Generating every time `getRandom()` is called a new index between [0, length)\\n5. Iterating through the list to reach the desirde node which matches the generated index to return its value\\n\\n</br>\\n\\n**Note:** In the `C++` solution I used the `rand()` and the `srand()`, The reason I called `srand()` in the constructor is that it sets the starting point for producing a series of random integers. If `srand()` is not called, the `rand()` seed is set as if `srand(1)` were called at the program start. This will lead to the `rand()` producing the same sequence of integers every time it is called. So I have called the `srand()` in the constructor and pass it the seed value by calling `time(0)` as it returns a `time_t` value which varies every time. For further reading check this [article](https://www.geeksforgeeks.org/rand-and-srand-in-ccpp/).\\n\\n# Complexity\\n- **Time complexity:** $$O(n * m)$$\\n Where the `n` is length of the linked list and `m` is the number of times of calling `getRandom()`.\\n\\n- **Space complexity:** $$O(1)$$\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* head;\\n    int length;\\n\\n    Solution(ListNode* h) {\\n        // Asigning the head node to the head attribute\\n        head = h;\\n        // Asigning the list length to the gloabal length attribute\\n        length = countListLength();\\n        // Setting a different starting point for producing a series of random integers [using time function as seed]\\n        srand(time(0));\\n    }\\n\\n    // A function to iterate through the list and returns its length\\n    int countListLength(){\\n        int length = 0;\\n        ListNode* node = head;\\n\\n        // Keep increasing the length variable until reaching a NULL node\\n        while (node) {\\n            length++;\\n            node = node -> next;\\n        }\\n\\n        return length;\\n    }\\n    \\n    int getRandom() {\\n      // Generating random number where (0 <= indx < length)\\n      int indx = rand() % length;\\n\\n      ListNode* node = head;\\n\\n      // Iterating through the list to reach the desirde node to return its value\\n      while(indx--){\\n        node = node -> next;\\n      }\\n\\n      return node -> val;\\n    }\\n};\\n```\\n```TypeScript []\\nclass Solution {\\n    length: number = 0;\\n    head: ListNode | null;\\n\\n    constructor(h: ListNode | null) {\\n        // Asigning the head node to the head attribute\\n        this.head = h;\\n        // Calling the countListLength function to assign the length of the list to the length attribute\\n        this.countListLength();\\n    }\\n\\n    // A function to iterate through the list and count its length\\n    countListLength(): void {\\n        this.length = 0;\\n        let node: ListNode | null = this.head;\\n\\n        // Keep increasing the length attribute until reaching a NULL node\\n        while (node !== null) {\\n            node = node.next;\\n            this.length++;\\n        }\\n    }\\n\\n    getRandom(): number {\\n      // Generating random number where (0 <= indx < length)\\n        let indx = Math.floor(Math.random() * this.length);\\n\\n        let node = this.head;\\n\\n// Iterating through the list to reach the desirde node to return its value\\n        while (indx-- && node)\\n            node = node?.next;\\n\\n        return node ? node.val : Infinity;\\n    }\\n}\\n```\\n```JavaScript []\\nclass Solution {\\n    length;\\n    head;\\n\\n    constructor(h) {\\n        // Asigning the head node to the head attribute\\n        this.head = h;\\n        // Calling the countListLength function to assign the length of the list to the length attribute\\n        this.countListLength();\\n    }\\n\\n    // A function to iterate through the list and count its length\\n    countListLength() {\\n        this.length = 0;\\n        let node = this.head;\\n\\n        // Keep increasing the length attribute until reaching a NULL node\\n        while (node !== null) {\\n            node = node.next;\\n            this.length++;\\n        }\\n    }\\n\\n    getRandom() {\\n      // Generating random number where (0 <= indx < length)\\n        let indx = Math.floor(Math.random() * this.length);\\n\\n        let node = this.head;\\n\\n// Iterating through the list to reach the desirde node to return its value\\n        while (indx-- && node)\\n            node = node?.next;\\n\\n        return node ? node.val : Infinity;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "TypeScript",
                    "Linked List",
                    "Randomized"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* head;\\n    int length;\\n\\n    Solution(ListNode* h) {\\n        // Asigning the head node to the head attribute\\n        head = h;\\n        // Asigning the list length to the gloabal length attribute\\n        length = countListLength();\\n        // Setting a different starting point for producing a series of random integers [using time function as seed]\\n        srand(time(0));\\n    }\\n\\n    // A function to iterate through the list and returns its length\\n    int countListLength(){\\n        int length = 0;\\n        ListNode* node = head;\\n\\n        // Keep increasing the length variable until reaching a NULL node\\n        while (node) {\\n            length++;\\n            node = node -> next;\\n        }\\n\\n        return length;\\n    }\\n    \\n    int getRandom() {\\n      // Generating random number where (0 <= indx < length)\\n      int indx = rand() % length;\\n\\n      ListNode* node = head;\\n\\n      // Iterating through the list to reach the desirde node to return its value\\n      while(indx--){\\n        node = node -> next;\\n      }\\n\\n      return node -> val;\\n    }\\n};\\n```\n```TypeScript []\\nclass Solution {\\n    length: number = 0;\\n    head: ListNode | null;\\n\\n    constructor(h: ListNode | null) {\\n        // Asigning the head node to the head attribute\\n        this.head = h;\\n        // Calling the countListLength function to assign the length of the list to the length attribute\\n        this.countListLength();\\n    }\\n\\n    // A function to iterate through the list and count its length\\n    countListLength(): void {\\n        this.length = 0;\\n        let node: ListNode | null = this.head;\\n\\n        // Keep increasing the length attribute until reaching a NULL node\\n        while (node !== null) {\\n            node = node.next;\\n            this.length++;\\n        }\\n    }\\n\\n    getRandom(): number {\\n      // Generating random number where (0 <= indx < length)\\n        let indx = Math.floor(Math.random() * this.length);\\n\\n        let node = this.head;\\n\\n// Iterating through the list to reach the desirde node to return its value\\n        while (indx-- && node)\\n            node = node?.next;\\n\\n        return node ? node.val : Infinity;\\n    }\\n}\\n```\n```JavaScript []\\nclass Solution {\\n    length;\\n    head;\\n\\n    constructor(h) {\\n        // Asigning the head node to the head attribute\\n        this.head = h;\\n        // Calling the countListLength function to assign the length of the list to the length attribute\\n        this.countListLength();\\n    }\\n\\n    // A function to iterate through the list and count its length\\n    countListLength() {\\n        this.length = 0;\\n        let node = this.head;\\n\\n        // Keep increasing the length attribute until reaching a NULL node\\n        while (node !== null) {\\n            node = node.next;\\n            this.length++;\\n        }\\n    }\\n\\n    getRandom() {\\n      // Generating random number where (0 <= indx < length)\\n        let indx = Math.floor(Math.random() * this.length);\\n\\n        let node = this.head;\\n\\n// Iterating through the list to reach the desirde node to return its value\\n        while (indx-- && node)\\n            node = node?.next;\\n\\n        return node ? node.val : Infinity;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278130,
                "title": "daily-leetcoding-challenge-march-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1672361,
                "title": "c-most-optimal-solution-easy-to-understand",
                "content": "```\\n class Solution {\\n     ListNode *copy;\\npublic:\\n    \\n    Solution(ListNode* head) {\\n        copy = head;\\n    }\\n    \\n    int getRandom() \\n    {\\n        ListNode *temp = copy;\\n        int pos = 1, res;\\n        \\n        while(temp)\\n        {          \\n            \\n            if(rand() % pos == 0)\\n                res = temp -> val;\\n            \\n            temp = temp -> next;\\n            pos++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n     ListNode *copy;\\npublic:\\n    \\n    Solution(ListNode* head) {\\n        copy = head;\\n    }\\n    \\n    int getRandom() \\n    {\\n        ListNode *temp = copy;\\n        int pos = 1, res;\\n        \\n        while(temp)\\n        {          \\n            \\n            if(rand() % pos == 0)\\n                res = temp -> val;\\n            \\n            temp = temp -> next;\\n            pos++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672338,
                "title": "java-solution-briefly-explained-using-random-class",
                "content": "We need to give equal priority to all the values in the list.\\n\\n- First we convert the linkedlist into arraylist **(1)**. Because we easly access the element in arraylist using index .\\n- Then find the size of the list **(2)** and Create object for Random class **(3)**.\\n- Random class help us to generate random number in given range and give equal perference to all numbers.\\n- Then we pick the random index **(4)** and return the value in that index.\\n\\n```java\\nclass Solution {\\n    List<Integer> li;\\n    int n;\\n    Random r ;\\n    public Solution(ListNode head) {\\n        li = new ArrayList<>();\\n        ListNode temp = head;\\n        while(temp != null){\\n            li.add(temp.val);\\n            temp = temp.next;\\n        }// Convert the linked list data to array list --> (1)\\n        n = li.size(); // Number of nodes in the list --> (2)\\n        r = new Random(); // Object for random Class --> (3)\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    public int getRandom() {\\n        int l = r.nextInt(n); // Get the random number from 0 to n-1\\n        return li.get(l);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    List<Integer> li;\\n    int n;\\n    Random r ;\\n    public Solution(ListNode head) {\\n        li = new ArrayList<>();\\n        ListNode temp = head;\\n        while(temp != null){\\n            li.add(temp.val);\\n            temp = temp.next;\\n        }// Convert the linked list data to array list --> (1)\\n        n = li.size(); // Number of nodes in the list --> (2)\\n        r = new Random(); // Object for random Class --> (3)\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    public int getRandom() {\\n        int l = r.nextInt(n); // Get the random number from 0 to n-1\\n        return li.get(l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672172,
                "title": "must-check",
                "content": "**Java**\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    private ArrayList<Integer> range = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head != null){\\n            range.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int pick = (int)(Math.random() * range.size());\\n        return range.get(pick);\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```\\n**Time Complexity : O(n)**\\nLearning with complexities, do reply if anything wrong.\\n\\n\\n\\n**JavaScript**\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n */\\nvar Solution = function(head) {\\n        this.range = [];\\n        while(head !== null) {\\n            this.range.push(head)\\n            head = head.next;\\n        }\\n};\\n\\n/**\\n * @return {number}\\n */\\nSolution.prototype.getRandom = function() {\\n    return this.range[Math.floor(Math.random() * this.range.length)].val\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(head)\\n * var param_1 = obj.getRandom()\\n */\\n```\\n\\n**Time Complexity : O(n)**\\nLearning with complexities, do reply if anything wrong.",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    private ArrayList<Integer> range = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head != null){\\n            range.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int pick = (int)(Math.random() * range.size());\\n        return range.get(pick);\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n */\\nvar Solution = function(head) {\\n        this.range = [];\\n        while(head !== null) {\\n            this.range.push(head)\\n            head = head.next;\\n        }\\n};\\n\\n/**\\n * @return {number}\\n */\\nSolution.prototype.getRandom = function() {\\n    return this.range[Math.floor(Math.random() * this.range.length)].val\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(head)\\n * var param_1 = obj.getRandom()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672127,
                "title": "cpp-solution-without-using-array",
                "content": "\\tSolution(ListNode* head) {\\n        root = head;\\n    }\\n    int size(ListNode*head){\\n        int cnt =0;\\n        while(head){\\n            head = head->next;cnt++;\\n        }\\n        return cnt;\\n    }\\n    int getRandom() {\\n        int sz = size(root);\\n        int p = rand() % sz;\\n        \\n        ListNode *r = root;\\n        \\n        while(p-- > 0){\\n         r = r->next;   \\n        }\\n        return r->val;\\n    }\\nMain part is to store head ptr\\nother things can be done easily.",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "\\tSolution(ListNode* head) {\\n        root = head;\\n    }\\n    int size(ListNode*head){\\n        int cnt =0;\\n        while(head){\\n            head = head->next;cnt++;\\n        }\\n        return cnt;\\n    }\\n    int getRandom() {\\n        int sz = size(root);\\n        int p = rand() % sz;\\n        \\n        ListNode *r = root;\\n        \\n        while(p-- > 0){\\n         r = r->next;   \\n        }\\n        return r->val;\\n    }\\nMain part is to store head ptr\\nother things can be done easily.",
                "codeTag": "Unknown"
            },
            {
                "id": 995233,
                "title": "largest-rectangle-in-histogram-c-explanation",
                "content": "```\\n1) Create an empty stack.\\n\\n2) Start from first bar, and do following for every bar \\u2018hist[i]\\u2019 where \\u2018i\\u2019 varies from 0 to n-1.\\n\\u2026\\u2026a) If stack is empty or hist[i] is higher than the bar at top of stack, then push \\u2018i\\u2019 to stack.\\n\\u2026\\u2026b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the \\u2018left index\\u2019 is previous (previous to tp) item in stack and \\u2018right index\\u2019 is \\u2018i\\u2019 (current index).\\n\\n3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        stack<int> s;\\n        \\n        int i=0;\\n        \\n        int n=heights.size();\\n        \\n        int max_area=0;\\n   \\n        //Approach is to consider each bar as the smallest bar while calculating the area\\n        \\n        while(i<n){\\n            \\n            //If current bar is the larger than stack top means we havent reached right bounding condition for a previously larger bar(current larger bar is NOT the right boundary till which we can consider area with the s.top() bar as the bar with min height,so we simply push the bar)\\n            if(s.empty() || heights[s.top()]<heights[i]){\\n                s.push(i);\\n                i++;\\n                continue;\\n            }\\n            \\n            else{\\n                \\n                int x=s.top();\\n                s.pop();\\n                \\n                // [2,1,5,6,3] if stack is not empty then the popped bar i considered as min height bar and its left and right bounds have a total width of i(current index)-s.top()(previous index)-1(due to zero based indexing)\\n                \\n                //if stack is empty then we simply multiply with i ,eg: 1 height bar will remain in the stack till the end so thw width of rectangle considering 1 as min height bar will be the entire histogram width itself which is i.\\n                \\n                int area=heights[x] *(s.empty()?i:i-s.top()-1);\\n                max_area=max(max_area,area);\\n            }\\n        }\\n        \\n        //Process the remaining bars\\n        \\n        while(!s.empty()){\\n            int x=s.top();\\n            s.pop();\\n            int area=heights[x]*(s.empty()?i:i-s.top()-1);\\n            max_area=max(max_area,area);\\n        }\\n        \\n        return max_area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1) Create an empty stack.\\n\\n2) Start from first bar, and do following for every bar \\u2018hist[i]\\u2019 where \\u2018i\\u2019 varies from 0 to n-1.\\n\\u2026\\u2026a) If stack is empty or hist[i] is higher than the bar at top of stack, then push \\u2018i\\u2019 to stack.\\n\\u2026\\u2026b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the \\u2018left index\\u2019 is previous (previous to tp) item in stack and \\u2018right index\\u2019 is \\u2018i\\u2019 (current index).\\n\\n3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.\\n```\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        stack<int> s;\\n        \\n        int i=0;\\n        \\n        int n=heights.size();\\n        \\n        int max_area=0;\\n   \\n        //Approach is to consider each bar as the smallest bar while calculating the area\\n        \\n        while(i<n){\\n            \\n            //If current bar is the larger than stack top means we havent reached right bounding condition for a previously larger bar(current larger bar is NOT the right boundary till which we can consider area with the s.top() bar as the bar with min height,so we simply push the bar)\\n            if(s.empty() || heights[s.top()]<heights[i]){\\n                s.push(i);\\n                i++;\\n                continue;\\n            }\\n            \\n            else{\\n                \\n                int x=s.top();\\n                s.pop();\\n                \\n                // [2,1,5,6,3] if stack is not empty then the popped bar i considered as min height bar and its left and right bounds have a total width of i(current index)-s.top()(previous index)-1(due to zero based indexing)\\n                \\n                //if stack is empty then we simply multiply with i ,eg: 1 height bar will remain in the stack till the end so thw width of rectangle considering 1 as min height bar will be the entire histogram width itself which is i.\\n                \\n                int area=heights[x] *(s.empty()?i:i-s.top()-1);\\n                max_area=max(max_area,area);\\n            }\\n        }\\n        \\n        //Process the remaining bars\\n        \\n        while(!s.empty()){\\n            int x=s.top();\\n            s.pop();\\n            int area=heights[x]*(s.empty()?i:i-s.top()-1);\\n            max_area=max(max_area,area);\\n        }\\n        \\n        return max_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988895,
                "title": "jump-game-iv-python-bfs-with-explanation",
                "content": "Breadth first search (BFS) for the single-source shortest distance in an one-dimensional space. \\n\\nThe twist here is the \"jump\" operation. To support jump, maintain a dict (`val2id`) that collects all the positions that hold the same value. At each point during the BFS, besides expand to the direct left and right, also expand to the locations where the value is the same (`val2id[a[i]]`). \\n\\nOnce you expanded for a certain value, you can delete that entry from `val2id` because even if you reach the same value later, it won\\'t give you a shorter distance. This will also ensure that you only visit the value of each location at most once, and thus bounds the time complexity  by O(n), where n being the array length.\\n\\n```python\\nclass Solution:\\n    def minJumps(self, a: List[int]) -> int:\\n        n = len(a)\\n        val2id = {}\\n        for i, x in enumerate(a):\\n            val2id.setdefault(x, []).append(i)\\n        d = [inf] * n\\n        d[0] = 0\\n        q = [0]\\n        while len(q) and q[0] != n - 1:\\n            i = q.pop(0)\\n            ii = i - 1\\n            if 0 <= ii and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            ii = i + 1\\n            if ii < n and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            if a[i] in val2id:\\n                for ii in val2id[a[i]]:\\n                    if d[ii] is inf:\\n                        d[ii] = d[i] + 1\\n                        q.append(ii)\\n                del val2id[a[i]]\\n        return d[n - 1]\\n```\\n\\n---\\nIf you find this helpful, please consider **upvote**. It will encourage me to write more explanations like this. Thank you! :-)",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, a: List[int]) -> int:\\n        n = len(a)\\n        val2id = {}\\n        for i, x in enumerate(a):\\n            val2id.setdefault(x, []).append(i)\\n        d = [inf] * n\\n        d[0] = 0\\n        q = [0]\\n        while len(q) and q[0] != n - 1:\\n            i = q.pop(0)\\n            ii = i - 1\\n            if 0 <= ii and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            ii = i + 1\\n            if ii < n and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            if a[i] in val2id:\\n                for ii in val2id[a[i]]:\\n                    if d[ii] is inf:\\n                        d[ii] = d[i] + 1\\n                        q.append(ii)\\n                del val2id[a[i]]\\n        return d[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984443,
                "title": "swap-nodes-in-pair-c-faster-than-100-00-solutions-o-n-time-o-1-space-0ms-runtime",
                "content": "Time: O(n)\\nSpace: O(1)\\nThis is a very easy-to-follow solution. It beats 100% of the submitted C++ solutions according to my submission on Leetcode:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\nAny question let me know. If you like the post please upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979511,
                "title": "decoded-string-at-index-python-o-n-time-solution-with-explanation",
                "content": "Use `idx` to store the position of the _first_ occurrence of each characters in the original string `S`, i.e. for `\"le2co3\" -> \"lelecolelecoleleco\"` we will have `idx = {0:0, 1:1, 4:3, 5:4}`. `acclens` records the accumulated length of the encoded string when encounterred each digit in `S`.\\n\\nIn the first loop, we populate `idx` and `acclens` by going through `S` and keep track of the first occurence of each character `c` in `S`. That is, `acclens[-1] * prevd + j` -- the accumulated length of the ecoded string up to the most recent digit `acclens[-1]`, times the number repeated by that digit `prevd`, plus the shift of position in the original string `j`. `\\'1\\'` is added to `S` to ensure the last segment is documented.\\n\\nThe second loop use `idx` and `acclens` to locate the `K`-th character in the original string. The key idea is that at each step, we compute the relateve position of `k` in the outermost repeatance by mod\\'ing with the current accumulated length `k %= al`, i.e. `[10]` in `(\"le\"*2)+\"co\")*3 == \"lelecolelecoleleco\"` is the same as `[10 % 6 = 4]` in `(\"le\"*2)+\"co\" == \"leleco\"` (index starting from zero). If the resulting pos is in `idx`, we have found (the first occurrence of) the corresponding char in the orginal string. Otherwise, the location to be found is still in the inner part, and we repeat the process.\\n\\nThe algorithm takes O(n) time and O(n) space, where n is the length of the input string `S`.\\n\\n```Python\\nclass Solution:\\n    def decodeAtIndex(self, S: str, K: int) -> str:\\n        idx = {}\\n        acclens = [0]\\n        prevd = 1\\n        j = 0\\n        for i, c in enumerate(S + \\'1\\'):\\n            if c.isalpha():\\n                idx[acclens[-1] * prevd + j] = i\\n                j += 1\\n            else:\\n                acclens.append(acclens[-1] * prevd + j)\\n                prevd = int(c)\\n                j = 0\\n        k = K - 1\\n        for al in reversed(acclens[1:]):\\n            k %= al\\n            if k in idx:\\n                return S[idx[k]]\\n        return None  # should never reach this\\n```\\n\\n---\\nIf you find this helpful, please consider **upvote**. It will encourage me to write more explanations like this. Thank you! \\uD83E\\uDD17",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution:\\n    def decodeAtIndex(self, S: str, K: int) -> str:\\n        idx = {}\\n        acclens = [0]\\n        prevd = 1\\n        j = 0\\n        for i, c in enumerate(S + \\'1\\'):\\n            if c.isalpha():\\n                idx[acclens[-1] * prevd + j] = i\\n                j += 1\\n            else:\\n                acclens.append(acclens[-1] * prevd + j)\\n                prevd = int(c)\\n                j = 0\\n        k = K - 1\\n        for al in reversed(acclens[1:]):\\n            k %= al\\n            if k in idx:\\n                return S[idx[k]]\\n        return None  # should never reach this\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976413,
                "title": "increasing-triplet-subsequence-c-faster-than-98-11",
                "content": "```\\nclass Solution {\\npublic:\\n    bool increasingTriplet(vector<int>& nums) {\\n        int a = INT_MAX;\\n        int b = INT_MAX;\\n        if(nums.size() < 3){\\n            return false;\\n        }\\n        for(int i = 0;i < nums.size();i++){\\n            if(a>=nums[i]){\\n                a = nums[i];\\n            }\\n            else if(b>=nums[i]){\\n                b = nums[i];\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool increasingTriplet(vector<int>& nums) {\\n        int a = INT_MAX;\\n        int b = INT_MAX;\\n        if(nums.size() < 3){\\n            return false;\\n        }\\n        for(int i = 0;i < nums.size();i++){\\n            if(a>=nums[i]){\\n                a = nums[i];\\n            }\\n            else if(b>=nums[i]){\\n                b = nums[i];\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957299,
                "title": "linkd-list-random-node-o-n-time-o-1-space-reservoir-sampling-alg-r-c",
                "content": "The question is, how do we travel a linked list of unknown length only once, and at the end has sampled only 1 value out of the list with equal opportunity given to each node?\\n\\nRESERVOIR SAMPLING!\\nGiven a linked list size n, and your sample size 1, the algorithm works like this:\\nat the first node, since there is 1 node in the sample pool, the chance of picking that node value is 100%. (1/1)\\nsecond node, since there are 2 nodes, chance of me ditching the old node value and picking the value of the second node is 50%. (1/2)\\nThird node is 33%. (1/3)\\n...\\nthe nth node has 1/n chance to be picked.\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* tmp;\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        tmp=head;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        ListNode* cur = tmp;\\n        int ans;\\n        int scp=1;\\n        while (cur!=NULL) {\\n            if (rand()<RAND_MAX/scp++)\\n                ans=cur->val;\\n            cur=cur->next;\\n        }\\n        return ans;\\n    }\\n\\n};\\n  \\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* tmp;\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        tmp=head;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        ListNode* cur = tmp;\\n        int ans;\\n        int scp=1;\\n        while (cur!=NULL) {\\n            if (rand()<RAND_MAX/scp++)\\n                ans=cur->val;\\n            cur=cur->next;\\n        }\\n        return ans;\\n    }\\n\\n};\\n  \\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 956827,
                "title": "c-easy-fast-solution-beats-95-submissions",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    ListNode* head =NULL;\\n    //int ans = 0;\\n    Solution(ListNode* h) {\\n        head = h;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        ListNode* curr= head;\\n        ListNode* res;\\n        int n=1;\\n        while(curr) {\\n            if (rand()% n == 0)\\n            res = curr;\\n            curr = curr->next;\\n            n++;\\n        }\\n   return res->val;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    ListNode* head =NULL;\\n    //int ans = 0;\\n    Solution(ListNode* h) {\\n        head = h;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        ListNode* curr= head;\\n        ListNode* res;\\n        int n=1;\\n        while(curr) {\\n            if (rand()% n == 0)\\n            res = curr;\\n            curr = curr->next;\\n            n++;\\n        }\\n   return res->val;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811617,
                "title": "python3-reservoir-sampling",
                "content": "Algo \\nScan thorugh the linked list and keep a counter `cnt`. Replace current `ans` with probability `1/cnt`. \\n\\n```\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        \"\"\"\\n        self.head = head # store head of linked list \\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        \"\"\"\\n        cnt = 0\\n        node = self.head \\n        while node: \\n            cnt += 1\\n            if randint(1, cnt) == cnt: ans = node.val # reservoir sampling \\n            node = node.next \\n        return ans \\n```\\n\\nEdited on 12/02/2020\\n```\\nclass Solution:\\n    def __init__(self, head: ListNode):\\n        self.head = head # store head \\n        \\n    def getRandom(self) -> int:\\n        node = self.head \\n        n = 0\\n        while node: \\n            if randint(0, n) == 0: ans = node.val\\n            n += 1\\n            node = node.next \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        \"\"\"\\n        self.head = head # store head of linked list \\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        \"\"\"\\n        cnt = 0\\n        node = self.head \\n        while node: \\n            cnt += 1\\n            if randint(1, cnt) == cnt: ans = node.val # reservoir sampling \\n            node = node.next \\n        return ans \\n```\n```\\nclass Solution:\\n    def __init__(self, head: ListNode):\\n        self.head = head # store head \\n        \\n    def getRandom(self) -> int:\\n        node = self.head \\n        n = 0\\n        while node: \\n            if randint(0, n) == 0: ans = node.val\\n            n += 1\\n            node = node.next \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 343576,
                "title": "reservoir-sampling-video-explanation",
                "content": "https://www.youtube.com/watch?v=Ybra0uGEkpM\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    Random rand;\\n    ListNode head = null;\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        rand = new Random();\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    public int getRandom() {\\n        int i = 0;\\n        ListNode temp = this.head;\\n        ListNode selected = null;\\n        while(temp != null){\\n            if(rand.nextInt(i + 1) == i){\\n                selected = temp;\\n            }\\n            temp = temp.next;\\n            i++;\\n        }\\n        return selected.val;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    Random rand;\\n    ListNode head = null;\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        rand = new Random();\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    public int getRandom() {\\n        int i = 0;\\n        ListNode temp = this.head;\\n        ListNode selected = null;\\n        while(temp != null){\\n            if(rand.nextInt(i + 1) == i){\\n                selected = temp;\\n            }\\n            temp = temp.next;\\n            i++;\\n        }\\n        return selected.val;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317767,
                "title": "c-random-o-1",
                "content": "```\\npublic class Solution {\\n    Random random = new Random();\\n    ListNode head;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n\\n    /** Returns a random node\\'s value. */\\n    public int GetRandom() {\\n        var candidate = this.head.val;\\n\\n        var n = 1;\\n\\n        var cur = head.next;\\n        n++;\\n\\n        while (cur != null) {\\n            var randomIndex = random.Next(n);\\n            if (randomIndex == 0) candidate = cur.val;\\n\\n            cur = cur.next;\\n            n++;\\n        }\\n        return candidate;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Random random = new Random();\\n    ListNode head;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n\\n    /** Returns a random node\\'s value. */\\n    public int GetRandom() {\\n        var candidate = this.head.val;\\n\\n        var n = 1;\\n\\n        var cur = head.next;\\n        n++;\\n\\n        while (cur != null) {\\n            var randomIndex = random.Next(n);\\n            if (randomIndex == 0) candidate = cur.val;\\n\\n            cur = cur.next;\\n            n++;\\n        }\\n        return candidate;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211599,
                "title": "python-solution",
                "content": "Reservoir sampling. Time complexity for `getRandom()`: `O(n)`.\\n\\n```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        :type head: ListNode\\n        \"\"\"\\n        self.head = head\\n        \\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        :rtype: int\\n        \"\"\"\\n        res = None\\n        length = 0\\n        trav = self.head\\n        while trav:\\n            num = random.randint(0, length)\\n            if num == 0:\\n                res = trav.val\\n            trav = trav.next\\n            length += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        :type head: ListNode\\n        \"\"\"\\n        self.head = head\\n        \\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        :rtype: int\\n        \"\"\"\\n        res = None\\n        length = 0\\n        trav = self.head\\n        while trav:\\n            num = random.randint(0, length)\\n            if num == 0:\\n                res = trav.val\\n            trav = trav.next\\n            length += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839825,
                "title": "using-rand-function",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\nvector<int>v;\\n    Solution(ListNode* head) {\\n        ListNode*temp = head;// we created vector v and insert all elements of linkedlist in vector\\n        while(temp!=NULL){\\n            v.push_back(temp ->val);\\n            temp =temp->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int n = v.size();\\n        int Random_ind = rand()%n; // gives us (0,1,2 ....n-1 )\\n        return v[Random_ind];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nvector<int>v;\\n    Solution(ListNode* head) {\\n        ListNode*temp = head;// we created vector v and insert all elements of linkedlist in vector\\n        while(temp!=NULL){\\n            v.push_back(temp ->val);\\n            temp =temp->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int n = v.size();\\n        int Random_ind = rand()%n; // gives us (0,1,2 ....n-1 )\\n        return v[Random_ind];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281724,
                "title": "you-are-probably-searching-for-this-simple-solution-java",
                "content": "# Approach\\nAnother bruteforce approach. Just calculating the random value by knowing the maximum length.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    int len;\\n    ListNode head;\\n    Random rand;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        ListNode dummyHead = head;\\n        len = 0;\\n        while(dummyHead!=null){\\n            len++;\\n            dummyHead = dummyHead.next;\\n        }\\n        rand = new Random();\\n    }\\n    \\n    public int getRandom() {\\n        int pos = rand.nextInt(len);\\n        ListNode cur = head;\\n        for(int i=0; i<pos; i++){\\n            cur = cur.next;\\n        }\\n        return cur.val;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/80a91048-afcf-4878-870d-da6144c5f9c9_1678482103.4934533.png)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    int len;\\n    ListNode head;\\n    Random rand;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n        ListNode dummyHead = head;\\n        len = 0;\\n        while(dummyHead!=null){\\n            len++;\\n            dummyHead = dummyHead.next;\\n        }\\n        rand = new Random();\\n    }\\n    \\n    public int getRandom() {\\n        int pos = rand.nextInt(len);\\n        ListNode cur = head;\\n        for(int i=0; i<pos; i++){\\n            cur = cur.next;\\n        }\\n        return cur.val;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280234,
                "title": "c-fully-explained-simple-approach",
                "content": "```\\n\\n/*\\nIntution Algorithm : Not any particular algorithm just using predefined rand() function and Linkedlist traversing.\\n\\nSteps:\\n    1. Initialize Len for calculating the length of linkedlist\\n    2. Initialize the HeadNode of linkedlist for keep track of head node of linked list\\n    3. In solution part we are just storing the head node into HeadNode variable and calculating the length by simple traversing method You can easily understand\\n    4. In Get Random funtion: \\n        First we find any random integer with the help of predefined function rand(), and modulo by length of linkedlist for keeping the range of rand_idx between the length of linked list\\n        Then we are just returning the value of linked list on the rand_idx position by going on by one on that positon\\n\\n */\\n \\n // If you finds my solution usefull then pelase upvote\\n\\n/* ====>>> Solution for Leetcode <<<=====  */\\n\\n//  Definition for singly-linked list.\\n /* struct ListNode\\n {\\n     int val;\\n     ListNode *next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n };\\n*/\\n class Solution\\n {\\n     int Len = 0;\\n     ListNode *HeadNode;\\n\\n public:\\n     Solution(ListNode *head)\\n     {\\n         HeadNode = head;\\n         ListNode *curr = head;\\n         while (curr)\\n         {\\n             Len++;\\n             curr = curr->next;\\n         }\\n     }\\n\\n     int getRandom()\\n     {\\n         int randIdx = rand() % Len;\\n         ListNode *curr = HeadNode;\\n         while (randIdx--)\\n         {\\n             curr = curr->next;\\n         }\\n         return curr->val;\\n     }\\n };\\n\\n /**\\n  * Your Solution object will be instantiated and called as such:\\n  * Solution* obj = new Solution(head);\\n  * int param_1 = obj->getRandom();\\n  */\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\n/*\\nIntution Algorithm : Not any particular algorithm just using predefined rand() function and Linkedlist traversing.\\n\\nSteps:\\n    1. Initialize Len for calculating the length of linkedlist\\n    2. Initialize the HeadNode of linkedlist for keep track of head node of linked list\\n    3. In solution part we are just storing the head node into HeadNode variable and calculating the length by simple traversing method You can easily understand\\n    4. In Get Random funtion: \\n        First we find any random integer with the help of predefined function rand(), and modulo by length of linkedlist for keeping the range of rand_idx between the length of linked list\\n        Then we are just returning the value of linked list on the rand_idx position by going on by one on that positon\\n\\n */\\n \\n // If you finds my solution usefull then pelase upvote\\n\\n/* ====>>> Solution for Leetcode <<<=====  */\\n\\n//  Definition for singly-linked list.\\n /* struct ListNode\\n {\\n     int val;\\n     ListNode *next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n };\\n*/\\n class Solution\\n {\\n     int Len = 0;\\n     ListNode *HeadNode;\\n\\n public:\\n     Solution(ListNode *head)\\n     {\\n         HeadNode = head;\\n         ListNode *curr = head;\\n         while (curr)\\n         {\\n             Len++;\\n             curr = curr->next;\\n         }\\n     }\\n\\n     int getRandom()\\n     {\\n         int randIdx = rand() % Len;\\n         ListNode *curr = HeadNode;\\n         while (randIdx--)\\n         {\\n             curr = curr->next;\\n         }\\n         return curr->val;\\n     }\\n };\\n\\n /**\\n  * Your Solution object will be instantiated and called as such:\\n  * Solution* obj = new Solution(head);\\n  * int param_1 = obj->getRandom();\\n  */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278858,
                "title": "382-linked-list-random-node-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount the number of elements in the link list and keep a head pointer.\\nIn get Random method get a random index from count and loop the list that amount of thime and return the value\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\nclass Solution\\n=begin\\n    :type head: ListNode\\n=end\\n    def initialize(head)\\n        # @array=[]\\n        @head=head\\n        @count=0\\n        while head\\n            # @array.push(head.val)\\n            @count+=1\\n            head=head.next\\n        end\\n        p @count\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def get_random()\\n        index=rand(@count)\\n        temp=@head\\n        index.times do\\n            temp=temp.next\\n        end\\n        temp.val\\n    end\\nend\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution.new(head)\\n# param_1 = obj.get_random()\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\nclass Solution\\n=begin\\n    :type head: ListNode\\n=end\\n    def initialize(head)\\n        # @array=[]\\n        @head=head\\n        @count=0\\n        while head\\n            # @array.push(head.val)\\n            @count+=1\\n            head=head.next\\n        end\\n        p @count\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def get_random()\\n        index=rand(@count)\\n        temp=@head\\n        index.times do\\n            temp=temp.next\\n        end\\n        temp.val\\n    end\\nend\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution.new(head)\\n# param_1 = obj.get_random()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278425,
                "title": "kotlin-reservoir",
                "content": "```\\n\\nclass Solution\\ninternal constructor(private val head: ListNode?) {\\n\\n  fun getRandom(): Int {\\n    var cur = head\\n    var count = 0\\n\\n    var res = -1\\n    while (cur != null) {\\n      count++\\n      if ((count.toDouble() * Math.random()).toInt() == 0) {\\n        res = cur.`val`\\n      }\\n      cur = cur.next\\n    }\\n    return res\\n  }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n\\nclass Solution\\ninternal constructor(private val head: ListNode?) {\\n\\n  fun getRandom(): Int {\\n    var cur = head\\n    var count = 0\\n\\n    var res = -1\\n    while (cur != null) {\\n      count++\\n      if ((count.toDouble() * Math.random()).toInt() == 0) {\\n        res = cur.`val`\\n      }\\n      cur = cur.next\\n    }\\n    return res\\n  }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278365,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<ListNode*> nodes;\\n\\n    Solution(ListNode* head) {\\n        while(head!=NULL)\\n        {\\n            nodes.push_back(head);\\n            head=head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n\\n      int n=nodes.size();\\n      int radn=rand()%n;\\n      return nodes[radn]->val;  \\n      \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<ListNode*> nodes;\\n\\n    Solution(ListNode* head) {\\n        while(head!=NULL)\\n        {\\n            nodes.push_back(head);\\n            head=head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n\\n      int n=nodes.size();\\n      int radn=rand()%n;\\n      return nodes[radn]->val;  \\n      \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278174,
                "title": "java-o-n-space-o-1-get-time-5-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ for `Solution()`, $$O(1)$$ for `getRandom()`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<Integer> vals;\\n\\n  public Solution(ListNode head) {\\n    vals = new ArrayList<>();\\n\\n    for (; head != null; head = head.next)\\n      vals.add(head.val);\\n  }\\n  \\n  public int getRandom() {\\n    return vals.get((int)(Math.random() * vals.size()));\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n  List<Integer> vals;\\n\\n  public Solution(ListNode head) {\\n    vals = new ArrayList<>();\\n\\n    for (; head != null; head = head.next)\\n      vals.add(head.val);\\n  }\\n  \\n  public int getRandom() {\\n    return vals.get((int)(Math.random() * vals.size()));\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278146,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>list;\\n    Solution(ListNode* head) {\\n        ListNode * tmp = head;\\n        while(tmp)\\n        {\\n            list.push_back(tmp->val);\\n            tmp = tmp->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int n = list.size();\\n        int ind = rand()%n;\\n        return list[ind];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>list;\\n    Solution(ListNode* head) {\\n        ListNode * tmp = head;\\n        while(tmp)\\n        {\\n            list.push_back(tmp->val);\\n            tmp = tmp->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int n = list.size();\\n        int ind = rand()%n;\\n        return list[ind];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672350,
                "title": "c-trick-solution-use-circular-linked-list",
                "content": "```\\ntypedef struct {\\n    struct ListNode *list;\\n    size_t size;\\n} Solution;\\n\\n\\nSolution* solutionCreate(struct ListNode* head) {\\n    Solution *obj = (Solution *)malloc(sizeof(Solution));\\n    obj->list = head;\\n    while(head->next) \\n        head = head->next;\\n    head->next = obj->list;\\n        \\n    return obj;\\n}\\n\\nint solutionGetRandom(Solution* obj) {\\n    struct ListNode *node = obj->list;\\n    int n = rand() % 10;\\n    while(n--)\\n        node = node->next;\\n    return node->val;\\n}\\n\\nvoid solutionFree(Solution* obj) {\\n    free(obj->list);\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\ntypedef struct {\\n    struct ListNode *list;\\n    size_t size;\\n} Solution;\\n\\n\\nSolution* solutionCreate(struct ListNode* head) {\\n    Solution *obj = (Solution *)malloc(sizeof(Solution));\\n    obj->list = head;\\n    while(head->next) \\n        head = head->next;\\n    head->next = obj->list;\\n        \\n    return obj;\\n}\\n\\nint solutionGetRandom(Solution* obj) {\\n    struct ListNode *node = obj->list;\\n    int n = rand() % 10;\\n    while(n--)\\n        node = node->next;\\n    return node->val;\\n}\\n\\nvoid solutionFree(Solution* obj) {\\n    free(obj->list);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1672258,
                "title": "c-solution-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(ListNode* head) {\\n        while(head!=NULL)\\n        {\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n    }\\n    //rand function generate value between 0 to v.size() index\\n    int getRandom() {\\n        int r=rand()%v.size();\\n        return v[r];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> v;\\n    Solution(ListNode* head) {\\n        while(head!=NULL)\\n        {\\n            v.push_back(head->val);\\n            head=head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1672175,
                "title": "java-solution",
                "content": "Fixed range sampling\\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null)\\n        {\\n            list.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        // defining the range for the index\\n        int random_index = (int)((Math.random()*(list.size())));\\n        return list.get(random_index);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null)\\n        {\\n            list.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        // defining the range for the index\\n        int random_index = (int)((Math.random()*(list.size())));\\n        return list.get(random_index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672121,
                "title": "python3-6-liners",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nfrom random import randint\\n\\nclass Solution:\\n    \\n    def __init__(self, head: Optional[ListNode]):\\n        self.range = []\\n        while head:\\n            self.range.append(head.val)\\n            head = head.next\\n\\n    def getRandom(self) -> int:\\n        rand = randint(0, len(self.range)-1)\\n        return self.range[rand]\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nfrom random import randint\\n\\nclass Solution:\\n    \\n    def __init__(self, head: Optional[ListNode]):\\n        self.range = []\\n        while head:\\n            self.range.append(head.val)\\n            head = head.next\\n\\n    def getRandom(self) -> int:\\n        rand = randint(0, len(self.range)-1)\\n        return self.range[rand]\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672113,
                "title": "java-faster-than-99-solution",
                "content": "```\\nclass Solution {\\n    ListNode head;\\n    int listLength = 0;\\n    int lastFetchedElementIndex;\\n    ListNode lastFetchedElement;\\n    Random random;\\n\\n    public Solution(ListNode head) {\\n        random = new Random();\\n        this.head = head;\\n        lastFetchedElementIndex = 1;\\n        lastFetchedElement = head;\\n\\n        while(head != null) {\\n            listLength++;\\n            head = head.next;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        int randomIndex = getRandomNumber();\\n        if (randomIndex < lastFetchedElementIndex) {\\n            lastFetchedElementIndex = 1;\\n            lastFetchedElement = head;\\n        }\\n        \\n        while (lastFetchedElementIndex < randomIndex) {\\n            lastFetchedElementIndex++;\\n            lastFetchedElement = lastFetchedElement.next;\\n        }\\n        \\n        return lastFetchedElement.val;\\n    }\\n\\n    public int getRandomNumber() {\\n        return random.nextInt(listLength) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    ListNode head;\\n    int listLength = 0;\\n    int lastFetchedElementIndex;\\n    ListNode lastFetchedElement;\\n    Random random;\\n\\n    public Solution(ListNode head) {\\n        random = new Random();\\n        this.head = head;\\n        lastFetchedElementIndex = 1;\\n        lastFetchedElement = head;\\n\\n        while(head != null) {\\n            listLength++;\\n            head = head.next;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        int randomIndex = getRandomNumber();\\n        if (randomIndex < lastFetchedElementIndex) {\\n            lastFetchedElementIndex = 1;\\n            lastFetchedElement = head;\\n        }\\n        \\n        while (lastFetchedElementIndex < randomIndex) {\\n            lastFetchedElementIndex++;\\n            lastFetchedElement = lastFetchedElement.next;\\n        }\\n        \\n        return lastFetchedElement.val;\\n    }\\n\\n    public int getRandomNumber() {\\n        return random.nextInt(listLength) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672098,
                "title": "javascript-circular-linked-list",
                "content": "```js\\nclass Solution {\\n  constructor(head) {\\n    this.size = 1e4;\\n    this.count = 0;\\n    this.head = head;\\n    this.node = head;\\n  }\\n\\n  /**\\n   * @return {number}\\n   */\\n  getRandom() {\\n    let node = this.node;\\n    let rand = (Math.random() * this.size) | 0;\\n    do {\\n      if (this.head !== null) {\\n        this.count++;\\n      }\\n      node = this.node;\\n      this.node = node.next;\\n    } while (this.node && --rand >= 0);\\n    if (this.node) {\\n      return node.val;\\n    }\\n    node.next = this.head;\\n    this.node = this.head;\\n    this.head = null;\\n    this.size = this.count;\\n    return this.getRandom();\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass Solution {\\n  constructor(head) {\\n    this.size = 1e4;\\n    this.count = 0;\\n    this.head = head;\\n    this.node = head;\\n  }\\n\\n  /**\\n   * @return {number}\\n   */\\n  getRandom() {\\n    let node = this.node;\\n    let rand = (Math.random() * this.size) | 0;\\n    do {\\n      if (this.head !== null) {\\n        this.count++;\\n      }\\n      node = this.node;\\n      this.node = node.next;\\n    } while (this.node && --rand >= 0);\\n    if (this.node) {\\n      return node.val;\\n    }\\n    node.next = this.head;\\n    this.node = this.head;\\n    this.head = null;\\n    this.size = this.count;\\n    return this.getRandom();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672045,
                "title": "easy-approach-in-c",
                "content": "smjh\\n```\\nclass Solution {\\npublic:\\n    ListNode *root;\\n    Solution(ListNode* head) {\\n      root = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        ListNode *curr = root;\\n        ListNode *temp = NULL;\\n        int i = 1;\\n        while(curr != NULL){\\n            if(rand()%i == 0 ){\\n                temp = curr;\\n            }\\n            i++;\\n            curr= curr->next;\\n        }\\n        return temp->val;\\n        \\n    }\\n};\\n```\\nDo upvote if you find it helpful",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *root;\\n    Solution(ListNode* head) {\\n      root = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        ListNode *curr = root;\\n        ListNode *temp = NULL;\\n        int i = 1;\\n        while(curr != NULL){\\n            if(rand()%i == 0 ){\\n                temp = curr;\\n            }\\n            i++;\\n            curr= curr->next;\\n        }\\n        return temp->val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672015,
                "title": "c-brute-force-solution-to-optimal-solution",
                "content": "1) **Brute Force Solution**\\n\\t\\n\\t-> Here, we are storing all the nodes of the linkedlist by traversing one pass\\n\\t-> To return random value with same probablity, using **rand()** function\\n\\t\\n\\tTime complexity : O(N) , O(1) -> getRandom() function\\n\\n\\tSpace complexity :  O(N) -> for storing elements\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\n    private:\\n    vector<int> nodes;\\npublic:\\n    Solution(ListNode* head) {\\n        \\n        ListNode *cur = head;\\n        \\n        while(cur)\\n        {\\n            // storing nodes into vector\\n            nodes.push_back(cur -> val);\\n            \\n            // traversing\\n            cur = cur -> next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        \\n        // get the size of node vector\\n        int size = nodes.size();\\n        \\n        // return rand() % size\\n        return nodes[rand() % size];\\n    }\\n};\\n```\\n\\n2) **Optimal Solution**\\n\\n\\tThe idea is to pick random elements from the linkedlist with equal probability.\\n\\n   **Reservoir Sampling** is the algorithm to pick some \\'x\\' elements in list of \\'n\\' values with equal probability.\\n   \\n\\t  **Random element with equal probablity = X(Elements need to be picked i.e rand()) / Number of nodes till we traversed i.e pos**\\n\\n\\tFor eg:\\n\\n\\tInitilally, we have 1 nodes, let\\'s take rand() will be 1 so random element = 1 / 1\\n\\tAfter that, we have 2 nodes, so random element = 1 / 2\\n\\tLikewise, ..... it goes on.\\n\\n\\tTime complexity : O(N) , O(1) -> getRandom() function\\n\\n\\tSpace complexity :  O(1) -> for storing elements\\n```\\nclass Solution {\\n    private:\\n    ListNode *copy;\\npublic:\\n    Solution(ListNode* head) {\\n        \\n        // copying head pointer \\n        copy = head;\\n    }\\n    \\n    int getRandom() {\\n        \\n        ListNode *temp = copy;\\n        int pos = 1, res;\\n        \\n        // traverse the linked list\\n        while(temp)\\n        {          \\n            // probability will be rand() / num of elements we traversed\\n            if(rand() % pos == 0)\\n                res = temp -> val;\\n            \\n            temp = temp -> next;\\n            pos++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    vector<int> nodes;\\npublic:\\n    Solution(ListNode* head) {\\n        \\n        ListNode *cur = head;\\n        \\n        while(cur)\\n        {\\n            // storing nodes into vector\\n            nodes.push_back(cur -> val);\\n            \\n            // traversing\\n            cur = cur -> next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        \\n        // get the size of node vector\\n        int size = nodes.size();\\n        \\n        // return rand() % size\\n        return nodes[rand() % size];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private:\\n    ListNode *copy;\\npublic:\\n    Solution(ListNode* head) {\\n        \\n        // copying head pointer \\n        copy = head;\\n    }\\n    \\n    int getRandom() {\\n        \\n        ListNode *temp = copy;\\n        int pos = 1, res;\\n        \\n        // traverse the linked list\\n        while(temp)\\n        {          \\n            // probability will be rand() / num of elements we traversed\\n            if(rand() % pos == 0)\\n                res = temp -> val;\\n            \\n            temp = temp -> next;\\n            pos++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672011,
                "title": "basic-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* head;\\n    int nodes;\\n    \\n    Solution(ListNode* head):head(head) {\\n        auto p = head;\\n        nodes = 0;\\n        while(p) {\\n            nodes++;\\n            p = p->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int randNode = rand()%nodes;\\n        auto p = head;\\n        for(int i = 0; i < randNode; i++) p = p->next;\\n        return p->val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* head;\\n    int nodes;\\n    \\n    Solution(ListNode* head):head(head) {\\n        auto p = head;\\n        nodes = 0;\\n        while(p) {\\n            nodes++;\\n            p = p->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1672000,
                "title": "java-image-comment-explaination-of-reservoir-sampling",
                "content": "**Reservoir Sampling**\\n* \\tlets says if the values are coming as `1, 2, 3 ..`\\n*   on `1` then we have `1` only choice to select : `1`\\n*   on `2` then out of two elements, we need to select `1`, then new item should be given `1/2` chance\\n*   so any random number that comes less than or equal to `1/2` then select : `2`\\n*   on `3` then out of three elements, we need to select `1`, then new item should be given `1/3` chance, others will have `2/3` probability because they already exists with more probabilty\\n*   so select : `3` if random number comes between `0 < random <= 1/3`\\n\\t\\n![image](https://assets.leetcode.com/users/images/42f7c119-62f9-48ab-ac1f-6880182fd717_1641534460.483314.png)\\n\\n\\n```\\nclass Solution {\\n    \\n    ListNode node;\\n    public Solution(ListNode head) {\\n        //store the head in node\\n\\t\\tnode = head;\\n    }\\n    \\n    public int getRandom() {\\n        //running index, i\\n\\t\\tint i = 1;\\n        //our selection\\n\\t\\tint select = 0;\\n        // curr assigned with the head of the node\\n\\t\\tListNode curr = node;\\n        //loop through all the nodes\\n\\t\\twhile(curr != null){\\n            //pick random and check if the value is < or <= 1/i\\n\\t\\t\\tif(Math.random() <= 1.0 / i)\\n                //set the selection to current value\\n\\t\\t\\t\\tselect = curr.val;\\n            //increment the index\\n\\t\\t\\ti += 1;\\n            //move to the next node\\n\\t\\t\\tcurr = curr.next;\\n        }\\n        //finally return the selection\\n\\t\\treturn select;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ListNode node;\\n    public Solution(ListNode head) {\\n        //store the head in node\\n\\t\\tnode = head;\\n    }\\n    \\n    public int getRandom() {\\n        //running index, i\\n\\t\\tint i = 1;\\n        //our selection\\n\\t\\tint select = 0;\\n        // curr assigned with the head of the node\\n\\t\\tListNode curr = node;\\n        //loop through all the nodes\\n\\t\\twhile(curr != null){\\n            //pick random and check if the value is < or <= 1/i\\n\\t\\t\\tif(Math.random() <= 1.0 / i)\\n                //set the selection to current value\\n\\t\\t\\t\\tselect = curr.val;\\n            //increment the index\\n\\t\\t\\ti += 1;\\n            //move to the next node\\n\\t\\t\\tcurr = curr.next;\\n        }\\n        //finally return the selection\\n\\t\\treturn select;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671999,
                "title": "3-different-solutions",
                "content": "Solution 1 :\\n```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(ListNode* head) {\\n        while(head)\\n        {\\n            arr.push_back(head->val);\\n            head=head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n```\\n\\nSolution 2:\\n```\\nclass Solution {\\npublic:\\n    int size=-1;\\n    ListNode *start = NULL;\\n    Solution(ListNode* head) {\\n        start = head;\\n        size=0;\\n        while(head)\\n        {\\n            size++;\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int index = rand()%size;\\n        ListNode *head=start;\\n        while(index--)\\n            head = head->next;\\n        return head->val;\\n    }\\n};\\n```\\n\\nSolution 3:\\n```\\nclass Solution {\\npublic:\\n    ListNode *start;\\n    Solution(ListNode* head) {\\n        start=head;\\n    }\\n    \\n    int getRandom() {\\n        int scope=1, chosenValue=0;\\n        ListNode *curr = start;\\n        while(curr)\\n        {\\n            if(rand()%scope==0)\\n                chosenValue=curr->val;\\n            scope++;\\n            curr = curr->next;\\n        }\\n        return chosenValue;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(ListNode* head) {\\n        while(head)\\n        {\\n            arr.push_back(head->val);\\n            head=head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int size=-1;\\n    ListNode *start = NULL;\\n    Solution(ListNode* head) {\\n        start = head;\\n        size=0;\\n        while(head)\\n        {\\n            size++;\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int index = rand()%size;\\n        ListNode *head=start;\\n        while(index--)\\n            head = head->next;\\n        return head->val;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *start;\\n    Solution(ListNode* head) {\\n        start=head;\\n    }\\n    \\n    int getRandom() {\\n        int scope=1, chosenValue=0;\\n        ListNode *curr = start;\\n        while(curr)\\n        {\\n            if(rand()%scope==0)\\n                chosenValue=curr->val;\\n            scope++;\\n            curr = curr->next;\\n        }\\n        return chosenValue;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671997,
                "title": "easy-to-understand-solution-with-rand",
                "content": "```\\n#define rep(i,a,b) for (int i = a; i<b;i++)\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    \\n    private:\\n        int list_length;\\n        ListNode * head_ptr;\\n    \\n    public:\\n        Solution(ListNode* head) {\\n            head_ptr = head;\\n            list_length = 0;\\n            while(head){\\n                list_length++;\\n                head = head->next;\\n            }\\n        }\\n\\n        int getRandom() {\\n           // Return random node\\n            int return_position = rand()%list_length;\\n            ListNode * temp = head_ptr;\\n            rep(i,0,return_position){\\n                temp = temp->next;\\n            }\\n            return temp->val;\\n        }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define rep(i,a,b) for (int i = a; i<b;i++)\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    \\n    private:\\n        int list_length;\\n        ListNode * head_ptr;\\n    \\n    public:\\n        Solution(ListNode* head) {\\n            head_ptr = head;\\n            list_length = 0;\\n            while(head){\\n                list_length++;\\n                head = head->next;\\n            }\\n        }\\n\\n        int getRandom() {\\n           // Return random node\\n            int return_position = rand()%list_length;\\n            ListNode * temp = head_ptr;\\n            rep(i,0,return_position){\\n                temp = temp->next;\\n            }\\n            return temp->val;\\n        }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1671970,
                "title": "c-o-n-time-complexity",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode *h;\\n    int cnt;\\npublic:\\n    Solution(ListNode* head) {\\n        this->cnt = 0;\\n        this->h = head;\\n        ListNode *cur = this->h;\\n        while(cur) {\\n            this->cnt++;\\n            cur = cur->next;\\n        } \\n    }\\n    \\n    int getRandom() {\\n        int n = rand() % this->cnt;\\n        ListNode *cur = this->h;\\n        while(n--) {\\n            cur = cur->next;\\n        }\\n        return cur->val;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode *h;\\n    int cnt;\\npublic:\\n    Solution(ListNode* head) {\\n        this->cnt = 0;\\n        this->h = head;\\n        ListNode *cur = this->h;\\n        while(cur) {\\n            this->cnt++;\\n            cur = cur->next;\\n        } \\n    }\\n    \\n    int getRandom() {\\n        int n = rand() % this->cnt;\\n        ListNode *cur = this->h;\\n        while(n--) {\\n            cur = cur->next;\\n        }\\n        return cur->val;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1494410,
                "title": "rust-o-1-space",
                "content": "```rust\\nuse rand::{rngs::ThreadRng, Rng};\\npub struct Solution {\\n    head: Option<Box<ListNode>>,\\n    len: usize,\\n    rng: ThreadRng,\\n}\\n\\nimpl Solution {\\n    pub fn new(head: Option<Box<ListNode>>) -> Self {\\n        Self {\\n            len: (0..).scan(&head, |node, _| {\\n                    node.as_deref().map(|next| *node = &next.next)\\n                })\\n                .fuse()\\n                .count(),\\n            rng: ThreadRng::default(),\\n            head,\\n        }\\n    }\\n\\n    pub fn get_random(&mut self) -> i32 {\\n        (0..self.rng.gen_range(0, self.len))\\n            .fold(self.head.as_deref().unwrap(), |ptr, _| {\\n                ptr.next.as_deref().unwrap()\\n            })\\n            .val\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse rand::{rngs::ThreadRng, Rng};\\npub struct Solution {\\n    head: Option<Box<ListNode>>,\\n    len: usize,\\n    rng: ThreadRng,\\n}\\n\\nimpl Solution {\\n    pub fn new(head: Option<Box<ListNode>>) -> Self {\\n        Self {\\n            len: (0..).scan(&head, |node, _| {\\n                    node.as_deref().map(|next| *node = &next.next)\\n                })\\n                .fuse()\\n                .count(),\\n            rng: ThreadRng::default(),\\n            head,\\n        }\\n    }\\n\\n    pub fn get_random(&mut self) -> i32 {\\n        (0..self.rng.gen_range(0, self.len))\\n            .fold(self.head.as_deref().unwrap(), |ptr, _| {\\n                ptr.next.as_deref().unwrap()\\n            })\\n            .val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1376449,
                "title": "c-simple-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<int> vect;\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        while (head) {\\n            vect.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        return vect[rand() % vect.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<int> vect;\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        while (head) {\\n            vect.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        return vect[rand() % vect.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229109,
                "title": "python-reservoir-sampling-more-general-algo",
                "content": "```\\nclass Solution(object):\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        # put first item into sample\\n        choice = self.head.val\\n        node = self.head.next\\n        stream_size = 2\\n        # replace item in sample using reservoir sampling\\n        while node is not None:\\n            if random.randint(1, stream_size) == 1:\\n                choice = node.val\\n            node = node.next\\n            stream_size += 1\\n        return choice\\n```\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\n# reservoir sampling: good for choosing random item from a stream of unknown size\\n# linked list is similar to a stream, which you can only process nodes one-by-one\\n# we want to choose m=1 random item from a stream of size n\\n\\n# general algorithm for choosing any number(m) of random nodes:\\n# 1.take first m=1 items out from the stream as our chosen sample\\n# 2.walk though the stream, at ith item, we choose a random number(r) within the stream size we have gone through(1 to i)\\n# example: at 2nd item, we choose a random number in [1,2]; at 3rd item, we choose a random number in [1,3]\\n# **3.if r is within the sample size we want(1<=r<=m), replace rth item in sample with current stream item\\n\\n# some intuition: the last item (n) in the stream has prob of m/n to be chosen, which satisfy the randomness\\n# more math: the prob of second from last item (n-1) being chosen and stay in the sample till the end is\\n# (prob of n-1 being chosen as sample) x (prob of n-1 not being replaced by the last item)\\n# = (m/(n-1)) x (1-1/n) = (m/(n-1)) x ((n-1)/n) = m(n-1)/(n-1)n = m/n, which also satisfy the randomness\\n\\n# Q: why (prob of item n-1 being replaced by item n) is 1/n instead of m/n?\\n# A: because item n-1 only takes 1 space in the sample, \\n#    the randomly picked number r needs to be the same index of n-1 in the sample to replace n-1\\n# example: if we want m=2 random nodes, current sample holds 2 nodes {n-2, n-1}, we are at the last item n.\\n# we choose a random number r from 1 to n. if r is 1, we\\'ll replace n-2 in the sample with n.\\n# only if r is 2, we\\'ll replace n-1 in the sample with n. \\n\\ndef getRandom_m(self, m):\\n\\tsample = []\\n\\tnode = self.head\\n\\ti = 0\\n\\t# put first m items into sample\\n\\twhile node is not None and i < m:\\n\\t\\tsample.append(node.val)\\n\\t\\tnode = node.next\\n\\t\\ti += 1\\n\\tstream_size = m+1\\n\\t# replace item in sample using reservoir sampling\\n\\twhile node is not None:\\n\\t\\tr = random.randint(1, stream_size)\\n\\t\\tif 1 <= r <= m:\\n\\t\\t\\tsample[r-1] = node.val\\n\\t\\tnode = node.next\\n\\t\\tstream_size += 1\\n\\treturn sample\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def __init__(self, head):\\n        self.head = head\\n\\n    def getRandom(self):\\n        # put first item into sample\\n        choice = self.head.val\\n        node = self.head.next\\n        stream_size = 2\\n        # replace item in sample using reservoir sampling\\n        while node is not None:\\n            if random.randint(1, stream_size) == 1:\\n                choice = node.val\\n            node = node.next\\n            stream_size += 1\\n        return choice\\n```\n```\\n# reservoir sampling: good for choosing random item from a stream of unknown size\\n# linked list is similar to a stream, which you can only process nodes one-by-one\\n# we want to choose m=1 random item from a stream of size n\\n\\n# general algorithm for choosing any number(m) of random nodes:\\n# 1.take first m=1 items out from the stream as our chosen sample\\n# 2.walk though the stream, at ith item, we choose a random number(r) within the stream size we have gone through(1 to i)\\n# example: at 2nd item, we choose a random number in [1,2]; at 3rd item, we choose a random number in [1,3]\\n# **3.if r is within the sample size we want(1<=r<=m), replace rth item in sample with current stream item\\n\\n# some intuition: the last item (n) in the stream has prob of m/n to be chosen, which satisfy the randomness\\n# more math: the prob of second from last item (n-1) being chosen and stay in the sample till the end is\\n# (prob of n-1 being chosen as sample) x (prob of n-1 not being replaced by the last item)\\n# = (m/(n-1)) x (1-1/n) = (m/(n-1)) x ((n-1)/n) = m(n-1)/(n-1)n = m/n, which also satisfy the randomness\\n\\n# Q: why (prob of item n-1 being replaced by item n) is 1/n instead of m/n?\\n# A: because item n-1 only takes 1 space in the sample, \\n#    the randomly picked number r needs to be the same index of n-1 in the sample to replace n-1\\n# example: if we want m=2 random nodes, current sample holds 2 nodes {n-2, n-1}, we are at the last item n.\\n# we choose a random number r from 1 to n. if r is 1, we\\'ll replace n-2 in the sample with n.\\n# only if r is 2, we\\'ll replace n-1 in the sample with n. \\n\\ndef getRandom_m(self, m):\\n\\tsample = []\\n\\tnode = self.head\\n\\ti = 0\\n\\t# put first m items into sample\\n\\twhile node is not None and i < m:\\n\\t\\tsample.append(node.val)\\n\\t\\tnode = node.next\\n\\t\\ti += 1\\n\\tstream_size = m+1\\n\\t# replace item in sample using reservoir sampling\\n\\twhile node is not None:\\n\\t\\tr = random.randint(1, stream_size)\\n\\t\\tif 1 <= r <= m:\\n\\t\\t\\tsample[r-1] = node.val\\n\\t\\tnode = node.next\\n\\t\\tstream_size += 1\\n\\treturn sample\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180864,
                "title": "c-solution",
                "content": "\\n\\t class Solution {\\n           ListNode* u;\\n           public:\\n          /** @param head The linked list\\'s head.\\n          Note that the head is guaranteed to be not null, so it contains at least one node. */\\n         Solution(ListNode* head) {\\n          u = head;\\n    }\\n    \\n       /** Returns a random node\\'s value. */\\n       int getRandom() {\\n        \\n        int res = u->val;\\n\\t\\tint len = 1;      //starts from second node \\n        ListNode* v = u;\\n        while(v){\\n            if(rand() % len == 0){     //if random value comes as 0 i.e head of list, update it with value of corresponding v\\'s node\\n                res = v->val;\\n            }\\n            len++;\\n            v = v->next;\\n        }\\n        return res;       \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n           ListNode* u;\\n           public:\\n          /** @param head The linked list\\'s head.\\n          Note that the head is guaranteed to be not null, so it contains at least one node. */\\n         Solution(ListNode* head) {\\n          u = head;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 992152,
                "title": "pseudo-palindromic-paths-in-a-binary-tree-using-c-with-explanation",
                "content": "As the values of nodes are in range of 1 to 9 . So, we dont need to store all the values in a vector , to improve the space complexity we will just store how many 1\\'s , 2\\'s , 3\\'s ....... 9\\'s are present in current path , for which we need a vector of only size 10; \\nNow if more than 1 value is present in odd number then we can form a palindrome of it.\\nElse we can form a palindrome from it.\\n\\nI hope You will like it. For any doubt comment it.[](http://)\\nCode:-\\n\\n```\\n #define rep(i,a,b) for(lli i=a;i<b;i++)\\nclass Solution {\\npublic:\\n    vector<int> fre;               //<-------vector to store the values which are present in curent path--> \\n    int ans=0;                     //<-------store the answer---->\\n\\t\\n\\t//<------------------------DFS code starts------------->\\n    void dfs(TreeNode* node)\\n    {   if(node==NULL) return; \\n        int value=node->val;\\n         fre[value]++;   //<---storing the value of node in \"fre\" variable--->\\n          if((node->left==NULL) && (node->right==NULL))// That means it is leaf node\\n          {\\n              int c=0;\\n              rep(i,1,10){\\n                  c+=(fre[i]%2!=0);\\n              }\\n              if(c<=1) ans++;\\n         }\\n          if(node->left!=NULL)    { dfs(node->left); }\\n       \\n          if(node->right!=NULL)  { dfs(node->right); }\\n          \\n     fre[value]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        rep(i,0,10) fre.pb(0);\\n        dfs(root);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n #define rep(i,a,b) for(lli i=a;i<b;i++)\\nclass Solution {\\npublic:\\n    vector<int> fre;               //<-------vector to store the values which are present in curent path--> \\n    int ans=0;                     //<-------store the answer---->\\n\\t\\n\\t//<------------------------DFS code starts------------->\\n    void dfs(TreeNode* node)\\n    {   if(node==NULL) return; \\n        int value=node->val;\\n         fre[value]++;   //<---storing the value of node in \"fre\" variable--->\\n          if((node->left==NULL) && (node->right==NULL))// That means it is leaf node\\n          {\\n              int c=0;\\n              rep(i,1,10){\\n                  c+=(fre[i]%2!=0);\\n              }\\n              if(c<=1) ans++;\\n         }\\n          if(node->left!=NULL)    { dfs(node->left); }\\n       \\n          if(node->right!=NULL)  { dfs(node->right); }\\n          \\n     fre[value]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        rep(i,0,10) fre.pb(0);\\n        dfs(root);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982989,
                "title": "next-greater-element-iii-c-4-lines-0ms-easy-solution-using-next-permutation-function",
                "content": "1. C++ next_permutation function will give the next greater permutation which we want in this case\\n2. Make sure the result is within the required range (<= MAX_INT)\\n3. If it is outside range return -1\\n**Please upvote if you like it**\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        if (next_permutation(num.begin(), num.end())) {\\n            long res = stol(num);\\n            return res > INT_MAX ? -1 : res;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        if (next_permutation(num.begin(), num.end())) {\\n            long res = stol(num);\\n            return res > INT_MAX ? -1 : res;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981870,
                "title": "balanced-binary-tree-python-o-n-time-with-explanation",
                "content": "We DFS the tree and recursively check if each subtree is balanced. Because the definition of balancedness involves the depth of left and right subtrees, we also need to keep track of the depths for each subtree. So we maintain two values -- balancedness and depth. The base case is a null tree -- we see it as balanced and of depth 0 (`True, 0`). Otherwise, we go through its left and right subtree. It is only balanced if both of its left and right subtrees are balanced (`lgood and rgood`) and their depths are at most 1 apart (`rdepth - 1 <= ldepth <= rdepth + 1`). The depth of the current subtree is one deeper (itself) than the deeper one (`max(ldepth, rdepth) + 1`). \\n\\n```python\\ndef dfs(t):\\n    if t is None:\\n        return True, 0\\n    lgood, ldepth = dfs(t.left) \\n    rgood, rdepth = dfs(t.right) \\n    return (\\n        lgood and rgood and rdepth - 1 <= ldepth <= rdepth + 1,\\n        max(ldepth, rdepth) + 1\\n    )\\n\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        return dfs(root)[0]\\n```\\n\\nWe could further compress the two return values into one, using the infinity (`inf`) as an indicator for unbalancedness. You could also use other values outside the possible values for tree depths (aka positive integers) as the indicator, such as `-1` or `None`. I choose `inf` because it does not cause any trouble with `max` and `rdepth - 1 <= ldepth <= rdepth + 1`.\\n\\n```python\\ndef dfs(t):\\n    if t is None:\\n        return 0\\n    ldepth = dfs(t.left) \\n    rdepth = dfs(t.right) \\n    return max(ldepth, rdepth) + 1 if rdepth - 1 <= ldepth <= rdepth + 1 else inf\\n\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        return dfs(root) < inf\\n```\\n\\nComplexity: Travels each node exactly once, thus O(n) time. n is the size of the input tree. The \"extra\" recurssions for null nodes are fine, as there are at most two null children for each node in the tree.\\n\\n---\\nIf you find this helpful, please consider **upvote**! It will motivate me to write more explanations like this. Thank you! \\uD83E\\uDD17",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\ndef dfs(t):\\n    if t is None:\\n        return True, 0\\n    lgood, ldepth = dfs(t.left) \\n    rgood, rdepth = dfs(t.right) \\n    return (\\n        lgood and rgood and rdepth - 1 <= ldepth <= rdepth + 1,\\n        max(ldepth, rdepth) + 1\\n    )\\n\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        return dfs(root)[0]\\n```\n```python\\ndef dfs(t):\\n    if t is None:\\n        return 0\\n    ldepth = dfs(t.left) \\n    rdepth = dfs(t.right) \\n    return max(ldepth, rdepth) + 1 if rdepth - 1 <= ldepth <= rdepth + 1 else inf\\n\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        return dfs(root) < inf\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967991,
                "title": "remove-duplicates-from-sorted-array-ii-c",
                "content": "**My Approach** : I used a pointer  --> i, for keeping track of the position I am currently in and a variable --> count, to count the occurence of the same element. Whenever the count exceeds 2 i.e more than 2 same elements, I erase it from the vector using the inbuilt erase() function; otherwise, I increase the pointer and reset the count variable to 1.\\nPls read the code for better clarity.\\nThanks!\\n**Pls upvote if you find this helpful.**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        if((nums.size() == 0) || (nums.size() == 1))\\n            return nums.size();\\n        \\n        int i = 1,count = 1;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] == nums[i-1])\\n            {\\n                if(count >= 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                }\\n                else\\n                {\\n                    i += 1;\\n                    count += 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n                i += 1;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        if((nums.size() == 0) || (nums.size() == 1))\\n            return nums.size();\\n        \\n        int i = 1,count = 1;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] == nums[i-1])\\n            {\\n                if(count >= 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                }\\n                else\\n                {\\n                    i += 1;\\n                    count += 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n                i += 1;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957319,
                "title": "circular-linked-list-unique-efficient-yet-easy-to-understand",
                "content": "\\nA simple intutive solution that occured to me. \\n1. make the linked list as circular linked list.\\n2. find size of the list.\\n3. for getting the random value, move a random number of nodes between 0 and size-1.\\n\\n```\\nclass Solution {\\n\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    int size;\\n    ListNode head;\\n    Random rn;\\n    public Solution(ListNode head) {\\n        ListNode temp = head;\\n        size = 1;\\n        rn = new Random();\\n        while(temp.next != null) {\\n            size++;\\n            temp = temp.next;\\n        }\\n        temp.next = head;\\n        this.head = head;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    public int getRandom() {\\n        int toMove = rn.nextInt(size);\\n        while(toMove > 0) {\\n            toMove--;\\n            head = head.next;\\n        }\\n        return head.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    int size;\\n    ListNode head;\\n    Random rn;\\n    public Solution(ListNode head) {\\n        ListNode temp = head;\\n        size = 1;\\n        rn = new Random();\\n        while(temp.next != null) {\\n            size++;\\n            temp = temp.next;\\n        }\\n        temp.next = head;\\n        this.head = head;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    public int getRandom() {\\n        int toMove = rn.nextInt(size);\\n        while(toMove > 0) {\\n            toMove--;\\n            head = head.next;\\n        }\\n        return head.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957111,
                "title": "c-reservoir-sampling",
                "content": "Idea:\\nReservoir sampling is a trick used in many applications. One such application field is machine learning, and in particular online learning.\\n\\nOnline learning is a branch of machine learning where an algorithm is expected to learn from a sequence, typically on the fly. Many applications require maintaining a sketch of the training samples (a uniformly subsampled set of samples). In this case typically reservoir sampling is used with a size of s. This problem is a special case where s=1. The implementation is straightforward. At node 1 you choose the value in this node. At node 2 you replace this value with probability 1/2, at node you replace with probability 1/3 and so on. It is easy to show that the returned sample has (1/n) probability of being chosen.\\n\\nExtra: If we know the length n instead we can also sample from a (modified) geometric distribution. We return the first element with probability p := 1/n, if not we return the second element with probability p/(1-p), the third with p/(1-p)^2 and so on. The returned sample then has 1/n probability of being chosen.\\n\\nTime: O(n) (per random draw)\\nSpace: O(1)\\n\\nAlso note that uniform sampling will have O(n) time complexity as long as we don\\'t store the linked list as an array, since the expectation of a discrete uniform distribution over 1,...,L is n/2.\\n\\n```\\nclass Solution {\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head): head_(head){}\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        int n = 0;\\n        int ans = 0;\\n        ListNode* p = head_;\\n        while(p){\\n            if(rand()% ++n == 0) ans = p->val; //Note:  int v1 = rand() % 100;  // v1 in the range 0 to 99\\n            p = p->next;\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    ListNode* head_;\\n};\\n```\\nReference:\\n[1] https://www.cplusplus.com/reference/cstdlib/rand/\\n[2] https://leetcode.com/problems/linked-list-random-node/discuss/956871/Python-reservoir-sampling",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head): head_(head){}\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        int n = 0;\\n        int ans = 0;\\n        ListNode* p = head_;\\n        while(p){\\n            if(rand()% ++n == 0) ans = p->val; //Note:  int v1 = rand() % 100;  // v1 in the range 0 to 99\\n            p = p->next;\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    ListNode* head_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956941,
                "title": "c-storing-and-non-sstoring-solutions-compared-and-explained-100-time-15-space",
                "content": "First approach - iterating through the list only once and storing the values into a container (I opted for an array sized to the maximum size of the list we can get).\\n\\nCreation and population of the container is linear, then each random pick is constant time. Space always linear, of course\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *nodes[10000];\\n    int pos = 0;\\n    Solution(ListNode* head) {\\n        // initialising random generation\\n        srand(std::time(nullptr));\\n        // storing values in the array\\n        while (head) {\\n            nodes[pos++] = head;\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n\\t\\t// extracting a random element\\n        return nodes[rand() % pos]->val;\\n    }\\n};\\n```\\n\\nAlternative: we just store head, its `length` and at each random call we iterate `n` times, with `0 <= n < length`.\\n\\nSpace is always constant, each operation is linear (but read below!).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *head;\\n    int length = 0;\\n    Solution(ListNode* head) {\\n        // storing the original head\\n        this->head = head;\\n        // initialising random generation\\n        srand(std::time(nullptr));\\n        // updating length\\n        while (head) {\\n            length++;\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        // support variables\\n        ListNode *curr = this->head;\\n        int pos = rand() % length;\\n\\t\\t// iterating pos times\\n        while (pos--) {\\n            curr = curr->next;\\n        }\\n        return curr->val;\\n    }\\n};\\n```\\n\\nNow, because the tests are not really that great, you might \"hack\" your way into better performance adding one final line to the constructor: `length = min(length, 10);` - up to you ;)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode *nodes[10000];\\n    int pos = 0;\\n    Solution(ListNode* head) {\\n        // initialising random generation\\n        srand(std::time(nullptr));\\n        // storing values in the array\\n        while (head) {\\n            nodes[pos++] = head;\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n\\t\\t// extracting a random element\\n        return nodes[rand() % pos]->val;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *head;\\n    int length = 0;\\n    Solution(ListNode* head) {\\n        // storing the original head\\n        this->head = head;\\n        // initialising random generation\\n        srand(std::time(nullptr));\\n        // updating length\\n        while (head) {\\n            length++;\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        // support variables\\n        ListNode *curr = this->head;\\n        int pos = rand() % length;\\n\\t\\t// iterating pos times\\n        while (pos--) {\\n            curr = curr->next;\\n        }\\n        return curr->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514340,
                "title": "c-o-n-o-1-no-rand-on-length-or-equivalent",
                "content": "To remove random restriction on length with two-node approach.\\nEach time we split the list between ``start`` and ``end``  into two halves and do a rand()%2 to pick which half.\\nIf the list contains odd number of nodes, we do extra rand()%2 to decide if ``middle`` node goes to 1st or 2nd half.\\n\\nCase0: ``node1->null``\\nSimply return value of node1\\nCase1:``node1->node2->null``\\nSplit into two halves (``node1->node2`` or ``node2->null``) and rand()%2 to decide where to go.\\nSet new ``start`` and ``end`` node accordingly and loop it. Note: ``end`` is excluded.\\nCase2: ``node1->node2->node3->null``\\nSplit into two halves. Extra rand()%2 to decide if ``node2`` belongs to 1st or 2nd half.\\n``node1->node2`` or ``node1->node2->node3`` or ``node2->node3->null`` or ``node3->null``\\n\\nProbability Explaination:\\nFor even case, it\\'s clear that half of the nodes between ``start`` and ``end`` will be selected.\\nFor odd case, the ``middle`` node\\'s chance being selected\\nP(Belong1st & Select1st) + P(Belong2nd & Select2nd) = 2/4 = 50%\\n\\nPerformance Explaination:\\nS(n) = O(1)\\nT(n) = n+n/2+n/4+n/8+... < 2n = O(n)\\n\\n```\\nclass Solution {\\nprivate:\\n    ListNode* head;\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        this->head = head;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        ListNode *start = head, *end = nullptr, *fast = nullptr, *slow = nullptr;\\n        while(start->next != end) {\\n            bool even = true;\\n            fast = start;\\n            slow = start;\\n            while(fast != end) {\\n                fast = fast->next;\\n                if (fast == end) {\\n                    even = false;\\n                } else {\\n                    fast = fast->next;\\n                }\\n                if (even) { // For odd case, we do extra rand()%2 later, hence save a previous\\n                    slow = slow->next;\\n                }\\n            }\\n            if (!even && (rand()%2)) {\\n                slow = slow->next;\\n            }\\n            if (rand()%2) {\\n                start = slow;\\n            } else {\\n                end = slow;\\n            }\\n        }\\n        return start->val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    ListNode* head;\\npublic:\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    Solution(ListNode* head) {\\n        this->head = head;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    int getRandom() {\\n        ListNode *start = head, *end = nullptr, *fast = nullptr, *slow = nullptr;\\n        while(start->next != end) {\\n            bool even = true;\\n            fast = start;\\n            slow = start;\\n            while(fast != end) {\\n                fast = fast->next;\\n                if (fast == end) {\\n                    even = false;\\n                } else {\\n                    fast = fast->next;\\n                }\\n                if (even) { // For odd case, we do extra rand()%2 later, hence save a previous\\n                    slow = slow->next;\\n                }\\n            }\\n            if (!even && (rand()%2)) {\\n                slow = slow->next;\\n            }\\n            if (rand()%2) {\\n                start = slow;\\n            } else {\\n                end = slow;\\n            }\\n        }\\n        return start->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421186,
                "title": "java-solution-using-fast-and-slow-pointers-beat-100",
                "content": "I came up with a solution to randomly select a node in a long list. Just let the possibility of hitting each node equally. We can try to advance the slow pointer when it reaches the count. The code is self-explantory.\\n```\\nclass Solution {\\n\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    \\n    ListNode head;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    public int getRandom() {\\n        \\n        double rand = Math.random();\\n        if(rand == 0) rand = 1;\\n        double index = 0;\\n        int prev = 0;\\n        \\n        ListNode fast = head;\\n        ListNode slow = head;\\n        while(fast != null){\\n            fast = fast.next;\\n            index += rand;\\n            // increase by 1\\n            if((int)index > prev){\\n                prev = (int)index;\\n                slow = slow.next;\\n            }\\n        }\\n        return slow.val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    /** @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\\n    \\n    ListNode head;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    /** Returns a random node\\'s value. */\\n    public int getRandom() {\\n        \\n        double rand = Math.random();\\n        if(rand == 0) rand = 1;\\n        double index = 0;\\n        int prev = 0;\\n        \\n        ListNode fast = head;\\n        ListNode slow = head;\\n        while(fast != null){\\n            fast = fast.next;\\n            index += rand;\\n            // increase by 1\\n            if((int)index > prev){\\n                prev = (int)index;\\n                slow = slow.next;\\n            }\\n        }\\n        return slow.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328557,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        :type head: ListNode\\n        \"\"\"\\n        self.count = 1\\n        self.head = head\\n        self.val = head.val\\n        \\n    def getRandom(self):\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        :rtype: int\\n        \"\"\"\\n        count,head,val = self.count,self.head,self.val\\n        while head.next:\\n            head = head.next\\n            count += 1\\n            random_num = random.uniform(0,1)\\n            if random_num < float(1) / count:\\n                val = head.val\\n        \\n        return val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        :type head: ListNode\\n        \"\"\"\\n        self.count = 1\\n        self.head = head\\n        self.val = head.val\\n        \\n    def getRandom(self):\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        :rtype: int\\n        \"\"\"\\n        count,head,val = self.count,self.head,self.val\\n        while head.next:\\n            head = head.next\\n            count += 1\\n            random_num = random.uniform(0,1)\\n            if random_num < float(1) / count:\\n                val = head.val\\n        \\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326699,
                "title": "simple-python-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        :type head: ListNode\\n        \"\"\"\\n        self.start = head\\n        self.cur = head\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        :rtype: int\\n        \"\"\"\\n        step = random.randint(0,4)\\n        for i in range(step):\\n            if self.cur and self.cur.next:\\n                self.cur = self.cur.next\\n            else:\\n                self.cur = self.start\\n        return self.cur.val\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n\\n    def __init__(self, head):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        :type head: ListNode\\n        \"\"\"\\n        self.start = head\\n        self.cur = head\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        :rtype: int\\n        \"\"\"\\n        step = random.randint(0,4)\\n        for i in range(step):\\n            if self.cur and self.cur.next:\\n                self.cur = self.cur.next\\n            else:\\n                self.cur = self.start\\n        return self.cur.val\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281228,
                "title": "python3-golang-2-easy-and-intuitive-solutions",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Version 1\\n1. In `__init__` / constructor we initialize a list and append to it all the values from the single-linked list\\n2. In `getRandom` return a random integer from the list \\n\\n# Complexity\\n- Time complexity:\\n`__init__` / constructor O(n)\\n`getRandom` O(1)\\n\\n- Space complexity: O(n)\\n\\n\\n\\n#### Don\\'t forget to Vote! :)\\n\\n# Code \\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.l = []\\n        \\n        curr = head\\n        while curr:\\n            self.l.append(curr.val)\\n            curr = curr.next\\n        \\n    def getRandom(self) -> int:\\n        return random.choice(self.l)\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```\\n```golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\ntype Solution struct {\\n    Values []int\\n}\\n\\n\\nfunc Constructor(head *ListNode) Solution {\\n    values := []int{}\\n    curr := head\\n    for curr != nil {\\n        values = append(values, curr.Val)\\n        curr = curr.Next\\n    }\\n\\n    return Solution{Values: values}\\n}\\n\\n\\nfunc (this *Solution) GetRandom() int {\\n    randInt := rand.Intn(len(this.Values))\\n    return this.Values[randInt]\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * obj := Constructor(head);\\n * param_1 := obj.GetRandom();\\n */\\n```\\n\\n<!-- Describe your approach to solving the problem. -->\\n## Version 2\\n1. In `__init__` / constructor we only set the head field\\n2. In `getRandom` iterate over the single-linked list, generate a random integer between 1 and counter that starts with 0, and if it is equal with 1 we set the node value. at the end we return the stored value.  \\n\\n# Complexity\\n- Time complexity:\\n`__init__` / constructor O(1)\\n`getRandom` O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code \\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.h = head\\n        \\n    def getRandom(self) -> int:\\n        \\n        curr = self.h\\n        count = 0\\n        res = 0\\n\\n        while curr:\\n            count += 1\\n            if randint(1, count) == 1:\\n                res = curr.val\\n            curr = curr.next\\n        \\n        return res\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```\\n```golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\ntype Solution struct {\\n    Head *ListNode\\n}\\n\\n\\nfunc Constructor(head *ListNode) Solution {\\n    return Solution{Head: head}\\n}\\n\\n\\nfunc (this *Solution) GetRandom() int {\\n    \\n    curr := this.Head\\n    count := 0\\n    result := 0\\n\\n    for curr != nil {\\n    \\n        count++    \\n        if (rand.Intn(count) + 1) == 1 {\\n            result = curr.Val\\n        }\\n        \\n        curr = curr.Next\\n    }\\n    return result\\n}\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * obj := Constructor(head);\\n * param_1 := obj.GetRandom();\\n */\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Go"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.l = []\\n        \\n        curr = head\\n        while curr:\\n            self.l.append(curr.val)\\n            curr = curr.next\\n        \\n    def getRandom(self) -> int:\\n        return random.choice(self.l)\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```\n```golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\ntype Solution struct {\\n    Values []int\\n}\\n\\n\\nfunc Constructor(head *ListNode) Solution {\\n    values := []int{}\\n    curr := head\\n    for curr != nil {\\n        values = append(values, curr.Val)\\n        curr = curr.Next\\n    }\\n\\n    return Solution{Values: values}\\n}\\n\\n\\nfunc (this *Solution) GetRandom() int {\\n    randInt := rand.Intn(len(this.Values))\\n    return this.Values[randInt]\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * obj := Constructor(head);\\n * param_1 := obj.GetRandom();\\n */\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.h = head\\n        \\n    def getRandom(self) -> int:\\n        \\n        curr = self.h\\n        count = 0\\n        res = 0\\n\\n        while curr:\\n            count += 1\\n            if randint(1, count) == 1:\\n                res = curr.val\\n            curr = curr.next\\n        \\n        return res\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```\n```golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\ntype Solution struct {\\n    Head *ListNode\\n}\\n\\n\\nfunc Constructor(head *ListNode) Solution {\\n    return Solution{Head: head}\\n}\\n\\n\\nfunc (this *Solution) GetRandom() int {\\n    \\n    curr := this.Head\\n    count := 0\\n    result := 0\\n\\n    for curr != nil {\\n    \\n        count++    \\n        if (rand.Intn(count) + 1) == 1 {\\n            result = curr.Val\\n        }\\n        \\n        curr = curr.Next\\n    }\\n    return result\\n}\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * obj := Constructor(head);\\n * param_1 := obj.GetRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281182,
                "title": "easy-and-unoptimized-approach-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    ListNode head;\\n    List<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode temp = head;\\n        while(temp != null){\\n            list.add(temp.val);\\n            temp = temp.next;\\n        }\\n        Random generator = new Random();\\n        int num = generator.nextInt(list.size());\\n        return list.get(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    ListNode head;\\n    List<Integer> list = new ArrayList<>();\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode temp = head;\\n        while(temp != null){\\n            list.add(temp.val);\\n            temp = temp.next;\\n        }\\n        Random generator = new Random();\\n        int num = generator.nextInt(list.size());\\n        return list.get(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280898,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\nprivate:\\n    vector<int> nodes;\\npublic:\\n    Solution(ListNode* head) {\\n        while(head) {\\n            nodes.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int id = rand() % nodes.size();\\n        return nodes[id];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\nprivate:\\n    vector<int> nodes;\\npublic:\\n    Solution(ListNode* head) {\\n        while(head) {\\n            nodes.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int id = rand() % nodes.size();\\n        return nodes[id];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280708,
                "title": "python3-97-fast-2-methods-detailed-explanation",
                "content": "# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n- create array of nodes.\\n- use random function to get random element from array.\\n- return element.\\n\\n![image.png](https://assets.leetcode.com/users/images/299277d7-1b02-44ad-96b1-f0e2d01761eb_1678462811.286384.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head = head\\n\\n    def getRandom(self) -> int:\\n        hmap = []\\n        head = self.head\\n        while head:\\n            hmap.append(head)\\n            head = head.next\\n        return random.choice(hmap).val\\n```\\n---\\n# Approach 2\\n- initialise result as first node.\\n- maintain n for random value, now start n from 2.\\n- now traverse from head.next, and get random value from 0 - n-1\\n- if random value equals to 0 then update the result to current node.\\n- every time increment further towards end of list.\\n- when list ends return found result.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n```\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head = head\\n\\n    def getRandom(self) -> int:\\n        result = self.head.val\\n        n = 2\\n        current = self.head.next\\n        while current:\\n            if random.randint(0,n-1) == 0:\\n                result = current.val\\n            current = current.next\\n            n += 1\\n        return result        \\n```\\n # Please like and comment below :-)",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Math",
                    "Reservoir Sampling",
                    "Randomized"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head = head\\n\\n    def getRandom(self) -> int:\\n        hmap = []\\n        head = self.head\\n        while head:\\n            hmap.append(head)\\n            head = head.next\\n        return random.choice(hmap).val\\n```\n```\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head = head\\n\\n    def getRandom(self) -> int:\\n        result = self.head.val\\n        n = 2\\n        current = self.head.next\\n        while current:\\n            if random.randint(0,n-1) == 0:\\n                result = current.val\\n            current = current.next\\n            n += 1\\n        return result        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280332,
                "title": "just-use-random-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head=head\\n\\n    def getRandom(self) -> int:\\n        count,output=0,0\\n        current=self.head\\n        while current:\\n            count+=1\\n            if random.randint(1,count)==1:  \\n                output=current.val\\n            current=current.next\\n        return output\\n#please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head=head\\n\\n    def getRandom(self) -> int:\\n        count,output=0,0\\n        current=self.head\\n        while current:\\n            count+=1\\n            if random.randint(1,count)==1:  \\n                output=current.val\\n            current=current.next\\n        return output\\n#please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280156,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nhttps://leetcode.com/problems/linked-list-random-node/submissions/912672477/\\n\\n- Space complexity:\\nhttps://leetcode.com/problems/linked-list-random-node/submissions/912672477/\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>list;\\n    Solution(ListNode* head)\\n     {\\n        ListNode * tmp = head;\\n        while(tmp)\\n        {\\n            list.push_back(tmp->val);\\n            tmp = tmp->next;\\n        }\\n    } \\n    int getRandom() \\n    {\\n        int n = list.size();\\n        int ind = rand()%n;\\n        return list[ind];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>list;\\n    Solution(ListNode* head)\\n     {\\n        ListNode * tmp = head;\\n        while(tmp)\\n        {\\n            list.push_back(tmp->val);\\n            tmp = tmp->next;\\n        }\\n    } \\n    int getRandom() \\n    {\\n        int n = list.size();\\n        int ind = rand()%n;\\n        return list[ind];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279623,
                "title": "java-using-random-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode temp;\\n    Random random;\\n    public Solution(ListNode head) {\\n        temp=head;\\n        random=new Random();\\n    }\\n    \\n    public int getRandom() {\\n        int count=0;\\n        int res=0;\\n        ListNode cur=temp;\\n        while(cur!=null)\\n        {\\n            count++;\\n            if(random.nextInt(count)==0){\\n                res=cur.val;\\n            }\\n            cur=cur.next;\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode temp;\\n    Random random;\\n    public Solution(ListNode head) {\\n        temp=head;\\n        random=new Random();\\n    }\\n    \\n    public int getRandom() {\\n        int count=0;\\n        int res=0;\\n        ListNode cur=temp;\\n        while(cur!=null)\\n        {\\n            count++;\\n            if(random.nextInt(count)==0){\\n                res=cur.val;\\n            }\\n            cur=cur.next;\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279126,
                "title": "3-solutions-beginner-friendly-c-easy",
                "content": "# **Solution 1 - Basic [O(N) space, O(N) time]**\\n``` \\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(ListNode* head) {\\n        while(head)\\n        {\\n            v.push_back(head -> val);\\n            head = head -> next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int n = v.size();\\n        int r = rand()%n;\\n        return v[r];\\n    }\\n};\\n```\\n# **Solution 2 - O(1) space, O(N) time**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *h = NULL;\\n    int len = 0;\\n    \\n    Solution(ListNode* head) {\\n        h = head;\\n        ListNode *temp = head;\\n        while(temp)\\n        {\\n            len++;\\n            temp = temp -> next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int ran = rand() % len;\\n        ListNode *temp = h;\\n        for(int i = 0 ; i < ran; i++)\\n        {\\n            temp = temp -> next;\\n        }\\n        return temp -> val;\\n    }\\n};\\n```\\n# **Solution 3 - Reservoir Sampling [O(1) space ~O(N) time]**\\n```\\nclass Solution{\\npublic:\\n    ListNode *head = NULL;\\n\\n    Solution(ListNode *h){\\n        head = h;\\n    }\\n    \\n    int getRandom(){\\n        ListNode *curr = head;\\n        ListNode *res;\\n        int n = 1;\\n        while (curr)\\n        {\\n            if (rand() % n == 0)\\n                res = curr;\\n            curr = curr->next;\\n            n++;\\n        }\\n        return res->val;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(ListNode* head) {\\n        while(head)\\n        {\\n            v.push_back(head -> val);\\n            head = head -> next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int n = v.size();\\n        int r = rand()%n;\\n        return v[r];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *h = NULL;\\n    int len = 0;\\n    \\n    Solution(ListNode* head) {\\n        h = head;\\n        ListNode *temp = head;\\n        while(temp)\\n        {\\n            len++;\\n            temp = temp -> next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int ran = rand() % len;\\n        ListNode *temp = h;\\n        for(int i = 0 ; i < ran; i++)\\n        {\\n            temp = temp -> next;\\n        }\\n        return temp -> val;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n    ListNode *head = NULL;\\n\\n    Solution(ListNode *h){\\n        head = h;\\n    }\\n    \\n    int getRandom(){\\n        ListNode *curr = head;\\n        ListNode *res;\\n        int n = 1;\\n        while (curr)\\n        {\\n            if (rand() % n == 0)\\n                res = curr;\\n            curr = curr->next;\\n            n++;\\n        }\\n        return res->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278715,
                "title": "efficient-algorithm-to-select-a-random-node-from-linked-list-with-equal-probability",
                "content": "# Intuition\\nThe problem statement asks us to return a random node\\'s value from a singly linked list, such that each node has an equal probability of being chosen.\\n\\nOne way to approach this problem is to iterate over the linked list and store all the nodes in an array or vector, and then randomly select one of the nodes from the array/vector. However, this solution has a space complexity of O(n), where n is the length of the linked list, which is not ideal.\\n\\nA more efficient solution is to use reservoir sampling, which is a widely-used algorithm for random sampling without replacement. The basic idea behind reservoir sampling is to maintain a reservoir of size k, where k is the number of samples we want to select, and to randomly replace elements in the reservoir with a decreasing probability as we iterate through the input.\\n\\n# Approach\\nIn this problem, we want to select only one sample, so we can set k = 1. The algorithm works as follows:\\n\\n1. Initialize a counter variable count to 1 and a variable res to the value of the first node in the list.\\n2. Iterate over the linked list. At each iteration, generate a random number r between 0 and count (inclusive). If r equals 0, set res to the value of the current node.\\n3. Return the value of res.\\n\\nThe key insight behind this algorithm is that each node has a probability of 1/n of being selected, where n is the number of nodes in the linked list.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* head;\\npublic:\\n    Solution(ListNode* h) {\\n        head = h;\\n        srand(time(NULL));\\n    }\\n    \\n    int getRandom() {\\n        int count = 0, res = 0;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            if (rand() % (++count) == 0)\\n                res = curr->val;\\n            curr = curr->next;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Reservoir Sampling"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* head;\\npublic:\\n    Solution(ListNode* h) {\\n        head = h;\\n        srand(time(NULL));\\n    }\\n    \\n    int getRandom() {\\n        int count = 0, res = 0;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            if (rand() % (++count) == 0)\\n                res = curr->val;\\n            curr = curr->next;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278705,
                "title": "easy-c-code-using-rand-function-day-38",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\nprivate:\\n    ListNode *head;\\n    int size=0;\\n\\n    int len(ListNode* head){\\n        ListNode* mover=head;\\n        int n=0;\\n        while(mover){\\n            n++;\\n            mover=mover->next;\\n        }\\n        return n;\\n    }\\npublic:\\n    \\n    Solution(ListNode* head) {\\n        this->head=head;\\n        size=len(head);\\n    }\\n    \\n    int getRandom() {\\n        int move=rand()%size;\\n        ListNode* mover=head;\\n        while(move){\\n            mover=mover->next;\\n            move--;\\n        }\\n        return mover->val;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math",
                    "Randomized"
                ],
                "code": "```\\n\\nclass Solution {\\nprivate:\\n    ListNode *head;\\n    int size=0;\\n\\n    int len(ListNode* head){\\n        ListNode* mover=head;\\n        int n=0;\\n        while(mover){\\n            n++;\\n            mover=mover->next;\\n        }\\n        return n;\\n    }\\npublic:\\n    \\n    Solution(ListNode* head) {\\n        this->head=head;\\n        size=len(head);\\n    }\\n    \\n    int getRandom() {\\n        int move=rand()%size;\\n        ListNode* mover=head;\\n        while(move){\\n            mover=mover->next;\\n            move--;\\n        }\\n        return mover->val;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278518,
                "title": "java-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ArrayList<Integer>list=new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        double random=Math.random()*list.size();\\n        return list.get((int)random);\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```\\n```\\nGIVE AN UPVOTE,IF YOU LIKE THE SOLUTION\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ArrayList<Integer>list=new ArrayList<>();\\n    public Solution(ListNode head) {\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        double random=Math.random()*list.size();\\n        return list.get((int)random);\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```\n```\\nGIVE AN UPVOTE,IF YOU LIKE THE SOLUTION\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278194,
                "title": "python3-using-random-randrange-70-ms-faster-than-83-83",
                "content": "Runtime: **70 ms, faster than 83.83%** of Python3 online submissions for Linked List Random Node.  \\nMemory Usage: 17.6 MB, less than 6.13% of Python3 online submissions for Linked List Random Node.  \\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.length = 0\\n        self.head = head\\n        node = head\\n        while node:\\n            self.length += 1\\n            node = node.next\\n\\n    def getRandom(self) -> int:\\n        p = randrange(self.length)\\n        node = self.head\\n        for _ in range(p):\\n            node = node.next\\n        return node.val\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```\\n\\n**A large test case**  \\nhttps://leetcode.com/submissions/detail/912382970/testcase/",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.length = 0\\n        self.head = head\\n        node = head\\n        while node:\\n            self.length += 1\\n            node = node.next\\n\\n    def getRandom(self) -> int:\\n        p = randrange(self.length)\\n        node = self.head\\n        for _ in range(p):\\n            node = node.next\\n        return node.val\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(head)\\n# param_1 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253146,
                "title": "382-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis is an implementation of an algorithm to return a random node value from a linked list with each node having an equal probability of being chosen.\\n\\nThe class Solution is defined with an __init__ method that takes a singly linked list\\'s head as input and initializes the object with it. The getRandom method of this class is responsible for choosing a node randomly from the list and returning its value.\\n\\nThe algorithm starts by initializing the reservoir with the value of the head node of the linked list. It also initializes the counter to 2 since we\\'ve already processed the head node.\\n\\nThe loop starts from the second node in the linked list, and for each node, it calculates the probability of choosing that node using the formula 1/i, where i is the counter. If the randomly generated probability is less than this value, the reservoir value is replaced with the current node value.\\n\\nThe counter is then incremented by 1, and the loop continues with the next node in the linked list.\\n\\nFinally, the algorithm returns the final value of the reservoir, which will be the value of the node chosen randomly with equal probability from the linked list.\\n\\n# Complexity\\n- Time complexity:\\n70.70%\\n\\n- Space complexity:\\n50.73%\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head = head\\n        \\n    def getRandom(self) -> int:\\n        # Initialize the reservoir with the value of the head node\\n        reservoir = self.head.val\\n        \\n        # Initialize the counter to 2 since we\\'ve already processed the head node\\n        i = 2\\n        \\n        # Loop through the linked list starting from the second node\\n        next = self.head.next\\n        while next:\\n            # With probability 1/i, replace the reservoir value with the value of the current node\\n            if random.random() < 1/i:\\n                reservoir = next.val\\n                \\n            # Increment the counter and move on to the next node\\n            i += 1\\n            next = next.next\\n            \\n        # Return the final reservoir value\\n        return reservoir\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Math",
                    "Reservoir Sampling"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head = head\\n        \\n    def getRandom(self) -> int:\\n        # Initialize the reservoir with the value of the head node\\n        reservoir = self.head.val\\n        \\n        # Initialize the counter to 2 since we\\'ve already processed the head node\\n        i = 2\\n        \\n        # Loop through the linked list starting from the second node\\n        next = self.head.next\\n        while next:\\n            # With probability 1/i, replace the reservoir value with the value of the current node\\n            if random.random() < 1/i:\\n                reservoir = next.val\\n                \\n            # Increment the counter and move on to the next node\\n            i += 1\\n            next = next.next\\n            \\n        # Return the final reservoir value\\n        return reservoir\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672763,
                "title": "simple-solution-no-extra-space-circular-linkedlist-and-random-numbers",
                "content": "```\\n\\nclass Solution {\\n    private ListNode head = null;\\n    private int numElements = 1;\\n\\n    public Solution(ListNode head) {\\n        makeCircularList(head);\\n    }\\n    \\n    private void makeCircularList(ListNode head) {\\n        ListNode tail = this.head = head;\\n        while(tail.next != null) {\\n            tail = tail.next;\\n            numElements++;\\n        }\\n        tail.next = head;\\n    }\\n    \\n    public int getRandom() {\\n        int rn = ThreadLocalRandom.current().nextInt(1, numElements + 1);\\n        while(rn-- > 0) this.head = this.head.next;\\n        return this.head.val;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    private ListNode head = null;\\n    private int numElements = 1;\\n\\n    public Solution(ListNode head) {\\n        makeCircularList(head);\\n    }\\n    \\n    private void makeCircularList(ListNode head) {\\n        ListNode tail = this.head = head;\\n        while(tail.next != null) {\\n            tail = tail.next;\\n            numElements++;\\n        }\\n        tail.next = head;\\n    }\\n    \\n    public int getRandom() {\\n        int rn = ThreadLocalRandom.current().nextInt(1, numElements + 1);\\n        while(rn-- > 0) this.head = this.head.next;\\n        return this.head.val;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233946,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> v;\\n    \\n    Solution(ListNode* head) {\\n        while(head != NULL)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        if(v.size() == 1) return v[0];\\n        int index = rand() % (v.size());\\n        return v[index];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> v;\\n    \\n    Solution(ListNode* head) {\\n        while(head != NULL)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        if(v.size() == 1) return v[0];\\n        int index = rand() % (v.size());\\n        return v[index];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070572,
                "title": "c-very-very-very-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector<int>v;\\n    Solution(ListNode* head) {\\n        \\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        \\n        int i=rand()%v.size();\\n        return v[i];\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>v;\\n    Solution(ListNode* head) {\\n        \\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head=head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1675329,
                "title": "as-instructed-soln-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    Solution(ListNode* head) {\\n        ListNode* temp = head;\\n        while(temp != NULL)\\n        {\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    Solution(ListNode* head) {\\n        ListNode* temp = head;\\n        while(temp != NULL)\\n        {\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673720,
                "title": "circular-linked-list",
                "content": "This satisfies both the follow up questions:\\n  * Works with list of unknown size\\n  * Takes up constant extra space\\n\\nThe idea is to output elements in circular fashion. \\nFor example: Input: 1->2->3\\nThen output: 1,2,3,1,2,3,1,2,3 ...\\n\\nTechnically, the values are not random but the requirement that each element having equal probability of ocurring is satisfied.\\n\\nOne way to generate random values is to traverse the linked list for a random number of times. \\n\\nTime Complexity:\\nConstructor: O(1)\\ngetRandom: O(k) ~ O(1): where k is the maximum number of times you can iterate the list. In this case 20. \\n\\nSpace Complexity:\\nO(1) for all methods. \\n\\n```c++\\nclass Solution {\\npublic:\\n    ListNode *tail,* const head; // Marking head as constant * to avoid changing it by programming error. \\n    \\n\\tSolution(ListNode* node):tail(node),head(node){}\\n    \\n    int getRandom() {\\n        int times = rand()%20; // Apparantly, for values<10, it does not work. If you know why, please comment. \\n        while(times--) tail = tail->next?tail->next:head;\\n        return tail->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    ListNode *tail,* const head; // Marking head as constant * to avoid changing it by programming error. \\n    \\n\\tSolution(ListNode* node):tail(node),head(node){}\\n    \\n    int getRandom() {\\n        int times = rand()%20; // Apparantly, for values<10, it does not work. If you know why, please comment. \\n        while(times--) tail = tail->next?tail->next:head;\\n        return tail->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673286,
                "title": "linked-list-random-node-java-easy-logic-o-n",
                "content": "class Solution {\\n\\n    ArrayList<Integer> res = new ArrayList<>();\\n\\n    public Solution(ListNode head) {\\n        while (head != null) { \\n            res.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        return res.get((int) (Math.random() * res.size()));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\n    ArrayList<Integer> res = new ArrayList<>();\\n\\n    public Solution(ListNode head) {\\n        while (head != null) { \\n            res.add(head.val);\\n            head = head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1672375,
                "title": "linked-list-random-node-c-rand-function",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> nums;\\n    int size=0;\\n    \\n    Solution(ListNode* head) {\\n        while(head != NULL){\\n            size++;\\n            nums.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n\\n    \\n    int getRandom() {\\n        \\n        return nums[rand()%size];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> nums;\\n    int size=0;\\n    \\n    Solution(ListNode* head) {\\n        while(head != NULL){\\n            size++;\\n            nums.push_back(head->val);\\n            head = head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1672372,
                "title": "linked-list-random-node-java-solutions-day-07",
                "content": "\\nclass Solution {\\n    List<Integer> l = new ArrayList<>();\\n    Random random = new Random();\\n    public Solution(ListNode head) {\\n        while (head != null) {\\n            l.add(head.val);\\n            head = head.next;\\n        }\\n    }\\n    public int getRandom() {\\n        return l.get(random.nextInt(l.size()));\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    List<Integer> l = new ArrayList<>();\\n    Random random = new Random();\\n    public Solution(ListNode head) {\\n        while (head != null) {\\n            l.add(head.val);\\n            head = head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1672371,
                "title": "intuitive-java-solution-no-extra-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    int length;\\n    ListNode hd;\\n    \\n    public Solution(ListNode head) {\\n        length = 0;\\n        hd = head;\\n        ListNode node = head;\\n        while (node != null) {\\n            node = node.next;\\n            length += 1;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int stopAt = (int) Math.floor(Math.random()*length);\\n        int count = 0;\\n        ListNode node = hd;\\n        while (count != stopAt) {\\n            node = node.next;\\n            count += 1;\\n        }\\n        return node.val;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    int length;\\n    ListNode hd;\\n    \\n    public Solution(ListNode head) {\\n        length = 0;\\n        hd = head;\\n        ListNode node = head;\\n        while (node != null) {\\n            node = node.next;\\n            length += 1;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int stopAt = (int) Math.floor(Math.random()*length);\\n        int count = 0;\\n        ListNode node = hd;\\n        while (count != stopAt) {\\n            node = node.next;\\n            count += 1;\\n        }\\n        return node.val;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(head);\\n * int param_1 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672317,
                "title": "java-code-using-reservoir-sampling",
                "content": "```\\nclass Solution {\\n    ListNode head = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode curr = head;\\n        int i = 1;\\n        int res = 0;\\n        while(curr != null){\\n            if(Math.random() < 1.0 / i){\\n                //take this value\\n                res = curr.val;\\n            }\\n            i++;\\n            curr = curr.next;\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    ListNode head = null;\\n    public Solution(ListNode head) {\\n        this.head = head;\\n    }\\n    \\n    public int getRandom() {\\n        ListNode curr = head;\\n        int i = 1;\\n        int res = 0;\\n        while(curr != null){\\n            if(Math.random() < 1.0 / i){\\n                //take this value\\n                res = curr.val;\\n            }\\n            i++;\\n            curr = curr.next;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671982,
                "title": "simple-c-solution-using-vector-o-n",
                "content": "This code is self explanatory. Do comment below if you have any query.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(ListNode* head) {\\n        while(head){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int n = rand()%v.size();\\n        return v[n];\\n    }\\n};\\n```\\n\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(ListNode* head) {\\n        while(head){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int n = rand()%v.size();\\n        return v[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589779,
                "title": "javascript-easy-explanation-solution-using-arrays-o-n",
                "content": "```\\n/**\\n * @param {ListNode} head\\n */\\nvar Solution = function(head) {\\n        this.listArray = []; //public variable\\n        let curr = head;  //private variable\\n        \\n        while(curr !== null) {\\n            this.listArray.push(curr)\\n            curr = curr.next;\\n        }\\n        this.length = this.listArray.length; //public variable\\n};\\n\\n/**\\n * @return {number}\\n */\\nSolution.prototype.getRandom = function() {\\n    return this.listArray[Math.floor(Math.random() * this.length)].val\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(head)\\n * var param_1 = obj.getRandom()\\n */\\n```\\n\\nIn the **Constructor Function**, We can create **public variables** with the use of the **\\'this\\' keyword** and private variables using var/ let/ const respectively.\\n\\n#  **Explaination**:\\n\\nSo here we are doing something really simple,\\n\\nIn the constructor function we just add all the items in the Linked List to a public Array called **\\'listArray\\'.**\\nNow, within the getRandom() function, we just make use of this \\'listArray\\' array and use the **Math library** provided out of the box by javascript.\\n\\nHere, **Math.random() generates random numbers between 0 and 1**.\\n\\nWe can restrict this to generating the random numbers between 0 and 3 (say for example the length of the array/List is 4, the index in the array will be from 0 to 3 for 4 List elements stored inside it).\\nWe just need to **multiply the length of the array(list) to Math.random() to generate random numbers between 0 and 3.**\\n\\nBut this multiplication between Math.random() and length of the list will **cause decimal(floating point) numbers**, for which we use **Math.floor()** in the end to remove this decimal and **round off the number to the lower whole number.**",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * @param {ListNode} head\\n */\\nvar Solution = function(head) {\\n        this.listArray = []; //public variable\\n        let curr = head;  //private variable\\n        \\n        while(curr !== null) {\\n            this.listArray.push(curr)\\n            curr = curr.next;\\n        }\\n        this.length = this.listArray.length; //public variable\\n};\\n\\n/**\\n * @return {number}\\n */\\nSolution.prototype.getRandom = function() {\\n    return this.listArray[Math.floor(Math.random() * this.length)].val\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(head)\\n * var param_1 = obj.getRandom()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995196,
                "title": "largest-rectangle-in-histogram-last-day-of-2020-problem-solving",
                "content": "This problem is nothing but finding the boundary on both the left and right sides to which the current block can expand. When can the current block expand? When the values on the right and the left are greater than the current value.\\nSo, we basically need to find the Next smallest element on both the sides as that gives us the boundaries.\\n```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        \\n        if not heights:\\n            return 0\\n        \\n        N = len(heights)\\n        area=0\\n        nsr=[]\\n        nsl=[]\\n        i = N - 1\\n        stack=[]\\n        \\n        while i >= 0 :\\n            \\n            while stack and heights[stack[-1]] >= heights[i]:\\n                stack.pop()\\n            if not stack:\\n                stack.append(i)\\n                nsr.append(N)\\n            else:\\n                nsr.append(stack[-1])\\n                stack.append(i)\\n            i-=1\\n        \\n        nsr = nsr[::-1]\\n        \\n        stack=[]\\n        i = 0\\n        while i < N :\\n            \\n            while stack and heights[stack[-1]] > heights[i]:\\n                stack.pop()\\n            if not stack:\\n                stack.append(i)\\n                nsl.append(-1)\\n            else:\\n                nsl.append(stack[-1])\\n                stack.append(i)\\n            i+=1\\n        for i in range(N):\\n            area = max(area,(nsr[i]+(-nsl[i]-1))*heights[i])\\n        return area\\n```\\nThe time complexity is O(n).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        \\n        if not heights:\\n            return 0\\n        \\n        N = len(heights)\\n        area=0\\n        nsr=[]\\n        nsl=[]\\n        i = N - 1\\n        stack=[]\\n        \\n        while i >= 0 :\\n            \\n            while stack and heights[stack[-1]] >= heights[i]:\\n                stack.pop()\\n            if not stack:\\n                stack.append(i)\\n                nsr.append(N)\\n            else:\\n                nsr.append(stack[-1])\\n                stack.append(i)\\n            i-=1\\n        \\n        nsr = nsr[::-1]\\n        \\n        stack=[]\\n        i = 0\\n        while i < N :\\n            \\n            while stack and heights[stack[-1]] > heights[i]:\\n                stack.pop()\\n            if not stack:\\n                stack.append(i)\\n                nsl.append(-1)\\n            else:\\n                nsl.append(stack[-1])\\n                stack.append(i)\\n            i+=1\\n        for i in range(N):\\n            area = max(area,(nsr[i]+(-nsl[i]-1))*heights[i])\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993912,
                "title": "game-of-life-python-in-place-update-with-explanation",
                "content": "In-place trick: \\nSince the possible values only take one bit (`0` or `1`), we can use the lowest bit to store the original value (`board[i][j] & 1`) and the second lowest bit to store the new updated value (`board[i][j] |= 2`). After calculating the updates for all values, move the bits (` board[i][j] >>= 1`) so that the updated values now become the orginal value.\\n\\n```python\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n = len(board), len(board[0])\\n        for i, j in product(range(m), range(n)):\\n            cnt = 0\\n            for di, dj in product(range(-1, 2), repeat=2):\\n                if di != 0 or dj != 0:\\n                    ii, jj = i + di, j + dj\\n                    if 0 <= ii < m and 0 <= jj < n:\\n                        cnt += board[ii][jj] & 1\\n            if cnt == 3 or (cnt == 2 and board[i][j] & 1): # Game-of-Life rule\\n                board[i][j] |= 2\\n        # print(board)\\n        for i, j in product(range(m), range(n)):\\n            board[i][j] >>= 1\\n```\\n\\nRemark: \\nMore generally, if the values are within range [0, R-1], we could store the updated values in the second lowest digit in base-R numbers. That is, `val = updated_val * R + original_val`. `val // R` gives the updated value and `val % R` gives the original value. You can compress even more values into a single number by utilizing higer digits in base-R.\\n\\n---\\nIf you find this helpful, please consider **upvote**. Thank you! \\uD83E\\uDD17",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n = len(board), len(board[0])\\n        for i, j in product(range(m), range(n)):\\n            cnt = 0\\n            for di, dj in product(range(-1, 2), repeat=2):\\n                if di != 0 or dj != 0:\\n                    ii, jj = i + di, j + dj\\n                    if 0 <= ii < m and 0 <= jj < n:\\n                        cnt += board[ii][jj] & 1\\n            if cnt == 3 or (cnt == 2 and board[i][j] & 1): # Game-of-Life rule\\n                board[i][j] |= 2\\n        # print(board)\\n        for i, j in product(range(m), range(n)):\\n            board[i][j] >>= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992304,
                "title": "pseudo-palindromic-paths-in-a-binary-tree-java-recursive-preorder-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int ans = 0;\\n    int[] digits;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        digits = new int[10];\\n        preorder(root);\\n        \\n        return ans;\\n    }\\n    \\n    public void preorder(TreeNode root){\\n        if(root == null)\\n            return;\\n        \\n        digits[root.val]++;\\n        \\n        if(root.left == null && root.right == null){\\n            if(isPalindrome()) ans++;\\n        }else{\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n        digits[root.val]--;\\n    }\\n    \\n    public boolean isPalindrome(){\\n        int oddc = 0;\\n        \\n        for(int i=0; i<10; i++){\\n            if(digits[i] % 2 != 0)\\n                oddc++;\\n        }\\n        \\n        return oddc > 1 ? false : true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int ans = 0;\\n    int[] digits;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        digits = new int[10];\\n        preorder(root);\\n        \\n        return ans;\\n    }\\n    \\n    public void preorder(TreeNode root){\\n        if(root == null)\\n            return;\\n        \\n        digits[root.val]++;\\n        \\n        if(root.left == null && root.right == null){\\n            if(isPalindrome()) ans++;\\n        }else{\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n        digits[root.val]--;\\n    }\\n    \\n    public boolean isPalindrome(){\\n        int oddc = 0;\\n        \\n        for(int i=0; i<10; i++){\\n            if(digits[i] % 2 != 0)\\n                oddc++;\\n        }\\n        \\n        return oddc > 1 ? false : true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990340,
                "title": "reach-a-number-python-time-sqrt-n",
                "content": "```\\nstep    all numbers reached         Farthest\\n0       0                           0\\n1       -1 1                        1\\n2       -3 -1 1 3                   3 (1+2)\\n3       -6 -4 -2 0 2 4 6            6 (1+2+3)\\n4       -10 -8 -6 -2 0 2 4 6 10     10 (1+2+3+4)\\n5       -15 -13 -11 -9 ...... 15    15 (1+2+3+4+5)\\n```\\n```\\nclass Solution:\\n    def reachNumber(self, target: int) -> int:\\n        if target == 0:\\n            return 0\\n        if target < 0:\\n            target = -target\\n        if target == 1:\\n            return 1\\n        step = 1\\n        farthest = 1\\n        while farthest < target or farthest%2 != target%2:\\n            step += 1\\n            farthest += step\\n        return step\\n```",
                "solutionTags": [],
                "code": "```\\nstep    all numbers reached         Farthest\\n0       0                           0\\n1       -1 1                        1\\n2       -3 -1 1 3                   3 (1+2)\\n3       -6 -4 -2 0 2 4 6            6 (1+2+3)\\n4       -10 -8 -6 -2 0 2 4 6 10     10 (1+2+3+4)\\n5       -15 -13 -11 -9 ...... 15    15 (1+2+3+4+5)\\n```\n```\\nclass Solution:\\n    def reachNumber(self, target: int) -> int:\\n        if target == 0:\\n            return 0\\n        if target < 0:\\n            target = -target\\n        if target == 1:\\n            return 1\\n        step = 1\\n        farthest = 1\\n        while farthest < target or farthest%2 != target%2:\\n            step += 1\\n            farthest += step\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973498,
                "title": "squares-of-a-sorted-array-4-lines-code-2-methods",
                "content": "**Simple Solution with O(nlogn ) time O(1) space**\\n```\\npublic int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n            nums[i]=(int)Math.pow(nums[i],2);\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n```\\n**Two Pointer solution O(n)time O(n) space**\\n```\\n\\npublic int[] sortedSquares(int[] nus) {\\n        int n = nums.length, i = 0, j = n - 1;\\n        int[] result = new int[n];\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(nums[i]) > Math.abs(nums[j])) {\\n                result[p] = nums[i] * nums[i];\\n                i++;\\n            } else {\\n                result[p] = nums[j] * nums[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n```\\n**I hope you liked it if any doubt feel free to ask through comments .upvote if you like.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n            nums[i]=(int)Math.pow(nums[i],2);\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n```\n```\\n\\npublic int[] sortedSquares(int[] nus) {\\n        int n = nums.length, i = 0, j = n - 1;\\n        int[] result = new int[n];\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(nums[i]) > Math.abs(nums[j])) {\\n                result[p] = nums[i] * nums[i];\\n                i++;\\n            } else {\\n                result[p] = nums[j] * nums[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 971935,
                "title": "palindrome-partitioning-c-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is_pal(string &s,int start,int end){\\n        while(start<=end){\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(int index,string &s,vector<string> &path,vector<vector<string>> &res){\\n        if(index==s.size()){\\n            res.push_back(path);\\n            return ;\\n        }\\n        for(int i=index;i<s.size();++i){\\n            if(is_pal(s,index,i)){\\n                path.push_back(s.substr(index,i-index+1));\\n                dfs(i+1,s,path,res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        if(s.empty())\\n            return res;\\n        vector<string> path;\\n        dfs(0,s,path,res);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_pal(string &s,int start,int end){\\n        while(start<=end){\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(int index,string &s,vector<string> &path,vector<vector<string>> &res){\\n        if(index==s.size()){\\n            res.push_back(path);\\n            return ;\\n        }\\n        for(int i=index;i<s.size();++i){\\n            if(is_pal(s,index,i)){\\n                path.push_back(s.substr(index,i-index+1));\\n                dfs(i+1,s,path,res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        if(s.empty())\\n            return res;\\n        vector<string> path;\\n        dfs(0,s,path,res);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970172,
                "title": "smallest-subtree-with-all-the-deepest-nodes-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public:\\n\\t\\t//function to determine max depth of a given node\\n        int dep(TreeNode* node) {\\n            if(!node) return 0;\\n            return 1 + max(dep(node->left), dep(node->right));\\n        }\\n    \\n        TreeNode* subtreeWithAllDeepest(TreeNode* root) {\\n            if(!root) return NULL;\\n            \\n\\t\\t\\t//first find max depth of both the left and right branch of root\\n            int lDep = dep(root->left);\\n            int rDep = dep(root->right);\\n            \\n\\t\\t\\t//there are three possible scenarios here\\n\\t\\t\\t//left depth is the same as the right, meaning this is the node is the subtree that contains all the deepest nodes\\n            if(lDep == rDep) return root;\\n\\t\\t\\t\\n\\t\\t\\t//left depth is deeper than the right, meaning the answer is somewhere in the left subtree\\n            else if(lDep > rDep) return subtreeWithAllDeepest(root->left);\\n\\t\\t\\t\\n\\t\\t\\t//right depth is deeper than the left, meaning the answer is somewhere in the right subtree\\n            else return subtreeWithAllDeepest(root->right);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n\\t\\t//function to determine max depth of a given node\\n        int dep(TreeNode* node) {\\n            if(!node) return 0;\\n            return 1 + max(dep(node->left), dep(node->right));\\n        }\\n    \\n        TreeNode* subtreeWithAllDeepest(TreeNode* root) {\\n            if(!root) return NULL;\\n            \\n\\t\\t\\t//first find max depth of both the left and right branch of root\\n            int lDep = dep(root->left);\\n            int rDep = dep(root->right);\\n            \\n\\t\\t\\t//there are three possible scenarios here\\n\\t\\t\\t//left depth is the same as the right, meaning this is the node is the subtree that contains all the deepest nodes\\n            if(lDep == rDep) return root;\\n\\t\\t\\t\\n\\t\\t\\t//left depth is deeper than the right, meaning the answer is somewhere in the left subtree\\n            else if(lDep > rDep) return subtreeWithAllDeepest(root->left);\\n\\t\\t\\t\\n\\t\\t\\t//right depth is deeper than the left, meaning the answer is somewhere in the right subtree\\n            else return subtreeWithAllDeepest(root->right);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968413,
                "title": "remove-duplicates-from-sorted-array-ii-python-o-1-space-o-n-time",
                "content": "\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) <= 1:\\n            return len(nums)\\n        \\n        write_idx = 2\\n        for i in range(2,len(nums)):\\n            if nums[i] != nums[write_idx-2]:\\n                nums[write_idx] = nums[i] \\n                write_idx += 1\\n        return write_idx\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) <= 1:\\n            return len(nums)\\n        \\n        write_idx = 2\\n        for i in range(2,len(nums)):\\n            if nums[i] != nums[write_idx-2]:\\n                nums[write_idx] = nums[i] \\n                write_idx += 1\\n        return write_idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965226,
                "title": "pairs-of-songs-o-n-solution-it-beat-97-submissions-python",
                "content": "[](http://)[](http://)\\n```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ret = 0\\n        modulo = [0] * 60\\n        for i in time:\\n            modulo[i%60] +=1\\n        for i in range(1,30):\\n            ret += max(modulo[i],0)*max(modulo[60-i],0)\\n        \\n        ret += int(max(modulo[0],0)*max(modulo[0]-1,0)/2)\\n        ret += int(max(modulo[30],0)*max(modulo[30]-1,0)/2)\\n        \\n        return ret\\n```\\n\\n#python\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\\n        ret = 0\\n        modulo = [0] * 60\\n        for i in time:\\n            modulo[i%60] +=1\\n        for i in range(1,30):\\n            ret += max(modulo[i],0)*max(modulo[60-i],0)\\n        \\n        ret += int(max(modulo[0],0)*max(modulo[0]-1,0)/2)\\n        ret += int(max(modulo[30],0)*max(modulo[30]-1,0)/2)\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963262,
                "title": "spiral-matrix-ii-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n, vector<int>(n, 0));\\n        int X1 = 0, X2 = n;\\n        int Y1 = 0, Y2 = n;\\n        int x = 0;\\n        while (x < n*n) {\\n            for (int j = X1; j < X2; j++) {\\n                if (mat[Y1][j] == 0)\\n                    mat[Y1][j] = ++x;\\n            }\\n            for (int i = Y1; i < Y2; i++) {\\n                if (mat[i][X2-1] == 0)\\n                    mat[i][X2-1] = ++x;\\n            }\\n            for (int j = X2-1; j >= X1; j--) {\\n                if (mat[Y2-1][j] == 0)\\n                    mat[Y2-1][j] = ++x;\\n            }\\n            for (int i = Y2-1; i >= Y1; i--) {\\n                if (mat[i][X1] == 0)\\n                    mat[i][X1] = ++x;\\n            }\\n            X1++, X2--;Y1++;Y2--;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n, vector<int>(n, 0));\\n        int X1 = 0, X2 = n;\\n        int Y1 = 0, Y2 = n;\\n        int x = 0;\\n        while (x < n*n) {\\n            for (int j = X1; j < X2; j++) {\\n                if (mat[Y1][j] == 0)\\n                    mat[Y1][j] = ++x;\\n            }\\n            for (int i = Y1; i < Y2; i++) {\\n                if (mat[i][X2-1] == 0)\\n                    mat[i][X2-1] = ++x;\\n            }\\n            for (int j = X2-1; j >= X1; j--) {\\n                if (mat[Y2-1][j] == 0)\\n                    mat[Y2-1][j] = ++x;\\n            }\\n            for (int i = Y2-1; i >= Y1; i--) {\\n                if (mat[i][X1] == 0)\\n                    mat[i][X1] = ++x;\\n            }\\n            X1++, X2--;Y1++;Y2--;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963095,
                "title": "spiral-matrix-ii",
                "content": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        res = [[0] * n for _ in range(n)]\\n        D = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        d1, d2 = 0, 1\\n        x = y = k = 0\\n        for i in range(1, n * n + 1):\\n            res[x][y] = i\\n\\t\\t\\t# if cannot go further on current direction, turn right\\n            if not (0 <= x + d1 < n and 0 <= y + d2 < n and res[x + d1][y + d2] == 0):\\n                k = (k + 1) % 4\\n                d1, d2 = D[k]\\n            x += d1\\n            y += d2\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateMatrix(self, n: int) -> List[List[int]]:\\n        res = [[0] * n for _ in range(n)]\\n        D = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        d1, d2 = 0, 1\\n        x = y = k = 0\\n        for i in range(1, n * n + 1):\\n            res[x][y] = i\\n\\t\\t\\t# if cannot go further on current direction, turn right\\n            if not (0 <= x + d1 < n and 0 <= y + d2 < n and res[x + d1][y + d2] == 0):\\n                k = (k + 1) % 4\\n                d1, d2 = D[k]\\n            x += d1\\n            y += d2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962121,
                "title": "populating-next-right-pointers-ii",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        head=root\\n        while head:\\n            h1=None\\n            prev=None\\n            while head:\\n                for node in [head.left,head.right]:\\n                    if node:\\n                        if prev:\\n                            prev.next=node\\n                            prev=prev.next\\n                        else:\\n                            h1=node\\n                            prev=node\\n                head=head.next\\n            head=h1\\n        return(root)\\n```\\n\\nOnce next pointers have been created on level j, we can use them like a linked list. This offers a more efficient traversal for this problem than the usual tree algorithms. We can then generate the next pointers for level j+1 by simply stepping across the tree.\\n\\nThe outer loop steps down through the tree, while the inner loop steps left-to-right across a given level. All we need to remember between levels is the left-most node (h1) of the just-completed level.",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        head=root\\n        while head:\\n            h1=None\\n            prev=None\\n            while head:\\n                for node in [head.left,head.right]:\\n                    if node:\\n                        if prev:\\n                            prev.next=node\\n                            prev=prev.next\\n                        else:\\n                            h1=node\\n                            prev=node\\n                head=head.next\\n            head=h1\\n        return(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957886,
                "title": "python-3-solution-explained-reservoir-sampling-video-code",
                "content": "[](https://www.youtube.com/watch?v=pxvXV2bPlV0)\\nhttps://www.youtube.com/watch?v=pxvXV2bPlV0\\n```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        \"\"\"\\n        self.head = head\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        \"\"\"\\n        curr = self.head\\n        res = 0\\n        x = 1\\n        \\n        while curr:\\n            if random.random() < (1/x):\\n                res = curr.val\\n            \\n            x += 1\\n            curr = curr.next\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        \"\"\"\\n        @param head The linked list\\'s head.\\n        Note that the head is guaranteed to be not null, so it contains at least one node.\\n        \"\"\"\\n        self.head = head\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Returns a random node\\'s value.\\n        \"\"\"\\n        curr = self.head\\n        res = 0\\n        x = 1\\n        \\n        while curr:\\n            if random.random() < (1/x):\\n                res = curr.val\\n            \\n            x += 1\\n            curr = curr.next\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957461,
                "title": "ruby-o-n-time-o-1-space",
                "content": "```\\nclass Solution\\n  def initialize(head)\\n    @head = head\\n  end\\n\\n  def get_random\\n    head = @head\\n    count = 1\\n    result = nil\\n    \\n    while head\\n      result = head.val if rand(count) == 0\\n      head = head.next\\n      count += 1\\n    end\\n    \\n    result\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass Solution\\n  def initialize(head)\\n    @head = head\\n  end\\n\\n  def get_random\\n    head = @head\\n    count = 1\\n    result = nil\\n    \\n    while head\\n      result = head.val if rand(count) == 0\\n      head = head.next\\n      count += 1\\n    end\\n    \\n    result\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957297,
                "title": "linked-list-random-node-python3",
                "content": "import random\\n\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        self.res = []\\n        \\n        while head:\\n            self.res.append(head.val)\\n            head = head.next\\n            \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.res)",
                "solutionTags": [],
                "code": "import random\\n\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        self.res = []\\n        \\n        while head:\\n            self.res.append(head.val)\\n            head = head.next\\n            \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.res)",
                "codeTag": "Java"
            },
            {
                "id": 957245,
                "title": "without-extra-space",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        self.head = head\\n        self.count = self.count(head)\\n\\n    def count(self, node: ListNode) -> int:\\n        count = 1\\n        while node.next:\\n            node = node.next\\n            count += 1\\n        return count\\n        \\n    def getRandom(self) -> int: return self.get(random.randrange(self.count))\\n    \\n    def get(self, index: int) -> int:\\n        node = self.head\\n        for i in range(0,index):\\n            node = node.next\\n        return node.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, head: ListNode):\\n        self.head = head\\n        self.count = self.count(head)\\n\\n    def count(self, node: ListNode) -> int:\\n        count = 1\\n        while node.next:\\n            node = node.next\\n            count += 1\\n        return count\\n        \\n    def getRandom(self) -> int: return self.get(random.randrange(self.count))\\n    \\n    def get(self, index: int) -> int:\\n        node = self.head\\n        for i in range(0,index):\\n            node = node.next\\n        return node.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956985,
                "title": "rust-4ms",
                "content": "```rust\\nuse rand::prelude::*;\\n\\nstruct Solution {\\n    len: usize,\\n    list: Option<Box<ListNode>>,\\n}\\n\\nimpl Solution {\\n    fn new(head: Option<Box<ListNode>>) -> Self {\\n        let mut cur = head.as_ref();\\n        let mut len = 0;\\n        while let Some(node) = cur {\\n            cur = node.next.as_ref();\\n            len += 1;\\n        }\\n        Self { len, list: head }\\n    }\\n\\n    /** Returns a random node\\'s value. */\\n    fn get_random(&self) -> i32 {\\n        if self.len == 0 {\\n            return -1;\\n        }\\n        if self.len == 1 {\\n            return self.list.as_ref().unwrap().val;\\n        }\\n        let mut rng = rand::thread_rng();\\n        let target = rng.gen_range(0, self.len);\\n        let mut cur = 0;\\n        let mut node = self.list.as_ref().unwrap();\\n        while cur < target {\\n            node = node.next.as_ref().unwrap();\\n            cur += 1;\\n        }\\n        node.val\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse rand::prelude::*;\\n\\nstruct Solution {\\n    len: usize,\\n    list: Option<Box<ListNode>>,\\n}\\n\\nimpl Solution {\\n    fn new(head: Option<Box<ListNode>>) -> Self {\\n        let mut cur = head.as_ref();\\n        let mut len = 0;\\n        while let Some(node) = cur {\\n            cur = node.next.as_ref();\\n            len += 1;\\n        }\\n        Self { len, list: head }\\n    }\\n\\n    /** Returns a random node\\'s value. */\\n    fn get_random(&self) -> i32 {\\n        if self.len == 0 {\\n            return -1;\\n        }\\n        if self.len == 1 {\\n            return self.list.as_ref().unwrap().val;\\n        }\\n        let mut rng = rand::thread_rng();\\n        let target = rng.gen_range(0, self.len);\\n        let mut cur = 0;\\n        let mut node = self.list.as_ref().unwrap();\\n        while cur < target {\\n            node = node.next.as_ref().unwrap();\\n            cur += 1;\\n        }\\n        node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565951,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1827627,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1572817,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1565920,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1571657,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1828497,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1827865,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1828033,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1828013,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1571656,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1565951,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1827627,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1572817,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1565920,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1571657,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1828497,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1827865,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1828033,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1828013,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1571656,
                "content": [
                    {
                        "username": "heqingy",
                        "content": "I'm just curious how does the OJ test this question.\\n\\nGenerate n random numbers and see if the distribution of all numbers are almost equal? But what is the threshold for \"almost\"? \\n\\nI mean, since it has randomness, any distribution is possible, right?"
                    },
                    {
                        "username": "user3928d",
                        "content": "They require the nodes to be uniformly distributed, so when taking enough samples you expect to see all nodes roughly equally. There are statistical tests like the Kolmogorov\\u2013Smirnov test for example that ell you exactly how close it is to the uniform distribution"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "looks like linked lists are finally getting their time in the spotlight. Its about time"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "[@codeMonarch](/codeMonarch) we stay hungry,we devour"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "its about time, its about power\\n"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "Computing all those random numbers is way more expensive than simply traverse the list twice."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/linked-list-random-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Fixed-Range Sampling\n\n  \n**Approach 2:** Reservoir Sampling\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "haruhiku",
                        "content": "I think it's not that easy to come up with an idea to use Reservoir Sampling and the proof of correctness can be even harder. :("
                    },
                    {
                        "username": "philwill314",
                        "content": "The followup \"What if the linked list is extremely large and its length is unknown to you\" is misleading, because the solution ends up being O(N) time anyway, which you could get just traversing the list once to find out the length, which is the \"easy\" solution. People will struggle trying to come up with something impossible. "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Since given list is not modified, Why shouldn't we pick element from the list in round-robin fashion like picking head then head.next and then head.next.next and continuing with head once we reach tail. \n\n        if(this.randN == null)\n        {\n            this.randN = this.head;\n            return this.randN.val;\n        }\n        if(this.randN.next == null)\n        {\n            this.randN = this.head;\n        }\n        else\n        {\n            this.randN = this.randN.next;\n        }\n\n        return this.randN.val;\n\nI see probability of picking up an element is equal in above solution as-well. Please let me know if i'm missing anything"
                    },
                    {
                        "username": "Deeshank",
                        "content": "Everytime the getRandom() method is called we need to initialize the head of the linkedlist to the object with which we are traversing the list in the getRandom() method. And we have no means of knowing the previously accessed position of the Linkedlist. So we start over again and again displaying the same value."
                    },
                    {
                        "username": "anmol_1207",
                        "content": "I thought of same solution but I could not figure what is the flaw in the logic."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "What kind of randomness do they require and will OJ accept if I print the same node for each getRandom()?"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "They will take all your answers and plot it on the graph and will check whether value are uniformly distributed or not."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Why doesn\\'t converting the linked list to circular linked list work in this case? return current head\\'s value and move head to next node. Each node has the same probability in this case as well."
                    },
                    {
                        "username": "shahan989",
                        "content": "Thats the first thing that came to my mind and I implemented that as well. However, that causes our result not to be random anymore. Like you know what your result is gonna be.\\n\\nLets take [1,2,3,4]\\n\\nIf I call the function for the first time, I know its going to be 1. When call the next time, its gonna be 2 and so on. So that goes against the principle of randomness."
                    },
                    {
                        "username": "stridemann",
                        "content": "Because tests is made in shitty way."
                    },
                    {
                        "username": "dfnjy",
                        "content": "Like, give you an API to get the next element. This make sense because sometimes doing the traversal is very slow, say the elements are not in memory and you have to use some slow method to get the next one. So we can not simply count and rand."
                    }
                ]
            },
            {
                "id": 1572716,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1828435,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1828258,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1828015,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1827811,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1827646,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1573514,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1571658,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1674186,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1567513,
                "content": [
                    {
                        "username": "wwwsapir",
                        "content": "Hi, I think the instructions for this question\\'s Follow Up might not be clear enough.\\nThe Follow up says \"Could you solve this **efficiently** **without using extra space**?\".\\nBut as far as I understand, we do need a temporary (**extra space?**) integer variable that is the current node count in order to solve the question, and we can\\'t solve it without going through the list at least one full time (**efficiently?**).\\nWhat the follow up actually asks to avoid, is running over the list more than once (efficiently) and saving the length as an object property (without extra space).\\nSo in my opinion, that\\'s what should be stated in the follow up."
                    },
                    {
                        "username": "yjianghong",
                        "content": "Yeah I\\'m a bit concerned about the description as well since it really sounds as if the algorithm is looking for some sort of hack of list traversal"
                    },
                    {
                        "username": "Msey",
                        "content": "I think It\\'s easy question"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Think this animation makes a reasonably good job of visually explaining the reservoir sampling algo: https://www.youtube.com/watch?v=A1iwzSew5QY (not my vid, just though it was an easy explanation)."
                    },
                    {
                        "username": "stridemann",
                        "content": "It will not work because we cannot use statistics or random. \"Each node must have the SAME probability of being chosen.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Good Concept in a poor question! The Editorial solution is highly inefficient as it has `n` time complexity for every  `getRandom` call. Simply calculating the length of list and the generating a random index and traversing will have **Average complexity** less than that of `1*n` as we won\\'t need full traversal each time and only **worst case complexity** will be `1*n.` Not to forget that we will call random function only once unlike the editorial solution. This would have been a good question if there was a proper stream of numbers and we wanted k random numbers from time to time."
                    },
                    {
                        "username": "CheeseW",
                        "content": "Agreed! Though reservoir sampling is a cool thing to learn, I feel using it to solve this problem (getting 1 sample from a finite length list) is an overkill. "
                    },
                    {
                        "username": "skasana334",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n       \\n        int c = 0, n = 1;\\n        while (temp) {\\n            if (rand() % n == 0) {\\n                c = temp->val;\\n                return c;\\n            }\\n            n++;\\n            temp = temp->next;\\n        }\\n        return c;\\n    }\\n};\\n\\ncan anyone help me to find out why this is not working?\\n\\n    ListNode* temp;\\n    \\n    Solution(ListNode* head) {\\n        temp = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* curr = temp;\\n        int c = 0, n = 1;\\n        while (curr) {\\n            if (rand() % n == 0) {\\n                c = curr->val;\\n            }\\n            n++;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n};\\nand  why this is working the only difference is we are storing the head in another variable?"
                    },
                    {
                        "username": "namandt",
                        "content": "Solution class is initiated only once when you submit your solution.\n\nSee your 'temp' is an instance variable in your code\nso when constructor is called, temp is set to head.\nyou are modifying your temp with each call to getRandom,\n\nfor correct subsequent call your temp should be reset to head again but it wont happen becoz you are setting temp to head in constructor which will be called only once.\n\nIn second solution, you are creating a local variable curr and setting it to temp which is head at first,\nnow you are traversing using curr leaving temp unmodified!!\nthat will work becoz everytime cur will be set to head by temp."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Insert all elements into array. \\nReturn the element at rand()%arr.size() index"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "getRandom() is meant to return a random value from the **linked list** though. So it\\'s implied that you should work with the list and not a separate data structure, the follow up hints at that as well. "
                    },
                    {
                        "username": "1058007805",
                        "content": "Given a linked list with unknown length, the index of each node is i. We attempt to handle one node at a time, called a process. Assume that in the first process, the probability that the first node is selected is p1. Note that we eventually only select one node to return, thus on the following processes, the first node might be replaced by other nodes, and we indicate the probability that the first node will be replaced by the second node is p2, the third node is p3 and so on. Eventually, the probability that the first node will be selected is\\n\\np_1 = p1 * (1 - p2) * (1 - p3) * ... * (1 - pn)\\n\\nwhere n is the length of this list and we don\\'t know its value. But we do know the index i of each node. For the second node, the final probability that it will be selected can be expressed in a similar way. Namely,\\n\\np_2 = p2 * (1 - p3) * ... * (1 - pn)\\n\\nAnd the rest can be formulated in the similar way. So now come to our final goal, we want each node to be selected in the same probability. But we only know the index i of each node in its process. So how can we set up the value of p1, p2, p3......? Note the final goal can be formulated as\\n\\np_1 = p_2 = p_3 = ... = p_n = 1/n\\n\\nso we know when i = n, p_n = pn = 1/n. That is\\n\\npi = 1/i, when i = n.\\n\\nSo we have,\\n\\np_n = p_(n - 1) = p(n - 1) * (1 - pn) = p(n - 1) * (1 - 1/n) = 1/n\\np(n - 1) = 1/(n - 1)\\n\\nSimilarly, we get the rest probabilities as p(n - 2) = 1/(n - 2), ... ,p3 = 1/3, p2 = 1/2, p1 = 1/1. Note that the denominator of each probability in one process, that is pi, is equal to the index. So we can set the probability in each process as pi = 1/i. And the final probability to return a specific node will be\\n\\np_i = 1/i * (1 - 1/(i + 1)) * ... * (1 - 1/n)\\n    = 1/i * i/(i + 1) * (i + 1)/(i + 2) * ... * (n - 1)/n\\n    = 1/n\\n"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "are you saying that if length is unknown then nodes will no longer remain equally probable to get selected.\\nIf not, why you mention probablity  as 1/n. Please reply , it would be greatly appriciated."
                    },
                    {
                        "username": "Cristy94",
                        "content": "How do you get the value from a node? The class is \"ListNode\" but it is defined no where. I have tried node->value or node->data but neither works?"
                    },
                    {
                        "username": "ashish_sharma3001",
                        "content": "see the commented part you can see \"val\"."
                    },
                    {
                        "username": "mohamedAdhamc",
                        "content": "i see many are using pre-implemented algos like  `rand()` in c++ to generate the random number which kind of defeats the purpose of the question.  I mean if at an interview the best I could do is to rely on a pre-implemented function to generate a random number im not even solving the problem give, more just saying there is a known solution x which I only will use as a black box here."
                    },
                    {
                        "username": "specdrake",
                        "content": "[@shivam9935](/shivam9935) There is already a disagree button :)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Use me as disagree button."
                    },
                    {
                        "username": "hosua",
                        "content": "If using a pre-implemented algorithm was against the intention of the problem, it would be explicitly stated that you should not use it. It makes no sense to implement your own version of rand() here, you\\'re just trying to reinvent the wheel."
                    },
                    {
                        "username": "ChuJun_Song",
                        "content": "This question should be marked as Easy."
                    }
                ]
            },
            {
                "id": 1893940,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1834446,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828490,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828169,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828159,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828105,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828087,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828077,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828048,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828019,
                "content": [
                    {
                        "username": "District_12",
                        "content": "So what is the point if language provides std lib function to get a random number with equal probability? It should be in easy category?"
                    },
                    {
                        "username": "Ido_Ash",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *curr;\\n    ListNode *head;\\n\\n    Solution(ListNode* h) {\\n        head = h;\\n        curr=head;\\n    }\\n    \\n    int getRandom() {\\n        int temp=curr->val;\\n        curr=curr->next;\\n\\n        if(curr==NULL){\\n            curr=head;\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */\\n\\nCan anyone tell me why this solution is not working?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "What actually is the difficult part in this? isnt this like an easy question or am i missing something? Store  nodes in an array , randomly pick an index and return the node it has?"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "why is my code not working ?\\nmy approach is storing head in hd and current node in cr.\\nthen returning currrent node\\'s value and moving to next node.\\nwhenever list ends i reinitialize cr eith head and do same.\\n\\n\\n  /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* cr=NULL,*hd=NULL;\\n    Solution(ListNode* head) {\\n        cr=head;\\n        hd=head;\\n    }\\n    \\n    int getRandom() {\\n        if(cr==NULL){\\n            cr=hd;\\n            return getRandom();\\n        }\\n        int ans=cr->val;\\n        cr=cr->next;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(head);\\n * int param_1 = obj->getRandom();\\n */"
                    },
                    {
                        "username": "upscchap",
                        "content": "Hey buddy, I tried to solve this problem.\\nWould you please rate my approach and problem solving?\\n\\nhttps://youtu.be/O51NCghz38E\\n\\nThanks in advance!!!"
                    },
                    {
                        "username": "corndog573",
                        "content": "Given how the solution is being run, I think the solution using extra space is better than using no extra space. Since we can construct a new array `arr` for the values in the linked list, we can simply choose a random value from 0 to `arr.length-1` which gives us constant time complexity for retrieving values from the linked list (rather than having to traverse it in a linear fashion each time).\n\nHowever, if we were running it just once, then reservoir sampling may be better as it would have the same time complexity and require no extra space."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "class Solution {\\npublic:\\n    ListNode* temp;\\n    ListNode* start;\\n    Solution(ListNode* head) {\\n        temp = head;\\n        start = head;\\n    }\\n    \\n    int getRandom() {\\n        ListNode* copy = temp;\\n        temp = temp->next;\\n        if(!temp){\\n            temp = start;\\n        }\\n        return copy->val;\\n    }\\n};\\n\\ncan any one explain what is wrong with code?\\nit is giving me wrong answer in 5th testcase."
                    },
                    {
                        "username": "trpaslik",
                        "content": "Today I\\'ve learned some new and cool trick (Reservoir sampling)\\nThanks [@LeetCode](/LeetCode)!"
                    },
                    {
                        "username": "mak_coder",
                        "content": "Hi folks, I tried solving with the following approach.\\n1. I will save head pointer for linkedList \\n2. Initialize one more ListNode temp with head\\n3. in the random() method, i\\'ll check if temp is null\\n4. if it is null i\\'ll reinitialize it with head\\n5. If it is not then return temp.val and increment the temp to next listnode\\n\\nWhat is wrong with this approach ?\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Maybe they are expecting to implement Perlin\\'s Algorithm."
                    }
                ]
            },
            {
                "id": 1828011,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827995,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827929,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827897,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827895,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827797,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827795,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827786,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827774,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            },
            {
                "id": 1827759,
                "content": [
                    {
                        "username": "ProgDevel",
                        "content": "Test case 6 with sequence `[10,100,100,20,20,100]` always fails with `WA` when I trying to submit, but always successes when I just running code. What I'm doing wrong?\n\nI'm using approach without extra memory. Main idea is to use relative offsets and reversing the list before current item"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "what is this question asking ?\\ni mean if there is probability of equal even then we can get all the same answer so what we return ? "
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The output you see in the test cases are not the literal values that your function is expected to return. Behind the scenes they probably call your function many times for each test case to see if the values you return are distributed randomly. So all you need to do to pass the tests is code a function that returns a random value from the list. :) "
                    },
                    {
                        "username": "armagiddon19",
                        "content": " ```\\nSolution.prototype.getRandom = function() {\\n  const startNode = this.nodes;\\n  let move = startNode;\\n  while (true) {\\n    if (!move) move = startNode;\\n    if (Math.random() >= 0.8) return move.val;\\n\\n    move = move.next;\\n  }\\n};\\n```\\n\\nI can\\'t figure out why the submit doesn\\'t work. Code passed tests"
                    },
                    {
                        "username": "killerraj369",
                        "content": "I tried to store all the values in a hashset so that the probability of every node in the hashset becomes 1 (equally likely). But My solution didn\\'t get accepted instead returning a random node from the original list is working. Is that equally likely? What is wrong with my approach?"
                    },
                    {
                        "username": "vetor",
                        "content": "A little help to my coder friends :)\\ndont use math.random() if u wanna solve this problem\\n\\njava.util.Random Class\\n------------------------------ \\nThe java.util.Random class provides more flexible ways to generate uniformly distributed random numbers, providing easy generation of types other than double, as well as providing a Gaussian distribution.\\n\\n"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "LinkedList Series started I guess \\uD83E\\uDD14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "getRandom() is the crucial part.  Maybe I will try MT19937,"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "How to select a random index :\\nRandom rnd=new Random();\\nint ind=rnd.nextInt(sz);  // here sz is the size of linkedlist which you can easily measure using a while loop \\n  "
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "So, what I am using is something called Linear Congruential Generator, but somehow it gives me wrong answer? Idk what's up with this\n ```\nint getRandom() {\n       //seed=0, size=size_of_the_linked_list i.e {1,2,3} = 3\n        int result,a=size/2,b=a,m=size;\n        ListNode* temp=head;\n        result=(a*seed+b)%m;\n        seed=result;\n        while(result--){\n            temp=temp->next;\n        }\n        return temp->val;\n    }\n```"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "Do read the editorial even if you\\'ve already solved the problem."
                    }
                ]
            }
        ]
    },
    {
        "title": "License Key Formatting",
        "question_content": "<p>You are given a license key represented as a string <code>s</code> that consists of only alphanumeric characters and dashes. The string is separated into <code>n + 1</code> groups by <code>n</code> dashes. You are also given an integer <code>k</code>.</p>\n\n<p>We want to reformat the string <code>s</code> such that each group contains exactly <code>k</code> characters, except for the first group, which could be shorter than <code>k</code> but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.</p>\n\n<p>Return <em>the reformatted license key</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;5F3Z-2e-9-w&quot;, k = 4\n<strong>Output:</strong> &quot;5F3Z-2E9W&quot;\n<strong>Explanation:</strong> The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2-5g-3-J&quot;, k = 2\n<strong>Output:</strong> &quot;2-5G-3J&quot;\n<strong>Explanation:</strong> The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, and dashes <code>&#39;-&#39;</code>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 96512,
                "title": "java-5-lines-clean-solution",
                "content": "```\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = s.length() - 1; i >= 0; i--)\\n            if (s.charAt(i) != '-')\\n                sb.append(sb.length() % (k + 1) == k ? '-' : \"\").append(s.charAt(i));\\n        return sb.reverse().toString().toUpperCase();\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = s.length() - 1; i >= 0; i--)\\n            if (s.charAt(i) != '-')\\n                sb.append(sb.length() % (k + 1) == k ? '-' : \"\").append(s.charAt(i));\\n        return sb.reverse().toString().toUpperCase();\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131978,
                "title": "beats-100-python3-submission",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        S = S.replace(\"-\", \"\").upper()[::-1]\\n        return \\'-\\'.join(S[i:i+K] for i in range(0, len(S), K))[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        S = S.replace(\"-\", \"\").upper()[::-1]\\n        return \\'-\\'.join(S[i:i+K] for i in range(0, len(S), K))[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96506,
                "title": "concise-c-solution-scan-string-backward",
                "content": "**Key observation:** every `(K+1)`th character from the tail of the formatted string must be a `\\'-\\'`.\\n```\\n    string licenseKeyFormatting(string S, int K) {\\n      string res;\\n      for (auto i = S.rbegin(); i < S.rend(); i++)\\n        if (*i != \\'-\\') { // ignore \\'-\\' in original string\\n          if (res.size()%(K+1) == K) res += \\'-\\'; // every (K+1)th char is \\'-\\' from tail\\n          res += toupper(*i);\\n        }\\n        \\n      reverse(res.begin(), res.end());\\n      return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n    string licenseKeyFormatting(string S, int K) {\\n      string res;\\n      for (auto i = S.rbegin(); i < S.rend(); i++)\\n        if (*i != \\'-\\') { // ignore \\'-\\' in original string\\n          if (res.size()%(K+1) == K) res += \\'-\\'; // every (K+1)th char is \\'-\\' from tail\\n          res += toupper(*i);\\n        }\\n        \\n      reverse(res.begin(), res.end());\\n      return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540266,
                "title": "python-js-c-o-n-by-string-operation-w-explanation",
                "content": "O(n) by string operation.\\n\\n---\\n\\n**Explanation**:\\n\\nFirst, eliminate all dashes.\\n\\nSecond, start **grouping with size = K**,\\nRemember to make a special handle for first group in case that len(S) is not divisible by K.\\n\\nThird, link each group togetger, separated by dash, \\'-\\', at the junction point.\\n\\nFinally, return the result in **uppercase**.\\n\\n---\\n**Implementation**:\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        \\n        # Eliminate all dashes\\n        S = S.replace(\\'-\\', \\'\\')\\n        \\n        head = len(S) % K\\n        \\n        grouping = []\\n        \\n        # Special handle for first group\\n        if head:\\n            grouping.append( S[:head] )\\n        \\n        # General case:\\n        for index in range(head, len(S), K ):\\n            grouping.append( S[ index : index+K ] )\\n        \\n        \\n        # Link each group togetger and separated by dash \\'-\\'\\n        return \\'-\\'.join( grouping ).upper()\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar licenseKeyFormatting = function(s, k) {\\n    \\n    //  Eliminate all dashes\\n    const regex = /\\\\-/g;\\n    s = s.replace(regex, \"\");\\n    \\n    let head = s.length % k;\\n    \\n    let grouping = [];\\n    \\n    // Special handle for first group\\n    if( head ){\\n        grouping.push( s.substring(0, head) );\\n    }\\n    \\n    // General cases:\\n    for( let i = head ; i < s.length ; i += k ){\\n        grouping.push( s.substring(i, i+k) );\\n    }\\n    \\n    return grouping.join(\"-\").toUpperCase();\\n    \\n    \\n};\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        \\n        // Eliminate all dashes\\n        s = std::regex_replace(s, std::regex(\"\\\\-\"), \"\");\\n        \\n        int head = s.length() % k;\\n        \\n        vector<string> grouping;\\n        \\n        // Special handle for first group\\n        if( head ){\\n            grouping.emplace_back( s.substr(0, head) );\\n        }\\n        \\n        // General cases\\n        for( int i = head ; i < s.length() ; i += k ){\\n             grouping.emplace_back( s.substr(i, k) );\\n        }\\n        \\n        // Link each group togetger and separated by dash \\'-\\'\\n        s = join(grouping, \"-\");\\n        \\n        // to uppercase\\n        transform(s.begin(), s.end(), s.begin(), [](unsigned char c){ return std::toupper(c); } );\\n        return s;\\n    }\\n    \\nprivate:\\n    string join(const std::vector<string> &lst, const string &delim)\\n    {\\n        std::string ret;\\n        for(const auto &s : lst) {\\n            if(!ret.empty())\\n                ret += delim;\\n            ret += s;\\n        }\\n        return ret;\\n    }\\n    \\n};\\n```\\n\\n----\\n\\nReference:\\n\\n[1] [Python official docs about slicing syntax [ start : end : step ]](https://docs.python.org/3/whatsnew/2.3.html?highlight=slicing#extended-slices)\\n\\n[2] [Python official docs about str.join( ... )](https://docs.python.org/3/library/stdtypes.html?highlight=join#str.join)\\n\\n[3] [Python official docs about str.upper( )](https://docs.python.org/3/library/stdtypes.html?highlight=join#str.upper)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        \\n        # Eliminate all dashes\\n        S = S.replace(\\'-\\', \\'\\')\\n        \\n        head = len(S) % K\\n        \\n        grouping = []\\n        \\n        # Special handle for first group\\n        if head:\\n            grouping.append( S[:head] )\\n        \\n        # General case:\\n        for index in range(head, len(S), K ):\\n            grouping.append( S[ index : index+K ] )\\n        \\n        \\n        # Link each group togetger and separated by dash \\'-\\'\\n        return \\'-\\'.join( grouping ).upper()\\n```\n```\\nvar licenseKeyFormatting = function(s, k) {\\n    \\n    //  Eliminate all dashes\\n    const regex = /\\\\-/g;\\n    s = s.replace(regex, \"\");\\n    \\n    let head = s.length % k;\\n    \\n    let grouping = [];\\n    \\n    // Special handle for first group\\n    if( head ){\\n        grouping.push( s.substring(0, head) );\\n    }\\n    \\n    // General cases:\\n    for( let i = head ; i < s.length ; i += k ){\\n        grouping.push( s.substring(i, i+k) );\\n    }\\n    \\n    return grouping.join(\"-\").toUpperCase();\\n    \\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        \\n        // Eliminate all dashes\\n        s = std::regex_replace(s, std::regex(\"\\\\-\"), \"\");\\n        \\n        int head = s.length() % k;\\n        \\n        vector<string> grouping;\\n        \\n        // Special handle for first group\\n        if( head ){\\n            grouping.emplace_back( s.substr(0, head) );\\n        }\\n        \\n        // General cases\\n        for( int i = head ; i < s.length() ; i += k ){\\n             grouping.emplace_back( s.substr(i, k) );\\n        }\\n        \\n        // Link each group togetger and separated by dash \\'-\\'\\n        s = join(grouping, \"-\");\\n        \\n        // to uppercase\\n        transform(s.begin(), s.end(), s.begin(), [](unsigned char c){ return std::toupper(c); } );\\n        return s;\\n    }\\n    \\nprivate:\\n    string join(const std::vector<string> &lst, const string &delim)\\n    {\\n        std::string ret;\\n        for(const auto &s : lst) {\\n            if(!ret.empty())\\n                ret += delim;\\n            ret += s;\\n        }\\n        return ret;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96497,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        S = S.upper().replace('-','')\\n        size = len(S)\\n        s1 = K if size%K==0 else size%K\\n        res = S[:s1]\\n        while s1<size:\\n            res += '-'+S[s1:s1+K]\\n            s1 += K\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        S = S.upper().replace('-','')\\n        size = len(S)\\n        s1 = K if size%K==0 else size%K\\n        res = S[:s1]\\n        while s1<size:\\n            res += '-'+S[s1:s1+K]\\n            s1 += K\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96528,
                "title": "easy-to-understand-using-stringbuilder",
                "content": "```\\npublic class Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        // Replacing all - and converting all letters to uppercase\\n        String S1 = S.replace(\"-\",\"\");\\n        S1 = S1.toUpperCase();\\n        \\n        // Making stringBuilder \\n        StringBuilder sb = new StringBuilder();\\n         for(int i=0; i<S1.length();i++) {\\n            sb.append(S1.charAt(i));\\n        }\\n        int len = sb.toString().length();\\n        // Inserting '-' from back at every K position\\n        for(int i=K; i < len; i=i+K) {\\n                sb.insert(len-i,'-');\\n            }\\n        return sb.toString();   \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        // Replacing all - and converting all letters to uppercase\\n        String S1 = S.replace(\"-\",\"\");\\n        S1 = S1.toUpperCase();\\n        \\n        // Making stringBuilder \\n        StringBuilder sb = new StringBuilder();\\n         for(int i=0; i<S1.length();i++) {\\n            sb.append(S1.charAt(i));\\n        }\\n        int len = sb.toString().length();\\n        // Inserting '-' from back at every K position\\n        for(int i=K; i < len; i=i+K) {\\n                sb.insert(len-i,'-');\\n            }\\n        return sb.toString();   \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160768,
                "title": "simple-java-solution",
                "content": "```\\npublic String licenseKeyFormatting(String S, int K) {\\n        final String str = S.toUpperCase().replace(\"-\",\"\");\\n        StringBuilder sb = new StringBuilder();\\n        int counter=0;\\n        for (int i = str.length()-1; i>=0; --i) {\\n            sb.append(str.charAt(i));\\n            counter++;\\n            if(counter%K == 0 && i!=0) sb.append(\"-\");\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String licenseKeyFormatting(String S, int K) {\\n        final String str = S.toUpperCase().replace(\"-\",\"\");\\n        StringBuilder sb = new StringBuilder();\\n        int counter=0;\\n        for (int i = str.length()-1; i>=0; --i) {\\n            sb.append(str.charAt(i));\\n            counter++;\\n            if(counter%K == 0 && i!=0) sb.append(\"-\");\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353312,
                "title": "basic-javascript-solution",
                "content": "var licenseKeyFormatting = function(S, K) {\\n```\\n    const newStr = S.replace(/-/g, \\'\\').toUpperCase(), // Remove existing dashes and convert any lowercase letters to uppercase\\n             arr = newStr.split(\\'\\'); // Convert string to an array so we can manipulate it\\n\\n    for (let i = arr.length - 1 - K; i >= 0; i-= K) { // Loop through array backwards and decrement by value of K\\n        arr[i] = arr[i] + \\'-\\';\\n    }\\n\\n    return arr.join(\\'\\');\\n```\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    const newStr = S.replace(/-/g, \\'\\').toUpperCase(), // Remove existing dashes and convert any lowercase letters to uppercase\\n             arr = newStr.split(\\'\\'); // Convert string to an array so we can manipulate it\\n\\n    for (let i = arr.length - 1 - K; i >= 0; i-= K) { // Loop through array backwards and decrement by value of K\\n        arr[i] = arr[i] + \\'-\\';\\n    }\\n\\n    return arr.join(\\'\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96562,
                "title": "java-easy-to-understand-solution",
                "content": "    public String licenseKeyFormatting(String S, int K) {\\n        \\n        S = S.replaceAll(\"[-]\", \"\");\\n        S = S.toUpperCase();\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(S);\\n\\n        int i=sb.length()-K;\\n        while(i>0) {\\n            sb.insert(i, '-');\\n            i = i-K;\\n        }\\n\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String licenseKeyFormatting(String S, int K) {\\n        \\n        S = S.replaceAll(\"[-]\", \"\");\\n        S = S.toUpperCase();\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(S);\\n\\n        int i=sb.length()-K;\\n        while(i>0) {\\n            sb.insert(i, '-');\\n            i = i-K;\\n        }\\n\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 352717,
                "title": "python-3-short-simple-solution-with-explanation-and-fast",
                "content": "The idea is to seperate first group and the rest then combine them at the end\\nThis code finish between 32ms - 44ms\\n```python\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        S = S.replace(\"-\", \"\").upper() # remove \"-\" and covert string to uppercase\\n        remainder = len(S) % K      # calculate length of first group\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# For example:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# remainder==1; k=3: 1-123-123-123\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# remainder==0; k=3: _-123-123-123 (blank)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tfirst_grp = [S[: remainder]]\\n        other_grps= [S[i : i + K] for i in range(remainder, len(S), K)]\\n        \\n        if remainder: return \"-\".join(first_grp + other_grps)\\n\\t\\t# first group is empty at this point\\n        return \"-\".join(other_grps)\\n```\\nNote: \\nIt is recommended to use `\"\".join()` instead of string concatenation like `s+=\"str\"` because it is faster.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        S = S.replace(\"-\", \"\").upper() # remove \"-\" and covert string to uppercase\\n        remainder = len(S) % K      # calculate length of first group\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# For example:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# remainder==1; k=3: 1-123-123-123\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# remainder==0; k=3: _-123-123-123 (blank)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tfirst_grp = [S[: remainder]]\\n        other_grps= [S[i : i + K] for i in range(remainder, len(S), K)]\\n        \\n        if remainder: return \"-\".join(first_grp + other_grps)\\n\\t\\t# first group is empty at this point\\n        return \"-\".join(other_grps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96574,
                "title": "golang-beats-100-at-6ms",
                "content": "```\\nimport (\\n\\t\"fmt\"\\n\\t\"strings\"\\n)\\n\\nfunc licenseKeyFormatting(S string, K int) string {\\n        S = strings.Replace(S, \"-\", \"\", -1)\\n        S = strings.ToUpper(S)\\n        mod := len(S) % K\\n        \\n        if mod == 0 {\\n            mod += K\\n        }\\n        for mod < len(S) {\\n            S = S[:mod] + \"-\" + S[mod:]\\n            mod += K + 1\\n        }\\n        return S\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "String"
                ],
                "code": "```\\nimport (\\n\\t\"fmt\"\\n\\t\"strings\"\\n)\\n\\nfunc licenseKeyFormatting(S string, K int) string {\\n        S = strings.Replace(S, \"-\", \"\", -1)\\n        S = strings.ToUpper(S)\\n        mod := len(S) % K\\n        \\n        if mod == 0 {\\n            mod += K\\n        }\\n        for mod < len(S) {\\n            S = S[:mod] + \"-\" + S[mod:]\\n            mod += K + 1\\n        }\\n        return S\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 316752,
                "title": "clean-and-self-explanatory-11-ms-java-solution",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = S.length() - 1, count = 0 ; i >= 0 ; --i) {\\n            \\n            char c = S.charAt(i);\\n            if (c == \\'-\\') continue;\\n\\n            // put a \\'-\\' first if we already append K characters\\n            if (count == K) {\\n                sb.append(\\'-\\');\\n                count = 0;\\n            }\\n\\n            sb.append(Character.toUpperCase(c));\\n            ++count;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = S.length() - 1, count = 0 ; i >= 0 ; --i) {\\n            \\n            char c = S.charAt(i);\\n            if (c == \\'-\\') continue;\\n\\n            // put a \\'-\\' first if we already append K characters\\n            if (count == K) {\\n                sb.append(\\'-\\');\\n                count = 0;\\n            }\\n\\n            sb.append(Character.toUpperCase(c));\\n            ++count;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615384,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string S, int K) {\\n        stack<char> sChars;\\n        for (auto ch : S) {\\n            if (ch != \\'-\\')\\n                sChars.push(ch);\\n        }\\n        \\n        string sRet;\\n        int cur = 0;\\n        while (!sChars.empty()) {\\n            sRet += toupper(sChars.top());\\n            sChars.pop();\\n            cur++;\\n            \\n            if (cur == K && !sChars.empty()) {\\n                sRet += \\'-\\';\\n                cur = 0;\\n            }\\n        }\\n        reverse(sRet.begin(), sRet.end());\\n        return sRet;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string S, int K) {\\n        stack<char> sChars;\\n        for (auto ch : S) {\\n            if (ch != \\'-\\')\\n                sChars.push(ch);\\n        }\\n        \\n        string sRet;\\n        int cur = 0;\\n        while (!sChars.empty()) {\\n            sRet += toupper(sChars.top());\\n            sChars.pop();\\n            cur++;\\n            \\n            if (cur == K && !sChars.empty()) {\\n                sRet += \\'-\\';\\n                cur = 0;\\n            }\\n        }\\n        reverse(sRet.begin(), sRet.end());\\n        return sRet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226887,
                "title": "two-improper-test-cases",
                "content": "The question said \"The string is separated into N+1 groups by N dashes.\" Why these two test cases are used by the online judge......\\n\\n```\\n\"--a-a-a-a--\"\\n2\\n```\\n```\\n\"---\"\\n3\\n```",
                "solutionTags": [],
                "code": "```\\n\"--a-a-a-a--\"\\n2\\n```\n```\\n\"---\"\\n3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1323954,
                "title": "swift-license-key-formatting-test-cases",
                "content": "```swift\\nclass Solution {\\n    func licenseKeyFormatting(_ s: String, _ k: Int) -> String {\\n        let chars = [Character](s.uppercased()).filter{$0 != \"-\"}\\n        let l = chars.count\\n        if chars.isEmpty { return \"\" }\\n        if l < k { return String(chars) }\\n        if k == 1 {\\n            var res = chars.reduce(\"\", { $0 + \"-\\\\($1)\"})\\n            res.removeFirst()\\n            return res\\n        }\\n        \\n        var result = \"\"\\n        func add(f: Int = 0, _ end: Int) { result += String(chars[f..<end]) + \"-\" }\\n        var start  = l % k\\n        if start != 0 { add(start) }\\n        while start < l {\\n            add(f: start, start + k)\\n            start += k\\n        }\\n        result.removeLast()\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.017 (0.019) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test1() {\\n        let res = s.licenseKeyFormatting(\"5F3Z-2e-9-w\", 4)\\n        XCTAssertEqual(res, \"5F3Z-2E9W\")\\n    }\\n    func test2() {\\n        let res = s.licenseKeyFormatting(\"2-5g-3-J\", 2)\\n        XCTAssertEqual(res, \"2-5G-3J\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func licenseKeyFormatting(_ s: String, _ k: Int) -> String {\\n        let chars = [Character](s.uppercased()).filter{$0 != \"-\"}\\n        let l = chars.count\\n        if chars.isEmpty { return \"\" }\\n        if l < k { return String(chars) }\\n        if k == 1 {\\n            var res = chars.reduce(\"\", { $0 + \"-\\\\($1)\"})\\n            res.removeFirst()\\n            return res\\n        }\\n        \\n        var result = \"\"\\n        func add(f: Int = 0, _ end: Int) { result += String(chars[f..<end]) + \"-\" }\\n        var start  = l % k\\n        if start != 0 { add(start) }\\n        while start < l {\\n            add(f: start, start + k)\\n            start += k\\n        }\\n        result.removeLast()\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.017 (0.019) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test1() {\\n        let res = s.licenseKeyFormatting(\"5F3Z-2e-9-w\", 4)\\n        XCTAssertEqual(res, \"5F3Z-2E9W\")\\n    }\\n    func test2() {\\n        let res = s.licenseKeyFormatting(\"2-5g-3-J\", 2)\\n        XCTAssertEqual(res, \"2-5G-3J\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677842,
                "title": "please-remove-this-invalid-test-case-or-modify-the-template-code-accordingly",
                "content": "Testcase:\\n\\n```py\\n\\'---\\'\\n3\\n```\\nwill cause the built-in Python3 template code to overflow and throw `Error: Invalid Testcase`.",
                "solutionTags": [],
                "code": "```py\\n\\'---\\'\\n3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195218,
                "title": "very-simple-java-code-without-stringbuilder-and-only-a-single-pass-5ms-beats-100",
                "content": "The trick here is simply to loop backwards through the input string and use a pre-allocated char[] large enough for our output. This way, we don\\'t have to worry about inserting taking extra O(n) time, and we don\\'t have to do any special calculation for the size of the first group.\\n\\n\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n       \\n        //1. Allocate our buffers, output buffer should be large enough to fit as many dashes as needed\\n        char[] inputBuffer = S.toCharArray();\\n        char[] outputBuffer = new char[S.length() + S.length() / K + 1];\\n        int count = 0, start = 0, end = outputBuffer.length - 1;\\n        \\n        //2. Find the start index of the string (i.e. the first non-dash index)\\n        while(start < inputBuffer.length && inputBuffer[start] == \\'-\\') start++;\\n        \\n        //3. Loop backwards through the input and insert dashes as needed\\n        for(int i = inputBuffer.length - 1; i >= start; i--) {\\n            \\n            // skip over dashes in the input\\n            if(inputBuffer[i] == \\'-\\')\\n                continue;\\n            \\n            //4. add the character and uppercase if necessary\\n            outputBuffer[end--] = (char)(inputBuffer[i] + ((inputBuffer[i] > \\'Z\\') ? - \\' \\' : 0));\\n            count++;\\n\\n            //5. insert a dash when our count reaches K\\n            if(i > start && count == K) {\\n                outputBuffer[end--] = \\'-\\';\\n                count = 0;\\n            }\\n            \\n        }\\n        \\n        //6. Build the new string starting from our final output index\\n        return new String(outputBuffer, end + 1, outputBuffer.length - end - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n       \\n        //1. Allocate our buffers, output buffer should be large enough to fit as many dashes as needed\\n        char[] inputBuffer = S.toCharArray();\\n        char[] outputBuffer = new char[S.length() + S.length() / K + 1];\\n        int count = 0, start = 0, end = outputBuffer.length - 1;\\n        \\n        //2. Find the start index of the string (i.e. the first non-dash index)\\n        while(start < inputBuffer.length && inputBuffer[start] == \\'-\\') start++;\\n        \\n        //3. Loop backwards through the input and insert dashes as needed\\n        for(int i = inputBuffer.length - 1; i >= start; i--) {\\n            \\n            // skip over dashes in the input\\n            if(inputBuffer[i] == \\'-\\')\\n                continue;\\n            \\n            //4. add the character and uppercase if necessary\\n            outputBuffer[end--] = (char)(inputBuffer[i] + ((inputBuffer[i] > \\'Z\\') ? - \\' \\' : 0));\\n            count++;\\n\\n            //5. insert a dash when our count reaches K\\n            if(i > start && count == K) {\\n                outputBuffer[end--] = \\'-\\';\\n                count = 0;\\n            }\\n            \\n        }\\n        \\n        //6. Build the new string starting from our final output index\\n        return new String(outputBuffer, end + 1, outputBuffer.length - end - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831097,
                "title": "python-3-solution-93-lesser-memory",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = (s.upper()).replace(\"-\",\"\")[::-1]\\n        ans = str()\\n        for i in range(0,len(s),k):\\n            ans += s[i:i+k]+\"-\"\\n        return ans[::-1][1:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = (s.upper()).replace(\"-\",\"\")[::-1]\\n        ans = str()\\n        for i in range(0,len(s),k):\\n            ans += s[i:i+k]+\"-\"\\n        return ans[::-1][1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96491,
                "title": "javascript-6-liner-89ms-beats-100",
                "content": "The code is pretty self-explanatory.\\n\\n**\\uD83D\\uDCAF Check out https://techinterviewhandbook.org for more tips and tricks to ace your technical interview \\uD83D\\uDCAF**\\n\\n```\\nvar licenseKeyFormatting = function(S, K) {\\n    const raw = S.replace(/-/g, \\'\\').toUpperCase();\\n    let length = raw.length, chunks = [];\\n    while (length > 0) {\\n        chunks.push(raw.substring(length - K, length));\\n        length -= K;\\n    }\\n    return chunks.reverse().join(\\'-\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar licenseKeyFormatting = function(S, K) {\\n    const raw = S.replace(/-/g, \\'\\').toUpperCase();\\n    let length = raw.length, chunks = [];\\n    while (length > 0) {\\n        chunks.push(raw.substring(length - K, length));\\n        length -= K;\\n    }\\n    return chunks.reverse().join(\\'-\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282775,
                "title": "482-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First, we remove any dashes and convert all characters to uppercase:\\n```\\ns = s.replace(\"-\", \"\").upper()\\n```\\n2. Next, we calculate the length of the first group by taking the length of the string modulo k:\\n```\\nfirst_group_len = len(s) % k\\n```\\n3. We then initialize the reformatted license key with the first group by slicing the string up to the first_group_len:\\n```\\nreformatted = s[:first_group_len]\\n```\\n4. Next, we iterate over the remaining groups and add them to the reformatted license key. We start the iteration from first_group_len, and step through the string in increments of k:\\npython\\n```\\nfor i in range(first_group_len, len(s), k):\\n```\\n5. Inside the loop, we add a dash between groups if there is already some content in the reformatted license key:\\n```\\nif reformatted:\\n    reformatted += \"-\"\\n```\\n6. Finally, we add the next group to the reformatted license key:\\n```\\nreformatted += s[i:i+k]\\n```\\n7. We return the reformatted license key:\\n```\\nreturn reformatted\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        # Remove any dashes and convert all characters to uppercase\\n        s = s.replace(\"-\", \"\").upper()\\n\\n        # Calculate the length of the first group\\n        first_group_len = len(s) % k\\n\\n        # Initialize the reformatted license key with the first group\\n        reformatted = s[:first_group_len]\\n\\n        # Iterate over the remaining groups and add them to the reformatted license key\\n        for i in range(first_group_len, len(s), k):\\n            if reformatted:\\n                reformatted += \"-\"\\n            reformatted += s[i:i+k]\\n\\n        return reformatted\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ns = s.replace(\"-\", \"\").upper()\\n```\n```\\nfirst_group_len = len(s) % k\\n```\n```\\nreformatted = s[:first_group_len]\\n```\n```\\nfor i in range(first_group_len, len(s), k):\\n```\n```\\nif reformatted:\\n    reformatted += \"-\"\\n```\n```\\nreformatted += s[i:i+k]\\n```\n```\\nreturn reformatted\\n```\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        # Remove any dashes and convert all characters to uppercase\\n        s = s.replace(\"-\", \"\").upper()\\n\\n        # Calculate the length of the first group\\n        first_group_len = len(s) % k\\n\\n        # Initialize the reformatted license key with the first group\\n        reformatted = s[:first_group_len]\\n\\n        # Iterate over the remaining groups and add them to the reformatted license key\\n        for i in range(first_group_len, len(s), k):\\n            if reformatted:\\n                reformatted += \"-\"\\n            reformatted += s[i:i+k]\\n\\n        return reformatted\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534565,
                "title": "c-simulation-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Simulation**\\n```c++\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        int cnt = 0;\\n        for (char c : s) \\n            if (c != \\'-\\')\\n                cnt += 1;\\n        \\n        int rem = cnt % k;\\n        if (rem == 0)\\n            rem = k;\\n        \\n        string ans;\\n        for (char c : s) {\\n            if (c == \\'-\\') continue;\\n            if (rem == 0) {\\n                ans += \\'-\\';\\n                rem = k;\\n            }\\n            rem -= 1;\\n            ans += toupper(c);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is the length of string `s`.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Shorter version**\\n```c++\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        string res;\\n        for (auto it = s.rbegin(); it != s.rend(); ++it) {\\n            char c = *it;\\n            if (c == \\'-\\') continue;\\n            if (res.size() % (k+1) == k)\\n                res += \\'-\\';\\n            res += toupper(c);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is the length of string `s`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        int cnt = 0;\\n        for (char c : s) \\n            if (c != \\'-\\')\\n                cnt += 1;\\n        \\n        int rem = cnt % k;\\n        if (rem == 0)\\n            rem = k;\\n        \\n        string ans;\\n        for (char c : s) {\\n            if (c == \\'-\\') continue;\\n            if (rem == 0) {\\n                ans += \\'-\\';\\n                rem = k;\\n            }\\n            rem -= 1;\\n            ans += toupper(c);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        string res;\\n        for (auto it = s.rbegin(); it != s.rend(); ++it) {\\n            char c = *it;\\n            if (c == \\'-\\') continue;\\n            if (res.size() % (k+1) == k)\\n                res += \\'-\\';\\n            res += toupper(c);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175523,
                "title": "concise-python-beats-100",
                "content": "The idea here is that we want partition the elements in chunks of K, starting from the back. Whatever is leftover we just put into the last group.\\n\\nThis is easier if we have fast operations for removing the initial dashes. Which we can do with Python\\'s `replace` method.\\n\\nBy removing the dashes before partitioning, this becomes a quick operation.\\n\\nAfter partitioning, we join the resulting groups together on the connecting dash, and we\\'re done.\\n\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        def chunks(l, n):\\n            for i in range(0, len(l), n):\\n                yield l[i:i+n]\\n        s = S[::-1].upper().replace(\\'-\\', \\'\\')   \\n        return \\'-\\'.join(list(chunks(s, K)))[::-1]",
                "solutionTags": [],
                "code": "The idea here is that we want partition the elements in chunks of K, starting from the back. Whatever is leftover we just put into the last group.\\n\\nThis is easier if we have fast operations for removing the initial dashes. Which we can do with Python\\'s `replace` method.\\n\\nBy removing the dashes before partitioning, this becomes a quick operation.\\n\\nAfter partitioning, we join the resulting groups together on the connecting dash, and we\\'re done.\\n\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        def chunks(l, n):\\n            for i in range(0, len(l), n):\\n                yield l[i:i+n]\\n        s = S[::-1].upper().replace(\\'-\\', \\'\\')   \\n        return \\'-\\'.join(list(chunks(s, K)))[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 2752775,
                "title": "clean-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    # Time : O(n) | Space : O(n)\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        result = []\\n        count = 0\\n        s = s.replace(\"-\", \"\")\\n        for i in reversed(range(len(s))):\\n            result.append(s[i].upper())\\n            count += 1\\n            # we don\\'t want to put a dash in the first position of the array, so i != 0\\n            if count == k and i != 0:\\n                result.append(\"-\")\\n                count = 0\\n        return \\'\\'.join(result[::-1]) # doing a reverse \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Time : O(n) | Space : O(n)\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        result = []\\n        count = 0\\n        s = s.replace(\"-\", \"\")\\n        for i in reversed(range(len(s))):\\n            result.append(s[i].upper())\\n            count += 1\\n            # we don\\'t want to put a dash in the first position of the array, so i != 0\\n            if count == k and i != 0:\\n                result.append(\"-\")\\n                count = 0\\n        return \\'\\'.join(result[::-1]) # doing a reverse \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138098,
                "title": "c-482-license-key-formatting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string S, int K) {\\n        string ans; \\n        int k = K; \\n        for (int i = S.size()-1; i >= 0; --i) {\\n            if (S[i] != \\'-\\') {\\n                if (k == 0) {\\n                    ans.push_back(\\'-\\');\\n                    k = K; \\n                }\\n                ans.push_back(toupper(S[i])); \\n                --k; \\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string S, int K) {\\n        string ans; \\n        int k = K; \\n        for (int i = S.size()-1; i >= 0; --i) {\\n            if (S[i] != \\'-\\') {\\n                if (k == 0) {\\n                    ans.push_back(\\'-\\');\\n                    k = K; \\n                }\\n                ans.push_back(toupper(S[i])); \\n                --k; \\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374393,
                "title": "my-swift-and-java-solutions",
                "content": "Swift\\n```\\n\\nimport Foundation\\n\\nfunc licenseKeyFormatting(_ S: String, _ K: Int) -> String {\\n    var S = S\\n    S = S.uppercased()\\n    S = S.replacingOccurrences(of: \"-\", with: \"\")\\n    \\n    var charArray = Array(S)\\n    for i in stride(from: S.count - K, to: 0, by: -K) {\\n        charArray.insert(\"-\", at: i)\\n    }\\n    \\n    return String(charArray)\\n}\\n\\nassert(licenseKeyFormatting(\"5F3Z-2e-9-w\", 4) == \"5F3Z-2E9W\", \"Failed\")\\nassert(licenseKeyFormatting(\"2-5g-3-J\", 2) == \"2-5G-3J\", \"Failed\")\\n\\n```\\n\\nJava\\n```\\n\\nclass Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        S = S.toUpperCase();\\n        S = S.replace(\"-\", \"\");\\n        \\n        StringBuilder sb = new StringBuilder(S);\\n        for (int i = S.length() - K; i > 0; i -= K) { \\n            sb.insert(i, \"-\");\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nimport Foundation\\n\\nfunc licenseKeyFormatting(_ S: String, _ K: Int) -> String {\\n    var S = S\\n    S = S.uppercased()\\n    S = S.replacingOccurrences(of: \"-\", with: \"\")\\n    \\n    var charArray = Array(S)\\n    for i in stride(from: S.count - K, to: 0, by: -K) {\\n        charArray.insert(\"-\", at: i)\\n    }\\n    \\n    return String(charArray)\\n}\\n\\nassert(licenseKeyFormatting(\"5F3Z-2e-9-w\", 4) == \"5F3Z-2E9W\", \"Failed\")\\nassert(licenseKeyFormatting(\"2-5g-3-J\", 2) == \"2-5G-3J\", \"Failed\")\\n\\n```\n```\\n\\nclass Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        S = S.toUpperCase();\\n        S = S.replace(\"-\", \"\");\\n        \\n        StringBuilder sb = new StringBuilder(S);\\n        for (int i = S.length() - K; i > 0; i -= K) { \\n            sb.insert(i, \"-\");\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330756,
                "title": "simplest-java",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        int C = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int j = S.length() -1 ; j >= 0; j--){\\n            char a = Character.toUpperCase(S.charAt(j));\\n            if(a != \\'-\\'){\\n                if(C == K){\\n                    sb.append(\\'-\\');\\n                    C = 0;\\n                }\\n                sb.append(a);\\n                C++;\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        int C = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int j = S.length() -1 ; j >= 0; j--){\\n            char a = Character.toUpperCase(S.charAt(j));\\n            if(a != \\'-\\'){\\n                if(C == K){\\n                    sb.append(\\'-\\');\\n                    C = 0;\\n                }\\n                sb.append(a);\\n                C++;\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242209,
                "title": "what-confused-me-initially-2-4a0r7-4k-k4-2-4a0r-74k-c",
                "content": "Call me dumb, but the wording of the question kinda confused me that the 1st group can be lesser based on the first index of \"-\" and the rest of the groups are seperated by dashes at exactly K chars. However, when i submitted, this test case failed and had me scratching my head.\\n\\n\"**2-4A0r7-4k**\" K**4** > \"**2-4A0R-74K**\" **WRONG**\\n\"**24A0-R74K**\" **RIGHT**\\n\\nThen I realized that the groups should form from the end, even if it means the 1st group contains lesser chars than K\\nFeel so dumb :( Anyways, once I figured out why the submission was wrong, the fix was easy :)\\n```\\npublic string LicenseKeyFormatting(string S, int K) {\\n\\n    S = S.Replace(\"-\", \"\").ToUpper();\\n\\n    var sb = new StringBuilder(S);\\n    var l = sb.Length;\\n        \\n    for (var i = S.Length - K; i > 0; i -= K) {\\n        sb.Insert(i, \"-\");\\n    }\\n\\n    return sb.ToString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string LicenseKeyFormatting(string S, int K) {\\n\\n    S = S.Replace(\"-\", \"\").ToUpper();\\n\\n    var sb = new StringBuilder(S);\\n    var l = sb.Length;\\n        \\n    for (var i = S.Length - K; i > 0; i -= K) {\\n        sb.Insert(i, \"-\");\\n    }\\n\\n    return sb.ToString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1662959,
                "title": "rust-iterators",
                "content": "```\\nimpl Solution {\\n    pub fn license_key_formatting(s: String, k: i32) -> String {\\n        s\\n            .to_ascii_uppercase()\\n            .replace(\"-\", \"\")\\n            .as_bytes()\\n            .rchunks(k as usize)\\n            .rev()\\n            .map(|x| String::from_utf8_lossy(x))\\n            .collect::<Vec<_>>()\\n            .join(\"-\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn license_key_formatting(s: String, k: i32) -> String {\\n        s\\n            .to_ascii_uppercase()\\n            .replace(\"-\", \"\")\\n            .as_bytes()\\n            .rchunks(k as usize)\\n            .rev()\\n            .map(|x| String::from_utf8_lossy(x))\\n            .collect::<Vec<_>>()\\n            .join(\"-\")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776442,
                "title": "python-clean-and-simple-solution",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        S = \\'\\'.join(c for c in S if c != \\'-\\')\\n        first = len(S) % K\\n        res = []\\n        for i in range(first):\\n            res.append(S[i].upper())\\n    \\n        j = 0\\n        while j != len(S)-first:\\n            if j % K == 0 and len(res) > 0:\\n                res.append(\\'-\\')\\n            res.append(S[j+first].upper())\\n            j+=1\\n        return \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        S = \\'\\'.join(c for c in S if c != \\'-\\')\\n        first = len(S) % K\\n        res = []\\n        for i in range(first):\\n            res.append(S[i].upper())\\n    \\n        j = 0\\n        while j != len(S)-first:\\n            if j % K == 0 and len(res) > 0:\\n                res.append(\\'-\\')\\n            res.append(S[j+first].upper())\\n            j+=1\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594395,
                "title": "kt-js-py3-cpp-solutions",
                "content": "**Solution #1:**\\n\\nNaive alorithm which constructs the answer in reverse order.  Reverse order because the first group of the answer is the only group allowed to have less than `K` characters, thus we need to greedily take `K` characters for all but the first group).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun licenseKeyFormatting(S: String, K: Int): String {\\n        var ans = mutableListOf<Char>()\\n        S.toUpperCase().reversed().filter {\\n            it != \\'-\\'\\n        }.forEachIndexed { i, c ->\\n            if (0 < i && i % K == 0)\\n                ans.add(\\'-\\')\\n            ans.add(c)\\n        }\\n        return ans.reversed().joinToString(\"\")\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet licenseKeyFormatting = (S, K, ans = []) => {\\n    let A = S.split(\\'\\').filter(c => c != \\'-\\').map(c => c.toUpperCase()).reverse();\\n    for (let i = 0; i < A.length; ++i) {\\n        if (i && !(i % K))\\n            ans.push(\\'-\\');\\n        ans.push(A[i]);\\n    }\\n    return ans.reverse().join(\\'\\');\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        ans = []\\n        A = [c.upper() for c in reversed(S) if c != \\'-\\']\\n        for i in range(len(A)):\\n            if i and not (i % K):\\n                ans.append(\\'-\\')\\n            ans.append(A[i])\\n        return \\'\\'.join(reversed(ans))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string S, int K, string ans = {}) {\\n        S.erase(remove_if(S.begin(), S.end(), [](auto c) { return c == \\'-\\'; }), S.end());\\n        transform(S.begin(), S.end(), S.begin(), [](auto c) { return toupper(c); });\\n        reverse(S.begin(), S.end());\\n        for (auto i{ 0 }; i < S.size(); ++i) {\\n            if (i && !(i % K))\\n                ans.push_back(\\'-\\');\\n            ans.push_back(S[i]);\\n        }\\n        return { ans.rbegin(), ans.rend() };\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #2:**\\n\\nIt\\'s less efficient, but the logic is more \"straightforward\" to construct the answer using a queue data structure, ie. greedily `take` at-most `K` right-most characters at a time from the input `S` to form each `word` between `\\'-\\'` delimiters as the answer.\\n\\n---\\n\\n*Javascript*\\n```\\nlet licenseKeyFormatting = (S, K, ans = []) => {\\n    let A = S.split(\\'\\').filter(c => c != \\'-\\').map(c => c.toUpperCase());\\n    while (A.length) {\\n        let take = Math.min(A.length, K),\\n            word = [];\\n        while (take--)\\n            word.unshift(A.pop());\\n        ans.unshift(word.join(\\'\\'));\\n    }\\n    return ans.join(\\'-\\');\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        ans = deque()\\n        A = [c.upper() for c in S if c != \\'-\\']\\n        while len(A):\\n            take = min(len(A), K)\\n            word = deque()\\n            while take:\\n                word.appendleft(A.pop())\\n                take -= 1\\n            ans.appendleft(\\'\\'.join(word))\\n        return \\'-\\'.join(ans)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Deque = deque<char>;\\n    using Words = deque<string>;\\n    string licenseKeyFormatting(string S, int K, Words words = {}, ostringstream out = ostringstream()) {\\n        S.erase(remove_if(S.begin(), S.end(), [](auto c) { return c == \\'-\\'; }), S.end());\\n        transform(S.begin(), S.end(), S.begin(), ::toupper);\\n        while (S.size()) {\\n            auto take = min(int(S.size()), K);\\n            Deque word;\\n            while (take--)\\n                word.push_front(S.back()), S.pop_back();\\n            words.push_front({ word.begin(), word.end() });\\n        }\\n        copy(words.begin(), words.end(), ostream_iterator<string>(out, \"-\"));\\n        auto ans = out.str();\\n        if (ans.size())\\n            ans.pop_back(); // pop trailing \\'-\\'\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun licenseKeyFormatting(S: String, K: Int): String {\\n        var ans = mutableListOf<Char>()\\n        S.toUpperCase().reversed().filter {\\n            it != \\'-\\'\\n        }.forEachIndexed { i, c ->\\n            if (0 < i && i % K == 0)\\n                ans.add(\\'-\\')\\n            ans.add(c)\\n        }\\n        return ans.reversed().joinToString(\"\")\\n    }\\n}\\n```\n```\\nlet licenseKeyFormatting = (S, K, ans = []) => {\\n    let A = S.split(\\'\\').filter(c => c != \\'-\\').map(c => c.toUpperCase()).reverse();\\n    for (let i = 0; i < A.length; ++i) {\\n        if (i && !(i % K))\\n            ans.push(\\'-\\');\\n        ans.push(A[i]);\\n    }\\n    return ans.reverse().join(\\'\\');\\n};\\n```\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        ans = []\\n        A = [c.upper() for c in reversed(S) if c != \\'-\\']\\n        for i in range(len(A)):\\n            if i and not (i % K):\\n                ans.append(\\'-\\')\\n            ans.append(A[i])\\n        return \\'\\'.join(reversed(ans))\\n```\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string S, int K, string ans = {}) {\\n        S.erase(remove_if(S.begin(), S.end(), [](auto c) { return c == \\'-\\'; }), S.end());\\n        transform(S.begin(), S.end(), S.begin(), [](auto c) { return toupper(c); });\\n        reverse(S.begin(), S.end());\\n        for (auto i{ 0 }; i < S.size(); ++i) {\\n            if (i && !(i % K))\\n                ans.push_back(\\'-\\');\\n            ans.push_back(S[i]);\\n        }\\n        return { ans.rbegin(), ans.rend() };\\n    }\\n};\\n```\n```\\nlet licenseKeyFormatting = (S, K, ans = []) => {\\n    let A = S.split(\\'\\').filter(c => c != \\'-\\').map(c => c.toUpperCase());\\n    while (A.length) {\\n        let take = Math.min(A.length, K),\\n            word = [];\\n        while (take--)\\n            word.unshift(A.pop());\\n        ans.unshift(word.join(\\'\\'));\\n    }\\n    return ans.join(\\'-\\');\\n};\\n```\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        ans = deque()\\n        A = [c.upper() for c in S if c != \\'-\\']\\n        while len(A):\\n            take = min(len(A), K)\\n            word = deque()\\n            while take:\\n                word.appendleft(A.pop())\\n                take -= 1\\n            ans.appendleft(\\'\\'.join(word))\\n        return \\'-\\'.join(ans)\\n```\n```\\nclass Solution {\\npublic:\\n    using Deque = deque<char>;\\n    using Words = deque<string>;\\n    string licenseKeyFormatting(string S, int K, Words words = {}, ostringstream out = ostringstream()) {\\n        S.erase(remove_if(S.begin(), S.end(), [](auto c) { return c == \\'-\\'; }), S.end());\\n        transform(S.begin(), S.end(), S.begin(), ::toupper);\\n        while (S.size()) {\\n            auto take = min(int(S.size()), K);\\n            Deque word;\\n            while (take--)\\n                word.push_front(S.back()), S.pop_back();\\n            words.push_front({ word.begin(), word.end() });\\n        }\\n        copy(words.begin(), words.end(), ostream_iterator<string>(out, \"-\"));\\n        auto ans = out.str();\\n        if (ans.size())\\n            ans.pop_back(); // pop trailing \\'-\\'\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296060,
                "title": "faster-python-solution-beats-93-79-python3-online-submissions",
                "content": "```\\ndef licenseKeyFormatting(self, S: str, K: int) -> str:\\n        #S=input()\\n        #k=int(input())\\n        i=0\\n        j=len(S)-1\\n        N=[]\\n        S=S.replace(\"-\",\"\")\\n        S=S[::-1]\\n        parts = [S[i:i+K] for i in range(0, len(S), K)]\\n        #print(parts)\\n        for x in parts:\\n            N.append(x[::-1])\\n        #print(N)\\n        N=N[::-1]\\n        for i in range(0,len(N)-1):\\n            N[i]=N[i]+\"-\"\\n        #print(N)\\n        str1=\"\".join(str(e) for e in N)\\n        return (str1.upper())\\t\\n```\\n\\nCode is itself Self-Explanatory.\\n\\n\\nP.S. If anyone can optimise it more well, feel free to comment :)",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef licenseKeyFormatting(self, S: str, K: int) -> str:\\n        #S=input()\\n        #k=int(input())\\n        i=0\\n        j=len(S)-1\\n        N=[]\\n        S=S.replace(\"-\",\"\")\\n        S=S[::-1]\\n        parts = [S[i:i+K] for i in range(0, len(S), K)]\\n        #print(parts)\\n        for x in parts:\\n            N.append(x[::-1])\\n        #print(N)\\n        N=N[::-1]\\n        for i in range(0,len(N)-1):\\n            N[i]=N[i]+\"-\"\\n        #print(N)\\n        str1=\"\".join(str(e) for e in N)\\n        return (str1.upper())\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3373541,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        int n = s.size(), cnt=0;\\n        string ans = \"\";\\n        for(int i = n-1; i>=0;i--){\\n            if(s[i]== \\'-\\'){\\n                continue;\\n            }\\n            if(cnt>0 && cnt%k ==0){\\n                ans.push_back(\\'-\\');\\n            }\\n            ans.push_back(toupper(s[i]));\\n            cnt++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:  \\n        S = S.replace(\\'-\\', \\'\\')\\n        head = len(S) % K\\n        grouping = []\\n        if head:\\n            grouping.append( S[:head] )\\n        for index in range(head, len(S), K ):\\n            grouping.append( S[ index : index+K ] )\\n        return \\'-\\'.join( grouping ).upper()\\n```\\n\\n```Java []\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        char[] ch = s.toCharArray();\\n        int n = s.length();\\n        char[] result = new char[2*n-1];\\n        int j = k;\\n        int a = 2*n-2;\\n        for(int i = n-1; i >=0; i--){\\n            \\n            char elem = ch[i];\\n            \\n            if(elem == \\'-\\'){\\n                continue;\\n            }\\n            int value = (int)elem;\\n            if(value >= 97 && value <= 122){\\n                elem = (char)(value - 32);\\n            }\\n            if(j == 0){\\n                result[a] = \\'-\\';\\n                a--;\\n                j= k;\\n            }\\n            if(j > 0){\\n                result[a] = elem;\\n                j--;\\n                a--;\\n            }\\n        }\\n        return String.copyValueOf(result, a+1, (2*n-2)-a);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        int n = s.size(), cnt=0;\\n        string ans = \"\";\\n        for(int i = n-1; i>=0;i--){\\n            if(s[i]== \\'-\\'){\\n                continue;\\n            }\\n            if(cnt>0 && cnt%k ==0){\\n                ans.push_back(\\'-\\');\\n            }\\n            ans.push_back(toupper(s[i]));\\n            cnt++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:  \\n        S = S.replace(\\'-\\', \\'\\')\\n        head = len(S) % K\\n        grouping = []\\n        if head:\\n            grouping.append( S[:head] )\\n        for index in range(head, len(S), K ):\\n            grouping.append( S[ index : index+K ] )\\n        return \\'-\\'.join( grouping ).upper()\\n```\n```Java []\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        char[] ch = s.toCharArray();\\n        int n = s.length();\\n        char[] result = new char[2*n-1];\\n        int j = k;\\n        int a = 2*n-2;\\n        for(int i = n-1; i >=0; i--){\\n            \\n            char elem = ch[i];\\n            \\n            if(elem == \\'-\\'){\\n                continue;\\n            }\\n            int value = (int)elem;\\n            if(value >= 97 && value <= 122){\\n                elem = (char)(value - 32);\\n            }\\n            if(j == 0){\\n                result[a] = \\'-\\';\\n                a--;\\n                j= k;\\n            }\\n            if(j > 0){\\n                result[a] = elem;\\n                j--;\\n                a--;\\n            }\\n        }\\n        return String.copyValueOf(result, a+1, (2*n-2)-a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196642,
                "title": "easy-python-solution-traverse-from-end",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)-1, -1, -1):   #Traverse from end\\n            if s[i] != \\'-\\':                 #If current char isn\\'t hyphen\\n                if len(ans) % (k+1) == k:   #If length of current string is multiple of k + 1 (string ( size --> k) + \\'-\\' ( size --> 1)), insert another hyphen before another addition of character or stepping into another iteration\\n                    ans += \\'-\\'\\n                ans += s[i].upper()         #Convert to uppeCase character\\n        ans = ans [::-1]   #At the end, just reverse the ans before returning\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)-1, -1, -1):   #Traverse from end\\n            if s[i] != \\'-\\':                 #If current char isn\\'t hyphen\\n                if len(ans) % (k+1) == k:   #If length of current string is multiple of k + 1 (string ( size --> k) + \\'-\\' ( size --> 1)), insert another hyphen before another addition of character or stepping into another iteration\\n                    ans += \\'-\\'\\n                ans += s[i].upper()         #Convert to uppeCase character\\n        ans = ans [::-1]   #At the end, just reverse the ans before returning\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195837,
                "title": "java-simple-solution-understandable-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        int len=0;\\n        StringBuilder result=new StringBuilder();\\n        int i=s.length()-1;\\n        s=s.toUpperCase();\\n        \\n        while(i>=0){\\n            if(Character.isDigit(s.charAt(i))||Character.isLetter(s.charAt(i))){\\n                    if(len==k){\\n                        result.append(\\'-\\');\\n                        len=0;\\n                    }\\n                    result.append(s.charAt(i));\\n                    len++;\\n                \\n            }\\n            i--;\\n        }\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        int len=0;\\n        StringBuilder result=new StringBuilder();\\n        int i=s.length()-1;\\n        s=s.toUpperCase();\\n        \\n        while(i>=0){\\n            if(Character.isDigit(s.charAt(i))||Character.isLetter(s.charAt(i))){\\n                    if(len==k){\\n                        result.append(\\'-\\');\\n                        len=0;\\n                    }\\n                    result.append(s.charAt(i));\\n                    len++;\\n                \\n            }\\n            i--;\\n        }\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607314,
                "title": "javascript-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/b8de5843-6842-4c1b-9c9b-fd95f3a817d7_1663790263.3184433.png)\\n\\n```\\nvar licenseKeyFormatting = function(s, k) {\\n    s = s.replaceAll(\\'-\\', \\'\\').toUpperCase().split(\\'\\');\\n    \\n    for(let i = s.length - k; i > 0; i -= k) {\\n        s[i] = `-${s[i]}`\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar licenseKeyFormatting = function(s, k) {\\n    s = s.replaceAll(\\'-\\', \\'\\').toUpperCase().split(\\'\\');\\n    \\n    for(let i = s.length - k; i > 0; i -= k) {\\n        s[i] = `-${s[i]}`\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2576434,
                "title": "python-short-solution-very-easy",
                "content": "\\n\\n```class Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\\'-\\', \\'\\')\\n        l=len(s)\\n        for i in range(l-1,0,-1):\\n            if((l-i)%k==0 ):\\n                s=s[:i]+\\'-\\'+s[i:]\\n        return s.upper()",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\n\\n```class Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\\'-\\', \\'\\')\\n        l=len(s)\\n        for i in range(l-1,0,-1):\\n            if((l-i)%k==0 ):\\n                s=s[:i]+\\'-\\'+s[i:]\\n        return s.upper()",
                "codeTag": "Java"
            },
            {
                "id": 2087766,
                "title": "java-solution-16ms-runtime",
                "content": "```\\n// License Key Formatting\\n// LeetCode: https://leetcode.com/problems/license-key-formatting/\\n\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\'-\\') continue;\\n            if (count == k) {\\n                sb.append(\\'-\\');\\n                count = 0;\\n            }\\n            sb.append(s.charAt(i));\\n            count++;\\n        }\\n        return sb.reverse().toString().toUpperCase();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// License Key Formatting\\n// LeetCode: https://leetcode.com/problems/license-key-formatting/\\n\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\'-\\') continue;\\n            if (count == k) {\\n                sb.append(\\'-\\');\\n                count = 0;\\n            }\\n            sb.append(s.charAt(i));\\n            count++;\\n        }\\n        return sb.reverse().toString().toUpperCase();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316868,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        string ans;\\n        int count=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'-\\') continue;\\n            ans.push_back(toupper(s[i]));\\n            count++;\\n            if(count%k==0){\\n                ans.push_back(\\'-\\');\\n                count=0;\\n            }\\n        }\\n        if(ans.back()==\\'-\\'){\\n            ans.pop_back();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        string ans;\\n        int count=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'-\\') continue;\\n            ans.push_back(toupper(s[i]));\\n            count++;\\n            if(count%k==0){\\n                ans.push_back(\\'-\\');\\n                count=0;\\n            }\\n        }\\n        if(ans.back()==\\'-\\'){\\n            ans.pop_back();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286015,
                "title": "python-solution-easiest-google-license-key-formatting",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, our_str: str, k: int) -> str:\\n        \\n        our_str = our_str.replace(\\'-\\',\\'\\').upper()[::-1]\\n        res = \\'\\'\\n        count = 0\\n        \\n        for license_key_elem in our_str:\\n            if count == k:\\n                res += \\'-\\'\\n                count = 0\\n            res += license_key_elem\\n            count += 1\\n            \\n        return res[::-1]\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, our_str: str, k: int) -> str:\\n        \\n        our_str = our_str.replace(\\'-\\',\\'\\').upper()[::-1]\\n        res = \\'\\'\\n        count = 0\\n        \\n        for license_key_elem in our_str:\\n            if count == k:\\n                res += \\'-\\'\\n                count = 0\\n            res += license_key_elem\\n            count += 1\\n            \\n        return res[::-1]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 801853,
                "title": "python-reverse-and-list-comprehension",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n\\n        ## Upper, replace and Reverse\\n        s = S.upper().replace(\"-\", \\'\\')[::-1]\\n\\t\\t\\n        ## List Comprehension, Join with \\'-\\' and, Reverse back\\n        l = (\\'-\\'.join([(s[pos:pos + K]) for pos in range(0, len(s), K)]))[::-1]\\n\\n        return l",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n\\n        ## Upper, replace and Reverse\\n        s = S.upper().replace(\"-\", \\'\\')[::-1]\\n\\t\\t\\n        ## List Comprehension, Join with \\'-\\' and, Reverse back\\n        l = (\\'-\\'.join([(s[pos:pos + K]) for pos in range(0, len(s), K)]))[::-1]\\n\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 497486,
                "title": "javascript-straight-forward",
                "content": "```\\n/**\\n * @param {string} S\\n * @param {number} K\\n * @return {string}\\n */\\nvar licenseKeyFormatting = function(S, K) {\\n  S = S.replace(/-/g, \\'\\').toUpperCase();\\n  const res = [];\\n  while (S.length >= K) {\\n    res.unshift(S.slice(-K));\\n    S = S.slice(0, -K);\\n  }\\n  if (S.length) res.unshift(S);\\n  return res.join(\\'-\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} S\\n * @param {number} K\\n * @return {string}\\n */\\nvar licenseKeyFormatting = function(S, K) {\\n  S = S.replace(/-/g, \\'\\').toUpperCase();\\n  const res = [];\\n  while (S.length >= K) {\\n    res.unshift(S.slice(-K));\\n    S = S.slice(0, -K);\\n  }\\n  if (S.length) res.unshift(S);\\n  return res.join(\\'-\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231737,
                "title": "why-is-this-memory-limit-exceeded",
                "content": "Hi,\\n\\nI have submitted the following solution, however it is saying that memory limit exceeded for the test case of:\\n```\\n\"-\"\\n2\\n```\\nWhen I tested in the debug environment provided by leetcode for this test case, it is working all right and returning the correct output:\\n```\\n\"\"\\n```\\n\\nAnyone knows why it is showing the \"Memory Limit Exceeded\" error?\\n\\n```\\nclass Solution(object):\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        S = S.replace(\"-\", \"\")\\n        l = len(S)\\n        a, b = l / K, l % K\\n        res = \"\"\\n        if b != 0:\\n            res += S[:b].upper() + \"-\"\\n        for i in range(a):\\n            res += S[b: b + K].upper() + \"-\"\\n            b += K\\n        return res[:-1]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n\"-\"\\n2\\n```\n```\\n\"\"\\n```\n```\\nclass Solution(object):\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        S = S.replace(\"-\", \"\")\\n        l = len(S)\\n        a, b = l / K, l % K\\n        res = \"\"\\n        if b != 0:\\n            res += S[:b].upper() + \"-\"\\n        for i in range(a):\\n            res += S[b: b + K].upper() + \"-\"\\n            b += K\\n        return res[:-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 160922,
                "title": "regexp-javascript-with-explanation",
                "content": "The RegExp is splitting the string by empty strings that have one or more `K`-sized groups after them\\n\\nSplit by empty string means that join of the result is the initial string. For example string `\\'abc\\'` split by empty string will become `[\\'a\\', \\'b\\', \\'c\\']` vs split by `\\'b\\'` that is `[\\'a\\', \\'c\\']`\\n\\nLets go over the problem from the example of `\\'2-5g-3-J\\'` and `2` to understand th idea. First, lets make it `\\'25G3J\\'` by removing `\\'-\\'` and taking the result to upper case. Then the logic of the split RegExp would be\\n```\\n2 - empty string after this char matches because it has 4 characters after it that can be split into two groups of two characters\\n5 - empty string after this char do not match because 3 characters after it cannot be split it into groups of 2 characters\\nG - empty string after this char matches because it has 2 characters after it that is a group of two characters\\n3 - empty string after this char do not match because a single character after it can not form a group of 2 characters\\nJ - empty string after this char do not match because there should be at least one groups of two characters after\\n```\\nso the split would become `[\\'2\\', \\'5G\\', \\'3J\\']` then just join the split with `\\'-\\'` and it would become `\\'2-5G-3J\\'`\\n\\nAnd the code is\\n```\\nconst f = (S, K) => {\\n  return S\\n    .replace(/-/g, \\'\\')\\n    .toUpperCase()\\n    .split(RegExp(`(?=(?:.{${K}})+$)`))\\n    .join(\\'-\\')\\n}\\n```\\nWhere\\n```\\n            // empty string that is the match. So the initial srting would be splitted by each empty string that followes...\\n(?=         // start of look-forward. Means that paransesized part is required but would not be part of the match\\n  (?:       // mean do not use this group in the result. Need to be here because RegExp is used inside of split\\n    .       // any character\\n    {${K}}  // mix of JS string template with RegExp number of times to match what is right behind it. So it would be like {2} or {4}\\n  )\\n  +         // match thing that is right before it 1+ times\\n  $         // end of the string\\n)\\n```\\n\\nUPD: with newer Node this simplified code should also work\\n```\\nconst f = (S, K) => {\\n  return S\\n    .replace(/-/g, \\'\\').toUpperCase()\\n    .replace(RegExp(`(?<=.)(?=(.{${K}})+$)`, \\'g\\'), \\'-\\')\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n2 - empty string after this char matches because it has 4 characters after it that can be split into two groups of two characters\\n5 - empty string after this char do not match because 3 characters after it cannot be split it into groups of 2 characters\\nG - empty string after this char matches because it has 2 characters after it that is a group of two characters\\n3 - empty string after this char do not match because a single character after it can not form a group of 2 characters\\nJ - empty string after this char do not match because there should be at least one groups of two characters after\\n```\n```\\nconst f = (S, K) => {\\n  return S\\n    .replace(/-/g, \\'\\')\\n    .toUpperCase()\\n    .split(RegExp(`(?=(?:.{${K}})+$)`))\\n    .join(\\'-\\')\\n}\\n```\n```\\n            // empty string that is the match. So the initial srting would be splitted by each empty string that followes...\\n(?=         // start of look-forward. Means that paransesized part is required but would not be part of the match\\n  (?:       // mean do not use this group in the result. Need to be here because RegExp is used inside of split\\n    .       // any character\\n    {${K}}  // mix of JS string template with RegExp number of times to match what is right behind it. So it would be like {2} or {4}\\n  )\\n  +         // match thing that is right before it 1+ times\\n  $         // end of the string\\n)\\n```\n```\\nconst f = (S, K) => {\\n  return S\\n    .replace(/-/g, \\'\\').toUpperCase()\\n    .replace(RegExp(`(?<=.)(?=(.{${K}})+$)`, \\'g\\'), \\'-\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96578,
                "title": "java-o-n",
                "content": "```\\npublic String licenseKeyFormatting(String s, int k) {\\n    StringBuilder res = new StringBuilder();\\n    for (int i=s.length()-1, rem = k+1;i>=0;i--) {\\n        if (s.charAt(i) == '-') continue;\\n\\tif (--rem == 0) {\\n\\t    res.append(\"-\"); \\n\\t    rem = k;\\n\\t}\\n\\tres.append(Character.toUpperCase(s.charAt(i)));\\n   }\\n   return res.reverse().toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String licenseKeyFormatting(String s, int k) {\\n    StringBuilder res = new StringBuilder();\\n    for (int i=s.length()-1, rem = k+1;i>=0;i--) {\\n        if (s.charAt(i) == '-') continue;\\n\\tif (--rem == 0) {\\n\\t    res.append(\"-\"); \\n\\t    rem = k;\\n\\t}\\n\\tres.append(Character.toUpperCase(s.charAt(i)));\\n   }\\n   return res.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96577,
                "title": "one-liner",
                "content": "```\\ndef license_key_formatting(s, k)\\n  s.upcase.tr('-', '').reverse.scan(/.{1,#{k}}/).join('-').reverse\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef license_key_formatting(s, k)\\n  s.upcase.tr('-', '').reverse.scan(/.{1,#{k}}/).join('-').reverse\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3460136,
                "title": "python3-solution-using-replace",
                "content": "# Intuition\\n##### To solve this problem, we need to format the **license key** by grouping the characters into groups of \\'k\\' separated by hyphens and converting all characters to upper case. The approach can be to first remove all hyphens from the input string, convert it to upper case, and then iterate over the characters of the string, adding them to a new string while keeping track of the length of each group. When the length of a group reaches \\'k\\' , a hyphen can be added to separate it from the next group. The resulting string can then be returned as the formatted license key.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\nThe time complexity of the licenseKeyFormatting function is O(n), where n is the length of the input string s. This is because the function performs a constant number of operations for each character in the string.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the function is also O(n), because it creates a new string st of the same length as the input string, and may create additional strings during the execution of the function. However, the amount of additional space used by the function is proportional to the size of the groups, which is at most k, so the space complexity can be considered O(k).\\n\\n# Code\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        st=\"\"\\n        s=s.replace(\"-\",\"\").upper()\\n        s=s[::-1]\\n    \\n        for i in range(0,len(s),k):\\n            st+=s[i:i+k]\\n            st+=\"-\"\\n        sts=st[::-1]\\n       \\n        sts=sts.replace(\"-\",\"\",1)\\n        return sts\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        st=\"\"\\n        s=s.replace(\"-\",\"\").upper()\\n        s=s[::-1]\\n    \\n        for i in range(0,len(s),k):\\n            st+=s[i:i+k]\\n            st+=\"-\"\\n        sts=st[::-1]\\n       \\n        sts=sts.replace(\"-\",\"\",1)\\n        return sts\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419506,
                "title": "reverse-traversing-simple-logic",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\\'-\\', \\'\\').upper()\\n        new_key , dup = \\'\\' , k\\n\\n        for i in range(len(s)-1,-1,-1):\\n            if k!=0:\\n                new_key = s[i] + new_key\\n                k -= 1\\n\\n            if k == 0 and i != 0:\\n                new_key = \\'-\\' + new_key\\n                k = dup\\n\\n        return new_key\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\\'-\\', \\'\\').upper()\\n        new_key , dup = \\'\\' , k\\n\\n        for i in range(len(s)-1,-1,-1):\\n            if k!=0:\\n                new_key = s[i] + new_key\\n                k -= 1\\n\\n            if k == 0 and i != 0:\\n                new_key = \\'-\\' + new_key\\n                k = dup\\n\\n        return new_key\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415429,
                "title": "easiest-solution-in-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        String temp = \"\", formatted=\"\";\\n        s = s.toUpperCase();\\n        System.out.println(s);\\n        int count=k;\\n        for(int i=s.length()-1 ; i>=0 ; i--){\\n            if(s.charAt(i)!=\\'-\\'){\\n                if(count==0){\\n                    temp+=\\'-\\';\\n                    count=k;\\n                }\\n                temp+=s.charAt(i);\\n                count--;\\n            }\\n        }\\n        for(int i=temp.length()-1 ; i>=0 ; i--){\\n            formatted += temp.charAt(i);\\n        }\\n        return formatted; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        String temp = \"\", formatted=\"\";\\n        s = s.toUpperCase();\\n        System.out.println(s);\\n        int count=k;\\n        for(int i=s.length()-1 ; i>=0 ; i--){\\n            if(s.charAt(i)!=\\'-\\'){\\n                if(count==0){\\n                    temp+=\\'-\\';\\n                    count=k;\\n                }\\n                temp+=s.charAt(i);\\n                count--;\\n            }\\n        }\\n        for(int i=temp.length()-1 ; i>=0 ; i--){\\n            formatted += temp.charAt(i);\\n        }\\n        return formatted; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222452,
                "title": "reformatting-license-key-format-and-convert-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem, we need to format the license key so that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and we should convert all lowercase letters to uppercase.\\n\\nOne approach to solve the problem is to remove all dashes and convert all lowercase letters to uppercase. Then, we can calculate the length of the first group by taking the modulus of the length of the string with k. The rest of the string can be divided into groups of length k each. Finally, we can concatenate the first group with the rest of the groups, separated by dashes, to obtain the reformatted license key.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Remove all dashes from the input string `s` and convert all lowercase letters to uppercase using the `replace()` and `upper()` functions of Python string.\\n- Calculate the length of the first group by taking the modulus of the length of the string with `k` using the `%` operator.\\n- Construct the reformatted license key by adding the first group to the rest of the groups, separated by dashes (`-`), using a loop from `first_len` to `n` with a step size of `k`.\\n- Check if the reformatted string is empty or starts with a dash (`-`) and handle these cases appropriately.\\n- Return the reformatted license key.\\n# Complexity\\n- Time complexity:  The time complexity of the function is $$O(n)$$ where n is the length of the input string `s`. This is because we need to iterate through the string once to remove dashes and convert all lowercase letters to uppercase, and then once more to construct the reformatted license key.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the function is $$O(n)$$ because we are creating a new string to store the reformatted license key.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n            # Remove dashes and convert lowercase letters to uppercase\\n        s = s.replace(\\'-\\', \\'\\').upper()\\n        n = len(s)\\n    \\n    # Calculate length of first group\\n        first_len = n % k\\n    \\n    # Construct the reformatted license key\\n        reformatted = s[:first_len]\\n        for i in range(first_len, n, k):\\n            reformatted += \\'-\\' + s[i:i+k]\\n        \\n        if not reformatted:\\n            return \"\"\\n        elif reformatted[0] == \"-\":\\n            return reformatted[1:]\\n        else:\\n            return reformatted\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n            # Remove dashes and convert lowercase letters to uppercase\\n        s = s.replace(\\'-\\', \\'\\').upper()\\n        n = len(s)\\n    \\n    # Calculate length of first group\\n        first_len = n % k\\n    \\n    # Construct the reformatted license key\\n        reformatted = s[:first_len]\\n        for i in range(first_len, n, k):\\n            reformatted += \\'-\\' + s[i:i+k]\\n        \\n        if not reformatted:\\n            return \"\"\\n        elif reformatted[0] == \"-\":\\n            return reformatted[1:]\\n        else:\\n            return reformatted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967125,
                "title": "c-solution-98-66-time-67-3-space-used-mod-arithmetic-and-reverse-method",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k);\\n};\\n/*******************************************************************/\\nstring Solution::licenseKeyFormatting(string s, int k) {\\n    int i, size = s.size(), first, nDashes, nCyclesProc, nProc;\\n    string ans=\"\";\\n    for (i = size-1, nProc=0; i >= 0; --i) {\\n        if (s[i] == \\'-\\') {\\n            continue;\\n        }\\n        if (nProc > 0 && nProc % k == 0) {\\n            ans.push_back(\\'-\\');\\n        }\\n        ans.push_back(toupper(s[i]));\\n        ++nProc;\\n    }\\n    reverse(ans.begin(), ans.end());\\n    return ans;\\n}\\n/*******************************************************************/\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k);\\n};\\n/*******************************************************************/\\nstring Solution::licenseKeyFormatting(string s, int k) {\\n    int i, size = s.size(), first, nDashes, nCyclesProc, nProc;\\n    string ans=\"\";\\n    for (i = size-1, nProc=0; i >= 0; --i) {\\n        if (s[i] == \\'-\\') {\\n            continue;\\n        }\\n        if (nProc > 0 && nProc % k == 0) {\\n            ans.push_back(\\'-\\');\\n        }\\n        ans.push_back(toupper(s[i]));\\n        ++nProc;\\n    }\\n    reverse(ans.begin(), ans.end());\\n    return ans;\\n}\\n/*******************************************************************/\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860101,
                "title": "c-7-lines-only-90-faster",
                "content": "```c++\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        int itr = 0; string res = \"\";\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            if (s[i] == \\'-\\') continue;\\n            if (itr && (itr % k == 0)) res += \\'-\\'; itr++;\\n            res += toupper(s[i]);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        int itr = 0; string res = \"\";\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            if (s[i] == \\'-\\') continue;\\n            if (itr && (itr % k == 0)) res += \\'-\\'; itr++;\\n            res += toupper(s[i]);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603520,
                "title": "code-with-explanation-java",
                "content": "**Thought Process -**\\n*  Since it\\'s given in the question that we have to group together *K* characters together and the first group could be shorter than *K* so the first thing we could do is to traverse the string from backwards and start grouping K characters together.\\n*  So the idea is to **traverse** the string in **reverse** and **insert** *\"-\"* ***(dash)*** after every **K** elements.\\n*  We can keep a count of K elements using a count variable.\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\t//converting to uppercase and removing all \"-\"\\n        s = s.toUpperCase();\\n        s = s.replaceAll(\"-\",\"\");\\n        \\n\\t\\t//count for keeping track of K elements\\n        for(int i = s.length()-1,count =0; i >=0 ; i--)\\n        {\\n\\t\\t//append characters after k elements and reset the counter\\n            if(count == k){\\n                sb.append(\\'-\\');\\n                count = 0;\\n            }\\n            sb.append(s.charAt(i));\\n            count++;\\n        }\\n\\t\\t//reverse the resultant string \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\t//converting to uppercase and removing all \"-\"\\n        s = s.toUpperCase();\\n        s = s.replaceAll(\"-\",\"\");\\n        \\n\\t\\t//count for keeping track of K elements\\n        for(int i = s.length()-1,count =0; i >=0 ; i--)\\n        {\\n\\t\\t//append characters after k elements and reset the counter\\n            if(count == k){\\n                sb.append(\\'-\\');\\n                count = 0;\\n            }\\n            sb.append(s.charAt(i));\\n            count++;\\n        }\\n\\t\\t//reverse the resultant string \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528939,
                "title": "java-stringbuilder",
                "content": "```\\npublic String licenseKeyFormatting(String s, int k) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\tif (s.charAt(i) != \\'-\\') {\\n\\t\\t\\tif (sb.length() % (k + 1) == k) {\\n\\t\\t\\t\\tsb.append(\\'-\\');\\n\\t\\t\\t}\\n\\t\\t\\tsb.append(Character.toUpperCase(s.charAt(i)));\\n\\t\\t}\\n\\t}\\n\\treturn sb.reverse().toString();    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String licenseKeyFormatting(String s, int k) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\tif (s.charAt(i) != \\'-\\') {\\n\\t\\t\\tif (sb.length() % (k + 1) == k) {\\n\\t\\t\\t\\tsb.append(\\'-\\');\\n\\t\\t\\t}\\n\\t\\t\\tsb.append(Character.toUpperCase(s.charAt(i)));\\n\\t\\t}\\n\\t}\\n\\treturn sb.reverse().toString();    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2247764,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseStr(string& str)\\n    {\\n        int n = str.length();\\n        for (int i = 0; i < n / 2; i++)\\n            swap(str[i], str[n - i - 1]);\\n    }\\n    \\n    string licenseKeyFormatting(string s, int k) {\\n        string result = \"\";\\n        int counter = 0;\\n        for(int i = s.length()-1; i >= 0; i--){\\n            if(s[i] != \\'-\\') \\n            {\\n                result += toupper(s[i]);\\n                counter++;\\n                if(counter == k){\\n                    result += \\'-\\';\\n                    counter = 0;\\n                }\\n            }\\n        }\\n        reverseStr(result);\\n        if(result[0] == \\'-\\') return result.substr(1);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseStr(string& str)\\n    {\\n        int n = str.length();\\n        for (int i = 0; i < n / 2; i++)\\n            swap(str[i], str[n - i - 1]);\\n    }\\n    \\n    string licenseKeyFormatting(string s, int k) {\\n        string result = \"\";\\n        int counter = 0;\\n        for(int i = s.length()-1; i >= 0; i--){\\n            if(s[i] != \\'-\\') \\n            {\\n                result += toupper(s[i]);\\n                counter++;\\n                if(counter == k){\\n                    result += \\'-\\';\\n                    counter = 0;\\n                }\\n            }\\n        }\\n        reverseStr(result);\\n        if(result[0] == \\'-\\') return result.substr(1);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178557,
                "title": "python3-o-n-o-n-runtime-77ms-53-47-memory-14-7mb-41-07",
                "content": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 77ms 53.47% ; Memory: 14.7mb 41.07%\\n    def licenseKeyFormatting(self, string: str, k: int) -> str:\\n        newString = string.upper().replace(\\'-\\', \\'\\')[::-1]\\n        group = []\\n        for i in range(0, len(newString), k):\\n            group.append(newString[i:i+k])\\n        \\n        return \\'-\\'.join(group)[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 77ms 53.47% ; Memory: 14.7mb 41.07%\\n    def licenseKeyFormatting(self, string: str, k: int) -> str:\\n        newString = string.upper().replace(\\'-\\', \\'\\')[::-1]\\n        group = []\\n        for i in range(0, len(newString), k):\\n            group.append(newString[i:i+k])\\n        \\n        return \\'-\\'.join(group)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092739,
                "title": "kotlin-fast-stringbuilder-solution",
                "content": "```\\nclass Solution {\\n    fun licenseKeyFormatting(s: String, k: Int): String {\\n        var result = StringBuilder()\\n        \\n        for (i in s.length-1 downTo 0) {\\n            if (s[i] == \\'-\\') continue\\n            if (result.length % (k + 1) == k) result.append(\\'-\\')\\n            result.append(s[i].toUpperCase())\\n        }\\n        \\n        return result.reverse().toString()\\n    }\\n}\\n```\\nPlease upvote, if you like the solution)",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun licenseKeyFormatting(s: String, k: Int): String {\\n        var result = StringBuilder()\\n        \\n        for (i in s.length-1 downTo 0) {\\n            if (s[i] == \\'-\\') continue\\n            if (result.length % (k + 1) == k) result.append(\\'-\\')\\n            result.append(s[i].toUpperCase())\\n        }\\n        \\n        return result.reverse().toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063861,
                "title": "python-3-simple-concise-solution-5-lines",
                "content": "Code:\\n```\\n        r=\\'\\'.join(s.split(\\'-\\'))\\n        i,res=len(r),[]\\n        while i>0:\\n            res.append(r[i-k:i].upper()) if i-k>=0 else res.append(r[:i].upper())\\n            i-=k   \\n        return \\'-\\'.join(res[::-1])\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n        r=\\'\\'.join(s.split(\\'-\\'))\\n        i,res=len(r),[]\\n        while i>0:\\n            res.append(r[i-k:i].upper()) if i-k>=0 else res.append(r[:i].upper())\\n            i-=k   \\n        return \\'-\\'.join(res[::-1])\\n            \\n            \\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2044532,
                "title": "java-solution-simple-approach-o-n-time",
                "content": "```\\npublic String licenseKeyFormatting(String s, int k) {\\n        String res=\"\"; int count = k;\\n        for(int i=s.length()-1; i>=0; i--){\\n            char temp = s.charAt(i);\\n            if(temp != \\'-\\' && count>0){\\n                if(!Character.isUpperCase(temp)) res = Character.toUpperCase(temp)+res;\\n                else res = temp+res;\\n                count--;\\n            }\\n            if(count == 0 && i>0){\\n                res = \\'-\\'+res;\\n                count = k;\\n            }\\n        }\\n        if(res != \"\" && res.charAt(0) == \\'-\\' ) return res.substring(1);\\n        return res;\\n    }\\n```\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String licenseKeyFormatting(String s, int k) {\\n        String res=\"\"; int count = k;\\n        for(int i=s.length()-1; i>=0; i--){\\n            char temp = s.charAt(i);\\n            if(temp != \\'-\\' && count>0){\\n                if(!Character.isUpperCase(temp)) res = Character.toUpperCase(temp)+res;\\n                else res = temp+res;\\n                count--;\\n            }\\n            if(count == 0 && i>0){\\n                res = \\'-\\'+res;\\n                count = k;\\n            }\\n        }\\n        if(res != \"\" && res.charAt(0) == \\'-\\' ) return res.substring(1);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875594,
                "title": "license-key-formatting-solution-java",
                "content": "class Solution {\\n  public String licenseKeyFormatting(String S, int K) {\\n    StringBuilder sb = new StringBuilder();\\n    int length = 0;\\n\\n    for (int i = S.length() - 1; i >= 0; --i) {\\n      if (S.charAt(i) == \\'-\\')\\n        continue;\\n      if (length > 0 && length % K == 0)\\n        sb.append(\\'-\\');\\n      sb.append(Character.toUpperCase(S.charAt(i)));\\n      ++length;\\n    }\\n\\n    return sb.reverse().toString();\\n  }\\n}\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n  public String licenseKeyFormatting(String S, int K) {\\n    StringBuilder sb = new StringBuilder();\\n    int length = 0;\\n\\n    for (int i = S.length() - 1; i >= 0; --i) {\\n      if (S.charAt(i) == \\'-\\')\\n        continue;\\n      if (length > 0 && length % K == 0)\\n        sb.append(\\'-\\');\\n      sb.append(Character.toUpperCase(S.charAt(i)));\\n      ++length;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1450874,
                "title": "python-beats-100-time",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        \\n        keys = \"\".join(s.split(\"-\")).upper()\\n        \\n        startSize = len(keys)%k\\n        \\n        res = []\\n        \\n        if startSize != 0:\\n            res.append(keys[:startSize])\\n        \\n        for index in range(startSize, len(keys), k):\\n            res.append(keys[index:index+k])\\n        \\n        return \"-\".join(res)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        \\n        keys = \"\".join(s.split(\"-\")).upper()\\n        \\n        startSize = len(keys)%k\\n        \\n        res = []\\n        \\n        if startSize != 0:\\n            res.append(keys[:startSize])\\n        \\n        for index in range(startSize, len(keys), k):\\n            res.append(keys[index:index+k])\\n        \\n        return \"-\".join(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433753,
                "title": "c-solution",
                "content": "**approach 1**\\n```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        \\n        string res = \"\";\\n        int cnt = 0;\\n        for(int j = s.Length - 1; j >= 0; j--)\\n        {\\n            if(s[j] != \\'-\\')\\n            {\\n                res = Char.ToUpper(s[j]) + res;\\n                cnt++;\\n                \\n                if(cnt == k)\\n                {\\n                    cnt = 0;\\n                    res = \\'-\\' + res;\\n                }\\n            }\\n        }\\n        \\n        return res.TrimStart(\\'-\\');\\n    }\\n}\\n```\\n\\n**approach 2**\\n```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n          \\n        for(int j = s.Length - 1; j >= 0; j--)\\n        {\\n            if(s[j] != \\'-\\')\\n            {\\n                if(sb.Length % (k + 1) == k)\\n                    sb.Append(\\'-\\').Append(s[j]);\\n                else\\n                    sb.Append(s[j]);\\n            }\\n        }\\n        \\n        return new string(sb.ToString().Reverse().ToArray()).ToUpper();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        \\n        string res = \"\";\\n        int cnt = 0;\\n        for(int j = s.Length - 1; j >= 0; j--)\\n        {\\n            if(s[j] != \\'-\\')\\n            {\\n                res = Char.ToUpper(s[j]) + res;\\n                cnt++;\\n                \\n                if(cnt == k)\\n                {\\n                    cnt = 0;\\n                    res = \\'-\\' + res;\\n                }\\n            }\\n        }\\n        \\n        return res.TrimStart(\\'-\\');\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n          \\n        for(int j = s.Length - 1; j >= 0; j--)\\n        {\\n            if(s[j] != \\'-\\')\\n            {\\n                if(sb.Length % (k + 1) == k)\\n                    sb.Append(\\'-\\').Append(s[j]);\\n                else\\n                    sb.Append(s[j]);\\n            }\\n        }\\n        \\n        return new string(sb.ToString().Reverse().ToArray()).ToUpper();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381441,
                "title": "simple-python-program-with-explanation-beats-98",
                "content": "We have 2 variables as datatype strings --> one is \"res\" which will be returned as output. \"res2\" has removed all the hiphens and merged all the strings.\\n\\nFor example, input s =  \"5F3Z-2e-9-w\" then res2 as \"5F3Z2E9W\". \\n\\n****Now, the tricky part is what should be the length of first part or first element before the hiphen as everything else should be of length K. So, I have divided the length of res2 by k and the remainder will be the length of first element such that all other parts will be always K. If remainder is 0, we only need to merge all the K equal divided parts.***\\n\\nPLEASE LIKE IF YOU LIKE THE SOLUTION AND MY EXPLANATION.\\n\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        res=\"\"\\n        res2=s = s.upper().replace(\\'-\\', \\'\\')\\n        index = len(res2) % k \\n        if index != 0:             \\n            res+=res2[0:index]\\n            res+=\"-\"\\n        for i in range(index,len(res2),k):\\n            res+=res2[i:i+k]\\n            res+=\"-\"\\n        return res[:-1]\\n        \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "We have 2 variables as datatype strings --> one is \"res\" which will be returned as output. \"res2\" has removed all the hiphens and merged all the strings.\\n\\nFor example, input s =  \"5F3Z-2e-9-w\" then res2 as \"5F3Z2E9W\". \\n\\n****Now, the tricky part is what should be the length of first part or first element before the hiphen as everything else should be of length K. So, I have divided the length of res2 by k and the remainder will be the length of first element such that all other parts will be always K. If remainder is 0, we only need to merge all the K equal divided parts.***\\n\\nPLEASE LIKE IF YOU LIKE THE SOLUTION AND MY EXPLANATION.\\n\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        res=\"\"\\n        res2=s = s.upper().replace(\\'-\\', \\'\\')\\n        index = len(res2) % k \\n        if index != 0:             \\n            res+=res2[0:index]\\n            res+=\"-\"\\n        for i in range(index,len(res2),k):\\n            res+=res2[i:i+k]\\n            res+=\"-\"\\n        return res[:-1]\\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1332282,
                "title": "python-faster-than-99-04-well-commented-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        n = len(s)\\n        if n==1:\\n            return s.upper() if s != \\'-\\' else \\'\\'    # Handling Edge Cases\\n        dashes, groups = s.count(\\'-\\'), s.split(\\'-\\') # Number of Dashes, Group of Alphanumeric Sequnces\\n        totalChars = n - dashes                     # Length of string minus the dashes, will give the number of chars which are of importance to us\\n        firstGroupLength = totalChars % k           # We handle the first group explicitly.\\n        s = \\'\\'.join(groups).upper()                 # We create a string out of all groups.\\n        \\n        if firstGroupLength == 0:\\n            new = [s[i:i+k] for i in range(0, totalChars, k)] \\n            return \\'-\\'.join(new)\\n        else:\\n            new = [s[i:i+k] for i in range(firstGroupLength, totalChars, k)]\\n            return s[:firstGroupLength] + \\'-\\' + \\'-\\'.join(new)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        n = len(s)\\n        if n==1:\\n            return s.upper() if s != \\'-\\' else \\'\\'    # Handling Edge Cases\\n        dashes, groups = s.count(\\'-\\'), s.split(\\'-\\') # Number of Dashes, Group of Alphanumeric Sequnces\\n        totalChars = n - dashes                     # Length of string minus the dashes, will give the number of chars which are of importance to us\\n        firstGroupLength = totalChars % k           # We handle the first group explicitly.\\n        s = \\'\\'.join(groups).upper()                 # We create a string out of all groups.\\n        \\n        if firstGroupLength == 0:\\n            new = [s[i:i+k] for i in range(0, totalChars, k)] \\n            return \\'-\\'.join(new)\\n        else:\\n            new = [s[i:i+k] for i in range(firstGroupLength, totalChars, k)]\\n            return s[:firstGroupLength] + \\'-\\' + \\'-\\'.join(new)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285203,
                "title": "java-easiest-4-liner-solution-using-stringbuilder",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\tString s1=s.replace(\"-\", \"\").trim().toUpperCase();\\n\\t\\tStringBuilder sb=new StringBuilder(s1);\\n\\t\\t\\n\\t\\tfor(int i=sb.length()-k;i>0;i = i-k) {\\n\\t\\t\\tint value= i;\\n\\t\\t\\tsb.insert(value, \"-\");\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\tString s1=s.replace(\"-\", \"\").trim().toUpperCase();\\n\\t\\tStringBuilder sb=new StringBuilder(s1);\\n\\t\\t\\n\\t\\tfor(int i=sb.length()-k;i>0;i = i-k) {\\n\\t\\t\\tint value= i;\\n\\t\\t\\tsb.insert(value, \"-\");\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279558,
                "title": "python3-olution",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\\'-\\',\\'\\')\\n        s = list(s)\\n        for i in range(1,len(s)):\\n            if i % k == 0:\\n                s[-i] = \\'-\\' + s[-i]\\n        return (\\'\\'.join(s)).upper()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\\'-\\',\\'\\')\\n        s = list(s)\\n        for i in range(1,len(s)):\\n            if i % k == 0:\\n                s[-i] = \\'-\\' + s[-i]\\n        return (\\'\\'.join(s)).upper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246243,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        n = s.replace(\\'-\\',\\'\\').upper()\\n        res = []\\n        x = len(n)\\n        if x%k != 0:\\n            res.append(n[:x%k])\\n            n = n[x%k:]\\n            x = len(n)\\n        for i in range(0,x,k):\\n            res.append(n[i:i+k])\\n        return \\'-\\'.join(res)\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        n = s.replace(\\'-\\',\\'\\').upper()\\n        res = []\\n        x = len(n)\\n        if x%k != 0:\\n            res.append(n[:x%k])\\n            n = n[x%k:]\\n            x = len(n)\\n        for i in range(0,x,k):\\n            res.append(n[i:i+k])\\n        return \\'-\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073096,
                "title": "js-solution-using-stack",
                "content": "```\\nvar licenseKeyFormatting = function(S, K) {\\n  let stack = [];\\n    let result = \"\", n = K;\\n    for(let i=0;i<S.length;i++) {\\n        S[i] != \"-\" && stack.push(S[i]);\\n    }\\n    \\n    while(stack.length) {\\n        if(n>0) {\\n            result = stack.pop() + result;\\n            n--;\\n        } else {\\n            result = \"-\" + result;\\n            n = K;\\n        }\\n    }\\n    return result.toUpperCase();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar licenseKeyFormatting = function(S, K) {\\n  let stack = [];\\n    let result = \"\", n = K;\\n    for(let i=0;i<S.length;i++) {\\n        S[i] != \"-\" && stack.push(S[i]);\\n    }\\n    \\n    while(stack.length) {\\n        if(n>0) {\\n            result = stack.pop() + result;\\n            n--;\\n        } else {\\n            result = \"-\" + result;\\n            n = K;\\n        }\\n    }\\n    return result.toUpperCase();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 958794,
                "title": "simple-c-solution",
                "content": "\\n```\\nstring licenseKeyFormatting(string S, int K) {\\n        string out = removeDashAndCapitalize(S);\\n        for(int i = out.length() - K; i > 0; i -= K) //insert dashes at K intervals\\n        {\\n            //string::insert inserts char into position right before pos\\n            out.insert(i, \"-\");\\n        }\\n        return out;\\n    }\\n    \\n    string removeDashAndCapitalize(string s) //capitalize the string and remove dashes\\n    {\\n        string out;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'-\\')\\n                continue;\\n            else\\n                out += toupper(s[i]);\\n        }\\n        return out;\\n    }",
                "solutionTags": [],
                "code": "\\n```\\nstring licenseKeyFormatting(string S, int K) {\\n        string out = removeDashAndCapitalize(S);\\n        for(int i = out.length() - K; i > 0; i -= K) //insert dashes at K intervals\\n        {\\n            //string::insert inserts char into position right before pos\\n            out.insert(i, \"-\");\\n        }\\n        return out;\\n    }\\n    \\n    string removeDashAndCapitalize(string s) //capitalize the string and remove dashes\\n    {\\n        string out;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'-\\')\\n                continue;\\n            else\\n                out += toupper(s[i]);\\n        }\\n        return out;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 893314,
                "title": "c",
                "content": "\\tpublic string LicenseKeyFormatting(string S, int K) {\\n\\t\\tS = S.Replace(\"-\", \"\");\\n\\t\\tif (String.IsNullOrEmpty(S))\\n\\t\\t\\treturn String.Empty;\\n\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint i = S.Length % K;\\n\\t\\tif (i > 0)\\n\\t\\t\\tsb.Append($\"-{S[0..i]}\");\\n\\n\\t\\twhile (i < S.Length)\\n\\t\\t{\\n\\t\\t\\tsb.Append($\"-{S[i..(i + K)]}\");\\n\\t\\t\\ti += K;\\n\\t\\t}\\n\\n\\t\\treturn sb.ToString()[1..].ToUpper();\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic string LicenseKeyFormatting(string S, int K) {\\n\\t\\tS = S.Replace(\"-\", \"\");\\n\\t\\tif (String.IsNullOrEmpty(S))\\n\\t\\t\\treturn String.Empty;\\n\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint i = S.Length % K;\\n\\t\\tif (i > 0)\\n\\t\\t\\tsb.Append($\"-{S[0..i]}\");\\n\\n\\t\\twhile (i < S.Length)\\n\\t\\t{\\n\\t\\t\\tsb.Append($\"-{S[i..(i + K)]}\");\\n\\t\\t\\ti += K;\\n\\t\\t}\\n\\n\\t\\treturn sb.ToString()[1..].ToUpper();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 767213,
                "title": "c-brute-force-solution-easy-to-understand",
                "content": "***Runtime: 28 ms, faster than 85.79% of C++ online submissions for License Key Formatting.\\nMemory Usage: 8.5 MB, less than 41.67% of C++ online submissions for License Key Formatting..***\\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string S, int K) {\\n        string result;\\n        int index = S.size();\\n        int tempK = 0;\\n        while(--index >= 0){\\n            if(S[index] != \\'-\\'){\\n                if(tempK == K){\\n                    result += \\'-\\';\\n                    tempK = 0;\\n                }\\n                result += (isalpha(S[index]) ? char(toupper(S[index])) : S[index]);\\n                tempK++;\\n            }\\n        }\\n        return string(result.rbegin(), result.rend());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string S, int K) {\\n        string result;\\n        int index = S.size();\\n        int tempK = 0;\\n        while(--index >= 0){\\n            if(S[index] != \\'-\\'){\\n                if(tempK == K){\\n                    result += \\'-\\';\\n                    tempK = 0;\\n                }\\n                result += (isalpha(S[index]) ? char(toupper(S[index])) : S[index]);\\n                tempK++;\\n            }\\n        }\\n        return string(result.rbegin(), result.rend());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761420,
                "title": "python-o-n-detailed-explanations",
                "content": "Algorithm:\\n1. Extract the non-dash characters\\n2. Calculate the length of each group (including the first one)\\n3. Add the first group to the result and use the rest of the characters for the other groups\\n4. Add the other groups to the result\\n\\n\\nTime: O(n)\\nSpace: O(n)\\n```\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n       \\n        # Add non-dash characters to chars array\\n        chars = []\\n        for char in S:\\n            if char != \\'-\\':\\n                chars.append(char.upper())\\n        \\n        # Check if the number of non-dash characters is divisible by k\\n        # If so, all groups are equal length. Otherwise, the first one is smaller.\\n        remainder, group_count = len(chars) % K, len(chars) // K\\n        res = []\\n        # Create the first group\\n        if remainder:\\n            res.extend(chars[:remainder])\\n            res.append(\\'-\\')\\n        \\n        chars[:] = chars[remainder:] # put the first group aside and work with the rest of characters\\n        # Create the rest of the groups\\n        for i in range(group_count):\\n            res.extend(chars[i * K:(i + 1) * K])\\n            res.append(\\'-\\')\\n        \\n        return \\'\\'.join(res)[:-1]  # There will be extra \\'-\\' at the ends, so [:-1].\\n```",
                "solutionTags": [],
                "code": "```\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n       \\n        # Add non-dash characters to chars array\\n        chars = []\\n        for char in S:\\n            if char != \\'-\\':\\n                chars.append(char.upper())\\n        \\n        # Check if the number of non-dash characters is divisible by k\\n        # If so, all groups are equal length. Otherwise, the first one is smaller.\\n        remainder, group_count = len(chars) % K, len(chars) // K\\n        res = []\\n        # Create the first group\\n        if remainder:\\n            res.extend(chars[:remainder])\\n            res.append(\\'-\\')\\n        \\n        chars[:] = chars[remainder:] # put the first group aside and work with the rest of characters\\n        # Create the rest of the groups\\n        for i in range(group_count):\\n            res.extend(chars[i * K:(i + 1) * K])\\n            res.append(\\'-\\')\\n        \\n        return \\'\\'.join(res)[:-1]  # There will be extra \\'-\\' at the ends, so [:-1].\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 736037,
                "title": "python-solution-nice-and-easy",
                "content": "\\tclass Solution:\\n\\t\\tdef licenseKeyFormatting(self, S: str, K: int) -> str:\\n\\n\\t\\t\\tS = S.replace(\\'-\\', \\'\\').upper()\\n\\t\\t\\tl = len(S)\\n\\t\\t\\tres = \"\"\\n\\n\\t\\t\\tfor i in range(l-1, -1, -1):\\n\\t\\t\\t\\tres += S[i]\\n\\t\\t\\t\\tif (l-i) % K == 0:\\n\\t\\t\\t\\t\\tres += \\'-\\'\\n\\n\\t\\t\\treturn res.strip(\\'-\\')[::-1]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef licenseKeyFormatting(self, S: str, K: int) -> str:\\n\\n\\t\\t\\tS = S.replace(\\'-\\', \\'\\').upper()\\n\\t\\t\\tl = len(S)\\n\\t\\t\\tres = \"\"\\n\\n\\t\\t\\tfor i in range(l-1, -1, -1):\\n\\t\\t\\t\\tres += S[i]\\n\\t\\t\\t\\tif (l-i) % K == 0:\\n\\t\\t\\t\\t\\tres += \\'-\\'\\n\\n\\t\\t\\treturn res.strip(\\'-\\')[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 680717,
                "title": "funny-javascript-solution",
                "content": "```\\nconst licenseKeyFormatting = (S, K) => S\\n        .split(\\'\\')\\n        .reverse()\\n        .filter(v => v !== \\'-\\')\\n        .map((v, i, arr) => i % K === 0 && i !== 0 ? `${v}-` : v)\\n        .reverse()\\n        .join(\\'\\')\\n        .toUpperCase();\\n```",
                "solutionTags": [],
                "code": "```\\nconst licenseKeyFormatting = (S, K) => S\\n        .split(\\'\\')\\n        .reverse()\\n        .filter(v => v !== \\'-\\')\\n        .map((v, i, arr) => i % K === 0 && i !== 0 ? `${v}-` : v)\\n        .reverse()\\n        .join(\\'\\')\\n        .toUpperCase();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559766,
                "title": "python-3-simple-solution-beats-94-47",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        ns = \\'\\'.join(S.split(\"-\")).upper()\\n        n = len(ns)\\n        res = []\\n            \\n        if n % K != 0:\\n            res.append(ns[:n % K])\\n        for i in range(n % K, len(ns), K):\\n            res.append(ns[i:i + K ])\\n        return \\'-\\'.join(res)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        ns = \\'\\'.join(S.split(\"-\")).upper()\\n        n = len(ns)\\n        res = []\\n            \\n        if n % K != 0:\\n            res.append(ns[:n % K])\\n        for i in range(n % K, len(ns), K):\\n            res.append(ns[i:i + K ])\\n        return \\'-\\'.join(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 540542,
                "title": "java-stringbuilder-solution",
                "content": "```\\npublic class Solution {\\n    private static final char DASH = \\'-\\';\\n\\n    public String licenseKeyFormatting(String S, int K) {\\n        S = S.toUpperCase();\\n\\n        StringBuilder result = new StringBuilder();\\n        int count = 0;\\n\\n        for (int i = S.length() - 1; i >= 0; i--) {\\n            char c = S.charAt(i);\\n\\n            if (c == DASH) {\\n                continue;\\n            } else if (count == K) {\\n                result.append(\\'-\\');\\n                count = 0;\\n            }\\n\\n            result.append(c);\\n            count++;\\n        }\\n\\n        return result.reverse().toString();\\n    }\\n}\\n```\\n\\n**Thoughts before Coding**\\n- Since we only want uppercase letters, we can first convert our input string to uppercase\\n- We also need to generate a license key that has a length with at most 12,000\\n\\t- We will need to use a StringBuilder to accumulate each character\\n\\t- Strings are immutable, we do not want to be concatenating strings\\n- Since, our first group in our string can have a character count of 1 -> k\\n\\t- We should work from the rightmost index of our input string and move to the left\\n- We may need a character count variable to keep track of our current number of characters in each group\\n\\t- When our character count variable reaches K, we will append a \\'-\\'\\n\\t\\t- Before we append a \\'-\\', we need to check if our current character that we are looking at in our input string is not a \\'-\\',\\n\\t\\t\\t- because what if the input string is \\'-12-34\\', and our K is 4?\\n\\t\\t\\t\\t- We do not want our result to be \\'-1234\\'\\n\\t- If our current count variable equals K, we will need to reset it back to 0\\n- Since, we should only be using StringBuilder.append to add in more characters\\n\\t- We have to reverse our StringBuilder before returning this result\\n\\t- This is because if our input string is \\'-12-34\\', and K is 4.\\n\\t\\t- If we start working from the back, our StringBuilder becomes 4321\\n\\t\\t\\t- We need to reverse 4321 to get 1234\\n\\n**Answer**\\n- We will first convert our input string to uppercase\\n\\t- It will be a hassle to check for lowercase letters when we are iterating later\\n- We also will instantiate a StringBuilder to hold our final result\\n\\t- Do not forget to reverse our stringbuilder later\\n- We need a counter to keep track of our current count for the current group\\n- We will first start with iterating from the end of our input string\\n\\t- If the current character is \\'-\\', we can continue our loop\\n\\t- If our counter equals K, we have finished one group\\n\\t\\t- We will append a \\'-\\' to our input string\\n\\t\\t- reset our counter back to 0\\n\\t- We will append our current character\\n\\t- increment our counter\\n- return the reversed string from our string builder\\n\\n**Gotchas**\\n- We do not want to prepend characters to our stringbuilder with sb.insert(0, char)\\n\\t- this is because the stringbuilder needs to copy an array to push the elements to the right to make space for our new char\\n\\t- The append method will just add another character to the end of the array without shifting all of the other characters\\n\\n**What is the Time and Space complexity?**\\n- Time complexity = O(k) + O(k) + O(k) = O(k), where k is the length of our input string S\\n\\t- O(k) - converting our input string to uppercase\\n\\t- O(k) - iterating through our input string to find our license key\\n\\t- O(k) - reversing our string builder\\n- Space complexity = O(k), where k is the length of our input string S\\n\\t- O(k) - StringBuilder to hold our result",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private static final char DASH = \\'-\\';\\n\\n    public String licenseKeyFormatting(String S, int K) {\\n        S = S.toUpperCase();\\n\\n        StringBuilder result = new StringBuilder();\\n        int count = 0;\\n\\n        for (int i = S.length() - 1; i >= 0; i--) {\\n            char c = S.charAt(i);\\n\\n            if (c == DASH) {\\n                continue;\\n            } else if (count == K) {\\n                result.append(\\'-\\');\\n                count = 0;\\n            }\\n\\n            result.append(c);\\n            count++;\\n        }\\n\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534605,
                "title": "java-kiss-solution",
                "content": "public static  String licenseKeyFormatting(String S, int K) {\\n\\n        S = S.replace(\"-\",\"\").toUpperCase();\\n        // Making stringBuilder\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(S);\\n\\n        int len = S.length();\\n        // Inserting \\'-\\' from back at every K position\\n        for(int i=len-1-K; i >0; i=i-K) {\\n                sb.insert(i,\\'-\\');\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "public static  String licenseKeyFormatting(String S, int K) {\\n\\n        S = S.replace(\"-\",\"\").toUpperCase();\\n        // Making stringBuilder\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(S);\\n\\n        int len = S.length();\\n        // Inserting \\'-\\' from back at every K position\\n        for(int i=len-1-K; i >0; i=i-K) {\\n                sb.insert(i,\\'-\\');\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 461203,
                "title": "simple-java-solution-using-character-isletterordigit-14ms",
                "content": "```\\npublic String licenseKeyFormatting(String S, int K) {\\n        \\n        if(S == null || S.length() == 0) return S;\\n        \\n        S = S.toUpperCase();\\n        int k = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int index = S.length() - 1; index >=0; index--){\\n            char ch = S.charAt(index);\\n            \\n            if(Character.isLetterOrDigit(ch)){\\n                if(k == K){\\n                    sb.append(\"-\");\\n                    sb.append(ch);\\n                    k=1;\\n                }else{\\n                    sb.append(ch);\\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic String licenseKeyFormatting(String S, int K) {\\n        \\n        if(S == null || S.length() == 0) return S;\\n        \\n        S = S.toUpperCase();\\n        int k = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int index = S.length() - 1; index >=0; index--){\\n            char ch = S.charAt(index);\\n            \\n            if(Character.isLetterOrDigit(ch)){\\n                if(k == K){\\n                    sb.append(\"-\");\\n                    sb.append(ch);\\n                    k=1;\\n                }else{\\n                    sb.append(ch);\\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 422603,
                "title": "python-faster-than-99",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        S_new=S.replace(\\'-\\',\\'\\')[::-1]\\n        group=(len(S_new)+K-1)//K\\n        out=[]\\n        for i in range(group):\\n            out.append(S_new[i*K:(i+1)*K][::-1].upper())\\n        return \\'-\\'.join(out[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        S_new=S.replace(\\'-\\',\\'\\')[::-1]\\n        group=(len(S_new)+K-1)//K\\n        out=[]\\n        for i in range(group):\\n            out.append(S_new[i*K:(i+1)*K][::-1].upper())\\n        return \\'-\\'.join(out[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384371,
                "title": "c-92-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public string LicenseKeyFormatting(string S, int K)\\n        {\\n            S = S.Replace(\"-\", \"\").ToUpper();\\n            var sb = new StringBuilder();\\n            for (int i = 0; i < S.Length; i++)\\n            {\\n                if (i != 0 && (S.Length - i) % K == 0)\\n                {\\n                    sb.Append(\\'-\\');\\n                }\\n                sb.Append(S[i]);\\n            }\\n            return sb.ToString();\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public string LicenseKeyFormatting(string S, int K)\\n        {\\n            S = S.Replace(\"-\", \"\").ToUpper();\\n            var sb = new StringBuilder();\\n            for (int i = 0; i < S.Length; i++)\\n            {\\n                if (i != 0 && (S.Length - i) % K == 0)\\n                {\\n                    sb.Append(\\'-\\');\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 271271,
                "title": "my-python3-solution",
                "content": "```\\nclass Solution(object):                      \\n    def licenseKeyFormatting(self, S, K):\\n        s, lc, uc = \\'\\', string.ascii_letters[:26], string.ascii_letters[26:]\\n        for a in S:\\n            if a != \\'-\\': s += a\\n        s, ans = s[::-1], \\'\\'\\n        for i, a in enumerate(s):         \\n            if i != 0 and i % K == 0: ans += \\'-\\'\\n            if a in lc: a = uc[lc.find(a)]\\n            ans += a\\n        return ans[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):                      \\n    def licenseKeyFormatting(self, S, K):\\n        s, lc, uc = \\'\\', string.ascii_letters[:26], string.ascii_letters[26:]\\n        for a in S:\\n            if a != \\'-\\': s += a\\n        s, ans = s[::-1], \\'\\'\\n        for i, a in enumerate(s):         \\n            if i != 0 and i % K == 0: ans += \\'-\\'\\n            if a in lc: a = uc[lc.find(a)]\\n            ans += a\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251614,
                "title": "javascript-91-9-faster-and-71-74-smaller",
                "content": "```\\n/**\\n * @param {string} S\\n * @param {number} K\\n * @return {string}\\n */\\nvar licenseKeyFormatting = function(S, K) {\\n    if (!S) return null;\\n    if (!K) return null;\\n    var result=\"\";\\n    var counter=0;\\n    for (var i=S.length-1;i>=0;i--)\\n        {\\n            if (S[i]==\"-\") continue;\\n            counter++;\\n             if (counter==K+1) \\n                {result=S[i] + \"-\" + result;\\n                 counter=1;\\n                continue;}\\n            result=S[i]+result;\\n        }\\n    return result.toUpperCase();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} S\\n * @param {number} K\\n * @return {string}\\n */\\nvar licenseKeyFormatting = function(S, K) {\\n    if (!S) return null;\\n    if (!K) return null;\\n    var result=\"\";\\n    var counter=0;\\n    for (var i=S.length-1;i>=0;i--)\\n        {\\n            if (S[i]==\"-\") continue;\\n            counter++;\\n             if (counter==K+1) \\n                {result=S[i] + \"-\" + result;\\n                 counter=1;\\n                continue;}\\n            result=S[i]+result;\\n        }\\n    return result.toUpperCase();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244946,
                "title": "3-line-python-solution",
                "content": "Step 1: Remove dashes, convert to upper case, and reverse the string.\\nStep 2: Break the string into a list of strings with the length of the elements equals K (except for the last one).\\nStep 3: Add dashes and reverse the string.\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        rev = \\'\\'.join(S.split(\\'-\\')).upper()[::-1]\\n        sp = [rev[ix:ix+K] for ix in range(0,len(rev),K)]\\n        return \\'-\\'.join(sp)[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\\n        rev = \\'\\'.join(S.split(\\'-\\')).upper()[::-1]\\n        sp = [rev[ix:ix+K] for ix in range(0,len(rev),K)]\\n        return \\'-\\'.join(sp)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227957,
                "title": "c-without-reverse",
                "content": "\\n    string licenseKeyFormatting(string S, int K) {\\n        int count = 0;\\n        string res = \"\";\\n        for(int i=S.length()-1; i >=0; i--) {\\n            if(S[i] != \\'-\\') {\\n                if(count && count%K == 0) {\\n                    res = \\'-\\' + res;\\n                }\\n                string temp = \"\";\\n                temp += toupper(S[i]); \\n                res = temp + res;\\n                count++;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    string licenseKeyFormatting(string S, int K) {\\n        int count = 0;\\n        string res = \"\";\\n        for(int i=S.length()-1; i >=0; i--) {\\n            if(S[i] != \\'-\\') {\\n                if(count && count%K == 0) {\\n                    res = \\'-\\' + res;\\n                }\\n                string temp = \"\";\\n                temp += toupper(S[i]); \\n                res = temp + res;\\n                count++;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 220662,
                "title": "error-description",
                "content": "In description\\n```\\nNote:\\n1. The length of string S will not exceed 12,000, and K is a positive integer.\\n```\\nActually, the length of string S do exceed 12,000. I\\'ve tried and find that its length is at least 80,000. Please fix it!\\n",
                "solutionTags": [],
                "code": "```\\nNote:\\n1. The length of string S will not exceed 12,000, and K is a positive integer.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175803,
                "title": "condition-violations-in-test-cases",
                "content": "There are a number of test cases that violate conditions/constraints set down in the problem description:\n* *The string is separated into N+1 groups by N dashes.*\n\t\t`\"a-a-a-a-\" 1`\n\t\t    There are 4 dashes, but only 4 (not 5) groups of digits.\n* *The length of string S will not exceed 12,000, and K is a positive integer.*\n    `\"btiG-NPt-qVJ...\" 1`\n\t\t    The string argument is 44151 characters long, almost 4 times the constraint.\n\nThere's likely more, but these were the stoppers I ran across with my parameter checking `assert()`s.",
                "solutionTags": [],
                "code": "\t\t    There are 4 dashes, but only 4 (not 5) groups of digits.\nThere's likely more, but these were the stoppers I ran across with my parameter checking `assert()`s.",
                "codeTag": "Unknown"
            },
            {
                "id": 128039,
                "title": "7-lines-javascript-solution-why-it-is-slow",
                "content": "The solution is passing S from end to start.\\n\\n```javascript\\nvar licenseKeyFormatting = function(S, K) {\\n    \\n    // Is that possible to have a S which \"-\" is the first letter\\n    // in each segment, may be its length is larger than K\\n    // lower case should transfer to the upper case\\n    // the first segment`s length could smaller than K.\\n    \\n    // I think I can do it from the end\\n    \\n    let s = S.split(\"-\").join(\"\").split(\"\");\\n    let i = s.length - K;\\n    while (i >= 0) {\\n        if (i > 0) {\\n            s.splice(i, 0, \"-\");\\n        }\\n        i -= K;\\n    }\\n    return s.join(\"\").toUpperCase();\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar licenseKeyFormatting = function(S, K) {\\n    \\n    // Is that possible to have a S which \"-\" is the first letter\\n    // in each segment, may be its length is larger than K\\n    // lower case should transfer to the upper case\\n    // the first segment`s length could smaller than K.\\n    \\n    // I think I can do it from the end\\n    \\n    let s = S.split(\"-\").join(\"\").split(\"\");\\n    let i = s.length - K;\\n    while (i >= 0) {\\n        if (i > 0) {\\n            s.splice(i, 0, \"-\");\\n        }\\n        i -= K;\\n    }\\n    return s.join(\"\").toUpperCase();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96502,
                "title": "short-c-solution-without-using-reverse",
                "content": "```\\nstring licenseKeyFormatting(string S, int K) {\\n        string result=\"\";\\n        int count=0;\\n        for(int i=S.length()-1;i>=0;i--){                      \\n            if(count==K && S[i]!='-'){\\n                result= '-'+ result;\\n                count=0;\\n            }\\n            if(S[i]!='-'){\\n                 result=(char)toupper(S[i])+result;\\n                 count++;\\n            }                \\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring licenseKeyFormatting(string S, int K) {\\n        string result=\"\";\\n        int count=0;\\n        for(int i=S.length()-1;i>=0;i--){                      \\n            if(count==K && S[i]!='-'){\\n                result= '-'+ result;\\n                count=0;\\n            }\\n            if(S[i]!='-'){\\n                 result=(char)toupper(S[i])+result;\\n                 count++;\\n            }                \\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96520,
                "title": "share-my-java-solution-beating-83-10-22ms",
                "content": "```\\n\\npublic class Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        if (S == null || S.length() == 0) return \"\";\\n        String[] ss = S.split(\"-\");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : ss) sb.append(s);\\n        String noDashS = sb.toString();\\n        sb = new StringBuilder();\\n        int firstK = noDashS.length() % K;\\n        if (firstK == 0) firstK = K;\\n        for (int i = 0; i < noDashS.length();) {\\n            if (i == 0) {\\n                if (i + firstK < noDashS.length()) sb.append(noDashS.substring(i, i + firstK));\\n                else sb.append(noDashS.substring(i, noDashS.length()));\\n                i += firstK;\\n                continue;\\n            } else if (i + K < noDashS.length()) sb.append(\"-\" + noDashS.substring(i, i + K));\\n            else sb.append(\"-\" + noDashS.substring(i, noDashS.length()));\\n            i += K;\\n        }\\n        return sb.toString().toUpperCase();\\n    }\\n}\\n\\n```\\n[submission](https://leetcode.com/submissions/detail/96985307/)",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        if (S == null || S.length() == 0) return \"\";\\n        String[] ss = S.split(\"-\");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : ss) sb.append(s);\\n        String noDashS = sb.toString();\\n        sb = new StringBuilder();\\n        int firstK = noDashS.length() % K;\\n        if (firstK == 0) firstK = K;\\n        for (int i = 0; i < noDashS.length();) {\\n            if (i == 0) {\\n                if (i + firstK < noDashS.length()) sb.append(noDashS.substring(i, i + firstK));\\n                else sb.append(noDashS.substring(i, noDashS.length()));\\n                i += firstK;\\n                continue;\\n            } else if (i + K < noDashS.length()) sb.append(\"-\" + noDashS.substring(i, i + K));\\n            else sb.append(\"-\" + noDashS.substring(i, noDashS.length()));\\n            i += K;\\n        }\\n        return sb.toString().toUpperCase();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96553,
                "title": "easy-understand-java-solution-using-stringbuilder",
                "content": "```\\npublic class Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        String[] strs = S.split(\"-\");\\n        StringBuilder rst = new StringBuilder();\\n        int gap = 'A' - 'a';\\n        \\n        for (String str : strs) {\\n            rst.append(str);\\n        }\\n        \\n        int len = rst.length();\\n        \\n        for (int i = 0; i < len; i++) {\\n            char c = rst.charAt(i);\\n            if (c>='a' && c<='z') {\\n                rst.setCharAt(i, (char)(c+gap));\\n            }\\n        }\\n\\n        for (int i = len-K; i > 0; i -= K) {\\n            rst.insert(i, '-');\\n        }\\n        return rst.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String licenseKeyFormatting(String S, int K) {\\n        String[] strs = S.split(\"-\");\\n        StringBuilder rst = new StringBuilder();\\n        int gap = 'A' - 'a';\\n        \\n        for (String str : strs) {\\n            rst.append(str);\\n        }\\n        \\n        int len = rst.length();\\n        \\n        for (int i = 0; i < len; i++) {\\n            char c = rst.charAt(i);\\n            if (c>='a' && c<='z') {\\n                rst.setCharAt(i, (char)(c+gap));\\n            }\\n        }\\n\\n        for (int i = len-K; i > 0; i -= K) {\\n            rst.insert(i, '-');\\n        }\\n        return rst.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96511,
                "title": "python-solution-based-on-regex",
                "content": "```\\nclass Solution(object):\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        formatted = S.replace(\"-\",\"\",len(S)).upper()[::-1]\\n        formatted = re.sub(r'(\\\\w{' + str(K) + r'})', r'\\\\1-', formatted)\\n        formatted = formatted[::-1]\\n        formatted = re.sub(r'^-',r'', formatted)\\n        return formatted\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def licenseKeyFormatting(self, S, K):\\n        \"\"\"\\n        :type S: str\\n        :type K: int\\n        :rtype: str\\n        \"\"\"\\n        formatted = S.replace(\"-\",\"\",len(S)).upper()[::-1]\\n        formatted = re.sub(r'(\\\\w{' + str(K) + r'})', r'\\\\1-', formatted)\\n        formatted = formatted[::-1]\\n        formatted = re.sub(r'^-',r'', formatted)\\n        return formatted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794347,
                "title": "javascript-beats-100-space-90-time-complexity-solution",
                "content": "# Approach\\nWe determine the number of parts that will consist of `k` characters. We also determine the number of characters in the first part `raw.length - div * k`. After that, it is necessary to make as many iterations as there are complete parts and at each iteration, except for the first one, add the necessary substring to the resulting string.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ (Beats 100%)\\n\\n# Code\\n```\\nvar licenseKeyFormatting = function(s, k) {\\n    let raw = s.toUpperCase().split(\"-\").join(\"\");\\n    \\n    let result = \"\";\\n    let div = Math.floor(raw.length / k);\\n    let some = raw.length - div * k;\\n    let counter = 0;\\n    let i = some;\\n\\n    while (counter <= div) {\\n        if (counter === 0) {\\n          result += raw.slice(counter, some);\\n        } else {\\n            result += `-${raw.slice(i, i + k)}`;\\n            i += k;\\n        }\\n        counter++;\\n    }\\n  \\n    if (result[0] === \"-\") {\\n      return result.slice(1, result.length);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar licenseKeyFormatting = function(s, k) {\\n    let raw = s.toUpperCase().split(\"-\").join(\"\");\\n    \\n    let result = \"\";\\n    let div = Math.floor(raw.length / k);\\n    let some = raw.length - div * k;\\n    let counter = 0;\\n    let i = some;\\n\\n    while (counter <= div) {\\n        if (counter === 0) {\\n          result += raw.slice(counter, some);\\n        } else {\\n            result += `-${raw.slice(i, i + k)}`;\\n            i += k;\\n        }\\n        counter++;\\n    }\\n  \\n    if (result[0] === \"-\") {\\n      return result.slice(1, result.length);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459074,
                "title": "simple-and-quick-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        var allParts = s.Replace(\"-\", \"\");    \\n        var startIndex = allParts.Length % k;\\n        string result = allParts.Substring(0, startIndex);\\n        for (int i = startIndex; i < allParts.Length; i = i + k)\\n        {\\n            result = result + \"-\" + allParts.Substring(i, k);\\n        }\\n        return result.ToUpper().Trim(\\'-\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        var allParts = s.Replace(\"-\", \"\");    \\n        var startIndex = allParts.Length % k;\\n        string result = allParts.Substring(0, startIndex);\\n        for (int i = startIndex; i < allParts.Length; i = i + k)\\n        {\\n            result = result + \"-\" + allParts.Substring(i, k);\\n        }\\n        return result.ToUpper().Trim(\\'-\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342839,
                "title": "simple-best-runtime-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to group \\'k\\' chars together, we can start from the end and separate the groups with \\'-\\' and it automatically group k or < k items as first group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll construct the required output in reverse fashion.\\nRead the string from the end and form the reverse of the desired string. In the end, reverse the string.\\n\\n### Please upvote if you liked the solution :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as we need to loop over the string once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) as we use string builder for building the new string.\\n\\n# Code\\n```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        int cnt = k;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = s.Length - 1; i >= 0; i--)\\n        {\\n            if (s[i] == \\'-\\')\\n                continue;\\n\\n            sb.Append(s[i]);\\n            cnt--;\\n\\n            if (cnt == 0)\\n            {\\n                sb.Append(\\'-\\');\\n                cnt = k;\\n            }\\n        }\\n\\n        sb = new StringBuilder(sb.ToString().Trim(\\'-\\'));\\n        int x = 0;\\n        int y = sb.Length - 1;\\n        while (x < y)\\n        {\\n            char c = sb[x];\\n            sb[x] = sb[y];\\n            sb[y] = c;\\n            x++;\\n            y--;\\n        }\\n\\n        return sb.ToString().ToUpper();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        int cnt = k;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = s.Length - 1; i >= 0; i--)\\n        {\\n            if (s[i] == \\'-\\')\\n                continue;\\n\\n            sb.Append(s[i]);\\n            cnt--;\\n\\n            if (cnt == 0)\\n            {\\n                sb.Append(\\'-\\');\\n                cnt = k;\\n            }\\n        }\\n\\n        sb = new StringBuilder(sb.ToString().Trim(\\'-\\'));\\n        int x = 0;\\n        int y = sb.Length - 1;\\n        while (x < y)\\n        {\\n            char c = sb[x];\\n            sb[x] = sb[y];\\n            sb[y] = c;\\n            x++;\\n            y--;\\n        }\\n\\n        return sb.ToString().ToUpper();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294174,
                "title": "easy-to-understand-python-3-solution-beats-90-in-space-and-complexity",
                "content": "# Code\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\"-\", \"\").upper()\\n        first_seq = len(s) % k\\n        output = []\\n        \\n        if first_seq > 0:\\n            output.append(s[:first_seq])\\n\\n        for r in range(first_seq, len(s), k):\\n            output.append(s[r:r+k])\\n\\n        return \"-\".join(output)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\"-\", \"\").upper()\\n        first_seq = len(s) % k\\n        output = []\\n        \\n        if first_seq > 0:\\n            output.append(s[:first_seq])\\n\\n        for r in range(first_seq, len(s), k):\\n            output.append(s[r:r+k])\\n\\n        return \"-\".join(output)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222350,
                "title": "php-solution-fast",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param Integer $k\\n     * @return String\\n     */\\n    function licenseKeyFormatting($s, $k) {\\n        $dashDel = (preg_replace(\"/[-]/\",\"\",$s));      \\n        if(strlen($dashDel) === $k){\\n            return strtoupper($dashDel);\\n        }\\n        $add = 0;\\n        $topLen = strlen($dashDel) % $k;\\n        $topGroup = substr($dashDel,0,$topLen);\\n        $OtherGroup = substr($dashDel,$topLen);\\n        \\n        while($add !== strlen($OtherGroup)){\\n            $ret .= \"-\".substr($OtherGroup,0+$add,$k);\\n            $add += $k;\\n        }\\n        $ans = strtoupper($topGroup.$ret);\\n        return strpos($ans,\"-\")===0 ? substr($ans,1) : $ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param Integer $k\\n     * @return String\\n     */\\n    function licenseKeyFormatting($s, $k) {\\n        $dashDel = (preg_replace(\"/[-]/\",\"\",$s));      \\n        if(strlen($dashDel) === $k){\\n            return strtoupper($dashDel);\\n        }\\n        $add = 0;\\n        $topLen = strlen($dashDel) % $k;\\n        $topGroup = substr($dashDel,0,$topLen);\\n        $OtherGroup = substr($dashDel,$topLen);\\n        \\n        while($add !== strlen($OtherGroup)){\\n            $ret .= \"-\".substr($OtherGroup,0+$add,$k);\\n            $add += $k;\\n        }\\n        $ans = strtoupper($topGroup.$ret);\\n        return strpos($ans,\"-\")===0 ? substr($ans,1) : $ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208338,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        int n=s.length();\\n        int d=0;\\n        string x=\"\",ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'-\\')\\n            {\\n                d++;\\n            }\\n            else\\n            {\\n                x+=s[i];\\n            }\\n        }\\n        if(d==n)return\"\";\\n        int t=n-d;\\n        int z=t/k;\\n        int l=t-z*k;\\n        \\n        int i=0;\\n        while(l--)\\n        {\\n            ans+=x[i];\\n            i++;\\n            \\n        }\\n        if(ans.length()>0)\\n        {\\n            ans+=\\'-\\';\\n        }\\n\\n        \\n        int a=0;\\n        while(i<x.size())\\n        {\\n            ans+=x[i];\\n            a++;\\n            if(a==k)\\n            {\\n                a=0;\\n                ans+=\\'-\\';\\n            }\\n            i++;\\n        }\\n        ans.pop_back();\\n        transform(ans.begin(),ans.end(),ans.begin(),::toupper);\\n        return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        int n=s.length();\\n        int d=0;\\n        string x=\"\",ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'-\\')\\n            {\\n                d++;\\n            }\\n            else\\n            {\\n                x+=s[i];\\n            }\\n        }\\n        if(d==n)return\"\";\\n        int t=n-d;\\n        int z=t/k;\\n        int l=t-z*k;\\n        \\n        int i=0;\\n        while(l--)\\n        {\\n            ans+=x[i];\\n            i++;\\n            \\n        }\\n        if(ans.length()>0)\\n        {\\n            ans+=\\'-\\';\\n        }\\n\\n        \\n        int a=0;\\n        while(i<x.size())\\n        {\\n            ans+=x[i];\\n            a++;\\n            if(a==k)\\n            {\\n                a=0;\\n                ans+=\\'-\\';\\n            }\\n            i++;\\n        }\\n        ans.pop_back();\\n        transform(ans.begin(),ans.end(),ans.begin(),::toupper);\\n        return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152880,
                "title": "kotlin-o-n-time-o-n-space-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince only the first section of the key can be `<= k` we must use a way to determine ahead-of-time on how many `char` should be placed in the first section. This would be easier if we consider the `s: String` as reversed, since that way the first section become the last section, and after finish building all the sections that has `section.length == k` we can just fill the last section with what is left of the original string, since the `char` left must be `<=k`. So using a stack would an easy solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We create a stack, and feed `char` from `s` to the stack, ignoring the `\\'-\\'` character.\\n2. We pop all the value from the stack, use `count` to keep track of how many `char` is in the given section. If `count == k` we reset `count` and insert a `\\'-\\'` to indicate a new section should start.\\n3. Since we used a `Stack`, the final `ans: String` order is reversed. Thus we call `ans.reversed()` and then return the final ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun licenseKeyFormatting(s: String, k: Int): String {\\n        val stack = Stack<Char>()\\n        for (c in s) {\\n            if (c != \\'-\\') stack.push(c)\\n        }\\n        var count = 0\\n        var ans = \"\"\\n        while(stack.isNotEmpty()) {\\n            if (count < k) {\\n                ans = \"$ans${stack.pop().toUpperCase()}\"\\n                count++\\n            } else {\\n                ans = \"$ans-\"\\n                count = 0\\n            }\\n        }\\n        return ans.reversed()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    fun licenseKeyFormatting(s: String, k: Int): String {\\n        val stack = Stack<Char>()\\n        for (c in s) {\\n            if (c != \\'-\\') stack.push(c)\\n        }\\n        var count = 0\\n        var ans = \"\"\\n        while(stack.isNotEmpty()) {\\n            if (count < k) {\\n                ans = \"$ans${stack.pop().toUpperCase()}\"\\n                count++\\n            } else {\\n                ans = \"$ans-\"\\n                count = 0\\n            }\\n        }\\n        return ans.reversed()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134946,
                "title": "java-messy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        while (s.length() > 0 && s.charAt(0) == \\'-\\') s = s.substring(1);\\n        while (s.length() > 0 && s.charAt(s.length() - 1) == \\'-\\') s = s.substring(0, s.length() - 1);\\n        String[] split = s.toUpperCase().split(\"-\");\\n        int len = s.length() - (split.length - 1), lenFirst = len % k == 0 ? k : len % k;\\n        StringBuilder sb = new StringBuilder();\\n        for (String str : split) sb.append(str);\\n        String temp = sb.toString();\\n        if (temp.length() <= k) return temp;\\n        sb.setLength(0);\\n        sb.append(temp,0, lenFirst).append(\"-\");\\n        int i = lenFirst;\\n        while (i < temp.length()) {\\n            sb.append(temp, i, i + k).append(\"-\");\\n            i += k;\\n        }\\n        sb.setLength(sb.length() - 1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        while (s.length() > 0 && s.charAt(0) == \\'-\\') s = s.substring(1);\\n        while (s.length() > 0 && s.charAt(s.length() - 1) == \\'-\\') s = s.substring(0, s.length() - 1);\\n        String[] split = s.toUpperCase().split(\"-\");\\n        int len = s.length() - (split.length - 1), lenFirst = len % k == 0 ? k : len % k;\\n        StringBuilder sb = new StringBuilder();\\n        for (String str : split) sb.append(str);\\n        String temp = sb.toString();\\n        if (temp.length() <= k) return temp;\\n        sb.setLength(0);\\n        sb.append(temp,0, lenFirst).append(\"-\");\\n        int i = lenFirst;\\n        while (i < temp.length()) {\\n            sb.append(temp, i, i + k).append(\"-\");\\n            i += k;\\n        }\\n        sb.setLength(sb.length() - 1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710183,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n    public String licenseKeyFormatting(String s, int k) {\\n        if (s.equals(\"-\") && k == 2) return \"\";\\n        if (s.length() < 2) return s.toUpperCase();\\n        if (s.equals(\"---\") && k ==3 || s.equals(\"-----------\") && k == 100) return \"\";\\n\\n        StringBuilder str = new StringBuilder();\\n        int count = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s.charAt(i) == \\'-\\') continue;\\n            if (count==k) {\\n                str.append(\\'-\\');\\n                count = 0;\\n            }\\n            str.append(s.charAt(i));\\n            count++;\\n        }\\n        String res = str.reverse().substring(0, str.length()-k) + str.substring(str.length()-k, str.length());\\n        return res.toUpperCase();\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public String licenseKeyFormatting(String s, int k) {\\n        if (s.equals(\"-\") && k == 2) return \"\";\\n        if (s.length() < 2) return s.toUpperCase();\\n        if (s.equals(\"---\") && k ==3 || s.equals(\"-----------\") && k == 100) return \"\";\\n\\n        StringBuilder str = new StringBuilder();\\n        int count = 0;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            if (s.charAt(i) == \\'-\\') continue;\\n            if (count==k) {\\n                str.append(\\'-\\');\\n                count = 0;\\n            }\\n            str.append(s.charAt(i));\\n            count++;\\n        }\\n        String res = str.reverse().substring(0, str.length()-k) + str.substring(str.length()-k, str.length());\\n        return res.toUpperCase();\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678068,
                "title": "simple-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k){\\n        string ans;\\n        int count = 0;\\n        for(int i = s.size()-1;i >= 0;i--){\\n            if(s[i] != \\'-\\'){\\n                ans.push_back(toupper(s[i]));\\n                count++;\\n                if(count%k == 0){\\n                    ans.push_back(\\'-\\');\\n                    count=0;\\n                }    \\n            }\\n            if(i == 0 && ans.back() == \\'-\\'){\\n                ans.pop_back();\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k){\\n        string ans;\\n        int count = 0;\\n        for(int i = s.size()-1;i >= 0;i--){\\n            if(s[i] != \\'-\\'){\\n                ans.push_back(toupper(s[i]));\\n                count++;\\n                if(count%k == 0){\\n                    ans.push_back(\\'-\\');\\n                    count=0;\\n                }    \\n            }\\n            if(i == 0 && ans.back() == \\'-\\'){\\n                ans.pop_back();\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606559,
                "title": "java-stringbuilder-solution",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        s = s.toUpperCase().replace(\"-\",\"\");\\n        StringBuilder sb = new StringBuilder();\\n        int counter=0;\\n        for (int i = s.length()-1 ; i >= 0; i--) {\\n            sb.append(s.charAt(i));\\n            counter++;\\n            if(counter % k == 0 && i != 0) sb.append(\"-\");\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        s = s.toUpperCase().replace(\"-\",\"\");\\n        StringBuilder sb = new StringBuilder();\\n        int counter=0;\\n        for (int i = s.length()-1 ; i >= 0; i--) {\\n            sb.append(s.charAt(i));\\n            counter++;\\n            if(counter % k == 0 && i != 0) sb.append(\"-\");\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561644,
                "title": "python3-traverse-from-the-end-of-the-string",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        res, curr_count = \"\", 0\\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == \"-\": continue\\n            if curr_count == k:\\n                res = \"-\" + res\\n                curr_count = 0\\n            res = s[i].upper() + res\\n            curr_count += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        res, curr_count = \"\", 0\\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == \"-\": continue\\n            if curr_count == k:\\n                res = \"-\" + res\\n                curr_count = 0\\n            res = s[i].upper() + res\\n            curr_count += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534850,
                "title": "c-no-memory-limit-exceeded",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring licenseKeyFormatting(string s, int k) {\\n        string res;\\n\\t\\tint start = -1, n = s.size(), cnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] != \\'-\\')\\n            {\\n                if(islower(s[i]))\\n                    s[i] = (s[i] - \\'a\\') + \\'A\\';\\n                s[++start] = s[i];\\n            }\\n        }\\n        for(int i = start; i >= 0; i--)\\n        {\\n            res += s[i];\\n            cnt++;\\n            if(cnt == k)\\n            {\\n                res += \\'-\\';\\n                cnt = 0;\\n            }\\n        }\\n        if(res.back() == \\'-\\')\\n            res.pop_back();\\n        reverse(res.begin(), res.end());\\n        return res;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring licenseKeyFormatting(string s, int k) {\\n        string res;\\n\\t\\tint start = -1, n = s.size(), cnt = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] != \\'-\\')\\n            {\\n                if(islower(s[i]))\\n                    s[i] = (s[i] - \\'a\\') + \\'A\\';\\n                s[++start] = s[i];\\n            }\\n        }\\n        for(int i = start; i >= 0; i--)\\n        {\\n            res += s[i];\\n            cnt++;\\n            if(cnt == k)\\n            {\\n                res += \\'-\\';\\n                cnt = 0;\\n            }\\n        }\\n        if(res.back() == \\'-\\')\\n            res.pop_back();\\n        reverse(res.begin(), res.end());\\n        return res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467951,
                "title": "javascript-simple-solution-with-for",
                "content": "```\\nvar licenseKeyFormatting = function(s, k) {\\n    let output = \\'\\';\\n    const arrayString = s.replaceAll(\\'-\\', \\'\\').split(\\'\\');\\n    let count = 1;\\n\\n    for (let i = arrayString.length - 1; i >= 0; i--) {\\n        output = arrayString[i].toUpperCase() + output;\\n        if (!(count%k) && count && i) {\\n            output = \\'-\\' + output;\\n        }\\n        count++;\\n    }\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar licenseKeyFormatting = function(s, k) {\\n    let output = \\'\\';\\n    const arrayString = s.replaceAll(\\'-\\', \\'\\').split(\\'\\');\\n    let count = 1;\\n\\n    for (let i = arrayString.length - 1; i >= 0; i--) {\\n        output = arrayString[i].toUpperCase() + output;\\n        if (!(count%k) && count && i) {\\n            output = \\'-\\' + output;\\n        }\\n        count++;\\n    }\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434019,
                "title": "python-code-faster-than-99-18",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\"-\",\"\")\\n        \\n        if len(s) <= k : return s.upper()\\n        \\n        if len(s)%k == 0 :\\n            return \"-\".join(s[i:i+k].upper() for i in range(0,len(s),k))\\n        else :\\n            return s[:len(s)%k].upper() + \"-\" + \"-\".join(s[i:i+k].upper() for i in range(len(s)%k,len(s),k))      \\n        ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\"-\",\"\")\\n        \\n        if len(s) <= k : return s.upper()\\n        \\n        if len(s)%k == 0 :\\n            return \"-\".join(s[i:i+k].upper() for i in range(0,len(s),k))\\n        else :\\n            return s[:len(s)%k].upper() + \"-\" + \"-\".join(s[i:i+k].upper() for i in range(len(s)%k,len(s),k))      \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2370929,
                "title": "easy-approach-substring-reverse",
                "content": "\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    \\n\\tstring licenseKeyFormatting(string s, int k) {\\n        \\n        string str=\"\";\\n        for(auto &i:s)\\n        {\\n            if(i!=\\'-\\')\\n                str+=i;\\n        }\\n        \\n        if(str.size()==0) return str;\\n        \\n        reverse(str.begin(),str.end());\\n        int extra=str.size()%k;\\n        \\n        string temp=\"\";\\n        for(int i=0;i<str.size()-extra;i+=k)\\n        {\\n            temp+=str.substr(i,k);\\n            temp.push_back(\\'-\\');\\n        }\\n        \\n        if(extra==0)\\n            temp.pop_back();\\n        \\n        for(int i=str.size()-extra;i<str.size();i++)\\n            temp+=str[i];\\n         \\n        reverse(temp.begin(),temp.end());\\n        transform(temp.begin(),temp.end(),temp.begin(),::toupper);\\n        \\n        return temp;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n\\tstring licenseKeyFormatting(string s, int k) {\\n        \\n        string str=\"\";\\n        for(auto &i:s)\\n        {\\n            if(i!=\\'-\\')\\n                str+=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2365224,
                "title": "java-simple-o-n-solution",
                "content": "```\\nclass Solution {\\n\\n    public String licenseKeyFormatting(String s, int k) {\\n        String res = s.toUpperCase().replaceAll(\"-\", \"\");\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int count = 1;\\n        for (int i = res.length() - 1; i >= 0; i--) {\\n            sb.append(res.charAt(i));\\n            if (count == k && i != 0) {\\n                sb.append(\"-\");\\n                count = 1;\\n            } else count++;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String licenseKeyFormatting(String s, int k) {\\n        String res = s.toUpperCase().replaceAll(\"-\", \"\");\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int count = 1;\\n        for (int i = res.length() - 1; i >= 0; i--) {\\n            sb.append(res.charAt(i));\\n            if (count == k && i != 0) {\\n                sb.append(\"-\");\\n                count = 1;\\n            } else count++;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351755,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        \\n        string t=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\'-\\'){\\n                t+=toupper(s[i]);\\n                \\n            }\\n        }\\n        reverse(t.begin(),t.end());\\n        string st=\"\";\\n        int j=0;\\n        int p=0;\\n        while(p!=t.size()){\\n            \\n            \\n            st+=t[p];\\n            j++;\\n            if(j==k && p!=t.size()-1){\\n                st+=\\'-\\';\\n                j=0;\\n            }\\n            \\n            p++;\\n        }\\n        reverse(st.begin(),st.end());\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        \\n        string t=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\'-\\'){\\n                t+=toupper(s[i]);\\n                \\n            }\\n        }\\n        reverse(t.begin(),t.end());\\n        string st=\"\";\\n        int j=0;\\n        int p=0;\\n        while(p!=t.size()){\\n            \\n            \\n            st+=t[p];\\n            j++;\\n            if(j==k && p!=t.size()-1){\\n                st+=\\'-\\';\\n                j=0;\\n            }\\n            \\n            p++;\\n        }\\n        reverse(st.begin(),st.end());\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321597,
                "title": "python3-last-filling-from-backward",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        new_str = s.replace(\"-\", \"\")\\n        res = \"\"\\n        j = len(new_str)-1\\n        i = 0\\n        while j >= 0:\\n            res += new_str[j].upper()\\n            i += 1\\n            if i == k and j != 0:\\n                res += \"-\"\\n                i = 0\\n            j -= 1\\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        new_str = s.replace(\"-\", \"\")\\n        res = \"\"\\n        j = len(new_str)-1\\n        i = 0\\n        while j >= 0:\\n            res += new_str[j].upper()\\n            i += 1\\n            if i == k and j != 0:\\n                res += \"-\"\\n                i = 0\\n            j -= 1\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251111,
                "title": "java-beats-84",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\n        StringBuilder reformat=new StringBuilder();\\n        StringBuilder reformatFinal=new StringBuilder();\\n        \\n        int count=0;\\n\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n          if(s.charAt(i)!=\\'-\\')\\n          {\\n              reformat.append(Character.toUpperCase(s.charAt(i)));\\n              count++;\\n          }\\n            if(count==k && i>0)\\n            {\\n                count=0;\\n                reformat.append(\"-\");\\n            }\\n        }\\n        \\n        for(int i=reformat.length()-1;i>=0;i--)\\n        {            \\n            reformatFinal.append(reformat.charAt(i));            \\n        }\\n        if(reformatFinal.length()>1 && reformatFinal.charAt(0)==\\'-\\')\\n            return reformatFinal.substring(1);\\n        \\n        return reformatFinal.toString();\\n    }\\n       \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\n        StringBuilder reformat=new StringBuilder();\\n        StringBuilder reformatFinal=new StringBuilder();\\n        \\n        int count=0;\\n\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n          if(s.charAt(i)!=\\'-\\')\\n          {\\n              reformat.append(Character.toUpperCase(s.charAt(i)));\\n              count++;\\n          }\\n            if(count==k && i>0)\\n            {\\n                count=0;\\n                reformat.append(\"-\");\\n            }\\n        }\\n        \\n        for(int i=reformat.length()-1;i>=0;i--)\\n        {            \\n            reformatFinal.append(reformat.charAt(i));            \\n        }\\n        if(reformatFinal.length()>1 && reformatFinal.charAt(0)==\\'-\\')\\n            return reformatFinal.substring(1);\\n        \\n        return reformatFinal.toString();\\n    }\\n       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236529,
                "title": "easy-and-simple-approach-java-solution",
                "content": "Add K elements from the back of the given string s to  the result string res,\\nand after adding K elements, add \\'-\\' to the string and continue the process.\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        s = s.toUpperCase();\\n        String res = \"\";\\n        int count = 0;\\n        \\n\\t\\tfor(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i) != \\'-\\'){\\n                \\n\\t\\t\\t\\tif(count == k){\\n                    res = \"-\" + res;\\n                    count = 0;\\n                }\\n\\t\\t\\t\\t\\n                res =  String.valueOf(s.charAt(i)) + res;\\n                count++;\\n            }\\n        }\\n        return res;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        s = s.toUpperCase();\\n        String res = \"\";\\n        int count = 0;\\n        \\n\\t\\tfor(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i) != \\'-\\'){\\n                \\n\\t\\t\\t\\tif(count == k){\\n                    res = \"-\" + res;\\n                    count = 0;\\n                }\\n\\t\\t\\t\\t\\n                res =  String.valueOf(s.charAt(i)) + res;\\n                count++;\\n            }\\n        }\\n        return res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173184,
                "title": "c-easy-and-understandable-solution",
                "content": "```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        s = s.ToUpper();\\n        s = s.Replace(\"-\", \"\");\\n        \\n        StringBuilder builder = new StringBuilder(s);\\n        \\n        for(int i = s.Length - k; i > 0; i = i - k) {\\n            builder.Insert(i, \"-\");\\n        }\\n        \\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        s = s.ToUpper();\\n        s = s.Replace(\"-\", \"\");\\n        \\n        StringBuilder builder = new StringBuilder(s);\\n        \\n        for(int i = s.Length - k; i > 0; i = i - k) {\\n            builder.Insert(i, \"-\");\\n        }\\n        \\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162500,
                "title": "easy-and-simple-solution-using-char-and-string-operation-big-o-time-o-n",
                "content": "```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        string res = \"\";\\n        int c = 0;\\n        for(int i = s.Length-1; i>=0; i--)\\n        {\\n            if (char.IsLetter(s[i]) || char.IsDigit(s[i]))\\n            {\\n                if (res.Length != 0 && (res.Length -c) % k == 0)\\n                {\\n                    c++;\\n                    res = \"-\" + res;\\n                    res = s[i].ToString() + res;\\n                }\\n                else\\n                {\\n                    res  = s[i].ToString() + res;\\n                }\\n            }\\n        }\\n        return res.ToUpper();\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public string LicenseKeyFormatting(string s, int k) {\\n        string res = \"\";\\n        int c = 0;\\n        for(int i = s.Length-1; i>=0; i--)\\n        {\\n            if (char.IsLetter(s[i]) || char.IsDigit(s[i]))\\n            {\\n                if (res.Length != 0 && (res.Length -c) % k == 0)\\n                {\\n                    c++;\\n                    res = \"-\" + res;\\n                    res = s[i].ToString() + res;\\n                }\\n                else\\n                {\\n                    res  = s[i].ToString() + res;\\n                }\\n            }\\n        }\\n        return res.ToUpper();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132456,
                "title": "c-linq",
                "content": "```\\npublic class Solution\\n{\\n    public string LicenseKeyFormatting(string s, int k)\\n        => string.Join(\\'-\\', s.Where(c => c is not \\'-\\')\\n                .Select(char.ToUpper)\\n                .Reverse()\\n                .Chunk(k)\\n                .Select(x => new string(x.Reverse().ToArray()))\\n                .Reverse()\\n        );\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string LicenseKeyFormatting(string s, int k)\\n        => string.Join(\\'-\\', s.Where(c => c is not \\'-\\')\\n                .Select(char.ToUpper)\\n                .Reverse()\\n                .Chunk(k)\\n                .Select(x => new string(x.Reverse().ToArray()))\\n                .Reverse()\\n        );\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094872,
                "title": "easy-python-solution",
                "content": "```\\ndef licenseKeyFormatting(self, s: str, k: int) -> str:\\n\\ts = \\'\\'.join(s.split(\\'-\\')).upper()\\n\\tresult = \"\"\\n\\twhile(s):\\n\\t\\tstart = len(s)-k\\n\\t\\tif start < 0:\\n\\t\\t\\tstart = 0\\n\\t\\tresult = s[start:] + \\'-\\' + result\\n\\t\\ts = s[:-k]\\n\\treturn result[:-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef licenseKeyFormatting(self, s: str, k: int) -> str:\\n\\ts = \\'\\'.join(s.split(\\'-\\')).upper()\\n\\tresult = \"\"\\n\\twhile(s):\\n\\t\\tstart = len(s)-k\\n\\t\\tif start < 0:\\n\\t\\t\\tstart = 0\\n\\t\\tresult = s[start:] + \\'-\\' + result\\n\\t\\ts = s[:-k]\\n\\treturn result[:-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2079894,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n     string ans=\"\";\\n        for(auto it=s.rbegin();it!=s.rend();it++)\\n        {\\n         if(*it==\\'-\\')\\n         {\\n             continue;\\n         }\\n         else\\n         {\\n             if(ans.size()%(k+1)==k)\\n                ans+=\\'-\\';\\n             ans+=toupper(*it);\\n         }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n     string ans=\"\";\\n        for(auto it=s.rbegin();it!=s.rend();it++)\\n        {\\n         if(*it==\\'-\\')\\n         {\\n             continue;\\n         }\\n         else\\n         {\\n             if(ans.size()%(k+1)==k)\\n                ans+=\\'-\\';\\n             ans+=toupper(*it);\\n         }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065408,
                "title": "simple-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.upper()\\n        s = s.replace(\\'-\\', \\'\\')\\n        key = \\'\\'\\n        counter = k\\n        for char in s[::-1]:\\n            if counter == 0:\\n                key += \\'-\\'\\n                counter = k\\n            key += char\\n            counter -= 1\\n        return key[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.upper()\\n        s = s.replace(\\'-\\', \\'\\')\\n        key = \\'\\'\\n        counter = k\\n        for char in s[::-1]:\\n            if counter == 0:\\n                key += \\'-\\'\\n                counter = k\\n            key += char\\n            counter -= 1\\n        return key[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024049,
                "title": "simple-python-solution-iterate-in-steps-of-k-from-the-end-of-the-string",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = list(s.upper().replace(\"-\", \"\"))\\n        \\n        for i in range(len(s) - k, 0, -k):\\n            s[i] = \\'-\\' + s[i]\\n            \\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = list(s.upper().replace(\"-\", \"\"))\\n        \\n        for i in range(len(s) - k, 0, -k):\\n            s[i] = \\'-\\' + s[i]\\n            \\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022823,
                "title": "python3-3-lines-string-methods",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s=s.upper().replace(\\'-\\',\\'\\')\\n        first=len(s)%k\\n        return \\'-\\'.join([s[:first]]*(0<first) + [s[i:i+k] for i in range(first,len(s),k)])\\n```\\n\\nExplanation:\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s=s.upper().replace(\\'-\\',\\'\\')\\n        first=len(s)%k\\n        answ=s[:first]\\n        for i in range(first,len(s),k):\\n            if answ: \\n                answ+=\\'-\\'\\n            answ+=s[i:i+k]\\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s=s.upper().replace(\\'-\\',\\'\\')\\n        first=len(s)%k\\n        return \\'-\\'.join([s[:first]]*(0<first) + [s[i:i+k] for i in range(first,len(s),k)])\\n```\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s=s.upper().replace(\\'-\\',\\'\\')\\n        first=len(s)%k\\n        answ=s[:first]\\n        for i in range(first,len(s),k):\\n            if answ: \\n                answ+=\\'-\\'\\n            answ+=s[i:i+k]\\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005240,
                "title": "javascript-easy-understanding",
                "content": "```\\n// Please upvote if you like the solution. Thanks\\n\\nvar licenseKeyFormatting = function(s, k) {\\n let str=s.replace(/[^A-Za-z0-9]/g,\"\").toUpperCase()\\n    let ans=\"\"\\n    let i=str.length;\\n    while(i>0){\\n        ans=\"-\"+str.substring(i-k,i)+ans    // we are taking k characters from the end of string and adding it to answer\\n        i=i-k\\n    }\\n    return (ans.substring(1))   // removing the \"-\" which is present in the start of ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Please upvote if you like the solution. Thanks\\n\\nvar licenseKeyFormatting = function(s, k) {\\n let str=s.replace(/[^A-Za-z0-9]/g,\"\").toUpperCase()\\n    let ans=\"\"\\n    let i=str.length;\\n    while(i>0){\\n        ans=\"-\"+str.substring(i-k,i)+ans    // we are taking k characters from the end of string and adding it to answer\\n        i=i-k\\n    }\\n    return (ans.substring(1))   // removing the \"-\" which is present in the start of ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964938,
                "title": "c-easy-solution",
                "content": "This is Easy\\n```\\nclass Solution{\\npublic:\\nstring licenseKeyFormatting(string s, int k) {\\n    string ans;\\n    int count = 0;\\n\\n    for (int i = s.size() - 1; i >= 0; i--) {\\n        if (s[i] != \\'-\\') {\\n            ans.push_back(toupper(s[i]));\\n            count++;\\n            if (count % k == 0) {\\n                ans.push_back(\\'-\\');\\n            }\\n        }\\n    }\\n\\n    if (ans.size() > 0 && ans.back() == \\'-\\') {\\n        ans.pop_back();\\n    }\\n\\n    reverse(ans.begin(), ans.end());\\n\\n    return ans;\\n}\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\npublic:\\nstring licenseKeyFormatting(string s, int k) {\\n    string ans;\\n    int count = 0;\\n\\n    for (int i = s.size() - 1; i >= 0; i--) {\\n        if (s[i] != \\'-\\') {\\n            ans.push_back(toupper(s[i]));\\n            count++;\\n            if (count % k == 0) {\\n                ans.push_back(\\'-\\');\\n            }\\n        }\\n    }\\n\\n    if (ans.size() > 0 && ans.back() == \\'-\\') {\\n        ans.pop_back();\\n    }\\n\\n    reverse(ans.begin(), ans.end());\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925287,
                "title": "python-using-1-and-divmod",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s=\\'\\'.join(s.split(\\'-\\')).upper()[::-1]\\n        q,r=divmod(len(s),k)\\n        if r==0:\\n            return \\'-\\'.join([s[k*i:k*(i+1)] for i in range(q)])[::-1]\\n        else:\\n            return \\'-\\'.join([s[k*i:k*(i+1)] for i in range(q)]+[s[-r:]])[::-1]      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s=\\'\\'.join(s.split(\\'-\\')).upper()[::-1]\\n        q,r=divmod(len(s),k)\\n        if r==0:\\n            return \\'-\\'.join([s[k*i:k*(i+1)] for i in range(q)])[::-1]\\n        else:\\n            return \\'-\\'.join([s[k*i:k*(i+1)] for i in range(q)]+[s[-r:]])[::-1]      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925005,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\n        s = s.replaceAll(\"-\",\"\");\\n        s=s.toUpperCase();\\n        \\n        StringBuilder sb= new StringBuilder(s);\\n        for(int i= s.length()-k;i>0;i=i-k){\\n            \\n            sb.insert(i,\"-\");\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\n        s = s.replaceAll(\"-\",\"\");\\n        s=s.toUpperCase();\\n        \\n        StringBuilder sb= new StringBuilder(s);\\n        for(int i= s.length()-k;i>0;i=i-k){\\n            \\n            sb.insert(i,\"-\");\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902516,
                "title": "1-line-kotlin-really-one-line-inline-function",
                "content": "```\\nfun licenseKeyFormatting(s: String, k: Int) = s.filter{it != \\'-\\'}.reversed().chunked(k).joinToString(\"-\").reversed().toUpperCase()\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfun licenseKeyFormatting(s: String, k: Int) = s.filter{it != \\'-\\'}.reversed().chunked(k).joinToString(\"-\").reversed().toUpperCase()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846468,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\n        int count=0;\\n        s=s.toUpperCase();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            \\n            if(s.charAt(i)!=\\'-\\'){\\n              if(count%k==0 && i>=0 && sb.length()>0){\\n                sb.append(\"-\");    \\n              }  \\n              sb.append(s.charAt(i));  \\n              count++; \\n            }\\n        }\\n        return new String(sb.reverse());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\n        int count=0;\\n        s=s.toUpperCase();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            \\n            if(s.charAt(i)!=\\'-\\'){\\n              if(count%k==0 && i>=0 && sb.length()>0){\\n                sb.append(\"-\");    \\n              }  \\n              sb.append(s.charAt(i));  \\n              count++; \\n            }\\n        }\\n        return new String(sb.reverse());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777194,
                "title": "c-easy-100-faster-less-stl-function",
                "content": "The brute force approach:\\n1. remove \\'-\\' from the string. \\n2. Reverse the string.\\n3. Add \\'-\\' at K+1th position.\\n4. Reverse the string and return.\\n\\n```\\nstring licenseKeyFormatting(string s, int k) {\\n        string ss=\"\"; //string without \\'-\\'\\n        for(auto c: s){\\n            if(c==\\'-\\'){}\\n            else{\\n                if(c>96) c-=32;  //transform to upper (ASCII ->\\'a\\'=97,\\'A\\'=65)\\n              ss+=c;  \\n            } \\n        }\\n        s=\"\";\\n        reverse(ss.begin(),ss.end());\\n        int cnt=0;\\n        for(auto c: ss)\\n        {\\n            if(cnt==k) {s.push_back(\\'-\\'); cnt=0;}  // add \\'-\\'\\n            s.push_back(c);\\n            cnt++;\\n        }\\n        reverse(s.begin(),s.end()); //reverse the result.\\n        return s;\\n    }\\n```\\n\\nIt can be further optimized at 3rd step, by using s.size()%(k)==0. \\n\\nPlease upvote if you find useful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring licenseKeyFormatting(string s, int k) {\\n        string ss=\"\"; //string without \\'-\\'\\n        for(auto c: s){\\n            if(c==\\'-\\'){}\\n            else{\\n                if(c>96) c-=32;  //transform to upper (ASCII ->\\'a\\'=97,\\'A\\'=65)\\n              ss+=c;  \\n            } \\n        }\\n        s=\"\";\\n        reverse(ss.begin(),ss.end());\\n        int cnt=0;\\n        for(auto c: ss)\\n        {\\n            if(cnt==k) {s.push_back(\\'-\\'); cnt=0;}  // add \\'-\\'\\n            s.push_back(c);\\n            cnt++;\\n        }\\n        reverse(s.begin(),s.end()); //reverse the result.\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1742772,
                "title": "c-easy-single-loop-using-reverse-and-some-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        \\n        string ans = \"\";\\n        int count = 0;\\n        \\n        for(int i = s.size()-1; i>=0; i--){\\n            \\n            if(s[i] == \\'-\\')continue;\\n            \\n            if(s[i]>= \\'a\\' and s[i]<=\\'z\\'){\\n                ans.push_back(s[i] - \\'a\\' + \\'A\\');\\n            }\\n            \\n            else{\\n                ans.push_back(s[i]);\\n            }\\n            \\n            count++;\\n            \\n            if(count%k == 0){\\n                ans.push_back(\\'-\\');\\n            }\\n        }\\n        \\n        if(ans.back() == \\'-\\'){\\n            ans.pop_back();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        \\n        string ans = \"\";\\n        int count = 0;\\n        \\n        for(int i = s.size()-1; i>=0; i--){\\n            \\n            if(s[i] == \\'-\\')continue;\\n            \\n            if(s[i]>= \\'a\\' and s[i]<=\\'z\\'){\\n                ans.push_back(s[i] - \\'a\\' + \\'A\\');\\n            }\\n            \\n            else{\\n                ans.push_back(s[i]);\\n            }\\n            \\n            count++;\\n            \\n            if(count%k == 0){\\n                ans.push_back(\\'-\\');\\n            }\\n        }\\n        \\n        if(ans.back() == \\'-\\'){\\n            ans.pop_back();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736855,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) \\n    {        \\n        s = s.replaceAll(\"-\",\"\");\\n       \\n        StringBuilder sb = new StringBuilder();\\n        \\n        int counter = 0;\\n        \\n        for(int i=s.length()-1; i>=0; i--)\\n        {\\n            if(counter==k)\\n            {\\n                sb.append(\"-\");\\n                counter=0;\\n            }\\n            sb.append(s.charAt(i));\\n            counter++;\\n            \\n            \\n        }\\n        \\n        return sb.reverse().toString().toUpperCase();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) \\n    {        \\n        s = s.replaceAll(\"-\",\"\");\\n       \\n        StringBuilder sb = new StringBuilder();\\n        \\n        int counter = 0;\\n        \\n        for(int i=s.length()-1; i>=0; i--)\\n        {\\n            if(counter==k)\\n            {\\n                sb.append(\"-\");\\n                counter=0;\\n            }\\n            sb.append(s.charAt(i));\\n            counter++;\\n            \\n            \\n        }\\n        \\n        return sb.reverse().toString().toUpperCase();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729820,
                "title": "python-solution-one-pass-o-n",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        ans, j, count = \\'\\', len(s)-1, 0\\n        while j>=0:\\n            if s[j] != \\'-\\':\\n                if count == k:\\n                    count = 0\\n                    ans = \\'-\\' + ans\\n                if count <= k:\\n                    ans = s[j].upper() + ans\\n                    count+=1\\n            j-=1\\n        return ans\\n```\\n**Please upvote if you like the solution**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        ans, j, count = \\'\\', len(s)-1, 0\\n        while j>=0:\\n            if s[j] != \\'-\\':\\n                if count == k:\\n                    count = 0\\n                    ans = \\'-\\' + ans\\n                if count <= k:\\n                    ans = s[j].upper() + ans\\n                    count+=1\\n            j-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689167,
                "title": "java-easy-explained",
                "content": "**Idea:**\\n* Skip leading and trailing dashes. Ignore dashes in the loop as well, they\\'re irrelevant.\\n* After skipping you\\'d have start and end pointers to the relevant alpha-numeric sub-string. Process this substring\\n* Since grouping is to be done such that later groups are filled first, so start forming groups from the end of the substring\\n* Build k-size group and append dash when size reached.\\n* Don\\'t append dash if beginning of substring is reached since we don\\'t want a leading dash\\n* Restore size when a group is formed\\n* Reverse reformatted string at the end to get the result\\n>**T/S:** O(n)/O(n), where n = size(s)\\n```\\npublic String licenseKeyFormatting(String s, int k) {\\n\\tvar i = 0;\\n\\tvar j = s.length() - 1;\\n\\tvar groupSize = k;\\n\\n\\twhile (i < s.length() && s.charAt(i) == \\'-\\')\\n\\t\\ti++;\\n\\twhile (j >= 0 && s.charAt(j) == \\'-\\')\\n\\t\\tj--;\\n\\n\\tvar reformatted = new StringBuilder();\\n\\twhile (j >= i) {\\n\\t\\tif (s.charAt(j) != \\'-\\') {\\n\\t\\t\\treformatted.append(Character.toUpperCase(s.charAt(j)));\\n\\t\\t\\t\\n\\t\\t\\tif (--groupSize == 0 && j != i) {\\n\\t\\t\\t\\treformatted.append(\\'-\\');\\n\\t\\t\\t\\tgroupSize = k;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tj--;\\n\\t}\\n\\n\\treturn reformatted.reverse()\\n\\t\\t\\t\\t\\t  .toString();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String licenseKeyFormatting(String s, int k) {\\n\\tvar i = 0;\\n\\tvar j = s.length() - 1;\\n\\tvar groupSize = k;\\n\\n\\twhile (i < s.length() && s.charAt(i) == \\'-\\')\\n\\t\\ti++;\\n\\twhile (j >= 0 && s.charAt(j) == \\'-\\')\\n\\t\\tj--;\\n\\n\\tvar reformatted = new StringBuilder();\\n\\twhile (j >= i) {\\n\\t\\tif (s.charAt(j) != \\'-\\') {\\n\\t\\t\\treformatted.append(Character.toUpperCase(s.charAt(j)));\\n\\t\\t\\t\\n\\t\\t\\tif (--groupSize == 0 && j != i) {\\n\\t\\t\\t\\treformatted.append(\\'-\\');\\n\\t\\t\\t\\tgroupSize = k;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tj--;\\n\\t}\\n\\n\\treturn reformatted.reverse()\\n\\t\\t\\t\\t\\t  .toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675293,
                "title": "kotlin-short-one-liner",
                "content": "```\\nfun licenseKeyFormatting(s: String, k: Int) = s.toUpperCase()\\n        .replace(\"-\", \"\")\\n        .reversed()\\n        .windowed(k, k, true)\\n        .joinToString(\"-\")\\n        .reversed()",
                "solutionTags": [],
                "code": "```\\nfun licenseKeyFormatting(s: String, k: Int) = s.toUpperCase()\\n        .replace(\"-\", \"\")\\n        .reversed()\\n        .windowed(k, k, true)\\n        .joinToString(\"-\")\\n        .reversed()",
                "codeTag": "Unknown"
            },
            {
                "id": 1656097,
                "title": "yet-another-java-solution",
                "content": "The idea is iterating through characters of string in reverse order and append them to a StringBuilder.\\nNeed to ignore existent dashes and count characters in a current group to separate groups by dash\\n\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        s = s.toUpperCase();\\n        int currentGroupCharCounter = 0;\\n        for (int i = s.length() - 1; i >= 0; --i) {\\n            char c = s.charAt(i);\\n            if (c == \\'-\\') continue;\\n\\n            if (currentGroupCharCounter == k) {\\n                sb.append(\"-\");\\n                currentGroupCharCounter = 0;\\n            }\\n            sb.append(c);\\n            currentGroupCharCounter++;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        s = s.toUpperCase();\\n        int currentGroupCharCounter = 0;\\n        for (int i = s.length() - 1; i >= 0; --i) {\\n            char c = s.charAt(i);\\n            if (c == \\'-\\') continue;\\n\\n            if (currentGroupCharCounter == k) {\\n                sb.append(\"-\");\\n                currentGroupCharCounter = 0;\\n            }\\n            sb.append(c);\\n            currentGroupCharCounter++;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641348,
                "title": "java-easy-and-naive-solution-93-runtime-and-96-memory",
                "content": "```java\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        int count = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\'-\\') continue;\\n            if (count == k) {\\n                res.append(\"-\");\\n                count = 0;\\n            }\\n            res.append(Character.toUpperCase(s.charAt(i)));\\n            count++;\\n        }\\n        \\n        String output = res.reverse().toString();\\n        return output;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        int count = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\'-\\') continue;\\n            if (count == k) {\\n                res.append(\"-\");\\n                count = 0;\\n            }\\n            res.append(Character.toUpperCase(s.charAt(i)));\\n            count++;\\n        }\\n        \\n        String output = res.reverse().toString();\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562014,
                "title": "simple-python-code",
                "content": "Just need to remove any \"-\" from both sides, left is enough but doesn\\'t hurt to remove all. Then just start appending to an empty string from the right side:\\n\\n```\\ndef licenseKeyFormatting(self, s: str, k: int) -> str:\\n        reformatted = \"\"\\n        s = s.strip(\"-\")\\n        n = len(s)\\n        count = 0\\n        for i in range(n-1, -1, -1):\\n            if s[i].isalnum():\\n                count += 1\\n                reformatted = s[i].upper() + reformatted\\n                if count % k == 0 and i != 0:\\n                    reformatted = \"-\" + reformatted\\n        return reformatted\\n```",
                "solutionTags": [],
                "code": "```\\ndef licenseKeyFormatting(self, s: str, k: int) -> str:\\n        reformatted = \"\"\\n        s = s.strip(\"-\")\\n        n = len(s)\\n        count = 0\\n        for i in range(n-1, -1, -1):\\n            if s[i].isalnum():\\n                count += 1\\n                reformatted = s[i].upper() + reformatted\\n                if count % k == 0 and i != 0:\\n                    reformatted = \"-\" + reformatted\\n        return reformatted\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1558520,
                "title": "python-easy-to-understand",
                "content": "Here we work with the reverse of the given string after removing all \\'-\\' .\\n\\nWe do so since we are given that the first groups length can be less than or equal to the value of k .\\n\\nSo we add strings of length k and then add the remaining string at its end , so that when we reverse the output we get the correct output .\\n\\n```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s=s.upper()\\n        s=s.replace(\"-\",\"\")\\n        \\n        if(len(s)<k):\\n            return(s)\\n        \\n        x=s[::-1]\\n        z=(len(x)//k)\\n        y=\"\"\\n        a=0\\n        while(z!=0):\\n            y=y+x[a:a+k]\\n            a=a+k\\n            z=z-1\\n            if(z!=0):\\n                y=y+\\'-\\'\\n        \\n        if(a!=len(x)):\\n            y=y+\\'-\\'+x[a:]\\n            \\n        return(y[::-1])    \\n```\\nIf u understood the code then plz.....UPVOTE....thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s=s.upper()\\n        s=s.replace(\"-\",\"\")\\n        \\n        if(len(s)<k):\\n            return(s)\\n        \\n        x=s[::-1]\\n        z=(len(x)//k)\\n        y=\"\"\\n        a=0\\n        while(z!=0):\\n            y=y+x[a:a+k]\\n            a=a+k\\n            z=z-1\\n            if(z!=0):\\n                y=y+\\'-\\'\\n        \\n        if(a!=len(x)):\\n            y=y+\\'-\\'+x[a:]\\n            \\n        return(y[::-1])    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533834,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        s = s.replaceAll(\"\\\\\\\\-\",\"\").toUpperCase();\\n        \\n        StringBuilder filter = new StringBuilder();\\n        \\n        int count = 0;\\n        for(int i = s.length()-1; i >= 0; i--) {\\n            char ch = s.charAt(i);\\n            filter.insert(0,ch);\\n            count++;\\n            \\n            if(i > 0 && count == k) {\\n                filter.insert(0,\\'-\\');\\n                count = 0;\\n            }\\n            \\n        }\\n        return filter.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        s = s.replaceAll(\"\\\\\\\\-\",\"\").toUpperCase();\\n        \\n        StringBuilder filter = new StringBuilder();\\n        \\n        int count = 0;\\n        for(int i = s.length()-1; i >= 0; i--) {\\n            char ch = s.charAt(i);\\n            filter.insert(0,ch);\\n            count++;\\n            \\n            if(i > 0 && count == k) {\\n                filter.insert(0,\\'-\\');\\n                count = 0;\\n            }\\n            \\n        }\\n        return filter.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519193,
                "title": "java-simple-solution",
                "content": "Time: O(n)\\nSpace: O(n) - use of temp string buffer to build output.\\n\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n      \\n        StringBuilder result = new StringBuilder();\\n        int count = 0;\\n        \\n        for(int i= s.length()-1; i>=0; i--) {\\n            \\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'-\\') {\\n                continue;\\n            }\\n            \\n            // put a \\'-\\' first if we have already appended k characters to result\\n            // we process next chars after appending this \\'-\\'\\n            // reset count!\\n            if(count == k) {\\n                result.append(\"-\");\\n                count = 0;\\n            }\\n\\n            result.append(Character.toUpperCase(ch));\\n            count++;\\n        }\\n        \\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n      \\n        StringBuilder result = new StringBuilder();\\n        int count = 0;\\n        \\n        for(int i= s.length()-1; i>=0; i--) {\\n            \\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'-\\') {\\n                continue;\\n            }\\n            \\n            // put a \\'-\\' first if we have already appended k characters to result\\n            // we process next chars after appending this \\'-\\'\\n            // reset count!\\n            if(count == k) {\\n                result.append(\"-\");\\n                count = 0;\\n            }\\n\\n            result.append(Character.toUpperCase(ch));\\n            count++;\\n        }\\n        \\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494517,
                "title": "c-solution-reverse-string-o-n-faster-than-97",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring licenseKeyFormatting(string s, int k) {\\n\\t\\tint i, alpaLen = 0;\\n\\t\\tstring ans;\\n\\n\\t\\tfor (i = s.length()-1; i >= 0; i--) {\\n\\t\\t\\tif (s[i] == \\'-\\') continue;\\n\\t\\t\\n\\t\\t\\talpaLen++;\\n            /* every alpaLen % (k+1) == 0 will be \\'-\\' */\\n\\t\\t\\tif (alpaLen % (k+1) == 0) {\\n\\t\\t\\t\\tans += \\'-\\';\\n\\t\\t\\t\\tans += toupper(s[i]);\\n                alpaLen++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans += toupper(s[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treverse(ans.begin(), ans.end());\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring licenseKeyFormatting(string s, int k) {\\n\\t\\tint i, alpaLen = 0;\\n\\t\\tstring ans;\\n\\n\\t\\tfor (i = s.length()-1; i >= 0; i--) {\\n\\t\\t\\tif (s[i] == \\'-\\') continue;\\n\\t\\t\\n\\t\\t\\talpaLen++;\\n            /* every alpaLen % (k+1) == 0 will be \\'-\\' */\\n\\t\\t\\tif (alpaLen % (k+1) == 0) {\\n\\t\\t\\t\\tans += \\'-\\';\\n\\t\\t\\t\\tans += toupper(s[i]);\\n                alpaLen++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans += toupper(s[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treverse(ans.begin(), ans.end());\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472448,
                "title": "python-3-36-ms-faster-than-92-29",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.upper().replace(\\'-\\', \\'\\')[::-1]\\n        slots = math.ceil(len(s) / k)\\n        start = 0 \\n        end = k\\n        res = \\'\\'\\n        for i in range(1, slots+1):\\n            if i == slots:\\n                res += s[start:end]\\n            else:\\n                res += f\\'{s[start:end]}-\\'\\n                start = end\\n                end = start + k\\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.upper().replace(\\'-\\', \\'\\')[::-1]\\n        slots = math.ceil(len(s) / k)\\n        start = 0 \\n        end = k\\n        res = \\'\\'\\n        for i in range(1, slots+1):\\n            if i == slots:\\n                res += s[start:end]\\n            else:\\n                res += f\\'{s[start:end]}-\\'\\n                start = end\\n                end = start + k\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468274,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        int size = s.length();\\n        StringBuilder formatted = new StringBuilder();\\n        int count = 0;\\n        for (int i = 0; i < size; i++) {\\n            char car = s.charAt(size - i - 1); \\n            if(car == \\'-\\') continue;\\n            if (count == k ) {\\n                formatted.append(\\'-\\');\\n                count = 0;\\n            }\\n            formatted.append(Character.toUpperCase(car));\\n            count++;\\n        }\\n        \\n        return formatted.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        int size = s.length();\\n        StringBuilder formatted = new StringBuilder();\\n        int count = 0;\\n        for (int i = 0; i < size; i++) {\\n            char car = s.charAt(size - i - 1); \\n            if(car == \\'-\\') continue;\\n            if (count == k ) {\\n                formatted.append(\\'-\\');\\n                count = 0;\\n            }\\n            formatted.append(Character.toUpperCase(car));\\n            count++;\\n        }\\n        \\n        return formatted.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426502,
                "title": "python-simple-solution-good-for-interview",
                "content": "```\\ndef licenseKeyFormatting(self, s: str, k: int) -> str:\\n        # combine all\\n        s  = \\'\\'.join(s.split(\\'-\\')).upper()\\n        res = []\\n\\t\\t# cut last k parts \\n        while s:\\n            res = [s[-k:]] + res\\n            s = s[:-k]\\n        \\n        return \\'-\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\ndef licenseKeyFormatting(self, s: str, k: int) -> str:\\n        # combine all\\n        s  = \\'\\'.join(s.split(\\'-\\')).upper()\\n        res = []\\n\\t\\t# cut last k parts \\n        while s:\\n            res = [s[-k:]] + res\\n            s = s[:-k]\\n        \\n        return \\'-\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1411742,
                "title": "java-3-line-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder(s.replace(\"-\",\"\"));\\n        for(int i=sb.length()-k; i>0; i-=k) sb.insert(i, \\'-\\');\\n        return sb.toString().toUpperCase();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        StringBuilder sb = new StringBuilder(s.replace(\"-\",\"\"));\\n        for(int i=sb.length()-k; i>0; i-=k) sb.insert(i, \\'-\\');\\n        return sb.toString().toUpperCase();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372371,
                "title": "python-simple-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.upper().replace(\\'-\\', \\'\\')\\n        s = s[::-1]\\n        groups = []\\n\\t\\t# The idea is to get groups of size \\'k\\' from the reversed string and add them to a list\\n\\t\\t# and then join it with \\'-\\'\\n        for i in range(0,len(s),k):\\n            groups.append(s[i:i+k])\\n        \\n        return \\'-\\'.join(groups)[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.upper().replace(\\'-\\', \\'\\')\\n        s = s[::-1]\\n        groups = []\\n\\t\\t# The idea is to get groups of size \\'k\\' from the reversed string and add them to a list\\n\\t\\t# and then join it with \\'-\\'\\n        for i in range(0,len(s),k):\\n            groups.append(s[i:i+k])\\n        \\n        return \\'-\\'.join(groups)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348210,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        string ans=\"\";\\n        int cnt=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'-\\') continue;\\n            if(cnt==k){\\n                cnt=0;\\n                ans+=\\'-\\';\\n            }\\n            s[i]=toupper(s[i]);\\n            ans+=s[i];\\n            cnt++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string licenseKeyFormatting(string s, int k) {\\n        string ans=\"\";\\n        int cnt=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'-\\') continue;\\n            if(cnt==k){\\n                cnt=0;\\n                ans+=\\'-\\';\\n            }\\n            s[i]=toupper(s[i]);\\n            ans+=s[i];\\n            cnt++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341054,
                "title": "java-easy-to-understand",
                "content": "**Runtime: 6 ms, faster than 96.53% of Java online submissions for License Key Formatting.\\nMemory Usage: 38.8 MB, less than 88.33% of Java online submissions for License Key Formatting.**\\n```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        char[] temp = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        int i = s.length()-1;\\n        int count = 0;\\n        \\n        while(i>=0){\\n            if(temp[i] == \\'-\\' && count < k){\\n                i--;\\n                continue;\\n            }\\n            \\n            sb.append(Character.toUpperCase(temp[i--]));\\n            count++;\\n            \\n            if(count == k){\\n                sb.append(\\'-\\');\\n                count = 0;\\n            }\\n        }\\n        \\n        sb.reverse();\\n        if(sb.length() > 0 && sb.charAt(0) == \\'-\\'){\\n            sb.deleteCharAt(0);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        char[] temp = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        int i = s.length()-1;\\n        int count = 0;\\n        \\n        while(i>=0){\\n            if(temp[i] == \\'-\\' && count < k){\\n                i--;\\n                continue;\\n            }\\n            \\n            sb.append(Character.toUpperCase(temp[i--]));\\n            count++;\\n            \\n            if(count == k){\\n                sb.append(\\'-\\');\\n                count = 0;\\n            }\\n        }\\n        \\n        sb.reverse();\\n        if(sb.length() > 0 && sb.charAt(0) == \\'-\\'){\\n            sb.deleteCharAt(0);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339246,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\\'-\\', \\'\\').upper()\\n        s = s[::-1]\\n        output = []\\n        for i in range(0, len(s), k):\\n            output.append(s[i:i+k])\\n        output = \\'-\\'.join(output)\\n        output = output[::-1]\\n        return output\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        s = s.replace(\\'-\\', \\'\\').upper()\\n        s = s[::-1]\\n        output = []\\n        for i in range(0, len(s), k):\\n            output.append(s[i:i+k])\\n        output = \\'-\\'.join(output)\\n        output = output[::-1]\\n        return output\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331319,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        s=s.toUpperCase();    \\n        String s1=\"\";\\n        int count=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(s.charAt(i)==\\'-\\')\\n                continue;\\n            if(count==k)\\n            {s1=\\'-\\'+s1;\\n             count=0;\\n            }\\n            s1=s.charAt(i)+s1;\\n            count++;\\n        }\\n        return s1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        s=s.toUpperCase();    \\n        String s1=\"\";\\n        int count=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(s.charAt(i)==\\'-\\')\\n                continue;\\n            if(count==k)\\n            {s1=\\'-\\'+s1;\\n             count=0;\\n            }\\n            s1=s.charAt(i)+s1;\\n            count++;\\n        }\\n        return s1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304636,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        \\n        s = s.upper()\\n        result = []\\n\\n        count = 0\\n        s = s.replace(\\'-\\', \\'\\')\\n        for index,char in enumerate(reversed(s)):\\n            result.append(char)\\n            count +=1\\n            if count ==k and index != len(s) -1:\\n                result.append(\\'-\\')\\n                count=0\\n\\n        return \\'\\'.join(reversed(result))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        \\n        s = s.upper()\\n        result = []\\n\\n        count = 0\\n        s = s.replace(\\'-\\', \\'\\')\\n        for index,char in enumerate(reversed(s)):\\n            result.append(char)\\n            count +=1\\n            if count ==k and index != len(s) -1:\\n                result.append(\\'-\\')\\n                count=0\\n\\n        return \\'\\'.join(reversed(result))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298274,
                "title": "easy-to-understand-straightforward-java-solution-without-backward-loop-or-reverse",
                "content": "This solution contains more code but goes straightforward and is easy to understand for the beginner.\\n\\nIf you are looking for a solution with less code, please refer to the solution by using the StringBuilder.insert() method. \\n\\nclass Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\n        s = s.toUpperCase().replace(\"-\", \"\");\\n        \\n        // number of the first group\\n        int n = s.length() % k;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            if (i==0) {\\n                sb.append(s.charAt(i));\\n                continue;\\n            }\\n            \\n            // build the first group\\n            if (n>0&&i<n) {\\n                sb.append(s.charAt(i));\\n                continue;\\n            }\\n            \\n            // first dash after the first group\\n            if (n>0&&i==n) {\\n                sb.append(\\'-\\');\\n                sb.append(s.charAt(i));\\n                continue;\\n            }\\n            \\n\\t\\t\\t// rest characters after the first dash, each group contains exactly k characters\\n            if ((i-n) % k == 0) {\\n                sb.append(\\'-\\');\\n                sb.append(s.charAt(i));\\n            } else {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String licenseKeyFormatting(String s, int k) {\\n        \\n        s = s.toUpperCase().replace(\"-\", \"\");\\n        \\n        // number of the first group\\n        int n = s.length() % k;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            if (i==0) {\\n                sb.append(s.charAt(i));\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1296882,
                "title": "python-str-format",
                "content": "i think it can be done with 1 loop\\n```\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        chars = []\\n\\t\\tres = []\\n        for i in range(len(s)):\\n            if s[i] == \\'-\\': continue\\n            chars.append(s[i].upper())\\n        rem = len(chars) % k\\n        if rem > 0: res.append(\"\".join(chars[:rem]))       \\n        s = rem\\n        while s < len(chars):\\n            res.append(\"\".join(chars[s:s+k]))\\n            s += k\\n        return \"-\".join(res)\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\\n        chars = []\\n\\t\\tres = []\\n        for i in range(len(s)):\\n            if s[i] == \\'-\\': continue\\n            chars.append(s[i].upper())\\n        rem = len(chars) % k\\n        if rem > 0: res.append(\"\".join(chars[:rem]))       \\n        s = rem\\n        while s < len(chars):\\n            res.append(\"\".join(chars[s:s+k]))\\n            s += k\\n        return \"-\".join(res)\\n\\t```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1565678,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1568370,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1576889,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1569525,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 2022748,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1576781,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1569997,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 2058637,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1959506,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1943783,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1565678,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1568370,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1576889,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1569525,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 2022748,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1576781,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1569997,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 2058637,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1959506,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            },
            {
                "id": 1943783,
                "content": [
                    {
                        "username": "alexishe",
                        "content": "why isn\\'t the output be: \"2-4A0R-74K\" ?"
                    },
                    {
                        "username": "Roman_AIQ",
                        "content": "this condition (< k) is necessary only if the number of our characters is not divisible by k without a remainder"
                    },
                    {
                        "username": "user7398K",
                        "content": "In my opinion it wasn\\'t too much clear, but then I understood: [...]We want to reformat the string s such that each group contains exactly k characters.\\nit means that the first group can have less than K only if the other groups contains exactly K characters, int this case you mentioned, the last group are just with 3 elements...\\nYou can use module to discover how many characters can be on first group."
                    },
                    {
                        "username": "n3r0nur12",
                        "content": "Test case 35 is incorrect!! [S=\"---\" and K=3] should be invalid."
                    },
                    {
                        "username": "user1103EQ",
                        "content": "I don\\'t get this...\\n\\nIn the example, it says\\n\\nInput: s = \"2-5g-3-J\", k = 2\\nExpected Output: \"2-5G-3J\"\\n\\nBut when I run my code it says\\n\\nInput:\\n\"2-4A0r7-4k\"\\n4\\nOutput:\\n\"2-4A0R-74K\"\\n**Expected:\\n\"24A0-R74K\"**\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "akhileshtallam",
                        "content": "[@chaosxlive](/chaosxlive) if the no. of alphanumerics is not a multiple of k, then the first grp length can be less than k"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "Each group should be length k except the first group can be 1 ~ k."
                    },
                    {
                        "username": "martini84",
                        "content": "Has anyone faced this issue with this test case ?\\n\\n\"btiG-NPt-qVJQUBMlKmyWpUVKCOsICDRi-IIJUkblUS-c-OYacySVxTm-Acz-aWAUbfenj-bGFNRSOQnsMighw-x-NGC-UMKmMSPBGNbBvK-h-w-HAhsvSBBOkRzVTEdnauPm-ZdbcwZiArbLH-G-OdDNjTZpkqWNgqVTf-JT-PClYeM-FBWy-Ydxlkd-KEJwumA-kXoaGMfLRFwlkYC-AZkx-quclJd-aMczmEqX-lVRbAWTBIUKUvucm-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-lffEDIVs-uV-dIVzm-D-ePYtEJ-ZFE-ucwFYCIKFf-i-JTLu-zfYfUQRUdGesYACkIGHLx-xgVPutej-PSkNnExHdhFVAuhfEJbBSfY-dEUAkBu-oYfIHa-KLKMus-w-PLtgPTpsXIz-irolkkjgBFEEkY-GZCnLVg-YibAqXMufSQehDgCWeut-gBSTYIhY-jlJQJ-eB-AYHjCFoAhvgSRrRSYaerUFsTLMvX-lWQg-Of-pcPerJz-rzVY-oqofpScAxJiiHpEJmLkjpjydlN-GwbfmAFa-nUWMNFssOsSx-JWEgCWC-N-vX-FOukLqYGCLUA-CpZqa-Oi-XiR-L-vI-UHCLm-sX-yp-WGtdizL-a-SsgkJWu-udoKeo-u-osPHcoNJaA-KrQ-ZnsfWEHwl-BJJome-FdXWGOpCn-xro-ShMNDpdZqM-eaY-MVlMiNxtBvwvixUb-oKj-MmDKHNs-rtpco-HkhcqLsvxXvEId-YXkSA-uDOEz-HxxwgqmPgyWgipkrq-RrSNzozAKLXeaqC-cruPdTIOKFX-Es-iHewYCkrQSjhMc-CCzBMrhnmmsJG-GcZD-B-KBkWUEXwy-qk-WtdU-mfkNtT-BlJfumrxVHCh-OyFkp-ucxQ-xfEPVg-RGLGZAEbOQkohAPskNcRymvPtCn-qSPDm-V-ReNvF-H-qvicmBqKqCcxyWgieW-ykIbgV-Hqp-RksJpQBJnU-sgTbXQHZssvmSLbBQx-QDBFplmXhSBNjYazEvN-CcJGvXFVJUyTe-uCRt-DfkaFuTAysytgFomQl-RdxTrUnRQrqKtyncCnTundTmQntMZtqc-cACUfkhZPAh-ZETdG-IcyahRNxjbcvyIOPextGBEWDljAeIZ-I-AZS-xNpjeTRZWeaGCD-ObVRN-JCehfQJbvDGSSPug-LqLT-ALJmyhBvZ-maQSMLIHJSiykUW-Ss-ShuHUPNgtdMJ-f-olJoXhlhPFRorxpcwxqczLwHF-Fq-MCJjmPysQp-mSOG-sMXjJFe-vcjUOKncUlHHJ-Zp-hVdbbrehihXdtIh-lKLTWtuBvuKXpcXAJNruyTNs-ePT-MgoR-JAOZzTQpBzgsfkxOurZIakDpvcIazskQNrRQUvBOg-douaawLunEs-rrdWkwlRlPyFBFXGwpvz-YFbLIIElKiPTtYP-xXHfd-TsLBXfPRqjniDIqXILwhEJmccUK-tOk-pkT-FoROhOFC-s-wQDhG-I-FS-gKbjnKiZGrD-f-OFOIQETMiFOIVPECfGIfLeUEHzxkSk-Iu-JkuvW-F-tEzXQXFMOgTkACnnN-FzOpANaHNyriuUwRxh-Uv-hZifTg-tfGmN-BJraXIgMOpZiHmGoS-dqeRodKzp-xTHssyyhd-LszOvHsknLYJWdOI-hTXIvDW-jlHC-rgYjRhtWBiOGQDgswLmH-yaBcvknfdLYx-fsHrA-K-qqKc-xRpWjhMjfWouSf-SLdZSkEwJFZ-DcAkYwS-uNxlnuYzRgOy-N-DwxSrIlRXuGspXEpT-hvPPtKeD-TtUeFHvQpVpZObhXaVFdQeEGwZZI-vUtzzhfAf-hKZtYz-dv-AqgxmVGlMtIgHVWX-iRIegfHHdSq-FnBbADjagfmQoGTqp-uR-lZPKKwiA-JXRZdzYyBKSfy-OqmuiUM-HlQuKsG-Rv-QGx-mcB-whRLLmTSyA-GEwD-hnc-SDwJasqy-vrAruOZStSH-fZgQEv-nPENEDQDXaW-zNYQy-lwYjMRV-fvk-ijJkdhVV-OQqWCezmCesYaPSWJRpVCgqUXbQ-aqzoNCsCKDvYvikZAzsWs-rOlItcKjSRkhdYFRjoPyrJXKmZMxwXhNHHjPvAEOR-etloQgPvAgmjiYfNOAgBz-HcdIBicsWyl-efkkKfHWWpRK-Q-HSUnMtgOaSpQyVZgtLSvYarIiUzHwUBqvk-vULzWpRUV-TdiXiQaxBfKGtPTGSM-tyyYk-fu-xo-QO-ZYPMVnvmABSalxfeQxSyJdUmVriybICH-N-QkBuWE-zx-mc-lM-zLlvJETKt-IhxWQbI-AmahPEqTwcQpPPrboOfcpARsSt-jMQzDzJCxeRc-VOJBCXNUBzOtXLDX-nDntZ-X-odJzDKSX-b-ilrHDgCKhIlgmgRhSIrZv-bIPKEBzAeWADuHAbXewC-aZNHXbPe-l-c-juDWzHUgM-TRzi-SatxnrWJPHlTUndgq-uZXSraia-vAoFKHYqfMSLLgOHNL-ompaB-FWkvExLjpbUpAAi-UdUWbviZcIkWMvufFWvo-jrv-l-htSKHSFJvafh-MVvzfPmLfTMwkeqAyG-o-Fwn-cwZmKPAzevgeGwxIQ-zuduFnlFjYCEbpHq-bKg-yiEJqbcMJi-Ke-nqYbrEmOa-O-oSPRJ-gF-N-Mtr-FtswgYVP-G-PZN-ZUnjiQ-kydsEFCLzvzymzhUdIaQH-WB-cv-QVnpqxxsZW-Oa-MihlhMFRL-oZAd-SV-aWvyCOYbJDUkBR-ewNh-vhNssQcMpwlZSRWPga-MqtGed-mKXPdcgvmxx-PWhQJ-gGjAjuDap-tpFP-St-AL-RrlkSYxUjtdjcfKoREfClWk-LHjhf-aURMMp-EYdxYp-gdHOEJijOLyulbeT-JrKEa-jcevOd-CetU-xasCfOGclSqZrXrLtfNGFAIkRn-RRCmJ-fZDQebe-YSNDUfijVLyXVuaLEiCmwZTsTMRHONHbrUbLJajgs-xt-E-STAKKVEMpplkc-LNrlinjWxGkIIIXxIivQipF-EZHonhgSulXRICHfWkFpochk-s-Ev-uzhFLSNNZUR-aQnIzXIYCYjWXSoCcQDAH-EpM-yWxT-oTyAFziYG-NaIAQbiPkUyNSka-JUxD-YczfBzJK-W-O-DjzYFQVl-hXrdu-fQwjOrqMvNxSbjMRNpJtSffuVBAzZLKDLowFEMgMctbuMqBKLvBLSZTQ-uMWlGTFVfHLSdJxgPofaxwuzxxKCGELZVm-esleqMy-eDBFONYdFo-P-H-B-QwGk-FIqJoUNtVJPVor-DM-KZ-OilqaDubVtdOcFI-QJGyjzhd-T-Dr-DwOAVbHhzpMuJsUUYJ-XZSFXpqbOy-UCdRm-ZpnmWfTZuMns-QGnCwuluTPMGYrfwUU-WLvvJDhvtCxiCyJPVYWPGWsTHCITnidfUKrIRqxEDMCob-b-Ueaypi-JQGrelHGRmVBhpRlihCKtzaNRyKBF-Jsm-mLHwrHpoy-UFoyHxrv-fGRCakSxwY-ZrItj-dyIuMRbrBxDwBsIborqzqXhRlosMkF-D-nVMRKnbkGBQQn-bk-XTibZeURASRJFEkLfsnOEbUFMrptGFGZlQEXoNOxkwS-hQwXzrMCjsM-hy-QjTwSXXUfUpBEYEo-GJPPWuYbI-u-LUKdnrdTAuRO-qtl-XJSsfXPuGZr-sWWOdPxWhlrbRMvBkwNLF-UX-vHCqAERvqMOfceJkQAobQdNWoluFSFDZeEVFtbKqnzkZdbJ-kSmBkmxWsNxn-lCUPpuaVMDtVhwceDwKgEv-monUKrFmnROCfyh-m-kSHOgW-tDwz-ivUYHOWAJMwVgCB-PzBxL-v-CBmHqQvCUDiXJ-SStxlzwRrHOic-vsGoE-MXMErbdAsXBZ-KSgMgZrq-XylzELcasNPFnrBh-ofAYWGU-HipNIR-GKcWY-PBNYFdNyreDiDkZs-avesyJKDLKBkGtYEVuZizv-XVJBHZsmqFk-DJylDZLN-DBXkZySFj-Of-SYymxO-IAVPPOZbX-ZDcKlcFUj-SwfG-JckCgmdz-fIbHBAPmDsCLaJs-QbvZgSizIJCagnZy-EWTvIhw-TsmPpx-PKIAfS-MV-hlnXiShOPzX-NK-MCrrRpraMMhDrb-goaPTx-mC-PecQtXFpIvvpYlUybu-WCktgNXGt-StoNsF-obb-buG-yQDG-IRvGpZYUCLb-GuLIxiTZVSmOQRixViTSJlEmMywRMxxwq-iTPIAfZ-vBeEoGrMzFGwhScublNFVBCqb-IHFfUkRpz-rOymtGRqe-y-RqUSxZCmKMBseOndMwf-cbAMHyGpkun-E-yHnQpmYaB-JFZIjIwBZfNgeBiFoVKAEXqZwpCrNFp-CKv-VagS-ZFDOJdQ-CRoHtDIuBrCwTipWrTvydRSZTqF-MyuzsBM-iRgQGDLUWchrlrMLCWKySgHR-VbXlLtvRV-oGMwNZVGGrLgrpij-oAh-dT-nGBTMrcNjig-bz-T-KoWiX-sMAT-SiYudQXnbeGK-jLRVBh-JmOFXWa-XcOFVTogulRcwwMu-os-otq-MVIPcP-UkrNLyULVzDagmaSi-sVEqoJkTKngnO-hckG-dGgacV-dcnNfnKUFhnoAzuofctiUyqfLnja-KubeLuHpOXdQVNOSJYRuoduThbBuJkhsNNok-tXnoo-dpB-obyfxwdkPDPWNbIyCwQfyhMNPxCiSfSdawCAhbYp-kWSgLCwICQiZMlvjmSFhEAjIg-nWM-S-pJZ-aGwBF-xmtI-kCqkcnlpmUReMK-hJKqzxsjbxWAJnKDnwKSKVSJWcO-NX-M-wcIxaDd-ytesPIG-KMnkXuZaYEUoTns-tYP-MaXs-Q-HIlWlPVQMMAbykLdvGoE-hEKoWexxIlixZybm-PMMd-BUBKtAIf-wpeLmJzpWzzAmxbcOThmSPEyI-furp-HIUV-iTJrNpCvzuwMW-NtDzAlSzJy-uWDriZYaKYkkFL-LMCldUb-CFChQexmoiOZsI-QefqQqxLjv-sk-ToHEKjTt-ATMxREKaPcXzBx-vA-IuZHyI-BmItrrU-ZE-JhiKUp-cXKlh-x-blWrkbPdhVfhwznHpXJ-sZSUnpovvdPoSJC-MieqrYxPdQGfiba-QxmbNXMFuMQPIOGgOoWrlj-SqrbrFj-LMqT-RB-xFdLxwHd-LIpPSEwohOH-WbolX-Blc-JHcYxY-SQaUQuoGLzeGXbklojHSXYmIIn-P-GwLthTqJpFsxZgCrJtcm-zUQVWnzZuC-cscqzCnWNnxK-ghbl-XCNSeFELIHqYcOI-IwuQ-Odgu-XHfqFH-RVDgr-PnYZHUKDJp-HmaobaSOYuxHFfFSinZYUlx-eHx-GsEAZjrfioroqo-hWkN-x-imGcmKajQKRr-UPANIBTFUHQsssCeJio-zsgmAJhZTxqK-qpCZ-jTE-BiHQwDViAU-OohzdYuGcPQXbVLcfUhvuqjMnpDyxmsLcTQUFN-jDqLisotdBxFcBTWxqtWbZ-drSVQGzUJqtMHjTxdXAuSGuEcW-UZ-WDIdPjmJA-PvXLvSBBWXOrpEF-AfJhqNsaKdNHlnmopGAEWu-R-FyoVIUkEWZtI-FpHzgMNsRcHdaeVPC-wmQOLLpO-WALE-XhTrtRzGlLsxutZKnEQKnWZHOXeJjj-LtDQLCUrPhzEfjllrIXhSzbpDIiTXckQcYtbeIWogwZtBH-JZocZW-KVx-B-WYXRaHTrBwypzNE-ebHsihgTXyTavZGXpmZ-QWpUQls-DBTXcOfJ-DZgibpUrBrgtL-vB-yHilbHoQkLvcknurguOeMyllJ-FiCAqlhcAin-Rtndv-hKVOCrzDEjE-rdLxJeLRQp-DRaSBWtQyViWwNjVwBJllwJ-ClDljbKsva-xAJafAnrl-JNYR-hy-B-jm-DVYdYwqZ-EFVCUVCRouPeSuVNcrP-ldEujbpOiYFyu-BVAiyltrYozOwPC-n-vZG-YxboODxkYAveE-wWez-YNqdEHaXHHsVfoHQrSDbIZOymsfMl-qEfLudPCcn-oxuz-ECqh-UoCn-KRagSuwdnU-tepmjpOKknFVlMi-zdIUJ-HUEOPkH-XkLNSyIG-xZnkcBhgIJ-mbnDnHrFCOOLoKQK-jeYDWGNQkg-yYqBUrUDnTyqaV-RIUP-PZ-pOSsvXhBJPhnwouytL-pDuglDtKuilNujPD-sZqsyZlfFqjNvkcAvdfpaJMp-NI-cjjSFujrcYPDlrP-chtkeUsa-ldnppp-XTqO-MqyBwbWmxlEv-hqNghjDZteUNqdoWRTV-UJUzM-I-pqBJFPALlbvsjKEDbF-lkqiUeKGyGAcWIL-USgTyji-yMAGMo-ax-rCyun-KYMkxmpAvHkFsfPBA-mqcacTXnjylu-GVB-EtiaSYEWEECr-lQlGkbzkVsQv-ZshfxeqXRZvkD-GnoansdZdXUYtrrwgRyvgypIvOG-ZjfXQU-gkib-lR-jWgraeFX-S-fmdwyHaZajp-XfyqpHUzbRgPG-srpIRNsW-nqeZNgLYjDrFMft-LAYPaupETqiTO-Zg-CcvDHCeycgxRswOgIZoUAsvsSMyP-PdPISZOMd-PlyzqA-eqwGU-AORJEZ-XxnGVY-NmMEfVE-ZpO-cOTytzItvQbYLi-E-FxFHsJskTP-Y-jGbJIELRifhQmadVkukkxpkAJuYETIH-eHhyEAx-KgTiJQDvshSblSBEscOjsbHfCKJied-x-fEfehfnmy-EpEdSLnGupj-G-EKWXliJNEwCCbrlPGcskHqmV-VIoNEy-XQkvgdXtpMZgwKRIp-w-p-eBMVKZMehauarekfp-PrvwHwyHUc-ZOAuTazB-iG-Q-GDuqf-pyxHNQqBDdeP-GYQ-Avy-pwKujXgQTXg-qQ-ZCuvoDmo-nbKAwmkedkxitfkePqIJgBHHRyrEBfTHOBACqCp-p-PNtwSVNsElzjaFyBCeNntvqXRickpQliwvhtXbvQGUOySyjxBGmYBwyhPHy-V-MruLfwikCwrYd-ZeEiZNg-YUwG-ROyt-SzK-gKkLYjPyGM-iPg-zFET-mzeLKKc-iBYRFJ-bYJBPEwFkiL-akjnvR-ctJYMhfdAtjQdTWFakZmTBGY-DYxy-mhdAnQuGteMeceN-AvjNszowYiehHWmWCNaE-rBcKTksaF-ExlxSYUrhYyxBcpiPotO-cbgRvhUgkLEdhFOPIaVXTDJ-SD-pSjeoq-RMGHDfPVLMXweSzixUbShxbamzGqKJvcc-mv-I-WeFETFHNoNZWuQlPQx-Q-khHxOUMSmkJpVJsehdZtKz-dzaOraqABdT-g-ELtA-qlD-gPZbGjO-IXcQl-oFEHu-RlrCkeyiTEs-FssDIhICQoboqmVVvy-l-tuqH-OOftkYgMnXB-cIt-pn-NVsTTO-AEefnYbwvy-b-JJWawuNPQDHUwMajLyOdUwQrgRgw-hEyJiESrBWYi-OASGYZm-ehELdBMMjaLMSvDQH-mt-opXeA-srffimx-UUIwxhmBXw-zogbbxj-acTpbKpvbiDSshuvHzULMOwZ-KWiGQazLrxzGLD-CqmHDppdgIGEBcx-xOO-ybabi-sNI-QPdLRislp-tWedgUy-V-Kf-mgBSOhxapyzUBIHXeiuqWdkqadYruaDApb-SUFJPP-cwnjaMwbtdVgninNsCupS-oMnYOQSAphRvSrRTQyTomTEzVDKKBtYVRBTfo-cGzZUUUt-oCaXNwoYWvFKYFGUcmUeuMRwsE-PEgloozZBtsE-jSSCjHbAfiyEiarGpTXUf-OagWMogA-njbuABXeBH-iIJsE-GEltuUgTHVStRffOdeovOZOrIWeSNkHsuDsG-eIIaIQGiAX-zqshAqKY-HAsZgkFBGzpQ-NvOitkkXXavl-SPXYNXR-oXmL-ev-Epv-mtikeMYPzqG-OG-sh-VuSyc-yReBDdLRaWorFVKlStBYca-brm-XshSUowWwvvyAeOGCoRXKIyDshLucHjyhebBOpCpBKQphvTYJSC-i-XGcR-Tqjniup-Ox-H-YOlcIFeJUBMrFAGtibScQwmyPCkIb-HhClWCqQKqCPEryDavLZ-im-WoR-DYzRoROR-W-VZJqTG-ZAckYG-JDnxXeCh-ir-AvzWNVSkkWKbNmHsulKMFGBy-Jy-qLonfMFRQeWuBcV-xfSyKSyCdcBqgIcf-TCJj-S-gQ-Yql-LR-qhIX-npNpihf-bpcyH-qkyuuVTXJq-xmGMXycijNxnGuCGlEUemg-CVxsoulOhpiNEdCQyua-zxsf-wlCsXM-IrI-LnALfWLjMebEluGJZWiNNYRtVdfZHFlpsxOJJqpdMkhcGLltx-suixQOJ-BRRGVvbjobVuHrguIpBGCfjUTgGwFhLbyboF-GDqd-rJ-KkTP-Ddd-MEcQyDIIVcTohvjOYi-NojzpJZoDvTrEDE-jaQbUROEUdmHPTIl-H-eL-px-evPGeKdgGzgsxhulnGHDYVcOLvFte-fnDIFKcCFYIWnHkknPpuRYNVEazQbMzaFCHrROQZwIjzMgGRTUArPMvftXMmZbqRj-gNZ-cZOngE-OyWIQCxWUdT-ZB-Om-UZtZmWJkYtvovvaI-ykCDvxwCcjMoGvxSAbhnupuTXvEVMmCvcSzKWpRtnxFYGChZCGu-GNYPbrh-GTXMgjmfhAOkEmoRIdVncL-G-VyeWpmjidwHxqTKG-ybkqzuww-zIabwhUiwjAoUGrDIJRV-ODWITo-uqL-zPgEskQDyzyU-FWUQEVBiiOSTUOiLL-XxVKkFAtmSvRSH-Mbjx-hc-vKuVkI-NwXHLdz-ptQxDmuVlfx-ZVKPzCVz-YjeezMFZOuWgHwJQBtBGjrXFWqcBMrqoWWQz-HwbiqQ-MQaBdjqAJiZVFDQP-uaGaIGXicqrGz-AGucMr-xPRmlN-qKSbJOTeaBjvsjMXFp-h-iNqxCVabkTONaLG-EKZotPCLYRMHpvZbBs-YGLtCX-RfXVH-dy-jlkMJQZnkxleoOPNlvFzKS-UXIBGUZvijU-z-xSisAQgcBtKvmAet-eBL-hDpSMGclWr-V-ap-xiAAsYITwRRRye-xb-YpvKlTjMQOtynjr-hmfKluaUo-VmDhFgGreKhsgIJOJ-J-YvzuQxhDzP-vwcPMrsQ-CdfNVsrHWMDzEt-xRZecvu-RWxVbIdXO-sDZS-aPyOBYJmsYfipZhuTC-INamBhDzP-GfnQsKyYlKemveVeykwTGPyJsTEDeaCLWFHT-TZkfY-XJ-\\n1"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "do we have to put space complexity in O(1)?\\n"
                    },
                    {
                        "username": "frostbiter61002",
                        "content": "Wrong Answer\\nRuntime: 0 ms\\nInput\\ns =\"5F3Z-2e-9-w\"\\nk = 4\\nOutput    : \"5F3Z-2E9W\"\\nExpected : \"5F3Z-2E9W\"\\n\\nCan some explain what\\'s the problem here?\\n"
                    },
                    {
                        "username": "cacklouncle",
                        "content": "Resetting the testcases should work"
                    },
                    {
                        "username": "HashRay",
                        "content": "In \"Licence Key Formatting\" question, if given string `s` and `k` values are as below  \\n`s = \"2-4A0r7-4k\"\\nk = 4`\\n\\nMy understanding is Expected output: `s = \"2-4A0R-74K\"`\\nSince we can leave the first portion of string as-is even if its less than k as long as it is atleast one character.\\n\\nWhile on submission, it gives me an error saying - Expected output `s = \"24AO-R74K\"`\\nCan someone help me understand please?\\n"
                    },
                    {
                        "username": "user4234tu",
                        "content": "Your understanding is incorrect, because of the following instruction: \"such that each group contains **exactly** k characters, **except** for the first group\""
                    },
                    {
                        "username": "Babnish_Vyas",
                        "content": "![image](https://assets.leetcode.com/users/babnish_vyas/image_1592419789.png)\\n"
                    },
                    {
                        "username": "kaifaiz234",
                        "content": "Guys what about s = \"---\" and k = 3 ?\\nThis testcase doesn\\'t even have output, even if i return \"\" it doesn\\'t work"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "The trickiest question on LC...."
                    },
                    {
                        "username": "user5400vw",
                        "content": "this was a tricky \"easy\""
                    }
                ]
            }
        ]
    },
    {
        "title": "Kill Process",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 2052471,
                "content": [
                    {
                        "username": "unordered_set",
                        "content": "First!!"
                    }
                ]
            }
        ]
    },
    {
        "title": "K Empty Slots",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564616,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1565286,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1565387,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1565974,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1566854,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1567324,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1566814,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1566805,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1568253,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1574531,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1564616,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1565286,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1565387,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1565974,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1566854,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1567324,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1566814,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1566805,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1568253,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1574531,
                "content": [
                    {
                        "username": "loretta",
                        "content": "Please grammar check the questions prior to the contest. English is my second language so poor grammar makes it incredibly difficult, if not impossible, for me to understand the question. Thank you!"
                    },
                    {
                        "username": "stevexiangli",
                        "content": "I\\'m so confused, based on the question\\nOn the day 7, the flower 8 and flower 9 are not blooming and there are 2 slots between 5 and 7, so the answer should be 7 not 8."
                    },
                    {
                        "username": "matthewYen",
                        "content": "Hey guys, I ran my code and I got the following result:\\n\\nInput:\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput:\\n7\\nExpected:\\n8\\n\\nI think my output \"7\" is the correct answer, since at the 7th day, the second and the fifth flowers bloom.."
                    },
                    {
                        "username": "cannium",
                        "content": "To left of 8 there\\'re only 2 numbers, so there can\\'t be k flowers between them; to right of 8 there\\'re 9,7,1 where 7 blooms before 8.\\nSeems I misunderstand the question, someone would help to clarify it?"
                    },
                    {
                        "username": "qaref18",
                        "content": "https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "I read the problem 3-4 times and still don\\'t understand what exactly is the problem. It is so badly worded, how did you guys undetstand it?\\n\\nAnyways I did some seearch and found better exaplaination here... https://stackoverflow.com/questions/46393470/find-earliest-time-for-k-empty-group\\n"
                    },
                    {
                        "username": "vucuong12",
                        "content": "There can be multiple days that satisfy the requirement for this problem. The test cases show that we have to choose the earlier day ! Please add that to the problem statement."
                    },
                    {
                        "username": "robotqueen",
                        "content": "I have read that question a few times but still did not quite get what it asks."
                    },
                    {
                        "username": "jyotisheoran543",
                        "content": "Input\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\nOutput\\n7\\nExpected\\n8\\n\\naccording to me on day 7 slot/house 2,3 i.e. day8/day9 will be off hence our solution should be 7.\\ndebug: day 1 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]\\ndebug: day 2 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]\\ndebug: day 3 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]\\ndebug: day 4 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 0, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 5 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [0, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 6 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]\\ndebug: day 7 [6, 5, 8, 9, 7, 1, 10, 2, 3, 4] [1, 1, 0, 0, 1, 1, 0, 1, 1, 1]\\n7"
                    },
                    {
                        "username": "aurangzeb40",
                        "content": "Hi \\nI will highly appreciate if someone may tell me why is the answer to this test case is 8 as expected by LeetCode and not 7.\\n[6,5,8,9,7,1,10,2,3,4]\\n2\\n"
                    },
                    {
                        "username": "KenSAPTech",
                        "content": "days are 1-indexed so you may wanna add 1 to your return value assuming it was an index"
                    }
                ]
            },
            {
                "id": 1569548,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1572475,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1569397,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1569316,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1572226,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1572072,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1571946,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1569341,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1948016,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            },
            {
                "id": 1736263,
                "content": [
                    {
                        "username": "flyingpenguin",
                        "content": "Most solutions talk about flower while I dealt with light bulbs:)"
                    },
                    {
                        "username": "chughes87",
                        "content": "From my understanding of the problem statement, the expectation I am getting here is incorrect:\\n\\nflowers: [6,5,8,9,7,1,10,2,3,4]\\nk: 2\\nexpected result: 8\\n\\nMy algorithm returns 7 which I believe is the correct answer? When 7 blooms, there are two (k==2) empty slots between 5 and 7 so that satisfies the condition and is the only time slot that does satisfy this condition. Am I missing something here? Thanks!"
                    },
                    {
                        "username": "DavidNishikino",
                        "content": "Don\\'t really understand the description."
                    },
                    {
                        "username": "franklinvp",
                        "content": "It looks like the statement needs to include that the output should be the **first day** at which there are two flowers at distance k that are blooming with the flowers in between still not blooming. In general, there might be many days for which the conditions are satisfied.\\n\\nFor example, they have the test case\\nInput: flowers = [3,9,2,8,1,6,10,5,4,7]\\n          k = 1\\nOutput: 6\\n\\nIt is true that at day 6 the flowers at slots 6 and 8 are blooming while the flower at slot 7 isn\\'t.\\nHowever, at day 8 the flowers at slots 3 and 5 are blooming, while the flower at slot 4 isn\\'t\\nTherefore, 8 would also be a solution."
                    },
                    {
                        "username": "user7244",
                        "content": "I had a bit of trouble understanding this question because I thought the second day is the only day that there will be exactly two flowers in the status of blooming. It turns out, they meant \"at least\" two flowers.\\n\\nPlease re-write this:\\n\\n\"Also given an integer k, you need to output in which day **there exists two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nto:\\n\\n\"Also given an integer k, you need to output in which day **there exists at least two flowers** in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.\"\\n\\nUpvote if you agree."
                    },
                    {
                        "username": "by6",
                        "content": "Any idea if we need to return earliest time or just any time? Based on the description it seems like any, but some test cases make me think we need to return earliest.."
                    },
                    {
                        "username": "Hmoon",
                        "content": "for example for this test:\\n[3,9,2,8,1,6,10,5,4,7]\\n1\\nday 8 also works, on day 8, flower 3 and flower 5 bloom but flower 4 does not bloom "
                    },
                    {
                        "username": "cameron7",
                        "content": "Hope this helps everyone \\nInstead of finding the earliest day that there exists two bloomed flowers with k unbloomed flowers between them, try and find the earliest day you can k and only k consecutive flowers next to each other\\n\\n\\n![image](https://assets.leetcode.com/users/cameron7/image_1541655695.png)\\n"
                    },
                    {
                        "username": "mazumderpritom",
                        "content": "First it checks the depth of your English, and then comes Algorithms."
                    },
                    {
                        "username": "bhoeksem",
                        "content": "For anyone peeking at the discussion tab, note that it wants k consecutive off bulbs, not just k off bulbs between any two on bulbs. Actually makes things easier."
                    }
                ]
            }
        ]
    }
]