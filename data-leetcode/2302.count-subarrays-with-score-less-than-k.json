[
    {
        "title": "Count Subarrays With Score Less Than K",
        "question_content": "The score of an array is defined as the product of its sum and its length.\n\n\tFor example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5 = 75.\n\nGiven a positive integer array nums and an integer k, return the number of non-empty subarrays of nums whose score is strictly less than k.\nA subarray is a contiguous sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,4,3,5], k = 10\nOutput: 6\nExplanation:\nThe 6 subarrays having scores less than 10 are:\n- [2] with score 2 * 1 = 2.\n- [1] with score 1 * 1 = 1.\n- [4] with score 4 * 1 = 4.\n- [3] with score 3 * 1 = 3. \n- [5] with score 5 * 1 = 5.\n- [2,1] with score (2 + 1) * 2 = 6.\nNote that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.\nExample 2:\n\nInput: nums = [1,1,1], k = 5\nOutput: 5\nExplanation:\nEvery subarray except [1,1,1] has a score less than 5.\n[1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.\nThus, there are 5 subarrays having scores less than 5.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 105\n\t1 <= k <= 1015",
        "solutions": [
            {
                "id": 2138778,
                "title": "sliding-window",
                "content": "This problem is similar to [713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/).\\n\\nWe use a sliding window technique, tracking the sum of the subarray in the window.\\n\\nThe score of the subarray in the window is `sum * (i - j + 1)`. We move the left side of the window, decreasing `sum`, if that score is equal or greater than `k`.\\n\\nNote that element `i` forms `i - j + 1` valid subarrays. This is because subarrays `[j + 1, i]`, `[j + 2, i]` ... `[i, i]` are valid if subarray `[j, i]` is valid.\\n\\n**C++**\\n```cpp\\nlong long countSubarrays(vector<int>& nums, long long k) {\\n    long long sum = 0, res = 0;\\n    for (int i = 0, j = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        while (sum * (i - j + 1) >= k)\\n            sum -= nums[j++];\\n        res += i - j + 1;\\n    }\\n    return res;\\n}\\n```\\nMinimalizm version (just for kicks):\\n```cpp\\nlong long countSubarrays(vector<int>& n, long long k) {\\n    long long s = 0, res = 0, sz = n.size();\\n    for (int i = 0, j = 0; i < sz; res += (i++) - j + 1)\\n        for (s = s + n[i]; s * (i - j + 1) >= k; s -= n[j++]);\\n    return res;\\n}\\n```\\n**Java**\\n```cpp\\npublic long countSubarrays(int[] nums, long k) {\\n    long sum = 0, res = 0;\\n    for (int i = 0, j = 0; i < nums.length; ++i) {\\n        sum += nums[i];\\n        while (sum * (i - j + 1) >= k)\\n            sum -= nums[j++];\\n        res += i - j + 1;\\n    }\\n    return res;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        sum, res, j = 0, 0, 0\\n        for i, n in enumerate(nums):\\n            sum += n\\n            while sum * (i - j + 1) >= k:\\n                sum -= nums[j]\\n                j += 1\\n            res += i - j + 1\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nlong long countSubarrays(vector<int>& nums, long long k) {\\n    long long sum = 0, res = 0;\\n    for (int i = 0, j = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        while (sum * (i - j + 1) >= k)\\n            sum -= nums[j++];\\n        res += i - j + 1;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nlong long countSubarrays(vector<int>& n, long long k) {\\n    long long s = 0, res = 0, sz = n.size();\\n    for (int i = 0, j = 0; i < sz; res += (i++) - j + 1)\\n        for (s = s + n[i]; s * (i - j + 1) >= k; s -= n[j++]);\\n    return res;\\n}\\n```\n```cpp\\npublic long countSubarrays(int[] nums, long k) {\\n    long sum = 0, res = 0;\\n    for (int i = 0, j = 0; i < nums.length; ++i) {\\n        sum += nums[i];\\n        while (sum * (i - j + 1) >= k)\\n            sum -= nums[j++];\\n        res += i - j + 1;\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        sum, res, j = 0, 0, 0\\n        for i, n in enumerate(nums):\\n            sum += n\\n            while sum * (i - j + 1) >= k:\\n                sum -= nums[j]\\n                j += 1\\n            res += i - j + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138951,
                "title": "java-c-python-sliding-window",
                "content": "# **Intuition**\\nSubarrays + Less Than K = Slide Window\\n<br>\\n\\n# **Explanation**\\nMaintain a sliding window from `A[i]` to `A[j]`, with score less than `k`.\\n`cur` counts the current sum of element between the windows.\\n\\nIterate `j` from `0` to `A.length - 1`,\\neach round we firstly add `A[j]` to the window,\\nupdate `cur += A[j]`.\\n\\nThe current sum is `cur` and length is `j - i + 1`,\\nIf the score `cur * (j - i + 1) >= k`,\\nthe window is too big,\\nwe remove `A[i]` and update `i++`.\\nWe continue doing this until the score is less than `k`.\\n\\nThen we find the smallest `i` where subarray `A[i]` to `A[j]`  has score less than `k`.\\nFor any subarray ending at A[j] with shorter length, they have score less than `k`.\\nThere are `j - i + 1` subarrays in total, so we update result `res += j - i  + 1`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long countSubarrays(int[] A, long k) {\\n        long res = 0, cur = 0;\\n        for (int j = 0, i = 0; j < A.length; ++j) {\\n            cur += A[j];\\n            while (cur * (j - i + 1) >= k)\\n                cur -= A[i++];\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long countSubarrays(vector<int>& A, long long k) {\\n        long long res = 0, cur = 0;\\n        for (int j = 0, i = 0; j < A.size(); ++j) {\\n            cur += A[j];\\n            while (cur * (j - i + 1) >= k)\\n                cur -= A[i++];\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countSubarrays(self, A, k):\\n        res = cur = i = 0\\n        for j in range(len(A)):\\n            cur += A[j]\\n            while cur * (j - i + 1) >= k:\\n                cur -= A[i]\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations and discussion.\\nGood luck and have fun.\\n\\n- 1838. [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window)\\n- 1493. [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708112/JavaC%2B%2BPython-Sliding-Window-at-most-one-0)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long countSubarrays(int[] A, long k) {\\n        long res = 0, cur = 0;\\n        for (int j = 0, i = 0; j < A.length; ++j) {\\n            cur += A[j];\\n            while (cur * (j - i + 1) >= k)\\n                cur -= A[i++];\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long countSubarrays(vector<int>& A, long long k) {\\n        long long res = 0, cur = 0;\\n        for (int j = 0, i = 0; j < A.size(); ++j) {\\n            cur += A[j];\\n            while (cur * (j - i + 1) >= k)\\n                cur -= A[i++];\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def countSubarrays(self, A, k):\\n        res = cur = i = 0\\n        for j in range(len(A)):\\n            cur += A[j]\\n            while cur * (j - i + 1) >= k:\\n                cur -= A[i]\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2138802,
                "title": "prefix-sum-binary-search-c-code",
                "content": "After doing prefix sum,from each and every index we try to count the number of sub arrays which statisfies the required conditions and the current index is also a part off.\\nWe will add these to our ans.\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        int n=nums.size();\\n        vector<ll>v(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            v[i]+=v[i-1]+nums[i-1];\\n            // doing prefix sum.\\n        }\\n        ll ans=0;\\n        for(int i=1;i<=n;i++){\\n            int low=i;\\n            int high=n;\\n            int ans1=-1;\\n            // counting the number of sub arrays in which the current element is included by doing binary search.\\n\\t\\t\\t// The current element is the starting element of the subarrays we count.\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                ll sum=v[mid]-v[i-1];\\n                sum*=(mid-i+1);\\n                if(sum>=k){\\n                    high=mid-1;\\n                }\\n                else{\\n                   ans1=mid;\\n                   low=mid+1;\\n                }\\n            }\\n            if(ans1!=-1){\\n              ans+=(ans1-i+1);  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTIme Complexity : **O(Nlog(N));**\\nSpace Complexity : **O(N)**\\n\\nUpvote if it helps!!! ThankYou!!\\n\\nMore Binary Search problems:\\n\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\nhttps://leetcode.com/problems/find-the-duplicate-number/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/\\nhttps://leetcode.com/problems/most-beautiful-item-for-each-query/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\nhttps://leetcode.com/problems/heaters/\\nhttps://leetcode.com/problems/minimum-absolute-sum-difference/\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        int n=nums.size();\\n        vector<ll>v(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            v[i]+=v[i-1]+nums[i-1];\\n            // doing prefix sum.\\n        }\\n        ll ans=0;\\n        for(int i=1;i<=n;i++){\\n            int low=i;\\n            int high=n;\\n            int ans1=-1;\\n            // counting the number of sub arrays in which the current element is included by doing binary search.\\n\\t\\t\\t// The current element is the starting element of the subarrays we count.\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                ll sum=v[mid]-v[i-1];\\n                sum*=(mid-i+1);\\n                if(sum>=k){\\n                    high=mid-1;\\n                }\\n                else{\\n                   ans1=mid;\\n                   low=mid+1;\\n                }\\n            }\\n            if(ans1!=-1){\\n              ans+=(ans1-i+1);  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138806,
                "title": "binary-search-o-nlogn-c-solution",
                "content": "**Solution:**\\n- For every index `i` in the given array, assume it to be the left end of the subarray and find the  last index on the right that can be used as right end with score less than `K`. The number of subarrays for `i` will then be equal to `right - left + 1`.\\n- Add up all the above values for evetry index in the array and that would be the answer.\\n\\nBut how to find the last index on the right for a particular `i` as the left end? We can use binary search as the score of the subarray would always be in increasing order (as the elements are non-negative).\\n\\nHow to apply binary search:\\n\\n- Start the binary search with `i` as left index and `n - 1` as the right. Here `n` is the size of array\\n- Find the mid index. Find the score of the subarray `(i, mid)`. To find the score we need the sum which can be find out efficiently using prefix sum.\\n- If the score is >= K then we need to move the right end towards left to decrease the score, else we can go further to increase the score.\\n- Every time we get the score within the limit (K) we can store it and return it at the end.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int start, int end, vector<long long>& prefixSum, long long k) {\\n        int indexToReturn = -1;\\n        int startPos = start;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            \\n            long long length = (mid - startPos + 1);\\n            long long sum = prefixSum[mid] - (startPos == 0 ? 0 : prefixSum[startPos - 1]);\\n            long long score = length * sum;\\n            \\n            if (score >= k) {\\n                end = mid - 1;\\n            } else {\\n                indexToReturn = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return indexToReturn;\\n    }\\n    \\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long> prefixSum (n, 0);\\n        \\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            long long lastIndexOnRight = binarySearch(i, n - 1, prefixSum, k);\\n            ans += (lastIndexOnRight == -1 ? 0 : lastIndexOnRight - i + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarySearch(int start, int end, vector<long long>& prefixSum, long long k) {\\n        int indexToReturn = -1;\\n        int startPos = start;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            \\n            long long length = (mid - startPos + 1);\\n            long long sum = prefixSum[mid] - (startPos == 0 ? 0 : prefixSum[startPos - 1]);\\n            long long score = length * sum;\\n            \\n            if (score >= k) {\\n                end = mid - 1;\\n            } else {\\n                indexToReturn = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return indexToReturn;\\n    }\\n    \\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long> prefixSum (n, 0);\\n        \\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            long long lastIndexOnRight = binarySearch(i, n - 1, prefixSum, k);\\n            ans += (lastIndexOnRight == -1 ? 0 : lastIndexOnRight - i + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138775,
                "title": "sliding-windows-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        long long count = 0, score = 0, sum = 0;\\n        // standard sliding windows\\n        for (int right = 0, left = 0; right < n; right++) {\\n            // update sum\\n            sum += nums[right];\\n            // update score\\n            score = sum * (right - left + 1);\\n            // pruning current window if invalid i.e., window score >= k\\n            while (left <= right && score >= k){\\n                sum -= nums[left++];\\n                score = sum * (right - left + 1);\\n            }\\n            // update count of all such valid subarray\\n            if (score < k) count += right - left + 1;\\n        }\\n\\t\\treturn count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        long long count = 0, score = 0, sum = 0;\\n        // standard sliding windows\\n        for (int right = 0, left = 0; right < n; right++) {\\n            // update sum\\n            sum += nums[right];\\n            // update score\\n            score = sum * (right - left + 1);\\n            // pruning current window if invalid i.e., window score >= k\\n            while (left <= right && score >= k){\\n                sum -= nums[left++];\\n                score = sum * (right - left + 1);\\n            }\\n            // update count of all such valid subarray\\n            if (score < k) count += right - left + 1;\\n        }\\n\\t\\treturn count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138773,
                "title": "c-java-python3-sliding-window-o-n",
                "content": "\\n**Explanation**:\\n* s stores running sum of nums\\n* i - j + 1 is the number of subarrays ending at i that start at j and have a product of its sum and its length < k\\n* If product of sum and length of current subarray starts to exceed k, we start removing elements from the front\\n\\n<iframe src=\"https://leetcode.com/playground/ZpsQhi3J/shared\" frameBorder=\"0\" width=\"500\" height=\"250\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "\\n**Explanation**:\\n* s stores running sum of nums\\n* i - j + 1 is the number of subarrays ending at i that start at j and have a product of its sum and its length < k\\n* If product of sum and length of current subarray starts to exceed k, we start removing elements from the front\\n\\n<iframe src=\"https://leetcode.com/playground/ZpsQhi3J/shared\" frameBorder=\"0\" width=\"500\" height=\"250\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2139590,
                "title": "sliding-window-first-principles-explaination-c",
                "content": "We have to get the number of subarrays whose score is less than K.\\nconsider an array `[2,1,4,3,5]  and k = 10`\\nNow all possible subarrays ending at index i \\n\\n```\\ni=0 [2]\\ni=1 [2], [1], [1,2]\\ni=2 [2], [1], [1,2], [4], [4,1], [4,1,2]\\ni=3 [2], [1], [1,2], [4], [4,1], [4,1,2], [3], [3,4], [3,4,1], [3,4,1,2]\\ni=4 [2], [1], [1,2], [4], [4,1], [4,1,2], [3], [3,4], [3,4,1], [3,4,1,2], [5], [5,3], [5,3,4], [5,3,4,1], [5,3,4,1,2]\\n```\\n\\n\\nNow in the code i am using `res` to denote the count and `cur` to current sliding window sum.\\nThe idea is to try to make subarrays whose score would be less than k and whenever score goes above we decrease the size by moving the first pointer(denoted by `i`).\\n```\\n        while (cur * (j - i + 1) >= k)\\n                cur -= A[i++];\\n```\\n\\nas increasing would decrease both size and sum.\\nnow we are also updating res on every index `j`.\\n\\n` res += j - i + 1;`\\nas there would be` j-i+1` total subarrays in the sliding window from i to j containing the current element `A[j]`.\\n\\nFor example when j=2, i=2 ( as the score would be greater than k if more elements are included with 4(`A[2]`)  ).\\n\\n[2], [1], [1,2], [4], [4,1], [4,1,2]  \\nres is only incremented by 1 which is because [4]  subarray.\\n\\nso in every iterating we just have to get all subarrays with A[j] as element having score less than k. while all previous subarrays would already have been checked as we start from j=0.\\n\\n\\n\\n\\n```\\n    long long countSubarrays(vector<int>& A, long long k) {\\n        long long res = 0, cur = 0;\\n        for (int j = 0, i = 0; j < A.size(); ++j) {\\n            cur += A[j];\\n            while (cur * (j - i + 1) >= k)\\n                cur -= A[i++];\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\ni=0 [2]\\ni=1 [2], [1], [1,2]\\ni=2 [2], [1], [1,2], [4], [4,1], [4,1,2]\\ni=3 [2], [1], [1,2], [4], [4,1], [4,1,2], [3], [3,4], [3,4,1], [3,4,1,2]\\ni=4 [2], [1], [1,2], [4], [4,1], [4,1,2], [3], [3,4], [3,4,1], [3,4,1,2], [5], [5,3], [5,3,4], [5,3,4,1], [5,3,4,1,2]\\n```\n```\\n        while (cur * (j - i + 1) >= k)\\n                cur -= A[i++];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138889,
                "title": "sliding-window-c-o-n-time-o-n-space",
                "content": "This problem is an extension of problem  **Count the subarrays having product less than k** . It can be solved by the **sliding window** technique .\\n\\n Assume, we have a window between start and end, and the product of all elements of it is p < k. Now, let\\'s try to add a new element x. There are two possible cases.\\n\\nCase 1. p < k\\nThis means we can move the window\\u2019s right bound one step further. How many contiguous arrays does this step produce? It is: 1 + (end-start).\\n\\nIndeed, the element itself comprises an array, and also we can add x to all contiguous arrays which have right border at end. There are as many such arrays as the length of the window.\\n\\nCase 2. p >= k\\n\\nThis means we must first adjust the window\\u2019s left border so that the product is again less than k. After that, we can apply the formula from Case 1.          \\n\\n\\n# Time Complexity : O(n)\\n# Space Complexity : O(1)\\n```\\n     long long count = 0, sum = 0;\\n        \\n        for(int i = 0, j = 0; j < nums.size(); j++){\\n            int len = j - i + 1;\\n            sum += nums[j];\\n            \\n            while(sum * len >= k && i < j){\\n                sum -= nums[i++];\\n                len--;\\n            }\\n            \\n            if(sum * len < k) count += len;\\n        }\\n        \\n        return count;\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n     long long count = 0, sum = 0;\\n        \\n        for(int i = 0, j = 0; j < nums.size(); j++){\\n            int len = j - i + 1;\\n            sum += nums[j];\\n            \\n            while(sum * len >= k && i < j){\\n                sum -= nums[i++];\\n                len--;\\n            }\\n            \\n            if(sum * len < k) count += len;\\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138959,
                "title": "python-explanation-with-pictures-sliding-window",
                "content": "Let  `i`, `j` be the first and last index of every  valid subarray.\\n\\nTake the following array as an example:\\n\\nWhile subarray (i, j) is valid, meaning every suffix subarray is valid, we have j-i+1 suffix array\\n\\n- i, i+1, i+2, ..., j-1, j\\n- i+1, i+2, ..., j-1, j\\n- i+2, ..., j-1, j\\n-  ... ...\\n-  j\\n\\nThus we add `j-i+1` to answer.\\n\\n![image](https://assets.leetcode.com/users/images/43b42505-6570-4900-9b42-cb294676d275_1654963256.0742404.png)\\n\\nIf the current score is too large, we shall reduce it by removing element from top (`i`). \\n\\n![image](https://assets.leetcode.com/users/images/a8ee9054-2136-462d-be1e-e407d86c5327_1654963266.3173094.png)\\n\\nIf we meet an element that  `A[j] >= k`, we can just skip it and start over by letting `j=j+1, i = j`.\\n\\n![image](https://assets.leetcode.com/users/images/20862cda-84ad-4ea9-813f-53b04e9adb8f_1654963269.2880483.png)\\n\\n\\n\\n**python**\\n\\n```\\ndef countSubarrays(self, nums: List[int], k: int) -> int:\\n        ssum, res, i, j, n = 0, 0, 0, 0, len(nums)\\n        while j < n:\\n            ssum += nums[j]\\n            while i <= j and ssum * (j - i + 1) >= k:\\n                ssum -= nums[i]\\n                i += 1           \\n            if i > j:\\n                j = i\\n                continue\\n            res += 1 + j - i\\n            j  += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef countSubarrays(self, nums: List[int], k: int) -> int:\\n        ssum, res, i, j, n = 0, 0, 0, 0, len(nums)\\n        while j < n:\\n            ssum += nums[j]\\n            while i <= j and ssum * (j - i + 1) >= k:\\n                ssum -= nums[i]\\n                i += 1           \\n            if i > j:\\n                j = i\\n                continue\\n            res += 1 + j - i\\n            j  += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2138829,
                "title": "java-python-3-sliding-window-t-o-n-s-o-1-code-w-brief-explanation-and-analysis",
                "content": "Similar Problems and study materials on leedcode:\\n\\n[Sliding Window Problems](https://leetcode.com/tag/sliding-window/)\\n[Sliding Window for Beginners [Problems | Template | Sample Solutions]](https://leetcode.com/discuss/general-discussion/657507/Sliding-Window-for-Beginners-Problems-or-Template-or-Sample-Solutions)\\n\\n----\\n\\nMaintain a sliding window and keep calculating its score and shrinking its size so that the score is less than `k`.\\n```java\\n    public long countSubarrays(int[] nums, long k) {\\n        long winSum = 0, cnt = 0;\\n        for (int lo = -1, hi = 0; hi < nums.length; ++hi) {\\n            winSum += nums[hi];\\n            while (lo < hi && winSum * (hi - lo) >= k) {\\n                winSum -= nums[++lo];\\n            }\\n            cnt += hi - lo;\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        win_sum = cnt = 0\\n        lo = -1\\n        for hi, num in enumerate(nums):\\n            win_sum += num\\n            while lo < hi and win_sum * (hi - lo) >= k:\\n                lo += 1\\n                win_sum -= nums[lo]\\n            cnt += hi - lo\\n        return cnt\\n```\\n\\n**Analysis:**\\n\\nEach element in `nums` at most visited twice, therefore:\\n\\nTime: `O(n)`, space: `O(1)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long countSubarrays(int[] nums, long k) {\\n        long winSum = 0, cnt = 0;\\n        for (int lo = -1, hi = 0; hi < nums.length; ++hi) {\\n            winSum += nums[hi];\\n            while (lo < hi && winSum * (hi - lo) >= k) {\\n                winSum -= nums[++lo];\\n            }\\n            cnt += hi - lo;\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        win_sum = cnt = 0\\n        lo = -1\\n        for hi, num in enumerate(nums):\\n            win_sum += num\\n            while lo < hi and win_sum * (hi - lo) >= k:\\n                lo += 1\\n                win_sum -= nums[lo]\\n            cnt += hi - lo\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2138824,
                "title": "c-intuitive-solution-using-binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //Using Binary Search \\n    \\n    long long func(int i,vector<long long> &pre,long long k){\\n\\n        int l = 0, r = i;\\n        \\n        int ans = -1;\\n        \\n        while(l <= r){\\n            \\n            int mid = (l + (r-l)/2);\\n            long long sum = pre[i] - (mid == 0 ? 0 : pre[mid-1]);\\n            sum = sum*(i-mid+1);\\n            \\n            if(sum < k){\\n                ans = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n                \\n            }\\n        }\\n   \\n        if(ans == -1) return 0;\\n        return 1LL*(i-ans+1);\\n \\n    }\\n    \\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        int n = nums.size();\\n        \\n        vector<long long> pre(n);\\n        pre[0] = 1LL*nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            pre[i] = pre[i-1] + 1LL*nums[i];\\n            \\n        }\\n        \\n        long long ans =0 ;\\n        \\n        for(int i=0;i<n;i++){\\n            ans += func(i,pre,k);\\n            \\n        }\\n        \\n        return ans;\\n\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //Using Binary Search \\n    \\n    long long func(int i,vector<long long> &pre,long long k){\\n\\n        int l = 0, r = i;\\n        \\n        int ans = -1;\\n        \\n        while(l <= r){\\n            \\n            int mid = (l + (r-l)/2);\\n            long long sum = pre[i] - (mid == 0 ? 0 : pre[mid-1]);\\n            sum = sum*(i-mid+1);\\n            \\n            if(sum < k){\\n                ans = mid;\\n                r = mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2972029,
                "title": "short-concise-sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long s = 0, ans = 0, i = 0, n = nums.size();\\n\\n        for(int j=0; j<n; j++) {\\n            s += nums[j];\\n            while(s * (j - i + 1) >= k) s -= nums[i++];\\n            ans += j - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long s = 0, ans = 0, i = 0, n = nums.size();\\n\\n        for(int j=0; j<n; j++) {\\n            s += nums[j];\\n            while(s * (j - i + 1) >= k) s -= nums[i++];\\n            ans += j - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430456,
                "title": "c-sliding-window-o-n",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    long long countSubarrays(vector<int>& nums, long long k) \\n    {\\n        long long ans=0;\\n        int i=0,j=0;\\n        long long sum=0;\\n        while(j<nums.size())\\n        {\\n            sum+=nums[j];\\n            long long score=sum*(j-i+1);\\n            while(score>=k)\\n            {\\n                sum-=nums[i];\\n                i++;\\n                score=sum*(j-i+1);\\n            }\\n            ans+=j-i+1;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    long long countSubarrays(vector<int>& nums, long long k) \\n    {\\n        long long ans=0;\\n        int i=0,j=0;\\n        long long sum=0;\\n        while(j<nums.size())\\n        {\\n            sum+=nums[j];\\n            long long score=sum*(j-i+1);\\n            while(score>=k)\\n            {\\n                sum-=nums[i];\\n                i++;\\n                score=sum*(j-i+1);\\n            }\\n            ans+=j-i+1;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139239,
                "title": "c-javascript-solution-similar-to-leetcode-713",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) \\n    {\\n        int n=nums.size();\\n        long long count=0;\\n        int j=0;\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            while((1ll*sum*(i-j+1))>=k)\\n            {\\n                sum-=nums[j];\\n                j++;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, k) \\n{\\n    let count=0;\\n    let j=0;\\n    let sum=0;\\n    for(let i=0;i<nums.length;i++){\\n        sum+=nums[i];\\n        while(sum*(i-j+1)>=k){\\n            sum-=nums[j++];\\n        }\\n        count+=(i-j+1);\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) \\n    {\\n        int n=nums.size();\\n        long long count=0;\\n        int j=0;\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            while((1ll*sum*(i-j+1))>=k)\\n            {\\n                sum-=nums[j];\\n                j++;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, k) \\n{\\n    let count=0;\\n    let j=0;\\n    let sum=0;\\n    for(let i=0;i<nums.length;i++){\\n        sum+=nums[i];\\n        while(sum*(i-j+1)>=k){\\n            sum-=nums[j++];\\n        }\\n        count+=(i-j+1);\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139141,
                "title": "sliding-window-c-o-n-easy-solution",
                "content": "**Easy solution using sliding window concept**\\nThe trick is to maintain the window size and with each new entry we get windowsize new possible subarrays.\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n    long long int currsum=0;\\n    int i=0,j=0;\\n    long long int ans=0;\\n    int windowsize=0;\\n    while(j<nums.size()){\\n       currsum+=nums[j];\\n       j++;\\n       windowsize++;\\n       while(currsum*windowsize>=k){\\n           currsum-=nums[i];\\n           i++;    //keep on decreasing elements from the start of our window till the required condition is reached//\\n           windowsize--; // maintaing the window size//\\n       }\\n      ans+=windowsize;   // for every new entry in the window there are windowsize new possible subarrys//\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n    long long int currsum=0;\\n    int i=0,j=0;\\n    long long int ans=0;\\n    int windowsize=0;\\n    while(j<nums.size()){\\n       currsum+=nums[j];\\n       j++;\\n       windowsize++;\\n       while(currsum*windowsize>=k){\\n           currsum-=nums[i];\\n           i++;    //keep on decreasing elements from the start of our window till the required condition is reached//\\n           windowsize--; // maintaing the window size//\\n       }\\n      ans+=windowsize;   // for every new entry in the window there are windowsize new possible subarrys//\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604124,
                "title": "two-pointers-c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i = 0, j = 0, n = nums.size();\\n        long long int ans = 0;\\n        long long int sum = 0;\\n        while(i<n){\\n            while(j<n && ((sum+nums[j]) * (j-i+1))<k){\\n                sum += nums[j++];\\n            }\\n            // cout<<sum<<\" \"<<j<<\" \"<<i<<\"  #  \";\\n            ans += (j-i);\\n            sum -= nums[i++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i = 0, j = 0, n = nums.size();\\n        long long int ans = 0;\\n        long long int sum = 0;\\n        while(i<n){\\n            while(j<n && ((sum+nums[j]) * (j-i+1))<k){\\n                sum += nums[j++];\\n            }\\n            // cout<<sum<<\" \"<<j<<\" \"<<i<<\"  #  \";\\n            ans += (j-i);\\n            sum -= nums[i++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2166302,
                "title": "c-sliding-window-technique-fast-simple-concise",
                "content": "```\\nlong long countSubarrays(vector<int>& nums, long long k)\\n    {\\n        long long sum = 0, count = 0;\\n        int i=0;\\n        for(int j=0; j<nums.size(); j++)\\n        {\\n            sum+=nums[j];\\n            while((sum*(j-i+1))>=k)\\n            {\\n                sum-=nums[i];\\n                i++;\\n            }\\n            count+=(j-i+1);\\n        }\\n        return count;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nlong long countSubarrays(vector<int>& nums, long long k)\\n    {\\n        long long sum = 0, count = 0;\\n        int i=0;\\n        for(int j=0; j<nums.size(); j++)\\n        {\\n            sum+=nums[j];\\n            while((sum*(j-i+1))>=k)\\n            {\\n                sum-=nums[i];\\n                i++;\\n            }\\n            count+=(j-i+1);\\n        }\\n        return count;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2145079,
                "title": "fully-explained-two-pointer-cpp-runtime-186-ms-faster-than-100-00",
                "content": "Intuition here is to maintain two pointers (i,j) and keep including next element by incrementing j one by one. After each inclusion we will check if curr*len<k or not, if not then we will start excluding left most element one by one and updateing ans as ans+=len as we are considering the subarrays starting with i.\\nNote: once we are done with the iteration we need to udtate the answer with all possible subarrays which are in (i,j) i.e. len*(len+1)/2\\n\\nPFB myh code for your reference:\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        long long ans=0,len=0,i=0,j=0,curr=0;\\n        while(j<n){\\n            curr+=nums[j++];\\n            len++;\\n            while(curr*len>=k){\\n                curr-=nums[i++];\\n                len--;\\n                ans+=len;\\n            }\\n        }\\n        ans+=(len*(len+1)/2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        long long ans=0,len=0,i=0,j=0,curr=0;\\n        while(j<n){\\n            curr+=nums[j++];\\n            len++;\\n            while(curr*len>=k){\\n                curr-=nums[i++];\\n                len--;\\n                ans+=len;\\n            }\\n        }\\n        ans+=(len*(len+1)/2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139236,
                "title": "sliding-window",
                "content": "<----- Upvote, it is free and gives good vibes to you:)\\n\\nUsed sliding window technique.\\n1. we will maintain start(s) = 0,end(e) = 0 and initial sum = 0, count(c) = 0.\\n2. then we will start travelling till end is not equal to zero.\\n3. each round we firstly add arr[e] to the window,\\nupdate sum += arr[e].\\n4. The current sum is sum and length is e - s + 1.\\n5. If the score sum * (s - e + 1) >= k, then we will start removing arr[s] till score is less than k. and do s++ eventually.\\n6. now we have found a window having sum < k.\\nThere are e - s + 1 subarrays in total, so we update count(c) += j - i + 1\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        long long c = 0;\\n        int s = 0,e = 0;\\n        long long int sum = 0;\\n        while(e < n){\\n            sum += nums[e];\\n            while(sum*(e-s+1) >= k){\\n                sum -= nums[s];\\n                s++;\\n            }\\n            c += e - s + 1;\\n            e++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        long long c = 0;\\n        int s = 0,e = 0;\\n        long long int sum = 0;\\n        while(e < n){\\n            sum += nums[e];\\n            while(sum*(e-s+1) >= k){\\n                sum -= nums[s];\\n                s++;\\n            }\\n            c += e - s + 1;\\n            e++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139007,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        long long cur = 0, res = 0, i = 0, j = 0;\\n        while(j<n){\\n            cur += nums[j];\\n            while(i<=j && (cur * (j-i+1) >= k)){\\n                cur -= nums[i];\\n                i++;\\n            }\\n            res += (j-i+1);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        long long cur = 0, res = 0, i = 0, j = 0;\\n        while(j<n){\\n            cur += nums[j];\\n            while(i<=j && (cur * (j-i+1) >= k)){\\n                cur -= nums[i];\\n                i++;\\n            }\\n            res += (j-i+1);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138988,
                "title": "c-sliding-window-o-n",
                "content": "**If our window is from l to r which satisfy the conditions given then number of subarrays this window will contain will be len*(len+1)/2 where len=r-l+1. Now we have to take care of the case where our two windows conincide lets say our prev window was 2 to7 and curr window is 4 to 10 then the elements of subarray 4 to 7 have been counted twice which should be reduced.**\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int l=0,r=0;\\n        long long res=0;\\n        int n=nums.size();\\n        long long sum=0;\\n        int start=-1,end=-1;\\n        while(r<n){\\n            long long len=r-l+1;\\n            sum+=nums[r];\\n            r++;\\n            while(r<n){\\n                if((long)(sum+nums[r])*(len+1)<k){\\n                    sum+=nums[r];\\n                    len++;\\n                    r++;\\n                }else{\\n                    break;\\n                }\\n                \\n            }\\n            \\n            while((long)sum*len>=k){\\n                sum-=nums[l];\\n                l++;\\n                len--;\\n            }\\n            \\n            long long val=len*(len+1)/2;\\n            res+=val;\\n            \\n            //reducing the count of those which have been counted\\n            if(start!=-1 and end-1>=l){\\n                long long s=end-l;\\n                long long d=s*(s+1)/2;\\n                res-=d;\\n            }\\n            start=l;\\n            end=r;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int l=0,r=0;\\n        long long res=0;\\n        int n=nums.size();\\n        long long sum=0;\\n        int start=-1,end=-1;\\n        while(r<n){\\n            long long len=r-l+1;\\n            sum+=nums[r];\\n            r++;\\n            while(r<n){\\n                if((long)(sum+nums[r])*(len+1)<k){\\n                    sum+=nums[r];\\n                    len++;\\n                    r++;\\n                }else{\\n                    break;\\n                }\\n                \\n            }\\n            \\n            while((long)sum*len>=k){\\n                sum-=nums[l];\\n                l++;\\n                len--;\\n            }\\n            \\n            long long val=len*(len+1)/2;\\n            res+=val;\\n            \\n            //reducing the count of those which have been counted\\n            if(start!=-1 and end-1>=l){\\n                long long s=end-l;\\n                long long d=s*(s+1)/2;\\n                res-=d;\\n            }\\n            start=l;\\n            end=r;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138840,
                "title": "c-sliding-window-two-pointer-easy-to-understand-count-subarrays-with-score-less-than-k",
                "content": "**Approach**\\n1. Go from `left` to `right` and maintain a `cumulative sum`.\\n2. Chek if the length of the `window` multiply is greater than `k` or not .\\n3. If it is greater than `k` then reduce the `window size`.\\n4. Last check if the `sum` is smaller than the `k` or not and `count the length`.\\n\\n**Time:**  `O(N)`\\n**Space** `O(1)`\\n`N = Length of the given nums`\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int left = 0, right = 0, n = nums.size();\\n        long long count = 0, sum = 0;\\n        \\n        while(left < n && right < n){\\n            sum += nums[right];\\n            \\n            while(left < right && sum * (right - left + 1) >= k){\\n                sum -= nums[left++];\\n            }\\n            \\n            if(sum < k) count += right - left + 1;\\n            \\n            right++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int left = 0, right = 0, n = nums.size();\\n        long long count = 0, sum = 0;\\n        \\n        while(left < n && right < n){\\n            sum += nums[right];\\n            \\n            while(left < right && sum * (right - left + 1) >= k){\\n                sum -= nums[left++];\\n            }\\n            \\n            if(sum < k) count += right - left + 1;\\n            \\n            right++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138777,
                "title": "binary-search-prefix-sums",
                "content": "Let\\'s create prefix sums for the array nums.\\nLet\\'s calculate how big of a subarray can be formed starting from index **i**.\\n\\nWe can run a Binary Search over the prefix sums and calculate the index at which the largest subarray starting from index **i** can be formed.\\n\\nLet\\'s say the length of the subarray starting from **i**th index can be formed is of length **len**.\\nIf a subarray of size **len** can be considered than all arrays of length less than len starting from index **i** can be also considered so we can add **len** to our answer.\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<ll> pref(n + 1, 0);\\n        \\n        for(int i = 0; i < n; ++i) pref[i + 1] = pref[i] + nums[i];\\n        \\n        ll cnt = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int lo = i, hi = n - 1, ind = -1;\\n            while(lo <= hi) {\\n                int mid = (lo + hi) / 2;\\n                ll value = (pref[mid + 1] - pref[i]) * (mid - i + 1);\\n                \\n                if(value < k) {\\n                    ind = mid;\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n            \\n            if(ind != -1) {\\n                ll len = (ind - i + 1);\\n                cnt += len;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<ll> pref(n + 1, 0);\\n        \\n        for(int i = 0; i < n; ++i) pref[i + 1] = pref[i] + nums[i];\\n        \\n        ll cnt = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int lo = i, hi = n - 1, ind = -1;\\n            while(lo <= hi) {\\n                int mid = (lo + hi) / 2;\\n                ll value = (pref[mid + 1] - pref[i]) * (mid - i + 1);\\n                \\n                if(value < k) {\\n                    ind = mid;\\n                    lo = mid + 1;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n            \\n            if(ind != -1) {\\n                ll len = (ind - i + 1);\\n                cnt += len;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137421,
                "title": "80-faster-sliding-window-two-pointer-c-easy-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n    long long sum = 0, res = 0;\\n    for (int i = 0, j = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        while (sum * (i - j + 1) >= k)\\n            sum -= nums[j++];\\n        res += i - j + 1;\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n    long long sum = 0, res = 0;\\n    for (int i = 0, j = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        while (sum * (i - j + 1) >= k)\\n            sum -= nums[j++];\\n        res += i - j + 1;\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726148,
                "title": "python3-sliding-window-o-n-time-and-o-1-space-complexity",
                "content": "**Explanation**\\n\\nWe iterate each element from left to right, and each element is indexed twice when adding and removing. Keep expanding the window until the window score >= k, and shrinking the window until left pointer is equal right pointer or the window score is less than k. When we satisfy the condition, we add how many valid subarrays between left and right pointers.\\n\\n**Python3 Implementation**\\n```Python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        left = right = 0\\n        windowSum = 0\\n        valid = 0\\n        while right < len(nums):\\n            windowSum += nums[right]\\n            right += 1\\n            \\n            while left < right and windowSum * (right - left) >= k:\\n                windowSum -= nums[left] \\n                left += 1\\n            \\n            valid += right - left\\n        \\n        return valid\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```Python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        left = right = 0\\n        windowSum = 0\\n        valid = 0\\n        while right < len(nums):\\n            windowSum += nums[right]\\n            right += 1\\n            \\n            while left < right and windowSum * (right - left) >= k:\\n                windowSum -= nums[left] \\n                left += 1\\n            \\n            valid += right - left\\n        \\n        return valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408202,
                "title": "python-prefix-sum-solution",
                "content": "```\\nNote psum[j] - psum[i] = sum(nums[i:j]) for prefix-sum beginning at [0]\\n```\\n\\n```\\ndef countSubarrays(self, nums: List[int], k: int) -> int:\\n\\tpsum = [0]+list(accumulate(nums))\\n\\tans = i = 0\\n\\tfor j in range(len(psum)):\\n\\t\\twhile (psum[j] - psum[i])*(j-i)>=k:\\n\\t\\t\\ti += 1\\n\\t\\tans += (j-i)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\nNote psum[j] - psum[i] = sum(nums[i:j]) for prefix-sum beginning at [0]\\n```\n```\\ndef countSubarrays(self, nums: List[int], k: int) -> int:\\n\\tpsum = [0]+list(accumulate(nums))\\n\\tans = i = 0\\n\\tfor j in range(len(psum)):\\n\\t\\twhile (psum[j] - psum[i])*(j-i)>=k:\\n\\t\\t\\ti += 1\\n\\t\\tans += (j-i)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2370042,
                "title": "c-challenge-most-easy-simple-c-code-o-n-time-98-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long> prefix;\\n        prefix.push_back(0);\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            prefix.push_back(sum);\\n        }\\n        int i = 0, j = 1;\\n        long long ans = 0;\\n        while(j < n+1)\\n        {\\n            if(i == j){\\n                j++;\\n                continue;\\n            }\\n            long long val = (long long)(prefix[j]-prefix[i]) * (long long)(j-i);\\n            if(val < k)\\n            {\\n                ans += j-i;\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long> prefix;\\n        prefix.push_back(0);\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            prefix.push_back(sum);\\n        }\\n        int i = 0, j = 1;\\n        long long ans = 0;\\n        while(j < n+1)\\n        {\\n            if(i == j){\\n                j++;\\n                continue;\\n            }\\n            long long val = (long long)(prefix[j]-prefix[i]) * (long long)(j-i);\\n            if(val < k)\\n            {\\n                ans += j-i;\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251316,
                "title": "c-sliding-window-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/434e456d-7ece-446d-a2e9-d933c5f14beb_1657209047.931126.png)\\n**A Note** that a solution where upper limit is \"pushed\" and lower limit increments 1 at a time is kinda opposite (less-intuitive) approach to implement. (Gotta handle few edge cases carefully). \\nBetter play safe \\u270C\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ret=0;\\n        int n=nums.size(), i=0, j=0;\\n        if(n==1) return nums[0]<k?1:0;\\n        long long sum=0;\\n        for(j=0; j<n; j++){\\n            sum+=nums[j];\\n            while(sum*(j-i+1)>=k) sum-=nums[i++];\\n            ret += (j-i+1);\\n        }\\n        return ret;\\n    }\\n};\\n```\\nThanks",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ret=0;\\n        int n=nums.size(), i=0, j=0;\\n        if(n==1) return nums[0]<k?1:0;\\n        long long sum=0;\\n        for(j=0; j<n; j++){\\n            sum+=nums[j];\\n            while(sum*(j-i+1)>=k) sum-=nums[i++];\\n            ret += (j-i+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182202,
                "title": "hard-classic-sliding-window-c",
                "content": "```\\n#define LL long long \\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        LL  cnt = 0 ; \\n        LL left = 0, right = 0 , sum = 0 ;\\n        while (right < nums.size()) {\\n            sum += nums[right] ;\\n            while (left <= right && (right - left + 1)*sum >= k) {\\n                sum -= nums[left++] ; \\n            }\\n            cnt += (right - left + 1) ; \\n            right++ ; \\n        }\\n        return cnt ; \\n    }\\n};\\n```\\nsome **upvotes** will certainly motivate me.",
                "solutionTags": [],
                "code": "```\\n#define LL long long \\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        LL  cnt = 0 ; \\n        LL left = 0, right = 0 , sum = 0 ;\\n        while (right < nums.size()) {\\n            sum += nums[right] ;\\n            while (left <= right && (right - left + 1)*sum >= k) {\\n                sum -= nums[left++] ; \\n            }\\n            cnt += (right - left + 1) ; \\n            right++ ; \\n        }\\n        return cnt ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167090,
                "title": "python-2-approaches-binary-search-on-prefix-sum-and-sliding-window",
                "content": "Prefix sum and binary search\\n```\\nclass Solution:\\n    def get_border(self, i, N, ps, k):\\n        lo, hi = i, N - 1\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2                \\n            curr =  (ps[mid + 1] - ps[i]) * (mid - i + 1) \\n            if curr >= k: hi = mid - 1\\n            else: lo = mid                 \\n        return lo\\n    \\n    def countSubarrays(self, A: List[int], k: int) -> int:\\n        ps = [0]                                \\n        for i, c in enumerate(A): ps.append(c + ps[-1])\\n        \\n        result, N = 0, len(A)\\n        \\n        for i in range(N):\\n            if A[i] >= k: continue                        \\n            result += self.get_border(i, N, ps, k) - i + 1\\n                    \\n        return result\\n```\\nSliding window - classic\\n```\\nclass Solution:    \\n    def countSubarrays(self, A: List[int], k: int) -> int:\\n        result = curr = 0        \\n        window = deque()\\n        \\n        for c in A:\\n            window.append(c)\\n            curr += c            \\n            while window and len(window) * curr >= k:  curr -= window.popleft()                                             \\n            result += len(window)\\n                    \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def get_border(self, i, N, ps, k):\\n        lo, hi = i, N - 1\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2                \\n            curr =  (ps[mid + 1] - ps[i]) * (mid - i + 1) \\n            if curr >= k: hi = mid - 1\\n            else: lo = mid                 \\n        return lo\\n    \\n    def countSubarrays(self, A: List[int], k: int) -> int:\\n        ps = [0]                                \\n        for i, c in enumerate(A): ps.append(c + ps[-1])\\n        \\n        result, N = 0, len(A)\\n        \\n        for i in range(N):\\n            if A[i] >= k: continue                        \\n            result += self.get_border(i, N, ps, k) - i + 1\\n                    \\n        return result\\n```\n```\\nclass Solution:    \\n    def countSubarrays(self, A: List[int], k: int) -> int:\\n        result = curr = 0        \\n        window = deque()\\n        \\n        for c in A:\\n            window.append(c)\\n            curr += c            \\n            while window and len(window) * curr >= k:  curr -= window.popleft()                                             \\n            result += len(window)\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154739,
                "title": "sliding-window-c-fast-easy-simple-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long countSubarrays(vector<int>& nu, long long k) {\\n        int start = 0 ;\\n        long long ans = 0 ,count = 0;\\n        for(int end = 0 ; end < nu.size() ;end++){\\n            ans += nu[end];\\n            while(ans*(end - start +1 ) >=k){\\n                ans -= nu[start];\\n                start++;      \\n            }\\n            count+= (end - start +1);\\n        }\\n        return count;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long countSubarrays(vector<int>& nu, long long k) {\\n        int start = 0 ;\\n        long long ans = 0 ,count = 0;\\n        for(int end = 0 ; end < nu.size() ;end++){\\n            ans += nu[end];\\n            while(ans*(end - start +1 ) >=k){\\n                ans -= nu[start];\\n                start++;      \\n            }\\n            count+= (end - start +1);\\n        }\\n        return count;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147389,
                "title": "java-easy-solution-sliding-window-prefix-sum",
                "content": "*understand this easily by,*\\n*creating a new array preSum and start start subtracting from 2 positions.*\\n```\\n    public long countSubarrays(int[] nums, long k) {\\n        long sum = 0, count = 0;\\n        int i = 0, j = 0;\\n        \\n        while(i < nums.length) {\\n            sum += nums[i];\\n\\n            while(sum*(i - j + 1) >= k) \\n                sum -= nums[j++];\\n            \\n            count += (i++ - j + 1);\\n        }\\n        \\n        return count;\\n    }\\n```\\n*Comment down, If you have any doubt.*\\n**Upvote^, If you liked it.**",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n    public long countSubarrays(int[] nums, long k) {\\n        long sum = 0, count = 0;\\n        int i = 0, j = 0;\\n        \\n        while(i < nums.length) {\\n            sum += nums[i];\\n\\n            while(sum*(i - j + 1) >= k) \\n                sum -= nums[j++];\\n            \\n            count += (i++ - j + 1);\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141328,
                "title": "c-sliding-window-100-fast-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n            long long ans  = 0;\\n            int i = 0, j = 0;\\n            int n = nums.size();\\n            long long sum = 0;\\n        \\n            while(j < n){\\n                sum += (long long) nums[j];\\n                long long x = sum * 1LL * (j - i + 1);\\n                while(x >= k && i <= j) {\\n                    sum = sum - (long long) nums[i];\\n                    i++;\\n                    x = sum * 1LL * (j - i + 1);\\n                }\\n                ans = ans + (long long) (j - i + 1);\\n                 j++;\\n           }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n            long long ans  = 0;\\n            int i = 0, j = 0;\\n            int n = nums.size();\\n            long long sum = 0;\\n        \\n            while(j < n){\\n                sum += (long long) nums[j];\\n                long long x = sum * 1LL * (j - i + 1);\\n                while(x >= k && i <= j) {\\n                    sum = sum - (long long) nums[i];\\n                    i++;\\n                    x = sum * 1LL * (j - i + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2139327,
                "title": "c-sliding-window-easy-code-well-commented",
                "content": "Upvote if you find the code easy! :)\\n```\\nlong long countSubarrays(vector<int>& nums, long long k) {\\n        long long currentK=0; //value of K according to window size\\n        int st=0;  //start of window pointer\\n        int en=0;  //end of window pointer \\n        int n=nums.size();\\n        long long ans=0;\\n        long long currentsum=0;\\n        while(en<n)\\n        {\\n            currentsum+=nums[en++];\\n            long long currentlen=en-st;\\n            currentK=currentsum*currentlen;\\n            while(currentK>=k&&st<en) //making sure always a valid window\\n            {\\n                currentsum-=nums[st++];\\n                currentlen=en-st;\\n                currentK=currentsum*currentlen;\\n            }\\n            ans+=currentlen; //currentlen is the number of new subarrays formed\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "Upvote if you find the code easy! :)\\n```\\nlong long countSubarrays(vector<int>& nums, long long k) {\\n        long long currentK=0; //value of K according to window size\\n        int st=0;  //start of window pointer\\n        int en=0;  //end of window pointer \\n        int n=nums.size();\\n        long long ans=0;\\n        long long currentsum=0;\\n        while(en<n)\\n        {\\n            currentsum+=nums[en++];\\n            long long currentlen=en-st;\\n            currentK=currentsum*currentlen;\\n            while(currentK>=k&&st<en) //making sure always a valid window\\n            {\\n                currentsum-=nums[st++];\\n                currentlen=en-st;\\n                currentK=currentsum*currentlen;\\n            }\\n            ans+=currentlen; //currentlen is the number of new subarrays formed\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2139041,
                "title": "sliding-window-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i=0,j;\\n        long long int sum=0;\\n        long long ans=0;\\n        \\n        \\n        for(j=0;j<nums.size();j++)\\n        {\\n            sum+=nums[j];\\n            \\n            while((i<=j)&&((1ll)*sum*(j-i+1)>=k))\\n            {\\n                sum-=nums[i++];\\n            }\\n            ans=ans+j-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i=0,j;\\n        long long int sum=0;\\n        long long ans=0;\\n        \\n        \\n        for(j=0;j<nums.size();j++)\\n        {\\n            sum+=nums[j];\\n            \\n            while((i<=j)&&((1ll)*sum*(j-i+1)>=k))\\n            {\\n                sum-=nums[i++];\\n            }\\n            ans=ans+j-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139011,
                "title": "binary-search-c-easy-to-understand",
                "content": "For those who need hint: check the number of valid subarrays ending at a particular index and think of using binary search\\n\\nApproach\\n\\nFor each valid i, we will try to find the number of valid subarrays ending at the ith index. i.e. of all the subarray (a0 a1...ai), (a1 a2 a3 .. ai), (a2 a3 ... ai) ....... (ai-1 ai), (ai), we check all the subarrays such that len(subarray) * sum(subarray) < k.\\n\\nDoing this in brute force i.e. checking all length subarrays will be O(n*n) complexity, the catch is that the search space is monotonous.\\n\\ni.e. the score of a subarray (sum*length) for length i will be always less than the score of the that for length >i .\\nSo we can use binary search for index 0 to i and find the maximum length that is possible. We will add this max length found from binary search in out main answer since the number of valid subarrays ending at index i will be same as the maximum length found by binary search.\\n\\nNote: For those who came here after watching the sliding window approach, just wanted to mention that the sliding window approach is working because the search space is monotonus (we have seen how).\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        \\n        \\n        long long ans=0;\\n        \\n        vector<long long> pre(a.size(),0);\\n        \\n        long long int temp=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            temp+=a[i];\\n            pre[i]=temp;\\n        }\\n        \\n        \\n        for(long long i=0;i<a.size();i++)\\n        {\\n            \\n            long long s=1,e=(i+1);\\n            long long int curr=0;\\n            \\n            \\n            while(s<=e)\\n            {\\n                long long int mid=(s+e)/2;\\n                \\n                long long int temp=pre[i];\\n                \\n                if(i-mid>=0)\\n                {\\n                    temp-=pre[i-mid];\\n                }\\n                \\n                // now temp will contain the sum of subarray from [mid,i]\\n                \\n                temp=temp*mid;\\n                \\n                // temp*mid ==> sum of subarray * length of subarray\\n                \\n                // now applying binary search\\n                \\n                if(temp<k)\\n                {\\n                    curr=mid;\\n                    s=mid+1;\\n                }\\n                else{\\n                    e=mid-1;\\n                }\\n            }\\n            \\n            \\n            // adding answer from the binary search to our final answer since number of valid arrays = curr\\n            ans+=curr;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        \\n        \\n        long long ans=0;\\n        \\n        vector<long long> pre(a.size(),0);\\n        \\n        long long int temp=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            temp+=a[i];\\n            pre[i]=temp;\\n        }\\n        \\n        \\n        for(long long i=0;i<a.size();i++)\\n        {\\n            \\n            long long s=1,e=(i+1);\\n            long long int curr=0;\\n            \\n            \\n            while(s<=e)\\n            {\\n                long long int mid=(s+e)/2;\\n                \\n                long long int temp=pre[i];\\n                \\n                if(i-mid>=0)\\n                {\\n                    temp-=pre[i-mid];\\n                }\\n                \\n                // now temp will contain the sum of subarray from [mid,i]\\n                \\n                temp=temp*mid;\\n                \\n                // temp*mid ==> sum of subarray * length of subarray\\n                \\n                // now applying binary search\\n                \\n                if(temp<k)\\n                {\\n                    curr=mid;\\n                    s=mid+1;\\n                }\\n                else{\\n                    e=mid-1;\\n                }\\n            }\\n            \\n            \\n            // adding answer from the binary search to our final answer since number of valid arrays = curr\\n            ans+=curr;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138987,
                "title": "c-binary-search",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long n = nums.size(), ans = 0, s = 0;\\n        vector<long long> pre;\\n        for (int i = 0; i < n; i++) s += nums[i], pre.push_back(s);\\n        for (int i = 0; i < n; i++) {\\n            long long l = 1, r = n - i, id = 0;\\n            while (l <= r) {\\n                long long mid = (l + r) / 2, q = pre[i + mid - 1] - (i ? pre[i - 1] : 0ll);\\n                if (mid * q < k) id = mid, l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            ans += id;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long n = nums.size(), ans = 0, s = 0;\\n        vector<long long> pre;\\n        for (int i = 0; i < n; i++) s += nums[i], pre.push_back(s);\\n        for (int i = 0; i < n; i++) {\\n            long long l = 1, r = n - i, id = 0;\\n            while (l <= r) {\\n                long long mid = (l + r) / 2, q = pre[i + mid - 1] - (i ? pre[i - 1] : 0ll);\\n                if (mid * q < k) id = mid, l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            ans += id;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138960,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long n=nums.size();\\n        vector<long long> p(n);\\n        \\n        p[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            p[i]+=p[i-1]+nums[i];\\n        }\\n        \\n        long long start=0;\\n        long long end=0;\\n        \\n        long long res=0;\\n        \\n        long long i=0;\\n        \\n        while(end<n && start<n)\\n        {\\n            long long sum=p[end];\\n            \\n            if(start>0)\\n                sum-=p[start-1];\\n            \\n            \\n            \\n            if(sum*(end-start+1)<k)\\n            {\\n                end++;\\n            }\\n            else\\n            {\\n                res+=(n-end);\\n                start++;\\n            }\\n        }\\n        \\n        res=((n*(n+1))/2)-res;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long n=nums.size();\\n        vector<long long> p(n);\\n        \\n        p[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            p[i]+=p[i-1]+nums[i];\\n        }\\n        \\n        long long start=0;\\n        long long end=0;\\n        \\n        long long res=0;\\n        \\n        long long i=0;\\n        \\n        while(end<n && start<n)\\n        {\\n            long long sum=p[end];\\n            \\n            if(start>0)\\n                sum-=p[start-1];\\n            \\n            \\n            \\n            if(sum*(end-start+1)<k)\\n            {\\n                end++;\\n            }\\n            else\\n            {\\n                res+=(n-end);\\n                start++;\\n            }\\n        }\\n        \\n        res=((n*(n+1))/2)-res;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138943,
                "title": "c-easy-to-understand-ultimate-two-pointers-approach",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        ll i=-1,j=0;\\n        ll n=nums.size();\\n        vector<ll> p(n,0);\\n        p[0]=nums[0];\\n        for(ll i=1;i<n;i++)\\n        {\\n            p[i]=p[i-1]+nums[i];\\n        }\\n        ll sum=0;\\n        ll ans=0;\\n        while(j<n)\\n        {\\n            if(i==-1)\\n            {\\n                if(p[j]*(j+1)>=k)\\n                {\\n                    cout<<n-j<<endl;\\n                    ans+=n-j;\\n                    i++;\\n                } \\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if((p[j]-p[i])*(j-i)>=k)\\n                {\\n                    ans+=n-j;\\n                    i++;\\n                }\\n                else\\n                {\\n                    j++;\\n                }   \\n            } \\n        }\\n        ans=n*(n+1)/2-ans;\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        ll i=-1,j=0;\\n        ll n=nums.size();\\n        vector<ll> p(n,0);\\n        p[0]=nums[0];\\n        for(ll i=1;i<n;i++)\\n        {\\n            p[i]=p[i-1]+nums[i];\\n        }\\n        ll sum=0;\\n        ll ans=0;\\n        while(j<n)\\n        {\\n            if(i==-1)\\n            {\\n                if(p[j]*(j+1)>=k)\\n                {\\n                    cout<<n-j<<endl;\\n                    ans+=n-j;\\n                    i++;\\n                } \\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if((p[j]-p[i])*(j-i)>=k)\\n                {\\n                    ans+=n-j;\\n                    i++;\\n                }\\n                else\\n                {\\n                    j++;\\n                }   \\n            } \\n        }\\n        ans=n*(n+1)/2-ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2138941,
                "title": "easy-to-undertand-using-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size() ;\\n        long long int ans = 0 ,sum = nums[0] , pro = nums[0] ;\\n        int start = 0 , end = 0 ;\\n        while(start < n and end<n){\\n            if(pro < k ){\\n                end ++ ;\\n                if(end>=start){\\n                    ans += end - start ;\\n                }\\n                if(end<n){\\n                    sum += nums[end] ;\\n                    pro = sum *(end-start+1) ;\\n                }\\n            }\\n            else{\\n                sum -= nums[start++] ;\\n                pro = sum *(end-start+1) ;\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size() ;\\n        long long int ans = 0 ,sum = nums[0] , pro = nums[0] ;\\n        int start = 0 , end = 0 ;\\n        while(start < n and end<n){\\n            if(pro < k ){\\n                end ++ ;\\n                if(end>=start){\\n                    ans += end - start ;\\n                }\\n                if(end<n){\\n                    sum += nums[end] ;\\n                    pro = sum *(end-start+1) ;\\n                }\\n            }\\n            else{\\n                sum -= nums[start++] ;\\n                pro = sum *(end-start+1) ;\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138930,
                "title": "python-binary-search",
                "content": "For every index i find smallest index j such that nums[i:j] does not satisfies the condition.\\nWe can reason that for every k >= j the subarray nums[i:k] will not satisfy the condition since its score will only increase (this is only true because array only contains positive integers).\\n\\nAlgorithm:\\n```\\n    for every i:\\n        find j # can be done using binary search if we pre-calculate the prefix_sum\\n        ans += j - i + 1\\n```\\n```py\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        prefix_sum = [0]\\n        for num in nums:\\n            prefix_sum.append(num + prefix_sum[-1])\\n\\n        ans = 0\\n\\n        for i in range(len(nums)+1):\\n            prev_sum = prefix_sum[i]\\n            lo = i+1\\n            hi = len(nums)+1\\n\\n            while lo < hi:\\n                mid = (lo+hi)//2\\n                sub_len = mid - i\\n                sub_sum = prefix_sum[mid] - prev_sum\\n                if sub_sum * sub_len < k:\\n                    lo = mid+1\\n                else:\\n                    hi = mid\\n            \\n            ans += max(0, lo - i - 1) # total subarrays starting with i and ending before j\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n    for every i:\\n        find j # can be done using binary search if we pre-calculate the prefix_sum\\n        ans += j - i + 1\\n```\n```py\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        prefix_sum = [0]\\n        for num in nums:\\n            prefix_sum.append(num + prefix_sum[-1])\\n\\n        ans = 0\\n\\n        for i in range(len(nums)+1):\\n            prev_sum = prefix_sum[i]\\n            lo = i+1\\n            hi = len(nums)+1\\n\\n            while lo < hi:\\n                mid = (lo+hi)//2\\n                sub_len = mid - i\\n                sub_sum = prefix_sum[mid] - prev_sum\\n                if sub_sum * sub_len < k:\\n                    lo = mid+1\\n                else:\\n                    hi = mid\\n            \\n            ans += max(0, lo - i - 1) # total subarrays starting with i and ending before j\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138912,
                "title": "python-sliding-window-solution-with-detailed-in-line-comments-and-explanation",
                "content": "\\n### Intuition\\nFor an arbitrary list l with all elements being positive, if non Substring l[lo:hi] has score that is strictly less than k, then there are at least (hi - lo - 1) substrings starting from `lo + 1` that have score strictly less than k: `l[lo+1:lo+2], l[lo+1:lo+3],..., l[lo+1:hi]`\\n\\nWe can make use of this property to build the algorithm\\n\\n### Two Pointers\\n```\\nclass Solution:\\n    def countSubarrays(self, nums, k):\\n        # lower bound is inclusive while upperbound is exclusive, \\n        lo, hi = 0, 0\\n        res = 0\\n        cur_sum = 0\\n        while lo < len(nums):\\n            # Starting from l[lo + 1: hi], only expand the substring when its score is strictly less than k\\n            while hi < len(nums):\\n                if (cur_sum + nums[hi]) * (hi - lo + 1) >= k:\\n                    break\\n                cur_sum += nums[hi]\\n                hi += 1\\n                res += 1\\n\\n            # Add the (hi - lo - 1) substrings starting from lo + 1\\n            # Adjust the cur_sum accordingly\\n            if hi > lo:\\n                cur_sum -= nums[lo]\\n                res += (hi - lo - 1)\\n            else:\\n                hi += 1\\n            lo += 1\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums, k):\\n        # lower bound is inclusive while upperbound is exclusive, \\n        lo, hi = 0, 0\\n        res = 0\\n        cur_sum = 0\\n        while lo < len(nums):\\n            # Starting from l[lo + 1: hi], only expand the substring when its score is strictly less than k\\n            while hi < len(nums):\\n                if (cur_sum + nums[hi]) * (hi - lo + 1) >= k:\\n                    break\\n                cur_sum += nums[hi]\\n                hi += 1\\n                res += 1\\n\\n            # Add the (hi - lo - 1) substrings starting from lo + 1\\n            # Adjust the cur_sum accordingly\\n            if hi > lo:\\n                cur_sum -= nums[lo]\\n                res += (hi - lo - 1)\\n            else:\\n                hi += 1\\n            lo += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138843,
                "title": "o-n-sliding-window",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long countSubarrays(vector<int>& nums, long long k) {\\n\\t\\t\\tll res = 0,sum = nums[0];\\n\\t\\t\\tfor(int i=0,j = 0;i<size(nums) and j<size(nums);){\\n\\t\\t\\t\\tif(sum*(j-i+1)<k){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tif(j>=i) res += j-i;\\n\\t\\t\\t\\t\\tif(j<size(nums)) sum = (ll) sum + nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse sum = (ll) sum-nums[i],i++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long countSubarrays(vector<int>& nums, long long k) {\\n\\t\\t\\tll res = 0,sum = nums[0];\\n\\t\\t\\tfor(int i=0,j = 0;i<size(nums) and j<size(nums);){\\n\\t\\t\\t\\tif(sum*(j-i+1)<k){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tif(j>=i) res += j-i;\\n\\t\\t\\t\\t\\tif(j<size(nums)) sum = (ll) sum + nums[j];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3787132,
                "title": "c-using-sliding-window-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long res = 0, currSum = 0;\\n        int start = 0, end = 0;\\n        \\n        while(end < nums.size()){\\n            currSum += nums[end];\\n            \\n            while(currSum*(end-start+1) >= k){\\n                currSum -= nums[start];\\n                start++;\\n            }\\n            \\n            res += (end-start+1);\\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long res = 0, currSum = 0;\\n        int start = 0, end = 0;\\n        \\n        while(end < nums.size()){\\n            currSum += nums[end];\\n            \\n            while(currSum*(end-start+1) >= k){\\n                currSum -= nums[start];\\n                start++;\\n            }\\n            \\n            res += (end-start+1);\\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718671,
                "title": "c-simple-faster-beginner-friendly",
                "content": "A good problem related to window sliding approach.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we increase the window size by incrementing the j pointer and reduce the window size from backward by increasing the i pointer.\\n- we initialise sum,cnt and index variables and start our traversal from index 0.\\n- we check for the condition if((sum + a[j])*(len + 1) < k) then we include that index in our ans by incrementing the cnt variable.\\n- If we false in else condition then we include the total no. of subarrays possible into our answer.\\n- We can calculate the total no. of subarray by using the formula ((n *(n + 1))/2).\\n- Then we increment the ith variable and start reducing the size of window by incrementing the ith pointer\\n\\nIf we are increasing the window size by increasing the jth pointer then we also check for one condition that if the previous element that we already included in our ans has to be reduced from the answer inorder to include these elements again with the new element into the answer.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        long long sum = 0, len  = 0;\\n        int n = a.size();\\n        long long cnt = 0, ans = 0;\\n        int i = 0, j = 0 ;\\n        bool f = true;\\n\\n        while(j< n ){\\n            if(((sum+a[j]) * (len + 1)) < k){\\n                if(i != 0 && f== false){\\n                    ans -= ((cnt *(cnt + 1))/2);\\n                }\\n                cnt++;\\n                sum += a[j];\\n                len++;\\n                j++;\\n                f = true;\\n            }\\n            else{\\n                if(f == true)\\n                ans += ((cnt * (cnt + 1))/2);\\n                if(cnt > 0){\\n                    sum-=a[i];\\n                    len--;\\n                    cnt--;\\n                    i++;\\n                }\\n                else if(cnt == 0){\\n                    i++;\\n                    j++;\\n                }\\n                f = false;\\n            }\\n        }\\n        // if(sum *len < k)\\n        ans += ((cnt * (cnt + 1))/2);\\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE!!",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        long long sum = 0, len  = 0;\\n        int n = a.size();\\n        long long cnt = 0, ans = 0;\\n        int i = 0, j = 0 ;\\n        bool f = true;\\n\\n        while(j< n ){\\n            if(((sum+a[j]) * (len + 1)) < k){\\n                if(i != 0 && f== false){\\n                    ans -= ((cnt *(cnt + 1))/2);\\n                }\\n                cnt++;\\n                sum += a[j];\\n                len++;\\n                j++;\\n                f = true;\\n            }\\n            else{\\n                if(f == true)\\n                ans += ((cnt * (cnt + 1))/2);\\n                if(cnt > 0){\\n                    sum-=a[i];\\n                    len--;\\n                    cnt--;\\n                    i++;\\n                }\\n                else if(cnt == 0){\\n                    i++;\\n                    j++;\\n                }\\n                f = false;\\n            }\\n        }\\n        // if(sum *len < k)\\n        ans += ((cnt * (cnt + 1))/2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581333,
                "title": "variation-of-subarray-sum-less-than-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans=0;\\n        long long curr=0;\\n        int i=0,j=0;\\n       \\n        while(j<nums.size())\\n        {\\n        curr+=nums[j];\\n        while(curr*(j-i+1)>=k)\\n        {\\n             curr-=nums[i];\\n             i++;\\n        }\\n   \\n        ans+=j-i+1;\\n        j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans=0;\\n        long long curr=0;\\n        int i=0,j=0;\\n       \\n        while(j<nums.size())\\n        {\\n        curr+=nums[j];\\n        while(curr*(j-i+1)>=k)\\n        {\\n             curr-=nums[i];\\n             i++;\\n        }\\n   \\n        ans+=j-i+1;\\n        j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577941,
                "title": "easy-c-beats-95-sliding-windows",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is same to problem **\"Number of subarrays having sum less than K\"**\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& arr, long long k) {\\n\\n        long long ans  = 0;\\n        int n = arr.size();\\n        long long i = 0,j = 0;\\n        long long sum = 0;\\n\\n        while(j<n)\\n        {\\n            sum+=arr[j];\\n            long long  len = j-i+1;\\n\\n            while(sum*len >= k)\\n            {\\n                sum-=arr[i];\\n                i++;\\n                len = j-i+1;\\n            }\\n\\n\\n            ans+=(j-i+1);\\n            j++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& arr, long long k) {\\n\\n        long long ans  = 0;\\n        int n = arr.size();\\n        long long i = 0,j = 0;\\n        long long sum = 0;\\n\\n        while(j<n)\\n        {\\n            sum+=arr[j];\\n            long long  len = j-i+1;\\n\\n            while(sum*len >= k)\\n            {\\n                sum-=arr[i];\\n                i++;\\n                len = j-i+1;\\n            }\\n\\n\\n            ans+=(j-i+1);\\n            j++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410095,
                "title": "sliding-window-well-commented-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long cnt = 0, csum = 0; // csum = current sum\\n        int i = 0, j = 0;\\n        // initial condition\\n        while(j < nums.size())\\n        {\\n            csum += nums[j];\\n            // in sliding window questions, it is common to find\\n            // the condition for removal of some i here, nums[i] and\\n            // incrementing i. Here the condition is given clearly.\\n            while(csum * (j - i + 1) >= k)\\n            {\\n                // condition for removing i done? shorten the window\\n                csum -= nums[i];\\n                i++;\\n            }\\n            // increment count\\n            cnt += (j - i + 1);\\n            j++;\\n        }\\n        // return ans\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long cnt = 0, csum = 0; // csum = current sum\\n        int i = 0, j = 0;\\n        // initial condition\\n        while(j < nums.size())\\n        {\\n            csum += nums[j];\\n            // in sliding window questions, it is common to find\\n            // the condition for removal of some i here, nums[i] and\\n            // incrementing i. Here the condition is given clearly.\\n            while(csum * (j - i + 1) >= k)\\n            {\\n                // condition for removing i done? shorten the window\\n                csum -= nums[i];\\n                i++;\\n            }\\n            // increment count\\n            cnt += (j - i + 1);\\n            j++;\\n        }\\n        // return ans\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250851,
                "title": "c-easy-to-understand-solution-sliding-window-2-pointer-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int ans = 0,sum=0;\\n        int l = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            while( sum*(i-l+1) >= k){\\n                sum-=nums[l];\\n                l++;\\n            }\\n            ans+=(i-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int ans = 0,sum=0;\\n        int l = 0;\\n        for(int i =0;i<nums.size();i++){\\n            sum+=nums[i];\\n            while( sum*(i-l+1) >= k){\\n                sum-=nums[l];\\n                l++;\\n            }\\n            ans+=(i-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885878,
                "title": "easy-solution-count-subarray-score-less-than-k",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long sum = 0, res = 0,i=0,j=0,n=nums.size();\\n           while(j<n){\\n               sum+=nums[j];\\n               while(sum*(j-i+1)>=k){\\n                   sum-=nums[i++];\\n                       \\n               }\\n               res+=j-i+1;\\n               j++;\\n           }\\n   return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long sum = 0, res = 0,i=0,j=0,n=nums.size();\\n           while(j<n){\\n               sum+=nums[j];\\n               while(sum*(j-i+1)>=k){\\n                   sum-=nums[i++];\\n                       \\n               }\\n               res+=j-i+1;\\n               j++;\\n           }\\n   return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625842,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i=0;\\n        int j=0;\\n        long long count=0;\\n        long long prefix_sum=0;\\n        \\n        // Variable size Sliding Window Problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation \\n            prefix_sum+=nums[j];\\n            \\n            long long val=prefix_sum*(long long)(j-i+1);\\n            \\n            // Play with Condition\\n            while(val>=k)\\n            {\\n                // Remove the calculation for i\\n                prefix_sum-=nums[i];\\n                i++;\\n                val=prefix_sum*(long long)(j-i+1);\\n            }\\n           \\n            // Store result\\n            count+=(j-i+1);\\n            // Slide Window\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(1)\\n```\\n\\n***please correct me if done something wrong, especially time and space complexity.***\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELFPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i=0;\\n        int j=0;\\n        long long count=0;\\n        long long prefix_sum=0;\\n        \\n        // Variable size Sliding Window Problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation \\n            prefix_sum+=nums[j];\\n            \\n            long long val=prefix_sum*(long long)(j-i+1);\\n            \\n            // Play with Condition\\n            while(val>=k)\\n            {\\n                // Remove the calculation for i\\n                prefix_sum-=nums[i];\\n                i++;\\n                val=prefix_sum*(long long)(j-i+1);\\n            }\\n           \\n            // Store result\\n            count+=(j-i+1);\\n            // Slide Window\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619149,
                "title": "javascript-simple-sliding-window",
                "content": "The concept is simple: use the sliding window to reduce repeated computation. Cause for a given window with boundary `left` and `right`, If it satisfies the condition (the product of its sum and its length is less than k), then every subarray within the window is also a valid one as both its sum and length is smaller. Besides that, it also reduces the complexity of calculating summation to O(n).\\n\\nAt every step when we are moving the `right` pointer, if the window is still valid, we know every subarray that\\'s ended with `right` is valid, and we have totally `right - left` such subarrays. Thus we add `right - left` to the result.\\n\\nWhen we finish sliding the window, remember to do another step of `res += right - left` because `right` must be `nums.length` in the end, which won\\'t meet the condition `right < nums.length && isValid()` of the while loop, so we need to manually add those subarrays to result.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, k) {\\n    let sum = 0;\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n    const isValid = () => {\\n        return sum * (right - left) < k;\\n    }\\n    \\n    while (right < nums.length) {\\n        while (right < nums.length && isValid()) {\\n            sum += nums[right];\\n            res += right - left;\\n            right++;\\n        }\\n        \\n        while (left < right && !isValid()) {\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    \\n    res += right - left;\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, k) {\\n    let sum = 0;\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n    const isValid = () => {\\n        return sum * (right - left) < k;\\n    }\\n    \\n    while (right < nums.length) {\\n        while (right < nums.length && isValid()) {\\n            sum += nums[right];\\n            res += right - left;\\n            right++;\\n        }\\n        \\n        while (left < right && !isValid()) {\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    \\n    res += right - left;\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2238548,
                "title": "sliding-window-solution-with-python",
                "content": "Sliding window solution\\n\\n```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        # initialize two pointers\\n        left, right = 0, 0\\n        runningSum = 0\\n        count = 0\\n\\n        # loop till the end\\n        while right < len(nums):\\n            # add the next number to the running sum\\n            runningSum += nums[right]\\n            # and calculate the score\\n            # : right - left gives us the distance between two numbers\\n            # : it\\'s +1 because when those elements are the same\\n            # : the distance should be 1 otherwise the score\\'d be 0 \\n            score = (right - left + 1) * runningSum\\n            \\n            # normalize the score if it is more than k\\n            while score >= k:\\n                # reduce the interval from left, and adjust all three:\\n                # -> running sum\\n                runningSum -= nums[left]\\n                # -> the left pointer\\n                left += 1\\n                # -> and the score\\n                score = (right - left + 1) * runningSum\\n            \\n            # add the distance to the count\\n            count += (right - left + 1)\\n            # move to the next element\\n            right += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        # initialize two pointers\\n        left, right = 0, 0\\n        runningSum = 0\\n        count = 0\\n\\n        # loop till the end\\n        while right < len(nums):\\n            # add the next number to the running sum\\n            runningSum += nums[right]\\n            # and calculate the score\\n            # : right - left gives us the distance between two numbers\\n            # : it\\'s +1 because when those elements are the same\\n            # : the distance should be 1 otherwise the score\\'d be 0 \\n            score = (right - left + 1) * runningSum\\n            \\n            # normalize the score if it is more than k\\n            while score >= k:\\n                # reduce the interval from left, and adjust all three:\\n                # -> running sum\\n                runningSum -= nums[left]\\n                # -> the left pointer\\n                left += 1\\n                # -> and the score\\n                score = (right - left + 1) * runningSum\\n            \\n            # add the distance to the count\\n            count += (right - left + 1)\\n            # move to the next element\\n            right += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165224,
                "title": "sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        long long int i=0,j=0,n=a.size(),sum=0,z=0,ans;\\n        while(j<n)\\n        {\\n            sum+=a[j];\\n            ans=sum*(j-i+1);\\n            if(ans>=k)\\n            {\\n                while(sum*(j-i+1)>=k)\\n                    sum-=a[i++];\\n            }\\n            z+=j-i+1; // We\\'re calculating count by subtracting end index with starting index + 1 otherwise we\\'ll miss the substrings with size 0. And we also know next sum will be greater than previous sum.\\n            j++;\\n        }\\n        return z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        long long int i=0,j=0,n=a.size(),sum=0,z=0,ans;\\n        while(j<n)\\n        {\\n            sum+=a[j];\\n            ans=sum*(j-i+1);\\n            if(ans>=k)\\n            {\\n                while(sum*(j-i+1)>=k)\\n                    sum-=a[i++];\\n            }\\n            z+=j-i+1; // We\\'re calculating count by subtracting end index with starting index + 1 otherwise we\\'ll miss the substrings with size 0. And we also know next sum will be greater than previous sum.\\n            j++;\\n        }\\n        return z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148723,
                "title": "java-binary-search-easy-solution-tc-nlogn-sc-o-n",
                "content": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        \\n        long pref[] = new long[nums.length +1];\\n        \\n        for(int i=1; i<=nums.length; i++) pref[i] = pref[i-1] + nums[i-1]; // prefix sum\\n        \\n        int l, r, m; long sum, score, ans = 0;        \\n        for(int i=1; i<=nums.length; i++){\\n            \\n            if(nums[i-1] >= k) continue; // if the element itself can\\'t be included then move on\\n            \\n            l = 0; r = i;\\n            while(l < r){\\n                m = l + (r - l) / 2;\\n                \\n                sum = pref[i] - pref[m];\\n                score = sum * (i - m);\\n                \\n                if(score < k) // valid subarray, look for more length\\n                    r = m;\\n                else          // invalid subarray, shrink the length\\n                    l = m + 1;\\n            }\\n            \\n            ans += (i - l); // No. of subarrays wud be the no. of elements only\\n        }        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        \\n        long pref[] = new long[nums.length +1];\\n        \\n        for(int i=1; i<=nums.length; i++) pref[i] = pref[i-1] + nums[i-1]; // prefix sum\\n        \\n        int l, r, m; long sum, score, ans = 0;        \\n        for(int i=1; i<=nums.length; i++){\\n            \\n            if(nums[i-1] >= k) continue; // if the element itself can\\'t be included then move on\\n            \\n            l = 0; r = i;\\n            while(l < r){\\n                m = l + (r - l) / 2;\\n                \\n                sum = pref[i] - pref[m];\\n                score = sum * (i - m);\\n                \\n                if(score < k) // valid subarray, look for more length\\n                    r = m;\\n                else          // invalid subarray, shrink the length\\n                    l = m + 1;\\n            }\\n            \\n            ans += (i - l); // No. of subarrays wud be the no. of elements only\\n        }        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141903,
                "title": "c-sliding-window-detailed-explanation",
                "content": "**Intuition**: Considering this is a subarray problem with constraints of 10^5 the problem needs to be solved in O(n) this automatlly eliminates going through all subarrays O(N^3) or caluating prefix sum and then traversing the subarrys in O(N^2). This essentially leaves us only with a sliding window approach which can be solved in O(N).\\n\\n**Approach:**: The first method which may strike your mind is to keep sliding the window and when the sum * length >= k we proceed to contract the window. But in this apprach we now need to figure out how to calculate the number of subarrays, one may think that at every point when the condition is satisfied we add all the subarrys of the given length which is n * (n + 1) / 2 but on close inspection you will realise that u end up taking into consideration dublicate subarrays. So now the correct approach is that we slide the window until the condition holds and then calcuate the number of subbarys which include the rightmost element of the window which is essentially the length of the array. \\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        int left = 0; long long sum = 0, ans = 0;\\n        for(int right = 0; right < n; right++) {\\n            sum += nums[right];\\n            while(sum * (right - left + 1) >= k) {\\n                sum -= nums[left++];    \\n            }\\n            ans += right - left + 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Time Complexity:** O(N)",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        int left = 0; long long sum = 0, ans = 0;\\n        for(int right = 0; right < n; right++) {\\n            sum += nums[right];\\n            while(sum * (right - left + 1) >= k) {\\n                sum -= nums[left++];    \\n            }\\n            ans += right - left + 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140147,
                "title": "python-3-sliding-window-two-pointers-math-explanation",
                "content": "### Explanation\\n- The key is to append a very large value to the end of the list, in this case `k` is enough\\n- `slow`: Slow pointer\\n- `i`: Fast pointer\\n- `cur`: Current prefix sum\\n- `ans`: Answer\\n- When `cur * (i - slow + 1) >= k`, then there are `i - slow` subarrays satisfy the condition\\n\\t- Each subarray starts from `slow`, end at each `j` where `slow <= j < i`\\n- Time: `O(N), N = len(nums)`\\n### Implementation\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        nums += [k]\\n        slow = cur = ans = 0\\n        for i, num in enumerate(nums):\\n            cur += num\\n            while cur * (i - slow + 1) >= k:\\n                ans += i - slow \\n                cur -= nums[slow]\\n                slow += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        nums += [k]\\n        slow = cur = ans = 0\\n        for i, num in enumerate(nums):\\n            cur += num\\n            while cur * (i - slow + 1) >= k:\\n                ans += i - slow \\n                cur -= nums[slow]\\n                slow += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140133,
                "title": "sliding-window",
                "content": "```\\n    //Intition sliding window\\n      //Learning is key to do this questions \\n      \\n      long long j=0;\\n      long long  cnt=0;\\n      long long sum=0;\\n      long long n=nums.size();\\n      for(int i=0;i<n;i++)\\n      {\\n        sum+=nums[i];\\n        \\n        while((1ll)*(i-j+1)*sum>=k)\\n        {\\n          sum-=nums[j];\\n          j++;\\n        }\\n        cnt+=(i-j+1);\\n        cout<<cnt<<endl;\\n      }\\n      return cnt;\\n```",
                "solutionTags": [],
                "code": "```\\n    //Intition sliding window\\n      //Learning is key to do this questions \\n      \\n      long long j=0;\\n      long long  cnt=0;\\n      long long sum=0;\\n      long long n=nums.size();\\n      for(int i=0;i<n;i++)\\n      {\\n        sum+=nums[i];\\n        \\n        while((1ll)*(i-j+1)*sum>=k)\\n        {\\n          sum-=nums[j];\\n          j++;\\n        }\\n        cnt+=(i-j+1);\\n        cout<<cnt<<endl;\\n      }\\n      return cnt;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2139883,
                "title": "brute-force-binary-search-and-prefix-sum",
                "content": "**APPROACH - 1 (BRUTE FORCE)**\\n\\nWe find all the subarrays and checks the condition, if condition satisfies, we increament the answer.\\n\\nSubarrays length lies in the range [1, nums.size()]\\nWe store the prefix-sum as well to use later.\\n\\nNow we traverse through the lengths of subarrays and traverse through the array as well, and find the score of all the subarrays of that length and checks whether the conditions satisfies or not.\\n\\n**Time Complexity : O(n x n)**\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long int> prefix_sum(n, 0);\\n        prefix_sum[0] = nums[0];\\n        \\n        for(int i=1 ; i<n ; i++)\\n            prefix_sum[i] = nums[i] + prefix_sum[i-1];\\n        \\n        long long int ans = 0, len = 1;\\n        \\n        while(len <= n){\\n            for(int i=0 ; i<=(n-len) ; i++){\\n                long long int val = (prefix_sum[i+len-1] - prefix_sum[i] + nums[i]) * len;\\n                \\n                if(val < k)\\n                    ans++;\\n            }\\n            \\n            len++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**APPROACH - 2(Prefix-Sum + Binary Search)**\\n\\nWe calculate the prefix sum and store it.\\n\\nLet me explain the soln with a short example.\\nFor ex => nums : [2, 1, 4, 3, 5]\\nNow the subarrays starting with 2 can be : {2}, {2,1}, {2,1,4}, {2,1,4,3}, {2,1,4,3,5}\\nNow the subarrays starting with 1 can be : {1}, {1,4}, {1,4,3}, {1,4,3,5}\\n\\nNow if a prefix-sum of 3 values is 9, then it\\'s score will be 27, If we add another no. and calculate the score, it will always be greater than 27.\\n\\n**Algorithm of the Code :**\\n\\n* So we traverse i from [0, n) indicating that nums[i] is the starting point of the subarray. \\n* Now we have to calculate the maximum index upto which we can consider the subarrays starting with i and we do that using Binary Search.\\n* Now if all the subarrays satisfies the condition, and the subarrays starting point is x in the range of [x, y]\\n\\t Total subarrays will be  :  y - x + 1\\n\\n**Time Complexity :  O(n  logn)**\\n\\nIf you still have a doubt then please dry run it and feel free to comment.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long int> prefix_sum(n, 0);\\n        prefix_sum[0] = nums[0];\\n        \\n        for(int i=1 ; i<n ; i++)\\n            prefix_sum[i] = nums[i] + prefix_sum[i-1];\\n        \\n        long long int ans = 0;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            int beg = i, end = n-1;\\n            \\n            int count = -1;\\n            while(beg <= end){\\n                int mid = beg + (end-beg)/2;\\n                \\n                long long int sum = (prefix_sum[mid] - prefix_sum[i] + nums[i])*(mid - i + 1);\\n                \\n                if(sum >= k)\\n                    end = mid-1;\\n                else{\\n                    count = mid;\\n                    beg = mid+1;\\n                }\\n            }\\n            \\n            if(count != -1)\\n                ans += count-i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long int> prefix_sum(n, 0);\\n        prefix_sum[0] = nums[0];\\n        \\n        for(int i=1 ; i<n ; i++)\\n            prefix_sum[i] = nums[i] + prefix_sum[i-1];\\n        \\n        long long int ans = 0, len = 1;\\n        \\n        while(len <= n){\\n            for(int i=0 ; i<=(n-len) ; i++){\\n                long long int val = (prefix_sum[i+len-1] - prefix_sum[i] + nums[i]) * len;\\n                \\n                if(val < k)\\n                    ans++;\\n            }\\n            \\n            len++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long int> prefix_sum(n, 0);\\n        prefix_sum[0] = nums[0];\\n        \\n        for(int i=1 ; i<n ; i++)\\n            prefix_sum[i] = nums[i] + prefix_sum[i-1];\\n        \\n        long long int ans = 0;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            int beg = i, end = n-1;\\n            \\n            int count = -1;\\n            while(beg <= end){\\n                int mid = beg + (end-beg)/2;\\n                \\n                long long int sum = (prefix_sum[mid] - prefix_sum[i] + nums[i])*(mid - i + 1);\\n                \\n                if(sum >= k)\\n                    end = mid-1;\\n                else{\\n                    count = mid;\\n                    beg = mid+1;\\n                }\\n            }\\n            \\n            if(count != -1)\\n                ans += count-i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139617,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        int n = nums.size();\\n        \\n        long long count = 0;\\n        \\n        long long curr_sum = 0;\\n        \\n        int left = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            curr_sum += nums[right];\\n            \\n            while(left <= right && (long long) (curr_sum) * (long long) (right - left + 1) >= k)\\n            {\\n                curr_sum -= nums[left];\\n                \\n                left++;\\n            }\\n            \\n            count += right - left + 1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        int n = nums.size();\\n        \\n        long long count = 0;\\n        \\n        long long curr_sum = 0;\\n        \\n        int left = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            curr_sum += nums[right];\\n            \\n            while(left <= right && (long long) (curr_sum) * (long long) (right - left + 1) >= k)\\n            {\\n                curr_sum -= nums[left];\\n                \\n                left++;\\n            }\\n            \\n            count += right - left + 1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139568,
                "title": "c-sliding-window",
                "content": "```\\n    public long CountSubarrays(int[] nums, long k)\\n    {\\n        long sum = 0;\\n        long result = 0;\\n        int left = 0;\\n        for (int right = 0; right < nums.Length; right++)\\n        {\\n            sum += nums[right];\\n            while (sum * (right - left + 1) >= k)\\n                sum -= nums[left++];\\n            result += right - left + 1;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n    public long CountSubarrays(int[] nums, long k)\\n    {\\n        long sum = 0;\\n        long result = 0;\\n        int left = 0;\\n        for (int right = 0; right < nums.Length; right++)\\n        {\\n            sum += nums[right];\\n            while (sum * (right - left + 1) >= k)\\n                sum -= nums[left++];\\n            result += right - left + 1;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139516,
                "title": "c-easy-to-understand-2-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        int n = nums.size();\\n        long long sum = 0ll;\\n        \\n        long long cnt = 0ll;\\n        \\n        for(long long i=0ll,j=0ll;i<n and j<n;i++)\\n        {\\n            sum += nums[i];\\n            \\n            if(sum*(i-j+1)<k)\\n            {\\n                long long len = i-j+1;\\n                \\n                cnt += (len+1)*len/2;\\n                cnt -= (len)*(len-1)/2;\\n            }else\\n            {\\n                while(j<n and sum*(i-j+1)>=k)\\n                sum -= nums[j++];\\n                \\n                long long len = i-j+1;\\n                \\n                cnt += (len+1)*len/2;\\n                cnt -= (len)*(len-1)/2;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        int n = nums.size();\\n        long long sum = 0ll;\\n        \\n        long long cnt = 0ll;\\n        \\n        for(long long i=0ll,j=0ll;i<n and j<n;i++)\\n        {\\n            sum += nums[i];\\n            \\n            if(sum*(i-j+1)<k)\\n            {\\n                long long len = i-j+1;\\n                \\n                cnt += (len+1)*len/2;\\n                cnt -= (len)*(len-1)/2;\\n            }else\\n            {\\n                while(j<n and sum*(i-j+1)>=k)\\n                sum -= nums[j++];\\n                \\n                long long len = i-j+1;\\n                \\n                cnt += (len+1)*len/2;\\n                cnt -= (len)*(len-1)/2;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139479,
                "title": "two-pointer-c-approach",
                "content": "``` // Observations \\n        // Sum and length both increases if we add element in subarray\\n        // We just need to create all intervals which contains valid subarrays\\n        // Two Pointer Approach For Finding valid Intervals\\n        int N = a.size();\\n        long long l = 0,r = 0;\\n        long long sum = 0;\\n        map <long long ,long long> m;\\n        // Map to Store Intervals <starting index,ending index> \\n        while(r < N)\\n        {\\n            long long score = (sum + a[r])*(r-l+1);\\n            // In case of valid subarray add it to map and increment end pointer to increase sum and length (score)\\n            if(score < k)\\n            {\\n                sum += a[r];\\n                m[l] = r;\\n                r++;\\n            }\\n            // In case of invalid subarray decrease score by removing starting index of subbarray \\n            else\\n            {\\n                sum -= a[l];\\n                l++;\\n            }\\n        }\\n        vector <pair<long long,long long>> v;\\n        // Vector of pairs for storing intervals\\n        for(auto x: m)\\n        v.push_back(x);\\n        int z = v.size();\\n        // If [a,b]  is valid interval and number of subarrays in this interval are ([b-a+1]*[b-a+1] + [b-a+1])/2  \\n        long long int x = v[0].second - v[0].first + 1;\\n        // Adding first interval to answer\\n        long long ans = (x*x + x)/2;\\n        for(int i = 1; i < z ; i++)\\n        {\\n            // Incase of overlapping intervals decrement the overlapping interval since they are counted twice\\n            // For example [1,5] and [2,6] are intervals then add (sub({1,5})) and (sub({2,6})) and minus sub{2,5}\\n            long long int x = v[i].second - v[i].first + 1;\\n            ans += (x*x + x)/2;\\n            if(v[i].first <= v[i-1].second)\\n            {\\n                long long int y = v[i-1].second - v[i].first + 1;\\n                ans -= (y*y + y)/2;\\n            }\\n        }\\n        return ans;",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "``` // Observations \\n        // Sum and length both increases if we add element in subarray\\n        // We just need to create all intervals which contains valid subarrays\\n        // Two Pointer Approach For Finding valid Intervals\\n        int N = a.size();\\n        long long l = 0,r = 0;\\n        long long sum = 0;\\n        map <long long ,long long> m;\\n        // Map to Store Intervals <starting index,ending index> \\n        while(r < N)\\n        {\\n            long long score = (sum + a[r])*(r-l+1);\\n            // In case of valid subarray add it to map and increment end pointer to increase sum and length (score)\\n            if(score < k)\\n            {\\n                sum += a[r];\\n                m[l] = r;\\n                r++;\\n            }\\n            // In case of invalid subarray decrease score by removing starting index of subbarray \\n            else\\n            {\\n                sum -= a[l];\\n                l++;\\n            }\\n        }\\n        vector <pair<long long,long long>> v;\\n        // Vector of pairs for storing intervals\\n        for(auto x: m)\\n        v.push_back(x);\\n        int z = v.size();\\n        // If [a,b]  is valid interval and number of subarrays in this interval are ([b-a+1]*[b-a+1] + [b-a+1])/2  \\n        long long int x = v[0].second - v[0].first + 1;\\n        // Adding first interval to answer\\n        long long ans = (x*x + x)/2;\\n        for(int i = 1; i < z ; i++)\\n        {\\n            // Incase of overlapping intervals decrement the overlapping interval since they are counted twice\\n            // For example [1,5] and [2,6] are intervals then add (sub({1,5})) and (sub({2,6})) and minus sub{2,5}\\n            long long int x = v[i].second - v[i].first + 1;\\n            ans += (x*x + x)/2;\\n            if(v[i].first <= v[i-1].second)\\n            {\\n                long long int y = v[i-1].second - v[i].first + 1;\\n                ans -= (y*y + y)/2;\\n            }\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2139402,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n     \\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        vector<long long> pre(n);\\n        pre[0]=nums[0];\\n        for(long long i=1;i<n;i++){\\n            pre[i]=nums[i]+pre[i-1];\\n        }\\n        long long x=0;\\n        for(long long i=0;i<n;i++){\\n            long long l=i,h=n-1;\\n            long long fac=i==0?0:pre[i-1];\\n            while(l<=h){\\n                long long m=(l+h)/2;\\n                if((pre[m]-fac)*(m-i+1)>=k) h=m-1;\\n                else l=m+1;\\n            }\\n            x+=h-i+1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        vector<long long> pre(n);\\n        pre[0]=nums[0];\\n        for(long long i=1;i<n;i++){\\n            pre[i]=nums[i]+pre[i-1];\\n        }\\n        long long x=0;\\n        for(long long i=0;i<n;i++){\\n            long long l=i,h=n-1;\\n            long long fac=i==0?0:pre[i-1];\\n            while(l<=h){\\n                long long m=(l+h)/2;\\n                if((pre[m]-fac)*(m-i+1)>=k) h=m-1;\\n                else l=m+1;\\n            }\\n            x+=h-i+1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139284,
                "title": "simple-sliding-window",
                "content": "Here am using a variable size sliding window and storing sum of that sliding window.If product of Sum and length of sliding window is greater or equal to k then i am reducing the sliding window size till the product of sum and length of sliding window  becames lesser than k.\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        long long ans = 0;\\n        int left = 0,right = 0;\\n        long long sum = 0;\\n        \\n        while(right < nums.size()) {\\n            sum += nums[right];\\n            long long x = sum * (right - left + 1);\\n            \\n            while(left <= right and x >= k) {\\n                sum -= nums[left];\\n                left++;\\n                x = sum * (right - left + 1);\\n            }\\n            \\n            ans += (right - left + 1);\\n            \\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        long long ans = 0;\\n        int left = 0,right = 0;\\n        long long sum = 0;\\n        \\n        while(right < nums.size()) {\\n            sum += nums[right];\\n            long long x = sum * (right - left + 1);\\n            \\n            while(left <= right and x >= k) {\\n                sum -= nums[left];\\n                left++;\\n                x = sum * (right - left + 1);\\n            }\\n            \\n            ans += (right - left + 1);\\n            \\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139196,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& arr, long long k) {\\n       long long i = 0;\\n        long long j = 0;\\n        long long sum = 0;\\n        long long res = 0;\\n        while(j<arr.size()){\\n            sum+=arr[j];\\n            long long div = sum*(j-i+1);\\n            while(div>=k){\\n                sum-=arr[i];\\n                i++;\\n                div = sum*(j-i+1);\\n            }\\n                res+=(j-i+1);\\n                j++;\\n            \\n            \\n        }\\n        return res;\\n \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& arr, long long k) {\\n       long long i = 0;\\n        long long j = 0;\\n        long long sum = 0;\\n        long long res = 0;\\n        while(j<arr.size()){\\n            sum+=arr[j];\\n            long long div = sum*(j-i+1);\\n            while(div>=k){\\n                sum-=arr[i];\\n                i++;\\n                div = sum*(j-i+1);\\n            }\\n                res+=(j-i+1);\\n                j++;\\n            \\n            \\n        }\\n        return res;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139194,
                "title": "c-binary-search-prefix-sums",
                "content": "```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\n#define pb push_back\\n#define ll long long\\nconst int MOD = 1e9 + 7, N = 200005;\\nconst ll INF = 2e18;\\ntypedef pair<int, int> pii;\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\ntemplate <class T> inline void chmin(T &x,T y){ x = min((x), (y));}\\ntemplate <typename T> T powm(T a,T b, ll m){T cnt=1; while(b>0) { if(b%2==1) cnt=(cnt*a)%m; b/=2; a=(a*a)%m; }return cnt%m;}\\ntemplate <typename T> T gcd(T a,T b) {if(a==0) return b; return gcd(b%a,a);}\\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        long long ans = 0;\\n        int n = sz(a);\\n        vector <ll> pre(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n          pre[i + 1] = pre[i] + a[i];\\n        }\\n        // for (int i = 1; i <= n; ++i) {\\n        //   cout << pre[i] << \" \";\\n        // }\\n        // cout << \\'\\\\n\\';\\n        for (int i = 1; i <= n; ++i) {\\n          int l = i, r = n;\\n          int take = -1;\\n          while (l <= r) {\\n            int mid = (l + r) >> 1;\\n            long long sum = pre[mid] - pre[i - 1];\\n            long long len = mid - i + 1;\\n            if (sum * len < k) {\\n              take = mid;\\n              l = mid + 1;\\n            } else {\\n              r = mid - 1;\\n            }\\n          }\\n          //cout << take << \" \";\\n          if (take != -1)\\n            ans += take - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\n#define pb push_back\\n#define ll long long\\nconst int MOD = 1e9 + 7, N = 200005;\\nconst ll INF = 2e18;\\ntypedef pair<int, int> pii;\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\ntemplate <class T> inline void chmin(T &x,T y){ x = min((x), (y));}\\ntemplate <typename T> T powm(T a,T b, ll m){T cnt=1; while(b>0) { if(b%2==1) cnt=(cnt*a)%m; b/=2; a=(a*a)%m; }return cnt%m;}\\ntemplate <typename T> T gcd(T a,T b) {if(a==0) return b; return gcd(b%a,a);}\\n\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        long long ans = 0;\\n        int n = sz(a);\\n        vector <ll> pre(n + 1, 0);\\n        for (int i = 0; i < n; ++i) {\\n          pre[i + 1] = pre[i] + a[i];\\n        }\\n        // for (int i = 1; i <= n; ++i) {\\n        //   cout << pre[i] << \" \";\\n        // }\\n        // cout << \\'\\\\n\\';\\n        for (int i = 1; i <= n; ++i) {\\n          int l = i, r = n;\\n          int take = -1;\\n          while (l <= r) {\\n            int mid = (l + r) >> 1;\\n            long long sum = pre[mid] - pre[i - 1];\\n            long long len = mid - i + 1;\\n            if (sum * len < k) {\\n              take = mid;\\n              l = mid + 1;\\n            } else {\\n              r = mid - 1;\\n            }\\n          }\\n          //cout << take << \" \";\\n          if (take != -1)\\n            ans += take - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2139160,
                "title": "rust-sliding-window",
                "content": "```rust\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, k: i64) -> i64 {\\n        let mut sum = 0;\\n        let mut count = 0;\\n        let mut left = 0;\\n        for (right, &num) in nums.iter().enumerate() {\\n            sum += num as i64;\\n\\n            while sum * (right - left + 1) as i64 >= k {\\n                sum -= nums[left] as i64;\\n                left += 1;\\n            }\\n\\n            count += right - left + 1;\\n        }\\n\\n        count as i64\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, k: i64) -> i64 {\\n        let mut sum = 0;\\n        let mut count = 0;\\n        let mut left = 0;\\n        for (right, &num) in nums.iter().enumerate() {\\n            sum += num as i64;\\n\\n            while sum * (right - left + 1) as i64 >= k {\\n                sum -= nums[left] as i64;\\n                left += 1;\\n            }\\n\\n            count += right - left + 1;\\n        }\\n\\n        count as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139092,
                "title": "short-sliding-window-java-solution",
                "content": "1) If score of an array is less than k, all subarrays of that array will also have score less than k.\\n2) Use sliding window method, at each ith index, find the largest possible window with ith index as rightmost index of window.\\ne.g.\\n[35, 62, 21, (a1, a2, ....., a5,  ith) , 76, 23, 54] \\n(ith)\\n(a5, ith)\\n(a4, a5, ith)\\n(a3, a4, a5, ith)\\n(a2, a3, a4, a5, ith)\\n(a1, a2, a3, a4, a5, ith)\\nNumber of subarrays containing ith index as rightmost index = 6;\\n3) Add the size of window to subarray counter.\\n\\n\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        int count = 0;\\n        long sum = 0;\\n        long subarrs = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            count++;\\n            while (sum * count >= k) {\\n                sum -= nums[i-count+1];\\n                count--;\\n            }\\n            subarrs += count;\\n        }\\n        \\n        return subarrs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        int count = 0;\\n        long sum = 0;\\n        long subarrs = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            count++;\\n            while (sum * count >= k) {\\n                sum -= nums[i-count+1];\\n                count--;\\n            }\\n            subarrs += count;\\n        }\\n        \\n        return subarrs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139029,
                "title": "c-sliding-window-o-n-time-and-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& A, long long B) {\\n        \\n        long long res = 0,i=0,j=0,sum=0;\\n\\n        while(j<A.size()){\\n            sum = sum + A[j];\\n           // cout<<sum<<endl;\\n            if((long long)(sum*(j-i+1))<B){\\n                j++;\\n            }else{\\n\\n                while((long long)(sum*(j-i+1))>=B){\\n                    res += (j-i);\\n                    sum -= A[i];\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        res += (long long)((j-i)*(j-i+1))/2;\\n        return res;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& A, long long B) {\\n        \\n        long long res = 0,i=0,j=0,sum=0;\\n\\n        while(j<A.size()){\\n            sum = sum + A[j];\\n           // cout<<sum<<endl;\\n            if((long long)(sum*(j-i+1))<B){\\n                j++;\\n            }else{\\n\\n                while((long long)(sum*(j-i+1))>=B){\\n                    res += (j-i);\\n                    sum -= A[i];\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        res += (long long)((j-i)*(j-i+1))/2;\\n        return res;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2139027,
                "title": "python-3-solution-using-deque-12loc",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n,c,s,total=len(nums),0,0,0\\n        q=deque()\\n        for i in range(n):\\n            c+=1\\n            s+=nums[i]\\n            q.append(i)\\n            while q and (s*c)>=k:\\n                s-=nums[q.popleft()]\\n                c-=1\\n            if q and  (s*c)<k:\\n                total+=len(q)\\n        return total\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n,c,s,total=len(nums),0,0,0\\n        q=deque()\\n        for i in range(n):\\n            c+=1\\n            s+=nums[i]\\n            q.append(i)\\n            while q and (s*c)>=k:\\n                s-=nums[q.popleft()]\\n                c-=1\\n            if q and  (s*c)<k:\\n                total+=len(q)\\n        return total\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138997,
                "title": "c-o-nlogn-using-prefix-sums-and-binary-search-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // Using Prefix Sums and Binary Search\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int ans = 0, n = nums.size();\\n        if(n == 0) return 0;\\n        vector<long long> pref(n);\\n        pref[0] = nums[0];\\n        for(int i = 1; i < n; i++) { // Calculating prefix sums\\n            pref[i] = pref[i - 1] + nums[i];\\n        }\\n        for(int i = 0; i < n; i++) {\\n            // For each i, count the number of substrings of \\'nums\\' that end at \\'i\\' and have score < k\\n            int l = 0, r = i;\\n            int bestInd = i + 1; \\n            while(l <= r) { // Binary search on the index \\'bestInd\\' such that the score(substring(nums[bestInd] -> nums[i])) < k\\n                int mid = l + (r - l) / 2;\\n                long long len = i - mid + 1, sum = pref[i] - ((mid > 0) ? pref[mid - 1] : 0);\\n                if(len * sum < k) { // Valid index. So, storing bestInd and proceeding to find if any better answer exists\\n                    bestInd = mid;\\n                    r = mid - 1;\\n                } else l = mid + 1; // Invalid index, hence proceeding to go for a higher index to see if any answer exists\\n            }\\n            ans += (i - bestInd + 1); // substring(nums[bestInd] -> nums[i]) has a score < k. So, all the substrings(nums[j] -> nums[i]) where bestInd <= j <= i have a valid score as well. So, there are (i - bestInd + 1) substrings that end at \\'i\\' and are valid\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Using Prefix Sums and Binary Search\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int ans = 0, n = nums.size();\\n        if(n == 0) return 0;\\n        vector<long long> pref(n);\\n        pref[0] = nums[0];\\n        for(int i = 1; i < n; i++) { // Calculating prefix sums\\n            pref[i] = pref[i - 1] + nums[i];\\n        }\\n        for(int i = 0; i < n; i++) {\\n            // For each i, count the number of substrings of \\'nums\\' that end at \\'i\\' and have score < k\\n            int l = 0, r = i;\\n            int bestInd = i + 1; \\n            while(l <= r) { // Binary search on the index \\'bestInd\\' such that the score(substring(nums[bestInd] -> nums[i])) < k\\n                int mid = l + (r - l) / 2;\\n                long long len = i - mid + 1, sum = pref[i] - ((mid > 0) ? pref[mid - 1] : 0);\\n                if(len * sum < k) { // Valid index. So, storing bestInd and proceeding to find if any better answer exists\\n                    bestInd = mid;\\n                    r = mid - 1;\\n                } else l = mid + 1; // Invalid index, hence proceeding to go for a higher index to see if any answer exists\\n            }\\n            ans += (i - bestInd + 1); // substring(nums[bestInd] -> nums[i]) has a score < k. So, all the substrings(nums[j] -> nums[i]) where bestInd <= j <= i have a valid score as well. So, there are (i - bestInd + 1) substrings that end at \\'i\\' and are valid\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138993,
                "title": "sliding-window-python-short-and-easy-to-understand",
                "content": "Idea: \\nSolution is easy but tricky a little! We can use slidding window approach to keep elements which is still less than k, and each new added element to the window can make l new subarrays, where l is the length of window. For example, let\\'s say \\n\\n\\n[2,1,4,3,5], k =10\\nWindow -> [2],  possible subarray: [2] -> total 1\\nWindow -> [2,1],  possible subarray: [2] + [2,1], [1] -> total 3\\nNow we have to pop 2 and 1 as window became bigger then 10\\nWindow -> [4] , possible subarray: [2], [2,1], [1] + [4] -> total 4\\nAnd so on next two elements will add one new subarrays\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        l = 0\\n        cur= 0\\n        cnt=0 \\n        for i, val in enumerate(nums):\\n            cur+=val\\n            while cur*(i-l+1)>=k:\\n                cur-=nums[l]\\n                l+=1\\n            cnt+=(i-l+1)\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        l = 0\\n        cur= 0\\n        cnt=0 \\n        for i, val in enumerate(nums):\\n            cur+=val\\n            while cur*(i-l+1)>=k:\\n                cur-=nums[l]\\n                l+=1\\n            cnt+=(i-l+1)\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138902,
                "title": "python-solution-binary-search-prefix-sum",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n        pre_sum = [0]\\n        for num in nums:\\n            pre_sum.append(pre_sum[-1] + num)\\n\\n        count = 0\\n        for j in range(len(nums)):\\n            start, end = 0, j\\n            while start + 1 < end:\\n                i = start + (end - start) // 2 \\n                if (pre_sum[j + 1] - pre_sum[i]) * (j - i + 1) < k:\\n                    end = i\\n                else:\\n                    start = i\\n\\n            if (pre_sum[j + 1] - pre_sum[start]) * (j - start + 1) < k:\\n                count += j - start + 1\\n            elif (pre_sum[j + 1] - pre_sum[end])  * (j - end + 1) < k:\\n                count += j - end + 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n        pre_sum = [0]\\n        for num in nums:\\n            pre_sum.append(pre_sum[-1] + num)\\n\\n        count = 0\\n        for j in range(len(nums)):\\n            start, end = 0, j\\n            while start + 1 < end:\\n                i = start + (end - start) // 2 \\n                if (pre_sum[j + 1] - pre_sum[i]) * (j - i + 1) < k:\\n                    end = i\\n                else:\\n                    start = i\\n\\n            if (pre_sum[j + 1] - pre_sum[start]) * (j - start + 1) < k:\\n                count += j - start + 1\\n            elif (pre_sum[j + 1] - pre_sum[end])  * (j - end + 1) < k:\\n                count += j - end + 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138853,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    long long countSubarrays(vector<int>& v, long long k) {\\n        ll sz = v.size(), res = 0;\\n        vi pre(sz);\\n        pre[0] = v[0];\\n        for (ll i = 1;i < sz;i++)\\n            pre[i] = pre[i - 1] + v[i];\\n        for (ll i = 0;i < sz;++i) {\\n            ll l = i,\\n                r = sz - 1,\\n                ind = -1;\\n            while (l <= r) {\\n                ll mid = l + ((r - l) >> 1);\\n                ll score = pre[mid] - (i > 0 ? pre[i - 1] : 0);\\n                score *= mid - i + 1;\\n                if (score < k) {\\n                    ind = mid;\\n                    l = mid + 1;\\n                    continue;\\n                }\\n                r = mid - 1;\\n            }\\n            if (ind != -1)\\n                res += ind - i + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    long long countSubarrays(vector<int>& v, long long k) {\\n        ll sz = v.size(), res = 0;\\n        vi pre(sz);\\n        pre[0] = v[0];\\n        for (ll i = 1;i < sz;i++)\\n            pre[i] = pre[i - 1] + v[i];\\n        for (ll i = 0;i < sz;++i) {\\n            ll l = i,\\n                r = sz - 1,\\n                ind = -1;\\n            while (l <= r) {\\n                ll mid = l + ((r - l) >> 1);\\n                ll score = pre[mid] - (i > 0 ? pre[i - 1] : 0);\\n                score *= mid - i + 1;\\n                if (score < k) {\\n                    ind = mid;\\n                    l = mid + 1;\\n                    continue;\\n                }\\n                r = mid - 1;\\n            }\\n            if (ind != -1)\\n                res += ind - i + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138846,
                "title": "moving-window-solution-o-n-c-python",
                "content": "**Moving Window Solution**\\n- At each step of the iteration, my moving window\\'s right end will be at `i`\\n- Also, the left end of my window will be such that\\xA0\\n    - The subarray represented by that window satisfies the solution\\n    - Window is as large as possible\\n- Then, all the subarrays with an ending at `i` and that have their starting point >= `start` will also satisfy the condition. Thus, I add `i - start + 1` to the answer in each iteration\\n\\nIn code, window is `nums[start ... i]` and `cur_sum` is the current sum of the window\\n\\n**Python**\\n```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        start, cur_sum, ans = 0, 0, 0\\n        # inv: cur_sum = sum(nums[start, ..., i])\\n        for i, num in enumerate(nums):\\n            cur_sum += num\\n            # size of window = i - start + 1\\n            while cur_sum * (i - start + 1) >= k:\\n                cur_sum -= nums[start]\\n                start += 1\\n            # assert: start <= i + 1\\n            ans += (i - start + 1)\\n        return ans\\n\\n```\\n\\n**C++**\\n```c++\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int start = 0, n = nums.size();\\n        ll cur_sum = 0, ans = 0;\\n        // inv: cur_sum = sum(nums[start, ..., i])\\n        for (int i = 0; i < n; i++) {\\n            cur_sum += nums[i];\\n            // size of window = i - start + 1\\n            while (cur_sum * (i - start + 1) >= k) {\\n                cur_sum -= nums[start];\\n                start += 1;\\n            }\\n            // assert: start <= i + 1\\n            ans += (i - start + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time complexity**\\n- I increase `start` and `i` at max n times, thus time complexity is `O(2 * n) = O(n)`\\n- You might wonder how the complexity of time is O(n) if I have two loops. In the while loop, I\\'m making the incrementing the variable `start`. But in the overall run, `start` can be increased a maximum of n times (because `start <= i + 1`). This means that inner while loop was called a maximum of n times in the overall run.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        start, cur_sum, ans = 0, 0, 0\\n        # inv: cur_sum = sum(nums[start, ..., i])\\n        for i, num in enumerate(nums):\\n            cur_sum += num\\n            # size of window = i - start + 1\\n            while cur_sum * (i - start + 1) >= k:\\n                cur_sum -= nums[start]\\n                start += 1\\n            # assert: start <= i + 1\\n            ans += (i - start + 1)\\n        return ans\\n\\n```\n```c++\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int start = 0, n = nums.size();\\n        ll cur_sum = 0, ans = 0;\\n        // inv: cur_sum = sum(nums[start, ..., i])\\n        for (int i = 0; i < n; i++) {\\n            cur_sum += nums[i];\\n            // size of window = i - start + 1\\n            while (cur_sum * (i - start + 1) >= k) {\\n                cur_sum -= nums[start];\\n                start += 1;\\n            }\\n            // assert: start <= i + 1\\n            ans += (i - start + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138816,
                "title": "two-pointer-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        vector<long long> check(n,0);\\n        \\n        //Store Prefix Sum\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                check[i]=(long long)nums[i];\\n            }\\n            else\\n                check[i]=((long long)nums[i]+check[i-1]);\\n        }\\n        \\n        \\n        long long ans=0;\\n        long long temp=0;\\n        int i=0;int j=0;\\n        \\n        //Use Two Pointer to track the sum not greater or equal to K\\n        while(i<n && j<n){\\n            if(nums[j]>=k){\\n                j++;\\n                i=j;\\n            }\\n            else{\\n                if(i==0)\\n                    temp=((long long)check[j]*(j+1));\\n                else\\n                    temp=((long long)(check[j]-check[i-1])*(j-i+1));              \\n                while(j>i && temp>=k){\\n                    if(i==0){\\n                        temp=((long long)check[j]*(j+1));\\n                    }\\n                    else\\n                        temp=((long long)(check[j]-check[i-1])*(j-i+1));\\n                    if(temp>=k)\\n                        i++; \\n                }\\n                ans+=((long long)(j-i+1));               \\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        vector<long long> check(n,0);\\n        \\n        //Store Prefix Sum\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                check[i]=(long long)nums[i];\\n            }\\n            else\\n                check[i]=((long long)nums[i]+check[i-1]);\\n        }\\n        \\n        \\n        long long ans=0;\\n        long long temp=0;\\n        int i=0;int j=0;\\n        \\n        //Use Two Pointer to track the sum not greater or equal to K\\n        while(i<n && j<n){\\n            if(nums[j]>=k){\\n                j++;\\n                i=j;\\n            }\\n            else{\\n                if(i==0)\\n                    temp=((long long)check[j]*(j+1));\\n                else\\n                    temp=((long long)(check[j]-check[i-1])*(j-i+1));              \\n                while(j>i && temp>=k){\\n                    if(i==0){\\n                        temp=((long long)check[j]*(j+1));\\n                    }\\n                    else\\n                        temp=((long long)(check[j]-check[i-1])*(j-i+1));\\n                    if(temp>=k)\\n                        i++; \\n                }\\n                ans+=((long long)(j-i+1));               \\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097228,
                "title": "time-complexity-100-beats-and-space-complexity-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc countSubarrays(nums []int, k int64) int64 {\\n    l,r,count,sum:=0,0,0,0\\n    for ;r<len(nums);r++{\\n        sum+=nums[r]\\n        for {\\n         if int64(sum*(r-l+1))<k{\\n             break\\n         }\\n        sum-=nums[l]\\n        l++\\n        }\\n        count+=r-l+1\\n    }\\n    return int64(count)\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nfunc countSubarrays(nums []int, k int64) int64 {\\n    l,r,count,sum:=0,0,0,0\\n    for ;r<len(nums);r++{\\n        sum+=nums[r]\\n        for {\\n         if int64(sum*(r-l+1))<k{\\n             break\\n         }\\n        sum-=nums[l]\\n        l++\\n        }\\n        count+=r-l+1\\n    }\\n    return int64(count)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083923,
                "title": "c-sliding-window-two-pointers-linear-time-o-n",
                "content": "# Approach\\nSliding window logic to store sum of the sliding window and increase and decrease the pointer\\'s location based on conditions on \\'k\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) if creating new array for prefix sum\\nO(1) if using a sum variable for window sum\\n\\n# Code\\n1. Using prefix array as prefix sum\\n```\\nclass Solution {\\npublic:\\n    long long getScore(int l, int r, vector<long long> &ps) {\\n        if(l == 0) return (long long)(ps[r]*(r+1));\\n        return (long long)((ps[r]-ps[l-1])*(r-l+1));\\n    }\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        vector<long long> nums(a.size());\\n        nums[0]=a[0];\\n        for(int i=1;i<nums.size();i++) nums[i]+=(a[i]+nums[i-1]);\\n        int i=0;\\n        int j=0;\\n        long long ans = 0;\\n        while(i<nums.size() && j<nums.size()) {\\n            long long curr = getScore(i,j,nums);\\n            if(curr < k) {\\n                ans += (j-i+1);\\n                j++;\\n            } else {\\n                curr = getScore(i,j,nums);\\n                while(i<=j && curr >= k) {\\n                    i++;\\n                    curr = getScore(i,j,nums);\\n                }\\n                if(i>j) j=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n2. Using sum variable to store sliding window sum\\n```\\nclass Solution {\\npublic:\\n    long long getScore(int l, int r, long long sum) {\\n        if(l == 0) return (long long)(sum*(r+1));\\n        return (long long)((sum)*(r-l+1));\\n    }\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i=0;\\n        long long sum = nums[0];\\n        int j=0;\\n        long long ans = 0;\\n        while(i<nums.size() && j<nums.size()) {\\n            long long curr = getScore(i,j,sum);\\n            if(curr < k) {\\n                ans += (j-i+1);\\n                j++;\\n                if(j<nums.size()) sum += nums[j];\\n            } else {\\n                curr = getScore(i,j,sum);\\n                while(i<=j && curr >= k) {\\n                    sum -= nums[i];\\n                    i++;\\n                    curr = getScore(i,j,sum);\\n                }\\n                if(i>j) {\\n                    j=i;\\n                    if(j<nums.size()) sum += nums[j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getScore(int l, int r, vector<long long> &ps) {\\n        if(l == 0) return (long long)(ps[r]*(r+1));\\n        return (long long)((ps[r]-ps[l-1])*(r-l+1));\\n    }\\n    long long countSubarrays(vector<int>& a, long long k) {\\n        vector<long long> nums(a.size());\\n        nums[0]=a[0];\\n        for(int i=1;i<nums.size();i++) nums[i]+=(a[i]+nums[i-1]);\\n        int i=0;\\n        int j=0;\\n        long long ans = 0;\\n        while(i<nums.size() && j<nums.size()) {\\n            long long curr = getScore(i,j,nums);\\n            if(curr < k) {\\n                ans += (j-i+1);\\n                j++;\\n            } else {\\n                curr = getScore(i,j,nums);\\n                while(i<=j && curr >= k) {\\n                    i++;\\n                    curr = getScore(i,j,nums);\\n                }\\n                if(i>j) j=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long getScore(int l, int r, long long sum) {\\n        if(l == 0) return (long long)(sum*(r+1));\\n        return (long long)((sum)*(r-l+1));\\n    }\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i=0;\\n        long long sum = nums[0];\\n        int j=0;\\n        long long ans = 0;\\n        while(i<nums.size() && j<nums.size()) {\\n            long long curr = getScore(i,j,sum);\\n            if(curr < k) {\\n                ans += (j-i+1);\\n                j++;\\n                if(j<nums.size()) sum += nums[j];\\n            } else {\\n                curr = getScore(i,j,sum);\\n                while(i<=j && curr >= k) {\\n                    sum -= nums[i];\\n                    i++;\\n                    curr = getScore(i,j,sum);\\n                }\\n                if(i>j) {\\n                    j=i;\\n                    if(j<nums.size()) sum += nums[j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081774,
                "title": "prefixsum-with-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBuild prefix sum first and use it with sliding window approach.\\n\\n# Complexity \\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long result = 0L;\\n        long [] prefixSum = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < prefixSum.length; i++)\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n\\n        for (int right = 0, left = 0; right < nums.length; right++) {\\n            long curr = (prefixSum[right] - prefixSum[left] + nums[left]) * (right - left + 1);\\n            while(curr >= k) {\\n                left++;\\n                if(left == nums.length) break; // break if left is out of bounds\\n                curr = (prefixSum[right] - prefixSum[left] + nums[left]) * (right - left + 1);\\n            }\\n            result += (right - left + 1);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long result = 0L;\\n        long [] prefixSum = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < prefixSum.length; i++)\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n\\n        for (int right = 0, left = 0; right < nums.length; right++) {\\n            long curr = (prefixSum[right] - prefixSum[left] + nums[left]) * (right - left + 1);\\n            while(curr >= k) {\\n                left++;\\n                if(left == nums.length) break; // break if left is out of bounds\\n                curr = (prefixSum[right] - prefixSum[left] + nums[left]) * (right - left + 1);\\n            }\\n            result += (right - left + 1);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039132,
                "title": "variation-of-subarray-product-less-than-k-simple-optimal-with-explanations",
                "content": "# Intuition\\nThis Problem is a variation of [713. Subarray Product Less Than K]().In this problem we have to calculate those subarrays whose **sum multiplied by size of subarray is should be less than k**.\\n- We solve this problems using Sliding Window.\\n- We have to extract those subarray  whose **sum multiplied by size of subarray is should be less than k**.here sliding window help us to extract those subarrays.\\n- Because if we closely observe then we get that we have to maintain the sum of subarrays in some how.we maintain the sum using **prefix sum** concept.\\n- prefix sum is nothing but the sum of current index of array including sum of previous indexes.\\n- if we get the **sum multiplied by size of subarray is should be less than k** greater than k i.e.**product>=k** then we do:\\n1. then we start removing the values from sum from starting index until we get the **sum multiplied by size of subarray is should be less than k**.When we get then we simply add the size of window to the answer.\\n2. DO A DRY RUN OF THIS EXAMPLE AND YOU WILL GET THE INTUITION\\n3. EXAMPLE: nums[4,1,6,5,7,3,2] k=25\\n4. comment what is the output of this example after that i will tell correct output \\n# Approach\\n- simply define some variables prefix_sum,product,size;\\n- Now start traversing array and do:\\n1. add array value to the prefix_sum.\\n2. extract size by j-i+1\\n3. calculate the product = sum*size.\\n4. Now if we get the product>=k then we start removing element from sum because our sum has all element since starting until we get product<k. Everytime while removing element we also have to update index i to forward.\\n5. now add window size to our ans variable.\\n#           PLEASE UPVOTE IF YOU LIKE MY SOLUTION  \\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) \\n    {\\n        int n = nums.size();\\n        long long ans = 0;\\n         //for calculating product\\n        long long product=1;\\n         //for calculating product\\n        long long prefix_sum=0;\\n        //for calculating window size\\n        int size=0;\\n        int i=0;\\n         //traversing array\\n        for(int j=0;j<n;j++)\\n        {\\n         //add value to the prefix sum \\n            prefix_sum+=nums[j];\\n         //extract window size\\n            size = j-i+1;\\n            //perform product \\n            product=(sum*size);\\n            //check product is less than k or not\\n            while(product>=k)\\n            {\\n            //extract value from prefixsum\\n                sum-=nums[i];\\n            //update starting index\\n                i++;\\n            //after extracting check for next productt\\n                size=j-i+1;\\n                product=(sum*size);\\n            }\\n        //add window size to our ans\\n            ans += j-i+1;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) \\n    {\\n        int n = nums.size();\\n        long long ans = 0;\\n         //for calculating product\\n        long long product=1;\\n         //for calculating product\\n        long long prefix_sum=0;\\n        //for calculating window size\\n        int size=0;\\n        int i=0;\\n         //traversing array\\n        for(int j=0;j<n;j++)\\n        {\\n         //add value to the prefix sum \\n            prefix_sum+=nums[j];\\n         //extract window size\\n            size = j-i+1;\\n            //perform product \\n            product=(sum*size);\\n            //check product is less than k or not\\n            while(product>=k)\\n            {\\n            //extract value from prefixsum\\n                sum-=nums[i];\\n            //update starting index\\n                i++;\\n            //after extracting check for next productt\\n                size=j-i+1;\\n                product=(sum*size);\\n            }\\n        //add window size to our ans\\n            ans += j-i+1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005844,
                "title": "binary-search-rightmost-index",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        p = [0] * (n + 1)\\n        for i in range(n):\\n            p[i + 1] += p[i] + nums[i]\\n        res = 0\\n        for i in range(n):\\n            beg = i\\n            end = n - 1\\n            curr = i - 1\\n            while beg <= end:\\n                mid = (beg + end) // 2\\n                if (p[mid + 1] - p[i]) * (mid - i + 1) < k:\\n                    curr = mid\\n                    beg = mid + 1\\n                else:\\n                    end = mid - 1\\n            res += curr - i + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        p = [0] * (n + 1)\\n        for i in range(n):\\n            p[i + 1] += p[i] + nums[i]\\n        res = 0\\n        for i in range(n):\\n            beg = i\\n            end = n - 1\\n            curr = i - 1\\n            while beg <= end:\\n                mid = (beg + end) // 2\\n                if (p[mid + 1] - p[i]) * (mid - i + 1) < k:\\n                    curr = mid\\n                    beg = mid + 1\\n                else:\\n                    end = mid - 1\\n            res += curr - i + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001273,
                "title": "best-solution-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHello...Namaste..!!\\nHere We have used the Sliding Window or 2 Pointer Approach. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach is that We are starting with the `start = 0` and going tol the end starting from `end = 0` and once the value of `sum` is greater then the `k` we are increasing the value of `start` and subracting the indeex value from the `sum` else we are inceasing the `end`.\\n\\nSee the code for better understanding.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int l=0;\\n        int r=0;\\n        long long int ans = 0;\\n        long long int sum = 0;\\n\\n\\n        while(l<nums.size()){\\n        \\n            while(r<nums.size() && (sum+nums[r])*(r-l+1)<k){\\n                sum+=nums[r];\\n                r++;\\n            }\\n            ans+=(r-l);\\n            sum-=nums[l];\\n            l++;\\n            cout<<sum<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int l=0;\\n        int r=0;\\n        long long int ans = 0;\\n        long long int sum = 0;\\n\\n\\n        while(l<nums.size()){\\n        \\n            while(r<nums.size() && (sum+nums[r])*(r-l+1)<k){\\n                sum+=nums[r];\\n                r++;\\n            }\\n            ans+=(r-l);\\n            sum-=nums[l];\\n            l++;\\n            cout<<sum<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3995205,
                "title": "sliding-window-solution-typeo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long count=0;\\n        long cur =0;\\n        for(int i=0, j=0; i<nums.length; i++){\\n            cur += nums[i];\\n            while(cur*(i-j+1) >= k){\\n                cur -= nums[j];\\n                j++;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long count=0;\\n        long cur =0;\\n        for(int i=0, j=0; i<nums.length; i++){\\n            cur += nums[i];\\n            while(cur*(i-j+1) >= k){\\n                cur -= nums[j];\\n                j++;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975868,
                "title": "sliding-window-approch-o-n",
                "content": "# Intuition\\n$score(l,r)<=score(l,r+1)$. So we can use the sliding window approch.\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) \\n    {\\n        long long int head=-1,tail=0,sum=0,score=0,count=0;\\n        long long int n=a.size();\\n\\n        while(tail<n)\\n        {\\n            while(head+1<n && ((sum+a[head+1])*(head+1-tail+1))<k)\\n            {\\n                head++;\\n                sum+=a[head];\\n            }\\n\\n            count+=head-tail+1;\\n\\n            if(tail>head)\\n            {\\n                tail++;\\n                head=tail-1;\\n            }\\n            else \\n            {\\n                sum-=a[tail];\\n                tail++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& a, long long k) \\n    {\\n        long long int head=-1,tail=0,sum=0,score=0,count=0;\\n        long long int n=a.size();\\n\\n        while(tail<n)\\n        {\\n            while(head+1<n && ((sum+a[head+1])*(head+1-tail+1))<k)\\n            {\\n                head++;\\n                sum+=a[head];\\n            }\\n\\n            count+=head-tail+1;\\n\\n            if(tail>head)\\n            {\\n                tail++;\\n                head=tail-1;\\n            }\\n            else \\n            {\\n                sum-=a[tail];\\n                tail++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975005,
                "title": "python3-easiest-solution-for-beginners",
                "content": "# honestly i randomly coded it with 0 intension passing all test cases but some how.... it passed LOL ... :)\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        count=0\\n        l=0\\n        r=0\\n        sumi=0\\n        while r<len(nums):\\n            sumi+=nums[r]\\n            if sumi*(r-l+1)<k:\\n                count+=r-l+1\\n                r+=1\\n            elif sumi*(r-l+1)>=k:\\n                sumi-=nums[l]\\n                sumi-=nums[r]\\n                l+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        count=0\\n        l=0\\n        r=0\\n        sumi=0\\n        while r<len(nums):\\n            sumi+=nums[r]\\n            if sumi*(r-l+1)<k:\\n                count+=r-l+1\\n                r+=1\\n            elif sumi*(r-l+1)>=k:\\n                sumi-=nums[l]\\n                sumi-=nums[r]\\n                l+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965377,
                "title": "direct-approach-using-dart",
                "content": "\\n\\n# Dart Code\\n```\\nclass Solution {\\n  int countSubarrays(List<int> nums, int k) {\\n        int ans = 0, count = 0;\\n        for (int j = 0, i = 0; j < nums.length; j++) {\\n            count += nums[j];\\n            while (count * (j - i + 1) >= k)\\n                count -= nums[i++];\\n            ans += j - i + 1;\\n        }\\n        return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart",
                    "Array",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n  int countSubarrays(List<int> nums, int k) {\\n        int ans = 0, count = 0;\\n        for (int j = 0, i = 0; j < nums.length; j++) {\\n            count += nums[j];\\n            while (count * (j - i + 1) >= k)\\n                count -= nums[i++];\\n            ans += j - i + 1;\\n        }\\n        return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943759,
                "title": "java-prefix-sum-sliding-window-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        \\n        int n = nums.length;\\n        long subarrays = 0;\\n        long prefixSum = 0;\\n\\n        int start = 0;\\n        int end = 0;\\n\\n        while(end < n){\\n\\n            prefixSum += nums[end];\\n\\n            while(prefixSum * (end - start + 1) >= k){\\n\\n                prefixSum -= nums[start++];\\n            }\\n\\n            subarrays += (end - start + 1);\\n\\n            end++;\\n        }\\n        return subarrays;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        \\n        int n = nums.length;\\n        long subarrays = 0;\\n        long prefixSum = 0;\\n\\n        int start = 0;\\n        int end = 0;\\n\\n        while(end < n){\\n\\n            prefixSum += nums[end];\\n\\n            while(prefixSum * (end - start + 1) >= k){\\n\\n                prefixSum -= nums[start++];\\n            }\\n\\n            subarrays += (end - start + 1);\\n\\n            end++;\\n        }\\n        return subarrays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942019,
                "title": "easiest-approch-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO ( n )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO ( 1 )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int sum = 0,score = 0,i = 0,j = 0,ans = 0;\\n\\n        long long int n = nums.size();\\n        while(i<n && j<n){\\n            sum += nums[j];// window expansion --->\\n            score = sum*(j-i+1);\\n            while(i<=j && score>=k){\\n                // window contraction ---> \\n                sum -= nums[i++];\\n                score = sum*(j-i+1);\\n            }\\n            ans += (j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int sum = 0,score = 0,i = 0,j = 0,ans = 0;\\n\\n        long long int n = nums.size();\\n        while(i<n && j<n){\\n            sum += nums[j];// window expansion --->\\n            score = sum*(j-i+1);\\n            while(i<=j && score>=k){\\n                // window contraction ---> \\n                sum -= nums[i++];\\n                score = sum*(j-i+1);\\n            }\\n            ans += (j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940690,
                "title": "easy-sliding-window-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        int n=nums.length;\\n\\n        int i=0;\\n        int j=0;\\n        long ans=0;\\n        long prod=0;\\n        long sum=0;\\n        while(i<nums.length){\\n            sum+=nums[i];\\n            prod=sum*(i-j+1);\\n\\n                while(prod>=k){\\n                    sum-=nums[j];\\n                    j++;\\n                    prod=sum*(i-j+1);\\n                }\\n            \\n            ans+=(i-j+1);\\n            i++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        int n=nums.length;\\n\\n        int i=0;\\n        int j=0;\\n        long ans=0;\\n        long prod=0;\\n        long sum=0;\\n        while(i<nums.length){\\n            sum+=nums[i];\\n            prod=sum*(i-j+1);\\n\\n                while(prod>=k){\\n                    sum-=nums[j];\\n                    j++;\\n                    prod=sum*(i-j+1);\\n                }\\n            \\n            ans+=(i-j+1);\\n            i++;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938606,
                "title": "c-solution-94-77-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i = 0;\\n        int j = 0;\\n        long long sum = 0;\\n        long long count = 0;\\n        while(j<nums.size()){\\n            sum = sum + nums[j];\\n            if(sum*(j-i+1)<k){\\n                count = count + (j-i+1);\\n                j++;\\n            }\\n            else if(sum*(j-i+1)>=k){\\n                sum = sum - nums[i];\\n                if(sum>0){\\n                    sum = sum - nums[j];\\n                }\\n                i++;\\n            }\\n\\n            if(i>j){\\n                j = i;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i = 0;\\n        int j = 0;\\n        long long sum = 0;\\n        long long count = 0;\\n        while(j<nums.size()){\\n            sum = sum + nums[j];\\n            if(sum*(j-i+1)<k){\\n                count = count + (j-i+1);\\n                j++;\\n            }\\n            else if(sum*(j-i+1)>=k){\\n                sum = sum - nums[i];\\n                if(sum>0){\\n                    sum = sum - nums[j];\\n                }\\n                i++;\\n            }\\n\\n            if(i>j){\\n                j = i;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938604,
                "title": "java-solution-3ms-84-93-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        int i = 0;\\n        int j = 0;\\n        long sum = 0;\\n        long count = 0;\\n        while(j<nums.length){\\n            sum = sum + nums[j];\\n            if(sum*(j-i+1)<k){\\n                count = count + (j-i+1);\\n                j++;\\n            }\\n            else if(sum*(j-i+1)>=k){\\n                sum = sum - nums[i];\\n                if(sum>0){\\n                    sum = sum - nums[j];\\n                }\\n                i++;\\n            }\\n\\n            if(i>j){\\n                j = i;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        int i = 0;\\n        int j = 0;\\n        long sum = 0;\\n        long count = 0;\\n        while(j<nums.length){\\n            sum = sum + nums[j];\\n            if(sum*(j-i+1)<k){\\n                count = count + (j-i+1);\\n                j++;\\n            }\\n            else if(sum*(j-i+1)>=k){\\n                sum = sum - nums[i];\\n                if(sum>0){\\n                    sum = sum - nums[j];\\n                }\\n                i++;\\n            }\\n\\n            if(i>j){\\n                j = i;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932909,
                "title": "beats-90-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding Window\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple dynamic sliding window approach to solve the problem\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) beats 90% \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) constant space\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        \\n        // sliding window;\\n         // while max has to be less than k\\n        \\n        int i=0;\\n        int len=0;\\n        long sum=0;\\n        long count=0;\\n        boolean recede=false;\\n        while(i<nums.length){\\n             if(!recede){\\n             len++;\\n             sum+=nums[i];\\n             }\\n            if(sum*len<k  && len>0){\\n              count+=len;\\n              i++;\\n              recede=false;\\n            }else if(len==0){\\n                recede=false;\\n                i++;\\n            }else{\\n             sum-=nums[i-len+1];\\n             len--;\\n              recede=true;\\n            }\\n        }\\n       return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        \\n        // sliding window;\\n         // while max has to be less than k\\n        \\n        int i=0;\\n        int len=0;\\n        long sum=0;\\n        long count=0;\\n        boolean recede=false;\\n        while(i<nums.length){\\n             if(!recede){\\n             len++;\\n             sum+=nums[i];\\n             }\\n            if(sum*len<k  && len>0){\\n              count+=len;\\n              i++;\\n              recede=false;\\n            }else if(len==0){\\n                recede=false;\\n                i++;\\n            }else{\\n             sum-=nums[i-len+1];\\n             len--;\\n              recede=true;\\n            }\\n        }\\n       return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930845,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long ans=0;\\n        long sum=0;\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            if((sum*(i-start+1))<k)\\n            {\\n                   ans+=i-start+1;\\n            }\\n            else\\n            {\\n                for(int j=start;j<=i;j++)\\n                {\\n                    sum=sum-nums[j];\\n                    start++;\\n                    if((sum*(i-start+1))<k)\\n                    {\\n                        ans+=i-start+1;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long ans=0;\\n        long sum=0;\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            if((sum*(i-start+1))<k)\\n            {\\n                   ans+=i-start+1;\\n            }\\n            else\\n            {\\n                for(int j=start;j<=i;j++)\\n                {\\n                    sum=sum-nums[j];\\n                    start++;\\n                    if((sum*(i-start+1))<k)\\n                    {\\n                        ans+=i-start+1;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926738,
                "title": "short-and-simple-beats-99-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\"Number of subarray with XYZ condition\" , this implies there has to be asliding window solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust take the prefix sum and stimulate the given condition just like standard variable size sliding window problems.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        vector<long long int>presum(nums.size());\\n        presum[0]=nums[0];\\n        for(int i=0;i<nums.size()-1;i++){\\n            presum[i+1]=presum[i]+nums[i+1];\\n        }\\n        int i=0,j=0;\\n        long long int ans=0;\\n        while(j<nums.size()){\\n           /* if(i==0){\\n                while((j-i+1)*presum[j]>=k && i<j){\\n                    i++;\\n                }\\n                 ans+=(j-i+1);\\n                j++;\\n                continue;\\n            }*/\\n           while((j-i+1)*(presum[j]-((i==0)?0:presum[i-1]))>=k && j>=i){\\n               i++;\\n           }\\n           ans+=(j-i+1);\\n           j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        vector<long long int>presum(nums.size());\\n        presum[0]=nums[0];\\n        for(int i=0;i<nums.size()-1;i++){\\n            presum[i+1]=presum[i]+nums[i+1];\\n        }\\n        int i=0,j=0;\\n        long long int ans=0;\\n        while(j<nums.size()){\\n           /* if(i==0){\\n                while((j-i+1)*presum[j]>=k && i<j){\\n                    i++;\\n                }\\n                 ans+=(j-i+1);\\n                j++;\\n                continue;\\n            }*/\\n           while((j-i+1)*(presum[j]-((i==0)?0:presum[i-1]))>=k && j>=i){\\n               i++;\\n           }\\n           ans+=(j-i+1);\\n           j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923118,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size(),i = 0,j = 0;\\n        long long sum = 0,ans = 0;\\n        while(j < n){\\n            sum += nums[j];\\n            if(sum * (j-i+1) < k){\\n                ans += j-i+1;\\n                j++;\\n            }else{\\n                while(sum * (j-i+1) >= k){\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n                ans += j-i+1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size(),i = 0,j = 0;\\n        long long sum = 0,ans = 0;\\n        while(j < n){\\n            sum += nums[j];\\n            if(sum * (j-i+1) < k){\\n                ans += j-i+1;\\n                j++;\\n            }else{\\n                while(sum * (j-i+1) >= k){\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n                ans += j-i+1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917666,
                "title": "easy-code-with-a-template-for-similar-problems",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        //strictly less than k hai \\n        int st=0;long long sum=0;long long ans=0;\\n        for(int end=0;end<nums.size();end++){\\n            sum+=nums[end];\\n            while(sum*(end-st+1)>=k){\\n                sum-=nums[st];\\n                st++;\\n            }\\n            ans+=end-st+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        //strictly less than k hai \\n        int st=0;long long sum=0;long long ans=0;\\n        for(int end=0;end<nums.size();end++){\\n            sum+=nums[end];\\n            while(sum*(end-st+1)>=k){\\n                sum-=nums[st];\\n                st++;\\n            }\\n            ans+=end-st+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909622,
                "title": "problem-with-subarray-with-score-than-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        sums=res=i=0\\n        for r,num in enumerate(nums):\\n            sums+=num\\n            while sums*(r-i+1)>=k:\\n                sums-=nums[i]\\n                i+=1\\n            res+=r-i+1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        sums=res=i=0\\n        for r,num in enumerate(nums):\\n            sums+=num\\n            while sums*(r-i+1)>=k:\\n                sums-=nums[i]\\n                i+=1\\n            res+=r-i+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872152,
                "title": "sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        int l = 0, r=0;\\n        long long currSum = 0, count =0;\\n        while(r < n){\\n            if(nums[r] >= k){\\n                l = r+ 1;\\n                currSum = 0;\\n            }\\n            else{\\n                count++;\\n                currSum += nums[r];\\n                \\n                while(currSum*(r-l+1) >= k){\\n                    currSum -= nums[l];\\n                    l++;\\n                }\\n                count += r - l;\\n            }\\n            r++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        int l = 0, r=0;\\n        long long currSum = 0, count =0;\\n        while(r < n){\\n            if(nums[r] >= k){\\n                l = r+ 1;\\n                currSum = 0;\\n            }\\n            else{\\n                count++;\\n                currSum += nums[r];\\n                \\n                while(currSum*(r-l+1) >= k){\\n                    currSum -= nums[l];\\n                    l++;\\n                }\\n                count += r - l;\\n            }\\n            r++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859324,
                "title": "python-fasters-than-98-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a subarray fits the restrain, then all subarraries of this subarray can fit the restrain.\\n\\nTherefore, we can find non-extenable subarraries which fit the restrain to cacluate the total number of subarraries. \\n\\nThere might be overlap between two non-extenable subarraries, thus we need to delete the subarray number in the overlapped section.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing sliding window to find the non-extenable subarray.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$, due to the sliding window approach\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$, the memory will not increase as the arrary length increases\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        @cache\\n        def len2cnt(maxlen: int) -> int:\\n            # count the number of subarraries in the non-extenable subarray\\n            if maxlen == 1:\\n                return 1\\n            return (1 + maxlen) * maxlen // 2\\n        \\n        # sliding window to find the max len of subarr\\n        segend = -1 # last non-extenable subarray ending index\\n        out = 0 # output\\n        left, right = 0, 0 # 2 pointers of sliding window\\n        curr_sum = 0\\n        next_score = lambda: (curr_sum + nums[right]) * (right - left + 1)\\n        get_score = lambda: curr_sum * (right - left)\\n        while True:\\n            if right < len(nums) and next_score() < k:\\n                curr_sum += nums[right]\\n                right += 1\\n            else:\\n                # then we found a non-extenable one\\n                out += len2cnt(right - left)\\n                if left < segend:\\n                    out -= len2cnt(segend - left)\\n                segend = right\\n                \\n                # update two pointers\\n                if right >= len(nums):\\n                    break\\n                curr_sum += nums[right] - nums[left]\\n                left += 1\\n                right += 1\\n                while get_score() >= k:\\n                    curr_sum -= nums[left]\\n                    left += 1\\n        return out\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        @cache\\n        def len2cnt(maxlen: int) -> int:\\n            # count the number of subarraries in the non-extenable subarray\\n            if maxlen == 1:\\n                return 1\\n            return (1 + maxlen) * maxlen // 2\\n        \\n        # sliding window to find the max len of subarr\\n        segend = -1 # last non-extenable subarray ending index\\n        out = 0 # output\\n        left, right = 0, 0 # 2 pointers of sliding window\\n        curr_sum = 0\\n        next_score = lambda: (curr_sum + nums[right]) * (right - left + 1)\\n        get_score = lambda: curr_sum * (right - left)\\n        while True:\\n            if right < len(nums) and next_score() < k:\\n                curr_sum += nums[right]\\n                right += 1\\n            else:\\n                # then we found a non-extenable one\\n                out += len2cnt(right - left)\\n                if left < segend:\\n                    out -= len2cnt(segend - left)\\n                segend = right\\n                \\n                # update two pointers\\n                if right >= len(nums):\\n                    break\\n                curr_sum += nums[right] - nums[left]\\n                left += 1\\n                right += 1\\n                while get_score() >= k:\\n                    curr_sum -= nums[left]\\n                    left += 1\\n        return out\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852266,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst expand the window and if score greater than or equal to k after that contract the window.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        long long i = 0, j = 0, sum = 0, score = 0;\\n        long long ans = 0;\\n        while(j<n){\\n            sum += nums[j]; // expansion\\n            score = sum*(j-i+1);\\n            while(i<=j && score>=k){\\n                sum -= nums[i++]; // contraction\\n                score = sum * (j-i+1);\\n            }\\n            ans += (j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        long long i = 0, j = 0, sum = 0, score = 0;\\n        long long ans = 0;\\n        while(j<n){\\n            sum += nums[j]; // expansion\\n            score = sum*(j-i+1);\\n            while(i<=j && score>=k){\\n                sum -= nums[i++]; // contraction\\n                score = sum * (j-i+1);\\n            }\\n            ans += (j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831753,
                "title": "beats-99-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i =0;\\n        int j =0;\\n        int n = nums.size();\\n        long long sum=0;\\n        long long count=0;\\n        while(j<n){\\n            sum+=nums[j];\\n            // if(nums[j]*1<k){\\n            //     count++;\\n            // }\\n           long long pro = (long long) (j-i+1)*(long long)sum;\\n            if(pro>=k){\\n                while((j-i+1)*sum>=k){\\n                sum-=nums[i];\\n                i++;\\n              }\\n            }\\n             if((j-i+1)*sum<k){\\n                count+=j-i+1;\\n            }\\n           \\n            j++;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i =0;\\n        int j =0;\\n        int n = nums.size();\\n        long long sum=0;\\n        long long count=0;\\n        while(j<n){\\n            sum+=nums[j];\\n            // if(nums[j]*1<k){\\n            //     count++;\\n            // }\\n           long long pro = (long long) (j-i+1)*(long long)sum;\\n            if(pro>=k){\\n                while((j-i+1)*sum>=k){\\n                sum-=nums[i];\\n                i++;\\n              }\\n            }\\n             if((j-i+1)*sum<k){\\n                count+=j-i+1;\\n            }\\n           \\n            j++;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800737,
                "title": "c-easy-sliding-window",
                "content": "# Intuition\\n\\n# Approach\\nSliding Window\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, long k) \\n    {\\n        int n = nums.Length;\\n\\n         int start = 0;\\n         long p = 1;\\n         long sum = 0;\\n\\n          long res = 0;\\n\\n         for(int end = 0; end < n; end++)\\n         {\\n             // perform\\n             sum += nums[end];\\n             p = sum * (end - start + 1);\\n\\n             // make window valid\\n             while(p >= k)\\n             {\\n                 sum -= nums[start++];\\n                 p = sum * (end - start + 1);\\n             }\\n\\n             // calc result\\n             res += end - start + 1;\\n         }\\n\\n         return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, long k) \\n    {\\n        int n = nums.Length;\\n\\n         int start = 0;\\n         long p = 1;\\n         long sum = 0;\\n\\n          long res = 0;\\n\\n         for(int end = 0; end < n; end++)\\n         {\\n             // perform\\n             sum += nums[end];\\n             p = sum * (end - start + 1);\\n\\n             // make window valid\\n             while(p >= k)\\n             {\\n                 sum -= nums[start++];\\n                 p = sum * (end - start + 1);\\n             }\\n\\n             // calc result\\n             res += end - start + 1;\\n         }\\n\\n         return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784839,
                "title": "simple-solution-using-python-and-dart",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Python\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n      count=last=first=s=0\\n      while last<len(nums):\\n        s+=nums[last]\\n        while s*(last-first+1)>=k:\\n          s-=nums[first]\\n          first+=1\\n        count+=(last-first+1)\\n        last+=1\\n      return count\\n```\\n\\n# Dart\\n``` dart\\nclass Solution {\\n  int countSubarrays(List<int> nums, int k) {\\n    int count=0;\\n    int last=0,first=0;\\n    int sum = 0;\\n    while(last<nums.length){\\n      sum+=nums[last];\\n      while(sum*(last-first+1)>=k){\\n        sum-=nums[first];\\n        first++;\\n      }\\n      count+=(last-first+1);\\n      last++;\\n    }\\n    return count;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Dart",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n      count=last=first=s=0\\n      while last<len(nums):\\n        s+=nums[last]\\n        while s*(last-first+1)>=k:\\n          s-=nums[first]\\n          first+=1\\n        count+=(last-first+1)\\n        last+=1\\n      return count\\n```\n``` dart\\nclass Solution {\\n  int countSubarrays(List<int> nums, int k) {\\n    int count=0;\\n    int last=0,first=0;\\n    int sum = 0;\\n    while(last<nums.length){\\n      sum+=nums[last];\\n      while(sum*(last-first+1)>=k){\\n        sum-=nums[first];\\n        first++;\\n      }\\n      count+=(last-first+1);\\n      last++;\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784838,
                "title": "simple-solution-using-python-and-dart",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Python\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n      count=last=first=s=0\\n      while last<len(nums):\\n        s+=nums[last]\\n        while s*(last-first+1)>=k:\\n          s-=nums[first]\\n          first+=1\\n        count+=(last-first+1)\\n        last+=1\\n      return count\\n```\\n\\n# Dart\\n``` dart\\nclass Solution {\\n  int countSubarrays(List<int> nums, int k) {\\n    int count=0;\\n    int last=0,first=0;\\n    int sum = 0;\\n    while(last<nums.length){\\n      sum+=nums[last];\\n      while(sum*(last-first+1)>=k){\\n        sum-=nums[first];\\n        first++;\\n      }\\n      count+=(last-first+1);\\n      last++;\\n    }\\n    return count;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Dart",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n      count=last=first=s=0\\n      while last<len(nums):\\n        s+=nums[last]\\n        while s*(last-first+1)>=k:\\n          s-=nums[first]\\n          first+=1\\n        count+=(last-first+1)\\n        last+=1\\n      return count\\n```\n``` dart\\nclass Solution {\\n  int countSubarrays(List<int> nums, int k) {\\n    int count=0;\\n    int last=0,first=0;\\n    int sum = 0;\\n    while(last<nums.length){\\n      sum+=nums[last];\\n      while(sum*(last-first+1)>=k){\\n        sum-=nums[first];\\n        first++;\\n      }\\n      count+=(last-first+1);\\n      last++;\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780442,
                "title": "easy-and-precise-c-code",
                "content": "After solving this problem visit the problem- https://leetcode.com/problems/subarray-product-less-than-k/description/ \\nand its solution- https://leetcode.com/problems/subarray-product-less-than-k/solutions/3780441/easy-precise-code-c/\\nThis both problems are pretty closely related.\\n\\nThis code is an implementation of a function that calculates the number of subarrays in a given vector `nums` whose sum is less than or equal to a given value `k`. It also uses the sliding window technique to efficiently find these subarrays.\\n\\n\\n1. The `countSubarrays` function is defined, which takes a vector of integers `nums` and a long long integer `k` as input and returns the count of subarrays satisfying the condition.\\n\\n2. Three variables `c`, `s`, `i`, and `j` are initialized.\\n   - `c` will store the final count of subarrays satisfying the condition.\\n   - `s` is used to keep track of the current sum of elements within the sliding window.\\n   - `i` and `j` are two pointers that mark the left and right boundaries of the sliding window, respectively.\\n\\n3. A `while` loop is used to iterate through the `nums` vector. The loop continues as long as the `j` pointer is less than the size of the `nums` vector.\\n\\n4. Inside the loop, the current element `nums[j]` is added to the `s`, updating the current sum.\\n\\n5. A nested `while` loop is used to adjust the sliding window boundaries (`i` and `j`) based on the current sum (`s`) and the given `k`.\\n   - The inner loop continues as long as the product of the current sum and the length of the current subarray (`j - i + 1`) is greater than or equal to `k`.\\n   - Within the inner loop, the value at index `i` is subtracted from the `s`, and `i` is incremented to move the left boundary of the sliding window forward.\\n   - This process continues until the product of the current sum and the length of the current subarray is less than `k`.\\n\\n6. After exiting the inner loop, the count of valid subarrays is updated by adding the length of the current subarray (`j - i + 1`) to `c`. This is because every valid subarray ending at index `j` and starting from index `i` contributes to the count.\\n\\n7. The `j` pointer is then incremented to move the right boundary of the sliding window forward, and the loop continues to process the next element.\\n\\n8. Once the loop completes, the `c` variable contains the total count of subarrays whose sum is less than or equal to `k`. The function returns this count as the final result.\\n\\nIn summary, the code efficiently calculates the number of subarrays in the given vector `nums` with a sum less than or equal to `k` by utilizing the sliding window technique. The inner while loop adjusts the window boundaries based on the sum, allowing the code to efficiently find all subarrays satisfying the condition. The final count is returned as the result.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long c=0, s=0;\\n        int i=0, j=0;\\n        while(j<nums.size())\\n        {\\n            s+= nums[j];\\n            while(s*(j-i+1)>=k)\\n            {\\n                s-=nums[i];\\n                i++;\\n            }\\n            c+=j-i+1;\\n            j++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long c=0, s=0;\\n        int i=0, j=0;\\n        while(j<nums.size())\\n        {\\n            s+= nums[j];\\n            while(s*(j-i+1)>=k)\\n            {\\n                s-=nums[i];\\n                i++;\\n            }\\n            c+=j-i+1;\\n            j++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768451,
                "title": "c-easy-to-understand-sliding-window-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n\\n        int head = 0;\\n        int tail = 0;\\n        long long ans = 0;\\n        long long sum = 0;\\n\\n        for (; head < n; head++) {\\n            sum += nums[head];\\n            while (sum*(head-tail+1) >= k) {\\n                sum -= nums[tail];\\n                tail++;\\n            }\\n            ans += head - tail + 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n\\n        int head = 0;\\n        int tail = 0;\\n        long long ans = 0;\\n        long long sum = 0;\\n\\n        for (; head < n; head++) {\\n            sum += nums[head];\\n            while (sum*(head-tail+1) >= k) {\\n                sum -= nums[tail];\\n                tail++;\\n            }\\n            ans += head - tail + 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768434,
                "title": "c-easy-to-understand-sliding-window-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        // auto calculateScore = [](int sum, int size) {\\n        //     return 1ll * sum * size;\\n        // };\\n        //when I was using this lambda function, it shows incorrect output for testcase 166.\\n\\n        int head = 0;\\n        int tail = 0;\\n        long long ans = 0;\\n        long long sum = 0;\\n\\n        for (; head < n; head++) {\\n            sum += nums[head];\\n            while (sum*(head-tail+1) >= k) {\\n                sum -= nums[tail];\\n                tail++;\\n            }\\n            ans += head - tail + 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        // auto calculateScore = [](int sum, int size) {\\n        //     return 1ll * sum * size;\\n        // };\\n        //when I was using this lambda function, it shows incorrect output for testcase 166.\\n\\n        int head = 0;\\n        int tail = 0;\\n        long long ans = 0;\\n        long long sum = 0;\\n\\n        for (; head < n; head++) {\\n            sum += nums[head];\\n            while (sum*(head-tail+1) >= k) {\\n                sum -= nums[tail];\\n                tail++;\\n            }\\n            ans += head - tail + 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761949,
                "title": "96-beats-two-pointer-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i=0,j=0,n=nums.size();\\n        long long ans=0,sum=0;\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            if(sum*(j-i+1)*1ll<k)\\n            ans+=j++-i+1;\\n            else \\n            sum-=(nums[i++]+nums[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i=0,j=0,n=nums.size();\\n        long long ans=0,sum=0;\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            if(sum*(j-i+1)*1ll<k)\\n            ans+=j++-i+1;\\n            else \\n            sum-=(nums[i++]+nums[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758348,
                "title": "sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nums.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n       if(k<=1) return 0;//if k<=1 then return because nums[i]>=1 \\n        int i=0;\\n        int j=0;\\n       long long int product=0;\\n       long long int sub=0;\\n       long long int count=0;\\n        while(i<nums.size()){\\n            if(product*count<k){\\n                if(j==nums.size()){\\n                    while(i<j){\\n                        sub+=j-i;\\n                        i++;\\n                    }\\n                }\\n              else  {\\n                product+=nums[j++];\\n                count++;}\\n            }\\n            else{\\n                while(product*count>=k){\\n                    sub+=j-i-1;\\n                    count--;\\n                    product-=nums[i++];\\n                }\\n            }\\n        }\\n        return sub;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n       if(k<=1) return 0;//if k<=1 then return because nums[i]>=1 \\n        int i=0;\\n        int j=0;\\n       long long int product=0;\\n       long long int sub=0;\\n       long long int count=0;\\n        while(i<nums.size()){\\n            if(product*count<k){\\n                if(j==nums.size()){\\n                    while(i<j){\\n                        sub+=j-i;\\n                        i++;\\n                    }\\n                }\\n              else  {\\n                product+=nums[j++];\\n                count++;}\\n            }\\n            else{\\n                while(product*count>=k){\\n                    sub+=j-i-1;\\n                    count--;\\n                    product-=nums[i++];\\n                }\\n            }\\n        }\\n        return sub;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755354,
                "title": "sliding-window-simple-sort-of-explained",
                "content": "# Approach\\nCheck the Sliding Window code template here: https://leetcode.com/explore/interview/card/cheatsheets/720/resources/4723/\\n\\nFirst, to spare you some headaches, use $$long$$ variables instead of $$int$$. \\n\\nThe approach is the standard one, just keep track of the `sum` and update it whenever the window boundaries change (`left` or `right` variables). Based on the sum, compute the score further used in the \"*window condition*\". \\n\\n---\\n\\nNow what I guess that makes this a $$hard$$ problem instead of a $$medium$$ one, gets down to undestanding that each valid `nums[right]` element will count as `right - left + 1` (window size) valid solutions. In other words, when a `[left, right]` window is valid, all other `[left + 1, right], [left + 2, right] ....  [right, right]` windows are also valid, because all their scores will be less than the larger `[left, right]` window\\'s score.\\n\\n\\nPlease, press the **upvote** button below if this helped. **Thank you!**\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, long k) \\n    {\\n        int left = 0;\\n        long sum = 0, score = 0, count = 0;\\n\\n        for(int right = 0; right < nums.Length; right++)\\n        {\\n            sum += nums[right];\\n            score = sum * (right - left + 1);\\n\\n            while (score >= k && left <= right)\\n            {\\n                sum -= nums[left];\\n                left++;\\n                score = sum * (right - left + 1);\\n            } \\n\\n            count += right - left + 1;\\n        }\\n       \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, long k) \\n    {\\n        int left = 0;\\n        long sum = 0, score = 0, count = 0;\\n\\n        for(int right = 0; right < nums.Length; right++)\\n        {\\n            sum += nums[right];\\n            score = sum * (right - left + 1);\\n\\n            while (score >= k && left <= right)\\n            {\\n                sum -= nums[left];\\n                left++;\\n                score = sum * (right - left + 1);\\n            } \\n\\n            count += right - left + 1;\\n        }\\n       \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750532,
                "title": "sliding-window-o-n-just-two-pointer-and-one-static-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSubarray Question is like Counting cases with `feed-forward way`\\n\\nand Sliding window is Just adding once and subtracting once\\n\\n> pick first current `i` position and add `nums[i]` to `current dp`\\n\\n> decide is current status is valid `if current_sum * (length of sub-array) < k: add (r-l+1) else 0`\\n\\n> adjust sub-array range with `left and right ptr`\\n> if current status not valid, shrink subarray with `left ++`\\n> if current status is valid, then find next `right++`\\n\\n\\n\\n```\\neg, \\nif nums is [1,3,5,50] and k is 120\\n\\nl:0 r:0 res:0 -> subarray :[1], res += (0-0+1) \\nadd case || [1]\\n\\nl:0 r:1 res:1 -> subarray :[1,3], then res += (1-0+1) \\nadd case || [3], [1,3]\\n\\nl:0 r:2 res:3 -> subarray :[1,3,5] then res += (2-0+1)\\nadd case || [5], [3,5] , [1,3,5]\\n\\nl:0 r:3 res :6 -> subarray :[1,3,5,50] it is not valid so, shrink l++\\nl:1 r:3 res :6 -> subarray : [3,5,50]  not valid , l++\\nl:2 r:3 res :6 -> subarray : [5,50] then res += (3-2+1)\\nadd case || [50], [5,50]\\nl:3 r:4 res : 8  -> end of the array\\n\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        l,r = 0, 0\\n        res = 0\\n        m = len(nums)\\n        cur = 0\\n        while r < m :\\n            \\n            cur += nums[r]\\n            if cur * (r-l+1) < k:\\n                res += (r-l+1)\\n            \\n            while cur*(r-l+1) >=k:\\n                cur -= nums[l]\\n                l+=1\\n                if cur * (r-l+1) <k:\\n                    res += (r-l+1)\\n            r += 1\\n\\n        \\n        return res \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Memoization",
                    "Sliding Window"
                ],
                "code": "```\\neg, \\nif nums is [1,3,5,50] and k is 120\\n\\nl:0 r:0 res:0 -> subarray :[1], res += (0-0+1) \\nadd case || [1]\\n\\nl:0 r:1 res:1 -> subarray :[1,3], then res += (1-0+1) \\nadd case || [3], [1,3]\\n\\nl:0 r:2 res:3 -> subarray :[1,3,5] then res += (2-0+1)\\nadd case || [5], [3,5] , [1,3,5]\\n\\nl:0 r:3 res :6 -> subarray :[1,3,5,50] it is not valid so, shrink l++\\nl:1 r:3 res :6 -> subarray : [3,5,50]  not valid , l++\\nl:2 r:3 res :6 -> subarray : [5,50] then res += (3-2+1)\\nadd case || [50], [5,50]\\nl:3 r:4 res : 8  -> end of the array\\n\\n```\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        l,r = 0, 0\\n        res = 0\\n        m = len(nums)\\n        cur = 0\\n        while r < m :\\n            \\n            cur += nums[r]\\n            if cur * (r-l+1) < k:\\n                res += (r-l+1)\\n            \\n            while cur*(r-l+1) >=k:\\n                cur -= nums[l]\\n                l+=1\\n                if cur * (r-l+1) <k:\\n                    res += (r-l+1)\\n            r += 1\\n\\n        \\n        return res \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743961,
                "title": "beats-100-of-the-other-solution-using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        l , r = 0 , 0\\n        res = 0\\n        tot = 0\\n        for i in range(len(nums)):\\n            tot+=nums[i]\\n            r+=1\\n            score = tot*r\\n            while score>=k:\\n                tot-=nums[l]\\n                l+=1\\n                r-=1\\n                score = tot*r\\n            res+=r\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        l , r = 0 , 0\\n        res = 0\\n        tot = 0\\n        for i in range(len(nums)):\\n            tot+=nums[i]\\n            r+=1\\n            score = tot*r\\n            while score>=k:\\n                tot-=nums[l]\\n                l+=1\\n                r-=1\\n                score = tot*r\\n            res+=r\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728709,
                "title": "aditya-verma-c-sliding-window-solution-two-pointers-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long  i=0;\\n        long long  j=0;\\n        long long  sum=0;\\n        long long score=0;\\n        long long res=0;\\n        while(j<nums.size()){\\n            long long size=j-i+1;\\n            sum+=nums[j];\\n            score=(sum*size);\\n            while(score>=k && i<=j){\\n             sum-=nums[i];\\n             score=sum*((j-i+1)-1);\\n             i++;\\n            }\\n            if(score<k) res+=j-i+1;\\n            j++;     \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long  i=0;\\n        long long  j=0;\\n        long long  sum=0;\\n        long long score=0;\\n        long long res=0;\\n        while(j<nums.size()){\\n            long long size=j-i+1;\\n            sum+=nums[j];\\n            score=(sum*size);\\n            while(score>=k && i<=j){\\n             sum-=nums[i];\\n             score=sum*((j-i+1)-1);\\n             i++;\\n            }\\n            if(score<k) res+=j-i+1;\\n            j++;     \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724317,
                "title": "c-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long sum = 0, count = 0, temp = 0, res = 0;\\n        int head = 0, tail = 0;\\n\\n        for (head = 0; head < nums.size(); head++) {\\n            sum += nums[head];\\n            temp = sum * (head-tail+1);\\n            while (temp >= k) {\\n                sum -= nums[tail];\\n                tail++;\\n                temp = sum * (head-tail+1);\\n                \\n            }\\n            res += (head - tail + 1);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long sum = 0, count = 0, temp = 0, res = 0;\\n        int head = 0, tail = 0;\\n\\n        for (head = 0; head < nums.size(); head++) {\\n            sum += nums[head];\\n            temp = sum * (head-tail+1);\\n            while (temp >= k) {\\n                sum -= nums[tail];\\n                tail++;\\n                temp = sum * (head-tail+1);\\n                \\n            }\\n            res += (head - tail + 1);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718982,
                "title": "c-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long int ind ( long long int i, long long int n, vector<long long int>& sum, vector<int>& nums, long long int k ) {\\n\\n        long long int ans = -1;\\n\\n        long long int s = i;\\n        long long int e = n-1;\\n\\n        long long int mid = s + (e-s)/2;\\n\\n        while ( s<=e ) {\\n\\n            if ( (sum[mid]-sum[i]+nums[i])*(mid-i+1) < k ) {\\n                ans = mid;\\n                s = mid + 1;\\n            }\\n\\n            else {\\n                e = mid - 1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        long long int ans = 0;\\n\\n        long long int n = nums.size();\\n        \\n        vector <long long int> sum(n);\\n        sum[0] = nums[0];\\n        for ( long long int i=1; i<n; i++ ) {\\n            sum[i] = sum[i-1] + nums[i];\\n        }\\n\\n        for ( long long int i=0; i<n; i++ ) {\\n\\n            long long int j = ind(i,n,sum,nums,k);\\n\\n            if ( j != -1 ) {\\n                ans += j-i+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long int ind ( long long int i, long long int n, vector<long long int>& sum, vector<int>& nums, long long int k ) {\\n\\n        long long int ans = -1;\\n\\n        long long int s = i;\\n        long long int e = n-1;\\n\\n        long long int mid = s + (e-s)/2;\\n\\n        while ( s<=e ) {\\n\\n            if ( (sum[mid]-sum[i]+nums[i])*(mid-i+1) < k ) {\\n                ans = mid;\\n                s = mid + 1;\\n            }\\n\\n            else {\\n                e = mid - 1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        long long int ans = 0;\\n\\n        long long int n = nums.size();\\n        \\n        vector <long long int> sum(n);\\n        sum[0] = nums[0];\\n        for ( long long int i=1; i<n; i++ ) {\\n            sum[i] = sum[i-1] + nums[i];\\n        }\\n\\n        for ( long long int i=0; i<n; i++ ) {\\n\\n            long long int j = ind(i,n,sum,nums,k);\\n\\n            if ( j != -1 ) {\\n                ans += j-i+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718647,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        long long int ans = 0;\\n\\n        int n = nums.size();\\n        int s = 0;\\n        int e = 0;\\n        long long int sum = 0;\\n\\n        while ( e<n ) {\\n\\n            sum += nums[e];\\n\\n            while ( sum*(e-s+1) >= k ) {\\n                sum -= nums[s];\\n                s++;\\n            }\\n\\n            ans += e-s+1;\\n\\n            e++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        \\n        long long int ans = 0;\\n\\n        int n = nums.size();\\n        int s = 0;\\n        int e = 0;\\n        long long int sum = 0;\\n\\n        while ( e<n ) {\\n\\n            sum += nums[e];\\n\\n            while ( sum*(e-s+1) >= k ) {\\n                sum -= nums[s];\\n                s++;\\n            }\\n\\n            ans += e-s+1;\\n\\n            e++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715250,
                "title": "easy-solution-using-concept-of-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans=0,sum=0,p=1;\\n        int n=nums.size(),len=0;\\n\\n        for(int i=0,j=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            len++;\\n\\n            p=sum*len;\\n\\n            while(p>=k and j<i)\\n            {\\n                sum-=nums[j];\\n                len--;\\n                p=sum*len;\\n                j++;\\n            }\\n\\n            if(p<k)\\n            {\\n                ans+=(i-j+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans=0,sum=0,p=1;\\n        int n=nums.size(),len=0;\\n\\n        for(int i=0,j=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            len++;\\n\\n            p=sum*len;\\n\\n            while(p>=k and j<i)\\n            {\\n                sum-=nums[j];\\n                len--;\\n                p=sum*len;\\n                j++;\\n            }\\n\\n            if(p<k)\\n            {\\n                ans+=(i-j+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707825,
                "title": "most-easy-c-solution-sliding-window-basic",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        long long ans=0;\\n        int i=0,j=0;\\n        long long sum=0;\\n        while(j<n){\\n            sum+=nums[j];\\n            if(sum*(j-i+1)<k){\\n                ans+=j-i+1;\\n            }\\n            else{\\n                while(sum*(j-i+1)>=k){\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n                ans+=j-i+1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        long long ans=0;\\n        int i=0,j=0;\\n        long long sum=0;\\n        while(j<n){\\n            sum+=nums[j];\\n            if(sum*(j-i+1)<k){\\n                ans+=j-i+1;\\n            }\\n            else{\\n                while(sum*(j-i+1)>=k){\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n                ans+=j-i+1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704333,
                "title": "c-sliding-window-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long cnt = 0;\\n        int n = nums.size();\\n\\n        int j = 0;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++) {\\n            sum += (long long)nums[i];\\n            sum *= (i-j+1);\\n\\n            while(sum >= k && j < n) {\\n                sum /= (i-j+1);\\n                sum -= nums[j];\\n                j++;\\n                sum *= (long long)(i-j+1);\\n            }\\n\\n            cnt += i-j+1;\\n            if(i-j+1 != 0) sum /= (i-j+1);\\n        }   \\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long cnt = 0;\\n        int n = nums.size();\\n\\n        int j = 0;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++) {\\n            sum += (long long)nums[i];\\n            sum *= (i-j+1);\\n\\n            while(sum >= k && j < n) {\\n                sum /= (i-j+1);\\n                sum -= nums[j];\\n                j++;\\n                sum *= (long long)(i-j+1);\\n            }\\n\\n            cnt += i-j+1;\\n            if(i-j+1 != 0) sum /= (i-j+1);\\n        }   \\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703349,
                "title": "beats-100-easy-solution-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long sum=0,ans=0;\\n        int n=nums.size();\\n        for(int i=0,j=0;i<n;i++){\\n            sum+=nums[i];\\n            //The size of Subarray to multiply with sum so far=i-j+1\\n            //By eliminate tail element our size automatically reduces by 1\\n            //as  per above formula of size of subarray\\n            while(sum*(i-j+1)>=k)\\n                sum-=nums[j++]; //# ans is out of while loop\\n\\n                ans+=i-j+1;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long sum=0,ans=0;\\n        int n=nums.size();\\n        for(int i=0,j=0;i<n;i++){\\n            sum+=nums[i];\\n            //The size of Subarray to multiply with sum so far=i-j+1\\n            //By eliminate tail element our size automatically reduces by 1\\n            //as  per above formula of size of subarray\\n            while(sum*(i-j+1)>=k)\\n                sum-=nums[j++]; //# ans is out of while loop\\n\\n                ans+=i-j+1;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687659,
                "title": "c-java-python-easiest-solution-6-line-solution",
                "content": "**C++ Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long cnt=0,ans=0,sum=0,i=0,j=0;\\n         while(i<nums.size()){\\n             while(j<nums.size()&&(sum+nums[j])*(j-i+1)<k){\\n                 sum +=nums[i];\\n                 j++;\\n             }\\n             ans+=j-i;\\n             sum= sum-nums[i];\\n             i++;\\n         }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```\\n\\n\\n\\n\\n**Java Solution**\\n\\n\\n```\\nimport java.util.List;\\n\\nclass Solution {\\n    public long countSubarrays(List<Integer> nums, long k) {\\n        long cnt = 0, ans = 0, sum = 0, i = 0, j = 0;\\n        while (i < nums.size()) {\\n            while (j < nums.size() && (sum + nums.get((int) j)) * (j - i + 1) < k) {\\n                sum += nums.get((int) j);\\n                j++;\\n            }\\n            ans += j - i;\\n            sum = sum - nums.get((int) i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n\\n\\n\\n**Python Code**\\n\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums, k):\\n        cnt = 0\\n        ans = 0\\n        sum = 0\\n        i = 0\\n        j = 0\\n        while i < len(nums):\\n            while j < len(nums) and (sum + nums[j]) * (j - i + 1) < k:\\n                sum += nums[j]\\n                j += 1\\n            ans += j - i\\n            sum = sum - nums[i]\\n            i += 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long cnt=0,ans=0,sum=0,i=0,j=0;\\n         while(i<nums.size()){\\n             while(j<nums.size()&&(sum+nums[j])*(j-i+1)<k){\\n                 sum +=nums[i];\\n                 j++;\\n             }\\n             ans+=j-i;\\n             sum= sum-nums[i];\\n             i++;\\n         }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```\n```\\nimport java.util.List;\\n\\nclass Solution {\\n    public long countSubarrays(List<Integer> nums, long k) {\\n        long cnt = 0, ans = 0, sum = 0, i = 0, j = 0;\\n        while (i < nums.size()) {\\n            while (j < nums.size() && (sum + nums.get((int) j)) * (j - i + 1) < k) {\\n                sum += nums.get((int) j);\\n                j++;\\n            }\\n            ans += j - i;\\n            sum = sum - nums.get((int) i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def countSubarrays(self, nums, k):\\n        cnt = 0\\n        ans = 0\\n        sum = 0\\n        i = 0\\n        j = 0\\n        while i < len(nums):\\n            while j < len(nums) and (sum + nums[j]) * (j - i + 1) < k:\\n                sum += nums[j]\\n                j += 1\\n            ans += j - i\\n            sum = sum - nums[i]\\n            i += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685708,
                "title": "10-lines-of-c-code-simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long cnt=0;\\n        long long i=0;\\n        long long j=0;\\n        long long sum=0;\\n        int n=nums.size();\\n        for(;j<n;j++)\\n        {\\n            sum+=nums[j];\\n            \\n            for(;sum*(j-i+1)>=k;i++)\\n            {\\n                sum-=nums[i];\\n            }\\n\\n            cnt+=j-i+1;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long cnt=0;\\n        long long i=0;\\n        long long j=0;\\n        long long sum=0;\\n        int n=nums.size();\\n        for(;j<n;j++)\\n        {\\n            sum+=nums[j];\\n            \\n            for(;sum*(j-i+1)>=k;i++)\\n            {\\n                sum-=nums[i];\\n            }\\n\\n            cnt+=j-i+1;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684009,
                "title": "easy-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsubarray + less than k ,it\\'s basic requirment of sliding window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe create a window of size j+1-i ,and check the condition if we matches the condition then add in our ans ,and move the window ahead.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long ans=0,cur=0;\\n        for(int i=0,j=0;j<nums.length;j++){\\n             cur+=nums[j];\\n            while(cur*(j-i+1)>=k){\\n                cur-=nums[i++];\\n            }\\n                ans+=j-i+1;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long ans=0,cur=0;\\n        for(int i=0,j=0;j<nums.length;j++){\\n             cur+=nums[j];\\n            while(cur*(j-i+1)>=k){\\n                cur-=nums[i++];\\n            }\\n                ans+=j-i+1;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673033,
                "title": "cpp-two-pointer-easy-solution-with-explanation",
                "content": "follow me on https://github.com/suuperstone/SuuperAlgorithm\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key idea is that if you add a new element to the current possible array,\\n\\n- all you need to do is **include the count of subarrays that contain that element** in the answer.\\n\\nIf you need to remove an element because the current array is not possible, there is no need to count the number of subarrays.\\n\\n# Approach\\nUsing Two pointers, we track the possible arrays. \\n\\nThe number of answers that are added when a new element can be added is equal to the **current window size**.\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Thumbs up if this code is helpful.\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int l=0, r=0;\\n        int n = nums.size();\\n        \\n        long long rst = 0;\\n        long long tmp_sum = 0;\\n        long long tmp_cnt = 1;\\n\\n        while (r<n) {\\n            tmp_sum += nums[r];\\n            if (tmp_sum * (r-l+1) < k) {\\n                rst += (r-l+1);\\n            }\\n            else {\\n                tmp_sum -= nums[l++];\\n                while (tmp_sum * (r-l+1) >= k) {\\n                    tmp_sum -= nums[l++];\\n                }\\n                rst += (r-l+1);\\n            }\\n            r++;\\n        }\\n\\n        return rst;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n// Thumbs up if this code is helpful.\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int l=0, r=0;\\n        int n = nums.size();\\n        \\n        long long rst = 0;\\n        long long tmp_sum = 0;\\n        long long tmp_cnt = 1;\\n\\n        while (r<n) {\\n            tmp_sum += nums[r];\\n            if (tmp_sum * (r-l+1) < k) {\\n                rst += (r-l+1);\\n            }\\n            else {\\n                tmp_sum -= nums[l++];\\n                while (tmp_sum * (r-l+1) >= k) {\\n                    tmp_sum -= nums[l++];\\n                }\\n                rst += (r-l+1);\\n            }\\n            r++;\\n        }\\n\\n        return rst;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657812,
                "title": "java-very-easy-sliding-window-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n         int i = 0;\\n        int j = 0;\\n        long count = 0;\\n        long sum = 0;\\n        long score = 0;\\n        while (j < nums.length) {\\n            sum += nums[j];\\n            score = sum * (j - i + 1);\\n            while (score >= k) {\\n                sum -= nums[i];\\n                i++;\\n                score = sum * (j - i + 1);\\n            }\\n            count += (j - i + 1);\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n         int i = 0;\\n        int j = 0;\\n        long count = 0;\\n        long sum = 0;\\n        long score = 0;\\n        while (j < nums.length) {\\n            sum += nums[j];\\n            score = sum * (j - i + 1);\\n            while (score >= k) {\\n                sum -= nums[i];\\n                i++;\\n                score = sum * (j - i + 1);\\n            }\\n            count += (j - i + 1);\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653588,
                "title": "binary-search-o-n-logn-o-1-don-t-click-this-for-placements",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long bs(long long k,vector<long long>&pre,long long ind){\\n        long lo = ind;\\n        long hi = pre.size()-1;\\n        long long ans = -1;\\n        while(lo <= hi){\\n            long long mid = (lo+hi)/2;\\n            long long add = 0;\\n            if(ind-1 >= 0)add = pre[ind-1];\\n            if((pre[mid]-add)*1ll*abs(mid-ind+1) < k){\\n                ans = (long long)abs(ind-mid);\\n                lo = mid+1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        if(ans == -1){\\n            return 0;\\n        }else{\\n            return ans+1ll;\\n        }\\n    }\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long>pre(n,0);\\n        pre[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i] = pre[i-1]+(long long)nums[i];\\n        }   \\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans += (bs(k,pre,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long bs(long long k,vector<long long>&pre,long long ind){\\n        long lo = ind;\\n        long hi = pre.size()-1;\\n        long long ans = -1;\\n        while(lo <= hi){\\n            long long mid = (lo+hi)/2;\\n            long long add = 0;\\n            if(ind-1 >= 0)add = pre[ind-1];\\n            if((pre[mid]-add)*1ll*abs(mid-ind+1) < k){\\n                ans = (long long)abs(ind-mid);\\n                lo = mid+1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        if(ans == -1){\\n            return 0;\\n        }else{\\n            return ans+1ll;\\n        }\\n    }\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long>pre(n,0);\\n        pre[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i] = pre[i-1]+(long long)nums[i];\\n        }   \\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans += (bs(k,pre,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645470,
                "title": "simple-sliding-window-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to make a wind where we will store sum of elements and pro for keeping product of wind and size of window .\\nWhile we have window that is fulfilling the criteria we add that to our answer and it is not then contract the window by incrementing j.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int ans = 0, pro = 1, wind = 0;\\n        int i = 0, j = 0;\\n        // increasing window by 1 size at a time\\n        for(; i< nums.size();i++){\\n            wind += nums[i];\\n            pro = 1ll*wind*(i-j+1);\\n            // reducing size till we get product less than k\\n            while(j <= i && pro >= k){\\n                wind -= nums[j++];\\n                pro = 1ll*wind*(i-j+1);\\n            }\\n            ans += i-j+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int ans = 0, pro = 1, wind = 0;\\n        int i = 0, j = 0;\\n        // increasing window by 1 size at a time\\n        for(; i< nums.size();i++){\\n            wind += nums[i];\\n            pro = 1ll*wind*(i-j+1);\\n            // reducing size till we get product less than k\\n            while(j <= i && pro >= k){\\n                wind -= nums[j++];\\n                pro = 1ll*wind*(i-j+1);\\n            }\\n            ans += i-j+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643106,
                "title": "simple-sliding-window-java-solution-beats-100",
                "content": "# Intuition\\nIf an array [a,b,c,d,e] has a score less than k, then the subarrays [b, c, d, e], [c, d, e], [d, e] and [e] and the array itself, all satisfy the condition too since the elements are positive, i.e number of subarrays = length of array.\\n\\n# Approach\\nFor every index *i*, we try to find the longest subarray ending at *i* which has score less than *k* by maintaining a *prev* pointer (sliding window) and sum of elements in subarray.\\n\\n Then for every index *i*, the number of subarrays (starting from *prev* pointer) which satisfy the condition is (*i - prev* + 1).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long ct = 0;\\n        int prev = 0;\\n        long sum = 0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            // sliding the window till condition is satisfied\\n            while(sum*(i-prev+1) >=k){\\n                sum-=nums[prev];\\n                prev++;\\n            }\\n            ct+=(i-prev+1);\\n        }\\n        return ct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countSubarrays(int[] nums, long k) {\\n        long ct = 0;\\n        int prev = 0;\\n        long sum = 0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            // sliding the window till condition is satisfied\\n            while(sum*(i-prev+1) >=k){\\n                sum-=nums[prev];\\n                prev++;\\n            }\\n            ct+=(i-prev+1);\\n        }\\n        return ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639175,
                "title": "short-and-simple-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans = 0, s = 0, e = 0, score = 0, sum = 0;\\n        for(e = 0; e < nums.size(); e++) {\\n            sum += nums[e];\\n            score = sum*(e-s+1);\\n            while(score >= k && s <= e) {\\n                sum -= nums[s++];\\n                score = sum*(e-s+1);\\n            }\\n            ans += (e-s+1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\nTC - O(n)\\nSC - O(1)",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans = 0, s = 0, e = 0, score = 0, sum = 0;\\n        for(e = 0; e < nums.size(); e++) {\\n            sum += nums[e];\\n            score = sum*(e-s+1);\\n            while(score >= k && s <= e) {\\n                sum -= nums[s++];\\n                score = sum*(e-s+1);\\n            }\\n            ans += (e-s+1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613600,
                "title": "c-sliding-window",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        ll n = nums.size(), i = 0, j = 0, sum = 0, ans = 0;\\n        while(j < n) {\\n            sum += nums[j];\\n            if(sum * (j - i + 1) < k) ans += j - i + 1;\\n            else {\\n                while(i < n and sum * (j - i + 1) >= k) {\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n                if(sum * (j - i + 1) < k) ans += j - i + 1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        ll n = nums.size(), i = 0, j = 0, sum = 0, ans = 0;\\n        while(j < n) {\\n            sum += nums[j];\\n            if(sum * (j - i + 1) < k) ans += j - i + 1;\\n            else {\\n                while(i < n and sum * (j - i + 1) >= k) {\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n                if(sum * (j - i + 1) < k) ans += j - i + 1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606128,
                "title": "java",
                "content": "```\\n class Solution {\\n        public long countSubarrays(int[] nums, long k) {\\n            long sum = 0, ans = 0;\\n            int cnt = 0, left = 0;\\n            for (int i = 0; i < nums.length; i++){\\n                sum += nums[i];\\n                cnt++;\\n                while (sum*cnt >= k) {\\n                    cnt--;\\n                    sum -= nums[left++];\\n                }\\n                if (sum*cnt < k) {\\n                    ans += i - left + 1;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n        public long countSubarrays(int[] nums, long k) {\\n            long sum = 0, ans = 0;\\n            int cnt = 0, left = 0;\\n            for (int i = 0; i < nums.length; i++){\\n                sum += nums[i];\\n                cnt++;\\n                while (sum*cnt >= k) {\\n                    cnt--;\\n                    sum -= nums[left++];\\n                }\\n                if (sum*cnt < k) {\\n                    ans += i - left + 1;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3580828,
                "title": "beats-98-9-solution-in-space-o-1-space-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst find out the number of subarray which have sum*product greater than or equal to k and then subtract it from total number of subarrays\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans = 0;\\n        long long sum = 0;\\n        int st = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            sum += nums[i];\\n            while((sum*(i+1-st)) >= k){\\n                // cout<<sum<<endl;\\n                sum -= nums[st];\\n                int rem = n - i;\\n                ans += 1LL*rem;\\n\\n                st++;\\n            }\\n        }\\n        long long total = 0;\\n        for(int i=1; i<=n; i++){\\n            total += 1LL*(n-i+1);\\n        }\\n        return total-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans = 0;\\n        long long sum = 0;\\n        int st = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            sum += nums[i];\\n            while((sum*(i+1-st)) >= k){\\n                // cout<<sum<<endl;\\n                sum -= nums[st];\\n                int rem = n - i;\\n                ans += 1LL*rem;\\n\\n                st++;\\n            }\\n        }\\n        long long total = 0;\\n        for(int i=1; i<=n; i++){\\n            total += 1LL*(n-i+1);\\n        }\\n        return total-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3577995,
                "title": "c-sliding-window-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a standard sliding window problem where we move our right pointer if sum*length < K and move our left pointer if sum*length >= K but the only catch is that we need to consider a case where the element of array is greater than K. \\nIn that case since this element will never contribute to our answer therefor we will skip this element and move to next element.\\nThe first if statement of while loop deals with this condition.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans=0;\\n        int n=nums.size();\\n        int i=0,j=0;\\n        long long sum=0;\\n        while(j<n) {\\n            if(nums[j]>=k) {\\n                j++;\\n                i=j;\\n                sum=0;\\n                continue;\\n            }\\n            sum += nums[j];\\n            if(sum*(j-i+1) < k) {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            else {\\n                while(i<n and j<n and (sum*(j-i+1) >= k)) {\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n                ans += j-i+1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long ans=0;\\n        int n=nums.size();\\n        int i=0,j=0;\\n        long long sum=0;\\n        while(j<n) {\\n            if(nums[j]>=k) {\\n                j++;\\n                i=j;\\n                sum=0;\\n                continue;\\n            }\\n            sum += nums[j];\\n            if(sum*(j-i+1) < k) {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            else {\\n                while(i<n and j<n and (sum*(j-i+1) >= k)) {\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n                ans += j-i+1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562422,
                "title": "sliding-window-template-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n       int start=0;\\n       int n=nums.size();\\n       long long ans=0;\\n       long long sum=0;\\n       for (int end=0;end<n;end++)\\n       {\\n           sum+=nums[end];\\n           while (sum*(end-start+1)>=k && start<n)\\n           {\\n               sum-=nums[start];\\n               start++;\\n           }\\n           if (sum*(end-start+1)<k)\\n             ans+=end-start+1;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n       int start=0;\\n       int n=nums.size();\\n       long long ans=0;\\n       long long sum=0;\\n       for (int end=0;end<n;end++)\\n       {\\n           sum+=nums[end];\\n           while (sum*(end-start+1)>=k && start<n)\\n           {\\n               sum-=nums[start];\\n               start++;\\n           }\\n           if (sum*(end-start+1)<k)\\n             ans+=end-start+1;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558624,
                "title": "sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach is somewhat easy to guess. We are asked to find number of **Subarrays** that satisfy the constraint. This automatically hints at the possibility of sliding window. Next, when we see the constraint, it involves sum of subarrays and also takes their length as a parameter. And with the given constraints on n, it is safe to assume that sliding windows is the answer here.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we need to set variables for the sliding window. As the subarray size is not fixed, our window will also be of variable size. Then whenever we expand our window, we need to increase the Sum of window so far, and then multiply it with size of window to check if the product is less than k or not. If less than k, this means we have found some more arrays that satisfy the constraint. The number of new arrays is exactly equal to the current size of window (Simple). If product is greater than or equal to k, we need to contract the window, obviously from the start side. We will contract till our window size becomes 0 or the contracted window satisfies our constraint. We again increment the count with size of our window.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe sliding window approach, in worst case, traverses the whole array twice, once by head and once by tail. Hence the time complexity is $$O(n)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe size of variables declared is independent of n, hence the space complexity is $$O(1)$$.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i = 0; //The start of sliding window\\n        int n = nums.size();\\n        long long int count = 0, Sum = 0;\\n        for (int j = 0; j < n; j++){ //j is end of sliding window\\n            Sum += nums[j]; //Add the end\\'s value in the Sum\\n            while (i <= j && Sum * (long long int)(j - i + 1) >= k){ //If sum exceeds, we start contracting the window, from the start side.\\n                Sum -= nums[i++]; // Decrement the value that has been removed from window while contracting\\n            }\\n            count += j - i + 1; //Add the new arrays to the count.\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int i = 0; //The start of sliding window\\n        int n = nums.size();\\n        long long int count = 0, Sum = 0;\\n        for (int j = 0; j < n; j++){ //j is end of sliding window\\n            Sum += nums[j]; //Add the end\\'s value in the Sum\\n            while (i <= j && Sum * (long long int)(j - i + 1) >= k){ //If sum exceeds, we start contracting the window, from the start side.\\n                Sum -= nums[i++]; // Decrement the value that has been removed from window while contracting\\n            }\\n            count += j - i + 1; //Add the new arrays to the count.\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541469,
                "title": "easy-c-4line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int c=0,sum=0,j=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n\\n            while(sum*(i-j+1)>=k)\\n            {\\n                sum-=nums[j];\\n                j++;\\n            }\\n            c+=(i-j+1);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long int c=0,sum=0,j=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n\\n            while(sum*(i-j+1)>=k)\\n            {\\n                sum-=nums[j];\\n                j++;\\n            }\\n            c+=(i-j+1);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541311,
                "title": "easy-c-2-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n       long long int j=0;\\n       long long int sum=0;\\n        long long int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            while(sum*(i-j+1)>=k){\\n               sum-=nums[j++];\\n            }\\n            c+=(i-j)+1;\\n        }\\n        return c;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n       long long int j=0;\\n       long long int sum=0;\\n        long long int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            while(sum*(i-j+1)>=k){\\n               sum-=nums[j++];\\n            }\\n            c+=(i-j)+1;\\n        }\\n        return c;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539447,
                "title": "two-pointer-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long getsum(vector<long long>& pre, int l, int r) {\\n        if (r < l) {\\n            return 0;\\n        }\\n        if (l == 0) {\\n            return pre[r];\\n        } else {\\n            return pre[r] - pre[l - 1];\\n        }\\n    }\\n\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long> pre(n, 0);\\n        pre[0] = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] + nums[i];\\n        }\\n\\n        int l = 0;\\n        int r = 0;\\n\\n        long long ans = 0;\\n        long long score = nums[0];\\n        while (r < n) {\\n            if (score < k) {\\n                ans++;\\n                r++;\\n                if (r < n) {\\n                    score += getsum(pre, l, r - 1) + nums[r] * 1LL * (r - l + 1);\\n                }\\n            } else {\\n                score -= 1LL * nums[l] * (r - l + 1);\\n                score -= getsum(pre, l + 1, r);\\n\\n                l++;\\n                if (r - l > 0) {\\n                    ans += (r - l);\\n                }\\n                //cout<<l<<\" \"<<r<<\" \"<<score<<endl;\\n                if (l > r) {\\n                    r++;\\n                    if (r < n) {\\n                        score = score + getsum(pre, l, r - 1) + nums[r] * (r - l + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = l + 1; i < n; i++) {\\n            ans += (n - i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long getsum(vector<long long>& pre, int l, int r) {\\n        if (r < l) {\\n            return 0;\\n        }\\n        if (l == 0) {\\n            return pre[r];\\n        } else {\\n            return pre[r] - pre[l - 1];\\n        }\\n    }\\n\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        int n = nums.size();\\n        vector<long long> pre(n, 0);\\n        pre[0] = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] + nums[i];\\n        }\\n\\n        int l = 0;\\n        int r = 0;\\n\\n        long long ans = 0;\\n        long long score = nums[0];\\n        while (r < n) {\\n            if (score < k) {\\n                ans++;\\n                r++;\\n                if (r < n) {\\n                    score += getsum(pre, l, r - 1) + nums[r] * 1LL * (r - l + 1);\\n                }\\n            } else {\\n                score -= 1LL * nums[l] * (r - l + 1);\\n                score -= getsum(pre, l + 1, r);\\n\\n                l++;\\n                if (r - l > 0) {\\n                    ans += (r - l);\\n                }\\n                //cout<<l<<\" \"<<r<<\" \"<<score<<endl;\\n                if (l > r) {\\n                    r++;\\n                    if (r < n) {\\n                        score = score + getsum(pre, l, r - 1) + nums[r] * (r - l + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = l + 1; i < n; i++) {\\n            ans += (n - i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3536945,
                "title": "c-simple-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long sum = 0;\\n        int left = 0;\\n        long long res = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            while (left <= i && sum * (i + 1 - left) >= k) {\\n                sum -= nums[left];\\n                left++;\\n            }\\n            res += i - left + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        long long sum = 0;\\n        int left = 0;\\n        long long res = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            while (left <= i && sum * (i + 1 - left) >= k) {\\n                sum -= nums[left];\\n                left++;\\n            }\\n            res += i - left + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528789,
                "title": "c-sliding-window",
                "content": "```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, long k) {\\n        long res=0;\\n        int n=nums.Length;\\n        long s=0;\\n        int l=0;\\n        for(int i=0;i<n;i++){\\n            s+=nums[i];\\n            if((s*(i-l+1))<k)\\n                continue;\\n            while((s*(i-l+1))>=k){\\n                res+=(i-l);\\n                s-=nums[l++];\\n            }\\n        }\\n        while(l<n)\\n            res+=(n-l++);\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, long k) {\\n        long res=0;\\n        int n=nums.Length;\\n        long s=0;\\n        int l=0;\\n        for(int i=0;i<n;i++){\\n            s+=nums[i];\\n            if((s*(i-l+1))<k)\\n                continue;\\n            while((s*(i-l+1))>=k){\\n                res+=(i-l);\\n                s-=nums[l++];\\n            }\\n        }\\n        while(l<n)\\n            res+=(n-l++);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518542,
                "title": "two-point-sliding-windows-in-python-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince all the numbers are positive, the monotonity is easily observed. Keeping a sliding window (l, r] in which `sum(nums[l+1:r+1]) * (r-l) < k` and sum up all subarray in the window. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy using two points l and r for the sliding window, the algorithm can be performed in $$O(n)$$. The sum of `nums[l+1:r+1]` can be updated along the sliding window. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        l = -1 \\n        s = 0\\n        ans = 0\\n        for r, v in enumerate(nums):\\n            s += v\\n            while s * (r-l) >= k and l < r:\\n                l += 1\\n                s -= nums[l]\\n            ans += r - l\\n        return ans        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        l = -1 \\n        s = 0\\n        ans = 0\\n        for r, v in enumerate(nums):\\n            s += v\\n            while s * (r-l) >= k and l < r:\\n                l += 1\\n                s -= nums[l]\\n            ans += r - l\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512126,
                "title": "c-solution-easy-to-understand-sliding-window-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        if(k<=1)return 0;\\n        int n=nums.size();\\n        long long ans=0;\\n        long long sum=0,left=0;\\n        for(int right=0;right<n;right++)\\n        {\\n            sum+=nums[right];\\n            while(sum*(right-left+1)>=k)\\n            {\\n                sum-=nums[left++];\\n            }\\n            ans+=right-left+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        if(k<=1)return 0;\\n        int n=nums.size();\\n        long long ans=0;\\n        long long sum=0,left=0;\\n        for(int right=0;right<n;right++)\\n        {\\n            sum+=nums[right];\\n            while(sum*(right-left+1)>=k)\\n            {\\n                sum-=nums[left++];\\n            }\\n            ans+=right-left+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510827,
                "title": "kotlin-sliding-window-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun countSubarrays(nums: IntArray, k: Long): Long {\\n        var result = 0L\\n        var left = 0\\n        var acc = 0L\\n        for (right in nums.indices) {\\n            acc = acc + nums[right].toLong()\\n\\n            while(left <= right) {\\n                val length = right - left + 1\\n                if (acc * length.toLong() < k) break\\n                acc -= nums[left]\\n                left++ \\n            }\\n\\n            result += right - left + 1\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countSubarrays(nums: IntArray, k: Long): Long {\\n        var result = 0L\\n        var left = 0\\n        var acc = 0L\\n        for (right in nums.indices) {\\n            acc = acc + nums[right].toLong()\\n\\n            while(left <= right) {\\n                val length = right - left + 1\\n                if (acc * length.toLong() < k) break\\n                acc -= nums[left]\\n                left++ \\n            }\\n\\n            result += right - left + 1\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493450,
                "title": "easy-java-solution-sliding-window-explained",
                "content": "```\\nclass Solution {\\n    // Takeaway : Logic is to consider Subarray formed with the last indexed element\\n    // Logic:\\n        // Maintain a sliding window which maintain the condition i.e. sum*len<k\\n            // If condition is breaking then shrink your window i.e. j++\\n        // count the sub array formed with last elements\\n        // return count.\\n    \\n    public long countSubarrays(int[] nums, long k) {\\n        \\n        int N = nums.length;\\n        int i=0;\\n        int j=0;\\n        long count = 0;\\n        long sum = 0;\\n        while(i<N) {\\n            sum += nums[i];\\n            while(sum * (i-j+1)>=k) {\\n                sum -= nums[j++];\\n            }\\n            count += i-j+1;\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Takeaway : Logic is to consider Subarray formed with the last indexed element\\n    // Logic:\\n        // Maintain a sliding window which maintain the condition i.e. sum*len<k\\n            // If condition is breaking then shrink your window i.e. j++\\n        // count the sub array formed with last elements\\n        // return count.\\n    \\n    public long countSubarrays(int[] nums, long k) {\\n        \\n        int N = nums.length;\\n        int i=0;\\n        int j=0;\\n        long count = 0;\\n        long sum = 0;\\n        while(i<N) {\\n            sum += nums[i];\\n            while(sum * (i-j+1)>=k) {\\n                sum -= nums[j++];\\n            }\\n            count += i-j+1;\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492448,
                "title": "100-faster-sliding-window-two-pointer",
                "content": "# Code\\n```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, long k) {\\n        int l = 0, r = 0, n = nums.Length;\\n        long prod = 0, cnt = 0, sum =0;\\n        while(r < n)\\n        {\\n            sum += nums[r];\\n            prod = sum * (r - l + 1);\\n            while(prod >= k && l <= r)\\n            {\\n                sum -= nums[l++];\\n                prod = sum * (r-l+1);          \\n            }\\n            cnt+= (r-l+1);\\n            r++;\\n        }   \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long CountSubarrays(int[] nums, long k) {\\n        int l = 0, r = 0, n = nums.Length;\\n        long prod = 0, cnt = 0, sum =0;\\n        while(r < n)\\n        {\\n            sum += nums[r];\\n            prod = sum * (r - l + 1);\\n            while(prod >= k && l <= r)\\n            {\\n                sum -= nums[l++];\\n                prod = sum * (r-l+1);          \\n            }\\n            cnt+= (r-l+1);\\n            r++;\\n        }   \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470394,
                "title": "count-subarrays-with-score-less-than-k",
                "content": "---------------- Easy C++ Solution ------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n       long long  int result = 0;\\n        long long total = 0;\\n        int i = 0;\\n        int j=0;\\n        int n=nums.size();\\n        while(j<n) {\\n            total += nums[j];\\n            while (total*(j-i+1) >= k) {\\n                total -= nums[i];\\n                i++;\\n            }\\n            result+= j-i+1;\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n       long long  int result = 0;\\n        long long total = 0;\\n        int i = 0;\\n        int j=0;\\n        int n=nums.size();\\n        while(j<n) {\\n            total += nums[j];\\n            while (total*(j-i+1) >= k) {\\n                total -= nums[i];\\n                i++;\\n            }\\n            result+= j-i+1;\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415795,
                "title": "python-easy-to-understand-code-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, arr: List[int], k: int) -> int:\\n        ans=0\\n        l=0\\n        Sum=0\\n        for r in range(len(arr)):\\n            Sum+=arr[r]\\n\\n            while Sum*(r-l+1)>=k:\\n                Sum-=arr[l]\\n                l+=1\\n            \\n            ans+=(r-l+1)\\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, arr: List[int], k: int) -> int:\\n        ans=0\\n        l=0\\n        Sum=0\\n        for r in range(len(arr)):\\n            Sum+=arr[r]\\n\\n            while Sum*(r-l+1)>=k:\\n                Sum-=arr[l]\\n                l+=1\\n            \\n            ans+=(r-l+1)\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389491,
                "title": "short-rust-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, k: i64) -> i64 {\\n        Self::f(&nums, k as usize, 0, 0, 0, 0) as i64\\n    }\\n    fn f(nums: &[i32], k: usize, i: usize, j: usize, ai: usize, aj: usize) -> usize {\\n        if (aj - ai) * (j - i) >= k {\\n            Self::f(nums, k, i + 1, j, ai + nums[i] as usize, aj)\\n        } else if j == nums.len() {\\n            j - i\\n        } else {\\n            Self::f(nums, k, i, j + 1, ai, aj + nums[j] as usize) + j - i\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, k: i64) -> i64 {\\n        Self::f(&nums, k as usize, 0, 0, 0, 0) as i64\\n    }\\n    fn f(nums: &[i32], k: usize, i: usize, j: usize, ai: usize, aj: usize) -> usize {\\n        if (aj - ai) * (j - i) >= k {\\n            Self::f(nums, k, i + 1, j, ai + nums[i] as usize, aj)\\n        } else if j == nums.len() {\\n            j - i\\n        } else {\\n            Self::f(nums, k, i, j + 1, ai, aj + nums[j] as usize) + j - i\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3385546,
                "title": "easy-to-understand-sliding-window-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant Space Complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        //score=sum*length of the array\\n        long long i=0,j=0,sum=0,len=0,ans=0;\\n        while(j<nums.size()){\\n            //forming the sliding window with the given condition\\n            sum+=nums[j]; len++;\\n            if(sum*len>=k){\\n                while(sum*len>=k){\\n                    sum-=nums[i];\\n                    len--;\\n                    i++;          // 2 1 4 3 5     k=10\\n                }\\n            }\\n            ans+=j-i+1;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSubarrays(vector<int>& nums, long long k) {\\n        //score=sum*length of the array\\n        long long i=0,j=0,sum=0,len=0,ans=0;\\n        while(j<nums.size()){\\n            //forming the sliding window with the given condition\\n            sum+=nums[j]; len++;\\n            if(sum*len>=k){\\n                while(sum*len>=k){\\n                    sum-=nums[i];\\n                    len--;\\n                    i++;          // 2 1 4 3 5     k=10\\n                }\\n            }\\n            ans+=j-i+1;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1753588,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1627302,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 2072010,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 2069902,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 2013691,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1997729,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1971050,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1884686,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1843061,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1802452,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1753588,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1627302,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 2072010,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 2069902,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 2013691,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1997729,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1971050,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1884686,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1843061,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            },
            {
                "id": 1802452,
                "content": [
                    {
                        "username": "ry129",
                        "content": "Why is this question categorized as HARD? Should be a medium I think."
                    },
                    {
                        "username": "Tensor08",
                        "content": "It could be categorized as HARD if all array numbers are not positive, which could be a follow-up question as well."
                    },
                    {
                        "username": "AbhayKadapa007",
                        "content": "in test case, nums = [2,1,4,3,5], k = 10\\nthey considered Output: 6\\nThe 6 subarrays having scores less than 10 are:\\n- [2] with score 2 * 1 = 2.\\n- [1] with score 1 * 1 = 1.\\n- [4] with score 4 * 1 = 4.\\n- [3] with score 3 * 1 = 3. \\n- [5] with score 5 * 1 = 5.\\n- [2,1] with score (2 + 1) * 2 = 6.\\n\\nWhy didn\\'t they consider subset [1,3] ?\\n- [1,3] with score (1+3) * 2 = 8.\\n\\nSo answer should be 7, right??"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "continuous bro, not subsequence."
                    },
                    {
                        "username": "justforfunby",
                        "content": "Please read the description one more time and pay attention to the last line:\\nA subarray is a *contiguous* sequence of elements within an array."
                    },
                    {
                        "username": "Lubron",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this should be medium"
                    },
                    {
                        "username": "faizanwani",
                        "content": "prerequisite-\\nhttps://leetcode.com/problems/subarray-product-less-than-k/"
                    },
                    {
                        "username": "nikalinov",
                        "content": "This question is definitely medium"
                    },
                    {
                        "username": "BatMe",
                        "content": "Why we do count+= j-i+1  and not simply count++? \\n\\nMy  code worked just by substituting count++ with count = j-i+1; "
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "if you just do count++ then u wont be counting all the subarray... for example do the dry run for the first example ... u will miss the subarrays of size 1 but if you do count+=j-i+1 it will count all the subarrays."
                    },
                    {
                        "username": "algoacer",
                        "content": "auto calculateScore = [](int sum, int size) {\\n     return 1ll * sum * size;\\n};\\nwhen I was using this lambda function, it shows incorrect output for testcase 166. Using same logic in code, it works fine. Can anyone explain."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anyone know why the first code works but the second does not work?\\n\\n```\\n# works\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            while total * (right - left + 1) >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n\\n# does not work\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n            res += (right - left + 1)\\n        \\n        return res\\n```"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "class Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        res = 0\\n        left = 0\\n        total = 0\\n        \\n        for right, val in enumerate(nums):\\n            total += val\\n            score = total * (right - left + 1)\\n            while score >= k:\\n                total -= nums[left]\\n                left += 1\\n                score = total * (right - left + 1) // extra line added\\n            res += (right - left + 1)\\n        \\n        return res\\n\\ndo this change and it will work... your code is not working ig because you have defined \"score\" before \"while\" loop and when the \"left\" value changes even in the \"while\" loop it doesnot change your \"score\" value"
                    },
                    {
                        "username": "Msey",
                        "content": "Sliding windows have been sold, come later"
                    },
                    {
                        "username": "Parth_G15",
                        "content": "class Solution:\\n    def countSubarrays(self, nums, k) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            value = 0\\n            j = 0\\n            while j <= i:\\n                for m in range(j, i + 1):\\n                    value = value + nums[m]\\n                res = value * (i - j + 1)\\n                if res < k:\\n                    count = count + 1\\n                else:\\n                    res = 0\\n                    value = 0\\n                    pass\\n                j = j + 1\\n        return count\\n\\n\\nWhat is wrong in my code?"
                    }
                ]
            }
        ]
    }
]