[
    {
        "title": "Combinations",
        "question_content": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n\nExample 2:\n\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 20\n\t1 <= k <= n",
        "solutions": [
            {
                "id": 26992,
                "title": "short-iterative-c-answer-8ms",
                "content": "    class Solution {\\n    public:\\n    \\tvector<vector<int>> combine(int n, int k) {\\n    \\t\\tvector<vector<int>> result;\\n    \\t\\tint i = 0;\\n    \\t\\tvector<int> p(k, 0);\\n    \\t\\twhile (i >= 0) {\\n    \\t\\t\\tp[i]++;\\n    \\t\\t\\tif (p[i] > n) --i;\\n    \\t\\t\\telse if (i == k - 1) result.push_back(p);\\n    \\t\\t\\telse {\\n    \\t\\t\\t    ++i;\\n    \\t\\t\\t    p[i] = p[i - 1];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn result;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int>> combine(int n, int k) {\\n    \\t\\tvector<vector<int>> result;\\n    \\t\\tint i = 0;\\n    \\t\\tvector<int> p(k, 0);\\n    \\t\\twhile (i >= 0) {\\n    \\t\\t\\tp[i]++;\\n    \\t\\t\\tif (p[i] > n) --i;\\n    \\t\\t\\telse if (i == k - 1) result.push_back(p);\\n    \\t\\t\\telse {\\n    \\t\\t\\t    ++i;\\n    \\t\\t\\t    p[i] = p[i - 1];\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 27002,
                "title": "backtracking-solution-java",
                "content": "        public static List<List<Integer>> combine(int n, int k) {\\n    \\t\\tList<List<Integer>> combs = new ArrayList<List<Integer>>();\\n    \\t\\tcombine(combs, new ArrayList<Integer>(), 1, n, k);\\n    \\t\\treturn combs;\\n    \\t}\\n    \\tpublic static void combine(List<List<Integer>> combs, List<Integer> comb, int start, int n, int k) {\\n    \\t\\tif(k==0) {\\n    \\t\\t\\tcombs.add(new ArrayList<Integer>(comb));\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tfor(int i=start;i<=n;i++) {\\n    \\t\\t\\tcomb.add(i);\\n    \\t\\t\\tcombine(combs, comb, i+1, n, k-1);\\n    \\t\\t\\tcomb.remove(comb.size()-1);\\n    \\t\\t}\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "        public static List<List<Integer>> combine(int n, int k) {\\n    \\t\\tList<List<Integer>> combs = new ArrayList<List<Integer>>();\\n    \\t\\tcombine(combs, new ArrayList<Integer>(), 1, n, k);\\n    \\t\\treturn combs;\\n    \\t}\\n    \\tpublic static void combine(List<List<Integer>> combs, List<Integer> comb, int start, int n, int k) {\\n    \\t\\tif(k==0) {\\n    \\t\\t\\tcombs.add(new ArrayList<Integer>(comb));\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tfor(int i=start;i<=n;i++) {\\n    \\t\\t\\tcomb.add(i);\\n    \\t\\t\\tcombine(combs, comb, i+1, n, k-1);\\n    \\t\\t\\tcomb.remove(comb.size()-1);\\n    \\t\\t}\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 844096,
                "title": "backtracking-cheatsheet-simple-solution",
                "content": "### Backtracking\\nBacktracking is a general algorithm for finding all (or some) solutions to some computational problems which incrementally builds candidates to the solution and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot lead to a valid solution. \\n\\nIt is due to this backtracking behaviour, the backtracking algorithms are often much faster than the brute-force search algorithm, since it eliminates many unnecessary exploration. \\n\\n```\\ndef backtrack(candidate):\\n    if find_solution(candidate):\\n        output(candidate)\\n        return\\n    \\n    # iterate all possible candidates.\\n    for next_candidate in list_of_candidates:\\n        if is_valid(next_candidate):\\n            # try this partial candidate solution\\n            place(next_candidate)\\n            # given the candidate, explore further.\\n            backtrack(next_candidate)\\n            # backtrack\\n            remove(next_candidate)\\n```\\n\\nOverall, the enumeration of candidates is done in two levels: \\n1) at the first level, the function is implemented as recursion. At each occurrence of recursion, the function is one step further to the final solution.  \\n2) as the second level, within the recursion, we have an iteration that allows us to explore all the candidates that are of the same progress to the final solution.  \\n\\n### Code\\nHere we have to explore all combinations of numbers from 1 to n of length k. Indeed, we could solve the problem with the paradigm of backtracking.\\n\\nProblem - combinations\\nDecision space- numbers from 1 to n without repetation\\nOutput- all combinatins of numbers from 1 to n of size k\\n\\n**Python 3**\\n```\\ndef combine(self, n, k):   \\n\\t\\tsol=[]\\n        def backtrack(remain,comb,nex):\\n\\t\\t\\t# solution found\\n            if remain==0:\\n                sol.append(comb.copy())\\n            else:\\n\\t\\t\\t\\t# iterate through all possible candidates\\n                for i in range(nex,n+1):\\n\\t\\t\\t\\t\\t# add candidate\\n                    comb.append(i)\\n\\t\\t\\t\\t\\t#backtrack\\n                    backtrack(remain-1,comb,i+1)\\n\\t\\t\\t\\t\\t# remove candidate\\n                    comb.pop()\\n            \\n        backtrack(k,[],1)\\n        return sol\\n```\\n- Given an empty array, the task is to add numbers between 1 to n to the array upto size of k. We could model the each step to add a number as a recursion function (i.e. backtrack() function).\\n\\n- At each step, technically we have 9 candidates at hand to add to the array. Yet, we want to consider solutions that lead to a valid case (i.e. is_valid(candidate)). Here the validity is determined by whether the number is repeated or not. Since in the loop, we iterate from nex to n+1, the numbers before nex are already visited and cannot be added to the array. Hence, we dont arrive at an invalid case.\\n\\n- Then, among all the suitable candidates, we add different numbers using `comb.append(i)` i.e. place(next_candidate). Later we can revert our decision with `comb.pop()` i.e.  remove(next_candidate), so that we could try out the other candidates.\\n\\n- The backtracking would be triggered at the points where the decision space is complete i.e. `nex` is 9 or when the size of the` comb `array becomes` k`. At the end of the backtracking, we would enumerate all the possible combinations.\\n\\n### Practice problems on backtracking\\n*Easy*\\n\\n[Binary watch](http://)\\n\\n*Medium*\\n\\n[Permutations](http://)\\n[Permutations II](http://)\\n[Combination sum III](http://)\\n\\n*Hard*\\n\\n[N Queens](http://)\\n[N Queen II](http://)\\n[Sudoku solver](http://)\\n\\n**Notes**\\n* For more examples and detailed explanation refer [Recursion II](http://)\\n* Any suggestions are welcome.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef backtrack(candidate):\\n    if find_solution(candidate):\\n        output(candidate)\\n        return\\n    \\n    # iterate all possible candidates.\\n    for next_candidate in list_of_candidates:\\n        if is_valid(next_candidate):\\n            # try this partial candidate solution\\n            place(next_candidate)\\n            # given the candidate, explore further.\\n            backtrack(next_candidate)\\n            # backtrack\\n            remove(next_candidate)\\n```\n```\\ndef combine(self, n, k):   \\n\\t\\tsol=[]\\n        def backtrack(remain,comb,nex):\\n\\t\\t\\t# solution found\\n            if remain==0:\\n                sol.append(comb.copy())\\n            else:\\n\\t\\t\\t\\t# iterate through all possible candidates\\n                for i in range(nex,n+1):\\n\\t\\t\\t\\t\\t# add candidate\\n                    comb.append(i)\\n\\t\\t\\t\\t\\t#backtrack\\n                    backtrack(remain-1,comb,i+1)\\n\\t\\t\\t\\t\\t# remove candidate\\n                    comb.pop()\\n            \\n        backtrack(k,[],1)\\n        return sol\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 27024,
                "title": "1-liner-3-liner-4-liner",
                "content": "**Library - AC in 64 ms**\\n\\nFirst the obvious solution - Python already provides this functionality and it's not forbidden, so let's take advantage of it.\\n\\n    from itertools import combinations\\n    \\n    class Solution:\\n        def combine(self, n, k):\\n            return list(combinations(range(1, n+1), k))\\n\\n---\\n\\n**Recursive - AC in 76 ms**\\n\\nBut doing it yourself is more interesting, and not that hard. Here's a recursive version.\\n\\n    class Solution:\\n        def combine(self, n, k):\\n            if k == 0:\\n                return [[]]\\n            return [pre + [i] for i in range(k, n+1) for pre in self.combine(i-1, k-1)]\\n\\nThanks to @boomcat for [pointing out](https://discuss.leetcode.com/post/242007) `to use range(k, n+1)` instead of my original `range(1, n+1)`.\\n\\n---\\n\\n**Iterative - AC in 76 ms**\\n\\nAnd here's an iterative one. \\n\\n    class Solution:\\n        def combine(self, n, k):\\n            combs = [[]]\\n            for _ in range(k):\\n                combs = [[i] + c for c in combs for i in range(1, c[0] if c else n+1)]\\n            return combs\\n\\n---\\n\\n**Reduce - AC in 76 ms**\\n\\nSame as that iterative one, but using `reduce` instead of a loop:\\n\\n    class Solution:\\n      def combine(self, n, k):\\n        return reduce(lambda C, _: [[i]+c for c in C for i in range(1, c[0] if c else n+1)],\\n                      range(k), [[]])",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Library - AC in 64 ms**\\n\\nFirst the obvious solution - Python already provides this functionality and it's not forbidden, so let's take advantage of it.\\n\\n    from itertools import combinations\\n    \\n    class Solution:\\n        def combine(self, n, k):\\n            return list(combinations(range(1, n+1), k))\\n\\n---\\n\\n**Recursive - AC in 76 ms**\\n\\nBut doing it yourself is more interesting, and not that hard. Here's a recursive version.\\n\\n    class Solution:\\n        def combine(self, n, k):\\n            if k == 0:\\n                return [[]]\\n            return [pre + [i] for i in range(k, n+1) for pre in self.combine(i-1, k-1)]\\n\\nThanks to @boomcat for [pointing out](https://discuss.leetcode.com/post/242007) `to use range(k, n+1)` instead of my original `range(1, n+1)`.\\n\\n---\\n\\n**Iterative - AC in 76 ms**\\n\\nAnd here's an iterative one. \\n\\n    class Solution:\\n        def combine(self, n, k):\\n            combs = [[]]\\n            for _ in range(k):\\n                combs = [[i] + c for c in combs for i in range(1, c[0] if c else n+1)]\\n            return combs\\n\\n---\\n\\n**Reduce - AC in 76 ms**\\n\\nSame as that iterative one, but using `reduce` instead of a loop:\\n\\n    class Solution:\\n      def combine(self, n, k):\\n        return reduce(lambda C, _: [[i]+c for c in C for i in range(1, c[0] if c else n+1)],\\n                      range(k), [[]])",
                "codeTag": "Java"
            },
            {
                "id": 1141903,
                "title": "clear-and-simple-explanation-with-intuition-100-faster",
                "content": "**Intuition:** Since we are asked to calculate all the possible combinations , hence we have to use backtracking\\n\\n**Concept:** In every backtracking problem , there are two things to keep in mind , which we will explore here as well :\\n*  Base Case: Every problem of backtracking has some base case which tells us at which point we have to stop with the recursion process. In our case, when the size of our array `current` equals to `k` i.e. `current.size()=k`, we stop with the recursion and add it to our final result `ans`.\\n\\n*   Conditions: There is just one thing to keep in mind here:\\n   After generating combinations corresponding to a particular number `i` , proceed to the next element by popping the element from the temporary array `current`, as we used that already. \\n \\nWe basically consider a number `i`, generate the combinations corresponding to it by recursively calling it again, and then we pop that element as we are done with it and proceed to the next!!\\n\\t\\t\\nAnd thats it!! We are done!! Keeping this in mind, here is the code\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void helper(int idx, int k,vector<int>&current,int n)\\n    {\\n        if(current.size()==k)    // base case\\n        {\\n            ans.push_back(current);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<n+1;i++)\\n        {\\n            current.push_back(i);  //consider the current element i\\n            helper(i+1,k,current,n); // generate combinations\\n            current.pop_back(); //proceed to next element\\n        }\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>current;\\n        helper(1,k,current,n);\\n        return ans; //return answer\\n    }\\n};\\n```\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void helper(int idx, int k,vector<int>&current,int n)\\n    {\\n        if(current.size()==k)    // base case\\n        {\\n            ans.push_back(current);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<n+1;i++)\\n        {\\n            current.push_back(i);  //consider the current element i\\n            helper(i+1,k,current,n); // generate combinations\\n            current.pop_back(); //proceed to next element\\n        }\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>current;\\n        helper(1,k,current,n);\\n        return ans; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27019,
                "title": "a-short-recursive-java-solution-based-on-c-n-k-c-n-1-k-1-c-n-1-k",
                "content": "Basically, this solution follows the idea of the mathematical formula C(n,k)=C(n-1,k-1)+C(n-1,k).\\n\\nHere C(n,k) is divided into two situations. Situation one, number n is selected, so we only need to select k-1 from n-1 next. Situation two, number n is not selected, and the rest job is selecting k from n-1.\\n\\n    public class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            if (k == n || k == 0) {\\n                List<Integer> row = new LinkedList<>();\\n                for (int i = 1; i <= k; ++i) {\\n                    row.add(i);\\n                }\\n                return new LinkedList<>(Arrays.asList(row));\\n            }\\n            List<List<Integer>> result = this.combine(n - 1, k - 1);\\n            result.forEach(e -> e.add(n));\\n            result.addAll(this.combine(n - 1, k));\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            if (k == n || k == 0) {\\n                List<Integer> row = new LinkedList<>();\\n                for (int i = 1; i <= k; ++i) {\\n                    row.add(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27015,
                "title": "3-ms-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            if (k > n || k < 0) {\\n                return result;\\n            }\\n            if (k == 0) {\\n                result.add(new ArrayList<Integer>());\\n                return result;\\n            }\\n            result = combine(n - 1, k - 1);\\n            for (List<Integer> list : result) {\\n                list.add(n);\\n            }\\n            result.addAll(combine(n - 1, k));\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            if (k > n || k < 0) {\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 27006,
                "title": "a-template-to-those-combination-problems",
                "content": "**Template first.**\\nAll those combination problems share a common characteristic: either select the element at current position or not, and continue the same process to the next position. Therefore, I summarized a simple template to those problems.\\n```\\nvector<vector<int>> main(...){\\n    vector<vector<int>>res;  // Store the result, could be other container\\n    backtrack(res, ...);  // Recursion function to fill the res\\n    return res;\\n}\\n\\nvoid backtrack(vector<vector<int>>& res, int cur, ..., vector<int>vec){\\n    if(meet the end critria, i.e. cur reach the end of array){  \\n        //vec could be a certain path/combination/subset\\n        res.push_back(vec);\\n        return;\\n    }\\n    // Current element is not selected\\n    backtrack(res, cur+1, ..., vec);\\n    // Current element is selected\\n    vec.push_back(cur); // or could be vec.push_back(nums[cur]), vec.push_back(graph[cur]);\\n    backtrack(res,cur+1, ..., vec);\\n}\\n```\\n***\\nNow go back to this problem([LeetCode 77. Combinations](https://leetcode.com/problems/combinations/description/)), we are asked to return all possible combinations of k numbers out of 1 ... n.\\nWe start from `1`, if `1` is selected, `k = k-1`; if `1` is not selected, `k = k`; proceed to next number, until `k` becomes `0` - the end critria.\\n**Code:**\\n```\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>res;\\n        backtrack(res,1,n,k,vector<int>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, int cur, int n, int k, vector<int>comb){\\n        if(k==0){\\n            res.push_back(comb);\\n            return;\\n        }\\n        // If cur>n-k, there are not enough numbers left, we have to select the current element\\n        if(cur<=n-k) backtrack(res,cur+1,n,k,comb);  \\n        comb.push_back(cur);\\n        backtrack(res,cur+1,n,k-1,comb);\\n    }\\n```\\nOr start with number `n`, and decreasing.\\n```\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>res;\\n        backtrack(res,n,k,vector<int>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, int n, int k, vector<int>comb){\\n        if(k==0){\\n            res.push_back(comb);\\n            return;\\n        }\\n        if(n>k) backtrack(res,n-1,k,comb);\\n        comb.push_back(n);\\n        backtrack(res,n-1,k-1,comb);\\n    }\\n```\\n***\\nHere is another combination problem, [LeetCode 78. Subsets](https://leetcode.com/problems/subsets/description/): Given a set of distinct integers, nums, return all possible subsets.\\nWe can use this template as well, pretty much the same code.\\n```\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        backtrack(nums,0,vector<int>(),res);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<int>& nums, int k,vector<int>subset,vector<vector<int>>& res){\\n        if(k==nums.size()){\\n            res.push_back(subset);\\n            return;\\n        }\\n        backtrack(nums,k+1,subset,res);\\n        subset.push_back(nums[k]);\\n        backtrack(nums,k+1,subset,res);\\n    }\\n```\\n***\\nStill, I think the template may have room to improve, it costs too much memory.\\nOne way to solve it is to change `vector<int>vec` to `vector<int>&vec`, and add `vec.pop_back()` at the end of `backtrack()`, but it may increase the time complexity, don't know which one is better.\\n\\n***\\n**EDIT(8/1/2017)**: Just found another combination problem, [LeetCode 93. Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/description/): Given a string containing only digits, restore it by returning all possible valid IP address combinations.\\n\\nFor example:\\nGiven \"25525511135\",\\n\\nreturn [\"255.255.11.135\", \"255.255.111.35\"].\\n\\nCan be easily solved using template:\\n\\n```\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> res;\\n        backtrack(res, s, 0, \"\", 0);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string s, int pos, string comb, int num){\\n        if(num > 4) return;  // IP address only allows for 4 segments\\n        if(pos >= s.size()){\\n            if(num == 4){\\n                comb.pop_back();\\n                res.push_back(comb);\\n            }\\n            return;\\n        }\\n        // 3 digit\\n        if(s[pos] != '0' && pos < s.size()-2 && stoi(s.substr(pos,3)) < 256)\\n            backtrack(res, s, pos + 3, comb + s.substr(pos,3) + \".\", num + 1);\\n        // 2 digit\\n        if(s[pos] != '0' && pos < s.size()-1)\\n            backtrack(res, s, pos + 2, comb + s.substr(pos,2) + \".\", num + 1);\\n        // 1 digit\\n        backtrack(res, s, pos + 1, comb + s.substr(pos,1) + \".\", num + 1);\\n    }\\n```\\n***\\n**Update(8/3/2017):** [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/description/) : Given a string s, partition s such that every substring of the partition is a palindrome. Solution: \\n```\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>res;\\n        backtrack(res,s,0,vector<string>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<string>>& res, string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            res.push_back(comb);\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(s.substr(pos,1));\\n        backtrack(res, s, pos + 1, comb);\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n            if(isPalindrome(s.substr(pos, step))){\\n                comb.push_back(s.substr(pos, step));\\n                backtrack(res, s, pos + step, comb);\\n                comb.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s){\\n        int i(0), j(s.size()-1);\\n        while(i < j) \\n            if(s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<vector<int>> main(...){\\n    vector<vector<int>>res;  // Store the result, could be other container\\n    backtrack(res, ...);  // Recursion function to fill the res\\n    return res;\\n}\\n\\nvoid backtrack(vector<vector<int>>& res, int cur, ..., vector<int>vec){\\n    if(meet the end critria, i.e. cur reach the end of array){  \\n        //vec could be a certain path/combination/subset\\n        res.push_back(vec);\\n        return;\\n    }\\n    // Current element is not selected\\n    backtrack(res, cur+1, ..., vec);\\n    // Current element is selected\\n    vec.push_back(cur); // or could be vec.push_back(nums[cur]), vec.push_back(graph[cur]);\\n    backtrack(res,cur+1, ..., vec);\\n}\\n```\n```\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>res;\\n        backtrack(res,1,n,k,vector<int>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, int cur, int n, int k, vector<int>comb){\\n        if(k==0){\\n            res.push_back(comb);\\n            return;\\n        }\\n        // If cur>n-k, there are not enough numbers left, we have to select the current element\\n        if(cur<=n-k) backtrack(res,cur+1,n,k,comb);  \\n        comb.push_back(cur);\\n        backtrack(res,cur+1,n,k-1,comb);\\n    }\\n```\n```\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>res;\\n        backtrack(res,n,k,vector<int>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, int n, int k, vector<int>comb){\\n        if(k==0){\\n            res.push_back(comb);\\n            return;\\n        }\\n        if(n>k) backtrack(res,n-1,k,comb);\\n        comb.push_back(n);\\n        backtrack(res,n-1,k-1,comb);\\n    }\\n```\n```\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        backtrack(nums,0,vector<int>(),res);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<int>& nums, int k,vector<int>subset,vector<vector<int>>& res){\\n        if(k==nums.size()){\\n            res.push_back(subset);\\n            return;\\n        }\\n        backtrack(nums,k+1,subset,res);\\n        subset.push_back(nums[k]);\\n        backtrack(nums,k+1,subset,res);\\n    }\\n```\n```\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> res;\\n        backtrack(res, s, 0, \"\", 0);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string s, int pos, string comb, int num){\\n        if(num > 4) return;  // IP address only allows for 4 segments\\n        if(pos >= s.size()){\\n            if(num == 4){\\n                comb.pop_back();\\n                res.push_back(comb);\\n            }\\n            return;\\n        }\\n        // 3 digit\\n        if(s[pos] != '0' && pos < s.size()-2 && stoi(s.substr(pos,3)) < 256)\\n            backtrack(res, s, pos + 3, comb + s.substr(pos,3) + \".\", num + 1);\\n        // 2 digit\\n        if(s[pos] != '0' && pos < s.size()-1)\\n            backtrack(res, s, pos + 2, comb + s.substr(pos,2) + \".\", num + 1);\\n        // 1 digit\\n        backtrack(res, s, pos + 1, comb + s.substr(pos,1) + \".\", num + 1);\\n    }\\n```\n```\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>res;\\n        backtrack(res,s,0,vector<string>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<string>>& res, string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            res.push_back(comb);\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(s.substr(pos,1));\\n        backtrack(res, s, pos + 1, comb);\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n            if(isPalindrome(s.substr(pos, step))){\\n                comb.push_back(s.substr(pos, step));\\n                backtrack(res, s, pos + step, comb);\\n                comb.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s){\\n        int i(0), j(s.size()-1);\\n        while(i < j) \\n            if(s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26990,
                "title": "python-easy-to-understand-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        ret = []\\n        self.dfs(list(range(1, n+1)), k, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, k, path, ret):\\n        if len(path) == k:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k, path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        ret = []\\n        self.dfs(list(range(1, n+1)), k, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, k, path, ret):\\n        if len(path) == k:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k, path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27111,
                "title": "my-shortest-c-solution-using-dfs",
                "content": "my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it;\\nthen  i pop the latest one,and push a another bigger one...\\nand if I has push k number into vector,I push this into result;\\n\\n**this solution take 24 ms.**\\n\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > combine(int n, int k) {\\n            vector<vector<int> >res;\\n            if(n<k)return res;\\n            vector<int> temp(0,k);\\n            combine(res,temp,0,0,n,k);\\n            return res;\\n        }\\n        \\n        void combine(vector<vector<int> > &res,vector<int> &temp,int start,int num,int n ,int k){\\n            if(num==k){\\n                res.push_back(temp);\\n                return;\\n            }\\n            for(int i = start;i<n;i++){\\n                temp.push_back(i+1);\\n                combine(res,temp,i+1,num+1,n,k);\\n                temp.pop_back();\\n                }\\n            }\\n    };",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combine(int n, int k) {\\n            vector<vector<int> >res;\\n            if(n<k)return res;\\n            vector<int> temp(0,k);\\n            combine(res,temp,0,0,n,k);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3845249,
                "title": "iterative-backtracking-video-100-efficient-combinatorial-generation",
                "content": "# Intuition\\nGiven two integers `n` and `k`, the task is to generate all possible combinations of `k` numbers from the range `[1, n]`. The initial intuition to solve this problem is to leverage the concept of combination generation, where we iteratively choose `k` numbers from `n` numbers without any repetition. However, there are multiple approaches to achieve this, and in this analysis, we\\'ll be comparing two of them: **backtracking** and **iterative** generation. \\n\\n# Video - Backtracking\\nhttps://youtu.be/aXgNccfxlkA\\n\\n# Video - Iterative\\nhttps://youtu.be/7Ocr2RXNIC4\\n\\n# Approaches - Summary\\nWe\\'ll tackle this problem using two distinct methods. The first method utilizes a classic backtracking algorithm, which involves building up a solution incrementally. The second method employs an iterative algorithm, which efficiently generates combinations in lexicographical order. While both methods aim to generate all possible combinations of `k` numbers out of `n`, the iterative approach has been found to be faster for the given test cases. \\n\\n1. **Backtracking Approach**: This approach involves a recursive function, `backtrack`, that generates all combinations of `k` numbers. We iterate over all numbers from `first` to `n`. For each number `i`, we add it to the current combination and then recursively generate all the combinations of the next numbers. After that, we remove `i` from the current combination to backtrack and try the next number.\\n\\n2. **Iterative Approach**: This approach uses an iterative algorithm to generate combinations. It maintains a list of current indices and generates the next combination from the current one by incrementing the rightmost element that hasn\\'t reached its maximum value yet.\\n\\n# Approach - Backtracking\\n\\nOur approach specifically involves a recursive function, `backtrack`, that generates all combinations of \\\\(k\\\\) numbers. Here\\'s a step-by-step walkthrough of the process:\\n\\n1. **Initialization**: We define an empty list, `output`, to store all our valid combinations. We also initialize our `backtrack` function, which takes as input parameters the first number to add to the current combination (`first`) and the current combination itself (`curr`).\\n\\n2. **Base case for recursion**: Within the `backtrack` function, we first check if the length of the current combination (`curr`) is equal to \\\\(k\\\\). If it is, we have a valid combination and add a copy of it to our `output` list.\\n\\n3. **Loop through the numbers**: For each number \\\\(i\\\\) in the range from `first` to \\\\(n\\\\), we add \\\\(i\\\\) to the current combination (`curr`).\\n\\n4. **Recursive call**: We then make a recursive call to `backtrack`, incrementing the value of `first` by 1 for the next iteration and passing the current combination as parameters. This step allows us to generate all combinations of the remaining numbers.\\n\\n5. **Backtrack**: After exploring all combinations with \\\\(i\\\\) included, we need to remove \\\\(i\\\\) from the current combination. This allows us to backtrack and explore the combinations involving the next number. This is done using the `pop()` method, which removes the last element from the list.\\n\\n6. **Return the result**: Finally, after all recursive calls and backtracking, the `backtrack` function will have filled our `output` list with all valid combinations of \\\\(k\\\\) numbers. We return this list as our final result.\\n\\n# Approach - Iterative\\n\\nThe approach taken to solve this problem involves the use of  function calls to generate all possible combinations. Here is a more detailed step-by-step breakdown of the approach:\\n\\n1. **Define the `generate_combinations` function:** This function takes in two parameters: `elems` (the range of numbers to choose from) and `num` (the number of elements in each combination). It begins by converting `elems` to a tuple (`elems_tuple`) for efficient indexing. It then checks if `num` is greater than the total number of elements; if it is, the function returns as it\\'s impossible to select more elements than exist in the range.\\n\\n2. **Initialize indices:** An array `curr_indices` is initialized with the first `num` indices. This will represent the indices in `elems_tuple` that we are currently considering for our combination.\\n\\n3. **Generate combinations:** The function enters a loop. In each iteration, it first generates a combination by picking elements from `elems_tuple` using the indices in `curr_indices` and yields it. This is done using a tuple comprehension.\\n\\n4. **Update indices:** Next, the function attempts to update `curr_indices` to represent the next combination. It starts from the end of `curr_indices` and moves towards the start, looking for an index that hasn\\'t reached its maximum value (which is its position from the end of `elems_tuple`). When it finds such an index, it increments it and sets all subsequent indices to be one greater than their previous index. This ensures that we generate combinations in increasing order. If it doesn\\'t find any index to increment (meaning we have generated all combinations), it breaks out of the loop and the function returns.\\n\\n5. **Call the `generate_combinations` function:** In the `combine` method, the `generate_combinations` function is called with the range `[1, n+1]` and `k` as arguments. The returned combinations are tuples, so a list comprehension is used to convert each combination into a list.\\n\\n# Complexity - Iterative\\n\\n- **Time complexity:** The time complexity is \\\\(O(C(n, k))\\\\), where \\\\(n\\\\) is the total number of elements and \\\\(k\\\\) is the number of elements in each combination. This is because the function generates each combination once. Here, \\\\(C(n, k)\\\\) denotes the number of ways to choose \\\\(k\\\\) elements from \\\\(n\\\\) elements without regard to the order of selection, also known as \"n choose k\".\\n\\n- **Space complexity:** The space complexity is also \\\\(O(C(n, k))\\\\) as we store all combinations in a list. \\n\\n\\n# Complexity - Backtracking\\n- **Time complexity:** The time complexity of this approach is (O(C(n, k)*k)). This is because in the worst-case scenario, we would need to explore all combinations of \\\\(k\\\\) out of \\\\(n\\\\) (which is C(n, k) and for each combination, it takes \\\\(O(k)\\\\) time to make a copy of it.\\n- **Space complexity:** The space complexity is \\\\(O(k)\\\\). This is because, in the worst case, if we consider the function call stack size in a depth-first search traversal, we could end up going as deep as \\\\(k\\\\) levels.\\n\\n# Code - Iterative\\n```Python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def generate_combinations(elems, num):\\n            elems_tuple = tuple(elems)\\n            total = len(elems_tuple)\\n            if num > total:\\n                return\\n            curr_indices = list(range(num))\\n            while True:\\n                yield tuple(elems_tuple[i] for i in curr_indices)\\n                for idx in reversed(range(num)):\\n                    if curr_indices[idx] != idx + total - num:\\n                        break\\n                else:\\n                    return\\n                curr_indices[idx] += 1\\n                for j in range(idx+1, num):\\n                    curr_indices[j] = curr_indices[j-1] + 1\\n\\n        return [list(combination) for combination in generate_combinations(range(1, n+1), k)]\\n```\\n``` Java []\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        generateCombinations(1, n, k, new ArrayList<Integer>(), result);\\n        return result;\\n    }\\n\\n    private void generateCombinations(int start, int n, int k, List<Integer> combination, List<List<Integer>> result) {\\n        if (k == 0) {\\n            result.add(new ArrayList<>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n - k + 1; i++) {\\n            combination.add(i);\\n            generateCombinations(i + 1, n, k - 1, combination, result);\\n            combination.remove(combination.size() - 1);\\n        }\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> result;\\n        vector<int> combination(k);\\n        generateCombinations(1, n, k, combination, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void generateCombinations(int start, int n, int k, vector<int> &combination, vector<vector<int>> &result) {\\n        if (k == 0) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = start; i <= n; ++i) {\\n            combination[combination.size() - k] = i;\\n            generateCombinations(i + 1, n, k - 1, combination, result);\\n        }\\n    }\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Combine(int n, int k) {\\n        var result = new List<IList<int>>();\\n        GenerateCombinations(1, n, k, new List<int>(), result);\\n        return result;\\n    }\\n    \\n    private void GenerateCombinations(int start, int n, int k, List<int> combination, IList<IList<int>> result) {\\n        if (k == 0) {\\n            result.Add(new List<int>(combination));\\n            return;\\n        }\\n        for (var i = start; i <= n; ++i) {\\n            combination.Add(i);\\n            GenerateCombinations(i + 1, n, k - 1, combination, result);\\n            combination.RemoveAt(combination.Count - 1);\\n        }\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function(n, k) {\\n    const result = [];\\n    generateCombinations(1, n, k, [], result);\\n    return result;\\n};\\n\\nfunction generateCombinations(start, n, k, combination, result) {\\n    if (k === 0) {\\n        result.push([...combination]);\\n        return;\\n    }\\n    for (let i = start; i <= n; ++i) {\\n        combination.push(i);\\n        generateCombinations(i + 1, n, k - 1, combination, result);\\n        combination.pop();\\n    }\\n}\\n```\\n\\n# Code - Backtracking\\n``` Python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def backtrack(first = 1, curr = []):\\n            if len(curr) == k:\\n                output.append(curr[:])\\n                return\\n            for i in range(first, n + 1):\\n                curr.append(i)\\n                backtrack(i + 1, curr)\\n                curr.pop()\\n        output = []\\n        backtrack()\\n        return output\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> result;\\n        vector<int> combination;\\n        backtrack(n, k, 1, combination, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(int n, int k, int start, vector<int>& combination, vector<vector<int>>& result) {\\n        if (combination.size() == k) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.push_back(i);\\n            backtrack(n, k, i + 1, combination, result);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        backtrack(n, k, 1, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(int n, int k, int start, List<Integer> combination, List<List<Integer>> result) {\\n        if (combination.size() == k) {\\n            result.add(new ArrayList<>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.add(i);\\n            backtrack(n, k, i + 1, combination, result);\\n            combination.remove(combination.size() - 1);\\n        }\\n    }\\n}\\n```\\n``` JavaScript []\\nvar combine = function(n, k) {\\n    const result = [];\\n    backtrack(n, k, 1, [], result);\\n    return result;\\n};\\n\\nfunction backtrack(n, k, start, combination, result) {\\n    if (combination.length === k) {\\n        result.push([...combination]);\\n        return;\\n    }\\n    for (let i = start; i <= n; i++) {\\n        combination.push(i);\\n        backtrack(n, k, i + 1, combination, result);\\n        combination.pop();\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Combine(int n, int k) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(n, k, 1, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int n, int k, int start, IList<int> combination, IList<IList<int>> result) {\\n        if (combination.Count == k) {\\n            result.Add(new List<int>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.Add(i);\\n            Backtrack(n, k, i + 1, combination, result);\\n            combination.RemoveAt(combination.Count - 1);\\n        }\\n    }\\n}\\n```\\n\\n## Performances - Iterative\\n| Language | Runtime | Rank | Memory |\\n|----------|---------|------|--------|\\n| Java     | 1 ms    | 100% | 45.3 MB|\\n| C++      | 14 ms   | 90.1%| 9.2 MB |\\n| Python3  | 68 ms   | 99.72%| 18.8 MB|\\n| JavaScript | 79 ms | 99.84%| 48.6 MB|\\n| C#       | 101 ms  | 93.1%| 44.1 MB|\\n\\n## Performances - Backtracking\\n| Language | Runtime | Beats | Memory |\\n|----------|---------|-------|--------|\\n| Java     | 17 ms   | 75.30%| 44.5 MB|\\n| C++      | 21 ms   | 85.40%| 9.1 MB |\\n| JavaScript | 86 ms | 97.78%| 48 MB  |\\n| C#       | 105 ms  | 88.60%| 44.4 MB|\\n| Python3  | 286 ms  | 78.68%| 18.2 MB|\\n\\nI hope you found this solution helpful! If so, please consider giving it an upvote. If you have any questions or suggestions for improving the solution, don\\'t hesitate to leave a comment. Your feedback not only helps me improve my answers, but it also helps other users who might be facing similar problems. Thank you for your support!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def generate_combinations(elems, num):\\n            elems_tuple = tuple(elems)\\n            total = len(elems_tuple)\\n            if num > total:\\n                return\\n            curr_indices = list(range(num))\\n            while True:\\n                yield tuple(elems_tuple[i] for i in curr_indices)\\n                for idx in reversed(range(num)):\\n                    if curr_indices[idx] != idx + total - num:\\n                        break\\n                else:\\n                    return\\n                curr_indices[idx] += 1\\n                for j in range(idx+1, num):\\n                    curr_indices[j] = curr_indices[j-1] + 1\\n\\n        return [list(combination) for combination in generate_combinations(range(1, n+1), k)]\\n```\n``` Java []\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        generateCombinations(1, n, k, new ArrayList<Integer>(), result);\\n        return result;\\n    }\\n\\n    private void generateCombinations(int start, int n, int k, List<Integer> combination, List<List<Integer>> result) {\\n        if (k == 0) {\\n            result.add(new ArrayList<>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n - k + 1; i++) {\\n            combination.add(i);\\n            generateCombinations(i + 1, n, k - 1, combination, result);\\n            combination.remove(combination.size() - 1);\\n        }\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> result;\\n        vector<int> combination(k);\\n        generateCombinations(1, n, k, combination, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void generateCombinations(int start, int n, int k, vector<int> &combination, vector<vector<int>> &result) {\\n        if (k == 0) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = start; i <= n; ++i) {\\n            combination[combination.size() - k] = i;\\n            generateCombinations(i + 1, n, k - 1, combination, result);\\n        }\\n    }\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Combine(int n, int k) {\\n        var result = new List<IList<int>>();\\n        GenerateCombinations(1, n, k, new List<int>(), result);\\n        return result;\\n    }\\n    \\n    private void GenerateCombinations(int start, int n, int k, List<int> combination, IList<IList<int>> result) {\\n        if (k == 0) {\\n            result.Add(new List<int>(combination));\\n            return;\\n        }\\n        for (var i = start; i <= n; ++i) {\\n            combination.Add(i);\\n            GenerateCombinations(i + 1, n, k - 1, combination, result);\\n            combination.RemoveAt(combination.Count - 1);\\n        }\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function(n, k) {\\n    const result = [];\\n    generateCombinations(1, n, k, [], result);\\n    return result;\\n};\\n\\nfunction generateCombinations(start, n, k, combination, result) {\\n    if (k === 0) {\\n        result.push([...combination]);\\n        return;\\n    }\\n    for (let i = start; i <= n; ++i) {\\n        combination.push(i);\\n        generateCombinations(i + 1, n, k - 1, combination, result);\\n        combination.pop();\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def backtrack(first = 1, curr = []):\\n            if len(curr) == k:\\n                output.append(curr[:])\\n                return\\n            for i in range(first, n + 1):\\n                curr.append(i)\\n                backtrack(i + 1, curr)\\n                curr.pop()\\n        output = []\\n        backtrack()\\n        return output\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> result;\\n        vector<int> combination;\\n        backtrack(n, k, 1, combination, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(int n, int k, int start, vector<int>& combination, vector<vector<int>>& result) {\\n        if (combination.size() == k) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.push_back(i);\\n            backtrack(n, k, i + 1, combination, result);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        backtrack(n, k, 1, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(int n, int k, int start, List<Integer> combination, List<List<Integer>> result) {\\n        if (combination.size() == k) {\\n            result.add(new ArrayList<>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.add(i);\\n            backtrack(n, k, i + 1, combination, result);\\n            combination.remove(combination.size() - 1);\\n        }\\n    }\\n}\\n```\n``` JavaScript []\\nvar combine = function(n, k) {\\n    const result = [];\\n    backtrack(n, k, 1, [], result);\\n    return result;\\n};\\n\\nfunction backtrack(n, k, start, combination, result) {\\n    if (combination.length === k) {\\n        result.push([...combination]);\\n        return;\\n    }\\n    for (let i = start; i <= n; i++) {\\n        combination.push(i);\\n        backtrack(n, k, i + 1, combination, result);\\n        combination.pop();\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Combine(int n, int k) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(n, k, 1, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int n, int k, int start, IList<int> combination, IList<IList<int>> result) {\\n        if (combination.Count == k) {\\n            result.Add(new List<int>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.Add(i);\\n            Backtrack(n, k, i + 1, combination, result);\\n            combination.RemoveAt(combination.Count - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429526,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27029,
                "title": "ac-python-backtracking-iterative-solution-60-ms",
                "content": "    def combine(self, n, k):\\n        ans = []\\n        stack = []\\n        x = 1\\n        while True:\\n            l = len(stack)\\n            if l == k:\\n                ans.append(stack[:])\\n            if l == k or x > n - k + l + 1:\\n                if not stack:\\n                    return ans\\n                x = stack.pop() + 1\\n            else:\\n                stack.append(x)\\n                x += 1\\n\\n    # 26 / 26 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 60 ms\\n    # 98.51%\\n\\n\\nCombinations is typical application for backtracking. Two conditions for back track: (1) the stack length is already k (2) the current value is too large for the rest slots to fit in since we are using ascending order to make sure the uniqueness of each combination.",
                "solutionTags": [],
                "code": "    def combine(self, n, k):\\n        ans = []\\n        stack = []\\n        x = 1\\n        while True:\\n            l = len(stack)\\n            if l == k:\\n                ans.append(stack[:])\\n            if l == k or x > n - k + l + 1:\\n                if not stack:\\n                    return ans\\n                x = stack.pop() + 1\\n            else:\\n                stack.append(x)\\n                x += 1\\n\\n    # 26 / 26 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 60 ms\\n    # 98.51%\\n\\n\\nCombinations is typical application for backtracking. Two conditions for back track: (1) the stack length is already k (2) the current value is too large for the rest slots to fit in since we are using ascending order to make sure the uniqueness of each combination.",
                "codeTag": "Python3"
            },
            {
                "id": 3214276,
                "title": "best-c-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements. where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(nCk), as stated above the nCk here refers to the binomial coefficient.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements.\\n    where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n    Space Complexity : O(nCk), as stated above the nCk here refers to the binomial coefficient.\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\nclass Solution { \\nprivate: \\n    void combine(int n, int k, vector<vector<int>> &output, vector<int> &temp, int start){\\n        if(temp.size() == k){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=start; i<=n; i++){\\n            temp.push_back(i);\\n            combine(n, k, output, temp, i+1);\\n            temp.pop_back();\\n        }\\n    }     \\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combine(n, k, output, temp, 1);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements.\\n    where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n    Space Complexity : O(nCk), as stated above the nCk here refers to the binomial coefficient.\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\nclass Solution { \\nprivate: \\n    void combine(int n, int k, vector<vector<int>> &output, vector<int> &temp, int start){\\n        if(temp.size() == k){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=start; i<=n; i++){\\n            temp.push_back(i);\\n            combine(n, k, output, temp, i+1);\\n            temp.pop_back();\\n        }\\n    }     \\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combine(n, k, output, temp, 1);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845227,
                "title": "2-methods-backtracking-recursion-video-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind recursively by take not take.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/QHaj0oRoYCI\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\nBoth the methods i discussed in depth\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhich is more efficient and why ?\\n\\nBoth `solve1` and `solve2` are recursive methods used to find combinations of `k` elements from the range `[1, n]`. However, they use different approaches to achieve the same result. Let\\'s compare their efficiency:\\n\\n1. `solve1`:\\n   - Approach: This method uses a binary tree-like recursion structure where, at each step, it either includes the current `num` in the combination or skips it.\\n   - Complexity: The time complexity of `solve1` is O(2^n) because for each number `num`, there are two recursive calls (one with `num` included and the other with `num` skipped), and this branching continues until `num` reaches `tot+1`.\\n\\n2. `solve2`:\\n   - Approach: This method uses a more straightforward approach with a loop that starts from the current `num` and iterates up to `tot`. At each iteration, it includes the current number in the combination and recursively explores the next elements.\\n   - Complexity: The time complexity of `solve2` is also O(2^n), but it performs better than `solve1` in practice due to the way the recursion is structured. It avoids some redundant recursive calls that are present in `solve1`.\\n\\nOverall, both methods have the same time complexity, and neither one is inherently more efficient than the other. The key difference is in the way the recursion is structured. `solve1` explores all possible combinations using a binary tree-like structure, while `solve2` explores combinations using a loop.\\n\\nIn practice, `solve2` is likely to perform better than `solve1` due to the reduced overhead from not making redundant recursive calls. However, the exact performance difference between the two methods can vary based on the specific inputs and other factors like the compiler optimizations.\\n\\nIn this case, the `combine` method uses `solve2` to find the combinations, which is a reasonable choice for efficiency and readability. The `solve2` method has a more straightforward implementation and avoids unnecessary recursive calls, making it generally more efficient than `solve1`.\\n\\n# Complexity\\n- Time complexity:$$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: at most $$O(2^n)$$ if k = n \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>>res;\\n    void solve1(int num,int tot,int k,vector<int>&ans){\\n        if(num==tot+1){\\n            //filter the size of subsequence of size k.\\n            if(ans.size()==k)\\n            res.push_back(ans);\\n            return;\\n        }\\n\\n        ans.push_back(num);\\n        solve1(num+1,tot,k,ans);//take current number\\n        ans.pop_back();\\n        solve1(num+1,tot,k,ans);//not take current number\\n    }\\n    void solve2(int num,int tot,int k,vector<int>&ans){\\n      if(ans.size()==k){\\n      res.push_back(ans);\\n      return;\\n      }\\n      for(int i=num;i<=tot;i++){\\n          ans.push_back(i);\\n          solve2(i+1,tot,k,ans);//generating answer in sorted order\\n// 1  12  123 13 like this\\n          ans.pop_back();\\n      }\\n      \\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>ans;\\n        solve2(1,n,k,ans);\\n        return res;\\n    }\\n};\\n```\\n```java []\\nimport java.util.*;\\n\\npublic class Solution {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    void solve1(int num, int tot, int k, List<Integer> ans) {\\n        if (num == tot + 1) {\\n            if (ans.size() == k) {\\n                res.add(new ArrayList<>(ans));\\n            }\\n            return;\\n        }\\n\\n        ans.add(num);\\n        solve1(num + 1, tot, k, ans);\\n        ans.remove(ans.size() - 1);\\n        solve1(num + 1, tot, k, ans);\\n    }\\n\\n    void solve2(int num, int tot, int k, List<Integer> ans) {\\n        if (ans.size() == k) {\\n            res.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        for (int i = num; i <= tot; i++) {\\n            ans.add(i);\\n            solve2(i + 1, tot, k, ans);\\n            ans.remove(ans.size() - 1);\\n        }\\n    }\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        solve2(1, n, k, ans);\\n        return res;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.res = []\\n\\n    def solve1(self, num, tot, k, ans):\\n        if num == tot + 1:\\n            if len(ans) == k:\\n                self.res.append(ans[:])\\n            return\\n\\n        ans.append(num)\\n        self.solve1(num + 1, tot, k, ans)\\n        ans.pop()\\n        self.solve1(num + 1, tot, k, ans)\\n\\n    def solve2(self, num, tot, k, ans):\\n        if len(ans) == k:\\n            self.res.append(ans[:])\\n            return\\n        for i in range(num, tot + 1):\\n            ans.append(i)\\n            self.solve2(i + 1, tot, k, ans)\\n            ans.pop()\\n\\n    def combine(self, n, k):\\n        ans = []\\n        self.solve2(1, n, k, ans)\\n        return self.res\\n\\n```\\n# Make sure to upvote if you understood the solution.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>>res;\\n    void solve1(int num,int tot,int k,vector<int>&ans){\\n        if(num==tot+1){\\n            //filter the size of subsequence of size k.\\n            if(ans.size()==k)\\n            res.push_back(ans);\\n            return;\\n        }\\n\\n        ans.push_back(num);\\n        solve1(num+1,tot,k,ans);//take current number\\n        ans.pop_back();\\n        solve1(num+1,tot,k,ans);//not take current number\\n    }\\n    void solve2(int num,int tot,int k,vector<int>&ans){\\n      if(ans.size()==k){\\n      res.push_back(ans);\\n      return;\\n      }\\n      for(int i=num;i<=tot;i++){\\n          ans.push_back(i);\\n          solve2(i+1,tot,k,ans);//generating answer in sorted order\\n// 1  12  123 13 like this\\n          ans.pop_back();\\n      }\\n      \\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>ans;\\n        solve2(1,n,k,ans);\\n        return res;\\n    }\\n};\\n```\n```java []\\nimport java.util.*;\\n\\npublic class Solution {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    void solve1(int num, int tot, int k, List<Integer> ans) {\\n        if (num == tot + 1) {\\n            if (ans.size() == k) {\\n                res.add(new ArrayList<>(ans));\\n            }\\n            return;\\n        }\\n\\n        ans.add(num);\\n        solve1(num + 1, tot, k, ans);\\n        ans.remove(ans.size() - 1);\\n        solve1(num + 1, tot, k, ans);\\n    }\\n\\n    void solve2(int num, int tot, int k, List<Integer> ans) {\\n        if (ans.size() == k) {\\n            res.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        for (int i = num; i <= tot; i++) {\\n            ans.add(i);\\n            solve2(i + 1, tot, k, ans);\\n            ans.remove(ans.size() - 1);\\n        }\\n    }\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        solve2(1, n, k, ans);\\n        return res;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.res = []\\n\\n    def solve1(self, num, tot, k, ans):\\n        if num == tot + 1:\\n            if len(ans) == k:\\n                self.res.append(ans[:])\\n            return\\n\\n        ans.append(num)\\n        self.solve1(num + 1, tot, k, ans)\\n        ans.pop()\\n        self.solve1(num + 1, tot, k, ans)\\n\\n    def solve2(self, num, tot, k, ans):\\n        if len(ans) == k:\\n            self.res.append(ans[:])\\n            return\\n        for i in range(num, tot + 1):\\n            ans.append(i)\\n            self.solve2(i + 1, tot, k, ans)\\n            ans.pop()\\n\\n    def combine(self, n, k):\\n        ans = []\\n        self.solve2(1, n, k, ans)\\n        return self.res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456495,
                "title": "python-2-solutions-bitmasking-backtracking-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bitmasking**\\n```python\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        def countBit1s(num, n):\\n            bits = 0\\n            for i in range(n):\\n                if (num >> i) & 1:\\n                    bits += 1\\n            return bits\\n        \\n        ans = []\\n        for mask in range(1 << n):\\n            if countBit1s(mask, n) != k: continue\\n            sub = []\\n            for i in range(n):\\n                if (mask >> i) & 1:\\n                    sub.append(i+1)\\n            ans.append(sub)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(2^n * n)`, where `n <= 20`\\n- Space: `O(C(n, k))`, where `k <= n`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Backtracking (Version 1)**\\n```python\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        self.ans = []\\n\\n        def bt(i, path):\\n            if len(path) == k:\\n                self.ans.append(deepcopy(path))\\n                return\\n            if i == n: return\\n\\n            # No pick\\n            bt(i + 1, path)\\n\\n            # Pick\\n            path.append(i + 1)\\n            bt(i + 1, path)\\n            path.pop()\\n\\n        bt(0, [])\\n        return self.ans\\n```\\nComplexity:\\n- Time: `O(C(n, k) * k)`, where `n <= 20`\\n- Space: `O(C(n, k))`, where `k <= n`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Backtracking (Version 2)**\\n```python\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        self.ans = []\\n\\n        def bt(i, path):\\n            if len(path) == k:\\n                self.ans.append(deepcopy(path))\\n                return\\n            \\n            for j in range(i, n):\\n                path.append(j + 1)\\n                bt(j + 1, path)\\n                path.pop()\\n\\n        bt(0, [])\\n        return self.ans\\n```\\nComplexity:\\n- Time: `O(C(n, k) * k)`, where `n <= 20`\\n- Space: `O(C(n, k))`, where `k <= n`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        def countBit1s(num, n):\\n            bits = 0\\n            for i in range(n):\\n                if (num >> i) & 1:\\n                    bits += 1\\n            return bits\\n        \\n        ans = []\\n        for mask in range(1 << n):\\n            if countBit1s(mask, n) != k: continue\\n            sub = []\\n            for i in range(n):\\n                if (mask >> i) & 1:\\n                    sub.append(i+1)\\n            ans.append(sub)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        self.ans = []\\n\\n        def bt(i, path):\\n            if len(path) == k:\\n                self.ans.append(deepcopy(path))\\n                return\\n            if i == n: return\\n\\n            # No pick\\n            bt(i + 1, path)\\n\\n            # Pick\\n            path.append(i + 1)\\n            bt(i + 1, path)\\n            path.pop()\\n\\n        bt(0, [])\\n        return self.ans\\n```\n```python\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        self.ans = []\\n\\n        def bt(i, path):\\n            if len(path) == k:\\n                self.ans.append(deepcopy(path))\\n                return\\n            \\n            for j in range(i, n):\\n                path.append(j + 1)\\n                bt(j + 1, path)\\n                path.pop()\\n\\n        bt(0, [])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27202,
                "title": "fast-simple-python-code-recursive",
                "content": "    def combine(self, n, k):\\n        if k==1:\\n            return [[i] for i in range(1,n+1)]\\n        elif k==n:\\n            return [[i for i in range(1,n+1)]]\\n        else:\\n            rs=[]\\n            rs+=self.combine(n-1,k)\\n            part=self.combine(n-1,k-1)\\n            for ls in part:\\n                ls.append(n)\\n            rs+=part\\n            return rs",
                "solutionTags": [],
                "code": "    def combine(self, n, k):\\n        if k==1:\\n            return [[i] for i in range(1,n+1)]\\n        elif k==n:\\n            return [[i for i in range(1,n+1)]]\\n        else:\\n            rs=[]\\n            rs+=self.combine(n-1,k)\\n            part=self.combine(n-1,k-1)\\n            for ls in part:\\n                ls.append(n)\\n            rs+=part\\n            return rs",
                "codeTag": "Python3"
            },
            {
                "id": 1586007,
                "title": "two-approach-recursive-iterative-c",
                "content": "Implementation\\n\\n\\n**1st Approach\\nRecursive Solution, Backtracking**\\n```\\nclass Solution {\\npublic:\\n    void findCombination(vector<vector<int>> &res, vector<int> temp, int index, int n, int k){\\n        if(temp.size() == k){\\n            res.push_back(temp);\\n            return;\\n        }\\n        for(int itr = index; itr < n; itr++){\\n            temp.push_back(itr+1);\\n            findCombination(res, temp, itr+1, n, k);\\n            temp.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        findCombination(res, vector<int>(), 0, n, k);\\n        return res;\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nIterative Solution**\\n```\\nclass Solution {\\npublic:   \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        vector<int> temp(k, 0);\\n        int itr = 0;\\n        while(itr > -1){\\n            temp[itr]++;\\n            if(temp[itr] > n) itr--;\\n            else if(itr == k-1) res.push_back(temp);\\n            else{                \\n                itr++;\\n                temp[itr] = temp[itr-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Combinatorics",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findCombination(vector<vector<int>> &res, vector<int> temp, int index, int n, int k){\\n        if(temp.size() == k){\\n            res.push_back(temp);\\n            return;\\n        }\\n        for(int itr = index; itr < n; itr++){\\n            temp.push_back(itr+1);\\n            findCombination(res, temp, itr+1, n, k);\\n            temp.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        findCombination(res, vector<int>(), 0, n, k);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:   \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        vector<int> temp(k, 0);\\n        int itr = 0;\\n        while(itr > -1){\\n            temp[itr]++;\\n            if(temp[itr] > n) itr--;\\n            else if(itr == k-1) res.push_back(temp);\\n            else{                \\n                itr++;\\n                temp[itr] = temp[itr-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27090,
                "title": "dp-for-the-problem",
                "content": "I didn't see any DP solution for this problem, so I share mine:\\nThe idea is simple, if the combination k out of n (select k elements from [1,n]) is combine(k, n).\\n\\nLet's consider how can we get combine(k, n) by adding the last element n to something we already have (combine(k - 1, n - 1) and combine(k, n - 1)). Actually, the combine(k, n) has two parts, one part is all combinations without n, it's combine(k, n - 1), another is all combinations with n, which can be gotten by appending n to every element in combine(k - 1, n - 1). Note, the combine(i, i) is what we can get directly.\\n\\nBelow is my code:\\n\\n\\n    public class Solution\\n    {\\n        // Combine(n, n).\\n        private List<Integer> allContain(int n)\\n        {\\n            final List<Integer> result = new ArrayList<>();\\n            for (int i = 1; i <= n; ++i)\\n            {\\n                result.add(i);\\n            }\\n            \\n            return result;\\n        }\\n        \\n        public List<List<Integer>> combine(int n, int k)\\n        {\\n            List<List<List<Integer>>> previous = new ArrayList<>();\\n            \\n            for (int i = 0; i <= n; ++i)\\n            {\\n                previous.add(Collections.singletonList(Collections.<Integer>emptyList()));\\n            }\\n            \\n            for (int i = 1; i <= k; ++i)\\n            {\\n                final List<List<List<Integer>>> current = new ArrayList<>();\\n                current.add(Collections.singletonList(allContain(i)));\\n                \\n                // Combine(i, j).\\n                for (int j = i + 1; j <= n; ++j)\\n                {\\n                    final List<List<Integer>> list = new ArrayList<>();\\n                    \\n                    // Combine(i, j - 1).\\n                    list.addAll(current.get(current.size() - 1));\\n                    \\n                    // Comine(i - 1, j - 1).\\n                    for (final List<Integer> item : previous.get(current.size()))\\n                    {\\n                        final List<Integer> newItem = new ArrayList<>(item);\\n                        newItem.add(j);\\n                        list.add(newItem);\\n                    }\\n                    \\n                    current.add(list);\\n                }\\n                \\n                previous = current;\\n            }\\n            \\n            return (previous.size() == 0) ? Collections.<List<Integer>>emptyList() : previous.get(previous.size() - 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        // Combine(n, n).\\n        private List<Integer> allContain(int n)\\n        {\\n            final List<Integer> result = new ArrayList<>();\\n            for (int i = 1; i <= n; ++i)\\n            {\\n                result.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 27032,
                "title": "iterative-java-solution",
                "content": "Hi guys!\\n\\nThe idea is to iteratively generate combinations for all lengths from 1 to k. We start with a list of all numbers <= n as combinations for k == 1. When we have all combinations of length k-1, we can get the new ones for a length k with trying to add to each one all elements that are <= n and greater than the last element of a current combination. \\n\\nI think the code here will be much more understandable than further attempts to explain. :) See below.\\n\\nHope it helps!\\n\\n----------\\n\\n    public class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            if (k == 0 || n == 0 || k > n) return Collections.emptyList();\\n            List<List<Integer>> combs = new ArrayList<>();\\n            for (int i = 1; i <= n; i++) combs.add(Arrays.asList(i));\\n            for (int i = 2; i <= k; i++) {\\n                List<List<Integer>> newCombs = new ArrayList<>();\\n                for (int j = i; j <= n; j++) {\\n                    for (List<Integer> comb : combs) {\\n                        if (comb.get(comb.size()-1) < j) {\\n                            List<Integer> newComb = new ArrayList<>(comb);\\n                            newComb.add(j);\\n                            newCombs.add(newComb);\\n                        }\\n                    }\\n                }\\n                combs = newCombs;\\n            }\\n            return combs;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            if (k == 0 || n == 0 || k > n) return Collections.emptyList();\\n            List<List<Integer>> combs = new ArrayList<>();\\n            for (int i = 1; i <= n; i++) combs.add(Arrays.asList(i));\\n            for (int i = 2; i <= k; i++) {\\n                List<List<Integer>> newCombs = new ArrayList<>();\\n                for (int j = i; j <= n; j++) {\\n                    for (List<Integer> comb : combs) {\\n                        if (comb.get(comb.size()-1) < j) {\\n                            List<Integer> newComb = new ArrayList<>(comb);\\n                            newComb.add(j);\\n                            newCombs.add(newComb);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 729397,
                "title": "python3-solution-with-detailed-explanation",
                "content": "Combination questions can be solved with `dfs` most of the time. I\\'m following [caikehe](https://leetcode.com/problems/combinations/discuss/26990/Easy-to-understand-Python-solution-with-comments.)\\'s approach. Also, if you want to fully understand this concept and [backtracking](https://www.***.org/backtracking-introduction/), try to finish [this](https://leetcode.com/problems/combination-sum/discuss/429538/General-Backtracking-questions-solutions-in-Python-for-reference-%3A) post and do all the examples. \\n\\n\\nWe have an array `[1, 2, ..., n]`, if `k == 0`, meaning combination of zero numbers which is nothing (lines `#7, 8, 9`), right? Return `[[]]`. \\n\\n\\n```\\ndef combine(self, n, k):\\n    res = [] #1\\n    self.dfs(range(1,n+1), k, 0, [], res) #2\\n    return res #3\\n    \\ndef dfs(self, nums, k, index, path, res):  #4\\n\\tprint(\\'index is:\\', index)\\n    print(\\'path is:\\', path)\\n    if k == 0:  #7\\n        res.append(path)  #8\\n        return # backtracking  #9 \\n    for i in range(index, len(nums)):  #10\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)  #11\\n```\\nLines `#1, 2, 3` are the main function, where you initialize `res = []`. Also, you call the `dfs` function to find all the combinations, and finally, you return the `res`. The `dfs` function is the main part of the code. Lines `#7, 8` were explained before. `dfs`fuction goes into deeper levels until these two lines get activated. Keep reading.  \\n\\nLet\\'s do an example for the rest! I define levels as the number of times `dfs` gets called recursively before moving on in the `for` loop of line `#10`. \\n\\n---- Level 0 (input: `nums`, `k=2`, `index = 0`, `path = []`, `res = []`). \\nThe idea of `dfs` is that it starts from first entry of `nums = [1, 2, ..., n]`. At first, `nums[0]` gets chosen in line `#10`, it calls the `dfs` again in line `#11` with updated inputs and goes basically one level deeper to choose the second number in the combination (note that his combination would look something like `[1, ...]`, right? `nums` doesn\\'t change, but since we have already chosen one entry, variables get updated `k = k - 1`. Also, since we\\'re already chosen entry `0`, `index` variable becomes `i = i +1` to go one step deeper. \\n\\n---- Level 1  (input: `nums`, `k=1`, `index = 1`, `path = [1]`, `res = []`).\\nNow, in line `#10`, the `range` changes. It starts from `1` to `len(nums)`. It goes in and calls `dfs` one more time.\\n\\n\\n--- Level 2 (input: `nums`, `k=0`, `index = 2`, `path = [1,2]]`, `res = []`).\\nThis time it gets stuck in line `#7`, and appends `path` to `res`. Now, `res = [[1,2]]`. \\n\\nDoes this make sense? \\n\\nAll these level just return one combination, right? ( `res = [[1,2]]`). Remember going into deeper levels happened when we were in line `#10` and called `dfs` for the first time in line `#11`, and then for the second time in level 1, and we ended up in level 2 and got stuck in line `#7`. Now, we go back one step to level 1 and move on in line `#10`. This time, `i = 1` and `index = 2`. Again we go back to level 2 and return `path = [1,3]`. This will be appended to `res` to get to `res = [[1,2],[1,3]]`. Finally, we exhaust all indices in level 1. We end up with `res = [[1,2],[1,3],[1,4]]`. We go up one level, to level 0. Move on in line `#10`, this time, we\\'ll get to `path = [[2,3],[2,4]]`, and will update `res = [[1,2],[1,3],[1,3],[2,3],[2,4]]`. We keep going to get the final combination, we\\'re done. \\n\\n\\nIf you want to fully understand how this works, try to print some variables at the start of your `dfs` function. I printed `index` and `path` and this is the outcome. \\n\\n```\\nindex is: 0\\npath is: []\\nindex is: 1\\npath is: [1]\\nindex is: 2\\npath is: [1, 2]\\nindex is: 3\\npath is: [1, 3]\\nindex is: 4\\npath is: [1, 4]\\nindex is: 2\\npath is: [2]\\nindex is: 3\\npath is: [2, 3]\\nindex is: 4\\npath is: [2, 4]\\nindex is: 3\\npath is: [3]\\nindex is: 4\\npath is: [3, 4]\\nindex is: 4\\npath is: [4]\\n\\nFinal output: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\\n```\\n\\nAnother way of doing this without the `index` variable is:\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        res = []\\n        self.dfs(range(1,n+1), k, [], res)\\n        return res\\n        \\n    def dfs(self, nums, k, path, res):\\n        if k == 0:\\n            res.append(path)\\n            return res\\n        \\n        if len(nums) >= k:\\n            for i in range(len(nums)):\\n                self.dfs(nums[i+1:], k-1, path+[nums[i]], res)\\n        return\\n```\\n\\nThat\\'s it! \\n\\n=====================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it. \\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = [] #1\\n    self.dfs(range(1,n+1), k, 0, [], res) #2\\n    return res #3\\n    \\ndef dfs(self, nums, k, index, path, res):  #4\\n\\tprint(\\'index is:\\', index)\\n    print(\\'path is:\\', path)\\n    if k == 0:  #7\\n        res.append(path)  #8\\n        return # backtracking  #9 \\n    for i in range(index, len(nums)):  #10\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)  #11\\n```\n```\\nindex is: 0\\npath is: []\\nindex is: 1\\npath is: [1]\\nindex is: 2\\npath is: [1, 2]\\nindex is: 3\\npath is: [1, 3]\\nindex is: 4\\npath is: [1, 4]\\nindex is: 2\\npath is: [2]\\nindex is: 3\\npath is: [2, 3]\\nindex is: 4\\npath is: [2, 4]\\nindex is: 3\\npath is: [3]\\nindex is: 4\\npath is: [3, 4]\\nindex is: 4\\npath is: [4]\\n\\nFinal output: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\\n```\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        res = []\\n        self.dfs(range(1,n+1), k, [], res)\\n        return res\\n        \\n    def dfs(self, nums, k, path, res):\\n        if k == 0:\\n            res.append(path)\\n            return res\\n        \\n        if len(nums) >= k:\\n            for i in range(len(nums)):\\n                self.dfs(nums[i+1:], k-1, path+[nums[i]], res)\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794032,
                "title": "python-js-go-by-dfs-backtracking-w-hint",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u8AAA\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=ITwWVCfLgug&t=468s )\\n\\nHint & recall:\\n\\n**DFS template** with **backtracking**\\n\\n```\\ndef dfs( parameter ):\\n\\n\\tif stop condtion or base case:\\n\\t\\t# base case:\\n\\t\\tupdate result\\n\\t    return\\n\\t\\n\\telse:\\n\\t\\t# general cases:\\n\\t\\tfor all possible next moves:\\n\\t\\t\\n\\t\\t    select one next move\\n\\t\\t\\tdfs( paramter with selected next move )\\n\\t\\t\\tundo the selection\\n\\t\\n\\t\\treturn\\n```\\n\\n---\\n\\n**Implementation** by DFS + backtracking in Python\\n\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        result = []\\n        \\n        def gen_comb(start, cur_comb):\\n            \\n            if k == len(cur_comb):\\n                # base case, also known as stop condition        \\n\\t\\t\\t\\t\\n                result.append( cur_comb[::] )\\n                return\\n            \\n            else:\\n                # general case:\\n                \\n                # solve in DFS\\n                for i in range(start, n+1):\\n                    \\n                    cur_comb.append( i )\\n                    \\n                    gen_comb(i+1, cur_comb)\\n                    \\n                    cur_comb.pop()\\n                \\n                return\\n        # ----------------------------------------------\\n        \\n        gen_comb( start=1, cur_comb=[] )\\n        return result\\n```\\n\\n---\\n\\n**Implementation** by DFS + backtracking in JS\\n\\n```\\nvar combine = function(n, k) {\\n    \\n    function* comb(start, curComb ){\\n        \\n        if(curComb.length == k){\\n            yield curComb;\\n            return;\\n        }\\n        \\n        for(let i = start; i <= n ; i++){\\n            yield* comb(i+1, [...curComb, i] );\\n        }\\n        return\\n    }\\n    \\n    \\n    return [ ...comb(start=1, curComb=[]) ];\\n};\\n```\\n\\nor \\n\\n```\\nvar combine = function(n, k) {\\n    \\n    result = []\\n    //-----------------------------------\\n    var comb = function(start, curComb ){\\n        \\n        // Base case:\\n        if(curComb.length == k){\\n            result.push( [...curComb] ) ;\\n            return;\\n        }\\n        \\n        // General cases:\\n        for(let i = start; i <= n ; i++){\\n            curComb.push( i );\\n            comb(i+1, curComb );\\n            curComb.pop()\\n        }\\n        return\\n    }\\n    //-----------------------------------\\n    comb(start=1, curComb=[]);\\n    return result;\\n};\\n```\\n\\n---\\n\\n**Implementation** by DFS + backtracking in Go\\n\\n```\\nfunc combine(n int, k int) [][]int {\\n    \\n    result := make([][]int, 0)\\n    \\n    //-------------------------------------------\\n    var comb func(start int, curComb []int)\\n    \\n    comb = func(start int, curComb []int){\\n        \\n        // Base case \\n        if len(curComb) == k{\\n            \\n            \\n            // make a copy of current combination\\n            dst := make([]int, k)\\n            copy(dst, curComb)\\n            result = append(result, dst)\\n            return\\n        }    \\n        \\n        // General cases:\\n        for i := start ; i <= n ; i++{\\n            curComb = append(curComb, i)\\n            comb(i+1, curComb)\\n            curComb = curComb[:len(curComb)-1]\\n        }\\n        return\\n    }\\n    //-------------------------------------------\\n    comb(1, make([]int,0) )\\n    return result    \\n}\\n```\\n\\n---\\n\\n**Implementation** by math formula for combination in Python\\n\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        def comb(n, k):\\n            \\n            if n == 0 :\\n                return [ [] ]\\n            \\n            elif n == k:\\n                return  [ [ i for i in range(1, n+1)] ]\\n            \\n            elif k == 1:\\n                return [ [i] for i in range(1,n+1) ]\\n\\n            else:\\n                \\n                # By math formula: C(n, k) = C(n-1, k-1) + C(n-1, k)\\n                take_n = [ c + [n] for c in comb( n-1, k-1 ) ]\\n                not_to_take_n = [ c for c in comb( n-1, k ) ]\\n\\n                return take_n + not_to_take_n\\n            \\n        # --------------------------------------\\n        \\n        return comb(n, k)\\n```\\n\\n---\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Go",
                    "Math",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs( parameter ):\\n\\n\\tif stop condtion or base case:\\n\\t\\t# base case:\\n\\t\\tupdate result\\n\\t    return\\n\\t\\n\\telse:\\n\\t\\t# general cases:\\n\\t\\tfor all possible next moves:\\n\\t\\t\\n\\t\\t    select one next move\\n\\t\\t\\tdfs( paramter with selected next move )\\n\\t\\t\\tundo the selection\\n\\t\\n\\t\\treturn\\n```\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        result = []\\n        \\n        def gen_comb(start, cur_comb):\\n            \\n            if k == len(cur_comb):\\n                # base case, also known as stop condition        \\n\\t\\t\\t\\t\\n                result.append( cur_comb[::] )\\n                return\\n            \\n            else:\\n                # general case:\\n                \\n                # solve in DFS\\n                for i in range(start, n+1):\\n                    \\n                    cur_comb.append( i )\\n                    \\n                    gen_comb(i+1, cur_comb)\\n                    \\n                    cur_comb.pop()\\n                \\n                return\\n        # ----------------------------------------------\\n        \\n        gen_comb( start=1, cur_comb=[] )\\n        return result\\n```\n```\\nvar combine = function(n, k) {\\n    \\n    function* comb(start, curComb ){\\n        \\n        if(curComb.length == k){\\n            yield curComb;\\n            return;\\n        }\\n        \\n        for(let i = start; i <= n ; i++){\\n            yield* comb(i+1, [...curComb, i] );\\n        }\\n        return\\n    }\\n    \\n    \\n    return [ ...comb(start=1, curComb=[]) ];\\n};\\n```\n```\\nvar combine = function(n, k) {\\n    \\n    result = []\\n    //-----------------------------------\\n    var comb = function(start, curComb ){\\n        \\n        // Base case:\\n        if(curComb.length == k){\\n            result.push( [...curComb] ) ;\\n            return;\\n        }\\n        \\n        // General cases:\\n        for(let i = start; i <= n ; i++){\\n            curComb.push( i );\\n            comb(i+1, curComb );\\n            curComb.pop()\\n        }\\n        return\\n    }\\n    //-----------------------------------\\n    comb(start=1, curComb=[]);\\n    return result;\\n};\\n```\n```\\nfunc combine(n int, k int) [][]int {\\n    \\n    result := make([][]int, 0)\\n    \\n    //-------------------------------------------\\n    var comb func(start int, curComb []int)\\n    \\n    comb = func(start int, curComb []int){\\n        \\n        // Base case \\n        if len(curComb) == k{\\n            \\n            \\n            // make a copy of current combination\\n            dst := make([]int, k)\\n            copy(dst, curComb)\\n            result = append(result, dst)\\n            return\\n        }    \\n        \\n        // General cases:\\n        for i := start ; i <= n ; i++{\\n            curComb = append(curComb, i)\\n            comb(i+1, curComb)\\n            curComb = curComb[:len(curComb)-1]\\n        }\\n        return\\n    }\\n    //-------------------------------------------\\n    comb(1, make([]int,0) )\\n    return result    \\n}\\n```\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        def comb(n, k):\\n            \\n            if n == 0 :\\n                return [ [] ]\\n            \\n            elif n == k:\\n                return  [ [ i for i in range(1, n+1)] ]\\n            \\n            elif k == 1:\\n                return [ [i] for i in range(1,n+1) ]\\n\\n            else:\\n                \\n                # By math formula: C(n, k) = C(n-1, k-1) + C(n-1, k)\\n                take_n = [ c + [n] for c in comb( n-1, k-1 ) ]\\n                not_to_take_n = [ c for c in comb( n-1, k ) ]\\n\\n                return take_n + not_to_take_n\\n            \\n        # --------------------------------------\\n        \\n        return comb(n, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340156,
                "title": "straight-forward-approach-easiest-explaination-java-code",
                "content": "Here we have used Backtracking ***(TAKE & DON\\'T TAKE Concept)*** to achieve the Possible Combinations. \\n\\nLet us understand the Methdology -\\n**1.** The recursive function must have a Base (End) condition, right? So in our case what will be the base condition?\\n**2.** Inside the recursive function **(solveitforMe)**, we are checking if the size of the combinations arraylist is equal to the k (where k is the value, which should be the size of the inner list) or not. If yes, then we have to add the combinations list with the main result arraylist. Else repeat the recursive function.\\n**3.** Below recursive function **(solveitforMe)** will execute till num is less than n+1,and save the combinations of size k inside our combinations arraylist. When we have saved that combinations arraylist inside our result arraylist, then we will backtrack using the line -`combinations.remove(combinations.size()-1);`  It will remove the last added element and will make way for the nex new element.\\n\\n**As Mentioned in Below Image:-**\\n\\n![image](https://assets.leetcode.com/users/images/42e98acf-883c-446a-9503-ac2edd6a77f5_1658910246.3118813.jpeg)\\n\\n\\n**Here the Code Part (In Java):-**\\n\\nclass Solution {\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();            //used to store the result (all the possible combonations)\\n        List<Integer> combinations = new ArrayList<>();            //use to store the combinations or we can say that subset\\n        \\n        solveitforMe(1,n,k,combinations,result);                   //Actual recursive logic\\n        \\n        return result;                \\n    }\\n    \\n    private void solveitforMe(int num, int n, int k, List<Integer> combinations, List<List<Integer>> result){\\n        \\n        if(num>n+1)                                         //OUR BASE CONDITION...if num is greater than the given n+1 then return (No more recusrive calls)\\n            return;\\n        \\n        if(combinations.size() == k){                       //ANOTHER BASE CONDITION... if temp list size i=is equals to the given k, then it means we one of our combinations\\n            // System.out.println(combinations);\\n            result.add(new ArrayList(combinations));        //Add that combination into the result list and return\\n            return;\\n        }\\n        \\n        combinations.add(num);                              //Add(TAKE) that number (we two choose TAKE & DON\\'T TAKE)\\n        solveitforMe(num+1,n,k,combinations,result);        //Do the recursive call further\\n        \\n        combinations.remove(combinations.size()-1);         //DON\\'T TAKE that number\\n        solveitforMe(num+1,n,k,combinations,result);        // & Do the recursive call further\\n        \\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();            //used to store the result (all the possible combonations)\\n        List<Integer> combinations = new ArrayList<>();            //use to store the combinations or we can say that subset\\n        \\n        solveitforMe(1,n,k,combinations,result);                   //Actual recursive logic\\n        \\n        return result;                \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 27081,
                "title": "c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combine(int n, int k) {\\n            vector<vector<int>> ans;\\n            vector<int> temp;\\n            combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n\\n            return ans;\\n        }\\n    private:\\n           void combine(int begin,int n, int k, vector<vector<int>> &ans, vector<int>& temp){\\n                if(k==0){ \\n                    ans.push_back(temp);\\n                    return;\\n                } \\n                //condition : n-i+1 is the range, range must greater than k\\n                for(int i=begin;n-i+1>=k;i++){ // for the ith iteration, get the combination of i and k-1 numbers differ from i.\\n                    temp.push_back(i); \\n                    combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) \\n                    temp.pop_back();\\n                }\\n            }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combine(int n, int k) {\\n            vector<vector<int>> ans;\\n            vector<int> temp;\\n            combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1409224,
                "title": "python-4-approaches-explained-visualized",
                "content": "-------------------------------------------------------\\n[1] Sub-optimal Iterative: TLE : 23 / 27 test cases passed.\\n-------------------------------------------------------\\n-------------------------------------------------------\\n- Generate all nodes/permutations (n!)\\n- Check if the same combo seen before by sorting\\n- `O(n!) * O(n!)`\\nSimialr to permutations : https://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis\\n```\\ndef combine(self, n: int, k: int) -> List[List[int]]:\\n\\tres = []\\n\\t# seen = set() # -- we cannot use sum becuz 2+3 = 1+4\\n\\tnums = list(range(1, n+1))\\n\\tstack = [([], nums[::-1])]\\n\\twhile stack:\\n\\t\\tcombo, nums = stack.pop()\\n\\t\\tif len(combo) == k: # or if nums = n - k\\n\\t\\t\\tif sorted(combo) not in res:\\n\\t\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tif len(combo) >= k:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tnewCombo = combo + [nums[i]]\\n\\t\\t\\tstack.append((newCombo, newNums))\\n\\treturn res\\n```\\n-------------------------------------------------------\\n[2] Recursive - without backtracking\\n-------------------------------------------------------\\n-------------------------------------------------------\\n- Runtime: 524 ms, faster than 40.75% of Python3\\n- Time : O(n C k) - only generate/traverse combinations that are size k\\n- Space: O(n C k)\\n\\n![image](https://assets.leetcode.com/users/images/98c118a8-e58d-4544-a86a-cf0d414fb484_1629207443.824713.jpeg)\\n- To make sure we do not generate permutations (different arrangement of the same combination)\\n\\t- The difference between generating permutations and combinations is that when generating the children node for the latter:\\n\\t   - Only generate nodes whose indecies are greater than the current idex\\n![image](https://assets.leetcode.com/users/images/2eba5eb0-7167-40af-ba27-bd61d586eb2c_1629207454.9767716.jpeg)\\n\\n```\\ndef combine(self, n: int, k: int) -> List[List[int]]:\\n # -- helper\\n def recurse(start, combo):\\n\\t if len(combo) == k:\\n\\t\\t res.append(combo)\\n\\n\\t else:\\n\\t\\t for i in range(start, n+1): # - traverse horizontal - move to/generate sibling node\\n\\t\\t\\t newCombo = combo + [i]\\n\\t\\t\\t recurse(i+1, newCombo) # - traverse vertically - DFS\\n\\t\\t return res\\n\\n # -- main\\n res = []\\n return recurse(1, [])\\n````        \\n-------------------------------------------------------\\n[3] Recursive - with backtracking\\n-------------------------------------------------------\\n-------------------------------------------------------\\n- Runtime: 460 ms, faster than 67.80% of Python3\\n- Time : O(n C k) - only generate/traverse combinations that are size k\\n- Space: O(n C k)\\n```\\ndef combine(self, n: int, k: int) -> List[List[int]]:\\n\\n\\t# -- helper\\n\\tdef recurse(start, combo):\\n\\t\\tif len(combo) == k:\\n\\t\\t\\tres.append(combo[::]) # take a copy of combo at leaf before you pop/backtrack\\n\\t\\telse:\\n\\t\\t\\tfor i in range(start, n+1):\\n\\t\\t\\t\\tcombo.append(i) # maintain one combo variable for entire space tree\\n\\t\\t\\t\\trecurse(i+1, combo)\\n\\t\\t\\t\\tcombo.pop() # - bactrack to move horiontally to sibling node\\n\\t\\t\\treturn res\\n\\t# main\\n\\tres = []\\n\\treturn recurse(1, [])\\n```\\n-------------------------------------------------------\\n[4] iterative\\n-------------------------------------------------------\\n-------------------------------------------------------\\n- 560 ms faster than 29%\\n- Time : O(n C k) - only generate/traverse combinations that are size k\\n- Space: O(n C k)\\n\\n```\\ndef combine(self, n: int, k: int) -> List[List[int]]:\\n\\tres = []\\n\\tstack = [(1, [])]\\n\\twhile stack:\\n\\t\\tstart, combo = stack.pop()\\n\\t\\tif len(combo) == k:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\telse: # -- Limit the length of combo to k\\n\\t\\t\\tfor i in range(start, n+1):\\n\\t\\t\\t\\tnewCombo = combo + [i]\\n\\t\\t\\t\\tstack.append((i+1, newCombo)) # -- go deeper\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef combine(self, n: int, k: int) -> List[List[int]]:\\n\\tres = []\\n\\t# seen = set() # -- we cannot use sum becuz 2+3 = 1+4\\n\\tnums = list(range(1, n+1))\\n\\tstack = [([], nums[::-1])]\\n\\twhile stack:\\n\\t\\tcombo, nums = stack.pop()\\n\\t\\tif len(combo) == k: # or if nums = n - k\\n\\t\\t\\tif sorted(combo) not in res:\\n\\t\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tif len(combo) >= k:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tnewCombo = combo + [nums[i]]\\n\\t\\t\\tstack.append((newCombo, newNums))\\n\\treturn res\\n```\n```\\ndef combine(self, n: int, k: int) -> List[List[int]]:\\n # -- helper\\n def recurse(start, combo):\\n\\t if len(combo) == k:\\n\\t\\t res.append(combo)\\n\\n\\t else:\\n\\t\\t for i in range(start, n+1): # - traverse horizontal - move to/generate sibling node\\n\\t\\t\\t newCombo = combo + [i]\\n\\t\\t\\t recurse(i+1, newCombo) # - traverse vertically - DFS\\n\\t\\t return res\\n\\n # -- main\\n res = []\\n return recurse(1, [])\\n```\n```\\ndef combine(self, n: int, k: int) -> List[List[int]]:\\n\\n\\t# -- helper\\n\\tdef recurse(start, combo):\\n\\t\\tif len(combo) == k:\\n\\t\\t\\tres.append(combo[::]) # take a copy of combo at leaf before you pop/backtrack\\n\\t\\telse:\\n\\t\\t\\tfor i in range(start, n+1):\\n\\t\\t\\t\\tcombo.append(i) # maintain one combo variable for entire space tree\\n\\t\\t\\t\\trecurse(i+1, combo)\\n\\t\\t\\t\\tcombo.pop() # - bactrack to move horiontally to sibling node\\n\\t\\t\\treturn res\\n\\t# main\\n\\tres = []\\n\\treturn recurse(1, [])\\n```\n```\\ndef combine(self, n: int, k: int) -> List[List[int]]:\\n\\tres = []\\n\\tstack = [(1, [])]\\n\\twhile stack:\\n\\t\\tstart, combo = stack.pop()\\n\\t\\tif len(combo) == k:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\telse: # -- Limit the length of combo to k\\n\\t\\t\\tfor i in range(start, n+1):\\n\\t\\t\\t\\tnewCombo = combo + [i]\\n\\t\\t\\t\\tstack.append((i+1, newCombo)) # -- go deeper\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3846748,
                "title": "python-c-c-99-backtrack-with-graph-explained-beginner-friendly",
                "content": "# Intuition\\nThis is a backtracking problem.\\nWe made a recursion function, and get all combinations by take or not take specific number.\\n\\n# Approach\\n## variables\\n`nums` is the current combination.\\n`pos` is the current position in `nums`\\n`cur` is the current number\\n\\nIn the function `backtrack`:\\nIf `pos == k`, we know that we got one of the combination.\\nIf `pos != k`, we can try every possible number to fit in the current position, then we call `backtrack` again.\\n\\n## Here is a graph for better understand\\n![image.png](https://assets.leetcode.com/users/images/662b5a0c-06a4-4ab0-81cb-686d45083b22_1690876441.72758.png)\\n\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/LchAVxik/shared\" frameBorder=\"0\" width=\"1500\" height=\"800\"></iframe>\\n\\n# Please UPVOTE if this helps you!!\\n![image.png](https://assets.leetcode.com/users/images/4398d9d1-2d84-4491-a253-b008ab0aaae7_1690875002.0471663.png)\\n![image.png](https://assets.leetcode.com/users/images/1c4d8242-7ccb-483b-8920-1b918c7488ea_1690875941.0002797.png)\\n![image.png](https://assets.leetcode.com/users/images/355d3712-b3ce-4e07-a742-7698b41245cd_1690875966.649884.png)\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Backtracking"
                ],
                "code": "# Intuition\\nThis is a backtracking problem.\\nWe made a recursion function, and get all combinations by take or not take specific number.\\n\\n# Approach\\n## variables\\n`nums` is the current combination.\\n`pos` is the current position in `nums`\\n`cur` is the current number\\n\\nIn the function `backtrack`:\\nIf `pos == k`, we know that we got one of the combination.\\nIf `pos != k`, we can try every possible number to fit in the current position, then we call `backtrack` again.\\n\\n## Here is a graph for better understand\\n![image.png](https://assets.leetcode.com/users/images/662b5a0c-06a4-4ab0-81cb-686d45083b22_1690876441.72758.png)\\n\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/LchAVxik/shared\" frameBorder=\"0\" width=\"1500\" height=\"800\"></iframe>\\n\\n# Please UPVOTE if this helps you!!\\n![image.png](https://assets.leetcode.com/users/images/4398d9d1-2d84-4491-a253-b008ab0aaae7_1690875002.0471663.png)\\n![image.png](https://assets.leetcode.com/users/images/1c4d8242-7ccb-483b-8920-1b918c7488ea_1690875941.0002797.png)\\n![image.png](https://assets.leetcode.com/users/images/355d3712-b3ce-4e07-a742-7698b41245cd_1690875966.649884.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1936350,
                "title": "recursive-and-iterative-solution-using-c-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursive & Backtracking.***\\n- As we have to take elements from 1 to n, first we\\u2019re passing 1 for the first time to our recursive function.\\n- Base case will be when the temp size will be equal to k, we\\u2019ll push to ans and return it.\\n- Else we\\u2019ll iterate with a loop till current number to n & make a recursive call for next numbers.\\n- Also after the function comes back we\\u2019ve to remove the element from temp and continue the loop.\\n- **Time complexity:** O((nCk)*k), where nCk is all possible subsets and k to copy subsets into ans vector.\\n- **Space complexity:** O((nCk)*k), to store all n C k subset in the ans vector of size k.\\n\\n### Solution 02\\n\\n- Using ***Iterative Approach.***\\n- Here we have 3 test cases:\\n    1. `if(temp[itr] > n)` Here, temp array at the itr position is exhausted. So there is no possible value that can be inserted at this position anymore. Since we started with the temp being filled with all zeros and incremented it step by step, we must have already passed all possible values for that index. In this case, we step back to one index and see if we can still increase the one element at the index behind.\\n    2. `if(itr == k-1)` Here, we have reached the end of our possible combination. Each of our combinations has a max length of k, so it doesn\\'t make sense to look at arrays that are larger than that. At this point, we can just add to our final result whichever value we\\'ve found.\\n    3. `else` we are in a scenario where both 1. and 2. are not satisfied. This means that our temp array at the itr position is NOT exhausted and we are NOT at the end of our array. In this case, we fix the value at itr and step one index ahead and start increasing the value at itr+1. We also copy the value of itr to itr+1 because to avoid duplications we make sure that our array always maintains the property that it is sorted in increasing order.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        \\n        help(1, temp, ans, n, k);\\n        return ans;\\n    }\\n    \\n    void help(int num, vector<int> &temp, vector<vector<int>> &ans, int n, int k){\\n        if(temp.size() == k){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=num; i<=n; i++){\\n            temp.push_back(i);\\n            help(i+1, temp, ans, n, k);\\n            temp.pop_back();   \\n        }\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:   \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        vector<int> temp(k, 0);\\n        int itr = 0;\\n\\n        while(itr > -1){\\n            temp[itr]++;\\n            if(temp[itr] > n) itr--;\\n            else if(itr == k-1) res.push_back(temp);\\n            else{                \\n                itr++;\\n                temp[itr] = temp[itr-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        \\n        help(1, temp, ans, n, k);\\n        return ans;\\n    }\\n    \\n    void help(int num, vector<int> &temp, vector<vector<int>> &ans, int n, int k){\\n        if(temp.size() == k){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=num; i<=n; i++){\\n            temp.push_back(i);\\n            help(i+1, temp, ans, n, k);\\n            temp.pop_back();   \\n        }\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:   \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        vector<int> temp(k, 0);\\n        int itr = 0;\\n\\n        while(itr > -1){\\n            temp[itr]++;\\n            if(temp[itr] > n) itr--;\\n            else if(itr == k-1) res.push_back(temp);\\n            else{                \\n                itr++;\\n                temp[itr] = temp[itr-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475116,
                "title": "backtracking-easy-to-understand-faster-simple-javascript-submission",
                "content": "**Please do upvote, it motivates me to write more such post\\uD83D\\uDE03**\\n\\n```\\nvar combine = function(n, k) {\\n    let out = comb(k, n);\\n    // console.log(out);\\n    return out;\\n};\\n\\n\\nfunction comb(max, n, out=[], curr = [], index = 1){\\n    if(curr.length===max){\\n        out.push(curr);\\n        return [];\\n    }\\n    else{\\n        while(index<=n){\\n            comb(max, n, out, [...curr, index], ++index);\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar combine = function(n, k) {\\n    let out = comb(k, n);\\n    // console.log(out);\\n    return out;\\n};\\n\\n\\nfunction comb(max, n, out=[], curr = [], index = 1){\\n    if(curr.length===max){\\n        out.push(curr);\\n        return [];\\n    }\\n    else{\\n        while(index<=n){\\n            comb(max, n, out, [...curr, index], ++index);\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846165,
                "title": "c-bits-approach-day-1",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>ans;\\n        for(int i=0;i<(1<<n) ;i++){\\n            vector<int>v;\\n            int f = __builtin_popcountll(i);\\n            if(f!=k)continue;\\n            for(int j=0;j<n;j++){\\n                if((1<<j) & i){\\n                    v.push_back(j+1);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/09b697bd-323a-4b95-bf73-f51a8a72546d_1690869475.4465623.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>ans;\\n        for(int i=0;i<(1<<n) ;i++){\\n            vector<int>v;\\n            int f = __builtin_popcountll(i);\\n            if(f!=k)continue;\\n            for(int j=0;j<n;j++){\\n                if((1<<j) & i){\\n                    v.push_back(j+1);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845903,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing backtracking to create all possible combinations.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/oDn_6n0ahkM\\n\\n# Subscribe to my channel from here. I have 237 videos as of August 1st\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Create an empty list `res` to store the final combinations and an empty list `comb` to store the current combination being formed.\\n\\n2. Define a recursive function `backtrack(start)`, which will generate all possible combinations of size `k` from the numbers starting from `start` up to `n`.\\n\\n3. In the `backtrack` function:\\n   - If the length of `comb` becomes equal to `k`, it means we have formed a valid combination, so we append a copy of the current `comb` list to the `res` list. We use `comb[:]` to create a copy of the list since lists are mutable in Python, and we want to preserve the combination at this point without being modified later.\\n\\n   - If the length of `comb` is not equal to `k`, we continue the recursion.\\n   \\n4. Within the `backtrack` function, use a loop to iterate over the numbers starting from `start` up to `n`.\\n   - For each number `num` in the range, add it to the current `comb` list to form the combination.\\n   \\n   - Make a recursive call to `backtrack` with `start` incremented by 1. This ensures that each number can only be used once in each combination, avoiding duplicate combinations.\\n\\n   - After the recursive call, remove the last added number from the `comb` list using `comb.pop()`. This allows us to backtrack and try other numbers for the current position in the combination.\\n\\n5. Start the recursion by calling `backtrack(1)` with `start` initially set to 1, as we want to start forming combinations with the numbers from 1 to `n`.\\n\\n6. After the recursion is complete, the `res` list will contain all the valid combinations of size `k` formed from the numbers 1 to `n`. Return `res` as the final result.\\n\\nThe code uses a recursive backtracking approach to generate all the combinations efficiently. It explores all possible combinations, avoiding duplicates and forming valid combinations of size `k`. The result `res` will contain all such combinations at the end.\\n\\n# Complexity\\n- Time complexity: O(n * k)\\nn is the number of elements and k is the size of the subset. The backtrack function is called n times, because there are n possible starting points for the subset. For each starting point, the backtrack function iterates through all k elements. This is because the comb list must contain all k elements in order for it to be a valid subset.\\n\\n- Space complexity: O(k)\\nThe comb list stores at most k elements. This is because the backtrack function only adds elements to the comb list when the subset is not yet complete.\\n\\n```python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        res = []\\n        comb = []\\n\\n        def backtrack(start):\\n            if len(comb) == k:\\n                res.append(comb[:])\\n                return\\n            \\n            for num in range(start, n + 1):\\n                comb.append(num)\\n                backtrack(num + 1)\\n                comb.pop()\\n\\n        backtrack(1)\\n        return res\\n```\\n```javascript []\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function(n, k) {\\n    const res = [];\\n    const comb = [];\\n\\n    function backtrack(start) {\\n        if (comb.length === k) {\\n            res.push([...comb]);\\n            return;\\n        }\\n\\n        for (let num = start; num <= n; num++) {\\n            comb.push(num);\\n            backtrack(num + 1);\\n            comb.pop();\\n        }\\n    }\\n\\n    backtrack(1);\\n    return res;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> comb = new ArrayList<>();\\n\\n        backtrack(1, comb, res, n, k);\\n        return res;\\n    }\\n\\n    private void backtrack(int start, List<Integer> comb, List<List<Integer>> res, int n, int k) {\\n        if (comb.size() == k) {\\n            res.add(new ArrayList<>(comb));\\n            return;\\n        }\\n\\n        for (int num = start; num <= n; num++) {\\n            comb.add(num);\\n            backtrack(num + 1, comb, res, n, k);\\n            comb.remove(comb.size() - 1);\\n        }\\n    } \\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        std::vector<std::vector<int>> res;\\n        std::vector<int> comb;\\n\\n        backtrack(1, comb, res, n, k);\\n        return res;        \\n    }\\n\\nprivate:\\n    void backtrack(int start, std::vector<int>& comb, std::vector<std::vector<int>>& res, int n, int k) {\\n        if (comb.size() == k) {\\n            res.push_back(comb);\\n            return;\\n        }\\n\\n        for (int num = start; num <= n; num++) {\\n            comb.push_back(num);\\n            backtrack(num + 1, comb, res, n, k);\\n            comb.pop_back();\\n        }\\n    }    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        res = []\\n        comb = []\\n\\n        def backtrack(start):\\n            if len(comb) == k:\\n                res.append(comb[:])\\n                return\\n            \\n            for num in range(start, n + 1):\\n                comb.append(num)\\n                backtrack(num + 1)\\n                comb.pop()\\n\\n        backtrack(1)\\n        return res\\n```\n```javascript []\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function(n, k) {\\n    const res = [];\\n    const comb = [];\\n\\n    function backtrack(start) {\\n        if (comb.length === k) {\\n            res.push([...comb]);\\n            return;\\n        }\\n\\n        for (let num = start; num <= n; num++) {\\n            comb.push(num);\\n            backtrack(num + 1);\\n            comb.pop();\\n        }\\n    }\\n\\n    backtrack(1);\\n    return res;    \\n};\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> comb = new ArrayList<>();\\n\\n        backtrack(1, comb, res, n, k);\\n        return res;\\n    }\\n\\n    private void backtrack(int start, List<Integer> comb, List<List<Integer>> res, int n, int k) {\\n        if (comb.size() == k) {\\n            res.add(new ArrayList<>(comb));\\n            return;\\n        }\\n\\n        for (int num = start; num <= n; num++) {\\n            comb.add(num);\\n            backtrack(num + 1, comb, res, n, k);\\n            comb.remove(comb.size() - 1);\\n        }\\n    } \\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        std::vector<std::vector<int>> res;\\n        std::vector<int> comb;\\n\\n        backtrack(1, comb, res, n, k);\\n        return res;        \\n    }\\n\\nprivate:\\n    void backtrack(int start, std::vector<int>& comb, std::vector<std::vector<int>>& res, int n, int k) {\\n        if (comb.size() == k) {\\n            res.push_back(comb);\\n            return;\\n        }\\n\\n        for (int num = start; num <= n; num++) {\\n            comb.push_back(num);\\n            backtrack(num + 1, comb, res, n, k);\\n            comb.pop_back();\\n        }\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549641,
                "title": "java-tc-o-k-c-n-k-sc-o-k-optimized-iterative-backtracking-solutions",
                "content": "**Backtracking (Recursive Solution)**\\n\\n```\\n/**\\n * Backtracking (Recursive Solution)\\n *\\n * Time complexity = InternalNodes in the RecursionTree   +   K * LeafNodes in RecursionTree\\n *                 = (C(N,0) + C(N,1) + ... + C(N,K-1))   +   K * C(N,K)\\n *\\n * Space Complexity = O(K) -> Depth of Recursion tree + Size of TempList\\n *\\n * N, K -> Input numbers.\\n */\\nclass Solution1 {\\n    public List<List<Integer>> combine(int n, int k) {\\n        if (n <= 0 || k < 0) {\\n            throw new IllegalArgumentException(\"invalid input\");\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (k == 0) {\\n            result.add(new ArrayList<>());\\n            return result;\\n        }\\n\\n        combineHelper(n, k, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combineHelper(int n, int k, List<Integer> temp, List<List<Integer>> result) {\\n        if (k == 0) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i = n; i >= 1; i--) {\\n            temp.add(i);\\n            combineHelper(i - 1, k - 1, temp, result);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution. This solution takes less time as compared to above recursive solution. In every iteration we are creating a valid combination. Thus, the total time taken is Total number of combinations * K**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * Here each combination is sorted. Thus it sets the first lowest possible value\\n * in the last column. Then it starts filling all possible values in the\\n * previous column and so-on.\\n * For N = 5, K = 3:\\n * 1, 2, 3(Here 3 is lowest possible value for the last (third) column).\\n *\\n * We also add a N+1 value in the end so that we do not go over N while generating the combinations.\\n *\\n * 1, 2, 3, 6 --> In next combination we will increment 3 to 4 as 1,2 are in correct place if 3 is in the third column\\n * 1, 2, 4, 6 --> Now we can fill 2 & 3 in the column before 4.\\n * 1, 3, 4, 6 --> Keep it sorted, we cannot increase 3 to 5. So we move on to first column and increment it to 2.\\n * 2, 3, 4, 6 --> Now we have exhausted the possible combinations with 4 in the third column.\\n * Now we will increase 4 to 5. And reset the first 2 columns\\n * With 5 in the third column, second column can have 2, 3, 4\\n * 1, 2, 5, 6 ->\\n * 1, 3, 5, 6 -> First C column can take 1, 2\\n * 2, 3, 5, 6 -> We cannot increment first column beyond 2 with 3 in second column. So we will increase second column to 4.\\n * 1, 4, 5, 6 -> Now first column can have 1, 2, 3\\n * 2, 4, 5, 6\\n * 3, 4, 5, 6 -> Exhausted all possible combinations. Exit now.\\n *\\n * Time complexity = 2*K * Total number of possible combinations\\n *                 = O(2 * K * C(N, K))\\n *\\n * Space Complexity = O(K+1) -> Size of TempList\\n *\\n * N, K -> Input numbers.\\n */\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        if (n <= 0 || k < 0) {\\n            throw new IllegalArgumentException(\"invalid input\");\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (k == 0) {\\n            result.add(new ArrayList<>());\\n            return result;\\n        }\\n\\n        List<Integer> temp = new ArrayList<>(k + 1);\\n        for (int i = 1; i <= k; i++) {\\n            temp.add(i);\\n        }\\n        temp.add(n + 1);\\n\\n        int i = 0;\\n        while (i < k) {\\n            result.add(new ArrayList<>(temp.subList(0, k)));\\n            i = 0;\\n            while (i < k && (temp.get(i) + 1 == temp.get(i + 1))) {\\n                temp.set(i, i + 1);\\n                i++;\\n            }\\n            temp.set(i, temp.get(i) + 1);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Backtracking (Recursive Solution)\\n *\\n * Time complexity = InternalNodes in the RecursionTree   +   K * LeafNodes in RecursionTree\\n *                 = (C(N,0) + C(N,1) + ... + C(N,K-1))   +   K * C(N,K)\\n *\\n * Space Complexity = O(K) -> Depth of Recursion tree + Size of TempList\\n *\\n * N, K -> Input numbers.\\n */\\nclass Solution1 {\\n    public List<List<Integer>> combine(int n, int k) {\\n        if (n <= 0 || k < 0) {\\n            throw new IllegalArgumentException(\"invalid input\");\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (k == 0) {\\n            result.add(new ArrayList<>());\\n            return result;\\n        }\\n\\n        combineHelper(n, k, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combineHelper(int n, int k, List<Integer> temp, List<List<Integer>> result) {\\n        if (k == 0) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i = n; i >= 1; i--) {\\n            temp.add(i);\\n            combineHelper(i - 1, k - 1, temp, result);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * Here each combination is sorted. Thus it sets the first lowest possible value\\n * in the last column. Then it starts filling all possible values in the\\n * previous column and so-on.\\n * For N = 5, K = 3:\\n * 1, 2, 3(Here 3 is lowest possible value for the last (third) column).\\n *\\n * We also add a N+1 value in the end so that we do not go over N while generating the combinations.\\n *\\n * 1, 2, 3, 6 --> In next combination we will increment 3 to 4 as 1,2 are in correct place if 3 is in the third column\\n * 1, 2, 4, 6 --> Now we can fill 2 & 3 in the column before 4.\\n * 1, 3, 4, 6 --> Keep it sorted, we cannot increase 3 to 5. So we move on to first column and increment it to 2.\\n * 2, 3, 4, 6 --> Now we have exhausted the possible combinations with 4 in the third column.\\n * Now we will increase 4 to 5. And reset the first 2 columns\\n * With 5 in the third column, second column can have 2, 3, 4\\n * 1, 2, 5, 6 ->\\n * 1, 3, 5, 6 -> First C column can take 1, 2\\n * 2, 3, 5, 6 -> We cannot increment first column beyond 2 with 3 in second column. So we will increase second column to 4.\\n * 1, 4, 5, 6 -> Now first column can have 1, 2, 3\\n * 2, 4, 5, 6\\n * 3, 4, 5, 6 -> Exhausted all possible combinations. Exit now.\\n *\\n * Time complexity = 2*K * Total number of possible combinations\\n *                 = O(2 * K * C(N, K))\\n *\\n * Space Complexity = O(K+1) -> Size of TempList\\n *\\n * N, K -> Input numbers.\\n */\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        if (n <= 0 || k < 0) {\\n            throw new IllegalArgumentException(\"invalid input\");\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (k == 0) {\\n            result.add(new ArrayList<>());\\n            return result;\\n        }\\n\\n        List<Integer> temp = new ArrayList<>(k + 1);\\n        for (int i = 1; i <= k; i++) {\\n            temp.add(i);\\n        }\\n        temp.add(n + 1);\\n\\n        int i = 0;\\n        while (i < k) {\\n            result.add(new ArrayList<>(temp.subList(0, k)));\\n            i = 0;\\n            while (i < k && (temp.get(i) + 1 == temp.get(i + 1))) {\\n                temp.set(i, i + 1);\\n                i++;\\n            }\\n            temp.set(i, temp.get(i) + 1);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845386,
                "title": "easy-backtracking-for-generating-combinations",
                "content": "# Intuition\\nIn this problem, we\\'re asked to generate all possible combinations of \\nk numbers out of n. My initial instinct was to use a recursive strategy, particularly the backtracking approach. Backtracking is a powerful method that systematically explores all potential combinations, distinguishing the ones that meet our specific criteria - here, those combinations that have a length of k.\\n\\nWhile the backtracking approach is typically more intuitive and easier to understand, it\\'s worth noting that it may not always be the fastest. There are other methods, such as the iterative approach proposed by vanAmsen [Iterative](https://leetcode.com/problems/combinations/solutions/3845249/iterative-backtracking-video-100-efficient-combinatorial-generation/) in this LeetCode solution, which can be more efficient. However, for the purposes of this explanation, we\\'ll focus on the backtracking approach due to its intuitive nature and general applicability to many combinatorial problems.\\n\\n# Approach\\nThe problem requires us to construct all potential combinations of \\\\(k\\\\) numbers from a total pool of \\\\(n\\\\) numbers. To tackle this problem, we utilize the principle of backtracking.\\n\\nBacktracking is a strategic algorithmic approach for finding all (or a subset of) solutions to a computational problem, particularly those that involve satisfying certain constraints. It works by progressively constructing candidates for the solution and discards a candidate as soon as it becomes apparent that the candidate cannot be extended into a viable solution.\\n\\nIn the context of our problem, we use a recursive function, `backtrack`, which is responsible for generating all combinations of \\\\(k\\\\) numbers. Here\\'s a detailed breakdown of the process:\\n\\n1. **Initialization**: We start by creating an empty list, `output`, where we\\'ll store all the valid combinations. We also establish our `backtrack` function, which takes two input parameters: the first number to be added to the current combination (`first`), and the current combination itself (`curr`).\\n\\n2. **Base case for recursion**: Inside the `backtrack` function, we first check whether the length of the current combination (`curr`) equals \\\\(k\\\\). If it does, it means we have a valid combination, so we add a copy of it to our `output` list.\\n\\n3. **Number iteration**: We then iterate over every number \\\\(i\\\\) within the range from `first` to \\\\(n\\\\), adding \\\\(i\\\\) to the current combination (`curr`).\\n\\n4. **Recursive call**: Next, we make a recursive call to `backtrack`, incrementing the value of `first` by 1 for the subsequent iteration and passing the current combination as parameters. This allows us to generate all combinations of the remaining numbers.\\n\\n5. **Backtrack**: Once we\\'ve explored all combinations that include \\\\(i\\\\), we need to remove \\\\(i\\\\) from the current combination. This is our \\'backtracking\\' step, which allows us to explore combinations that involve the next number. We achieve this by using the `pop()` method, which removes the last element from the list.\\n\\n6. **Result return**: Finally, after all recursive calls and backtracking are complete, our `backtrack` function will have populated our `output` list with all valid combinations of \\\\(k\\\\) numbers. This list is then returned as our final result.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is \\\\(O(\\\\binom{n}{k} \\\\cdot k)\\\\). This is because, in a worst-case scenario, we would need to explore all combinations of \\\\(k\\\\) out of \\\\(n\\\\) (which is \\\\(\\\\binom{n}{k}\\\\)) and for each combination, it takes \\\\(O(k)\\\\) time to copy it.\\n- Space complexity: The space complexity is \\\\(O(k)\\\\). This is because, in the worst-case scenario, if we consider the function call stack size during a depth-first search traversal, we could potentially go as deep as \\\\(k\\\\) levels.\"\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is (O(C(n, k)*k)). This is because in the worst-case scenario, we would need to explore all combinations of \\\\(k\\\\) out of \\\\(n\\\\) (which is C(n, k) and for each combination, it takes \\\\(O(k)\\\\) time to make a copy of it.\\n- Space complexity: The space complexity is \\\\(O(k)\\\\). This is because, in the worst case, if we consider the function call stack size in a depth-first search traversal, we could end up going as deep as \\\\(k\\\\) levels.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def backtrack(first = 1, curr = []):\\n            if len(curr) == k:\\n                output.append(curr[:])\\n                return\\n            for i in range(first, n + 1):\\n                curr.append(i)\\n                backtrack(i + 1, curr)\\n                curr.pop()\\n        output = []\\n        backtrack()\\n        return output\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> result;\\n        vector<int> combination;\\n        backtrack(n, k, 1, combination, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(int n, int k, int start, vector<int>& combination, vector<vector<int>>& result) {\\n        if (combination.size() == k) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.push_back(i);\\n            backtrack(n, k, i + 1, combination, result);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        backtrack(n, k, 1, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(int n, int k, int start, List<Integer> combination, List<List<Integer>> result) {\\n        if (combination.size() == k) {\\n            result.add(new ArrayList<>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.add(i);\\n            backtrack(n, k, i + 1, combination, result);\\n            combination.remove(combination.size() - 1);\\n        }\\n    }\\n}\\n```\\n``` JavaScript []\\nvar combine = function(n, k) {\\n    const result = [];\\n    backtrack(n, k, 1, [], result);\\n    return result;\\n};\\n\\nfunction backtrack(n, k, start, combination, result) {\\n    if (combination.length === k) {\\n        result.push([...combination]);\\n        return;\\n    }\\n    for (let i = start; i <= n; i++) {\\n        combination.push(i);\\n        backtrack(n, k, i + 1, combination, result);\\n        combination.pop();\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Combine(int n, int k) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(n, k, 1, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int n, int k, int start, IList<int> combination, IList<IList<int>> result) {\\n        if (combination.Count == k) {\\n            result.Add(new List<int>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.Add(i);\\n            Backtrack(n, k, i + 1, combination, result);\\n            combination.RemoveAt(combination.Count - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def backtrack(first = 1, curr = []):\\n            if len(curr) == k:\\n                output.append(curr[:])\\n                return\\n            for i in range(first, n + 1):\\n                curr.append(i)\\n                backtrack(i + 1, curr)\\n                curr.pop()\\n        output = []\\n        backtrack()\\n        return output\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> result;\\n        vector<int> combination;\\n        backtrack(n, k, 1, combination, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(int n, int k, int start, vector<int>& combination, vector<vector<int>>& result) {\\n        if (combination.size() == k) {\\n            result.push_back(combination);\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.push_back(i);\\n            backtrack(n, k, i + 1, combination, result);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        backtrack(n, k, 1, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void backtrack(int n, int k, int start, List<Integer> combination, List<List<Integer>> result) {\\n        if (combination.size() == k) {\\n            result.add(new ArrayList<>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.add(i);\\n            backtrack(n, k, i + 1, combination, result);\\n            combination.remove(combination.size() - 1);\\n        }\\n    }\\n}\\n```\n``` JavaScript []\\nvar combine = function(n, k) {\\n    const result = [];\\n    backtrack(n, k, 1, [], result);\\n    return result;\\n};\\n\\nfunction backtrack(n, k, start, combination, result) {\\n    if (combination.length === k) {\\n        result.push([...combination]);\\n        return;\\n    }\\n    for (let i = start; i <= n; i++) {\\n        combination.push(i);\\n        backtrack(n, k, i + 1, combination, result);\\n        combination.pop();\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Combine(int n, int k) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(n, k, 1, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int n, int k, int start, IList<int> combination, IList<IList<int>> result) {\\n        if (combination.Count == k) {\\n            result.Add(new List<int>(combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; i++) {\\n            combination.Add(i);\\n            Backtrack(n, k, i + 1, combination, result);\\n            combination.RemoveAt(combination.Count - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112007,
                "title": "simple-java-code-with-the-best-explanation",
                "content": "***Java Solution with explanation***\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n\\t//declaring new list of list for storing results\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t//calling the helper function\\n        helper(n, k, 1,  res, new ArrayList<>());\\n        return res;\\n    }\\n    private void helper(int n, int k, int idex, List<List<Integer>> res, List<Integer> temp){\\n\\t//when size of the temp list equals to k it is added to the final list \\'res\\'\\n        if(temp.size()==k){\\n            res.add(new ArrayList<>(temp));\\n\\t\\t\\t//after adding the temp to res just return \\n            return;\\n        }\\n\\t\\t//for loop for iterating over the range [1,n]\\n        for(int i = idex; i<=n;i++){\\n            temp.add(i);\\n            helper(n, k, i+1, res, temp);\\n\\t\\t\\t//backtracking to the previous numeber\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```\\n\\n***clean code***\\n\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n\\t\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(n, k, 1,  res, new ArrayList<>());\\n        return res;\\n    }\\n    private void helper(int n, int k, int idex, List<List<Integer>> res, List<Integer> temp){\\n\\t\\n        if(temp.size()==k){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\t\\t\\n        for(int i = idex; i<=n;i++){\\n            temp.add(i);\\n            helper(n, k, i+1, res, temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```\\n\\nPlease upvote if found helpeful:\\n\\n![image](https://assets.leetcode.com/users/images/22d113b9-360c-44e4-8c8e-fd8d24930ef1_1674968358.456658.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n\\t//declaring new list of list for storing results\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t//calling the helper function\\n        helper(n, k, 1,  res, new ArrayList<>());\\n        return res;\\n    }\\n    private void helper(int n, int k, int idex, List<List<Integer>> res, List<Integer> temp){\\n\\t//when size of the temp list equals to k it is added to the final list \\'res\\'\\n        if(temp.size()==k){\\n            res.add(new ArrayList<>(temp));\\n\\t\\t\\t//after adding the temp to res just return \\n            return;\\n        }\\n\\t\\t//for loop for iterating over the range [1,n]\\n        for(int i = idex; i<=n;i++){\\n            temp.add(i);\\n            helper(n, k, i+1, res, temp);\\n\\t\\t\\t//backtracking to the previous numeber\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n\\t\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(n, k, 1,  res, new ArrayList<>());\\n        return res;\\n    }\\n    private void helper(int n, int k, int idex, List<List<Integer>> res, List<Integer> temp){\\n\\t\\n        if(temp.size()==k){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\t\\t\\n        for(int i = idex; i<=n;i++){\\n            temp.add(i);\\n            helper(n, k, i+1, res, temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043903,
                "title": "c-simple-solution-using-dfs-and-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>& result,int n,int begin ,int k ,vector<int>& combination){\\n        if(combination.size()==k){\\n            result.push_back(combination);\\n            return;\\n        }\\n        for(int i=begin ; i<=n ;i++){\\n            combination.push_back(i);\\n            solve(result , n , i+1 , k , combination);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> combination;\\n        vector<vector<int>> result;\\n        solve(result , n , 1 , k , combination);\\n        return result;\\n    }\\n};\\n```\\n\\n**Happy Coding**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>& result,int n,int begin ,int k ,vector<int>& combination){\\n        if(combination.size()==k){\\n            result.push_back(combination);\\n            return;\\n        }\\n        for(int i=begin ; i<=n ;i++){\\n            combination.push_back(i);\\n            solve(result , n , i+1 , k , combination);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> combination;\\n        vector<vector<int>> result;\\n        solve(result , n , 1 , k , combination);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27113,
                "title": "perhaps-the-simplest-solution-using-recursion-backtracing",
                "content": "The idea is that C(n,k) = C(n-1, k-1) U n + C(n-1,k), do you get this?\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > combine(int n, int k) {\\n            \\n            vector<vector<int> > result;\\n            if (n < 1 || k <1 || k > n)\\n            {\\n                return result;\\n            }\\n            \\n            result = combine(n-1, k-1);\\n            \\n            if(result.empty())\\n            {\\n                result.push_back(vector<int>{n});\\n            }\\n            else\\n            {\\n                for (vector<vector<int> >::iterator it = result.begin();\\n                        it!= result.end(); it++)\\n                {\\n                    it->push_back(n);\\n                }\\n            }\\n            vector<vector<int> > result2 = combine(n-1, k);\\n            result. insert(result.end(), result2.begin(), result2.end());\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combine(int n, int k) {\\n            \\n            vector<vector<int> > result;\\n            if (n < 1 || k <1 || k > n)\\n            {\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 179736,
                "title": "javascript-dfs",
                "content": "```\\nvar combine = function(n, k) {\\n    let result = [];\\n    \\n    function dfs(current, start) {\\n        if(current.length == k) {\\n            result.push(current);\\n            return;\\n        }\\n        if(current.length > k) {\\n            return;\\n        }\\n        \\n        for(let i = start; i <= n; i++) {\\n            dfs(current.concat(i), i + 1);\\n        }\\n        \\n    }\\n    \\n    dfs([], 1);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar combine = function(n, k) {\\n    let result = [];\\n    \\n    function dfs(current, start) {\\n        if(current.length == k) {\\n            result.push(current);\\n            return;\\n        }\\n        if(current.length > k) {\\n            return;\\n        }\\n        \\n        for(let i = start; i <= n; i++) {\\n            dfs(current.concat(i), i + 1);\\n        }\\n        \\n    }\\n    \\n    dfs([], 1);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27039,
                "title": "2ms-beats-90-java-solution-a-small-trick-to-end-search-early",
                "content": "    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> results = new ArrayList<>();\\n        dfs(1, n, k, new ArrayList<Integer>(), results);\\n        return results;\\n    }\\n    \\n    private void dfs(int crt, int n, int level, List<Integer> comb, List<List<Integer>> results) {\\n        if (level == 0) {\\n            List<Integer> newComb = new ArrayList<>(comb);\\n            results.add(newComb);\\n            return;\\n        }\\n        int size = comb.size();\\n        for (int i = crt, max = n - level + 1; i <= max; i++) { \\n        //end search when its not possible to have any combination\\n            comb.add(i);\\n            dfs(i + 1, n, level - 1, comb, results);\\n            comb.remove(size);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> results = new ArrayList<>();\\n        dfs(1, n, k, new ArrayList<Integer>(), results);\\n        return results;\\n    }\\n    \\n    private void dfs(int crt, int n, int level, List<Integer> comb, List<List<Integer>> results) {\\n        if (level == 0) {\\n            List<Integer> newComb = new ArrayList<>(comb);\\n            results.add(newComb);\\n            return;\\n        }\\n        int size = comb.size();\\n        for (int i = crt, max = n - level + 1; i <= max; i++) { \\n        //end search when its not possible to have any combination\\n            comb.add(i);\\n            dfs(i + 1, n, level - 1, comb, results);\\n            comb.remove(size);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3845573,
                "title": "c-java-python-simple-solution-with-explanation-backtracking",
                "content": "# Intuition\\nIt is pretty clear from the constraints that the solution of 2<sup>n</sup> could work. We could use a backtracking approch in which if we see that the going path doesn\\'t leads towards answer we could backtrack.\\n<table>\\n<tr>\\n<th>Input Parameters</th>\\n<th>Required time Complexity</th>\\n</tr>\\n<tr>\\n<td> n \\u2264 10 </td>\\n<td> O(n!) </td>\\n</tr>\\n<tr>\\n<td> n \\u2264 20 </td>\\n<td> O(2<sup>n</sup>) </td>\\n</tr>\\n<tr>\\n<td> n \\u2264 500 </td>\\n<td> O(n<sup>3</sup>) </td>\\n</tr>\\n<tr>\\n<td> n \\u2264 5000 </td>\\n<td> O(n<sup>2</sup>) </td>\\n</tr>\\n<tr>\\n<td> n \\u2264 10<sup>6</sup> </td>\\n<td> O(n) </td>\\n</tr>\\n<tr>\\n<td> n is large </td>\\n<td> O(1) or O(log n) </td>\\n</tr>\\n</table>\\n\\n# Approach\\n- Base case is when k == 0 or i == n\\n    - when k == 0 , we fill our ans vector with the vector we\\'ve built till now\\n    - when i == 0 we simply return ;\\n- Then it\\'s a simple process of take and not take. \\n# Complexity\\n- Time complexity:O(2<sup>n</sup>)\\n\\n- Space complexity:O(2<sup>n</sup>)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(int i , int n , int k , vector<int>& temp){\\n        if(k == 0){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        if(i == n) return ;\\n        dfs(i + 1 , n , k , temp);\\n        temp.push_back(i+1);\\n        dfs(i + 1 , n , k - 1 , temp);\\n        temp.pop_back();\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> temp;\\n        dfs(0 , n , k , temp);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    private List<List<Integer>> ans = new ArrayList<>();\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<Integer> temp = new ArrayList<>();\\n        dfs(1, n, k, temp);\\n        return ans;\\n    }\\n\\n    private void dfs(int i, int n, int k, List<Integer> temp) {\\n        if (k == 0) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if (i > n) return;\\n        dfs(i + 1, n, k, temp);\\n        temp.add(i);\\n        dfs(i + 1, n, k - 1, temp);\\n        temp.remove(temp.size() - 1);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, n, k, temp, ans):\\n            if k == 0:\\n                ans.append(temp[:])\\n                return\\n            if i == n:\\n                return\\n            dfs(i + 1, n, k, temp, ans)\\n            temp.append(i + 1)\\n            dfs(i + 1, n, k - 1, temp, ans)\\n            temp.pop()\\n\\n        ans = []\\n        temp = []\\n        dfs(0, n, k, temp, ans)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(int i , int n , int k , vector<int>& temp){\\n        if(k == 0){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        if(i == n) return ;\\n        dfs(i + 1 , n , k , temp);\\n        temp.push_back(i+1);\\n        dfs(i + 1 , n , k - 1 , temp);\\n        temp.pop_back();\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> temp;\\n        dfs(0 , n , k , temp);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    private List<List<Integer>> ans = new ArrayList<>();\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<Integer> temp = new ArrayList<>();\\n        dfs(1, n, k, temp);\\n        return ans;\\n    }\\n\\n    private void dfs(int i, int n, int k, List<Integer> temp) {\\n        if (k == 0) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if (i > n) return;\\n        dfs(i + 1, n, k, temp);\\n        temp.add(i);\\n        dfs(i + 1, n, k - 1, temp);\\n        temp.remove(temp.size() - 1);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, n, k, temp, ans):\\n            if k == 0:\\n                ans.append(temp[:])\\n                return\\n            if i == n:\\n                return\\n            dfs(i + 1, n, k, temp, ans)\\n            temp.append(i + 1)\\n            dfs(i + 1, n, k - 1, temp, ans)\\n            temp.pop()\\n\\n        ans = []\\n        temp = []\\n        dfs(0, n, k, temp, ans)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467498,
                "title": "java-0ms-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n choose k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n choose k)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/afc6ec07-c724-4ffd-b223-d560f70ca0fe_1682792804.0870206.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        ArrayList<Integer> ds = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(n, k, 1, ds, ans); // start from 1 instead of 0\\n        return ans;\\n    }\\n\\n    public void helper(int n, int k, int start, ArrayList<Integer> ds, List<List<Integer>> ans) {\\n        if (ds.size() == k) { // add a base case to terminate recursion when the list size reaches k\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        for (int i = start; i <= n; i++) {\\n            ds.add(i); // add the actual value i to the list instead of the index\\n            helper(n, k, i + 1, ds, ans); // increment start to i + 1 to avoid duplicates\\n            ds.remove(ds.size() - 1); // remove the last element to backtrack\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        ArrayList<Integer> ds = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(n, k, 1, ds, ans); // start from 1 instead of 0\\n        return ans;\\n    }\\n\\n    public void helper(int n, int k, int start, ArrayList<Integer> ds, List<List<Integer>> ans) {\\n        if (ds.size() == k) { // add a base case to terminate recursion when the list size reaches k\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        for (int i = start; i <= n; i++) {\\n            ds.add(i); // add the actual value i to the list instead of the index\\n            helper(n, k, i + 1, ds, ans); // increment start to i + 1 to avoid duplicates\\n            ds.remove(ds.size() - 1); // remove the last element to backtrack\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097270,
                "title": "simple-c-backtracking-solution-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply generate all the subsets but if size execeeds k then return . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Backtracking like allother subset problems\\n# Complexity\\n- Time complexity:$$(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(int n,int start,vector<int>&temp,int k){\\n        if(temp.size()>k)return;\\n        if(temp.size()==k)ans.push_back(temp);\\n\\n          for(int i=start;i<=n;i++){\\n              temp.push_back(i);\\n              backtrack(n,i+1,temp,k);\\n              temp.pop_back();\\n          }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>temp;\\n         backtrack(n,1,temp,k);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(int n,int start,vector<int>&temp,int k){\\n        if(temp.size()>k)return;\\n        if(temp.size()==k)ans.push_back(temp);\\n\\n          for(int i=start;i<=n;i++){\\n              temp.push_back(i);\\n              backtrack(n,i+1,temp,k);\\n              temp.pop_back();\\n          }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>temp;\\n         backtrack(n,1,temp,k);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918860,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\\n        var res: [[Int]] = []\\n        \\n        \\n        func backtrack(_ path: [Int], _ max: Int) {\\n            if path.count == k {\\n                res.append(path)\\n                return\\n            \\n            }\\n            \\n            var path = path\\n            if max + 1 > n { return }\\n            \\n            for i in max+1...n {\\n                if n - i < k - path.count - 1 {\\n                    continue\\n                }\\n                \\n                path.append(i)\\n                backtrack(path, i)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtrack([], 0)\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\\n        var res: [[Int]] = []\\n        \\n        \\n        func backtrack(_ path: [Int], _ max: Int) {\\n            if path.count == k {\\n                res.append(path)\\n                return\\n            \\n            }\\n            \\n            var path = path\\n            if max + 1 > n { return }\\n            \\n            for i in max+1...n {\\n                if n - i < k - path.count - 1 {\\n                    continue\\n                }\\n                \\n                path.append(i)\\n                backtrack(path, i)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtrack([], 0)\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872771,
                "title": "python-dfs-solution-visualization-step-by-step",
                "content": "Not the most optimal solution in terms of runtime, but for someone who is learning recursive solutions (such as myself) I hope the visualization is helpful!\\n```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        self.dfs(n, k, 0, [], res)\\n        return res\\n    \\n    def dfs(self, n, k, start, path, res):\\n        if len(path) == k:\\n            res.append(path)\\n            return None\\n        \\n        for index in range(start, n):\\n            self.dfs(n, k, index+1, path+[index+1], res)\\n            \\n        \\n        \\n\\'\\'\\'\\ndfs( n = 4, k = 2, start = 0, path = [], res = []) \\n| index = 0\\n----dfs( n = 4, k = 2, start = 1, path  = [1], res = []) \\n|   | index = 1\\n|   ----dfs ( n = 4, k = 2, start = 2, path  = [1, 2], res = [1, 2]) -> add & return\\n|   | index = 2\\n|   ----dfs( n = 4, k = 2, start = 3, path  = [1, 3], res = [[1, 2], [1, 3]]) -> add & return\\n|   | index = 3\\n|   ----dfs( n = 4, k = 2, start = 4, path  = [1, 4], res = [[1, 2], [1, 3], [1, 4]]) -> add & return\\n| index = 1\\n----dfs( n = 4, k = 2, start = 2, path  = [2], res = [[1, 2], [1, 3], [1, 4]]) \\n|   | index = 2\\n|   ----dfs ( n = 4, k = 2, start = 3, path  = [2, 3], res = [[1, 2], [1, 3], [1, 4], [2, 3]]) -> add & return\\n|   | index = 3\\n|   ----dfs( n = 4, k = 2, start = 4, path  = [1, 4], res = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]) -> add & return\\n| index = 2\\n----dfs( n = 4, k = 2, start = 3, path = [3], res = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]) \\n|   | index = 3\\n|   ----dfs ( n = 4, k = 2, start = 4, path  = [3, 4], res = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]) -> add & return\\n| index = 3\\n----dfs( n = 4, k = 2, start = 4, path = [4], res = [[1, 2], [1, 3], [1, 4], [2, 3], [3, 4]]) -> return None\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        self.dfs(n, k, 0, [], res)\\n        return res\\n    \\n    def dfs(self, n, k, start, path, res):\\n        if len(path) == k:\\n            res.append(path)\\n            return None\\n        \\n        for index in range(start, n):\\n            self.dfs(n, k, index+1, path+[index+1], res)\\n            \\n        \\n        \\n\\'\\'\\'\\ndfs( n = 4, k = 2, start = 0, path = [], res = []) \\n| index = 0\\n----dfs( n = 4, k = 2, start = 1, path  = [1], res = []) \\n|   | index = 1\\n|   ----dfs ( n = 4, k = 2, start = 2, path  = [1, 2], res = [1, 2]) -> add & return\\n|   | index = 2\\n|   ----dfs( n = 4, k = 2, start = 3, path  = [1, 3], res = [[1, 2], [1, 3]]) -> add & return\\n|   | index = 3\\n|   ----dfs( n = 4, k = 2, start = 4, path  = [1, 4], res = [[1, 2], [1, 3], [1, 4]]) -> add & return\\n| index = 1\\n----dfs( n = 4, k = 2, start = 2, path  = [2], res = [[1, 2], [1, 3], [1, 4]]) \\n|   | index = 2\\n|   ----dfs ( n = 4, k = 2, start = 3, path  = [2, 3], res = [[1, 2], [1, 3], [1, 4], [2, 3]]) -> add & return\\n|   | index = 3\\n|   ----dfs( n = 4, k = 2, start = 4, path  = [1, 4], res = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]) -> add & return\\n| index = 2\\n----dfs( n = 4, k = 2, start = 3, path = [3], res = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]) \\n|   | index = 3\\n|   ----dfs ( n = 4, k = 2, start = 4, path  = [3, 4], res = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]) -> add & return\\n| index = 3\\n----dfs( n = 4, k = 2, start = 4, path = [4], res = [[1, 2], [1, 3], [1, 4], [2, 3], [3, 4]]) -> return None\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395558,
                "title": "time-complexity-analysis-of-backtracking-java",
                "content": "Here is the code, classic dfs backtracing.\\n```\\npublic List<List<Integer>> combine(int n, int k) {\\n        List<Integer> curr=new ArrayList<Integer>();\\n        List<List<Integer>> ans =new ArrayList<List<Integer>>();\\n        dfs(n,k,1,curr,ans);\\n        return ans;\\n    }\\n    \\n    private void dfs(int n, int k,int next,List<Integer> curr, List<List<Integer>> ans){\\n        if(curr.size()==k){\\n            ans.add(new ArrayList(curr));\\n            return;\\n        }\\n        for(int i=next;i<=n;i++){\\n            curr.add(i);\\n            dfs(n,k,i+1,curr,ans);\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n```\\n\\nThere are a lot of different answers for time complexity. Finally I think I got it right and clear, please let me know if you find I got anything wrong.\\n\\n**First of all, O(2^n) is not tight, O(n!) is not tight. My answer is O(n!/(k-1)!)**\\n\\nThe simplest way to analysis is that : every round of for loop it will add one and only one number for sure, so how many numbers means how many round of loops, there are k*C(n,k) numbers in the output\\n\\nso it is O(k*C(n,k)) which is O(n!/(k-1)!)\\n\\nO(n!/(k-1)!) is not O(n!) because k is not some constant but a input that has impact on time complexity\\n\\n**Also, I can prove it another way,  more acdamic way:**\\n\\n**Prove: T(n) = n!/(k-1)!**\\n\\nfrom the dfs we can simply see that\\n\\n\\tT(n) = C1\\xA0+\\xA0n [(T(n-1)\\xA0+ C2]\\xA0\\xA0 \\xA0 \\xA0 \\xA0\\n         = nT(n-1)\\xA0+ C2*n + C1\\n\\nwhen you see\\xA0T(n) = nT(n-1)..., it usually means n!\\n\\nbecause \\n\\n     T(0) = 1\\n     T(n) = nT(n-1)\\xA0\\xA0 \\xA0 \\xA0 \\xA0 \\n          = n*[(n-1)*T(n-2)]\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t  = (n)*(n-1)*(n-2)*(n-3).......T(0)\\xA0\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t  = n!\\n\\t\\t\\n**But, here comes the core part of this analysis.**\\n```\\nif(curr.size()==k){\\n            ans.add(new ArrayList(curr));\\n            return;\\n        }\\n```\\nbecasue of this part of code, which is the bounding condition of backtracking\\n\\n\\n**the recursive call will only reach kth level of call**\\n\\nso \\n\\n\\tT(n)  = nT(n-1)\\xA0\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t  = n*[(n-1)*T(n-2)]\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t  = (n)*(n-1)*(n-2)*(n-3)......(n-k)*T(n-k-1)\\xA0\\xA0 \\xA0 \\xA0 \\xA0 \\n\\nwhen recrive reach the kth level and try to do T(n-k-1) ```curr.size()==k``` is true, becasue every level curr add one number\\n\\nT(n-k-1) will simply ``` ans.add(new ArrayList(curr))``` and returns which means T(n-k-1) = 1\\n\\nso \\n\\n\\tT(n)  = (n)*(n-1)*(n-2)*(n-3)......(n-k) * 1\\n          = n!/(k-1)! \\n          = k * n!/k! \\n\\t      = k * C(n,k)\\n\\t\\t\\t \\n\\ncompare with n!/(k-1)! , both 2^n and n! are not tight.\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> combine(int n, int k) {\\n        List<Integer> curr=new ArrayList<Integer>();\\n        List<List<Integer>> ans =new ArrayList<List<Integer>>();\\n        dfs(n,k,1,curr,ans);\\n        return ans;\\n    }\\n    \\n    private void dfs(int n, int k,int next,List<Integer> curr, List<List<Integer>> ans){\\n        if(curr.size()==k){\\n            ans.add(new ArrayList(curr));\\n            return;\\n        }\\n        for(int i=next;i<=n;i++){\\n            curr.add(i);\\n            dfs(n,k,i+1,curr,ans);\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n```\n```\\nif(curr.size()==k){\\n            ans.add(new ArrayList(curr));\\n            return;\\n        }\\n```\n```curr.size()==k```\n``` ans.add(new ArrayList(curr))```",
                "codeTag": "Unknown"
            },
            {
                "id": 26988,
                "title": "recursive-javascript-solution",
                "content": "```\\nfunction combinations(n, k) {\\n  let result = [];\\n\\n  function traverse(arr, depth) {\\n    if (arr.length === k) {\\n      result.push(arr);\\n      return;\\n    }\\n    \\n    if (depth > n) {      \\n      return;\\n    }\\n\\n    traverse(arr, depth + 1);  \\n    traverse(arr.concat(depth), depth + 1);\\n  }\\n\\n  traverse([], 1);\\n\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nfunction combinations(n, k) {\\n  let result = [];\\n\\n  function traverse(arr, depth) {\\n    if (arr.length === k) {\\n      result.push(arr);\\n      return;\\n    }\\n    \\n    if (depth > n) {      \\n      return;\\n    }\\n\\n    traverse(arr, depth + 1);  \\n    traverse(arr.concat(depth), depth + 1);\\n  }\\n\\n  traverse([], 1);\\n\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845214,
                "title": "c-math-dp-unordered-map-map-4d-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I provide other idea from backtracking. I prefer to use DP. The backtracking solution can be used to solve the similar question.\\n[46. Permutations\\n](https://leetcode.com/problems/permutations/solutions/3850602/cpython-bitmask-backtrackingbeats-100/)\\nLet\\'s solve it by Math. Consider the set n choose k denoted as\\n$$ \\nC_k^n=\\\\{\\\\{i_1,\\\\cdots, i_k\\\\}|1\\\\leq i_1<\\\\cdots< i_k\\\\leq n\\\\}\\n$$\\nthen, it follows\\n$$\\nC_k^n=C_k^{n-1}\\\\bigcup C_{with\\\\ n}^n\\n$$\\nwhere\\n$$\\nC_{with\\\\ n}^n=\\\\{\\\\{i_1,\\\\cdots, i_k\\\\}|1\\\\leq i_1<\\\\cdots<i_{k-1}< i_k= n\\\\}\\n$$.\\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\\\ n}^n$ with\\n$$\\nv\\\\in C_{k-1}^{n-1} \\\\longrightarrow v\\\\cup \\\\{n \\\\} \\\\in C_{with\\\\ n}^n.\\n$$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse unordered_map( based own hash), recursion with memoization to implement this idea.\\n\\n2nd version uses map.\\n\\n3rd version uses 4D array as DP state matrix.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n choose k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(n * k)\\n\\n# Code\\n```\\nusing int2=pair<int, int>;\\nstruct pair_hash\\n{\\n    size_t operator() (const int2& pair) const {\\n        return hash<int>()(pair.first) ^ hash<int>()(pair.second);\\n    }\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int2, vector<vector<int>>, pair_hash> mp;\\n    \\n    vector<vector<int>> comb(int n, int k){\\n        if (n==1 && k==1) return mp[{1,1}]={{1}};\\n        if (mp.count({n, k})!=0) return mp[{n, k}];\\n        vector<vector<int>> ans={};\\n        if (k==1){\\n            for(int x=1; x<=n; x++) ans.push_back({x});\\n        } \\n        else if (n==k){\\n            ans.resize(1);\\n            for(int x=1; x<=n; x++) ans[0].push_back(x);\\n        }\\n        else{\\n            ans=comb(n-1, k);\\n            vector<vector<int>> c_wo_n=comb(n-1, k-1);\\n            for (vector<int>& v: c_wo_n){\\n                vector<int> v_w_n=v;\\n                v_w_n.push_back(n);\\n                ans.push_back(v_w_n);\\n            }\\n        }\\n        return mp[{n, k}]=ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return comb(n, k);\\n    }\\n};\\n```\\n# Code using map is faster for the sake of constraints 1<=k<=n<=20\\n```\\nclass Solution {\\npublic:\\n    map<int2, vector<vector<int>>> mp;\\n    \\n    vector<vector<int>> comb(int n, int k){\\n        if (n==1 && k==1) return mp[{1,1}]={{1}};\\n        if (mp.count({n, k})!=0) return mp[{n, k}];\\n        vector<vector<int>> ans={};\\n        if (k==1){\\n            for(int x=1; x<=n; x++) ans.push_back({x});\\n        } \\n        else if (n==k){\\n            ans.resize(1);\\n            for(int x=1; x<=n; x++) ans[0].push_back(x);\\n        }\\n        else{\\n            ans=comb(n-1, k);\\n            vector<vector<int>> c_wo_n=comb(n-1, k-1);\\n            for (vector<int>& v: c_wo_n){\\n                vector<int> v_w_n=v;\\n                v_w_n.push_back(n);\\n                ans.push_back(v_w_n);\\n            }\\n        }\\n        return mp[{n, k}]=ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return comb(n, k);\\n    }\\n};\\n```\\n# code using 4D array\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp;\\n    \\n    vector<vector<int>> comb(int n, int k){\\n        if (n==1 && k==1) return dp[1][1]={{1}};\\n        if (!dp[n][k].empty()) return dp[n][k];\\n        vector<vector<int>>& ans=dp[n][k];\\n        if (k==1){\\n            for(int x=1; x<=n; x++) ans.push_back({x});\\n        } \\n        else if (n==k){\\n            ans.resize(1);\\n            for(int x=1; x<=n; x++) ans[0].push_back(x);\\n        }\\n        else{\\n            ans=comb(n-1, k);\\n            vector<vector<int>> c_wo_n=comb(n-1, k-1);\\n            for (vector<int>& v: c_wo_n){\\n                vector<int> v_w_n=v;\\n                v_w_n.push_back(n);\\n                ans.push_back(v_w_n);\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        dp.assign(n+1, vector<vector<vector<int>>>(k+1, vector<vector<int>>()));\\n        return comb(n, k);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nusing int2=pair<int, int>;\\nstruct pair_hash\\n{\\n    size_t operator() (const int2& pair) const {\\n        return hash<int>()(pair.first) ^ hash<int>()(pair.second);\\n    }\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int2, vector<vector<int>>, pair_hash> mp;\\n    \\n    vector<vector<int>> comb(int n, int k){\\n        if (n==1 && k==1) return mp[{1,1}]={{1}};\\n        if (mp.count({n, k})!=0) return mp[{n, k}];\\n        vector<vector<int>> ans={};\\n        if (k==1){\\n            for(int x=1; x<=n; x++) ans.push_back({x});\\n        } \\n        else if (n==k){\\n            ans.resize(1);\\n            for(int x=1; x<=n; x++) ans[0].push_back(x);\\n        }\\n        else{\\n            ans=comb(n-1, k);\\n            vector<vector<int>> c_wo_n=comb(n-1, k-1);\\n            for (vector<int>& v: c_wo_n){\\n                vector<int> v_w_n=v;\\n                v_w_n.push_back(n);\\n                ans.push_back(v_w_n);\\n            }\\n        }\\n        return mp[{n, k}]=ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return comb(n, k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<int2, vector<vector<int>>> mp;\\n    \\n    vector<vector<int>> comb(int n, int k){\\n        if (n==1 && k==1) return mp[{1,1}]={{1}};\\n        if (mp.count({n, k})!=0) return mp[{n, k}];\\n        vector<vector<int>> ans={};\\n        if (k==1){\\n            for(int x=1; x<=n; x++) ans.push_back({x});\\n        } \\n        else if (n==k){\\n            ans.resize(1);\\n            for(int x=1; x<=n; x++) ans[0].push_back(x);\\n        }\\n        else{\\n            ans=comb(n-1, k);\\n            vector<vector<int>> c_wo_n=comb(n-1, k-1);\\n            for (vector<int>& v: c_wo_n){\\n                vector<int> v_w_n=v;\\n                v_w_n.push_back(n);\\n                ans.push_back(v_w_n);\\n            }\\n        }\\n        return mp[{n, k}]=ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return comb(n, k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp;\\n    \\n    vector<vector<int>> comb(int n, int k){\\n        if (n==1 && k==1) return dp[1][1]={{1}};\\n        if (!dp[n][k].empty()) return dp[n][k];\\n        vector<vector<int>>& ans=dp[n][k];\\n        if (k==1){\\n            for(int x=1; x<=n; x++) ans.push_back({x});\\n        } \\n        else if (n==k){\\n            ans.resize(1);\\n            for(int x=1; x<=n; x++) ans[0].push_back(x);\\n        }\\n        else{\\n            ans=comb(n-1, k);\\n            vector<vector<int>> c_wo_n=comb(n-1, k-1);\\n            for (vector<int>& v: c_wo_n){\\n                vector<int> v_w_n=v;\\n                v_w_n.push_back(n);\\n                ans.push_back(v_w_n);\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        dp.assign(n+1, vector<vector<vector<int>>>(k+1, vector<vector<int>>()));\\n        return comb(n, k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620905,
                "title": "backtracking-simple-straightforward",
                "content": "If you find this helpful, do upvote.\\n\\n```\\nvar combine = function(n, k) {\\n    let res = [];\\n    function backtrack(start = 1, path = []){\\n        if(path.length == k){\\n            res.push(Array.from(path));\\n        }else {\\n            for(let i=start; i<=n; i++){\\n                path.push(i);\\n                backtrack(i + 1, path);\\n                path.pop();\\n            }\\n        }\\n    }\\n    backtrack();\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar combine = function(n, k) {\\n    let res = [];\\n    function backtrack(start = 1, path = []){\\n        if(path.length == k){\\n            res.push(Array.from(path));\\n        }else {\\n            for(let i=start; i<=n; i++){\\n                path.push(i);\\n                backtrack(i + 1, path);\\n                path.pop();\\n            }\\n        }\\n    }\\n    backtrack();\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703949,
                "title": "javascript-straightforward-backtracking-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function (n, k) {\\n    if (n == 1 && k == 1) return [[1]];\\n    let out = [];\\n    const dfs = (currentSolution, startNumber, out) => {\\n        if (currentSolution.length == k) out.push(Array.from(currentSolution));\\n        for (let i = startNumber; i <= n; i++) {\\n            currentSolution.push(i);\\n            dfs(currentSolution, i + 1, out);\\n            currentSolution.pop();\\n        }\\n    }\\n    dfs([], 1, out);\\n    return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function (n, k) {\\n    if (n == 1 && k == 1) return [[1]];\\n    let out = [];\\n    const dfs = (currentSolution, startNumber, out) => {\\n        if (currentSolution.length == k) out.push(Array.from(currentSolution));\\n        for (let i = startNumber; i <= n; i++) {\\n            currentSolution.push(i);\\n            dfs(currentSolution, i + 1, out);\\n            currentSolution.pop();\\n        }\\n    }\\n    dfs([], 1, out);\\n    return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26995,
                "title": "python-dfs-solution-tle-solved-for-the-test-case-n-20-k-16",
                "content": "```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        if k==0 or n<1:\\n            return res\\n        \\n        self.dfs(n, k, [], res, 1)\\n        return res\\n        \\n    def dfs(self, n, k, path, res, index):\\n        length = len(path)\\n        #if len(path) == k:\\n        if length == k:\\n            res.append(path[:])\\n            return\\n        \\n        # TLE problem solved by adding this\\n        if k-length > n - index + 1: # need k numbers in total , still need (k-lenth)\\n            return\\n        \\n        for num in range(index, n+1):\\n            if num not in path:\\n                path += [num]        \\n                self.dfs(n, k, path, res, num+1)\\n                path.pop()\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        if k==0 or n<1:\\n            return res\\n        \\n        self.dfs(n, k, [], res, 1)\\n        return res\\n        \\n    def dfs(self, n, k, path, res, index):\\n        length = len(path)\\n        #if len(path) == k:\\n        if length == k:\\n            res.append(path[:])\\n            return\\n        \\n        # TLE problem solved by adding this\\n        if k-length > n - index + 1: # need k numbers in total , still need (k-lenth)\\n            return\\n        \\n        for num in range(index, n+1):\\n            if num not in path:\\n                path += [num]        \\n                self.dfs(n, k, path, res, num+1)\\n                path.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580226,
                "title": "python-simple-recursion-76-ms-faster-than-97-09",
                "content": "*nCk* can be constructed through the result of two sub parts:\\n1. *(n-1)C(k)*\\n2. *(n-1)C(k-1)*, with *n* appended to each result.\\n\\nThe base cases are when *n==k* and when *k==1*\\n\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        if n == k:\\n            return [[x for x in range(1,n+1)]]\\n        if k == 1:\\n            return [[x] for x in range(1,n+1)]\\n        # (n-1)C(k-1)\\n        res = self.combine(n-1, k-1)\\n        res = [lst + [n] for lst in res]\\n        # (n-1)C(k)\\n        res.extend(self.combine(n-1, k))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        if n == k:\\n            return [[x for x in range(1,n+1)]]\\n        if k == 1:\\n            return [[x] for x in range(1,n+1)]\\n        # (n-1)C(k-1)\\n        res = self.combine(n-1, k-1)\\n        res = [lst + [n] for lst in res]\\n        # (n-1)C(k)\\n        res.extend(self.combine(n-1, k))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557838,
                "title": "c-backtracking-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<vector<int>> &res , vector<int>& ans , int n , int left , int k)\\n    {\\n     if(k == 0)\\n     {\\n         res.push_back(ans);\\n         return ;\\n     }\\n        \\n        for(int i = left ; i <= n ; i++)\\n        {\\n            ans.push_back(i);\\n            helper(res,ans,n,i+1,k-1);\\n            ans.pop_back();\\n        }\\n        \\n    }\\n    \\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        vector<int> ans;\\n        \\n        helper(res,ans,n,1,k);\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<vector<int>> &res , vector<int>& ans , int n , int left , int k)\\n    {\\n     if(k == 0)\\n     {\\n         res.push_back(ans);\\n         return ;\\n     }\\n        \\n        for(int i = left ; i <= n ; i++)\\n        {\\n            ans.push_back(i);\\n            helper(res,ans,n,i+1,k-1);\\n            ans.pop_back();\\n        }\\n        \\n    }\\n    \\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        vector<int> ans;\\n        \\n        helper(res,ans,n,1,k);\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960674,
                "title": "c-backtracking-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void backtrack(int n,int k,vector<int> &curr,vector<vector<int> >&ans,int num){\\n        curr.push_back(num);\\n        if(curr.size()==k){\\n            ans.push_back(curr);\\n            curr.pop_back();\\n            return;\\n        }\\n        for(int i=num+1;i<=n;i++){\\n            backtrack(n,k,curr,ans,i);\\n        }\\n        curr.pop_back();\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int> > ans;\\n        vector<int> curr;\\n        for(int i=1;i<=n;i++){\\n            backtrack(n,k,curr,ans,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(int n,int k,vector<int> &curr,vector<vector<int> >&ans,int num){\\n        curr.push_back(num);\\n        if(curr.size()==k){\\n            ans.push_back(curr);\\n            curr.pop_back();\\n            return;\\n        }\\n        for(int i=num+1;i<=n;i++){\\n            backtrack(n,k,curr,ans,i);\\n        }\\n        curr.pop_back();\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int> > ans;\\n        vector<int> curr;\\n        for(int i=1;i<=n;i++){\\n            backtrack(n,k,curr,ans,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764427,
                "title": "2-approaches-easy-short",
                "content": "\\n```Approach 1:```\\n\\n**Simple and fast**\\n\\ncode:\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> combine(int n, int k)\\n\\t{\\n\\t\\tvector<vector<int>> result;\\n\\t\\tint i = 0;\\n\\t\\tvector<int> p(k, 0);\\n\\t\\twhile (i >= 0)\\n\\t\\t{\\n\\t\\t\\tp[i]++;\\n\\t\\t\\tif (p[i] > n)\\n\\t\\t\\t\\t--i;\\n\\t\\t\\telse if (i == k - 1)\\n\\t\\t\\t\\tresult.push_back(p);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t++i;\\n\\t\\t\\t\\tp[i] = p[i - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```\\n\\n```Approach 2:```\\n\\n**using Recursion**\\n\\ncode:\\n\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> ans;\\n\\n\\tvoid helper(int idx, int k, vector<int> &current, int n)\\n\\t{\\n\\t\\tif (current.size() == k)\\n\\t\\t{\\n\\t\\t\\tans.push_back(current);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = idx; i < n + 1; i++)\\n\\t\\t{\\n\\t\\t\\tcurrent.push_back(i);\\n\\t\\t\\thelper(i + 1, k, current, n);\\n\\t\\t\\tcurrent.pop_back();\\n\\t\\t}\\n\\t}\\n\\n\\tvector<vector<int>> combine(int n, int k)\\n\\t{\\n\\t\\tvector<int> current;\\n\\t\\thelper(1, k, current, n);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\nHope it will help you \\uD83D\\uDE4C.\\nThank you!",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```Approach 1:```\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> combine(int n, int k)\\n\\t{\\n\\t\\tvector<vector<int>> result;\\n\\t\\tint i = 0;\\n\\t\\tvector<int> p(k, 0);\\n\\t\\twhile (i >= 0)\\n\\t\\t{\\n\\t\\t\\tp[i]++;\\n\\t\\t\\tif (p[i] > n)\\n\\t\\t\\t\\t--i;\\n\\t\\t\\telse if (i == k - 1)\\n\\t\\t\\t\\tresult.push_back(p);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t++i;\\n\\t\\t\\t\\tp[i] = p[i - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```\n```Approach 2:```\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> ans;\\n\\n\\tvoid helper(int idx, int k, vector<int> &current, int n)\\n\\t{\\n\\t\\tif (current.size() == k)\\n\\t\\t{\\n\\t\\t\\tans.push_back(current);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = idx; i < n + 1; i++)\\n\\t\\t{\\n\\t\\t\\tcurrent.push_back(i);\\n\\t\\t\\thelper(i + 1, k, current, n);\\n\\t\\t\\tcurrent.pop_back();\\n\\t\\t}\\n\\t}\\n\\n\\tvector<vector<int>> combine(int n, int k)\\n\\t{\\n\\t\\tvector<int> current;\\n\\t\\thelper(1, k, current, n);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194428,
                "title": "java-solution-using-backtracking",
                "content": "```\\npublic List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList();\\n        combinations(res, new ArrayList<Integer>(), 1, n, k);\\n        return res;\\n    }\\n    private void combinations(List<List<Integer>> res, List<Integer> temp, int start, int end, int k){\\n        if(k == 0){\\n            res.add(new ArrayList<Integer>(temp));\\n            return;\\n        }\\n        for(int i=start; i<=end-k+1; i++){\\n            temp.add(i);\\n            combinations(res, temp, i+1, end, k-1);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n```\\n**Please upvote if you found the solution helpful**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList();\\n        combinations(res, new ArrayList<Integer>(), 1, n, k);\\n        return res;\\n    }\\n    private void combinations(List<List<Integer>> res, List<Integer> temp, int start, int end, int k){\\n        if(k == 0){\\n            res.add(new ArrayList<Integer>(temp));\\n            return;\\n        }\\n        for(int i=start; i<=end-k+1; i++){\\n            temp.add(i);\\n            combinations(res, temp, i+1, end, k-1);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597580,
                "title": "js-simple-backtracking-solution",
                "content": "```\\nvar combine = function(n, k) {\\n    const backtrack = (first = 1, arr = []) => {\\n        if (arr.length == k) {\\n            output.push([...arr])\\n        }\\n        if (arr.length < k)\\n            for (let i = first; i <= n; i++) {\\n                arr.push(i);\\n                backtrack(i + 1, arr);\\n                arr.pop();\\n            }\\n    }\\n\\n    let output = [];\\n    backtrack();\\n    return output;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar combine = function(n, k) {\\n    const backtrack = (first = 1, arr = []) => {\\n        if (arr.length == k) {\\n            output.push([...arr])\\n        }\\n        if (arr.length < k)\\n            for (let i = first; i <= n; i++) {\\n                arr.push(i);\\n                backtrack(i + 1, arr);\\n                arr.pop();\\n            }\\n    }\\n\\n    let output = [];\\n    backtrack();\\n    return output;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 917398,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    private IList<IList<int>> res = new List<IList<int>>();\\n    \\n    public IList<IList<int>> Combine(int n, int k) {\\n        Helper(n, k, 1, new List<int>());\\n        \\n        return res;\\n    }\\n    \\n    private void Helper(int n, int k, int i, List<int> l)\\n    {\\n        if (l.Count == k)\\n            res.Add(new List<int>(l));\\n        else\\n            for (int j = i; j <= n; j++)\\n            {\\n                l.Add(j);\\n                \\n                Helper(n, k, j + 1, l);\\n                \\n                l.RemoveAt(l.Count - 1);\\n            }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private IList<IList<int>> res = new List<IList<int>>();\\n    \\n    public IList<IList<int>> Combine(int n, int k) {\\n        Helper(n, k, 1, new List<int>());\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 27151,
                "title": "easy-python-recursive-solution-64ms",
                "content": "    def combinations(n, k, start=1):\\n        if k == 1:\\n            return [[x,] for x in xrange(start, n+1)]\\n     \\n        Result = []\\n        for FirstNum in xrange(start, n - k + 2):\\n            for Comb in combinations(n, k-1, FirstNum + 1):\\n                Result.append([FirstNum,] + Comb)\\n        return Result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def combinations(n, k, start=1):\\n        if k == 1:\\n            return [[x,] for x in xrange(start, n+1)]\\n     \\n        Result = []\\n        for FirstNum in xrange(start, n - k + 2):\\n            for Comb in combinations(n, k-1, FirstNum + 1):\\n                Result.append([FirstNum,] + Comb)\\n        return Result",
                "codeTag": "Python3"
            },
            {
                "id": 27215,
                "title": "dfs-recursive-java-solution",
                "content": "A DFS idea with back-trace. Very straightforward.\\n\\n    public class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            List<List<Integer>> rslt = new ArrayList<List<Integer>>();\\n            dfs(new Stack<Integer>(), 1, n, k, rslt);\\n            return rslt;\\n        }\\n        \\n        private void dfs(Stack<Integer> path, int index, int n, int k, List<List<Integer>> rslt){\\n            // ending case\\n            if(k==0){\\n                List<Integer> list = new ArrayList<Integer>(path);\\n                rslt.add(list);\\n                return;\\n            }\\n            // recursion case\\n            for(int i = index;i <= n;i++){\\n                path.push(i);\\n                dfs(path, i+1, n, k-1, rslt);\\n                path.pop();\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            List<List<Integer>> rslt = new ArrayList<List<Integer>>();\\n            dfs(new Stack<Integer>(), 1, n, k, rslt);\\n            return rslt;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3874192,
                "title": "one-liner-by-using-builtin-functions-and-many-beats-than-simple-back-tracing-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport itertools\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        return list(combinations(range(1,n+1),k))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport itertools\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        return list(combinations(range(1,n+1),k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845643,
                "title": "easy-to-understand-c-java-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding all possible combinations of k numbers chosen from the range [1, n]. To solve this, we can use a backtracking approach. The idea is to start with an empty combination and keep adding numbers to it one by one until it reaches the desired length (k).\\n\\nThe key insight of the backtracking approach is that at each step, we have two choices for the next number to include in the combination:\\n\\n1. Include the current number in the combination and move forward to explore combinations of length k - 1.\\n2. Skip the current number and move forward to explore combinations without it.\\n\\nBy making these choices recursively, we can generate all valid combinations of k numbers from the range [1, n].\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We start by defining the main combine function that takes two integers n and k as input and returns a list of lists containing all possible combinations of k numbers chosen from the range [1, n].\\n\\n2. To implement backtracking, we define a recursive helper function, let\\'s call it backtrack, which will perform the actual exploration of combinations.\\n\\nThe backtrack function takes the following parameters:\\n\\n- start: An integer representing the current number being considered for the combination.\\n- curr_combination: A list that holds the current combination being formed.\\n- result: The list that will store the final valid combinations.\\n4. The base case of the backtrack function is when the length of curr_combination reaches k. This means we have formed a valid combination of length k, so we add it to the result list.\\n\\n5. Otherwise, if the length of curr_combination is less than k, we proceed with the exploration. For each number i from start to n, we make two choices:\\na) Include the number i in the current combination by adding it to curr_combination.\\nb) Recur for the next number by calling backtrack(i + 1, curr_combination, result).\\n\\n6. After making the recursive call, we need to backtrack (undo) the choice we made. Since we are using the same curr_combination list for all recursive calls, we remove the last added element from curr_combination. This ensures that we explore all possible combinations correctly.\\n\\n7. By following this backtracking process, the backtrack function will explore all possible combinations of length k from the range [1, n], and the valid combinations will be stored in the result list.\\n\\n8. Finally, we call the backtrack function initially with start = 1, an empty curr_combination, and the result list. This will start the backtracking process and generate all valid combinations.\\n\\n9. After the backtracking process is complete, the result list contains all the valid combinations, and we return it as the final answer.\\n\\n# Complexity\\n- **Time complexity:** The time complexity of this approach is O(n choose k) since we are generating all possible combinations of k numbers from the range [1, n]. The number of such combinations is (n choose k), which is the total number of elements in the result list.\\n\\n- **Space complexity:**  The space complexity is O(k) since the maximum depth of the recursion (backtracking stack) is k, which represents the length of the combinations we are generating. Additionally, the result list will contain all valid combinations, which can be (n choose k) elements in the worst case.\\n\\n# Code\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> result;\\n        vector<int> curr_combination;\\n        backtrack(1, n, k, curr_combination, result);\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack(int start, int n, int k, vector<int>& curr_combination, vector<vector<int>>& result) {\\n        if (curr_combination.size() == k) {\\n            result.push_back(curr_combination);\\n            return;\\n        }\\n        for (int i = start; i <= n; ++i) {\\n            curr_combination.push_back(i);\\n            backtrack(i + 1, n, k, curr_combination, result);\\n            curr_combination.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n**Java:**\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> curr_combination = new ArrayList<>();\\n        backtrack(1, n, k, curr_combination, result);\\n        return result;\\n    }\\n\\n    private void backtrack(int start, int n, int k, List<Integer> curr_combination, List<List<Integer>> result) {\\n        if (curr_combination.size() == k) {\\n            result.add(new ArrayList<>(curr_combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; ++i) {\\n            curr_combination.add(i);\\n            backtrack(i + 1, n, k, curr_combination, result);\\n            curr_combination.remove(curr_combination.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n**python3:**\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        result = []\\n        curr_combination = []\\n        self.backtrack(1, n, k, curr_combination, result)\\n        return result\\n\\n    def backtrack(self, start, n, k, curr_combination, result):\\n        if len(curr_combination) == k:\\n            result.append(curr_combination[:])\\n            return\\n        for i in range(start, n + 1):\\n            curr_combination.append(i)\\n            self.backtrack(i + 1, n, k, curr_combination, result)\\n            curr_combination.pop()\\n```\\n\\n## Please upvote the solution, Your upvote makes my day.\\n![upvote img.jpg](https://assets.leetcode.com/users/images/7229039f-8d58-4917-851c-3a97517231fc_1690861201.0607455.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> result;\\n        vector<int> curr_combination;\\n        backtrack(1, n, k, curr_combination, result);\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack(int start, int n, int k, vector<int>& curr_combination, vector<vector<int>>& result) {\\n        if (curr_combination.size() == k) {\\n            result.push_back(curr_combination);\\n            return;\\n        }\\n        for (int i = start; i <= n; ++i) {\\n            curr_combination.push_back(i);\\n            backtrack(i + 1, n, k, curr_combination, result);\\n            curr_combination.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> curr_combination = new ArrayList<>();\\n        backtrack(1, n, k, curr_combination, result);\\n        return result;\\n    }\\n\\n    private void backtrack(int start, int n, int k, List<Integer> curr_combination, List<List<Integer>> result) {\\n        if (curr_combination.size() == k) {\\n            result.add(new ArrayList<>(curr_combination));\\n            return;\\n        }\\n        for (int i = start; i <= n; ++i) {\\n            curr_combination.add(i);\\n            backtrack(i + 1, n, k, curr_combination, result);\\n            curr_combination.remove(curr_combination.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        result = []\\n        curr_combination = []\\n        self.backtrack(1, n, k, curr_combination, result)\\n        return result\\n\\n    def backtrack(self, start, n, k, curr_combination, result):\\n        if len(curr_combination) == k:\\n            result.append(curr_combination[:])\\n            return\\n        for i in range(start, n + 1):\\n            curr_combination.append(i)\\n            self.backtrack(i + 1, n, k, curr_combination, result)\\n            curr_combination.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845574,
                "title": "python3-one-liner-solution",
                "content": "\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        return combinations(range(1,n+1),k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        return combinations(range(1,n+1),k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845388,
                "title": "c-recursion-backtracking",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(sub_ans);\\n            return;\\n        }\\n        if(num == n+1) return;\\n        \\n        // skip\\n        solve(n,k,num+1,sub_ans,ans);\\n        \\n        // acquire\\n        sub_ans.push_back(num);\\n        solve(n,k-1,num+1,sub_ans,ans);\\n        sub_ans.pop_back();\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> sub_ans;\\n        \\n        solve(n,k,1,sub_ans,ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(sub_ans);\\n            return;\\n        }\\n        if(num == n+1) return;\\n        \\n        // skip\\n        solve(n,k,num+1,sub_ans,ans);\\n        \\n        // acquire\\n        sub_ans.push_back(num);\\n        solve(n,k-1,num+1,sub_ans,ans);\\n        sub_ans.pop_back();\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> sub_ans;\\n        \\n        solve(n,k,1,sub_ans,ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198613,
                "title": "c-2-different-approaches-easy-explanation-clean-code",
                "content": "\\n# Generate All Possible Subset\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to find out all the possible subset and take only those which have a size == k\\n\\nRecommended Question ( Subset ) :  [ https://leetcode.com/problems/subsets/]()\\n\\n# Complexity\\n- Time complexity : 2^N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans){\\n\\n        \\n          if(index==nums.size()){\\n\\n              if(temp.size()==k){\\n                  ans.push_back(temp);\\n              }\\n              return ;\\n          }\\n\\n          helper(nums, k, index+1, temp, ans);\\n          temp.push_back(nums[index]);\\n          helper(nums, k, index+1, temp, ans);\\n          temp.pop_back();\\n        \\n\\n\\n\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        vector<int> nums;\\n\\n        for(int i = 1;i<=n;i++){\\n            nums.push_back(i);\\n        }\\n\\n        helper(nums,k,0,temp,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n# 2nd Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake all the possible pairs in each for loop iteration and for each index i, push them into temp and decrease size of k and call Recursion after the Recursion call ends pop back the value.\\n\\n# Complexity\\n- Time complexity : 2^N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans){\\n\\n        \\n            if(k==0){\\n                ans.push_back(temp);\\n                return;\\n            }\\n          \\n\\n            if(index==nums.size()) return ;\\n\\n            for(int i = index;i<nums.size();i++){\\n                temp.push_back(nums[i]);\\n                helper(nums,k-1,i+1,temp,ans);\\n                temp.pop_back();\\n            }\\n\\n\\n\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        vector<int> nums;\\n\\n        for(int i = 1;i<=n;i++){\\n            nums.push_back(i);\\n        }\\n\\n        helper(nums,k,0,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans){\\n\\n        \\n          if(index==nums.size()){\\n\\n              if(temp.size()==k){\\n                  ans.push_back(temp);\\n              }\\n              return ;\\n          }\\n\\n          helper(nums, k, index+1, temp, ans);\\n          temp.push_back(nums[index]);\\n          helper(nums, k, index+1, temp, ans);\\n          temp.pop_back();\\n        \\n\\n\\n\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        vector<int> nums;\\n\\n        for(int i = 1;i<=n;i++){\\n            nums.push_back(i);\\n        }\\n\\n        helper(nums,k,0,temp,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans){\\n\\n        \\n            if(k==0){\\n                ans.push_back(temp);\\n                return;\\n            }\\n          \\n\\n            if(index==nums.size()) return ;\\n\\n            for(int i = index;i<nums.size();i++){\\n                temp.push_back(nums[i]);\\n                helper(nums,k-1,i+1,temp,ans);\\n                temp.pop_back();\\n            }\\n\\n\\n\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        vector<int> nums;\\n\\n        for(int i = 1;i<=n;i++){\\n            nums.push_back(i);\\n        }\\n\\n        helper(nums,k,0,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051287,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    int nl;\\n\\n    void solve(vector<int> &a, int id, int k) {\\n        if(k == 0) {\\n            ans.push_back(a);\\n            return;\\n        }\\n        for(int i=id; i<=nl; i++) {\\n            a.push_back(i);\\n            solve(a, i+1, k-1);\\n            a.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combine(int n, int k) {\\n        nl = n;\\n        vector<int> a;\\n        solve(a, 1, k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    int nl;\\n\\n    void solve(vector<int> &a, int id, int k) {\\n        if(k == 0) {\\n            ans.push_back(a);\\n            return;\\n        }\\n        for(int i=id; i<=nl; i++) {\\n            a.push_back(i);\\n            solve(a, i+1, k-1);\\n            a.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combine(int n, int k) {\\n        nl = n;\\n        vector<int> a;\\n        solve(a, 1, k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245858,
                "title": "python3-backtracking-intuitive-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        nums = list(range(1, n+1))\\n        results = []\\n        \\n        def backtrack(i, ans):\\n            if len(ans) == k:\\n                results.append(ans[:])\\n                return\\n            \\n            for num in nums[i:]:\\n                ans.append(num)\\n                # i+1 to control the search space vertically i.e. to use each element only once\\n                backtrack(i+1, ans)\\n                ans.pop()\\n                # to control the search space horizontally i.e. to only use successive elements\\n                i += 1\\n                \\n        backtrack(0, [])\\n        \\n        return results\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        nums = list(range(1, n+1))\\n        results = []\\n        \\n        def backtrack(i, ans):\\n            if len(ans) == k:\\n                results.append(ans[:])\\n                return\\n            \\n            for num in nums[i:]:\\n                ans.append(num)\\n                # i+1 to control the search space vertically i.e. to use each element only once\\n                backtrack(i+1, ans)\\n                ans.pop()\\n                # to control the search space horizontally i.e. to only use successive elements\\n                i += 1\\n                \\n        backtrack(0, [])\\n        \\n        return results\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1778321,
                "title": "c-easy-and-simple-code-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void backTrack(int n,int k,int it,vector<vector<int>> &ans,vector<int> &res){\\n        \\n        if(res.size()==k){\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i=it;i<=n;i++){\\n            res.push_back(i);\\n            backTrack(n,k,i+1,ans,res);\\n            res.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        backTrack(n,k,1,ans,res);\\n        return ans;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backTrack(int n,int k,int it,vector<vector<int>> &ans,vector<int> &res){\\n        \\n        if(res.size()==k){\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i=it;i<=n;i++){\\n            res.push_back(i);\\n            backTrack(n,k,i+1,ans,res);\\n            res.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        backTrack(n,k,1,ans,res);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654409,
                "title": "combinations-c-backtracking",
                "content": "TC=O(n*(2^n))\\nSC=O(n) this can be a topic of discussion\\n\\nsimilar to the question subsets\\nhttps://leetcode.com/problems/subsets/discuss/1654354/3-sol.-oror-c%2B%2B-oror-subsets-oror-backtracking-oror-bit-manipulation-oror-iterative\\n\\n```\\nclass Solution {\\npublic:\\n    void generate(vector<int>& nums,int idx,int k,vector<int>& curr,vector<vector<int>>&ans){\\n        if(curr.size()==k){\\n         ans.push_back(curr);\\n            return;}\\n        for( int i=idx;i<nums.size();i++){\\n            curr.push_back(nums[i]);\\n            generate(nums,i+1,k,curr,ans);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> ans;\\n        vector<int> curr;\\n        vector<int> nums(n,0);\\n        for(int i=0;i<n;i++){\\n            nums[i]=i+1;\\n        }\\n    generate(nums,0,k,curr,ans);\\n        return ans;\\n    }\\n};\\n\\n```\\nupvote if found useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generate(vector<int>& nums,int idx,int k,vector<int>& curr,vector<vector<int>>&ans){\\n        if(curr.size()==k){\\n         ans.push_back(curr);\\n            return;}\\n        for( int i=idx;i<nums.size();i++){\\n            curr.push_back(nums[i]);\\n            generate(nums,i+1,k,curr,ans);\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> ans;\\n        vector<int> curr;\\n        vector<int> nums(n,0);\\n        for(int i=0;i<n;i++){\\n            nums[i]=i+1;\\n        }\\n    generate(nums,0,k,curr,ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303288,
                "title": "general-approach-to-backtracking-problems-in-c",
                "content": "Below I present a general approach to many standard backtracking problems. A similar version exists for JAVA [here](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)) but I thought it would be a good idea to do the same for C++ as well, even though  the essence of the solutions remains the same. Most of these problems follow a single template as given below. \\n\\n```\\n//Template\\nvoid Backtrack(int start)\\n{\\n    //Base case \\n\\n// loop for all possible values\\n{\\n    //include the current element at this position if possible in the ans \\n\\t//More generally, make a choice \\n\\n    Backtrack(start+1) \\n\\n    //backtrack by removing current element \\n}\\n```\\n\\n\\n**1**.[78. Subsets](https://leetcode.com/problems/subsets/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        GenerateSubs(a,0,subset,ans);\\n        return ans;      \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n          for(int i=s;i<n;i++)\\n        {\\n            subset.push_back(a[i]); //include element at ith position\\n            GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n            subset.pop_back(); //backtrack\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\\n\\n**2**.[90. Subsets II](https://leetcode.com/problems/subsets-ii/) (Subsets with duplicates)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        sort(a.begin(),a.end()); //sort the elements so that we can keep track of duplicates\\n        GenerateSubs(a,0,subset,ans);\\n        return ans;    \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n        for(int i=s;i<n;i++)\\n        {\\n            if(i==s||a[i]!=a[i-1]) \\n            {\\n              subset.push_back(a[i]); //include element at ith position\\n              GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n              subset.pop_back(); //backtrack\\n            }\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\\n\\n**3.** [77. Combinations](https://leetcode.com/problems/combinations/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        \\n        GenerateCombs(n,1,k,ans,combination);\\n        return ans;\\n    }\\nprivate:\\n    void GenerateCombs(int n,int s,int k,vector<vector<int>> &ans,vector<int> &combination)\\n    {\\n        if(combination.size()==k) //base case\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=n;i++)\\n        {\\n            combination.push_back(i); //include i in a combination\\n            GenerateCombs(n,i+1,k,ans,combination);\\n            combination.pop_back(); //remove i, i.e. backtrack\\n        }\\n    }\\n};\\n```\\n\\n**4.** [39. Combination Sum\\n](https://leetcode.com/problems/combination-sum/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0) //base case1\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination); //base case 2\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n            combination.push_back(a[i]);\\n            combs(a,i,sum-a[i]);\\n            combination.pop_back();\\n        }\\n    }  \\n};\\n```\\n\\n**5.** [40. Combination Sum II\\n](https://leetcode.com/problems/combination-sum-ii/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0)\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n                \\n            if(i==s||a[i]!=a[i-1])\\n            {\\n             combination.push_back(a[i]);\\n             combs(a,i+1,sum-a[i]);\\n             combination.pop_back();   \\n            }\\n        }\\n    }\\n};\\n```\\n\\n**6.**  [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        Generate(0,0,s,n);\\n        return ans;\\n    }\\nprivate:\\n    vector<string>ans;\\n    void Generate(int left,int right,string &s,int n)\\n    {\\n        if(left==n&&right==n) // base case: when left and right parentheses are equal to n.\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t\\n        // case I: if left parenteses are less than n, we can add a ( to the string. \\n\\t\\t//But we might also add a ) so we backtrack by poppping it.\\n        if(left<n)\\n\\t\\t{\\n            s+=\\'(\\';\\n            Generate(left+1,right,s,n);\\n            s.pop_back(); \\n        }\\n        \\n        if(left>right) //case II: follows from I.\\n        {\\n            s+=\\')\\';\\n            Generate(left,right+1,s,n);\\n            s.pop_back();\\n        } \\n    }\\n};\\n```\\n\\n**7.** [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        n=s.size();\\n        Generate(s,0);\\n        return ans;   \\n    }\\nprivate:\\n    vector<vector<string>>ans;\\n    vector<string>Partition;\\n    int n;\\n    \\n    bool is_pal(string &s,int start,int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void Generate(string &s,int start)\\n    {\\n        if(start==n)\\n        {\\n            ans.push_back(Partition);\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++)\\n        {\\n            if(is_pal(s,start,i))\\n            {\\n                Partition.push_back(s.substr(start,i-start+1));\\n                Generate(s,i+1);\\n                Partition.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\\n\\n**8.** [46. Permutations](https://leetcode.com/problems/permutations/)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        vector<vector<int>> ans;\\n        \\n        permutations(arr,0,ans);\\n        \\n        return ans;\\n    }\\n    void permutations(vector<int>&arr,int s,vector<vector<int>>&ans)\\n    {\\n        if(s==arr.size())\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i=s;i<arr.size();i++)\\n        {\\n            swap(arr[s],arr[i]);\\n            permutations(arr,s+1,ans);\\n            swap(arr[s],arr[i]);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n//Template\\nvoid Backtrack(int start)\\n{\\n    //Base case \\n\\n// loop for all possible values\\n{\\n    //include the current element at this position if possible in the ans \\n\\t//More generally, make a choice \\n\\n    Backtrack(start+1) \\n\\n    //backtrack by removing current element \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        GenerateSubs(a,0,subset,ans);\\n        return ans;      \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n          for(int i=s;i<n;i++)\\n        {\\n            subset.push_back(a[i]); //include element at ith position\\n            GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n            subset.pop_back(); //backtrack\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& a) {\\n        vector<vector<int>> ans;\\n        vector<int> subset;\\n        n=a.size();\\n        \\n        sort(a.begin(),a.end()); //sort the elements so that we can keep track of duplicates\\n        GenerateSubs(a,0,subset,ans);\\n        return ans;    \\n    }\\nprivate:\\n    int n;\\n    void GenerateSubs(vector<int>&a,int s,vector<int>&subset,vector<vector<int>>&ans)\\n    {\\n        for(int i=s;i<n;i++)\\n        {\\n            if(i==s||a[i]!=a[i-1]) \\n            {\\n              subset.push_back(a[i]); //include element at ith position\\n              GenerateSubs(a,i+1,subset,ans); //generate all subsets including ith element\\n              subset.pop_back(); //backtrack\\n            }\\n        }\\n        ans.push_back(subset);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        \\n        GenerateCombs(n,1,k,ans,combination);\\n        return ans;\\n    }\\nprivate:\\n    void GenerateCombs(int n,int s,int k,vector<vector<int>> &ans,vector<int> &combination)\\n    {\\n        if(combination.size()==k) //base case\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=n;i++)\\n        {\\n            combination.push_back(i); //include i in a combination\\n            GenerateCombs(n,i+1,k,ans,combination);\\n            combination.pop_back(); //remove i, i.e. backtrack\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0) //base case1\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination); //base case 2\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n            combination.push_back(a[i]);\\n            combs(a,i,sum-a[i]);\\n            combination.pop_back();\\n        }\\n    }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& a, int sum) {\\n        n=a.size();\\n        sort(a.begin(),a.end()); // optimising by only including elements smaller than sum\\n        combs(a,0,sum);\\n        \\n        return ans;\\n        \\n    }\\nprivate:\\n    vector<vector<int>>ans;\\n    vector<int> combination;\\n    int n;\\n    \\n    void combs(vector<int>&a,int s,int sum)\\n    {\\n        if(sum<0)\\n            return;\\n        \\n        if(sum==0)\\n        {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        \\n        for(int i=s;i<n&&a[i]<=sum;i++)\\n        {\\n                \\n            if(i==s||a[i]!=a[i-1])\\n            {\\n             combination.push_back(a[i]);\\n             combs(a,i+1,sum-a[i]);\\n             combination.pop_back();   \\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        Generate(0,0,s,n);\\n        return ans;\\n    }\\nprivate:\\n    vector<string>ans;\\n    void Generate(int left,int right,string &s,int n)\\n    {\\n        if(left==n&&right==n) // base case: when left and right parentheses are equal to n.\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t\\n        // case I: if left parenteses are less than n, we can add a ( to the string. \\n\\t\\t//But we might also add a ) so we backtrack by poppping it.\\n        if(left<n)\\n\\t\\t{\\n            s+=\\'(\\';\\n            Generate(left+1,right,s,n);\\n            s.pop_back(); \\n        }\\n        \\n        if(left>right) //case II: follows from I.\\n        {\\n            s+=\\')\\';\\n            Generate(left,right+1,s,n);\\n            s.pop_back();\\n        } \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        n=s.size();\\n        Generate(s,0);\\n        return ans;   \\n    }\\nprivate:\\n    vector<vector<string>>ans;\\n    vector<string>Partition;\\n    int n;\\n    \\n    bool is_pal(string &s,int start,int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(s[start++]!=s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void Generate(string &s,int start)\\n    {\\n        if(start==n)\\n        {\\n            ans.push_back(Partition);\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++)\\n        {\\n            if(is_pal(s,start,i))\\n            {\\n                Partition.push_back(s.substr(start,i-start+1));\\n                Generate(s,i+1);\\n                Partition.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        vector<vector<int>> ans;\\n        \\n        permutations(arr,0,ans);\\n        \\n        return ans;\\n    }\\n    void permutations(vector<int>&arr,int s,vector<vector<int>>&ans)\\n    {\\n        if(s==arr.size())\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i=s;i<arr.size();i++)\\n        {\\n            swap(arr[s],arr[i]);\\n            permutations(arr,s+1,ans);\\n            swap(arr[s],arr[i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738165,
                "title": "javascript",
                "content": "```\\nfunction findCombination(n, k, position, seq, mutRes) {\\n    if (k === 0) { mutRes.push([...seq]); return; } \\n    if (position > n) return;\\n    \\n    seq.push(position);\\n    findCombination(n, k - 1, position + 1, seq, mutRes);\\n    seq.pop();\\n    \\n    findCombination(n, k, position + 1, seq, mutRes);\\n}\\n\\n\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function(n, k) {\\n    const mutRes = [];\\n    findCombination(n, k, 1, [], mutRes)\\n    return mutRes;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction findCombination(n, k, position, seq, mutRes) {\\n    if (k === 0) { mutRes.push([...seq]); return; } \\n    if (position > n) return;\\n    \\n    seq.push(position);\\n    findCombination(n, k - 1, position + 1, seq, mutRes);\\n    seq.pop();\\n    \\n    findCombination(n, k, position + 1, seq, mutRes);\\n}\\n\\n\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function(n, k) {\\n    const mutRes = [];\\n    findCombination(n, k, 1, [], mutRes)\\n    return mutRes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315285,
                "title": "swift-iterative-solution",
                "content": "```\\nclass Solution {\\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\\n        \\n        var res = [[Int]]()\\n        var data = [Int](repeating: 0, count: k)\\n        var i = 0\\n    \\n        while data[0] <= (n - k + 1) {\\n            \\n            data[i] += 1\\n            if data[i] > n {\\n                i -= 1\\n            } else if i == (k - 1) {\\n                res.append(data)\\n            } else {\\n                i += 1\\n                data[i] = data[i - 1]\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```\\n\\nThe best I can tell, the TC of this is upper-bound by\\n\\nO ( N! / K! )\\n\\nI am not sure how to prove it. The bottom term may even be something larger size. Don\\'t even know the true MATHZ.\\n\\nPlease pray for my solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\\n        \\n        var res = [[Int]]()\\n        var data = [Int](repeating: 0, count: k)\\n        var i = 0\\n    \\n        while data[0] <= (n - k + 1) {\\n            \\n            data[i] += 1\\n            if data[i] > n {\\n                i -= 1\\n            } else if i == (k - 1) {\\n                res.append(data)\\n            } else {\\n                i += 1\\n                data[i] = data[i - 1]\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180125,
                "title": "5-lines-python-solution-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def combine(self, n, k):\\n        if n == k:\\n            return [list(range(1,n+1))]\\n        if k == 1:\\n            return [ [i] for i in range(1,n+1) ]\\n        return self.combine(n-1,k) + [ j + [n] for j in self.combine(n-1,k-1) ]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combine(self, n, k):\\n        if n == k:\\n            return [list(range(1,n+1))]\\n        if k == 1:\\n            return [ [i] for i in range(1,n+1) ]\\n        return self.combine(n-1,k) + [ j + [n] for j in self.combine(n-1,k-1) ]",
                "codeTag": "Java"
            },
            {
                "id": 131195,
                "title": "backtracking-python",
                "content": "Hope it helps:\\n```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if k>n:\\n            return []\\n        ans=[]\\n        self.helper(n,1,k,ans,[])\\n        return ans\\n    \\n    def helper(self,n,start,k,ans,sub):\\n        if k==0:\\n            ans.append(sub[::])\\n            return\\n        for i in range(start,n-k+2):\\n            sub.append(i)\\n            self.helper(n,i+1,k-1,ans,sub)\\n            sub.pop()\\n\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "Hope it helps:\\n```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if k>n:\\n            return []\\n        ans=[]\\n        self.helper(n,1,k,ans,[])\\n        return ans\\n    \\n    def helper(self,n,start,k,ans,sub):\\n        if k==0:\\n            ans.append(sub[::])\\n            return\\n        for i in range(start,n-k+2):\\n            sub.append(i)\\n            self.helper(n,i+1,k-1,ans,sub)\\n            sub.pop()\\n\\t\\t\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 26997,
                "title": "time-limit-exceeded-why",
                "content": "It works for n = 4, k = 2, but TLE for 20, 16.  Anyone knows why it's inefficient?\\n\\n```class Solution(object):\\n    def combine(self, n, k):\\n        res = []\\n        self.combineHelper(n, k, res, [], 1)\\n        return res\\n            \\n    def combineHelper(self, n, k, res, temp, i):\\n        if len(temp) == k:\\n            res.append(temp)\\n        else:\\n            for i in xrange(i, n+1):\\n                tempList = temp + [i]\\n                self.combineHelper(n, k, res, tempList, i+1)",
                "solutionTags": [],
                "code": "It works for n = 4, k = 2, but TLE for 20, 16.  Anyone knows why it's inefficient?\\n\\n```class Solution(object):\\n    def combine(self, n, k):\\n        res = []\\n        self.combineHelper(n, k, res, [], 1)\\n        return res\\n            \\n    def combineHelper(self, n, k, res, temp, i):\\n        if len(temp) == k:\\n            res.append(temp)\\n        else:\\n            for i in xrange(i, n+1):\\n                tempList = temp + [i]\\n                self.combineHelper(n, k, res, tempList, i+1)",
                "codeTag": "Java"
            },
            {
                "id": 27101,
                "title": "combinations-v-s-combination-sum-iii-java",
                "content": "These two questions are very similar, so here I am going to put these two questions into comparisons.\\n\\nIn ***Combinations***, given `k` is the length of the sub-list, `n` is the last number of combination, return all possible combinations of k numbers out of 1 ... n.\\n\\nIn ***Combination Sum III***,  `k` is the length of the sub-list, `n` is the target sum, return all possible combinations of k numbers  that add up to `n`. Here, we limit the number used from 1 to 9. \\n\\nWhat's the similarities? \\n\\n 1. Both start at `1`\\n 2. ***Combinations*** ends ranges from `n - k + 1` to `n` , ***Combination Sum III*** from `1` to `9`  \\n 3. ***Combinations*** adds sub-list when sub-list size is equal to `k`, ***Combination Sum III*** adds sub-list when sub-list size is equal to `k` and remaining equals `0` (subtract `i` from `n` in loop)\\n \\n----------\\n\\n\\nCombinations :\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, 1, n - k + 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int start, int end) {\\n       if (tempList.size() == k) list.add(new ArrayList<>(tempList)); \\n       else{\\n          for (int i = start; i <= end; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, i + 1, end + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III :\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n       if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i <= 9; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, remain - i, i + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "These two questions are very similar, so here I am going to put these two questions into comparisons.\\n\\nIn ***Combinations***, given `k` is the length of the sub-list, `n` is the last number of combination, return all possible combinations of k numbers out of 1 ... n.\\n\\nIn ***Combination Sum III***,  `k` is the length of the sub-list, `n` is the target sum, return all possible combinations of k numbers  that add up to `n`. Here, we limit the number used from 1 to 9. \\n\\nWhat's the similarities? \\n\\n 1. Both start at `1`\\n 2. ***Combinations*** ends ranges from `n - k + 1` to `n` , ***Combination Sum III*** from `1` to `9`  \\n 3. ***Combinations*** adds sub-list when sub-list size is equal to `k`, ***Combination Sum III*** adds sub-list when sub-list size is equal to `k` and remaining equals `0` (subtract `i` from `n` in loop)\\n \\n----------\\n\\n\\nCombinations :\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, 1, n - k + 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int start, int end) {\\n       if (tempList.size() == k) list.add(new ArrayList<>(tempList)); \\n       else{\\n          for (int i = start; i <= end; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, i + 1, end + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III :\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n       if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i <= 9; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, remain - i, i + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26998,
                "title": "python-recursive-solution",
                "content": "    class Solution:\\n        # @return a list of lists of integers\\n        # 9:14\\n        def __init__(self):\\n            self.output = []\\n    \\n        def combine(self, n, k, pos=0, temp=None):\\n            temp = temp or []\\n            \\n            if len(temp) == k:\\n                self.output.append(temp[:])\\n                return\\n    \\n            for i in range(pos, n):\\n                temp.append(i+1)\\n                self.combine(n, k, i+1, temp)\\n                temp.pop()\\n            \\n            return self.output",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return a list of lists of integers\\n        # 9:14\\n        def __init__(self):\\n            self.output = []\\n    \\n        def combine(self, n, k, pos=0, temp=None):\\n            temp = temp or []\\n            \\n            if len(temp) == k:\\n                self.output.append(temp[:])\\n                return\\n    \\n            for i in range(pos, n):\\n                temp.append(i+1)\\n                self.combine(n, k, i+1, temp)\\n                temp.pop()\\n            \\n            return self.output",
                "codeTag": "Java"
            },
            {
                "id": 3851362,
                "title": "best-solution",
                "content": "# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, int k, vector<int>& temp, vector<vector<int>>& ans) {\\n        if (k == 0) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if (i == 0) {\\n            return;\\n        }\\n        temp.push_back(i);\\n        solve(i-1, k-1, temp, ans);\\n        temp.pop_back();\\n        solve(i-1, k, temp, ans);\\n    }\\n\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(n, k, temp, ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, int k, vector<int>& temp, vector<vector<int>>& ans) {\\n        if (k == 0) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if (i == 0) {\\n            return;\\n        }\\n        temp.push_back(i);\\n        solve(i-1, k-1, temp, ans);\\n        temp.pop_back();\\n        solve(i-1, k, temp, ans);\\n    }\\n\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(n, k, temp, ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846581,
                "title": "java-simple-recursion-easy-to-understand",
                "content": "# Intuition\\n- Brute force: Try out all ways\\n- Recursion\\n\\n# Approach\\n- Recursion\\n\\n# Complexity\\n- Time complexity: Roughly Exponential\\n\\n- Space complexity: O(n) (neglecting output array)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> allCombinations = new ArrayList<>();\\n        f(1, n, k, allCombinations, new ArrayList<>());\\n        return allCombinations;\\n    }\\n\\n    private void f(int i, int n, int k, List<List<Integer>> allCombinations, ArrayList<Integer> list){\\n        if (list.size() == k){\\n            allCombinations.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for (int j = i; j <= n; j++){\\n            list.add(j);\\n            f(j + 1, n, k, allCombinations, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> allCombinations = new ArrayList<>();\\n        f(1, n, k, allCombinations, new ArrayList<>());\\n        return allCombinations;\\n    }\\n\\n    private void f(int i, int n, int k, List<List<Integer>> allCombinations, ArrayList<Integer> list){\\n        if (list.size() == k){\\n            allCombinations.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for (int j = i; j <= n; j++){\\n            list.add(j);\\n            f(j + 1, n, k, allCombinations, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846523,
                "title": "backtracking-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>> &ans,vector<int> &temp,int ind, int n, int k)\\n    {   \\n        if(k==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<=n-k+1;i++) \\n        {\\n            temp.push_back(i);\\n            backtrack(ans,temp,i+1,n,k-1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        backtrack(ans,temp,1,n,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>> &ans,vector<int> &temp,int ind, int n, int k)\\n    {   \\n        if(k==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<=n-k+1;i++) \\n        {\\n            temp.push_back(i);\\n            backtrack(ans,temp,i+1,n,k-1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        backtrack(ans,temp,1,n,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845814,
                "title": "c-recursion-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry all combinations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake every integer to form combinations and on returning remove them so we can form new combinations and do not repeat the numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int n,int k,vector<int>vec,vector<vector<int>>& ans){\\n        if(vec.size()==k)\\n            ans.push_back(vec);\\n\\n\\n        for(int j=i;j<=n;j++){\\n            vec.push_back(j);\\n            solve(j+1,n,k,vec,ans);\\n            vec.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> vec;\\n        int i=1;\\n        solve(i,n,k,vec,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int n,int k,vector<int>vec,vector<vector<int>>& ans){\\n        if(vec.size()==k)\\n            ans.push_back(vec);\\n\\n\\n        for(int j=i;j<=n;j++){\\n            vec.push_back(j);\\n            solve(j+1,n,k,vec,ans);\\n            vec.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> vec;\\n        int i=1;\\n        solve(i,n,k,vec,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845553,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/DcUkm8CPeaY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    public List<List<Integer>> combine(int n, int k) {\\n        ans = new ArrayList<>();\\n        helper(1,n,k,new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    public void helper(int start, int n, int k, List<Integer>sub){\\n        if(k==0) {\\n            ans.add(new ArrayList<>(sub));\\n            return;\\n        }\\n        for(int i = start;i<=n-k+1;i++){\\n            sub.add(i);\\n            helper(i+1,n,k-1, sub);\\n            sub.remove(sub.size()-1);\\n        }\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> combine(int n, int k) {\\n        ans.clear();\\n        vector<int> sub;\\n        helper(1, n, k, sub);\\n        return ans;\\n    }\\n\\n    void helper(int start, int n, int k, vector<int>& sub) {\\n        if (k == 0) {\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for (int i = start; i <= n - k + 1; i++) {\\n            sub.push_back(i);\\n            helper(i + 1, n, k - 1, sub);\\n            sub.pop_back();\\n        }\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans = []\\n        self.helper(1, n, k, [], ans)\\n        return ans\\n    \\n    def helper(self, start, n, k, sub, ans):\\n        if k == 0:\\n            ans.append(sub[:])\\n            return\\n        for i in range(start, n - k + 2):\\n            sub.append(i)\\n            self.helper(i + 1, n, k - 1, sub, ans)\\n            sub.pop()\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    public List<List<Integer>> combine(int n, int k) {\\n        ans = new ArrayList<>();\\n        helper(1,n,k,new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    public void helper(int start, int n, int k, List<Integer>sub){\\n        if(k==0) {\\n            ans.add(new ArrayList<>(sub));\\n            return;\\n        }\\n        for(int i = start;i<=n-k+1;i++){\\n            sub.add(i);\\n            helper(i+1,n,k-1, sub);\\n            sub.remove(sub.size()-1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> combine(int n, int k) {\\n        ans.clear();\\n        vector<int> sub;\\n        helper(1, n, k, sub);\\n        return ans;\\n    }\\n\\n    void helper(int start, int n, int k, vector<int>& sub) {\\n        if (k == 0) {\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for (int i = start; i <= n - k + 1; i++) {\\n            sub.push_back(i);\\n            helper(i + 1, n, k - 1, sub);\\n            sub.pop_back();\\n        }\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans = []\\n        self.helper(1, n, k, [], ans)\\n        return ans\\n    \\n    def helper(self, start, n, k, sub, ans):\\n        if k == 0:\\n            ans.append(sub[:])\\n            return\\n        for i in range(start, n - k + 2):\\n            sub.append(i)\\n            self.helper(i + 1, n, k - 1, sub, ans)\\n            sub.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818262,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRecursive Backtracking:\\n\\nThe function combine calls the recursive function solve to find all possible combinations of k numbers from the set [1, 2, ..., n].\\nThe solve function uses backtracking to generate all possible subsets of size k by making decisions to include or exclude elements from the set.\\nThe base case of the recursion is when the size of the subsets vector becomes equal to k. In this case, it means that k elements have been selected, and the current subsets vector is a valid combination. The subsets vector is added to the ans vector of combinations.\\nBacktracking Algorithm:\\n\\nThe function starts with an empty vector subsets.\\nFor each index i in the range [begin, end], it includes the element i in the current subsets vector and recursively calls solve with i+1 as the new begin index. This decision represents including the element i in the combination.\\nAfter the recursive call, the element i is removed (backtracked) from the subsets vector to explore other combinations.\\nMain Function:\\n\\nThe combine function initializes an empty vector subsets and starts the recursive process by calling solve with begin = 1 and end = n.\\nThe function solve generates all valid combinations of k elements from the set [1, 2, ..., n] and stores them in the ans vector.\\nOutput:\\n\\nThe combine function returns the 2D vector ans, which contains all possible combinations of k numbers from the set [1, 2, ..., n].\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n!/(-k)!k!)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n\\nvoid solve(int begin, int end, int k,vector<int>subsets)\\n{\\n    if(subsets.size()==k)\\n    {\\n       return ans.push_back(subsets);\\n    }\\n    for(int i = begin ; i<=end ; i++)\\n    {\\n        subsets.push_back(i);\\n        solve(i+1,end,k,subsets);\\n        subsets.pop_back();\\n    }\\n\\n}\\n    vector<vector<int>> combine(int n, int k) \\n    {\\n        vector<int>subsets;\\n        solve(1,n,k,subsets);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n\\nvoid solve(int begin, int end, int k,vector<int>subsets)\\n{\\n    if(subsets.size()==k)\\n    {\\n       return ans.push_back(subsets);\\n    }\\n    for(int i = begin ; i<=end ; i++)\\n    {\\n        subsets.push_back(i);\\n        solve(i+1,end,k,subsets);\\n        subsets.pop_back();\\n    }\\n\\n}\\n    vector<vector<int>> combine(int n, int k) \\n    {\\n        vector<int>subsets;\\n        solve(1,n,k,subsets);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559297,
                "title": "fast-quick-backtracking-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBACK TRACKING\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n!)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(vector<int> output,int i,int g,int j,int n){\\n        if(output.size()==g){\\n            ans.push_back(output);\\n            return;\\n        }\\n        for(int k=n+1;k<=i;k++){\\n            output.push_back(k);\\n            help(output,i,g,j+1,k);\\n            output.pop_back();\\n        }\\n\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>output;\\n        help(output,n,k,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(vector<int> output,int i,int g,int j,int n){\\n        if(output.size()==g){\\n            ans.push_back(output);\\n            return;\\n        }\\n        for(int k=n+1;k<=i;k++){\\n            output.push_back(k);\\n            help(output,i,g,j+1,k);\\n            output.pop_back();\\n        }\\n\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>output;\\n        help(output,n,k,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454065,
                "title": "two-similar-solutions-one-100-time-beats-second-100-space-beats-with-explanation",
                "content": "# Intuition\\nFirst I came up with the first solution, and then I tried to optimize it from space, so the second one happened. Everyone knows that on a leetcode after each submission, you can get different time and space complexity, so the first solution turned out to be 100% beats in time, and the second in space. Although the worst-case time complexity is the same, in general the first solution performs slightly better.\\n\\nI prefer to disassemble the code myself without reading the comments, so I understand better. Therefore, at the end you will find code both with and without comments.\\n\\n# Approach\\nThis code generates all possible combinations of k numbers from 1 to n inclusive using **recursion** and **backtracking**.\\n\\n\\nThe combine function first initializes an empty List of Lists called result. If k is equal to 1, it directly adds a List containing integers from 1 to n in result. Otherwise, it calls the addNumber function for each number i from 1 to n. \\n\\n\\nThe addNumber function performs a recursive backtracking algorithm. First, it checks whether the difference between n and the last element of the current List is less than the difference between k and the length of the current List. This is to avoid adding more numbers than needed to create valid combinations. \\n\\n\\nIf the condition passes, it loops through numbers from the next element of the last number in current to n. For each i, it creates a new List containing a copy of current and appends i to the copy. If this new List has a length of k, it directly adds it to matrix. Otherwise, it recursively calls addNumber with the new List, and the function continues to loop through the remaining numbers. \\n\\n\\nEventually, when all possible combinations have been generated, the result List is returned containing all the valid combinations.\\n\\n# Complexity\\n- Time complexity O(n choose k):\\nBoth solutions have a time complexity of O(n choose k), which is the number of possible combinations. The first solution generates all possible combinations by iterating through all n numbers and then recursively adding numbers to the current combination until it reaches k length. This results in a time complexity of O(n choose k). The second solution uses backtracking to traverse through all possible combinations by adding each number to the current combination and then recursively calling the function for the remaining numbers. This also has a time complexity of O(n choose k).\\n- Space complexity for the **first** solution O(n choose k)\\n- Space complexity for the **second** solution O(n)\\nFor space complexity, the first solution uses additional space for the result List and for the current combination List in the addNumber function. This results in a space complexity of O(n choose k). The second solution only uses additional space for the result List and the current combination List (which is modified in place), resulting in a space complexity of O(k).\\n\\n# Code\\n# - First approach with comments\\n```\\nclass Solution {\\n\\n  // Function takes in n and k as parameters and returns the result List\\n  List<List<int>> combine(int n, int k) {\\n    List<List<int>> result = []; // initialize an empty result List\\n    if (k == 1){ // if k is 1, add all numbers from 1 to n to the result List as single-item Lists\\n      for (var i = 1; i <= n; i++) {\\n        result.add([i]);\\n      }\\n      return result;\\n    }\\n    for (var i = 1; i <= n; i++) { // iterate from 1 to n, and call the addNumber function for each number\\n      addNumber(n, k, [i], result);\\n    }\\n    return result; // return the result List\\n  }\\n\\n  // Function takes in n, k, current combination, and result matrix as parameters\\n  void addNumber(int n, int k, List<int> current, List<List<int>> matrix){\\n    if (n - current.last < k - current.length) { // if there aren\\'t enough numbers left to fill k-length combinations, return\\n      return;\\n    }\\n    for (var i = current.last + 1; i <= n; i++) { // iterate from the next number after the last in the current combination, to n\\n      List<int> number = [...current]; // create a new List with the current numbers\\n      number.add(i); // add the current number to the new List\\n      if (number.length == k){ // if the new List has reached k length, add it to the result matrix\\n        matrix.add(number);\\n        continue;\\n      }else{ // otherwise, call the addNumber function recursively with the new List as the current combination\\n        addNumber(n, k, number, matrix);\\n      }\\n    }\\n  }\\n}\\n\\n```\\n# - Second approach with comments\\n```\\n// Define the Solution class\\nclass Solution {\\n\\n  // Define the combine function which takes in n and k as parameters and returns the result List\\n  List<List<int>> combine(int n, int k) {\\n    \\n    // Initialize an empty result List\\n    List<List<int>> result = [];\\n\\n    // Initialize an empty current List\\n    List<int> current = [];\\n\\n    // Call the addNumber function with the given parameters\\n    addNumber(n, k, 1, current, result);\\n\\n    // Return the result List\\n    return result;\\n  }\\n\\n  // Define the addNumber function which takes in n, k, start, current and matrix as parameters\\n  void addNumber(int n, int k, int start, List<int> current, List<List<int>> matrix){\\n    \\n    // If the current List has a length equal to k, add it to the result List and return\\n    if (current.length == k) {\\n      matrix.add([...current]);\\n      return;\\n    }\\n\\n    // Loop through the numbers from start to n\\n    for (var i = start; i <= n; i++) {\\n      \\n      // Add the current number to the current List\\n      current.add(i);\\n\\n      // Recursively call the addNumber function with the next number as the start parameter\\n      addNumber(n, k, i + 1, current, matrix);\\n\\n      // Remove the last number from the current List\\n      current.removeLast();\\n    }\\n  }\\n}\\n```\\n# - First approach withount comments\\n```\\nclass Solution {\\n  List<List<int>> combine(int n, int k) {\\n    List<List<int>> result = [];\\n    if (k == 1){\\n      for (var i = 1; i <= n; i++) {\\n        result.add([i]);\\n      }\\n      return result;\\n    }\\n    for (var i = 1; i <= n; i++) {\\n      addNumber(n, k, [i], result);\\n    }\\n\\n    return result;\\n  }\\n\\n  void addNumber(int n, int k, List<int> current, List<List<int>> matrix){\\n    if (n - current.last < k - current.length) {\\n      return;\\n    }\\n    for (var i = current.last + 1; i <= n; i++) {\\n      List<int> number = [...current];\\n      number.add(i);\\n      if (number.length == k){\\n        matrix.add(number);\\n        continue;\\n      }else{\\n        addNumber(n, k, number, matrix);\\n      }\\n    }\\n  }\\n}\\n```\\n# - Second approach withount comments\\n```\\nclass Solution {\\n  List<List<int>> combine(int n, int k) {\\n    List<List<int>> result = [];\\n    List<int> current = [];\\n\\n    addNumber(n, k, 1, current, result);\\n\\n    return result;\\n  }\\n\\n  void addNumber(int n, int k, int start, List<int> current, List<List<int>> matrix){\\n    if (current.length == k) {\\n      matrix.add([...current]);\\n      return;\\n    }\\n    for (var i = start; i <= n; i++) {\\n      current.add(i);\\n      addNumber(n, k, i + 1, current, matrix);\\n      current.removeLast();\\n    }\\n  }\\n}\\n```\\nIf you liked this solution, then do not forget to rate it please \\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "Dart",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n  // Function takes in n and k as parameters and returns the result List\\n  List<List<int>> combine(int n, int k) {\\n    List<List<int>> result = []; // initialize an empty result List\\n    if (k == 1){ // if k is 1, add all numbers from 1 to n to the result List as single-item Lists\\n      for (var i = 1; i <= n; i++) {\\n        result.add([i]);\\n      }\\n      return result;\\n    }\\n    for (var i = 1; i <= n; i++) { // iterate from 1 to n, and call the addNumber function for each number\\n      addNumber(n, k, [i], result);\\n    }\\n    return result; // return the result List\\n  }\\n\\n  // Function takes in n, k, current combination, and result matrix as parameters\\n  void addNumber(int n, int k, List<int> current, List<List<int>> matrix){\\n    if (n - current.last < k - current.length) { // if there aren\\'t enough numbers left to fill k-length combinations, return\\n      return;\\n    }\\n    for (var i = current.last + 1; i <= n; i++) { // iterate from the next number after the last in the current combination, to n\\n      List<int> number = [...current]; // create a new List with the current numbers\\n      number.add(i); // add the current number to the new List\\n      if (number.length == k){ // if the new List has reached k length, add it to the result matrix\\n        matrix.add(number);\\n        continue;\\n      }else{ // otherwise, call the addNumber function recursively with the new List as the current combination\\n        addNumber(n, k, number, matrix);\\n      }\\n    }\\n  }\\n}\\n\\n```\n```\\n// Define the Solution class\\nclass Solution {\\n\\n  // Define the combine function which takes in n and k as parameters and returns the result List\\n  List<List<int>> combine(int n, int k) {\\n    \\n    // Initialize an empty result List\\n    List<List<int>> result = [];\\n\\n    // Initialize an empty current List\\n    List<int> current = [];\\n\\n    // Call the addNumber function with the given parameters\\n    addNumber(n, k, 1, current, result);\\n\\n    // Return the result List\\n    return result;\\n  }\\n\\n  // Define the addNumber function which takes in n, k, start, current and matrix as parameters\\n  void addNumber(int n, int k, int start, List<int> current, List<List<int>> matrix){\\n    \\n    // If the current List has a length equal to k, add it to the result List and return\\n    if (current.length == k) {\\n      matrix.add([...current]);\\n      return;\\n    }\\n\\n    // Loop through the numbers from start to n\\n    for (var i = start; i <= n; i++) {\\n      \\n      // Add the current number to the current List\\n      current.add(i);\\n\\n      // Recursively call the addNumber function with the next number as the start parameter\\n      addNumber(n, k, i + 1, current, matrix);\\n\\n      // Remove the last number from the current List\\n      current.removeLast();\\n    }\\n  }\\n}\\n```\n```\\nclass Solution {\\n  List<List<int>> combine(int n, int k) {\\n    List<List<int>> result = [];\\n    if (k == 1){\\n      for (var i = 1; i <= n; i++) {\\n        result.add([i]);\\n      }\\n      return result;\\n    }\\n    for (var i = 1; i <= n; i++) {\\n      addNumber(n, k, [i], result);\\n    }\\n\\n    return result;\\n  }\\n\\n  void addNumber(int n, int k, List<int> current, List<List<int>> matrix){\\n    if (n - current.last < k - current.length) {\\n      return;\\n    }\\n    for (var i = current.last + 1; i <= n; i++) {\\n      List<int> number = [...current];\\n      number.add(i);\\n      if (number.length == k){\\n        matrix.add(number);\\n        continue;\\n      }else{\\n        addNumber(n, k, number, matrix);\\n      }\\n    }\\n  }\\n}\\n```\n```\\nclass Solution {\\n  List<List<int>> combine(int n, int k) {\\n    List<List<int>> result = [];\\n    List<int> current = [];\\n\\n    addNumber(n, k, 1, current, result);\\n\\n    return result;\\n  }\\n\\n  void addNumber(int n, int k, int start, List<int> current, List<List<int>> matrix){\\n    if (current.length == k) {\\n      matrix.add([...current]);\\n      return;\\n    }\\n    for (var i = start; i <= n; i++) {\\n      current.add(i);\\n      addNumber(n, k, i + 1, current, matrix);\\n      current.removeLast();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183292,
                "title": "77-combinations-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses the backtracking algorithm to generate all the combinations of k numbers from the range [1, n]. The function backtrack starts with a starting point first and an empty list curr which will store the current combination being generated. If the length of curr is equal to k, it means that a combination has been generated and it is appended to the result list res. If not, the function continues to generate combinations by adding integers from first to n to curr and recursively calling backtrack with updated values of first and curr. Before making the recursive call, the function pops the last element from curr to prepare for the next iteration.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def backtrack(first = 1, curr = []):\\n            if len(curr) == k:\\n                res.append(curr[:])\\n                return\\n            for i in range(first, n+1):\\n                curr.append(i)\\n                backtrack(i+1, curr)\\n                curr.pop()\\n        res = []\\n        backtrack()\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def backtrack(first = 1, curr = []):\\n            if len(curr) == k:\\n                res.append(curr[:])\\n                return\\n            for i in range(first, n+1):\\n                curr.append(i)\\n                backtrack(i+1, curr)\\n                curr.pop()\\n        res = []\\n        backtrack()\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818566,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function (n, k) {\\n    let output = [];\\n\\n    const findCombinations = (start, combination) => {\\n        if (combination.length === k) {\\n            output.push([...combination]);\\n            return;\\n        }\\n\\n        if (combination.length > k) return;\\n\\n        for (let i = start; i <= n; i++) {\\n            combination.push(i);\\n            findCombinations(i + 1, combination);\\n            combination.pop();\\n        }\\n    }\\n\\n    findCombinations(1, []);\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar combine = function (n, k) {\\n    let output = [];\\n\\n    const findCombinations = (start, combination) => {\\n        if (combination.length === k) {\\n            output.push([...combination]);\\n            return;\\n        }\\n\\n        if (combination.length > k) return;\\n\\n        for (let i = start; i <= n; i++) {\\n            combination.push(i);\\n            findCombinations(i + 1, combination);\\n            combination.pop();\\n        }\\n    }\\n\\n    findCombinations(1, []);\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774014,
                "title": "combinations-java-solution-2-simple-recursive-approaches",
                "content": "```\\n1. First Approach\\nStep1. get all subset\\nStep2. insert in final ans having subset size k\\n//Example :- n = 3 & k = 2 i.e. [1,2,3]\\nStep1. subset = [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]\\nStep2. subset having size, k i.e. [1,2],[1,3],[2,3]\\n```\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        //Step1\\n\\t\\thelper(1,n,ans,subset);\\n        \\n\\t\\t//step2\\n        List<List<Integer>> finalAns = new ArrayList<>();\\n        for(List<Integer> list : ans){\\n            if(list.size()==k)\\n                finalAns.add(list);\\n        }\\n        return finalAns;\\n    }\\n     public void helper(int start, int n, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n\\t//BASE CASE\\n        if(start>=n+1){\\n            ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(start);\\n        helper(start+1 ,n,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(start+1,n,ans,subset);\\n    }\\n\\tT.C :- 2^n(for generating all subsets) * 2^n(looping to get k size subset from 2^n subsets )\\n}\\n```\\n```\\n2. Second Approach :- removing extra 2^n for looping to get k size subset from 2^n subsets\\nby maintaining size in each recursive call and when size become equal to k we store our that subset\\n```\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(1,n,0,k,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start, int n, int size,int k,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(start>n){\\n            if(size==k){\\n                ans.add(new ArrayList(subset));\\n            }\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(start);\\n        helper(start+1,n,size+1,k,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(start+1,n,size,k,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. First Approach\\nStep1. get all subset\\nStep2. insert in final ans having subset size k\\n//Example :- n = 3 & k = 2 i.e. [1,2,3]\\nStep1. subset = [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]\\nStep2. subset having size, k i.e. [1,2],[1,3],[2,3]\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        //Step1\\n\\t\\thelper(1,n,ans,subset);\\n        \\n\\t\\t//step2\\n        List<List<Integer>> finalAns = new ArrayList<>();\\n        for(List<Integer> list : ans){\\n            if(list.size()==k)\\n                finalAns.add(list);\\n        }\\n        return finalAns;\\n    }\\n     public void helper(int start, int n, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n\\t//BASE CASE\\n        if(start>=n+1){\\n            ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(start);\\n        helper(start+1 ,n,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(start+1,n,ans,subset);\\n    }\\n\\tT.C :- 2^n(for generating all subsets) * 2^n(looping to get k size subset from 2^n subsets )\\n}\\n```\n```\\n2. Second Approach :- removing extra 2^n for looping to get k size subset from 2^n subsets\\nby maintaining size in each recursive call and when size become equal to k we store our that subset\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(1,n,0,k,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start, int n, int size,int k,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(start>n){\\n            if(size==k){\\n                ans.add(new ArrayList(subset));\\n            }\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(start);\\n        helper(start+1,n,size+1,k,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(start+1,n,size,k,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529218,
                "title": "java-solution-using-backtracking-easy-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> combine(int n, int k) {\\n        int[] nums = new int[n];\\n        for(int i = 0 ; i < n ; i ++){\\n            nums[i] = i + 1;\\n        }\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        permute(nums,0,k,al);\\n        return ans;\\n    }\\n    public void permute(int[] nums,int index,int k,ArrayList<Integer> curr){\\n        if(curr.size() == k){\\n            ans.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        for(int i = index ; i < nums.length; i ++){\\n            curr.add(nums[i]);\\n            permute(nums,i+1,k,curr);\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> combine(int n, int k) {\\n        int[] nums = new int[n];\\n        for(int i = 0 ; i < n ; i ++){\\n            nums[i] = i + 1;\\n        }\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        permute(nums,0,k,al);\\n        return ans;\\n    }\\n    public void permute(int[] nums,int index,int k,ArrayList<Integer> curr){\\n        if(curr.size() == k){\\n            ans.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        for(int i = index ; i < nums.length; i ++){\\n            curr.add(nums[i]);\\n            permute(nums,i+1,k,curr);\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879724,
                "title": "c-standard-backtracking-template-easy-understanding",
                "content": "```\\npublic class Solution {\\n    private int n;\\n    private IList<IList<int>> result = new List<IList<int>>();\\n    public IList<IList<int>> Combine(int n, int k) {\\n        this.n = n;\\n        IList<int> combination = new List<int>();\\n        this.backtrack(combination, 1, k);\\n        return result;\\n    }\\n    \\n    private void backtrack(IList<int> values, int start, int size){\\n        if(values.Count == size){\\n            result.Add(new List<int>(values));\\n        }\\n        \\n        for(int i = start; i < n + 1; i++){\\n            values.Add(i);\\n            this.backtrack(values, i+1, size);\\n            values.RemoveAt(values.Count - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    private int n;\\n    private IList<IList<int>> result = new List<IList<int>>();\\n    public IList<IList<int>> Combine(int n, int k) {\\n        this.n = n;\\n        IList<int> combination = new List<int>();\\n        this.backtrack(combination, 1, k);\\n        return result;\\n    }\\n    \\n    private void backtrack(IList<int> values, int start, int size){\\n        if(values.Count == size){\\n            result.Add(new List<int>(values));\\n        }\\n        \\n        for(int i = start; i < n + 1; i++){\\n            values.Add(i);\\n            this.backtrack(values, i+1, size);\\n            values.RemoveAt(values.Count - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756787,
                "title": "combinations-java-backtracking-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        //final linked list\\n        List<List<Integer>> result = new LinkedList();\\n        \\n        //This will store each combination, which will then be added to the final linked list \\n        LinkedList<Integer> comb = new LinkedList();\\n        \\n        comboGenerator(1, n, k, result, comb);\\n        return result;\\n    }\\n    \\n    //recursive method\\n    public void comboGenerator(int start, int n, int k, List<List<Integer>> result, LinkedList<Integer> combo){\\n        \\n        //each combination can be of size k or less\\n        if(combo.size() == k) result.add(new LinkedList(combo));\\n        \\n        //iterate through all \\'n\\' numbers, generating each combo.\\n        //After a combo has been added to the final \\'result\\', \\n        //then remove the last element of the combo to continue generating even more combinations\\n        for(int i=start; i<=n && combo.size()<k; i++){\\n           combo.add(i);\\n           comboGenerator(i+1, n, k, result, combo);\\n           combo.removeLast();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        //final linked list\\n        List<List<Integer>> result = new LinkedList();\\n        \\n        //This will store each combination, which will then be added to the final linked list \\n        LinkedList<Integer> comb = new LinkedList();\\n        \\n        comboGenerator(1, n, k, result, comb);\\n        return result;\\n    }\\n    \\n    //recursive method\\n    public void comboGenerator(int start, int n, int k, List<List<Integer>> result, LinkedList<Integer> combo){\\n        \\n        //each combination can be of size k or less\\n        if(combo.size() == k) result.add(new LinkedList(combo));\\n        \\n        //iterate through all \\'n\\' numbers, generating each combo.\\n        //After a combo has been added to the final \\'result\\', \\n        //then remove the last element of the combo to continue generating even more combinations\\n        for(int i=start; i<=n && combo.size()<k; i++){\\n           combo.add(i);\\n           comboGenerator(i+1, n, k, result, combo);\\n           combo.removeLast();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729350,
                "title": "short-recursive-python-solution-without-backtracking",
                "content": "## Approach: recursion\\n---\\n##### Time complexity: O(k * [n choose k])\\n##### Space complexity: O(n choose k)\\nThis solution is fairly standard and the same pattern can be applied to other combinations and permutations problems. The basic intuition is to try all possible choices for the first number, try all possible remaining choices for the second number, and so on until we have no more remaining slots/spots to pick from. During all this, we\\'re building up our combination and at that point we append it to our result. Note how we\\'re passing `num + 1` as the `start` index in the recursive calls; this is so that we don\\'t double count a combination and that we don\\'t include the same number twice, e.g. `[1,3]` is the same as `[3,1]` and `[2,2]` is not valid.\\n\\n```python\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans = []\\n\\n        def helper(combination, start, remaining_slots):\\n            if remaining_slots == 0:\\n                ans.append(combination)\\n            else:\\n                for num in range(start, n + 1):\\n                    helper(combination + [num], num + 1, remaining_slots - 1)\\n\\n        helper([], 1, k):\\n\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans = []\\n\\n        def helper(combination, start, remaining_slots):\\n            if remaining_slots == 0:\\n                ans.append(combination)\\n            else:\\n                for num in range(start, n + 1):\\n                    helper(combination + [num], num + 1, remaining_slots - 1)\\n\\n        helper([], 1, k):\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623773,
                "title": "python-solution-2-ways",
                "content": "\\tclass Solution:\\n\\t\\tdef combine(self, n: int, k: int) -> List[List[int]]:\\n\\t\\t\\tres = []\\n\\t\\t\\tstack = [(1, [])]\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tlevel, comb = stack.pop()\\n\\t\\t\\t\\tif len(comb) == k: \\n\\t\\t\\t\\t\\tres.append(comb)\\n\\n\\t\\t\\t\\tfor i in range(level, n+1):\\n\\t\\t\\t\\t\\tstack.append((i + 1, comb + [i]))\\n\\t\\t\\treturn res\\n\\t\\t\\t\\nrecursive\\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef combine(self, n: int, k: int) -> List[List[int]]:\\n\\t\\t\\tres = []\\n\\n\\t\\t\\tdef helper(level, comb):\\n\\t\\t\\t\\tif len(comb) == k:\\n\\t\\t\\t\\t\\tres.append(comb[:])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfor i in range(level, n + 1):\\n\\t\\t\\t\\t\\t\\tcomb.append(i)\\n\\t\\t\\t\\t\\t\\thelper(i + 1, comb)\\n\\t\\t\\t\\t\\t\\tcomb.pop()\\n\\t\\t\\thelper(1, [])        \\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef combine(self, n: int, k: int) -> List[List[int]]:\\n\\t\\t\\tres = []\\n\\t\\t\\tstack = [(1, [])]\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tlevel, comb = stack.pop()\\n\\t\\t\\t\\tif len(comb) == k: \\n\\t\\t\\t\\t\\tres.append(comb)\\n\\n\\t\\t\\t\\tfor i in range(level, n+1):\\n\\t\\t\\t\\t\\tstack.append((i + 1, comb + [i]))\\n\\t\\t\\treturn res\\n\\t\\t\\t\\nrecursive\\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef combine(self, n: int, k: int) -> List[List[int]]:\\n\\t\\t\\tres = []\\n\\n\\t\\t\\tdef helper(level, comb):\\n\\t\\t\\t\\tif len(comb) == k:\\n\\t\\t\\t\\t\\tres.append(comb[:])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfor i in range(level, n + 1):\\n\\t\\t\\t\\t\\t\\tcomb.append(i)\\n\\t\\t\\t\\t\\t\\thelper(i + 1, comb)\\n\\t\\t\\t\\t\\t\\tcomb.pop()\\n\\t\\t\\thelper(1, [])        \\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1560732,
                "title": "amazing-approach-of-backtrack-in-c-backtrack",
                "content": "class Solution {\\npublic:\\n    \\n    void backtrack(int num,int k,vector<vector<int>> &ans,vector<int> &curr,int n){\\n        curr.push_back(num);\\n        if(curr.size()==k){\\n            ans.push_back(curr);\\n            curr.pop_back();\\n            return;\\n        }\\n        for(int j=num+1;j<=n;j++){\\n            backtrack(j,k,ans,curr,n);\\n        }\\n        curr.pop_back();\\n    } \\n        \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        for(int i=1;i<=n;i++){\\n            backtrack(i,k,ans,curr,n);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void backtrack(int num,int k,vector<vector<int>> &ans,vector<int> &curr,int n){\\n        curr.push_back(num);\\n        if(curr.size()==k){\\n            ans.push_back(curr);\\n            curr.pop_back();\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1484026,
                "title": "c-backtracking",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> vec;\\n    void comb(int n,int k,int idx)\\n    {\\n        if(k==0)\\n        {\\n            ans.push_back(vec);\\n            return;\\n        }\\n        for(int i = idx;i<=n;i++)\\n        {\\n            vec.push_back(i);\\n            comb(n,k-1,i+1);\\n            vec.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combine(int n, int k) \\n    {\\n        comb(n,k,1);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> vec;\\n    void comb(int n,int k,int idx)\\n    {\\n        if(k==0)\\n        {\\n            ans.push_back(vec);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1023998,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 748696,
                "title": "python-dfs",
                "content": "**Python DFS**\\n\\n```\\nclass Solution:\\n    def combine(self, n, k):\\n        res = []\\n        def dfs(A):\\n            if len(A)==k:\\n                return res.append(list(A))\\n            x = A[-1]+1 if A else 1\\n            for i in range(x,n+1):\\n                A.append(i)\\n                dfs(A)\\n                A.pop()\\n        dfs([])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combine(self, n, k):\\n        res = []\\n        def dfs(A):\\n            if len(A)==k:\\n                return res.append(list(A))\\n            x = A[-1]+1 if A else 1\\n            for i in range(x,n+1):\\n                A.append(i)\\n                dfs(A)\\n                A.pop()\\n        dfs([])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638126,
                "title": "golang-backtracking",
                "content": "```Go\\nfunc combine(n int, k int) [][]int {\\n    results := [][]int{}\\n    if k > n {\\n        return results\\n    }\\n    \\n    dfs([]int{}, n, k, 1, &results)\\n    return results\\n}\\n\\nfunc dfs(buf []int, n, k, idx int, results *[][]int) {\\n    if k == 0 {\\n        tmp := make([]int, len(buf))\\n        copy(tmp, buf)\\n        *results = append(*results, tmp)\\n    }\\n    \\n    for i := idx; i <= n; i++ {\\n        buf = append(buf, i)\\n        \\n        dfs(buf, n, k-1, i+1, results)\\n        \\n        buf = buf[:len(buf)-1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```Go\\nfunc combine(n int, k int) [][]int {\\n    results := [][]int{}\\n    if k > n {\\n        return results\\n    }\\n    \\n    dfs([]int{}, n, k, 1, &results)\\n    return results\\n}\\n\\nfunc dfs(buf []int, n, k, idx int, results *[][]int) {\\n    if k == 0 {\\n        tmp := make([]int, len(buf))\\n        copy(tmp, buf)\\n        *results = append(*results, tmp)\\n    }\\n    \\n    for i := idx; i <= n; i++ {\\n        buf = append(buf, i)\\n        \\n        dfs(buf, n, k-1, i+1, results)\\n        \\n        buf = buf[:len(buf)-1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 608221,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\n\\tvoid dfs(vector<int>nums, int k, int l, vector<int>& v, vector<vector<int>>& ans) {\\n\\t\\tif (k == 0) {\\n\\t\\t\\tans.push_back(v);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = l; i < nums.size(); i++) {\\n\\t\\t\\tv.push_back(nums[i]);\\n\\t\\t\\tdfs(nums, k-1, i+1, v, ans);\\n\\t\\t\\tv.pop_back();\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        \\n        vector<vector<int>> ans;\\n\\t\\tvector<int>v;\\n\\t\\tvector<int>nums;\\n\\t\\t\\n        for (int i = 1; i <= n; i++)\\n\\t\\t\\tnums.push_back(i);\\n\\t\\t\\t\\n\\t\\tdfs(nums, k, 0, v, ans);\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tvoid dfs(vector<int>nums, int k, int l, vector<int>& v, vector<vector<int>>& ans) {\\n\\t\\tif (k == 0) {\\n\\t\\t\\tans.push_back(v);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = l; i < nums.size(); i++) {\\n\\t\\t\\tv.push_back(nums[i]);\\n\\t\\t\\tdfs(nums, k-1, i+1, v, ans);\\n\\t\\t\\tv.pop_back();\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        \\n        vector<vector<int>> ans;\\n\\t\\tvector<int>v;\\n\\t\\tvector<int>nums;\\n\\t\\t\\n        for (int i = 1; i <= n; i++)\\n\\t\\t\\tnums.push_back(i);\\n\\t\\t\\t\\n\\t\\tdfs(nums, k, 0, v, ans);\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538179,
                "title": "how-itertools-combinations-works",
                "content": "There are a few Python solutions posted that make use of the `combinations` function from the `itertools` module. I think it\\'s interesting to look at how this function is implemented, because it\\'s a bit different from some of the other solutions posted in that it doesn\\'t use recursion or a stack. We can do this because they provide the implementation code in the [documentation](https://docs.python.org/3.8/library/itertools.html#itertools.combinations), which I\\'ve reproduced here:\\n\\n```python\\ndef combinations(iterable, r):\\n    # combinations(\\'ABCD\\', 2) --> AB AC AD BC BD CD\\n    # combinations(range(4), 3) --> 012 013 023 123\\n    pool = tuple(iterable)\\n    n = len(pool)\\n    if r > n:\\n        return\\n    indices = list(range(r))\\n    yield tuple(pool[i] for i in indices)\\n    while True:\\n        for i in reversed(range(r)):\\n            if indices[i] != i + n - r:\\n                break\\n        else:\\n            return\\n        indices[i] += 1\\n        for j in range(i+1, r):\\n            indices[j] = indices[j-1] + 1\\n        yield tuple(pool[i] for i in indices)\\n```\\n\\n(The itertools module is in fact implemented in C, for perfomance reasons, but this is the equivalent python code.)\\n\\nEssentially, after storing the given values into the tuple `pool`, they keep a table of `r` indices, initially pointing to the first `r` elements of `pool`. Then, inside the loop, they find the last index that can be incremented, increment that index, and then shift all the subsequent indices as far to the left as they can go. Here is how this looks for the input `iterable = \\'ABCDE\\', r = 3`:\\n\\n```text\\nA B C D E     (pool)\\n^ ^ ^\\n0 1 2         (indices)\\n\\nA B C D E\\n^ ^   ^\\n0 1   3\\n\\nA B C D E\\n^ ^     ^\\n0 1     4\\n\\nA B C D E\\n^   ^ ^\\n0   2 3\\n\\nA B C D E\\n^   ^   ^\\n0   2   4\\n\\nA B C D E\\n^     ^ ^\\n0     3 4\\n\\nA B C D E\\n  ^ ^ ^\\n  1 2 3\\n  \\nA B C D E\\n  ^ ^   ^\\n  1 2   4\\n  \\nA B C D E\\n  ^   ^ ^\\n  1   3 4\\n  \\nA B C D E\\n    ^ ^ ^\\n    2 3 4\\n```\\n\\nThis code can be molded into a solution for the problem, which it turns out is about as fast as if you make a call to `itertools.combinations`:\\n\\n```python\\nclass Solution:\\n    \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        indices = list(range(k))\\n        result  = []\\n        \\n        while True:\\n            result.append([i+1 for i in indices])\\n            \\n\\t\\t\\t# Find the last index that can be incremented:\\n            for i in reversed(range(k)):\\n                if indices[i] != i + n - k:\\n                    break\\n            else: # If no index can be incremented, we\\'ve seen the final combination:\\n                return result\\n            \\n\\t\\t\\t# Increment that index and push all subsequent indices to the left:\\n            indices[i] += 1\\n            for j in range(i+1, k):\\n                indices[j] = indices[j-1] + 1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef combinations(iterable, r):\\n    # combinations(\\'ABCD\\', 2) --> AB AC AD BC BD CD\\n    # combinations(range(4), 3) --> 012 013 023 123\\n    pool = tuple(iterable)\\n    n = len(pool)\\n    if r > n:\\n        return\\n    indices = list(range(r))\\n    yield tuple(pool[i] for i in indices)\\n    while True:\\n        for i in reversed(range(r)):\\n            if indices[i] != i + n - r:\\n                break\\n        else:\\n            return\\n        indices[i] += 1\\n        for j in range(i+1, r):\\n            indices[j] = indices[j-1] + 1\\n        yield tuple(pool[i] for i in indices)\\n```\n```text\\nA B C D E     (pool)\\n^ ^ ^\\n0 1 2         (indices)\\n\\nA B C D E\\n^ ^   ^\\n0 1   3\\n\\nA B C D E\\n^ ^     ^\\n0 1     4\\n\\nA B C D E\\n^   ^ ^\\n0   2 3\\n\\nA B C D E\\n^   ^   ^\\n0   2   4\\n\\nA B C D E\\n^     ^ ^\\n0     3 4\\n\\nA B C D E\\n  ^ ^ ^\\n  1 2 3\\n  \\nA B C D E\\n  ^ ^   ^\\n  1 2   4\\n  \\nA B C D E\\n  ^   ^ ^\\n  1   3 4\\n  \\nA B C D E\\n    ^ ^ ^\\n    2 3 4\\n```\n```python\\nclass Solution:\\n    \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        \\n        indices = list(range(k))\\n        result  = []\\n        \\n        while True:\\n            result.append([i+1 for i in indices])\\n            \\n\\t\\t\\t# Find the last index that can be incremented:\\n            for i in reversed(range(k)):\\n                if indices[i] != i + n - k:\\n                    break\\n            else: # If no index can be incremented, we\\'ve seen the final combination:\\n                return result\\n            \\n\\t\\t\\t# Increment that index and push all subsequent indices to the left:\\n            indices[i] += 1\\n            for j in range(i+1, k):\\n                indices[j] = indices[j-1] + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458537,
                "title": "c-concise-recursion-solution",
                "content": "\\tclass Solution {\\n\\t\\tprivate:\\n\\t\\tvector<vector<int>> res;\\n\\tpublic:\\n\\t\\tvoid dfs(int k, int n, int idx, vector<int> path){\\n\\t\\t\\tif(k==0){\\n\\t\\t\\t\\tres.push_back(path);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfor(int i=idx+1;i<=n;i++){\\n\\t\\t\\t\\t\\tpath.push_back(i);\\n\\t\\t\\t\\t\\tdfs(k-1,n,i,path);\\n\\t\\t\\t\\t\\tpath.pop_back();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> combine(int n, int k) {\\n\\t\\t\\tvector<int> path;\\n\\t\\t\\tdfs(k,n,0,path);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tprivate:\\n\\t\\tvector<vector<int>> res;\\n\\tpublic:\\n\\t\\tvoid dfs(int k, int n, int idx, vector<int> path){\\n\\t\\t\\tif(k==0){\\n\\t\\t\\t\\tres.push_back(path);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 365328,
                "title": "python-backtracking-86",
                "content": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        if n == k: return [[i for i in range(1, n + 1)]]\\n        elif n < k or k <= 0: return [[]]\\n        exclude_n = self.combine(n - 1, k)\\n        combs_incl = self.combine(n - 1, k - 1)\\n        include_n = [lst + [n] for lst in combs_incl]\\n        return exclude_n + include_n\\n  ```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        if n == k: return [[i for i in range(1, n + 1)]]\\n        elif n < k or k <= 0: return [[]]\\n        exclude_n = self.combine(n - 1, k)\\n        combs_incl = self.combine(n - 1, k - 1)\\n        include_n = [lst + [n] for lst in combs_incl]\\n        return exclude_n + include_n\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 315260,
                "title": "c-iterative-solution-text-book",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aData(k, 0);\\n        \\n        int i = 0;\\n        \\n        while (aData[0] <= (n - k + 1)) {\\n            \\n            aData[i]++;\\n            if (aData[i] > n) {\\n                i -= 1;\\n            } else if (i == (k - 1)) {\\n                aResult.push_back(aData);\\n            } else {\\n                i += 1;\\n                aData[i] = aData[i - 1];\\n            }\\n        }\\n        \\n        return aResult;\\n        \\n    }\\n};\\n```\\n\\nThe time complexity is Definitely Upper Bound by O(N!)\\nThe time complexity seems Upper Bound by O(N! / K!)\\n\\nThe exact time complexity is ???\\n\\n[[This Goes faster than recursive solution in most cases, so the actual running speed might be best here...]]\\n\\nMy tests have yielded mixed results.\\n\\nThe time complexity is definitely slower than O( choose(n, k) )\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aData(k, 0);\\n        \\n        int i = 0;\\n        \\n        while (aData[0] <= (n - k + 1)) {\\n            \\n            aData[i]++;\\n            if (aData[i] > n) {\\n                i -= 1;\\n            } else if (i == (k - 1)) {\\n                aResult.push_back(aData);\\n            } else {\\n                i += 1;\\n                aData[i] = aData[i - 1];\\n            }\\n        }\\n        \\n        return aResult;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283354,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> Combine(int n, int k) {\\n        var result = new List<IList<int>>();\\n\\n        DFS(1, n, k, new List<int>(), result);\\n\\n        return result;\\n    }\\n\\n    private void DFS(int start, int n, int k, IList<int> oneResult, IList<IList<int>> result) {\\n        if (k == 0) {\\n            result.Add(new List<int>(oneResult));\\n        } else {\\n            for (int i = start; i <= n; i++) {\\n                oneResult.Add(i);\\n                DFS(i + 1, n, k - 1, oneResult, result);\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Combine(int n, int k) {\\n        var result = new List<IList<int>>();\\n\\n        DFS(1, n, k, new List<int>(), result);\\n\\n        return result;\\n    }\\n\\n    private void DFS(int start, int n, int k, IList<int> oneResult, IList<IList<int>> result) {\\n        if (k == 0) {\\n            result.Add(new List<int>(oneResult));\\n        } else {\\n            for (int i = start; i <= n; i++) {\\n                oneResult.Add(i);\\n                DFS(i + 1, n, k - 1, oneResult, result);\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214483,
                "title": "rust-solution",
                "content": "```Rust\\nimpl Solution {\\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\\n        if k == 0 {\\n            return vec![vec![]];\\n        }\\n        let mut rtn = vec![];\\n        for i in k..=n {\\n            for mut pre in Self::combine(i-1, k-1) {\\n                pre.push(i);\\n                rtn.push(pre);\\n            }\\n        }\\n        return rtn;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\\n        if k == 0 {\\n            return vec![vec![]];\\n        }\\n        let mut rtn = vec![];\\n        for i in k..=n {\\n            for mut pre in Self::combine(i-1, k-1) {\\n                pre.push(i);\\n                rtn.push(pre);\\n            }\\n        }\\n        return rtn;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170834,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if k == 0:\\n            return []\\n        elif k == 1:\\n            return [[i] for i in range(1,n+1)]\\n        res = []\\n        for tail in range(n,k-1,-1):\\n            tmp = self.combine(tail-1, k-1)\\n            for i in range(len(tmp)):\\n                tmp[i].append(tail)\\n            res += tmp\\n        return res          \\n```\\nSame idea, more succinct:\\n```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if k == 0:\\n            return [[]]\\n        return [x+[tail] for tail in range(n,k-1,-1) for x in self.combine(tail-1, k-1)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if k == 0:\\n            return []\\n        elif k == 1:\\n            return [[i] for i in range(1,n+1)]\\n        res = []\\n        for tail in range(n,k-1,-1):\\n            tmp = self.combine(tail-1, k-1)\\n            for i in range(len(tmp)):\\n                tmp[i].append(tail)\\n            res += tmp\\n        return res          \\n```\n```\\nclass Solution(object):\\n    def combine(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if k == 0:\\n            return [[]]\\n        return [x+[tail] for tail in range(n,k-1,-1) for x in self.combine(tail-1, k-1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26991,
                "title": "c-dfs-solution",
                "content": "    vector<vector<int>> combine(int n, int k) \\n    {\\n        vector<vector<int>> result;\\n        vector<int> solution;\\n        dfs(result, solution, n, k, 1);\\n        \\n        return result;\\n    }\\n    \\n    void dfs(vector<vector<int>>& result, vector<int>& solution, int n, int k, int start)\\n    {\\n        if (solution.size() == k)\\n        {\\n            result.push_back(solution);\\n            return;\\n        }\\n        \\n        for (int i = start; i <= n; i++)\\n        {\\n            solution.push_back(i);\\n            dfs(result, solution, n, k, i + 1);\\n            solution.pop_back();\\n        }\\n    }",
                "solutionTags": [],
                "code": "    vector<vector<int>> combine(int n, int k) \\n    {\\n        vector<vector<int>> result;\\n        vector<int> solution;\\n        dfs(result, solution, n, k, 1);\\n        \\n        return result;\\n    }\\n    \\n    void dfs(vector<vector<int>>& result, vector<int>& solution, int n, int k, int start)\\n    {\\n        if (solution.size() == k)\\n        {\\n            result.push_back(solution);\\n            return;\\n        }\\n        \\n        for (int i = start; i <= n; i++)\\n        {\\n            solution.push_back(i);\\n            dfs(result, solution, n, k, i + 1);\\n            solution.pop_back();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27100,
                "title": "recursive-is-faster-than-dp",
                "content": "// recursion solution\\n\\npublic class Solution {\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        if(n < 0 || n < k){ return result;}\\n        if(k == 1){\\n            for(int i = 1; i <= n; i++){\\n                List<Integer> temp = new ArrayList<Integer>();\\n                temp.add(i);\\n                result.add(temp);\\n            }\\n            return result;\\n        }\\n        result = combine(n-1, k-1);\\n        for(int i = 0; i < result.size(); i++){\\n            result.get(i).add(n);\\n        }\\n        List<List<Integer>> temp = combine(n-1, k);\\n        result.addAll(temp);\\n        return result;\\n    }\\n}\\n\\n// dp solution\\n\\npublic class Solution {\\n\\n   public List<List<Integer>> combine(int n, int k) {\\n\\n        List<List<List<List<Integer>>>> dp = new ArrayList<List<List<List<Integer>>>>();\\n        List<List<List<Integer>>> line = new ArrayList<List<List<Integer>>>();\\n        List<List<Integer>> cell = new ArrayList<List<Integer>>();\\n        List<Integer> entry = new ArrayList<Integer>();\\n        entry.add(1);\\n        cell.add(entry);\\n        line.add(cell);\\n        dp.add(line);\\n        for(int i = 1; i < k; i++){\\n            List<List<Integer>> cellI = new ArrayList<List<Integer>>();\\n            line.add(cellI);\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            List<List<List<Integer>>> newLine = new ArrayList<List<List<Integer>>>();\\n            newLine.add(new ArrayList<List<Integer>>(dp.get(i-1).get(0)));\\n            List<Integer> temp = new ArrayList<Integer>();\\n            temp.add(i+1);\\n            newLine.get(0).add(temp);\\n            dp.add(newLine);\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < k; j++){\\n                List<List<Integer>> newCell = new ArrayList<List<Integer>>();\\n                List<List<Integer>> pre = dp.get(i-1).get(j);\\n                for(int m = 0; m < pre.size(); m++){\\n                \\tnewCell.add(new ArrayList<Integer>(pre.get(m)));\\n                }\\n                List<List<Integer>> previous = dp.get(i-1).get(j-1);\\n                for(int m = 0; m < previous.size(); m++){\\n                    List<Integer> entryTemp = new ArrayList<Integer>(previous.get(m));\\n                    entryTemp.add(i+1);\\n                    newCell.add(entryTemp);\\n                }\\n\\n                dp.get(i).add(newCell);\\n            }\\n        }\\n        return dp.get(n-1).get(k-1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        if(n < 0 || n < k){ return result;}",
                "codeTag": "Java"
            },
            {
                "id": 27160,
                "title": "java-my-iterative-13ms-and-recursive-7ms-solutions",
                "content": "iterative solution\\n\\n    public class Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        List<Integer> kind = new ArrayList<Integer>();\\n        int i = 1;\\n        while(i<=n || kind.size()!=0){\\n            if(kind.size()==k){\\n                list.add(new ArrayList(kind));\\n            }\\n            if(i>n||kind.size()==k){\\n                i = kind.get(kind.size()-1)+1;\\n                kind.remove(kind.size()-1);\\n            }\\n            else{\\n                kind.add(i);\\n                i++;\\n            }\\n        }\\n        return list;\\n    }\\n\\nrecursive solution\\n\\n    public class Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        helper(list , new ArrayList<Integer>(),n,k,1);\\n        return list;\\n    }\\n    \\n    public void helper(List<List<Integer>> list,List<Integer> kind , int n , int k,int start){\\n        if(kind.size() == k){\\n            list.add(new ArrayList(kind));\\n            return;\\n        }\\n        \\n        for(int i = start;i<=n;i++){\\n            if(!kind.contains(i)){\\n                kind.add(i);\\n                helper(list,kind,n,k,i);\\n                kind.remove(kind.size()-1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        List<Integer> kind = new ArrayList<Integer>();\\n        int i = 1;\\n        while(i<=n || kind.size()!=0){\\n            if(kind.size()==k){\\n                list.add(new ArrayList(kind));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 27167,
                "title": "clean-java-recursive-solution",
                "content": "    public List<List<Integer>> combine(int n, int k) {\\n    \\t\\tList<List<Integer>> ans = new LinkedList<List<Integer>>();\\n    \\t\\tcombineHelper(ans, new LinkedList<Integer>(), n, k, 1);\\n    \\t\\treturn ans;\\n    \\n    \\t}\\n    \\n    \\tprivate void combineHelper(List<List<Integer>> ans, List<Integer> current,\\n    \\t\\t\\tint n, int k, int start) {\\n    \\t\\tif (current.size() == k) {\\n    \\t\\t\\tans.add(current);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tfor (int i = start; i <= n; i++) {\\n    \\t\\t\\tList<Integer> newCurrent = new LinkedList<Integer>(current);\\n    \\t\\t\\tnewCurrent.add(i);\\n    \\t\\t\\tcombineHelper(ans, newCurrent, n, k, i + 1);\\n        \\t\\t}\\n    }",
                "solutionTags": [],
                "code": "    public List<List<Integer>> combine(int n, int k) {\\n    \\t\\tList<List<Integer>> ans = new LinkedList<List<Integer>>();\\n    \\t\\tcombineHelper(ans, new LinkedList<Integer>(), n, k, 1);\\n    \\t\\treturn ans;\\n    \\n    \\t}\\n    \\n    \\tprivate void combineHelper(List<List<Integer>> ans, List<Integer> current,\\n    \\t\\t\\tint n, int k, int start) {\\n    \\t\\tif (current.size() == k) {\\n    \\t\\t\\tans.add(current);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tfor (int i = start; i <= n; i++) {\\n    \\t\\t\\tList<Integer> newCurrent = new LinkedList<Integer>(current);\\n    \\t\\t\\tnewCurrent.add(i);\\n    \\t\\t\\tcombineHelper(ans, newCurrent, n, k, i + 1);\\n        \\t\\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27180,
                "title": "c-solution-using-bit-operation-with-full-explanation",
                "content": "The question required us to list all combinations with k numbers from 1...n. We could treat each valid combination as a n-bit number, in which k bits are 1 and other bits are 0. \\n\\nFor example, n = 4 & k = 2, a valid combination **[1,4]** could be represented as **1001**, **[1,3]** could be represented as **0101**. \\n\\n\\nThus, all we need is 2 loops, while the first `for(int i = 0; i < 1<<n; i++)` will loop over all n-bit numbers, from 0...0 to 1...1, and the second `for(int j = 0; j < n; j++)` will loop around the n bits, and count the number of `1` in the n bits. If the result equal to k, this result should be translated and stored into the final result. \\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> combine(int n, int k) {\\n            vector<vector<int>> result;\\n            vector<int> cur;\\n            for(int i = 0; i < 1<<n; i++){\\n                int sum = 0;\\n                for(int j = 0; j < n; j++){\\n                    int valid = (i>>j) & 1;\\n                    sum += valid;\\n                    if(valid) cur.push_back(j+1);\\n                }\\n                if(sum == k) result.push_back(cur);\\n                cur.clear();\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combine(int n, int k) {\\n            vector<vector<int>> result;\\n            vector<int> cur;\\n            for(int i = 0; i < 1<<n; i++){\\n                int sum = 0;\\n                for(int j = 0; j < n; j++){\\n                    int valid = (i>>j) & 1;\\n                    sum += valid;\\n                    if(valid) cur.push_back(j+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27183,
                "title": "c-iteration-solution-without-recursive-or-stack-21-lines-8ms-no-pointer",
                "content": "Use recursive will be a short solution but I think it's not need extra load.\\n\\n21 lines no pointer, easy understand:\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> combine(int n, int k) {\\n            vector<vector<int> >results;\\n            vector<int> res(k,0);\\n            int level = 0;\\n            int maxLevel = k-1;\\n            int level0_Max = n - k + 1;\\n            while(level >= 0){\\n                if(++res[level] > level0_Max + level)\\n                    level--;\\n                else if(level == maxLevel)\\n                    results.push_back(res);\\n                else{\\n                    res[level+1] = res[level];\\n                    level++;\\n                }\\n            }\\n            return results;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combine(int n, int k) {\\n            vector<vector<int> >results;\\n            vector<int> res(k,0);\\n            int level = 0;\\n            int maxLevel = k-1;\\n            int level0_Max = n - k + 1;\\n            while(level >= 0){\\n                if(++res[level] > level0_Max + level)\\n                    level--;\\n                else if(level == maxLevel)\\n                    results.push_back(res);\\n                else{\\n                    res[level+1] = res[level];\\n                    level++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27216,
                "title": "12ms-recursive-c",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > combine(int n, int k) {\\n            vector<vector<int> > rslt;\\n            vector<int> path(k, 0);\\n            combine(n, k, rslt, path);\\n            return rslt;\\n        }\\n    private:\\n        void combine(int n, int k, vector<vector<int> > &rslt, vector<int> &path) {\\n            if (k == 0) {\\n                rslt.push_back(path);\\n                return;\\n            }\\n            for (int i = n; i >= 1; i--) {\\n                path[k - 1] = i;\\n                combine(i - 1, k - 1, rslt, path);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combine(int n, int k) {\\n            vector<vector<int> > rslt;\\n            vector<int> path(k, 0);\\n            combine(n, k, rslt, path);\\n            return rslt;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 27223,
                "title": "accepted-java-recursive-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            return combine(n,1,k);\\n        }\\n    \\n        public List<List<Integer>> combine(int n,int current,int k){\\n            List<List<Integer>> result = new LinkedList<List<Integer>>();\\n            \\n            if(k==0) {\\n                result.add(new LinkedList<Integer>());\\n                return result;\\n            }\\n            \\n            if(current>n) return result;\\n    \\n            for(List<Integer> res:combine(n,current+1,k)){\\n                result.add(res);\\n            }\\n            for(List<Integer> res:combine(n,current+1,k-1)){\\n                res.add(0,current);\\n                result.add(res);\\n            }\\n    \\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combine(int n, int k) {\\n            return combine(n,1,k);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 27233,
                "title": "iterative-version",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > combine(int n, int k) {\\n            int cur=0;\\n            vector<int> v(k,0);\\n            vector<vector<int> > ans;\\n            while (cur>=0) {\\n                if (cur==k) {\\n                    ans.push_back(v);\\n                    --cur;\\n                    continue;\\n                }\\n                int val=v[cur]+1;\\n                if (cur>0) {\\n                    val=max(val,v[cur-1]+1);\\n                }\\n                if (val<=n) {\\n                    v[cur++]=val;\\n                } else {\\n                    v[cur--]=0;\\n                }\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combine(int n, int k) {\\n            int cur=0;\\n            vector<int> v(k,0);\\n            vector<vector<int> > ans;\\n            while (cur>=0) {\\n                if (cur==k) {\\n                    ans.push_back(v);\\n                    --cur;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3847000,
                "title": "backtracking-and-recursion-c-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution is basically picking number or notpicking that number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis method uses a binary tree-like recursion structure where, at each step, it either includes the current num in the combination or skips it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(recursion stack space)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>res;\\n    void f(int num,int total,int k,vector<int>&ans){\\n        if(num==total+1){\\n            if(ans.size()==k)\\n            res.push_back(ans);\\n            return;\\n        }\\n\\n        ans.push_back(num);\\n        f(num+1,total,k,ans);\\n        ans.pop_back();\\n        f(num+1,total,k,ans);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>ans;\\n        f(1,n,k,ans);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>res;\\n    void f(int num,int total,int k,vector<int>&ans){\\n        if(num==total+1){\\n            if(ans.size()==k)\\n            res.push_back(ans);\\n            return;\\n        }\\n\\n        ans.push_back(num);\\n        f(num+1,total,k,ans);\\n        ans.pop_back();\\n        f(num+1,total,k,ans);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>ans;\\n        f(1,n,k,ans);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846842,
                "title": "simple-and-basic-approach-using-recursion-of-take-and-nottake-case",
                "content": "# Intuition\\n<!-- simply used take and nottake cases for combinations -->\\n\\n# Approach\\n<!-- used backtracking first push element into array untill size of temp bacomes K and then pop the element that is pushed so that next element can be taken -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(2^k) -->\\n\\n- Space complexity:\\n<!-- O(2^n) -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void f(int ind,int k,vector<int> &temp,vector<vector<int>> &ans) \\n    {\\n        if(k==0)\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        if(ind==0) return ;\\n        f(ind-1,k,temp,ans);\\n        temp.push_back(ind);\\n        f(ind-1,k-1,temp,ans);\\n        temp.pop_back();\\n\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(n,k,temp,ans);\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int ind,int k,vector<int> &temp,vector<vector<int>> &ans) \\n    {\\n        if(k==0)\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        if(ind==0) return ;\\n        f(ind-1,k,temp,ans);\\n        temp.push_back(ind);\\n        f(ind-1,k-1,temp,ans);\\n        temp.pop_back();\\n\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(n,k,temp,ans);\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846713,
                "title": "bitmasking-easily-explained-in-hindi-clean-and-concise-code",
                "content": "# Approach\\n1. We have to choose exactly K numbers out of N numbers.\\n2. To choose that we will create bit masks.\\n3. What bit masks will do is, we have all the numbers which have only K set bits and it is less than 2^N (i.e. total number of bits are less equal to N) so these will help to choose the K numbers. \\n\\nSo what we did is : \\n- Saare numbers genrate kar liye jisne K set bits hai.\\n- Jin position ki bit set hai unko ek array m push kra \\n- Usko result m push kr diya\\n\\n\\n# Complexity\\n- Time complexity: O(2^N * log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // ye function ek number ko lega aur usme jis position \\n    // pr set bit (1) hai usko array m push krega \\n    vector<int> fun(int num)\\n    {\\n       vector<int> ans;\\n       int cnt=1;\\n       while(num)\\n       {\\n           if(num%2) ans.emplace_back(cnt);\\n           num/=2;\\n           cnt++;\\n       }\\n       return ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        // (1<<n) = 2^n\\n        // Loop chala do 2^N taki saare numbers aa jaaye \\n        for(int i=0; i< (1<<n) ; i++) \\n        {\\n            // Jis numbers mai bits exactly K hai vo he kaam k hai bs\\n            if(__builtin_popcount(i) == k) \\n            ans.emplace_back(fun(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // ye function ek number ko lega aur usme jis position \\n    // pr set bit (1) hai usko array m push krega \\n    vector<int> fun(int num)\\n    {\\n       vector<int> ans;\\n       int cnt=1;\\n       while(num)\\n       {\\n           if(num%2) ans.emplace_back(cnt);\\n           num/=2;\\n           cnt++;\\n       }\\n       return ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        // (1<<n) = 2^n\\n        // Loop chala do 2^N taki saare numbers aa jaaye \\n        for(int i=0; i< (1<<n) ; i++) \\n        {\\n            // Jis numbers mai bits exactly K hai vo he kaam k hai bs\\n            if(__builtin_popcount(i) == k) \\n            ans.emplace_back(fun(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846555,
                "title": "c-recursive-one-liner",
                "content": "<!--# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!--# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!--# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!--- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public IList<IList<int>> Combine(int n, int k)\\n        =>  k == 1\\n            // handle base case\\n            ? Enumerable.Range(1, n).Select(x => new []{ x }).ToArray()\\n            // transition to upper dimension;\\n            // generate combinations of dimension k - 1\\n            // then generate all possible dimension k combinations\\n            // by appending values, that are greater than the last value in current combination to avoid duplicates\\n            : Combine(n, k - 1).SelectMany(x => Enumerable.Range(x[^1] + 1, n - x[^1]).Select(y => x.Append(y).ToArray())).ToArray();\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<IList<int>> Combine(int n, int k)\\n        =>  k == 1\\n            // handle base case\\n            ? Enumerable.Range(1, n).Select(x => new []{ x }).ToArray()\\n            // transition to upper dimension;\\n            // generate combinations of dimension k - 1\\n            // then generate all possible dimension k combinations\\n            // by appending values, that are greater than the last value in current combination to avoid duplicates\\n            : Combine(n, k - 1).SelectMany(x => Enumerable.Range(x[^1] + 1, n - x[^1]).Select(y => x.Append(y).ToArray())).ToArray();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845865,
                "title": "90-beats-c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int s,int &n,int k,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int i = s; i <= n; i++){\\n            tmp.push_back(i);\\n            solve(i+1,n,k-1,tmp,ans);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        solve(1,n,k,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int s,int &n,int k,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int i = s; i <= n; i++){\\n            tmp.push_back(i);\\n            solve(i+1,n,k-1,tmp,ans);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        solve(1,n,k,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845676,
                "title": "combinations-easy-recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    vector<int>temp;\\n    vector<vector<int>> combine(int n, int k) {\\n        memo(n,k);\\n        return ans;\\n    }\\n    void memo(int n, int k){\\n        if(k == temp.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(n == 0) return;\\n        temp.push_back(n);\\n        memo(n-1,k);\\n        temp.pop_back();\\n        memo(n-1,k);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    vector<int>temp;\\n    vector<vector<int>> combine(int n, int k) {\\n        memo(n,k);\\n        return ans;\\n    }\\n    void memo(int n, int k){\\n        if(k == temp.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(n == 0) return;\\n        temp.push_back(n);\\n        memo(n-1,k);\\n        temp.pop_back();\\n        memo(n-1,k);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845192,
                "title": "daily-leetcoding-challenge-august-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combinations/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combinations/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3329740,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans)\\n    {\\n          if(index==nums.size())\\n          {\\n              if(temp.size()==k)\\n              {\\n                  ans.push_back(temp);\\n              }\\n              return ;\\n          }\\n          helper(nums, k, index+1, temp, ans);\\n          temp.push_back(nums[index]);\\n          helper(nums, k, index+1, temp, ans);\\n          temp.pop_back();\\n    }\\n    vector<vector<int>> combine(int n, int k)\\n     {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        vector<int> nums;\\n        for(int i = 1;i<=n;i++)\\n        {\\n            nums.push_back(i);\\n        }\\n        helper(nums,k,0,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans)\\n    {\\n          if(index==nums.size())\\n          {\\n              if(temp.size()==k)\\n              {\\n                  ans.push_back(temp);\\n              }\\n              return ;\\n          }\\n          helper(nums, k, index+1, temp, ans);\\n          temp.push_back(nums[index]);\\n          helper(nums, k, index+1, temp, ans);\\n          temp.pop_back();\\n    }\\n    vector<vector<int>> combine(int n, int k)\\n     {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        vector<int> nums;\\n        for(int i = 1;i<=n;i++)\\n        {\\n            nums.push_back(i);\\n        }\\n        helper(nums,k,0,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178748,
                "title": "90-faster-code-in-c-and-python-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBacktracking\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**C++ Solution:-**\\n```\\nclass Solution {\\npublic:\\n    void backtrack(int ind, int n, int k, vector<int>&ds, vector<vector<int>>&res) {\\n         if(ds.size() == k) {\\n             res.emplace_back(ds);\\n             return;\\n         }\\n        for(int i=ind; i<=n; i++) {\\n            ds.emplace_back(i);\\n            backtrack(i+1, n, k, ds, res);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        vector<int> ds;\\n        backtrack(1, n, k, ds, res);\\n        return res;\\n    }\\n};\\n```\\n**Python Solution:-**\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def backtrack(ind, n, k, ds, res):\\n            if len(ds) == k:\\n                res.append(ds[:])\\n                return\\n            for i in range(ind, n+1):\\n                ds.append(i)\\n                backtrack(i+1, n, k, ds, res)\\n                ds.pop()\\n                \\n        res = []\\n        backtrack(1, n, k, [], res)\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(int ind, int n, int k, vector<int>&ds, vector<vector<int>>&res) {\\n         if(ds.size() == k) {\\n             res.emplace_back(ds);\\n             return;\\n         }\\n        for(int i=ind; i<=n; i++) {\\n            ds.emplace_back(i);\\n            backtrack(i+1, n, k, ds, res);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> res;\\n        vector<int> ds;\\n        backtrack(1, n, k, ds, res);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def backtrack(ind, n, k, ds, res):\\n            if len(ds) == k:\\n                res.append(ds[:])\\n                return\\n            for i in range(ind, n+1):\\n                ds.append(i)\\n                backtrack(i+1, n, k, ds, res)\\n                ds.pop()\\n                \\n        res = []\\n        backtrack(1, n, k, [], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176166,
                "title": "time-space-90-beats-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int n,int k,vector<int>& tmp,vector<vector<int>> &ans,int s){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(s>n){\\n            return;\\n        }\\n        for(int i = s; i<=n; i++){\\n            tmp.push_back(i);\\n            solve(n,k-1,tmp,ans,i+1);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        solve(n,k,tmp,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int n,int k,vector<int>& tmp,vector<vector<int>> &ans,int s){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(s>n){\\n            return;\\n        }\\n        for(int i = s; i<=n; i++){\\n            tmp.push_back(i);\\n            solve(n,k-1,tmp,ans,i+1);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        solve(n,k,tmp,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167087,
                "title": "c-solution-using-recursion",
                "content": "# EXPLANATION\\nWe created **\"ans\"** for our answer and **\"v\"** for the combination of numbers.\\nWe used recursion to keep on with numbers and insert into vector **\"v\"** and ultimately returned answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> v;\\n    void solution(int i,int n, int k){\\n        if(v.size()==k){\\n            ans.push_back(v);\\n            return;\\n        }\\n        while(i<=n){\\n            v.push_back(i);\\n            solution(i+1,n,k);\\n            v.pop_back();\\n            solution(i+1,n,k);\\n            return;\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        solution(1,n,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> v;\\n    void solution(int i,int n, int k){\\n        if(v.size()==k){\\n            ans.push_back(v);\\n            return;\\n        }\\n        while(i<=n){\\n            v.push_back(i);\\n            solution(i+1,n,k);\\n            v.pop_back();\\n            solution(i+1,n,k);\\n            return;\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        solution(1,n,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092501,
                "title": "c-solution-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid combi(int n , int k , int ind , vector<vector<int>> &ans,vector<int> out){\\n// base case if out vector\\'s size is equal to k than add out vector in\\n// our ans vector\\n    if(out.size()==k){\\n        ans.push_back(out);\\n        return;\\n    }\\n    for(int i=ind ;i<=n;i++){\\n        out.push_back(i);\\n        combi(n,k,i+1,ans,out);\\n        out.pop_back();\\n    }\\n}\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>out;\\n        vector<vector<int>>ans;\\n        if(n==0) return ans;\\n        combi(n,k,1,ans,out);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid combi(int n , int k , int ind , vector<vector<int>> &ans,vector<int> out){\\n// base case if out vector\\'s size is equal to k than add out vector in\\n// our ans vector\\n    if(out.size()==k){\\n        ans.push_back(out);\\n        return;\\n    }\\n    for(int i=ind ;i<=n;i++){\\n        out.push_back(i);\\n        combi(n,k,i+1,ans,out);\\n        out.pop_back();\\n    }\\n}\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>out;\\n        vector<vector<int>>ans;\\n        if(n==0) return ans;\\n        combi(n,k,1,ans,out);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783789,
                "title": "time-and-space-80-and-90-beats-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int s,int& n,int k,vector<vector<int>> &ans,vector<int>& tmp){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int i = s; i <= n; i++){\\n            tmp.push_back(i);\\n            solve(i+1,n,k-1,ans,tmp);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        solve(1,n,k,ans,tmp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int s,int& n,int k,vector<vector<int>> &ans,vector<int>& tmp){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int i = s; i <= n; i++){\\n            tmp.push_back(i);\\n            solve(i+1,n,k-1,ans,tmp);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        solve(1,n,k,ans,tmp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774503,
                "title": "java-c-easy-to-understand-recursion",
                "content": "# \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<Integer> ans=new ArrayList();\\n        List<List<Integer>> res=new ArrayList();\\n        combi(n,k,1,ans,res);\\n        return res;\\n    }\\n    public static void combi(int n, int k, int index, List<Integer> ans, List<List<Integer>> res)\\n    {\\n        if(k==0)\\n        {\\n            res.add(new ArrayList(ans));\\n            return;\\n        }\\n        for(int i=index;i<=n;i++)\\n        {\\n            ans.add(i);\\n            combi(n, k-1,i+1, ans, res);\\n            ans.remove(ans.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<Integer> ans=new ArrayList();\\n        List<List<Integer>> res=new ArrayList();\\n        combi(n,k,1,ans,res);\\n        return res;\\n    }\\n    public static void combi(int n, int k, int index, List<Integer> ans, List<List<Integer>> res)\\n    {\\n        if(k==0)\\n        {\\n            res.add(new ArrayList(ans));\\n            return;\\n        }\\n        for(int i=index;i<=n;i++)\\n        {\\n            ans.add(i);\\n            combi(n, k-1,i+1, ans, res);\\n            ans.remove(ans.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522287,
                "title": "simple-go-solution",
                "content": "```\\nfunc combine(n int, k int) [][]int {\\n    var res [][]int\\n\\n    combination := make([]int, k)\\n    \\n    var backtrack func(int)\\n    backtrack = func(index int) {\\n        if index == k {\\n            copiedCombination := make([]int, k)\\n            copy(copiedCombination, combination)\\n            res = append(res, copiedCombination)\\n            return \\n        }\\n        \\n        begin := 1\\n        \\n        if index > 0 {\\n            begin = combination[index-1] + 1\\n        }\\n        \\n        for i := begin; i <= n; i++ {\\n            combination[index] = i\\n            backtrack(index + 1)\\n        } \\n    }\\n    \\n    backtrack(0)\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfunc combine(n int, k int) [][]int {\\n    var res [][]int\\n\\n    combination := make([]int, k)\\n    \\n    var backtrack func(int)\\n    backtrack = func(index int) {\\n        if index == k {\\n            copiedCombination := make([]int, k)\\n            copy(copiedCombination, combination)\\n            res = append(res, copiedCombination)\\n            return \\n        }\\n        \\n        begin := 1\\n        \\n        if index > 0 {\\n            begin = combination[index-1] + 1\\n        }\\n        \\n        for i := begin; i <= n; i++ {\\n            combination[index] = i\\n            backtrack(index + 1)\\n        } \\n    }\\n    \\n    backtrack(0)\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2518988,
                "title": "java-solution-backtracking",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        combinations(n,k,ans,temp);\\n        return ans;\\n    }\\n    \\n    public void combinations(int n , int k , List<List<Integer>> ans , List<Integer> temp){\\n        if(k == 0)\\n        {\\n            ans.add(new ArrayList(temp));\\n            return;\\n        }\\n        if(n == 0)\\n            return;\\n        \\n//         We are not taking n\\n        combinations(n-1, k, ans,temp);\\n        \\n//         We are taking n\\n        temp.add(n);\\n        combinations(n-1,k-1,ans,temp);\\n        temp.remove(temp.size()-1);\\n    }\\n}\\n```\\n\\nIf you like the solution, please UPVOTE :)",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        combinations(n,k,ans,temp);\\n        return ans;\\n    }\\n    \\n    public void combinations(int n , int k , List<List<Integer>> ans , List<Integer> temp){\\n        if(k == 0)\\n        {\\n            ans.add(new ArrayList(temp));\\n            return;\\n        }\\n        if(n == 0)\\n            return;\\n        \\n//         We are not taking n\\n        combinations(n-1, k, ans,temp);\\n        \\n//         We are taking n\\n        temp.add(n);\\n        combinations(n-1,k-1,ans,temp);\\n        temp.remove(temp.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254593,
                "title": "easy-to-understand-faster-than-99",
                "content": "Please Upvote if you find this solution helpful...\\n----\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> ans;\\n    void dfs(int cur, int n, int k, vector<int>& temp){\\n        if(k==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=cur+1;i<=n-k+1;i++){\\n            temp.push_back(i);\\n            dfs(i, n, k-1, temp);\\n            temp.pop_back();            // Back Tracking\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combine(int n, int k){ \\n        vector<int> temp;\\n        dfs(0, n, k, temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> ans;\\n    void dfs(int cur, int n, int k, vector<int>& temp){\\n        if(k==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=cur+1;i<=n-k+1;i++){\\n            temp.push_back(i);\\n            dfs(i, n, k-1, temp);\\n            temp.pop_back();            // Back Tracking\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combine(int n, int k){ \\n        vector<int> temp;\\n        dfs(0, n, k, temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100613,
                "title": "c-best-code-backtracking-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void fn(int i,int k,int n,vector<int>&nums,vector<int>&v,\\n        vector<vector<int>>&ans){\\n\\t\\t\\n\\t\\t//base case\\n        if(i>n || k==0){\\n            if(k==0)\\n                ans.push_back(v);\\n            return;\\n        }\\n\\t\\t\\n\\t\\t//pick up the element\\n        v.push_back(nums[i]);\\n        fn(i+1,k-1,n,nums,v,ans);\\n        v.pop_back();\\n        \\n\\t\\t//dont pick up the element\\n        fn(i+1,k,n,nums,v,ans);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>v,nums(n+1,0);\\n        vector<vector<int>>ans;\\n        for(int i=1;i<=n;i++){\\n            nums[i]=i;\\n        }\\n        fn(1,k,n,nums,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fn(int i,int k,int n,vector<int>&nums,vector<int>&v,\\n        vector<vector<int>>&ans){\\n\\t\\t\\n\\t\\t//base case\\n        if(i>n || k==0){\\n            if(k==0)\\n                ans.push_back(v);\\n            return;\\n        }\\n\\t\\t\\n\\t\\t//pick up the element\\n        v.push_back(nums[i]);\\n        fn(i+1,k-1,n,nums,v,ans);\\n        v.pop_back();\\n        \\n\\t\\t//dont pick up the element\\n        fn(i+1,k,n,nums,v,ans);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>v,nums(n+1,0);\\n        vector<vector<int>>ans;\\n        for(int i=1;i<=n;i++){\\n            nums[i]=i;\\n        }\\n        fn(1,k,n,nums,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791019,
                "title": "python-3-900ms-dfs-solution-recursive",
                "content": "```\\nclass Solution:\\n    def combine(self, n, k):\\n        ret = []\\n        self.dfs(list(range(1, n+1)), k, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, k, path, ret):\\n        if len(path) == k:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k, path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combine(self, n, k):\\n        ret = []\\n        self.dfs(list(range(1, n+1)), k, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, k, path, ret):\\n        if len(path) == k:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k, path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782037,
                "title": "c-efficient-recursive-backtracking-simple-solution-with-comment",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;//to store all combination\\n    void helper(int index,int k, vector<int>temp, int n){\\n        if(temp.size()==k){//base case\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index;i<=n;i++){\\n            temp.push_back(i);//consider the current element i\\n            helper(i+1, k, temp, n);// generate combinations\\n            temp.pop_back();//proceed to next element //(backtracking)\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>temp;//to story combination in each iteration\\n        helper(1,k,temp,n);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;//to store all combination\\n    void helper(int index,int k, vector<int>temp, int n){\\n        if(temp.size()==k){//base case\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index;i<=n;i++){\\n            temp.push_back(i);//consider the current element i\\n            helper(i+1, k, temp, n);// generate combinations\\n            temp.pop_back();//proceed to next element //(backtracking)\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int>temp;//to story combination in each iteration\\n        helper(1,k,temp,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777322,
                "title": "c-easy-to-understand-using-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int> > ans;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                temp.push_back(j+1);\\n            }\\n            if(temp.size()==k)\\n            ans.push_back(temp);\\n        }     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int> > ans;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                temp.push_back(j+1);\\n            }\\n            if(temp.size()==k)\\n            ans.push_back(temp);\\n        }     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760124,
                "title": "c-soln-using-backtrack",
                "content": "```\\nvoid backtrack(vector<vector<int>>&ans,vector<int>curr_arr,int index,int k,int n){\\n        if(curr_arr.size()==k){\\n            ans.push_back(curr_arr);\\n            return ;\\n        }\\n        for(int i=index;i<=n;i++){\\n            curr_arr.push_back(i);\\n            backtrack(ans,curr_arr,++index,k,n);\\n            curr_arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>ans;\\n        vector<int>curr_arr;\\n        backtrack(ans,curr_arr,1,k,n);\\n        return ans;\\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nvoid backtrack(vector<vector<int>>&ans,vector<int>curr_arr,int index,int k,int n){\\n        if(curr_arr.size()==k){\\n            ans.push_back(curr_arr);\\n            return ;\\n        }\\n        for(int i=index;i<=n;i++){\\n            curr_arr.push_back(i);\\n            backtrack(ans,curr_arr,++index,k,n);\\n            curr_arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>ans;\\n        vector<int>curr_arr;\\n        backtrack(ans,curr_arr,1,k,n);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1678173,
                "title": "a-python-simple-solution-based-on-the-concept-of-pascal-s-formula-c-n-k-c-n-1-k-1-c-n-1-k",
                "content": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        if k==1:\\n            return [[i+1] for i in range(n)]\\n        ans=[]\\n        for item in self.combine(n-1,k-1):\\n            ans.append(item+[n])\\n        if n-1>=k:\\n            ans+=self.combine(n-1,k)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        if k==1:\\n            return [[i+1] for i in range(n)]\\n        ans=[]\\n        for item in self.combine(n-1,k-1):\\n            ans.append(item+[n])\\n        if n-1>=k:\\n            ans+=self.combine(n-1,k)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603213,
                "title": "java-1ms-backtracking-concise-solution-beats-100-95",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> res = new ArrayList<>();\\n    LinkedList<Integer> tmp = new LinkedList<>();\\n    public List<List<Integer>> combine(int n, int k) {\\n        back(n,k,1);\\n        return res;\\n    }\\n    \\n    public void back(int n,int k, int start){\\n        if(tmp.size() == k){\\n            res.add(new ArrayList<>(tmp));\\n            return;\\n        }\\n        \\n        for(int i = start;i<=n-(k-tmp.size())+1;i++){\\n            tmp.add(i);\\n            back(n,k,i+1);\\n            tmp.removeLast();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> res = new ArrayList<>();\\n    LinkedList<Integer> tmp = new LinkedList<>();\\n    public List<List<Integer>> combine(int n, int k) {\\n        back(n,k,1);\\n        return res;\\n    }\\n    \\n    public void back(int n,int k, int start){\\n        if(tmp.size() == k){\\n            res.add(new ArrayList<>(tmp));\\n            return;\\n        }\\n        \\n        for(int i = start;i<=n-(k-tmp.size())+1;i++){\\n            tmp.add(i);\\n            back(n,k,i+1);\\n            tmp.removeLast();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539386,
                "title": "python-backtracking-solution-time-o-n-k-pace-o-k-space-not-including-the-output-space",
                "content": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        result  = []\\n        current = []\\n        def dfs(index):\\n            if len(current) == k:\\n                result.append(current[:])\\n                return\\n            for i in range(index, n + 1):\\n                current.append(i)\\n                dfs(i + 1)\\n                current.pop()\\n        dfs(1)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        result  = []\\n        current = []\\n        def dfs(index):\\n            if len(current) == k:\\n                result.append(current[:])\\n                return\\n            for i in range(index, n + 1):\\n                current.append(i)\\n                dfs(i + 1)\\n                current.pop()\\n        dfs(1)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455247,
                "title": "recursion-backtracking-very-intuitive-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //since we have to generate all possible combinations so we will use recursion and backtracking here...\\n    \\n    void solve(int idx,int k,vector<vector<int>>&res,vector<int>&temp,int n){\\n        //below is the base case as we want to create subsets which having only k elements so we check that our temp vector size is equal to k or not if it is equal to the k then this is the time when we get our first subset...\\n        if(temp.size() == k){ \\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<=n;i++){\\n            temp.push_back(i); // we take one element\\n            solve(i+1,k,res,temp,n); //here we generate all possible combinations\\n            temp.pop_back();//and now we have to move to the next index so we backtrack here\\n        }\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>res; // to store result\\n        vector<int>temp; //to store one possilbe answer\\n        solve(1,k,res,temp,n);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //since we have to generate all possible combinations so we will use recursion and backtracking here...\\n    \\n    void solve(int idx,int k,vector<vector<int>>&res,vector<int>&temp,int n){\\n        //below is the base case as we want to create subsets which having only k elements so we check that our temp vector size is equal to k or not if it is equal to the k then this is the time when we get our first subset...\\n        if(temp.size() == k){ \\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<=n;i++){\\n            temp.push_back(i); // we take one element\\n            solve(i+1,k,res,temp,n); //here we generate all possible combinations\\n            temp.pop_back();//and now we have to move to the next index so we backtrack here\\n        }\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>res; // to store result\\n        vector<int>temp; //to store one possilbe answer\\n        solve(1,k,res,temp,n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225680,
                "title": "javascript-very-easy-solution",
                "content": "```\\nvar combine = function(n, k) {\\n    let result =[];\\n    let combinations=[];\\n    helper(1,n,k);\\n    return result;\\n    \\n    function helper(startIndex,n,k){\\n        if(combinations.length===k){\\n            result.push([...combinations])\\n            return\\n        }\\n        \\n        for(let i=startIndex; i<=n; i++){\\n            combinations.push(i);\\n            helper(i+1,n,k)\\n            combinations.pop()\\n        }\\n    }\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combine = function(n, k) {\\n    let result =[];\\n    let combinations=[];\\n    helper(1,n,k);\\n    return result;\\n    \\n    function helper(startIndex,n,k){\\n        if(combinations.length===k){\\n            result.push([...combinations])\\n            return\\n        }\\n        \\n        for(let i=startIndex; i<=n; i++){\\n            combinations.push(i);\\n            helper(i+1,n,k)\\n            combinations.pop()\\n        }\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1219992,
                "title": "layman-s-approach-with-optimised-code",
                "content": "class Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        fin_list=new ArrayList<>();\\n        combination(0,k,n,-1,new int[k]);\\n        return fin_list;\\n    }\\n    \\n   static  List<List<Integer>> fin_list;\\n    \\n    public static void combination(int level,int k,int n,int li,int[] ans)\\n    {\\n        if(level==k)\\n        {\\n            List<Integer> list=new ArrayList<>();\\n            for(int i=0;i<k;i++)\\n                list.add(ans[i]);\\n            \\n            fin_list.add(list);\\n            return;\\n        }\\n        \\n        for(int i=li+1;i<n;i++)\\n        {\\n            ans[level]=i+1; // 1 -2,3,4 : 2-3,4 : 3-4 : 4-.\\n            combination(level+1,k,n,i,ans);\\n            ans[level]=0;\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        fin_list=new ArrayList<>();\\n        combination(0,k,n,-1,new int[k]);\\n        return fin_list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1157726,
                "title": "c-easy-to-understand-recursion-recursion-tree-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/77170c6d-42c9-4e28-8335-5bb952618c1b_1618382381.6897032.png)\\n\\n```\\nclass Solution {\\n    vector<vector<int>> ans;\\n    vector<int>curr;\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        recurse(1,n,k);\\n        return ans;\\n    }\\n    \\n    void recurse(int i, int &n, int &k){\\n        if(curr.size() == k){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        if(i > n){\\n            return;\\n        }\\n        \\n        while(i <= n){\\n            curr.push_back(i++);\\n            recurse(i,n,k);\\n            curr.pop_back();\\n        }\\n    }  \\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n    vector<int>curr;\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        recurse(1,n,k);\\n        return ans;\\n    }\\n    \\n    void recurse(int i, int &n, int &k){\\n        if(curr.size() == k){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        if(i > n){\\n            return;\\n        }\\n        \\n        while(i <= n){\\n            curr.push_back(i++);\\n            recurse(i,n,k);\\n            curr.pop_back();\\n        }\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059623,
                "title": "100-idiomatic-backtrack-solution",
                "content": "```\\nfunc combine(n int, k int) [][]int {\\n\\tvar result [][]int\\n\\tbuffer := make([]int, 0, k)\\n\\tbacktrack(&result, buffer, k, n, 1)\\n\\treturn result\\n}\\n\\nfunc backtrack(result *[][]int, buffer []int, left, n, s int) {\\n\\tif left == 0 {\\n\\t\\tcp := make([]int, len(buffer))\\n\\t\\tcopy(cp, buffer)\\n\\t\\t*result = append(*result, cp)\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := s; i <= n-left+1; i++ {\\n\\t\\tbacktrack(result, append(buffer, i), left-1, n, i+1)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc combine(n int, k int) [][]int {\\n\\tvar result [][]int\\n\\tbuffer := make([]int, 0, k)\\n\\tbacktrack(&result, buffer, k, n, 1)\\n\\treturn result\\n}\\n\\nfunc backtrack(result *[][]int, buffer []int, left, n, s int) {\\n\\tif left == 0 {\\n\\t\\tcp := make([]int, len(buffer))\\n\\t\\tcopy(cp, buffer)\\n\\t\\t*result = append(*result, cp)\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := s; i <= n-left+1; i++ {\\n\\t\\tbacktrack(result, append(buffer, i), left-1, n, i+1)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042867,
                "title": "c-solution-using-bit-masking",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> combine(int n, int k) {  \\n\\t\\t\\tvector<vector<int>> op;\\n\\t\\t\\tfor(int i = 1;i < (1<<n) ; i++){\\n\\t\\t\\t\\tif( __builtin_popcount(i) == k){  \\n\\t\\t\\t\\t\\tvector<int> small;\\n\\t\\t\\t\\t   for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\tif( i & (1<<j) ){\\n\\t\\t\\t\\t\\t\\t\\tsmall.push_back(j+1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\top.push_back(small);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn op;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> combine(int n, int k) {  \\n\\t\\t\\tvector<vector<int>> op;\\n\\t\\t\\tfor(int i = 1;i < (1<<n) ; i++){\\n\\t\\t\\t\\tif( __builtin_popcount(i) == k){  \\n\\t\\t\\t\\t\\tvector<int> small;\\n\\t\\t\\t\\t   for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\tif( i & (1<<j) ){\\n\\t\\t\\t\\t\\t\\t\\tsmall.push_back(j+1);\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 808169,
                "title": "c-clean-backtracking-solution",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> result;\\n    \\n    void helper(int index, vector<int>& cur, int n, int k) {\\n        if (cur.size() == k) {\\n            result.push_back(cur);\\n            return;\\n        }\\n        \\n        for (int i = index; i <= n; i++) {\\n            cur.push_back(i);\\n            helper(i+1, cur, n, k);\\n            cur.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> cur;\\n        \\n        helper(1, cur, n, k);\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<vector<int>> result;\\n    \\n    void helper(int index, vector<int>& cur, int n, int k) {\\n        if (cur.size() == k) {\\n            result.push_back(cur);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 735597,
                "title": "python-one-liner-using-combinations-76ms",
                "content": "The ```itertools``` module provides a ```combinations()``` method which can be used in this question.\\n\\n```\\nfrom itertools import combinations \\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        return [i for i in list(combinations([i for i in range(1, n+1)], k))]\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```itertools```\n```combinations()```\n```\\nfrom itertools import combinations \\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        return [i for i in list(combinations([i for i in range(1, n+1)], k))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411806,
                "title": "c-simple-solution",
                "content": "```\\nvoid GetLineSize(int **res, int *line, int lineSize,int n, int k, int *resLen, int idx)\\n{\\n    if (lineSize == k) {\\n        res[*resLen] = (int *)malloc(sizeof(int) * k);\\n        memcpy(res[*resLen], line, sizeof(int) * k);\\n        (*resLen) = (*resLen) + 1;\\n        return;\\n    }\\n\\n    for (int i = idx; i <= n; i++) {\\n        line[lineSize] = i;\\n        GetLineSize(res, line, lineSize + 1, n, k, resLen, i + 1);\\n    }\\n}\\nint** combine(int n, int k, int* returnSize, int** returnColumnSizes){\\n\\n    int **res = (int **)malloc(sizeof(int *)* 10000);\\n    int line[100];\\n    int lineSize = 0;\\n    int resLen = 0;\\n    GetLineSize(res, line, lineSize, n, k, &resLen, 1);\\n    *returnSize = resLen;\\n    *returnColumnSizes=malloc(sizeof(int)*(*returnSize));\\n    int i=*returnSize-1;\\n    while(i>=0){\\n    \\t(*returnColumnSizes)[i--]=k;\\n    }\\n    return res;\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid GetLineSize(int **res, int *line, int lineSize,int n, int k, int *resLen, int idx)\\n{\\n    if (lineSize == k) {\\n        res[*resLen] = (int *)malloc(sizeof(int) * k);\\n        memcpy(res[*resLen], line, sizeof(int) * k);\\n        (*resLen) = (*resLen) + 1;\\n        return;\\n    }\\n\\n    for (int i = idx; i <= n; i++) {\\n        line[lineSize] = i;\\n        GetLineSize(res, line, lineSize + 1, n, k, resLen, i + 1);\\n    }\\n}\\nint** combine(int n, int k, int* returnSize, int** returnColumnSizes){\\n\\n    int **res = (int **)malloc(sizeof(int *)* 10000);\\n    int line[100];\\n    int lineSize = 0;\\n    int resLen = 0;\\n    GetLineSize(res, line, lineSize, n, k, &resLen, 1);\\n    *returnSize = resLen;\\n    *returnColumnSizes=malloc(sizeof(int)*(*returnSize));\\n    int i=*returnSize-1;\\n    while(i>=0){\\n    \\t(*returnColumnSizes)[i--]=k;\\n    }\\n    return res;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329537,
                "title": "python-backtrack",
                "content": "\\tdef combine(self, n: int, k: int) -> List[List[int]]:\\n\\t\\t\\tdef helper(index, newK, chosen, res):\\n\\t\\t\\t\\tif newK == 0:\\n\\t\\t\\t\\t\\tres.append(chosen[:])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfor i in range(index, n + 1):\\n\\t\\t\\t\\t\\t\\t# Choose\\n\\t\\t\\t\\t\\t\\tchosen.append(i)\\n\\t\\t\\t\\t\\t\\t# Explore\\n\\t\\t\\t\\t\\t\\thelper(i + 1, newK - 1, chosen, res)\\n\\t\\t\\t\\t\\t\\t# Unchoose\\n\\t\\t\\t\\t\\t\\tchosen.pop()\\n        res = []\\n        helper(1, k, [], res)\\n        return res",
                "solutionTags": [],
                "code": "\\tdef combine(self, n: int, k: int) -> List[List[int]]:\\n\\t\\t\\tdef helper(index, newK, chosen, res):\\n\\t\\t\\t\\tif newK == 0:\\n\\t\\t\\t\\t\\tres.append(chosen[:])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfor i in range(index, n + 1):\\n\\t\\t\\t\\t\\t\\t# Choose\\n\\t\\t\\t\\t\\t\\tchosen.append(i)\\n\\t\\t\\t\\t\\t\\t# Explore\\n\\t\\t\\t\\t\\t\\thelper(i + 1, newK - 1, chosen, res)\\n\\t\\t\\t\\t\\t\\t# Unchoose\\n\\t\\t\\t\\t\\t\\tchosen.pop()\\n        res = []\\n        helper(1, k, [], res)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 315280,
                "title": "swift-100-beat-recursive-solution-why-so-fast",
                "content": "```\\nclass Solution {\\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\\n        \\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, 0, n, k)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ start: Int, _ n: Int, _ k: Int) {\\n        \\n        if k == 0 {\\n            res.append(temp)\\n            return\\n        }\\n        \\n        var i: Int = start\\n        \\n        while k < (n - i + 1) {\\n            \\n            temp.append(i + 1)\\n            helper(&res, &temp, i + 1, n, k - 1)\\n            temp.removeLast()\\n            \\n            i += 1\\n        }\\n    }\\n}\\n```\\n\\nThis just screams in Swift, seems worse than the iterative solution for CPP. Not sure the iussue is here.? Wh",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\\n        \\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, 0, n, k)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ start: Int, _ n: Int, _ k: Int) {\\n        \\n        if k == 0 {\\n            res.append(temp)\\n            return\\n        }\\n        \\n        var i: Int = start\\n        \\n        while k < (n - i + 1) {\\n            \\n            temp.append(i + 1)\\n            helper(&res, &temp, i + 1, n, k - 1)\\n            temp.removeLast()\\n            \\n            i += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315257,
                "title": "c-top-80-solution-recursive-mode-meh-not-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        helper(aResult, aTemp, 1, n, k);\\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> pTemp, int pStart, int n, int k) {\\n        if (k == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        int i=pStart;\\n        int aCmp = (n - k + 1);\\n        \\n        while (i <= aCmp) {\\n            \\n            pTemp.push_back(i);\\n            helper(pRes, pTemp, i + 1, n, k - 1);\\n            pTemp.pop_back();\\n            \\n            ++i;\\n        }\\n    }\\n    \\n};\\n```\\n\\nLEL, K",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        helper(aResult, aTemp, 1, n, k);\\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> pTemp, int pStart, int n, int k) {\\n        if (k == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        int i=pStart;\\n        int aCmp = (n - k + 1);\\n        \\n        while (i <= aCmp) {\\n            \\n            pTemp.push_back(i);\\n            helper(pRes, pTemp, i + 1, n, k - 1);\\n            pTemp.pop_back();\\n            \\n            ++i;\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312427,
                "title": "1-line-100-simple-ruby",
                "content": "\\n```ruby\\ndef combine(n, k)\\n  (1..n).to_a.combination(k).to_a\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef combine(n, k)\\n  (1..n).to_a.combination(k).to_a\\nend\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1713237,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1995109,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1568897,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1926151,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1995125,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1953413,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1717987,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1995137,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1770558,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1995167,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1713237,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1995109,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1568897,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1926151,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1995125,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1953413,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1717987,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1995137,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1770558,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1995167,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Guys, no solution needs to be published in this section, this section is for only discussion!!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Always encouraging to revisit problems you struggled with so hard before and now they're easy :)"
                    },
                    {
                        "username": "bryan3",
                        "content": "I got this error:\\n\\n    Input:\\t2, 2\\n    Output:\\t[[2,1]]\\n    Expected:\\t[[1,2]]\\n\\nI can easily flip the order and get OJ to accept, but why does the order matter?"
                    },
                    {
                        "username": "theCoderMonkey",
                        "content": "[@kjcjwj007](/kjcjwj007) Hey, I wonder how would we be doing after almost 10 years. Maybe if this still exists, comeback and leave a post!"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "[@deCodeIt](/deCodeIt) That\\'s almost 10 years. I wonder how this Bryan guy is doing right now."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Maybe it was way long back when you posted this but the order doesn\\'t matter as of today."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Here I provide other idea from backtracking. I prefer to use DP.\nLet's  solve it by Math. Consider the set \n$$ \nC_k^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots< i_k\\leq n\\}\n$$\nthen, it follows\n$$\nC_k^n=C_k^{n-1} \\cup C_{with\\ n}^n\n$$\nwhere\n$$\nC_{with\\ n}^n=\\{\\{i_1,\\cdots, i_k\\}|1\\leq i_1<\\cdots<i_{k-1}< i_k= n\\}\n$$.\nThe crucial part is that there exists an one-to-one correspondence between the sets $C_{k-1}^{n-1}$ and $C_{with\\ n}^n$ with\n$$\nv\\in C_{k-1}^{n-1} \\longrightarrow v\\cup \\{n \\} \\in C_{with\\ n}^n.\n$$"
                    },
                    {
                        "username": "hero080",
                        "content": "You don\\'t need math. The intuition is enough to know that.\\nInstead you should use math to proof that DP cannot improve the time/space complexity of this problem.\\n\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "N choose K, what a classic! "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "@Leetcode this is probably the easiest backtracking problem, so I would tag it as easy to signal that this is a good one to start with."
                    },
                    {
                        "username": "schatterjee380",
                        "content": "I believe everybody is different. Some people may find this easy. Some people will find this hard. As for difficulty,  I believe this problem should stay medium for people who are new to backtracking."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Back tracking? I just solved it with a simple recursive for loop. "
                    },
                    {
                        "username": "meow_power",
                        "content": "This question initially took me 4-5 days to grasp, this is not at all easy."
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) because backtracking isn\\'t an easy concept."
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "this problem is covering basic approach, It should be considered easy"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@2uringTested](/2uringTested) Its easy .. whats difficult in this ?\\n"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Definitely not"
                    },
                    {
                        "username": "vikasss",
                        "content": "why getting tle on last test case."
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "[@guptatanish145](/guptatanish145) Same thing happened with me passing all by reference solved the problem"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@noman598](/noman598)  Pass all the vector by reference. I got tle on 26th test case. I just passed my temp vector by reference then my solution got accepted."
                    },
                    {
                        "username": "noman598",
                        "content": "if(flag == k){\\n             ans.push_back(vec);\\n             return ;\\n         }\\nelse if(idx > n) return ;\\n\\nKeep base condition almost on this concept."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "If not familiar with backtracking it\\'s definitely worth it to go over some simple examples of it. Then the problem becomes easy, otherwise it\\'s pretty hard"
                    },
                    {
                        "username": "sneharatnani",
                        "content": "Can anyone explain what is the time complexity of this problem ? I saw some video solutions they are mostly explaining how to solve the problem but they are not really clear about the time complexity. "
                    },
                    {
                        "username": "hero080",
                        "content": "[@mshoosterman](/mshoosterman) That\\'s the lower bound. But in fact when you are building the answer, you also built the answer for all $n \\\\choose i$ where $0 \\\\le i \\\\le k$. Sum them up you get $O(2^n)$ when $k$ is not too small."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Time complexity should just be the length of the final list. So NCK. Or technically it should be NCK*K "
                    },
                    {
                        "username": "Jaiff",
                        "content": "IMO the complexity is O(k*2^n) as in the base case, we are copying the current result to the ans. "
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s $O(2^n)$. This is when you use $O$ rather than $\\\\Theta$ because if $k$ is small it\\'s much better than that, assuming your solution is similar to mine:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "2powerN (2^N)"
                    },
                    {
                        "username": "bezwish",
                        "content": "[@askold_ilvento](/askold_ilvento) Holy... I thought the time complexity for sliding window problems was bad"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Here we generate $n!/(n-k)!/k!$ arrays size of n.\nSo the output size of the problem is $n*n!/(n-k)!/k!$ \nInevitably the complexity (both time and memory) cannot be better. \nTo generate each array, $O(n)$ operations is enough (it is quite plain if you look at non-recursive solution).  \nThus the complexity is $O(n*n!/(n-k)!/k!)$. \nIt is easy to get upper bound for that bunch of factorials as $O(n^k)$. \nIf you need more accurate asymptotic than roughly it should be close to $O((n/e)^k)$. "
                    },
                    {
                        "username": "yren996",
                        "content": "A great problem to practice backtracking with!"
                    }
                ]
            },
            {
                "id": 1718843,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 1764519,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 2014694,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 1995238,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 1995095,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 1755615,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 2026365,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 1995755,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 1995373,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 1995198,
                "content": [
                    {
                        "username": "nurlan01",
                        "content": "Don\\'t post your answers here !!!"
                    },
                    {
                        "username": "yogwill",
                        "content": "Better explanation of recursive mechanism of this problem - \\n\\nhttps://www.youtube.com/watch?v=7IQHYbmuoVU"
                    },
                    {
                        "username": "killua8p",
                        "content": "If you are wondering why your Python solution is slower than 90% of users -- because most submissions have been using the builtin `itertools.combinations`. So your Backtracking / BFS based algorithm might still be pretty good despite what the result tells you.\\n\\nWhat is wrong with `itertools.combinations`?\\nNothing. In production, you will want to use it as it\\'s blazing fast.\\nIn interviews, you will want to avoid it as that\\'s not what interviewers are looking for."
                    },
                    {
                        "username": "VMAtm",
                        "content": "Agree. However, one can find a rough estimation of that function on the official docs page: https://docs.python.org/3/library/itertools.html#itertools.combinations\\n\\nIt\\'s not as fast as built-in, however, still beats a lot of submissions"
                    },
                    {
                        "username": "charant587",
                        "content": "Me who struggled more than an hour for this problem .... Now it\\'s under easiest category for me ........ Thanks leetcode for pushing me here ....."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is done before. Resubmit"
                    },
                    {
                        "username": "alksjdf12384",
                        "content": "Question with using backtracking:\\n# result: the final list of lists\\n# record: current path of list\\nWhile I\\'m checking the ending condition is met, and assign the record to the result, I have \\nresult.append(record)\\n\\nHowever, in python when I pop value from record afterward, the result global variable would be affect too\\n\\nThus I use copy() for that: reuslt.append(record.copy())\\nto avoid affecting the result\\n\\nThis is a waste of space, is there other solution to prevent result form changing while doing pop()?\\n\\n"
                    },
                    {
                        "username": "CC_Debjyoti",
                        "content": "Similar to Combination sum 3 Hint : pick and no pick "
                    },
                    {
                        "username": "VMAtm",
                        "content": "[Built-in function](https://docs.python.org/3/library/itertools.html#itertools.combinations) with some ideas to think about"
                    },
                    {
                        "username": "user5400vw",
                        "content": "here, i found focusing on the next possible iteration in a strictly increasing series of numbers simplifed things for me.\\n\\nP.S.  finding permutation (where 123 and 321 are different) is much more challenging and doesn\\'t allow for focusing on just increasing numbers!  thats where you do some fancy swap and reverse techniques, but another story for another day :D"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hmm, I feel like my solution is overly complicated then, because I could change it to work for all permutations, and it would probably even be simpler! For the permutation case you can just generate a list of all possible size k arrays with elements from 1 to n, and then just use a global boolean array to record which elements are currently already in the array as you fill it. then just skip steps where you would be adding in a duplicate. "
                    },
                    {
                        "username": "hero080",
                        "content": "You are absolutely right. This problem should be solved by the most intuitive way and it\\'s also the fastest way:\\nhttps://leetcode.com/problems/combinations/solutions/3846160/beat-100-o-k-2-n-no-brainer-solution-simple-dfs/"
                    },
                    {
                        "username": "SebastianKane",
                        "content": "Python technically has a one liner for this one... \\uD83D\\uDC40"
                    },
                    {
                        "username": "svinther",
                        "content": "If you are referring to this, it is actually C, not Python :-)\\nhttps://github.com/python/cpython/blob/main/Modules/itertoolsmodule.c"
                    }
                ]
            },
            {
                "id": 1993101,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 1995535,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 1996269,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 1674059,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 2069444,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 2044306,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 2034081,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 1996627,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 1996559,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 1996268,
                "content": [
                    {
                        "username": "herald13",
                        "content": "Hey guys, I have weird feeling after solving these recursive problems... I feel like I don\\'t understand how I just solved this... Very weird..."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes i get it, it happens to beginners solving recursive problems, try making the recursive tree and visualising the call stack, you will be habituated to you."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Everyone seems to copy the solution(s) of others and shit_posting in the solution window"
                    },
                    {
                        "username": "SohanaShabnam05",
                        "content": " vector<vector<int>> f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n    {\\n      if(temp.size() == k)\\n      {\\n        output.push_back(temp);\\n      }\\n\\n      for(int i=start; i<=n; i++)\\n      {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n      }\\n        return output;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        f(ans,temp,1, n, k);\\n        return ans;\\n    }   Why this code is showing TLE ?? For last testcase"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "As  you are returning the output vector in every recursion call, it is showing the TLE.\\nJust try to draw the recursion tree diagram and you will get to know the problem that is arising due to returning the output vector at every recursion call.\\nChange the return type of the function f() to void instead of vector<vector<int>>, remove the last line i.e return output and add return just after the output.push_back(temp); in the base condition. \\n// for reference\\nvoid f(vector<vector<int>>& output, vector<int>& temp, int start, int n, int k)\\n{\\n    if(temp.size() == k)\\n    {\\n        output.push_back(temp);\\n        return;\\n    }\\n    for(int i=start; i<=n; i++)\\n    {\\n        temp.push_back(i);\\n        f(output, temp, i+1, n, k);\\n        temp.pop_back();\\n    }  \\n}\\n//"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//Fast and efficient soln c++\\nclass Solution {\\npublic:\\n    void generatecombine(int start,int n,int k,vector<vector<int>>&ans,vector<int>&temp)\\n    {\\n        if(temp.size()==k){\\n            ans.push_back(temp);\\n             return; \\n        }\\n        for(int i=start;i<=n;i++)\\n        {\\n            temp.push_back(i);\\n            generatecombine(i+1,n,k,ans,temp);\\n            temp.pop_back();\\n        }\\n    }\\n   \\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>>ans;\\n        vector<int>temp;\\n        generatecombine(1,n,k,ans,temp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Report Done!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "\"\\uD83D\\uDCA1 Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\"\\n\\nlooks like you have trouble reading this."
                    },
                    {
                        "username": "SaurabhSingh1234",
                        "content": "I am getting Memory Limit Exceeded for 20,10"
                    },
                    {
                        "username": "sergei99",
                        "content": "How on Earth did the top coder achieve 2 ms execution time in C++ with the recursive stuff?\\n\\nFirst I\\'ve tried a flat solution of my own, just creating an array of [1, 2, 3, .., k] and incrementing its members in two nested loops. Got 100-110 ms. Killed stdio sync, added preallocation and replaced an inner linear search with a pointer retaining value between iterations. All I could achieve was 79 ms. It\\'s exactly same asymptotics, only low-order factors differ (and not in top solution\\'s favour). \"All right, that\\'s because I\\'m a f...ing noob, let\\'s try the real tough guy\\'s code\", - I thought. Took the top solution, spilled constant function parameters to members of \"this\", added prealloc again, played with inlining, etc... Got almost same 95-110 ms from several submissions AND a larger by 6 Mb memory consumption than that of my solution. I knew I was definitely a loser, but not to that extent. How could they possibly execute their code 40 times faster then? Or was there a test engine glitch, low number of test data may be?"
                    },
                    {
                        "username": "nguyenquoctuan61089",
                        "content": "has anyone tried with case n=20 and k=10?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me: this challenge is an excellent exercise for understanding and implementing the backtracking algorithm, a fundamental concept in computer science. It also helps solidify understanding of permutations, which are a crucial aspect of combinatorics and are widely used in different areas of computer science, like cryptography, game theory, and algorithm design."
                    },
                    {
                        "username": "akashrai02",
                        "content": "Can Anybody help why my code is not working.\nIt is returning empty list\n\nclass Solution {\n    public void backtracking(int ind,int n,int k,List<Integer>curr,List<List<Integer>> result){\n        if(ind == n+1 || k == 0) return;\n        curr.add(ind);\n        if(curr.size() == k){\n            result.add(curr);\n            return;\n        }\n        backtracking(ind+1,n,k-1,curr,result);\n        curr.remove(curr.size()-1);\n        backtracking(ind+1,n,k,curr,result);\n    }\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1,n,k,curr,result);\n        return result;\n    }\n}\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "hey i have made somw changes to ur current code. there where multiple issues with base case and the way u were putting value .\nhere is updated code\nclass Solution {\n    public void backtracking(int ind, int n, int k, List<Integer> curr, List<List<Integer>> result) {\n        if (k == 0) {\n            result.add(new ArrayList<>(curr)); \n            return;\n        }\n        if (ind == n + 1) return;\n\n\n        curr.add(ind);\n        backtracking(ind + 1, n, k - 1, curr, result);\n        curr.remove(curr.size() - 1);\n        backtracking(ind + 1, n, k, curr, result);\n    }\n\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> curr = new ArrayList<>();\n        backtracking(1, n, k, curr, result);\n        return result;\n    }\n}\nsee what changes i made, and feel free to comment ur doubt\nthe biggest reason why u were getting an empty result because ur code never able to put any curr arraylist to the result.\n see at the first line ur code says if k==0 return and in the recurence relation u r subtracting 1 from k, so obviously when the k value will become 0 it will simply return and nothing will happen to result.\n  in second base case when cursize==k u r adding ur cur to the result.but this will never happen . why ?\n suppose initially k=2 \nnow when i put cur=[1,2]  k will reduce to 0 because of recurrence relation. when the next call will see that k=0 it will return from the first line and never reach the 2nd base case. \nand even if it reaches the second base case since k is now 0 and cur.size() is now 2 thus if statement won't execute."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Wait I\\'ll check "
                    },
                    {
                        "username": "akashrai02",
                        "content": "[@souvikmkhrj](/souvikmkhrj) No it didn\\'t worked"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "the \\'curr\\' list is added to the \\'result\\' list, it is not creating a new instance of the list, but rather adding the same reference to the \\'curr\\' list. This means that all subsequent changes to \\'curr\\' will affect the previously added lists in \\'result\\'.thats why its returning empty stack. to avoid this just pass copy of current list  like this -- result.add(new ArrayList<>(curr));   i hope it helps."
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, never did really did backtracking but this problem was kinda straight forward. Nice!"
                    }
                ]
            },
            {
                "id": 1995937,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995684,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995555,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995513,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995487,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995470,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995465,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995439,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995351,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995327,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "short and straight forward\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "class Solution:\\n    def f(self,i,n,stack,ans,k):\\n        if k is 0:\\n            ans.append(stack.copy())\\n            return\\n\\n        # RECURENCE RELATION\\n        self.f(i+1,n,stack + [i],ans,k-1)\\n        self.f(i,n,stack+[i],ans,k) \\n            \\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans=[]\\n        stack=[]\\n        self.f(1,n,stack,ans,k)\\n        return ans\\ncan anyone tell me why i am getting memory limit Exceeded error?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "A very Classic Backtracking problem "
                    },
                    {
                        "username": "oops_moment",
                        "content": "EXPLORE ALL POSSIBLE WAYS : YES RECURSION ."
                    },
                    {
                        "username": "Vedant8",
                        "content": "Can someone help to fix this error !\\n\\nError -->\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'std::vector<int, std::allocator<int>>\\' (stl_vector.h)  \\n\\nCode -->\\nclass Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n       vector<vector<int>> v;\\n       int count = 1;\\n\\n       //Traversing integers\\n       for(int i=0; i<n; i++){\\n           for(int j=i+1; j<n; j++){\\n               while(count<=k){\\n                   v[i].push_back(j);\\n                   count++;\\n               }\\n               count = 1;\\n           }\\n           count = 1;\\n       }\\n       return v; \\n    }\\n};"
                    },
                    {
                        "username": "EricRaw",
                        "content": "in your code, you are trying to access the vector inside your 2d vector v without initializing its inner vectors \nthe code :\n```\nv[i].push_back(j);\n```\nlead to error because you are trying to access inner vectors which is still null"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***I was unable to solve this problem initially, but after revisiting it a second time, I managed to find a solution with a better time complexity.***"
                    },
                    {
                        "username": "algoacer",
                        "content": "One thing I learnt from this question is which base case should be before the other. It is very important to maintain the order of base cases failing which one might incur wrong answers. Starting my August Challenge, this was a good refresher.\\n\\nif(k==0){//this should be before\\nans.push_back(curr);\\nreturn;\\n}\\nif(i>n)return;//this should be after\\n\\nIt is so because what if we take the last element and goes to n+1 index, which means k is zero now and curr needs to be inserted in our answer before anything further."
                    },
                    {
                        "username": "gauravsodhani00",
                        "content": "When I write the following:\\n`pnc(n-1,k,vec);`\\n`vec.push_back(n);`\\n`pnc(n-1,k,vec);`\\nthis doesn\\'t work. But when I change the order to take number first and then pop it , it works:\\n `vec.push_back(n);`\\n  `pnc(n-1,k,vec);`\\n  `vec.pop_back();`\\n  `pnc(n-1,k,vec);`\\nWhy is that?\\nP.S. pnc is my recursive function call."
                    },
                    {
                        "username": "pri1311",
                        "content": "Im assuming you are passing the vector by reference. So when you modify the vector to add an element and dont remove it, the element will remain present in consecutive calls too. first approach might work when you pass vectors by value."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "An Easy!!!"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Note that example 1 pretty much gives away exactly what you need to do, assuming you know some Math\\'s you can write a recursive thing which recreates exactly that in a few loops."
                    }
                ]
            },
            {
                "id": 1995306,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1995296,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1995283,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1995279,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1995228,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1995172,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1987938,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1911096,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1910702,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            },
            {
                "id": 1903790,
                "content": [
                    {
                        "username": "farmanmohd124",
                        "content": "take or notake very simple recursion problem"
                    },
                    {
                        "username": "__AKASH_SINGH___",
                        "content": "Can anyone tell me why line number 3 giving Compile Error.\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<vector<int>>>> dp(21, vector<vector<vector<int>>>(21));\\n    vector<vector<int>> fun(int n, int k)\\n    {\\n        if(n==0 && k==0) return {{}};\\n        if(n<k || n<0 || k<0) return {};\\n        if(dp[n][k].size()) return dp[n][k];\\n        vector<vector<int>> ans = fun(n-1, k);\\n        vector<vector<int>> temp = fun(n-1, k-1);\\n        for(auto it: temp)\\n        {\\n            it.push_back(n);\\n            ans.push_back(it);\\n        }\\n        return dp[n][k] = ans;\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        return fun(n, k);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes, because its a class and you cannot initialize the dp vector  or any variable for that matter in the class itself, if you want to do it then do it in the constructor or in the combine function.\\n\\nfor example:\\n\\n```\\nvector<vector<vector<vector>>> dp;\\nSolution(){\\n    dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n}\\n\\n```\\n\\nor you can do it in the combine function:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<vector<vector>>> dp;\\n    vector<vector<int>> combine(int n, int k) { \\n\\n        dp = vector<vector<vector<vector>>>(21, vector<vector<vector>>(21));\\n        return fun(n,k);\\n\\n    }\\n};\\n```\\n\\n\\n    "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The constraints `1 <= n <= 20` and `1 <= k <= n` point at using backtracking.\\n\\nAt a very high level start by creating a recursive function where you loop from a...b and add to list as element at first position. See how you can use this to figure out next set of elements."
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "Simple Recursion + backtracking problem"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Surprised that brute force worked"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Prefer old classic problems for daily challenge!"
                    },
                    {
                        "username": "carol_king",
                        "content": "I initially did exclude before include, but it didn\\'t work (call recursive function, append value, call function again). It worked if I include before I exclude. Why would this be?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 The time complexity of Pick and drop recursive method would  be k * n!\\nso we have to think of a good solution"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why did the my solution is showing memory limit exceeded\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int n, int k, vector<int> subs, int i=1){\\n        if(i == n+2) return ;\\n        if(subs.size() == k) {\\n            ans.push_back(subs);\\n            return ;\\n        }\\n        subs.push_back(i);\\n        solve(n, k, subs, i+1);\\n        subs.pop_back();\\n        solve(n, k, subs, i+1);\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<int> subs ={};\\n        solve(n, k, subs, 1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "DDKK64",
                        "content": "For C++ users, use `std::move` to hint compiler to avoid temporary vector copy."
                    }
                ]
            }
        ]
    }
]