[
    {
        "title": "Fair Candy Swap",
        "question_content": "Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has.\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\nReturn an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.\n&nbsp;\nExample 1:\n\nInput: aliceSizes = [1,1], bobSizes = [2,2]\nOutput: [1,2]\n\nExample 2:\n\nInput: aliceSizes = [1,2], bobSizes = [2,3]\nOutput: [1,2]\n\nExample 3:\n\nInput: aliceSizes = [2], bobSizes = [1,3]\nOutput: [2,3]\n\n&nbsp;\nConstraints:\n\n\t1 <= aliceSizes.length, bobSizes.length <= 104\n\t1 <= aliceSizes[i], bobSizes[j] <= 105\n\tAlice and Bob have a different total number of candies.\n\tThere will be at least one valid answer for the given input.",
        "solutions": [
            {
                "id": 161269,
                "title": "c-java-python-straight-forward",
                "content": "Calculate `dif = (sum(A) - sum(B)) / 2`\\nWe want find a pair `(a, b)` with `a = b + dif`\\n\\n**Time Complexity**:\\nO(N)\\n\\n**C++:**\\n```\\n    vector<int> fairCandySwap(vector<int> A, vector<int> B) {\\n        int dif = (accumulate(A.begin(), A.end(), 0) - accumulate(B.begin(), B.end(), 0)) / 2;\\n        unordered_set<int> S(A.begin(), A.end());\\n        for (int b: B)\\n            if (S.count(b + dif))\\n                return {b + dif, b};\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int dif = (IntStream.of(A).sum() - IntStream.of(B).sum()) / 2;\\n        HashSet<Integer> S = new HashSet<>();\\n        for (int a : A) S.add(a);\\n        for (int b : B) if (S.contains(b + dif)) return new int[] {b + dif, b};\\n        return new int[0];\\n    }\\n```\\n**Python:**\\n```\\n    def fairCandySwap(self, A, B):\\n        dif = (sum(A) - sum(B)) / 2\\n        A = set(A)\\n        for b in set(B):\\n            if dif + b in A:\\n                return [dif + b, b]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    vector<int> fairCandySwap(vector<int> A, vector<int> B) {\\n        int dif = (accumulate(A.begin(), A.end(), 0) - accumulate(B.begin(), B.end(), 0)) / 2;\\n        unordered_set<int> S(A.begin(), A.end());\\n        for (int b: B)\\n            if (S.count(b + dif))\\n                return {b + dif, b};\\n    }\\n```\n```\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int dif = (IntStream.of(A).sum() - IntStream.of(B).sum()) / 2;\\n        HashSet<Integer> S = new HashSet<>();\\n        for (int a : A) S.add(a);\\n        for (int b : B) if (S.contains(b + dif)) return new int[] {b + dif, b};\\n        return new int[0];\\n    }\\n```\n```\\n    def fairCandySwap(self, A, B):\\n        dif = (sum(A) - sum(B)) / 2\\n        A = set(A)\\n        for b in set(B):\\n            if dif + b in A:\\n                return [dif + b, b]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161316,
                "title": "java-2-solutions-clear-explanation-with-illustration",
                "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/marswork/image_1534651707.png)\\nTherefore, our target is to find a candy pair whose difference is exactly `x/2`\\nif B > A, logic is exactly the same\\n#### Sol1 Brute Force \\ntime complexity:`O(A + B + A * B)`\\nspace  complexity:`O(1)`\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0, sumB = 0;\\n        for (int i = 0; i < A.length; i++)\\n            sumA += A[i];\\n        for (int i = 0; i < B.length; i++)\\n            sumB += B[i];\\n        int dif = (sumA - sumB) / 2;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                if (A[i] - B[j] == dif)\\n                    return new int[]{A[i], B[j]};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n#### Sol2 Use Hash Set \\ntime complexity: `O(A + B)`\\nspace complexity: `O(A)`\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0, sumB = 0;\\n        Set<Integer> setA = new HashSet<>();\\n        for (int i = 0; i < A.length; i++) {\\n            sumA += A[i];\\n            setA.add(A[i]);\\n        }\\n        for (int i = 0; i < B.length; i++)\\n            sumB += B[i];\\n        int dif = (sumA - sumB) / 2;\\n        for (int i = 0; i < B.length; i++) {\\n            int targetA = B[i] + dif;\\n            if (setA.contains(targetA))\\n                return new int[]{targetA, B[i]};\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0, sumB = 0;\\n        for (int i = 0; i < A.length; i++)\\n            sumA += A[i];\\n        for (int i = 0; i < B.length; i++)\\n            sumB += B[i];\\n        int dif = (sumA - sumB) / 2;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                if (A[i] - B[j] == dif)\\n                    return new int[]{A[i], B[j]};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0, sumB = 0;\\n        Set<Integer> setA = new HashSet<>();\\n        for (int i = 0; i < A.length; i++) {\\n            sumA += A[i];\\n            setA.add(A[i]);\\n        }\\n        for (int i = 0; i < B.length; i++)\\n            sumB += B[i];\\n        int dif = (sumA - sumB) / 2;\\n        for (int i = 0; i < B.length; i++) {\\n            int targetA = B[i] + dif;\\n            if (setA.contains(targetA))\\n                return new int[]{targetA, B[i]};\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826376,
                "title": "c-6-lines",
                "content": "**Prerequiste:**\\n` `sumA -x + y = sumB +x -y\\n` `2y = 2x + sumB - sum A\\n` `y = x+ (sumB-sumA)/2\\n\\n**Explanation:**\\n` `Alice has sumA candies and gives x candies to Bob which has sumB candies. Besides, Bob gives y candies to Alice. They need to have same number of the candies.\\n\\n**C++:**\\n\\n```\\nvector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n\\tint sumA = accumulate(A.begin(),A.end(),0), sumB = accumulate(B.begin(), B.end(),0);\\n\\tint tmp = (sumB-sumA)/2;\\n\\tset<int> stA(A.begin(),A.end()),stB(B.begin(),B.end());\\n\\tfor(auto &x:stA)\\n\\t  if(stB.find(x+tmp)!=stB.end()) return {x,x+tmp};\\n\\treturn {0,0};\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n\\tint sumA = accumulate(A.begin(),A.end(),0), sumB = accumulate(B.begin(), B.end(),0);\\n\\tint tmp = (sumB-sumA)/2;\\n\\tset<int> stA(A.begin(),A.end()),stB(B.begin(),B.end());\\n\\tfor(auto &x:stA)\\n\\t  if(stB.find(x+tmp)!=stB.end()) return {x,x+tmp};\\n\\treturn {0,0};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209748,
                "title": "c-24-ms-99-o-n-solution-using-bitfield",
                "content": "The intuition is based on the equation for solving this problem: sumA - A + B = sumB + A - B.\\n\\nSimplifying this equation yields: 2*B = sumB - sumA + 2*A = 2*A - (sumA - sumB).\\n\\nThus, we need to go through each number in A, and see if there is a corresponding number in B that matches the equality. To do this, we can put numbers of B into a set, and then go through  A and see if there is a nubmer in set B that works.\\n\\nSince we only need to mark numbers, and the range of values are small, we can use a bitfield instead of a set. This saves space, which makes it more cache friendly. It also saves some overhead from doing hashes. (Using a set requires about 100ms run-time).\\n\\nThe time complexity is O(n + m), where n is size of A and m size of B. The space complexity is 200002 bits, which is about 25 KB, which fits inside most L1 caches.\\n\\nNote: Not sure if it is problem with my code or with LeetCode, but the first time I submitted this solution I got time limit exceeded, but the second time it is 24 ms.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        bitset<200002> bf;\\n        \\n        int sumA = 0, sumB = 0;\\n        for(auto n: A) {\\n            sumA += n;\\n        }\\n        for(auto n: B) {\\n            sumB += n;\\n            bf.set(2*n);\\n        }\\n        \\n        int diff = sumA - sumB;\\n        \\n        for(auto n: A) {\\n            int det = 2*n - diff;\\n            if(det > 0 && det < 200002 && bf.test(det)) {\\n                return {n, (2*n-diff)/2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        bitset<200002> bf;\\n        \\n        int sumA = 0, sumB = 0;\\n        for(auto n: A) {\\n            sumA += n;\\n        }\\n        for(auto n: B) {\\n            sumB += n;\\n            bf.set(2*n);\\n        }\\n        \\n        int diff = sumA - sumB;\\n        \\n        for(auto n: A) {\\n            int det = 2*n - diff;\\n            if(det > 0 && det < 200002 && bf.test(det)) {\\n                return {n, (2*n-diff)/2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3442225,
                "title": "brute-force-binary-search-hashmap",
                "content": "# Brute Force Intuition + Approach\\nJust consider every possible pair, and try to match one element `aliceCandies[i]` from alice and another element `bobCandies[j]` from bob. \\n\\nReturn when \\n```\\n  total(aliceCandies) - aliceCandies[i] + bobCandies[j] \\nequals\\n  total(bobCandies) - bobCandies[j] + aliceCandies[j]\\n```\\n\\nwhere\\n`total(aliceCandies) = all candies initially owned by alice`\\n`total(bobCandies) = all candies initially owned by alice`\\n`aliceCandies[i] = chosen box of candies to trade FROM alice`\\n`bobCandies[i] = chosen box of candies to trade FROM bob`\\n\\n# Complexity\\n- Time complexity:\\nO(mn) - m is length of array from alice, and n is length of array from bob\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes) aliceTotal += candies;\\n    for (int candies : bobSizes) bobTotal += candies;\\n    \\n    int m = aliceSizes.length, n = bobSizes.length;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++)\\n        if ((aliceTotal - aliceSizes[i] + bobSizes[j]) == (bobTotal - bobSizes[j] + aliceSizes[i]))\\n          return new int[] { aliceSizes[i], bobSizes[j] };\\n\\n    return new int[0];\\n  }\\n```\\n\\n# Binary Search Intuition + Approach\\nThis builds off of previous solution by taking advantage of \\nthe formula:\\n\\n```\\n(aliceTotal - aliceSizes[i] + bobSizes[j]) == (bobTotal - bobSizes[j] + aliceSizes[i])\\n```\\n\\nwhere\\n`total(aliceCandies) = all candies initially owned by alice`\\n`total(bobCandies) = all candies initially owned by alice`\\n`aliceCandies[i] = chosen box of candies to trade FROM alice`\\n`bobCandies[i] = chosen box of candies to trade FROM bob`\\n\\nBecause we know that what alice is trading is proportional to what bob is losing and bob\\'s total, we arrive to the following formula to find `bobSizes[j]`, which is what bob needs to trade to get an equivalent total from both sides:\\n```\\nA_total - A[i] + B[j] = B_total - B[j] + A[i]\\nB[j] + A_total - A[i] + B[j] = B_total + A[i]\\n2 * B[j] + A_total - A[i] = B_total + A[i]\\n2 * B[j] + A_total = B_total + A[i] + A[i]\\n2 * B[j] + A_total = B_total + 2 * A[i]\\n2 * B[j] = B_total - A_total + 2 * A[i]\\nB[j] = (B_total - A_total + 2 * A[i]) / 2\\n```\\n`B[j]` in this case is equivalent to `target` in the code that we are going to binary search every ith iteration, in bob\\'s array.\\n\\nHowever, first need to sort bob\\'s array to be able to perform binary search.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn + mlogn) - m is length of array from alice, and n is length of array from bob\\n\\n- Space complexity:\\nO(1) - no extra space is used\\n\\n# Code\\n```\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes)\\n      aliceTotal += candies;\\n    for (int candies : bobSizes)\\n      bobTotal += candies;\\n    \\n    Arrays.sort(bobSizes);\\n    \\n    int m = aliceSizes.length, n = bobSizes.length;\\n    for (int i = 0; i < m; i++) {      \\n      int target = (bobTotal + 2 * aliceSizes[i] - aliceTotal) / 2;\\n      if (binarySearch(bobSizes, target))\\n        return new int[] { aliceSizes[i], target };\\n    }\\n\\n    return new int[0];\\n  }\\n\\n  private boolean binarySearch(int[] arr, int target) {\\n    int l = 0, r = arr.length - 1;\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n      if (target < arr[m])\\n        r = m - 1;\\n      else if (target > arr[m])\\n        l = m + 1;\\n      else\\n        return true;\\n    }\\n    return false;\\n  }\\n```\\n\\n# HashMap Intuition + Approach\\nThis again builds on previous intuition, where we can figure out hte corresponding pair that must be traded from bob. Store a hashmap of pairing between what alice trade (`A[i]`), and the calculation of what bob must trade.\\n\\nDo a first pass on alice array to compute all keys (trades from bob that must satisfy the formula, given a trade from alice `A[i]`)\\n\\nDo another pass on bob\\'s array, If the key existts in hashmap, then we found a pair, because this was precomputed in first pass.\\n\\n# Complexity\\n- Time complexity:\\nO(m + n) - m is length of array from alice, and n is length of array from bob\\n\\n- Space complexity:\\nO(m) - For storing the target pairs from alice array, m is the length fo the array from alice\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes) aliceTotal += candies;\\n    for (int candies : bobSizes) bobTotal += candies;\\n        \\n    Set<Integer> targets = new HashSet<>();\\n    for (int i = 0, m = aliceSizes.length; i < m; i++)\\n      targets.add((bobTotal - aliceTotal + 2 * aliceSizes[i]) / 2);\\n\\n    for (int j = 0, n = bobSizes.length; j < n; j++)\\n      if (targets.contains(bobSizes[j]))\\n        return new int[] { (aliceTotal + 2 * bobSizes[j] - bobTotal) / 2, bobSizes[j] };\\n\\n    return new int[0];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n  total(aliceCandies) - aliceCandies[i] + bobCandies[j] \\nequals\\n  total(bobCandies) - bobCandies[j] + aliceCandies[j]\\n```\n```\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes) aliceTotal += candies;\\n    for (int candies : bobSizes) bobTotal += candies;\\n    \\n    int m = aliceSizes.length, n = bobSizes.length;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++)\\n        if ((aliceTotal - aliceSizes[i] + bobSizes[j]) == (bobTotal - bobSizes[j] + aliceSizes[i]))\\n          return new int[] { aliceSizes[i], bobSizes[j] };\\n\\n    return new int[0];\\n  }\\n```\n```\\n(aliceTotal - aliceSizes[i] + bobSizes[j]) == (bobTotal - bobSizes[j] + aliceSizes[i])\\n```\n```\\nA_total - A[i] + B[j] = B_total - B[j] + A[i]\\nB[j] + A_total - A[i] + B[j] = B_total + A[i]\\n2 * B[j] + A_total - A[i] = B_total + A[i]\\n2 * B[j] + A_total = B_total + A[i] + A[i]\\n2 * B[j] + A_total = B_total + 2 * A[i]\\n2 * B[j] = B_total - A_total + 2 * A[i]\\nB[j] = (B_total - A_total + 2 * A[i]) / 2\\n```\n```\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes)\\n      aliceTotal += candies;\\n    for (int candies : bobSizes)\\n      bobTotal += candies;\\n    \\n    Arrays.sort(bobSizes);\\n    \\n    int m = aliceSizes.length, n = bobSizes.length;\\n    for (int i = 0; i < m; i++) {      \\n      int target = (bobTotal + 2 * aliceSizes[i] - aliceTotal) / 2;\\n      if (binarySearch(bobSizes, target))\\n        return new int[] { aliceSizes[i], target };\\n    }\\n\\n    return new int[0];\\n  }\\n\\n  private boolean binarySearch(int[] arr, int target) {\\n    int l = 0, r = arr.length - 1;\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n      if (target < arr[m])\\n        r = m - 1;\\n      else if (target > arr[m])\\n        l = m + 1;\\n      else\\n        return true;\\n    }\\n    return false;\\n  }\\n```\n```\\nclass Solution {\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes) aliceTotal += candies;\\n    for (int candies : bobSizes) bobTotal += candies;\\n        \\n    Set<Integer> targets = new HashSet<>();\\n    for (int i = 0, m = aliceSizes.length; i < m; i++)\\n      targets.add((bobTotal - aliceTotal + 2 * aliceSizes[i]) / 2);\\n\\n    for (int j = 0, n = bobSizes.length; j < n; j++)\\n      if (targets.contains(bobSizes[j]))\\n        return new int[] { (aliceTotal + 2 * bobSizes[j] - bobTotal) / 2, bobSizes[j] };\\n\\n    return new int[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554019,
                "title": "java-easy-to-understand-o-1-space-binary-search",
                "content": "Let Sum of choclates by Alice Be Sa and Sum of choclates by Alice Be Sb\\n\\nLet the choclates from Alice to Bob be A and from Bob to Alice be B\\n\\nSa -A + B = Sb -B+A\\n2(A-B) = (Sa-Sb)\\nA-B = (Sa-Sb)/2\\nA = B+(Sa-Sb)/2\\n\\nSo the goal is to search the elements of Alice such that Bob + (Diff of Sum) exists in the Alice \\nFor optimisation Alice is sorted and Binary search is applied on Alice\\n\\n\\n```\\nclass Solution {\\n    \\n    private int binarySearch(int[] arr,int target){ \\n        int s=0,e = arr.length-1;\\n        \\n        while(s<=e){\\n            int mid = s+ (e-s)/2;\\n            if(arr[mid]==target) return mid;\\n            else if(arr[mid]<target) s=mid+1;\\n            else e=mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n    \\n    public int[] fairCandySwap(int[] a, int[] b) { //a = Alice , b=Bob\\n        int suma=0,sumb=0;\\n        for(int i=0;i<a.length;i++)\\n            suma+=a[i];\\n        for(int i=0;i<b.length;i++)\\n            sumb+=b[i];\\n        \\n        int diff = (suma-sumb)/2;\\n        \\n        Arrays.sort(a);\\n        for(int num:b){\\n            if (binarySearch(a,num+diff) !=-1) return new int[]{num+diff,num};\\n        }\\n        \\n        return null;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int binarySearch(int[] arr,int target){ \\n        int s=0,e = arr.length-1;\\n        \\n        while(s<=e){\\n            int mid = s+ (e-s)/2;\\n            if(arr[mid]==target) return mid;\\n            else if(arr[mid]<target) s=mid+1;\\n            else e=mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n    \\n    public int[] fairCandySwap(int[] a, int[] b) { //a = Alice , b=Bob\\n        int suma=0,sumb=0;\\n        for(int i=0;i<a.length;i++)\\n            suma+=a[i];\\n        for(int i=0;i<b.length;i++)\\n            sumb+=b[i];\\n        \\n        int diff = (suma-sumb)/2;\\n        \\n        Arrays.sort(a);\\n        for(int num:b){\\n            if (binarySearch(a,num+diff) !=-1) return new int[]{num+diff,num};\\n        }\\n        \\n        return null;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675821,
                "title": "binary-search-java-not-easy-level",
                "content": "*Let Sum of choclates by Alice Be Sa and Sum of choclates by Alice Be Sb\\n\\nLet the choclates from Alice to Bob be A and from Bob to Alice be B\\n\\nSa -A + B = Sb -B+A\\n2(A-B) = (Sa-Sb)\\nA-B = (Sa-Sb)/2\\nA = B+(Sa-Sb)/2\\n\\nSo the goal is to search the elements of Alice such that Bob + (Diff of Sum) exists in the Alice\\nFor optimisation Alice is sorted and Binary search is applied on Alice*\\n\\ni don\\'t think this question is an easy level question !! What do you think ?\\n\\n```\\nclass Solution {\\n    private int binarySearch(int[] arr,int target){ \\n\\n        int s = 0, e = arr.length-1;\\n        \\n        while(s <= e)\\n        {\\n            int mid = s + (e-s)/2;\\n            if(arr[mid] == target) return mid;\\n            else if(arr[mid] < target) s=mid+1;\\n            else e = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] fairCandySwap(int[] a, int[] b) { //a = Alice , b=Bob\\n\\n        int suma=0,sumb=0;\\n        for(int i = 0; i < a.length; i++)\\n            suma += a[i];\\n        \\n        for(int i = 0; i < b.length; i++)\\n            sumb +=b [i];\\n        \\n        int diff = (suma - sumb)/2;\\n        \\n        Arrays.sort(a);\\n        for(int num : b)\\n        {\\n            if (binarySearch(a, num + diff) !=-1) \\n                return new int[] { num + diff, num };\\n        }\\n        \\n        return null;\\n    }\\n}\\n```\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/26c10ed8-4af3-4b8e-9baa-9f486ad1ab0e_1674298298.8688552.webp)\\n\\n\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348) Thanks for voting !!**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int binarySearch(int[] arr,int target){ \\n\\n        int s = 0, e = arr.length-1;\\n        \\n        while(s <= e)\\n        {\\n            int mid = s + (e-s)/2;\\n            if(arr[mid] == target) return mid;\\n            else if(arr[mid] < target) s=mid+1;\\n            else e = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] fairCandySwap(int[] a, int[] b) { //a = Alice , b=Bob\\n\\n        int suma=0,sumb=0;\\n        for(int i = 0; i < a.length; i++)\\n            suma += a[i];\\n        \\n        for(int i = 0; i < b.length; i++)\\n            sumb +=b [i];\\n        \\n        int diff = (suma - sumb)/2;\\n        \\n        Arrays.sort(a);\\n        for(int num : b)\\n        {\\n            if (binarySearch(a, num + diff) !=-1) \\n                return new int[] { num + diff, num };\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088075,
                "title": "python-super-simple-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        difference = (sum(A) - sum(B)) / 2\\n        A = set(A)\\n        for candy in set(B):\\n            if difference + candy in A:\\n                return [difference + candy, candy]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        difference = (sum(A) - sum(B)) / 2\\n        A = set(A)\\n        for candy in set(B):\\n            if difference + candy in A:\\n                return [difference + candy, candy]",
                "codeTag": "Java"
            },
            {
                "id": 174893,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        //\\n        // Note that the problem statement says that Alice and Bob need to exchange one candy each, no more or no less.\\n        //\\n        // Assume x needs to be removed and y needs to be added to A to equalize, so:\\n        //  Sum(A) - x + y = Sum(B) - y + x\\n        //  therefore, Sum(A) - Sum(B) = -2y + 2x\\n        //  therefore, x = ((Sum(A) - Sum(B)) / 2) + y\\n        //  lets call ((Sum(A) - Sum(B)) / 2), delta\\n        //\\n        \\n        int sumA = 0;\\n        int sumB = 0;\\n        \\n        for (auto e : A)\\n            sumA += e;\\n        \\n        for (auto e : B)\\n            sumB += e;\\n        \\n        int delta = (sumA - sumB) / 2;\\n        \\n        set<int> searchA;\\n        for (auto x : A)\\n        {\\n            //cout << x << endl;\\n            searchA.insert(x);\\n        }\\n        \\n        \\n        //cout << endl;\\n        for (auto y : B)    \\n        {\\n            //cout << y << setw(5) << delta + y << endl;\\n            if (searchA.count(delta + y) > 0)\\n            {\\n                return vector<int>{delta + y, y};\\n            }\\n        }\\n        \\n        return vector<int>();\\n    }",
                "solutionTags": [],
                "code": "    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        //\\n        // Note that the problem statement says that Alice and Bob need to exchange one candy each, no more or no less.\\n        //\\n        // Assume x needs to be removed and y needs to be added to A to equalize, so:\\n        //  Sum(A) - x + y = Sum(B) - y + x\\n        //  therefore, Sum(A) - Sum(B) = -2y + 2x\\n        //  therefore, x = ((Sum(A) - Sum(B)) / 2) + y\\n        //  lets call ((Sum(A) - Sum(B)) / 2), delta\\n        //\\n        \\n        int sumA = 0;\\n        int sumB = 0;\\n        \\n        for (auto e : A)\\n            sumA += e;\\n        \\n        for (auto e : B)\\n            sumB += e;\\n        \\n        int delta = (sumA - sumB) / 2;\\n        \\n        set<int> searchA;\\n        for (auto x : A)\\n        {\\n            //cout << x << endl;\\n            searchA.insert(x);\\n        }\\n        \\n        \\n        //cout << endl;\\n        for (auto y : B)    \\n        {\\n            //cout << y << setw(5) << delta + y << endl;\\n            if (searchA.count(delta + y) > 0)\\n            {\\n                return vector<int>{delta + y, y};\\n            }\\n        }\\n        \\n        return vector<int>();\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2727134,
                "title": "c-5-different-approaches-brute-force-hash-set-bitset-binary-search-two-pointers",
                "content": "Please let me know if you have suggestions for an other approach or how to improve one of the approaches below.\\n\\n## Intuition\\n\\nIf Alice has a total of $$a$$ candies and Bob has a total of $$b$$ candies, then the target both need to hit is $$\\\\frac{a + b}{2}$$. Let\\'s assume $$a > b$$, then Alices needs to end up with $$d = \\\\frac{a - b}{2}$$ fewer canides than she has now, and likewise Bob needs $$d$$ more.  If Alices gives $$x$$ candies to Bob, then Bob needs to give Alice $$y = x - d$$ candies back, so that both hit the target number.  The question is now what is $$x$$ and $$y$$? Or stated differently if we pick a candy box from Alice with size $$x$$, does Bob have a candy box of size $$y$$?\\n\\n## Approach 1: brute force (572ms)\\n\\nIt was a bit surprising that this approach is still fast enough to pass.\\n\\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, const vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        // assert((sum_a - sum_b) % 2 == 0);\\n        const int diff = (sum_a - sum_b) / 2;\\n        for (int a : A)\\n            for (int b : B)\\n                if (a - b == diff) return {a, b};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\nNote that instead of ```std::reduce``` ```std::accumulate``` could have been used as well.\\n\\n**Complexity Analysis**\\nLet $$m$$ be the number of candy boxes Alice has (```size(A)```) and $$n$$ be the number of candy boxes Bob has (```size(B)```) then the\\n  * Time complexity is $$O(m * n)$$ as we are looping over all combinations, and the\\n  * Space complexity is $$O(1)$$ quite obviously.\\n\\n## afterthought\\n\\nI was trying to make this approach TLE by generating test cases with the following code:\\n\\n```py\\ndef gen(n):\\n  print(str([2 for i in range(n)] + [5]).replace(\", \", \",\"))\\n  print(str([2 for i in range(n - 1)] + [3]).replace(\", \", \",\"))\\n```\\n\\nThis yields test cases like this:\\n\\n```text\\n>>> gen(10)\\n[2,2,2,2,2,2,2,2,2,2,5]\\n[2,2,2,2,2,2,2,2,2,3]\\n```\\n\\nThe answer for a test case like this is always ```[5,3]```, but even a test case generated with ```gen(9999)``` which is the longest possible test case still passes.\\n\\n## Approach 2: hash set (99ms)\\n\\nInstead of linear scan over all of Bob\\'s candy boxes for each of Alice\\'s boxes, we can create an index using a hash set.\\n\\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, const vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n        \\n        const unordered_set<int> B_set(begin(B), end(B));\\n        \\n        for (int a : A)\\n            if (B_set.count(a - diff)) return {a, a - diff};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$m$$ be the number of candy boxes Alice has (```size(A)```) and $$n$$ be the number of candy boxes Bob has (```size(B)```) then the\\n  * Time complexity is $$O(m)$$ as we need to lookup for each of Alice\\'s boxes in $$O(1)$$ time of Bob has a matching box, and we need $$O(n)$$ for building the hash set, so that\\'s a total of $$O(m + n)$$, and the\\n  * Space complexity is $$O(n)$$ for creating the index of Bob\\'s boxes.\\n\\n## Approch 3: bitset (79 ms)\\n\\nThis input range is limited enough that we can use a ```bitset<>``` instead of a hash set, and this seems to perform also better than the hashset.\\n\\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n\\n        bitset<128 * 1024> B_set;\\n        for (int b : B) B_set.set(b);\\n\\n        for (int a : A) {\\n            const int b = a - diff;\\n            if (b > 0 && b < size(B_set) && B_set[b]) return {a, b};\\n        }\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\n**Complexity Analysis**\\nAs above $$m$$ is ```size(A)``` and $$n$$ is ```size(B)``` then the\\n  * Time complexity is $$O(m + n)$$ as we need to scan boths inputs and the rest is linear, and the\\n  * Space complexity is $$O(1)$$ albeit its a very big 1 as we need 16k for the bitset.\\n\\n## Approach 4: sort and binary search (69ms)\\n\\nInstead of using a hash set as an index we can also sort Bob\\'s boxes and use binary search.\\n\\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n        \\n        sort(begin(B), end(B));\\n        \\n        for (int a : A)\\n            if (binary_search(begin(B), end(B), a - diff)) return {a, a - diff};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\n**Complexity Analysis**\\nAs above $$m$$ is ```size(A)``` and $$n$$ is ```size(B)``` then the\\n  * Time complexity is $$O(m \\\\log n)$$ for the $$m$$ times binary search in an array of lenght $$n$$, and we need $$O(n \\\\log n)$$ to sort Bob\\'s boxes, that\\'s a total of $$O((m + n) \\\\log n)$$\\n  * Space complexity is $$O(1)$$ assuming we can sort ```B``` in place.\\n\\nThis seems to be again an example where the constant factors in the complexity analysis matter. While approach 2 has better asymptotic runtime of this seems to be faster.\\n\\n## Approach 5: two pointers (101ms)\\n\\nThis is based on a [post](https://leetcode.com/problems/fair-candy-swap/discuss/264171/Python-two-pointers) by @iamhehe.\\n\\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n\\n        sort(begin(A), end(A));\\n        sort(begin(B), end(B));\\n        \\n        for (int i = 0, j = 0; i < size(A) && j < size(B); ) {\\n            const int d = A[i] - B[j];\\n            if (d == diff) return {A[i], B[j]};\\n\\n            if (d < diff) {\\n                ++i;\\n            } else {\\n                ++j;\\n            }\\n        }\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\n**Complexity Analysis**\\nAs above $$m$$ is ```size(A)``` and $$n$$ is ```size(B)``` then the\\n  * Time complexity is $$O(m \\\\log m + n \\\\log n + n + m)$$ for sorting the two arrays and then the search with two pointers that touches each element at most once, and the\\n  * Space complexity is $$O(1)$$.\\n\\nThis result makes me wonder if this is just another testiment for the poor performance of the hash set / hash map implemention in the standard library.\\n\\n\\n## Appendix\\n\\nFor some approaches it would be beneficial to sort or index the smaller or larger array. To accompblish this we could add the following code at the beginning of these approaches:\\n\\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        if (size(B) > size(A)) {\\n            vector<int> tmp = fairCandySwap(B, A);\\n            return {tmp[1], tmp[0]};\\n        }\\n        assert(size(B) <= size(A));\\n\\n        // Here goes the remaining code ...\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, const vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        // assert((sum_a - sum_b) % 2 == 0);\\n        const int diff = (sum_a - sum_b) / 2;\\n        for (int a : A)\\n            for (int b : B)\\n                if (a - b == diff) return {a, b};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```std::reduce```\n```std::accumulate```\n```size(A)```\n```size(B)```\n```py\\ndef gen(n):\\n  print(str([2 for i in range(n)] + [5]).replace(\", \", \",\"))\\n  print(str([2 for i in range(n - 1)] + [3]).replace(\", \", \",\"))\\n```\n```text\\n>>> gen(10)\\n[2,2,2,2,2,2,2,2,2,2,5]\\n[2,2,2,2,2,2,2,2,2,3]\\n```\n```[5,3]```\n```gen(9999)```\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, const vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n        \\n        const unordered_set<int> B_set(begin(B), end(B));\\n        \\n        for (int a : A)\\n            if (B_set.count(a - diff)) return {a, a - diff};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```size(A)```\n```size(B)```\n```bitset<>```\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n\\n        bitset<128 * 1024> B_set;\\n        for (int b : B) B_set.set(b);\\n\\n        for (int a : A) {\\n            const int b = a - diff;\\n            if (b > 0 && b < size(B_set) && B_set[b]) return {a, b};\\n        }\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```size(A)```\n```size(B)```\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n        \\n        sort(begin(B), end(B));\\n        \\n        for (int a : A)\\n            if (binary_search(begin(B), end(B), a - diff)) return {a, a - diff};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```size(A)```\n```size(B)```\n```B```\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n\\n        sort(begin(A), end(A));\\n        sort(begin(B), end(B));\\n        \\n        for (int i = 0, j = 0; i < size(A) && j < size(B); ) {\\n            const int d = A[i] - B[j];\\n            if (d == diff) return {A[i], B[j]};\\n\\n            if (d < diff) {\\n                ++i;\\n            } else {\\n                ++j;\\n            }\\n        }\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```size(A)```\n```size(B)```\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        if (size(B) > size(A)) {\\n            vector<int> tmp = fairCandySwap(B, A);\\n            return {tmp[1], tmp[0]};\\n        }\\n        assert(size(B) <= size(A));\\n\\n        // Here goes the remaining code ...\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 264171,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        a,b=sum(A),sum(B)\\n        diff=(a-b)//2\\n        i,j=0,0\\n        A.sort()\\n        B.sort()\\n        while i<len(A) and j<len(B):\\n            temp = A[i]-B[j]\\n            if temp == diff:\\n                return [A[i],B[j]]\\n            elif temp<diff:\\n                i+=1\\n            else:\\n                j+=1\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        a,b=sum(A),sum(B)\\n        diff=(a-b)//2\\n        i,j=0,0\\n        A.sort()\\n        B.sort()\\n        while i<len(A) and j<len(B):\\n            temp = A[i]-B[j]\\n            if temp == diff:\\n                return [A[i],B[j]]\\n            elif temp<diff:\\n                i+=1\\n            else:\\n                j+=1\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888042,
                "title": "math-behind-lee215-s-solution",
                "content": "Assume that alice has sizes $[x_1, x_2, ..., x_m]$, while bob has sizes $[y_1, y_2, ..., y_n]$. Also, we are going to switch $x_a$ and $y_b$ so that they will have some size total at the end. Then, we have\\n\\n$$\\\\sum_{i=1}^nx_i - x_a + y_b = \\\\sum_{j=1}^my_j - y_b + x_a$$\\n\\nwhich can be rewritten as \\n\\n$$\\\\sum_{i=1}^nx_i - \\\\sum_{j=1}^my_j =  2x_a - 2y_b $$\\n\\nwhich is\\n\\n$$diff = \\\\frac{\\\\sum_{i=1}^nx_i - \\\\sum_{j=1}^my_j}{2} =  x_a - y_b $$\\n\\nTherefore, if `diff + bob_size` is in `aliceSizes`, we know that we find the result. \\n\\nHope this helps.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        delta = (sum(aliceSizes) - sum(bobSizes)) // 2\\n        aliceSizes = set(aliceSizes)\\n        for size in set(bobSizes):\\n            if delta + size in aliceSizes:\\n                return [delta + size, size]\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        delta = (sum(aliceSizes) - sum(bobSizes)) // 2\\n        aliceSizes = set(aliceSizes)\\n        for size in set(bobSizes):\\n            if delta + size in aliceSizes:\\n                return [delta + size, size]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571182,
                "title": "python-c-java-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q888. Fair Candy Swap***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sa=0,sb=0;\\n        for(int i=0;i<A.length;i++)\\n            sa+=A[i];\\n        for(int i=0;i<B.length;i++)\\n            sb+=B[i];\\n        int diff=(sa-sb)/2;\\n        for(int i=0;i<A.length;i++)\\n            for(int j=0;j<B.length;j++)\\n                if(A[i]-B[j]==diff)\\n                    return new int[]{A[i],B[j]};\\n        return null;\\n    }\\n}\\n```\\n**Runtime:**  408 ms\\t\\t\\n**Memory Usage:**  43.8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int>ans;\\n        int asum=0,bsum=0;\\n        for(auto x:aliceSizes)\\n            asum+=x;\\n        for(auto x:bobSizes)\\n            bsum+=x;\\n        int diff=(bsum-asum)/2;\\n        unordered_set<int> s(bobSizes.begin(),bobSizes.end());\\n        \\n        for(auto x : aliceSizes)\\n        {\\n              if(s.find(x + diff) != s.end())\\n              {\\n                  ans.push_back(x);\\n                  ans.push_back(x+diff);\\n                  break;\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Runtime:** 96 ms\\t\\n**Memory Usage:**  47.3 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sa=0,sb=0;\\n        for(int i=0;i<A.length;i++)\\n            sa+=A[i];\\n        for(int i=0;i<B.length;i++)\\n            sb+=B[i];\\n        int diff=(sa-sb)/2;\\n        for(int i=0;i<A.length;i++)\\n            for(int j=0;j<B.length;j++)\\n                if(A[i]-B[j]==diff)\\n                    return new int[]{A[i],B[j]};\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int>ans;\\n        int asum=0,bsum=0;\\n        for(auto x:aliceSizes)\\n            asum+=x;\\n        for(auto x:bobSizes)\\n            bsum+=x;\\n        int diff=(bsum-asum)/2;\\n        unordered_set<int> s(bobSizes.begin(),bobSizes.end());\\n        \\n        for(auto x : aliceSizes)\\n        {\\n              if(s.find(x + diff) != s.end())\\n              {\\n                  ans.push_back(x);\\n                  ans.push_back(x+diff);\\n                  break;\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512064,
                "title": "javascript-solution-using-set",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar fairCandySwap = function(A, B) {\\n  const sumA = A.reduce((acc, cur) => acc + cur);\\n  const sumB = B.reduce((acc, cur) => acc + cur);\\n  const diff = (sumA - sumB) >> 1;\\n  const setA = new Set(A);\\n  for (const candy of B) {\\n    if (setA.has(candy + diff)) return [candy + diff, candy];\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar fairCandySwap = function(A, B) {\\n  const sumA = A.reduce((acc, cur) => acc + cur);\\n  const sumB = B.reduce((acc, cur) => acc + cur);\\n  const diff = (sumA - sumB) >> 1;\\n  const setA = new Set(A);\\n  for (const candy of B) {\\n    if (setA.has(candy + diff)) return [candy + diff, candy];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161309,
                "title": "python-solution-using-set-similar-to-twosum-concept",
                "content": "If we know the final same total amount ```total```, \\nwe can pick any element ```a``` in A  and check if **the rest in A** + **any element ```b``` in B** == **total**.\\nThat is, the rest of candy left in A = sum(A) - element in A\\npossible B = total - (the rest of candy left in A)\\n```python\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        sumA, sumB  = sum(A), sum(B)\\n        setA, setB = set(A), set(B)\\n        total = (sumA + sumB) // 2 # the final same total amount\\n        \\n        for i in setA:\\n            if total - (sumA - i) in setB:\\n                return [i, total - (sumA - i)]\\n```",
                "solutionTags": [],
                "code": "```total```\n```a```\n```b```\n```python\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        sumA, sumB  = sum(A), sum(B)\\n        setA, setB = set(A), set(B)\\n        total = (sumA + sumB) // 2 # the final same total amount\\n        \\n        for i in setA:\\n            if total - (sumA - i) in setB:\\n                return [i, total - (sumA - i)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229888,
                "title": "c-set-solution-with-explanation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n\\t\\t\\tint sA = 0; // sA is the sum of the sizes of Alice\\'s candy bars\\n\\t\\t\\tint sB = 0; // sB is the sum of the sizes of Bob\\'s candy bars\\n\\t\\t\\tfor(int i = 0; i < aliceSizes.size(); i++){\\n\\t\\t\\t\\tsA += aliceSizes[i];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < bobSizes.size(); i++){\\n\\t\\t\\t\\tsB += bobSizes[i];\\n\\t\\t\\t}\\n\\t\\t\\t// Let x =  Size of a candy bar exchanged by Alice\\n\\t\\t\\t// Let y = Size of a candy bar exchanged by Bob\\n\\t\\t\\t// sA - x + y = sB - y + x \\n\\t\\t\\t// (sA - sB) / 2 = x - y;\\n\\n\\t\\t\\t// So, our target is to find a candy bar pair whose whose difference is (sA - sB) / 2 \\n\\t\\t\\tint d = (sA - sB) / 2;\\n\\n\\t\\t\\t// We want to find if any aliceSizes[i] = bobSizes[j] + d\\n\\t\\t\\tset<int> bob;\\n\\t\\t\\tfor(int i = 0; i < bobSizes.size(); i++){\\n\\t\\t\\t\\tbob.insert(bobSizes[i] + d);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < aliceSizes.size(); i++){\\n\\t\\t\\t\\tif(bob.find(aliceSizes[i]) != bob.end()){    \\n\\t\\t\\t\\t\\treturn {aliceSizes[i], aliceSizes[i] - d};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn {};\\n\\t\\t}\\n\\t};\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n\\t\\t\\tint sA = 0; // sA is the sum of the sizes of Alice\\'s candy bars\\n\\t\\t\\tint sB = 0; // sB is the sum of the sizes of Bob\\'s candy bars\\n\\t\\t\\tfor(int i = 0; i < aliceSizes.size(); i++){\\n\\t\\t\\t\\tsA += aliceSizes[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 750626,
                "title": "could-not-think-of-linear-time-solution-used-binary-search-instead",
                "content": "The linear time solution was pretty clever. I could not come up with it in 30-ish minutes. I was surprised that the naive `O(n^2)` solution was accepted. Working from the naive solution, I was able to get down to linearithmic runtime.\\n\\nLet `B = |B|` and `A = |A|`, `O(Blog(B) + Alog(B))` solution:\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int nA = A.size();\\n        int nB = B.size();\\n        // could help to sort the smaller of the two lists\\n        sort(B.begin(), B.end());\\n        \\n        int sumA = 0;\\n        int sumB = 0;\\n        \\n        for (int v : A)\\n            sumA += v;\\n        \\n        for (int v : B)\\n            sumB += v;\\n        \\n        for (int i = 0; i < nA; ++i) {\\n            int aliceBar = A[i];\\n            \\n            int ii = 0;\\n            int j = nB - 1;\\n            // find the element that will make the two sums\\n\\t\\t\\t// the same\\n            while (ii <= j) {\\n                int m = ii + (j-ii)/2;\\n                int bobBar = B[m];\\n                \\n                int resA = sumA - aliceBar + bobBar;\\n                int resB = sumB - bobBar + aliceBar;\\n                \\n                if (resA == resB) // both sums are the same!\\n                    return { aliceBar, bobBar };\\n                else if (resA > resB) {\\n\\t\\t\\t\\t\\t// if \\'swapping\\' something from B leads to a larger sum for A\\n\\t\\t\\t\\t\\t// then we should try to \\'swap\\' something smaller\\n                    j = m - 1;\\n                } else {\\n\\t\\t\\t\\t\\t// if \\'swapping\\' something from B leads to a smaller sum for A\\n\\t\\t\\t\\t\\t// then we should try to swap something bigger\\n                    ii = m + 1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int nA = A.size();\\n        int nB = B.size();\\n        // could help to sort the smaller of the two lists\\n        sort(B.begin(), B.end());\\n        \\n        int sumA = 0;\\n        int sumB = 0;\\n        \\n        for (int v : A)\\n            sumA += v;\\n        \\n        for (int v : B)\\n            sumB += v;\\n        \\n        for (int i = 0; i < nA; ++i) {\\n            int aliceBar = A[i];\\n            \\n            int ii = 0;\\n            int j = nB - 1;\\n            // find the element that will make the two sums\\n\\t\\t\\t// the same\\n            while (ii <= j) {\\n                int m = ii + (j-ii)/2;\\n                int bobBar = B[m];\\n                \\n                int resA = sumA - aliceBar + bobBar;\\n                int resB = sumB - bobBar + aliceBar;\\n                \\n                if (resA == resB) // both sums are the same!\\n                    return { aliceBar, bobBar };\\n                else if (resA > resB) {\\n\\t\\t\\t\\t\\t// if \\'swapping\\' something from B leads to a larger sum for A\\n\\t\\t\\t\\t\\t// then we should try to \\'swap\\' something smaller\\n                    j = m - 1;\\n                } else {\\n\\t\\t\\t\\t\\t// if \\'swapping\\' something from B leads to a smaller sum for A\\n\\t\\t\\t\\t\\t// then we should try to swap something bigger\\n                    ii = m + 1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929167,
                "title": "python3-with-explanation",
                "content": "sum(alice)-i+j=sum(bob)-j+i\\n        diff=2(i-j)\\n        diff/2=(i-j)\\n        diff/2+j=i\\n        j=i-diff/2\\n```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        total_alice=sum(aliceSizes)\\n        total_bob=sum(bobSizes)\\n        diff=(total_alice-total_bob)//2\\n        \\n        for i in set(aliceSizes):\\n            if i-diff in set(bobSizes):\\n                return [i,i-diff]\\n            \\n\\n\\t\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        total_alice=sum(aliceSizes)\\n        total_bob=sum(bobSizes)\\n        diff=(total_alice-total_bob)//2\\n        \\n        for i in set(aliceSizes):\\n            if i-diff in set(bobSizes):\\n                return [i,i-diff]\\n            \\n\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1641633,
                "title": "python-binary-search-with-explanation",
                "content": "* This is the first time I posted my solution, and I am a beginner in algorism, hope this simple solution can give you some help. \\n* Please feel free to comment, hope to learn more from you!\\n```\\nclass Solution(object):\\n    def fairCandySwap(self, aliceSizes, bobSizes):\\n        \"\"\"\\n        :type aliceSizes: List[int]\\n        :type bobSizes: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\t# Calculate the total value each list should satisfy\\n        alice, bob = 0, 0\\n        for i in aliceSizes: alice += i\\n        for j in bobSizes: bob += j\\n        each = (alice+bob)/2\\n\\t\\t# Sort each list first to utilize the binary search\\n        aliceSizes.sort()\\n        bobSizes.sort()\\n        for i in range(len(aliceSizes)):\\n            alice_change = aliceSizes[i]\\n            bl, br = 0, len(bobSizes)-1\\n            while bl <= br:\\n                bm = bl + (br-bl)//2\\n                bob_change = bobSizes[bm]\\n                new_alice = alice - alice_change + bob_change\\n                new_bob = bob + alice_change - bob_change\\n\\t\\t\\t\\t# If two list have the same value, then break\\n                if new_alice == new_bob:\\n                    return [alice_change, bob_change]\\n                    break\\n\\t\\t\\t\\t# If new_alice > new_bob, we should choose a larger value for exchanging\\n                elif new_alice > new_bob:\\n                    br = bm - 1\\n\\t\\t\\t\\t# If new_alice < new_bob, we should choose a smaller value for exchanging\\n                elif new_alice < new_bob:\\n                    bl = bm + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, aliceSizes, bobSizes):\\n        \"\"\"\\n        :type aliceSizes: List[int]\\n        :type bobSizes: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\t# Calculate the total value each list should satisfy\\n        alice, bob = 0, 0\\n        for i in aliceSizes: alice += i\\n        for j in bobSizes: bob += j\\n        each = (alice+bob)/2\\n\\t\\t# Sort each list first to utilize the binary search\\n        aliceSizes.sort()\\n        bobSizes.sort()\\n        for i in range(len(aliceSizes)):\\n            alice_change = aliceSizes[i]\\n            bl, br = 0, len(bobSizes)-1\\n            while bl <= br:\\n                bm = bl + (br-bl)//2\\n                bob_change = bobSizes[bm]\\n                new_alice = alice - alice_change + bob_change\\n                new_bob = bob + alice_change - bob_change\\n\\t\\t\\t\\t# If two list have the same value, then break\\n                if new_alice == new_bob:\\n                    return [alice_change, bob_change]\\n                    break\\n\\t\\t\\t\\t# If new_alice > new_bob, we should choose a larger value for exchanging\\n                elif new_alice > new_bob:\\n                    br = bm - 1\\n\\t\\t\\t\\t# If new_alice < new_bob, we should choose a smaller value for exchanging\\n                elif new_alice < new_bob:\\n                    bl = bm + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687223,
                "title": "java-solution-hash-set-with-explanantion",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        \\n        /*\\n          X is the value from Array A\\n          \\n          Y is the value from Array B\\n          \\n          sumA - sum of values in Array A\\n          \\n          sumB - sum of values in Array B\\n          \\n          We need to find X and Y values that satisfy below conditions\\n          \\n          sumA + Y - X  ==  sumB + X - Y\\n          \\n          sumA + 2Y - sumB = 2X \\n          \\n          X = (sumA - sumB + 2Y)/2\\n          \\n          populate all the values of Array A in a set\\n          \\n          loop through all the values of array B and calculate below formalu and check if the result exists in Array A\\n        \\n        */\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        int sumA = 0;\\n        \\n        int sumB = 0;\\n        \\n        for (int i : A)\\n        {\\n            sumA = sumA + i;\\n            \\n            set.add(i);\\n        }\\n        \\n         for (int i : B)\\n        {\\n            sumB = sumB + i;\\n            \\n        }\\n        \\n        for(int j: B)\\n        {\\n            int temp = (sumA - sumB + 2*j) / 2;\\n            if(set.contains(temp))\\n            {\\n                return new int[]{temp,j};\\n                   \\n               }\\n     \\n        }\\n        \\n        return new int[]{0,0};\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        \\n        /*\\n          X is the value from Array A\\n          \\n          Y is the value from Array B\\n          \\n          sumA - sum of values in Array A\\n          \\n          sumB - sum of values in Array B\\n          \\n          We need to find X and Y values that satisfy below conditions\\n          \\n          sumA + Y - X  ==  sumB + X - Y\\n          \\n          sumA + 2Y - sumB = 2X \\n          \\n          X = (sumA - sumB + 2Y)/2\\n          \\n          populate all the values of Array A in a set\\n          \\n          loop through all the values of array B and calculate below formalu and check if the result exists in Array A\\n        \\n        */\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        int sumA = 0;\\n        \\n        int sumB = 0;\\n        \\n        for (int i : A)\\n        {\\n            sumA = sumA + i;\\n            \\n            set.add(i);\\n        }\\n        \\n         for (int i : B)\\n        {\\n            sumB = sumB + i;\\n            \\n        }\\n        \\n        for(int j: B)\\n        {\\n            int temp = (sumA - sumB + 2*j) / 2;\\n            if(set.contains(temp))\\n            {\\n                return new int[]{temp,j};\\n                   \\n               }\\n     \\n        }\\n        \\n        return new int[]{0,0};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652916,
                "title": "cpp-simple-solution-using-set-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int a=0,b=0;\\n        for(int i=0;i<A.size();i++)\\n            a+=A[i];\\n        for(int i=0;i<B.size();i++)\\n            b+=B[i];\\n        a=(b-a)/2;\\n        set<int> s;\\n        for(auto x:A)\\n            s.insert(x+a);\\n        for(auto x:B)\\n        {\\n            if(s.find(x)!=s.end())\\n                return {x-a,x};\\n        }\\n        return {};\\n        \\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int a=0,b=0;\\n        for(int i=0;i<A.size();i++)\\n            a+=A[i];\\n        for(int i=0;i<B.size();i++)\\n            b+=B[i];\\n        a=(b-a)/2;\\n        set<int> s;\\n        for(auto x:A)\\n            s.insert(x+a);\\n        for(auto x:B)\\n        {\\n            if(s.find(x)!=s.end())\\n                return {x-a,x};\\n        }\\n        return {};\\n        \\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259366,
                "title": "java-solution-using-binary-search-with-explanation",
                "content": "Same logic as the solution but use binary search.\\nTakes O(MlogN) time but it\\'s in-place.\\n```\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        Arrays.sort(B);//In order to use binary search\\n        \\n        int sumA=0, sumB=0;\\n        for(int i: A)\\n            sumA+=i;\\n        for(int i: B)\\n            sumB+=i;\\n        int diffOfAns = (sumA-sumB)/2;//Use the equation\\n       \\n        int[] ans = new int[2];//Initailize the answer array\\n        \\n        for(int i=0; i<A.length; i++){\\n        //want to find a number in B that satisfies: ansA - ansB = diffOfAns\\n            //binary search \\n            int left = 0, right = B.length-1;\\n            while(left<=right){\\n                int mid = left+(right-left)/2;\\n                if(B[mid] == A[i]-diffOfAns){\\n                    ans[0]=A[i];\\n                    ans[1]=B[mid];\\n                    return ans;\\n                }\\n                else if(B[mid] > A[i]-diffOfAns){\\n                    right = mid-1;\\n                }\\n                else{\\n                    left = mid+1;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        Arrays.sort(B);//In order to use binary search\\n        \\n        int sumA=0, sumB=0;\\n        for(int i: A)\\n            sumA+=i;\\n        for(int i: B)\\n            sumB+=i;\\n        int diffOfAns = (sumA-sumB)/2;//Use the equation\\n       \\n        int[] ans = new int[2];//Initailize the answer array\\n        \\n        for(int i=0; i<A.length; i++){\\n        //want to find a number in B that satisfies: ansA - ansB = diffOfAns\\n            //binary search \\n            int left = 0, right = B.length-1;\\n            while(left<=right){\\n                int mid = left+(right-left)/2;\\n                if(B[mid] == A[i]-diffOfAns){\\n                    ans[0]=A[i];\\n                    ans[1]=B[mid];\\n                    return ans;\\n                }\\n                else if(B[mid] > A[i]-diffOfAns){\\n                    right = mid-1;\\n                }\\n                else{\\n                    left = mid+1;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161305,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        a, diff = set(A), (sum(A) - sum(B)) // 2\\n        for b in B:\\n            if b + diff in a:\\n                return [b + diff, b]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        a, diff = set(A), (sum(A) - sum(B)) // 2\\n        for b in B:\\n            if b + diff in a:\\n                return [b + diff, b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406728,
                "title": "beats-90-sol-with-comments",
                "content": "# **Please Upvote me \\uD83E\\uDD79**\\n\\n# Approach\\nApproach is written in Code with Comments just go through them and pls dry run code once you will get to know the logic , and you will find it pretty simple and straightforward\\n\\n# If Helpful Please Upvote\\uD83E\\uDD79\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n        // Problem is very simple if you think about it with pen and paper\\n        // let us assume\\n        // Sa = sum of alice candies, Sb = sum of bob candies\\n        // acc to question\\n        // Sa - x + y = Sb + x - y\\n        // y = x + (Sb-Sa)/2\\n\\n        // finding the sum of candies that bob and alice have\\n        int sumA = 0;\\n        for(auto &i : alice){\\n            sumA += i;\\n        }\\n\\n        int sumB = 0;\\n        for(auto &i: bob){\\n            sumB += i;\\n        }\\n\\n        int z = (sumB-sumA)/2;\\n\\n        // putting all the elements of bob into the map \\n        unordered_map<int,int>mpp;\\n        for(int i = 0; i<bob.size(); i++){\\n            mpp[bob[i]]++; \\n        }\\n\\n        for(int i = 0; i<alice.size(); i++){\\n            int x = alice[i];\\n            int y = x+z;\\n            if(mpp.find(y) != mpp.end()){\\n                return {x,y};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n        // Problem is very simple if you think about it with pen and paper\\n        // let us assume\\n        // Sa = sum of alice candies, Sb = sum of bob candies\\n        // acc to question\\n        // Sa - x + y = Sb + x - y\\n        // y = x + (Sb-Sa)/2\\n\\n        // finding the sum of candies that bob and alice have\\n        int sumA = 0;\\n        for(auto &i : alice){\\n            sumA += i;\\n        }\\n\\n        int sumB = 0;\\n        for(auto &i: bob){\\n            sumB += i;\\n        }\\n\\n        int z = (sumB-sumA)/2;\\n\\n        // putting all the elements of bob into the map \\n        unordered_map<int,int>mpp;\\n        for(int i = 0; i<bob.size(); i++){\\n            mpp[bob[i]]++; \\n        }\\n\\n        for(int i = 0; i<alice.size(); i++){\\n            int x = alice[i];\\n            int y = x+z;\\n            if(mpp.find(y) != mpp.end()){\\n                return {x,y};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377028,
                "title": "my-accepted-c-code-easy-understanding-bs",
                "content": "```\\nclass Solution {\\npublic:\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n\\n    sort(bobSizes.begin(),bobSizes.end());\\n    sort(aliceSizes.begin(),aliceSizes.end());\\n\\n    int sum1=0;\\n    int sum2=0;\\n    vector <int> ans;\\n    for(int i =0 ; i <aliceSizes.size(); i++)\\n    {\\n        sum1+=aliceSizes[i];\\n    }\\n    for(int i =0 ; i <bobSizes.size(); i++)\\n    {\\n        sum2+=bobSizes[i];\\n    }\\n    \\n    int dif = (sum1-sum2)/2;\\n    \\n    \\n    for(int i = 0 ; i <aliceSizes.size(); i++)\\n    {\\n        \\n        int st=0;\\n        int end = bobSizes.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            int mid = (st+end)/2;\\n            \\n            if(bobSizes[mid]==aliceSizes[i]-dif)\\n            {\\n             ans.push_back(aliceSizes[i]);\\n             ans.push_back(bobSizes[mid]);\\n             return ans;\\n            }\\n            \\n            else if(bobSizes[mid]<aliceSizes[i]-dif)\\n            {\\n                st=mid+1;\\n            }\\n            else if(bobSizes[mid]>aliceSizes[i]-dif)\\n            {\\n                end=mid-1;\\n            }\\n              \\n        }    \\n    }\\n    \\n    return ans;\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n\\n    sort(bobSizes.begin(),bobSizes.end());\\n    sort(aliceSizes.begin(),aliceSizes.end());\\n\\n    int sum1=0;\\n    int sum2=0;\\n    vector <int> ans;\\n    for(int i =0 ; i <aliceSizes.size(); i++)\\n    {\\n        sum1+=aliceSizes[i];\\n    }\\n    for(int i =0 ; i <bobSizes.size(); i++)\\n    {\\n        sum2+=bobSizes[i];\\n    }\\n    \\n    int dif = (sum1-sum2)/2;\\n    \\n    \\n    for(int i = 0 ; i <aliceSizes.size(); i++)\\n    {\\n        \\n        int st=0;\\n        int end = bobSizes.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            int mid = (st+end)/2;\\n            \\n            if(bobSizes[mid]==aliceSizes[i]-dif)\\n            {\\n             ans.push_back(aliceSizes[i]);\\n             ans.push_back(bobSizes[mid]);\\n             return ans;\\n            }\\n            \\n            else if(bobSizes[mid]<aliceSizes[i]-dif)\\n            {\\n                st=mid+1;\\n            }\\n            else if(bobSizes[mid]>aliceSizes[i]-dif)\\n            {\\n                end=mid-1;\\n            }\\n              \\n        }    \\n    }\\n    \\n    return ans;\\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301988,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sum_a=0,sum_b=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            sum_a+=A[i];\\n        }\\n        for(int i=0;i<B.length;i++)\\n        {\\n            sum_b+=B[i];\\n        }\\n        int target=(sum_a-sum_b)/2;\\n        int[] res=new int[2];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            for(int j=0;j<B.length;j++)\\n            {\\n                if(A[i]==B[j]+target)\\n                {\\n                    res[0]=A[i];\\n                    res[1]=B[j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sum_a=0,sum_b=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            sum_a+=A[i];\\n        }\\n        for(int i=0;i<B.length;i++)\\n        {\\n            sum_b+=B[i];\\n        }\\n        int target=(sum_a-sum_b)/2;\\n        int[] res=new int[2];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            for(int j=0;j<B.length;j++)\\n            {\\n                if(A[i]==B[j]+target)\\n                {\\n                    res[0]=A[i];\\n                    res[1]=B[j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815011,
                "title": "python-simple-math-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        sum_A = sum(A)\\n        sum_B = sum(B)\\n\\t\\t# we go over the candies in A and check if there is a candy in B to swap so the sums should be equal\\n        for candy in A:\\n            if candy + (sum_B - sum_A) / 2 in B:\\n                return [candy, candy + (sum_B - sum_A) / 2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        sum_A = sum(A)\\n        sum_B = sum(B)\\n\\t\\t# we go over the candies in A and check if there is a candy in B to swap so the sums should be equal\\n        for candy in A:\\n            if candy + (sum_B - sum_A) / 2 in B:\\n                return [candy, candy + (sum_B - sum_A) / 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252033,
                "title": "simple-python-with-explanation-beats-100",
                "content": "The average of both sums will be the  total amount that both of them will have at the end. This means if we have to add some value reqA to A, the same value reqA will be subtracted from B and vice versa. \\nWe add that required value (reqA) to an element of A (a) and if that exists in B we have our answer.\\nHere, suppose that required value is reqA (reqA =  finalTotal - sumA ) therefore if b exists such that b = a + reqA, then (b - reqA = a ), exists as well, thus we don\\'t need to check if B follows the given criteria. Only checking if a+ reqA is present in B is enough.\\n\\n```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sumb = sum(B)\\n        suma = sum(A)\\n        \\n        finalTotal = (suma+sumb)/2\\n        reqA = finalTotal - suma \\n      \\n        setB = set(B)\\n        \\n        for a in A:\\n            if a+reqA in setB :\\n                return a,a+reqA\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "The average of both sums will be the  total amount that both of them will have at the end. This means if we have to add some value reqA to A, the same value reqA will be subtracted from B and vice versa. \\nWe add that required value (reqA) to an element of A (a) and if that exists in B we have our answer.\\nHere, suppose that required value is reqA (reqA =  finalTotal - sumA ) therefore if b exists such that b = a + reqA, then (b - reqA = a ), exists as well, thus we don\\'t need to check if B follows the given criteria. Only checking if a+ reqA is present in B is enough.\\n\\n```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sumb = sum(B)\\n        suma = sum(A)\\n        \\n        finalTotal = (suma+sumb)/2\\n        reqA = finalTotal - suma \\n      \\n        setB = set(B)\\n        \\n        for a in A:\\n            if a+reqA in setB :\\n                return a,a+reqA\\n\\t\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 175595,
                "title": "python-simple-and-quick-solution-without-loop",
                "content": "```Python\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = (sum(A) - sum(B)) // 2\\n        A = list(map(lambda a: a - n, A))\\n        b = (list(set(A) & set(B)))[0]\\n        return [b + n, b]\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = (sum(A) - sum(B)) // 2\\n        A = list(map(lambda a: a - n, A))\\n        b = (list(set(A) & set(B)))[0]\\n        return [b + n, b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341418,
                "title": "c-easiest-explanation-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sum1 = accumulate(aliceSizes.begin(), aliceSizes.end(), 0); // total number of candies Alice has\\n        int sum2 = accumulate(bobSizes.begin(), bobSizes.end(), 0); // total number of candies Bob has\\n\\n        int diff = (sum2 - sum1) / 2; // the difference that needs to be balanced between Alice and Bob\\n        \\n        set<int> s; // using a set to keep track of the candies that Bob has\\n        \\n        for (auto b : bobSizes) {\\n            s.insert(b);\\n        }\\n        \\n        for (auto a : aliceSizes) {\\n            int b = a + diff; // Bob needs to give this many candies to Alice to balance the total candy count\\n            if (s.count(b)) { // if Bob has this many candies\\n                return {a, b}; // return the boxes that need to be exchanged\\n            }\\n        }\\n        \\n        return {}; // this line will not be executed as at least one solution is guaranteed\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sum1 = accumulate(aliceSizes.begin(), aliceSizes.end(), 0); // total number of candies Alice has\\n        int sum2 = accumulate(bobSizes.begin(), bobSizes.end(), 0); // total number of candies Bob has\\n\\n        int diff = (sum2 - sum1) / 2; // the difference that needs to be balanced between Alice and Bob\\n        \\n        set<int> s; // using a set to keep track of the candies that Bob has\\n        \\n        for (auto b : bobSizes) {\\n            s.insert(b);\\n        }\\n        \\n        for (auto a : aliceSizes) {\\n            int b = a + diff; // Bob needs to give this many candies to Alice to balance the total candy count\\n            if (s.count(b)) { // if Bob has this many candies\\n                return {a, b}; // return the boxes that need to be exchanged\\n            }\\n        }\\n        \\n        return {}; // this line will not be executed as at least one solution is guaranteed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811880,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsed Divide and Conquer approach with two for loop to iterate over each element of the arrays.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed an Optimized approach using the divide and conquer technique with Hashset to reduce the iteration Cost of the element of the array. \\n# Complexity\\n- Time complexity: $$O(n)$$ ( n = Maximum of arr1.length and arr2.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] arr1, int[] arr2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i=0;i<arr1.length;i++){\\n            sum1+=arr1[i];\\n        }\\n        for(int i=0;i<arr2.length;i++){\\n            sum2+=arr2[i];\\n        }\\n        int mid = ( sum1 - sum2 ) / 2;\\n        Set<Integer> s2 = new HashSet<>();\\n\\n        for(int i=0;i<arr2.length;i++){\\n            s2.add(arr2[i]);\\n        }\\n\\n        for(int v : arr1){\\n            if( s2.contains(v-mid)){\\n                return new int[] {v,v-mid};\\n            }\\n        }\\n        return new int[] {0,0};\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] arr1, int[] arr2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i=0;i<arr1.length;i++){\\n            sum1+=arr1[i];\\n        }\\n        for(int i=0;i<arr2.length;i++){\\n            sum2+=arr2[i];\\n        }\\n        int mid = ( sum1 - sum2 ) / 2;\\n        Set<Integer> s2 = new HashSet<>();\\n\\n        for(int i=0;i<arr2.length;i++){\\n            s2.add(arr2[i]);\\n        }\\n\\n        for(int v : arr1){\\n            if( s2.contains(v-mid)){\\n                return new int[] {v,v-mid};\\n            }\\n        }\\n        return new int[] {0,0};\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295343,
                "title": "fair-candy-swap-java",
                "content": "**java O(nlogn)**\\n```\\n  int sumA = 0;\\n        int sumB = 0;\\n        int y;\\n        for(int t: aliceSizes) sumA+=t;\\n        for(int t: bobSizes) sumB+=t;\\n        Arrays.sort(aliceSizes);\\n        \\n        int d = (sumA-sumB)/2;\\n        for(int x:bobSizes){\\n           y =  d+x;\\n           if(bs(aliceSizes, y)){\\n               return new int[]{y,x};\\n               \\n           } \\n        }\\n        return new int[]{};\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n  int sumA = 0;\\n        int sumB = 0;\\n        int y;\\n        for(int t: aliceSizes) sumA+=t;\\n        for(int t: bobSizes) sumB+=t;\\n        Arrays.sort(aliceSizes);\\n        \\n        int d = (sumA-sumB)/2;\\n        for(int x:bobSizes){\\n           y =  d+x;\\n           if(bs(aliceSizes, y)){\\n               return new int[]{y,x};\\n               \\n           } \\n        }\\n        return new int[]{};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731853,
                "title": "clear-explained-approach-java",
                "content": "```\\nBasically we need to equal the sum of these two arrays by swapping one of element from both array,\\nLets\\'s Suppose sum of aliceSizes is SumA and sum of bobSizes is SumB\\nSo we have to do the follow\\n    SumA-x+y = SumB +x-y\\n    \\n    where x is candies given by alice\\n    and y is candies given by bob\\n    \\n    As it is mentioned in question that they both have to excahnge some thing in order to have equal balance , Hence x and y always exists in the ans\\n   **SumA -x +y = SumB +x-y\\n   SumA-SumB = 2x - 2y\\n  (SumA-SumB)/2 = x-y ------------------------- equation 1\\n   ** \\n    Now problem is reduced to finding x and y where they follow eq. 1\\n\\t\\n\\t\\n\\t\\n\\t\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int sum1 =0;\\n        int sum2 =0;\\n        for(int i : aliceSizes)\\n            sum1+=i;\\n        for(int i : bobSizes)\\n            sum2+= i;\\n        \\n        int diff = (sum1-sum2)/2;\\n        \\n        for(int j = aliceSizes.length -1;j>=0; j--)\\n        {\\n            for(int k = bobSizes.length -1; k>=0; k--)\\n                \\n            {\\n                if(aliceSizes[j]-bobSizes[k] == diff)\\n                    return new int[]{aliceSizes[j],bobSizes[k]};\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    } \\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nBasically we need to equal the sum of these two arrays by swapping one of element from both array,\\nLets\\'s Suppose sum of aliceSizes is SumA and sum of bobSizes is SumB\\nSo we have to do the follow\\n    SumA-x+y = SumB +x-y\\n    \\n    where x is candies given by alice\\n    and y is candies given by bob\\n    \\n    As it is mentioned in question that they both have to excahnge some thing in order to have equal balance , Hence x and y always exists in the ans\\n   **SumA -x +y = SumB +x-y\\n   SumA-SumB = 2x - 2y\\n  (SumA-SumB)/2 = x-y ------------------------- equation 1\\n   ** \\n    Now problem is reduced to finding x and y where they follow eq. 1\\n\\t\\n\\t\\n\\t\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402672,
                "title": "c-smart-version-of-two-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int sum_A = accumulate(begin(A), end(A), 0);\\n        int sum_B = accumulate(begin(B), end(B), 0);\\n        \\n        //According to question\\n        /*\\n            if we choose x from A and y from B\\n            sum_A - x + y = sum_B - y + x\\n            solve it:\\n            2*(y-x) = sum_B-sum_A;\\n            y - x   = (sum_B-sum_A)/2;\\n            \\n            So, if for any candy box \\'x\\' in A, we have candy box\\n            y = (sum_B - sum_A)/2 + x; then we have the answer {x, y}\\n        */\\n        \\n        unordered_set<int> st(begin(B), end(B));\\n        int target = (sum_B - sum_A)/2;\\n        for(int &x : A) {\\n            if(st.count(target+x))\\n                return {x, target+x};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int sum_A = accumulate(begin(A), end(A), 0);\\n        int sum_B = accumulate(begin(B), end(B), 0);\\n        \\n        //According to question\\n        /*\\n            if we choose x from A and y from B\\n            sum_A - x + y = sum_B - y + x\\n            solve it:\\n            2*(y-x) = sum_B-sum_A;\\n            y - x   = (sum_B-sum_A)/2;\\n            \\n            So, if for any candy box \\'x\\' in A, we have candy box\\n            y = (sum_B - sum_A)/2 + x; then we have the answer {x, y}\\n        */\\n        \\n        unordered_set<int> st(begin(B), end(B));\\n        int target = (sum_B - sum_A)/2;\\n        for(int &x : A) {\\n            if(st.count(target+x))\\n                return {x, target+x};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352714,
                "title": "c-easy-to-understand-o-n-time-complexity",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        int sumA=0,sumB=0;\\n        unordered_set<int> a;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            a.insert(aliceSizes[i]);\\n            sumA+=aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            sumB+=bobSizes[i];\\n        }   \\n        int delta=(sumB-sumA)/2;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            if(a.count(bobSizes[i]-delta))\\n             return {bobSizes[i]-delta,bobSizes[i]};   \\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        int sumA=0,sumB=0;\\n        unordered_set<int> a;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            a.insert(aliceSizes[i]);\\n            sumA+=aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            sumB+=bobSizes[i];\\n        }   \\n        int delta=(sumB-sumA)/2;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            if(a.count(bobSizes[i]-delta))\\n             return {bobSizes[i]-delta,bobSizes[i]};   \\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306780,
                "title": "c-simple-easy-sol-with-explanation-o-n-sol",
                "content": "**Step by Step Approach:**\\n1) Get the sum of Alice\\'s candies & bob\\'s candies. \\n\\t\\t\\tSa = sum of Alice\\n\\t\\t\\tSb = sum of Bob\\n\\t\\t\\t\\n2) Calculate the difference of the sums : say c = Sa - Sb\\n3) Now, In order to make the sums same , let\\'s assume candy of hieght **a** is moved from Alice side & candy of height **b** is moved from bob side. After doing this resultant sum from both side should be equal right!. Now comes simple maths.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tResultant sum of Alice       =        Resultant sum of Bob\\n\\t\\t\\t\\t\\t\\tSa - a + b           =            Sb - b + a\\n\\t\\t\\t\\t\\t\\tSa - Sb              =              2*(a-b)\\n\\t\\t\\t\\t\\t\\t\\tc                =              2*(a-b)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tor\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tb    =   (2a - c)/2\\n\\n4) So at last it means, if we are iterating on alice array(say a) we just need to find a number(say b) in bob array such     that  above relation satisfies.\\n\\nHope this explanation is simple and understandable!.\\n\\t\\t\\t\\t\\t\\t\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int c=0;\\n        for(int i : aliceSizes)\\n            c += i;\\n        for(int i : bobSizes)\\n            c -= i;\\n\\n        unordered_map<int,int> mp;\\n        for(int i : bobSizes)\\n            mp[i]++;\\n        \\n        for(int i : aliceSizes){\\n            if(mp.find((2*i - c)/2) != mp.end())\\n                return vector<int>({i,(2*i - c)/2});\\n        }\\n        \\n        return vector<int>({-1,-1});\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int c=0;\\n        for(int i : aliceSizes)\\n            c += i;\\n        for(int i : bobSizes)\\n            c -= i;\\n\\n        unordered_map<int,int> mp;\\n        for(int i : bobSizes)\\n            mp[i]++;\\n        \\n        for(int i : aliceSizes){\\n            if(mp.find((2*i - c)/2) != mp.end())\\n                return vector<int>({i,(2*i - c)/2}",
                "codeTag": "Java"
            },
            {
                "id": 1230846,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA = 0;\\n        int sumB = 0;\\n        int[] result = new int[2];\\n        \\n        for (int i=0; i<aliceSizes.length; i++) {\\n            sumA += aliceSizes[i];\\n        }\\n        for (int i=0; i<bobSizes.length; i++) {\\n            sumB += bobSizes[i];\\n        }\\n        \\n        int targetB = (sumA-sumB)/(2);\\n        \\n        for (int i=0; i<aliceSizes.length; i++) {\\n            for (int j=0; j<bobSizes.length; j++) {\\n                if (aliceSizes[i]==bobSizes[j]+targetB) {\\n                    result[0] = aliceSizes[i];\\n                    result[1] = bobSizes[j];\\n                    return result;\\n                }\\n            }    \\n        }\\n        return result;\\n    }\\n}\\n//Time: O(M*N)\\n//Space: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA = 0;\\n        int sumB = 0;\\n        int[] result = new int[2];\\n        \\n        for (int i=0; i<aliceSizes.length; i++) {\\n            sumA += aliceSizes[i];\\n        }\\n        for (int i=0; i<bobSizes.length; i++) {\\n            sumB += bobSizes[i];\\n        }\\n        \\n        int targetB = (sumA-sumB)/(2);\\n        \\n        for (int i=0; i<aliceSizes.length; i++) {\\n            for (int j=0; j<bobSizes.length; j++) {\\n                if (aliceSizes[i]==bobSizes[j]+targetB) {\\n                    result[0] = aliceSizes[i];\\n                    result[1] = bobSizes[j];\\n                    return result;\\n                }\\n            }    \\n        }\\n        return result;\\n    }\\n}\\n//Time: O(M*N)\\n//Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427002,
                "title": "python-6-lines-beats97-100-in-o-n",
                "content": "```python\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        sum1,sum2 = sum(A) , sum(B)\\n        B = set(B)\\n        for one in A:\\n            temp = int((sum2+2*one-sum1 )/2)\\n            if temp in B:\\n                return [one,temp]\\n```\\nafter swap:\\nsum1 + temp - one == sum2 - temp + one\\nso :\\ntemp = int((sum2+2*one-sum1 )/2)\\n\\n\\n**if it helps you , Please give me a vote star\\nThanks**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        sum1,sum2 = sum(A) , sum(B)\\n        B = set(B)\\n        for one in A:\\n            temp = int((sum2+2*one-sum1 )/2)\\n            if temp in B:\\n                return [one,temp]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410592,
                "title": "javascript-solution",
                "content": "var fairCandySwap = function(A, B) {\\n    let aliceArr = A;\\n    let bobArr = B;\\n    let aliceSize = 0;\\n    let bobSize = 0;\\n    let swap = [];\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        aliceSize += aliceArr[i];\\n    }\\n    \\n    for (let i = 0; i < bobArr.length; i++) {\\n        bobSize += bobArr[i];\\n    }\\n    \\n    let difference = aliceSize - bobSize;\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        for (let j = 0; j < bobArr.length; j++) {\\n            if ((aliceArr[i] - bobArr[j]) === (difference/2)) {\\n                swap.push(aliceArr[i], bobArr[j]);\\n                return swap;\\n            }\\n        }\\n    }\\n    \\n    return swap;\\n};\\n\\nalternative way ---> \\n___________________________________________________________\\n\\nvar fairCandySwap = function(A, B) {\\n    let aliceArr = A;\\n    let bobArr = B;\\n    let aliceSize = 0;\\n    let bobSize = 0;\\n    let swap = [];\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        aliceSize += aliceArr[i];\\n    }\\n    \\n    for (let i = 0; i < bobArr.length; i++) {\\n        bobSize += bobArr[i];\\n    }\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        for (let j = 0; j < bobArr.length; j++) {\\n            if ((aliceSize - aliceArr[i] + bobArr[j]) === bobSize - bobArr[j] + aliceArr[i]) {\\n                swap.push(aliceArr[i], bobArr[j]);\\n                return swap;\\n            }\\n        }\\n    }\\n    \\n    return swap;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var fairCandySwap = function(A, B) {\\n    let aliceArr = A;\\n    let bobArr = B;\\n    let aliceSize = 0;\\n    let bobSize = 0;\\n    let swap = [];\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        aliceSize += aliceArr[i];\\n    }\\n    \\n    for (let i = 0; i < bobArr.length; i++) {\\n        bobSize += bobArr[i];\\n    }\\n    \\n    let difference = aliceSize - bobSize;\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        for (let j = 0; j < bobArr.length; j++) {\\n            if ((aliceArr[i] - bobArr[j]) === (difference/2)) {\\n                swap.push(aliceArr[i], bobArr[j]);\\n                return swap;\\n            }\\n        }\\n    }\\n    \\n    return swap;\\n};\\n\\nalternative way ---> \\n___________________________________________________________\\n\\nvar fairCandySwap = function(A, B) {\\n    let aliceArr = A;\\n    let bobArr = B;\\n    let aliceSize = 0;\\n    let bobSize = 0;\\n    let swap = [];\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        aliceSize += aliceArr[i];\\n    }\\n    \\n    for (let i = 0; i < bobArr.length; i++) {\\n        bobSize += bobArr[i];\\n    }\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        for (let j = 0; j < bobArr.length; j++) {\\n            if ((aliceSize - aliceArr[i] + bobArr[j]) === bobSize - bobArr[j] + aliceArr[i]) {\\n                swap.push(aliceArr[i], bobArr[j]);\\n                return swap;\\n            }\\n        }\\n    }\\n    \\n    return swap;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 205138,
                "title": "c-beat-95",
                "content": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B) {\\n            var k = (A.Sum() - B.Sum()) / 2; \\n\\n            var h = new HashSet<int>(A);\\n\\n            foreach (var b in B)\\n                if (h.Contains(k + b)) return new[] { k + b, b };\\n\\t\\t\\t\\t\\n            throw new Exception();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B) {\\n            var k = (A.Sum() - B.Sum()) / 2; \\n\\n            var h = new HashSet<int>(A);\\n\\n            foreach (var b in B)\\n                if (h.Contains(k + b)) return new[] { k + b, b };\\n\\t\\t\\t\\t\\n            throw new Exception();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416276,
                "title": "solution-using-array-and-hash-set-with-explanation",
                "content": "# Intuition\\nNOTE: The question said that there would be multiple right answers for a perticular question.\\n\\nIf Alice is giving some candies(i.e. x) to Bob then in return Alice get some candies(i.e. y) from Bob.  \\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe x and y are the values from the array.\\n\\nFind the total number of candies for each(i.e. sumA, sumB)\\n\\nNow, sumB-sumA will give you the difference(i.e. number of extra candies Bob have)\\n\\nTo make both have the same amount of candies, we have to equally distribute that difference between both, so-\\n\\n            delta= (sumB - sumA) / 2\\n\\nThat means, if Alice gives x candies to Bob then in return Alice receives y= (x+delta) amount of candies from Bob.\\n\\nWhy \"x+delta\"? --> because x = Alice[i] and delta= no. of extra candies that we want to equally distribute.\\n\\nFor better understanding, please go through the code.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int sumA= 0;\\n        int sumB=0;\\n\\n        for(int i : aliceSizes) {\\n            sumA += i;\\n        }\\n\\n        for(int i : bobSizes) {\\n            sumB += i;\\n        }\\n\\n        int delta= (sumB-sumA)/2;\\n\\n        Set<Integer> setB= new HashSet<>();\\n\\n        for(int i : bobSizes) {\\n            setB.add(i);\\n        }\\n\\n        for(int i : aliceSizes) {\\n            if(setB.contains(i + delta)) {\\n                return new int[] {i, i+delta};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int sumA= 0;\\n        int sumB=0;\\n\\n        for(int i : aliceSizes) {\\n            sumA += i;\\n        }\\n\\n        for(int i : bobSizes) {\\n            sumB += i;\\n        }\\n\\n        int delta= (sumB-sumA)/2;\\n\\n        Set<Integer> setB= new HashSet<>();\\n\\n        for(int i : bobSizes) {\\n            setB.add(i);\\n        }\\n\\n        for(int i : aliceSizes) {\\n            if(setB.contains(i + delta)) {\\n                return new int[] {i, i+delta};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800158,
                "title": "c-using-hashmap-easy",
                "content": "**UP VOTE**\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int suma=0,sumb=0;\\n        unordered_map<int,int> mp;\\n        for(auto x:aliceSizes)\\n            suma+=x;\\n        for(auto x:bobSizes)\\n            {\\n                sumb+=x;\\n                mp[x]=1;\\n            }\\n        int diff=((suma-sumb)/2);\\n        for(auto x:aliceSizes)\\n        {\\n            if(mp[x-diff]==1)\\n                return {x,x-diff};\\n        }\\n        return {0,0};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int suma=0,sumb=0;\\n        unordered_map<int,int> mp;\\n        for(auto x:aliceSizes)\\n            suma+=x;\\n        for(auto x:bobSizes)\\n            {\\n                sumb+=x;\\n                mp[x]=1;\\n            }\\n        int diff=((suma-sumb)/2);\\n        for(auto x:aliceSizes)\\n        {\\n            if(mp[x-diff]==1)\\n                return {x,x-diff};\\n        }\\n        return {0,0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582008,
                "title": "c-binary-search-sorting",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int> &v, int target){\\n        int l = 0, r = v.size() - 1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(v[mid] == target){\\n                return true;\\n            } else if(v[mid] < target){\\n                l = mid+1;\\n            } else{\\n                r = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> solve(vector<int> &v1, vector<int> &v2, int target){\\n        for(int i = 0; i < v1.size(); ++i){\\n            if(binarySearch(v2, v1[i] + target)){\\n                return {v1[i], v1[i] + target};\\n            }\\n        }\\n        return {};\\n    }\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int aliceSum = 0, bobSum = 0;\\n        for(int i = 0; i < aliceSizes.size(); ++i){\\n            aliceSum = aliceSum + aliceSizes[i];\\n        }\\n        for(int i = 0; i < bobSizes.size(); ++i){\\n            bobSum = bobSum + bobSizes[i];\\n        }\\n        \\n        vector<int> res;\\n        if(aliceSum < bobSum){\\n            sort(bobSizes.begin(), bobSizes.end());\\n            res = solve(aliceSizes, bobSizes, (bobSum - aliceSum) >> 1);\\n        } else{\\n            sort(aliceSizes.begin(), aliceSizes.end());\\n            res = solve(bobSizes, aliceSizes, (aliceSum - bobSum) >> 1);\\n            swap(res[0], res[1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Output**\\n```\\nRuntime: 179 ms, faster than 45.65% of C++ online submissions for Fair Candy Swap.\\nMemory Usage: 39 MB, less than 94.76% of C++ online submissions for Fair Candy Swap.\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int> &v, int target){\\n        int l = 0, r = v.size() - 1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(v[mid] == target){\\n                return true;\\n            } else if(v[mid] < target){\\n                l = mid+1;\\n            } else{\\n                r = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> solve(vector<int> &v1, vector<int> &v2, int target){\\n        for(int i = 0; i < v1.size(); ++i){\\n            if(binarySearch(v2, v1[i] + target)){\\n                return {v1[i], v1[i] + target};\\n            }\\n        }\\n        return {};\\n    }\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int aliceSum = 0, bobSum = 0;\\n        for(int i = 0; i < aliceSizes.size(); ++i){\\n            aliceSum = aliceSum + aliceSizes[i];\\n        }\\n        for(int i = 0; i < bobSizes.size(); ++i){\\n            bobSum = bobSum + bobSizes[i];\\n        }\\n        \\n        vector<int> res;\\n        if(aliceSum < bobSum){\\n            sort(bobSizes.begin(), bobSizes.end());\\n            res = solve(aliceSizes, bobSizes, (bobSum - aliceSum) >> 1);\\n        } else{\\n            sort(aliceSizes.begin(), aliceSizes.end());\\n            res = solve(bobSizes, aliceSizes, (aliceSum - bobSum) >> 1);\\n            swap(res[0], res[1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nRuntime: 179 ms, faster than 45.65% of C++ online submissions for Fair Candy Swap.\\nMemory Usage: 39 MB, less than 94.76% of C++ online submissions for Fair Candy Swap.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558855,
                "title": "java-sol-using-binary-search",
                "content": "```\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int[] res = new int [] {0, 0};\\n        int alice = 0, bob = 0, start, end, mid;\\n        \\n        Arrays.sort(bobSizes);\\n        \\n        for (int i = 0; i < aliceSizes.length; ++i)\\n            alice += aliceSizes[i]; \\n        for (int i = 0; i < bobSizes.length; ++i)\\n            bob += bobSizes[i];\\n        \\n        for (int i = 0; i < aliceSizes.length; ++i)\\n        {\\n            alice -= aliceSizes[i];\\n            bob += aliceSizes[i];\\n            start = 0;\\n            end = bobSizes.length - 1;\\n            \\n            while (start <= end)\\n            {\\n                mid = start + (end - start) / 2;\\n                \\n                alice += bobSizes[mid];\\n                bob -= bobSizes[mid];\\n\\n                if (alice == bob)\\n                {\\n                    res[0] = aliceSizes[i];\\n                    res[1] = bobSizes[mid];\\n                    \\n                    return res;\\n                }\\n                else if (alice > bob)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n                \\n                alice -= bobSizes[mid];\\n                bob += bobSizes[mid];\\n            }\\n            \\n            alice += aliceSizes[i];\\n            bob -= aliceSizes[i];\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int[] res = new int [] {0, 0};\\n        int alice = 0, bob = 0, start, end, mid;\\n        \\n        Arrays.sort(bobSizes);\\n        \\n        for (int i = 0; i < aliceSizes.length; ++i)\\n            alice += aliceSizes[i]; \\n        for (int i = 0; i < bobSizes.length; ++i)\\n            bob += bobSizes[i];\\n        \\n        for (int i = 0; i < aliceSizes.length; ++i)\\n        {\\n            alice -= aliceSizes[i];\\n            bob += aliceSizes[i];\\n            start = 0;\\n            end = bobSizes.length - 1;\\n            \\n            while (start <= end)\\n            {\\n                mid = start + (end - start) / 2;\\n                \\n                alice += bobSizes[mid];\\n                bob -= bobSizes[mid];\\n\\n                if (alice == bob)\\n                {\\n                    res[0] = aliceSizes[i];\\n                    res[1] = bobSizes[mid];\\n                    \\n                    return res;\\n                }\\n                else if (alice > bob)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n                \\n                alice -= bobSizes[mid];\\n                bob += bobSizes[mid];\\n            }\\n            \\n            alice += aliceSizes[i];\\n            bob -= aliceSizes[i];\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2519085,
                "title": "c-solution-binary-search-solution-commented-approach-explained",
                "content": "Time complexity :- O(N*logM) N = Size of alice vector, M = Size of Bob vector\\n\\nclass Solution {\\npublic:\\n*     vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        // Approach :- We\\'ll sure binary search. we will try to replace every candy alice has with candies that Bob have if possible. The difference between the swapped candies must be (Sum of AliceSizes - Sum of Bob Sizes)/2. We\\'ll sort both the vectors and try to find this difference with every candy Alice has throigh binary search. If current difference is more less than the difference we need we\\'ll shrink the interval to left otherwise right.\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        long long sumalice = 0;\\n        long long sumbob = 0;\\n        int alice = aliceSizes.size();\\n        int bob = bobSizes.size();\\n        for(int i = 0;i < alice; i++)\\n        {\\n            sumalice += aliceSizes[i];\\n        }\\n        for(int i = 0;i < bob; i++)\\n        {\\n            sumbob += bobSizes[i];\\n        }\\n        long long diff = sumalice-sumbob;\\n        diff = diff/2;\\n        vector<int>ans(2);\\n        for(int i = 0;i < alice; i++)\\n        {\\n            int temp = solve(bobSizes,aliceSizes[i],diff);\\n            if(temp != INT_MAX)\\n            {\\n                ans[0] = aliceSizes[i];\\n                ans[1] = temp;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n*     int solve(vector<int>& bob, int& al, long long& diff){\\n        int h = bob.size()-1;\\n        int l = 0;\\n        int mid = l+(h-l)/2;\\n        while(l <= h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(al-bob[mid] == diff)\\n            {\\n                return bob[mid];\\n            }\\n            if(al-bob[mid] < diff)\\n            {\\n                h = mid-1;\\n            }else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return INT_MAX;\\n    }\\n};\\n**Do upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n*     vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        // Approach :- We\\'ll sure binary search. we will try to replace every candy alice has with candies that Bob have if possible. The difference between the swapped candies must be (Sum of AliceSizes - Sum of Bob Sizes)/2. We\\'ll sort both the vectors and try to find this difference with every candy Alice has throigh binary search. If current difference is more less than the difference we need we\\'ll shrink the interval to left otherwise right.\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        long long sumalice = 0;\\n        long long sumbob = 0;\\n        int alice = aliceSizes.size();\\n        int bob = bobSizes.size();\\n        for(int i = 0;i < alice; i++)\\n        {\\n            sumalice += aliceSizes[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2431352,
                "title": "hashmap-easy-to-understand",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        Map<Integer, Integer> map = new HashMap();\\n        int sa = 0;\\n        int sb = 0;\\n        for (int i: A){\\n            sa += i;\\n            map.put(i, 1);\\n        }\\n        for (int i: B) sb += i;\\n        int dist = (sa - sb) / 2;\\n\\n        for (int i: B){\\n            if (map.get(i + dist) != null){\\n                return new int[]{i+dist, i};\\n            }\\n        }\\n\\n        return null;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1896913,
                "title": "python-binary-search",
                "content": "```\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        sum1 = sum(aliceSizes)\\n        sum2 = sum(bobSizes)\\n        \\n        aliceSizes = sorted(aliceSizes)\\n        bobSizes = sorted(bobSizes)\\n        \\n        for a in aliceSizes:\\n            maybe_b = (2*a - (sum1 - sum2))/2\\n            b = self.binarySearch(bobSizes, maybe_b)\\n            if not b:\\n                continue\\n            else:\\n                return [a, b]\\n                \\n    def binarySearch(self, nums, n):\\n        l, r = 0, len(nums)-1\\n        while l <= r:                     \\n            mid = (l+r)//2                \\n            if nums[mid] == n:\\n                return nums[mid]\\n            elif nums[mid] > n:\\n                r = mid-1\\n            elif nums[mid] < n:\\n                l = mid+1  \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        sum1 = sum(aliceSizes)\\n        sum2 = sum(bobSizes)\\n        \\n        aliceSizes = sorted(aliceSizes)\\n        bobSizes = sorted(bobSizes)\\n        \\n        for a in aliceSizes:\\n            maybe_b = (2*a - (sum1 - sum2))/2\\n            b = self.binarySearch(bobSizes, maybe_b)\\n            if not b:\\n                continue\\n            else:\\n                return [a, b]\\n                \\n    def binarySearch(self, nums, n):\\n        l, r = 0, len(nums)-1\\n        while l <= r:                     \\n            mid = (l+r)//2                \\n            if nums[mid] == n:\\n                return nums[mid]\\n            elif nums[mid] > n:\\n                r = mid-1\\n            elif nums[mid] < n:\\n                l = mid+1  \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1877306,
                "title": "two-ways-binary-search-and-find-in-c",
                "content": "1)using vector find stl :-\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sa=0,sb=0;\\n        for(int i:aliceSizes)\\n            sa+=i;\\n        for(int j:bobSizes)\\n            sb+=j;\\n        int delta = (sb-sa)/2;\\n        vector<int>ans;\\n    for(int i:aliceSizes){\\n        if(find(bobSizes.begin(),bobSizes.end(),i+delta)!=bobSizes.end()){\\n            ans.push_back(i);\\n            ans.push_back(i+delta);\\n            break;\\n        }\\n    }\\n           return ans;\\n    }\\n};\\n```\\n2) using binary search :-\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sa=0,sb=0;\\n        for(int i:aliceSizes)\\n            sa+=i;\\n        for(int j:bobSizes)\\n            sb+=j;\\n        int delta = (sb-sa)/2;\\n        \\n        for(int i=0;i<aliceSizes.size();i++){\\n            vector<int>ans;\\n            int l=0,h=aliceSizes.size()-1,target = aliceSizes[i]+delta;\\n            ans.push_back(aliceSizes[i]);\\n            while(l<=h){\\n                int mid = l + ((h-l)/2);\\n                if(bobSizes[mid] == target){\\n                    ans.push_back(target);\\n                    return ans;\\n                }\\n                else if(bobSizes[mid]<target){\\n                    l = mid+1;\\n                }\\n                else\\n                    h = mid-1;\\n            }\\n        }\\n        vector<int> v;\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sa=0,sb=0;\\n        for(int i:aliceSizes)\\n            sa+=i;\\n        for(int j:bobSizes)\\n            sb+=j;\\n        int delta = (sb-sa)/2;\\n        vector<int>ans;\\n    for(int i:aliceSizes){\\n        if(find(bobSizes.begin(),bobSizes.end(),i+delta)!=bobSizes.end()){\\n            ans.push_back(i);\\n            ans.push_back(i+delta);\\n            break;\\n        }\\n    }\\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735583,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(int i=0;i<aliceSizes.length;i++)  //find sum of alicesizes array\\n        {\\n            sum1=sum1+aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.length;i++)   //find sum of bobsizesarray\\n        {\\n            sum2=sum2+bobSizes[i];\\n        }\\n        \\n        int diff=(sum1-sum2)/2;  /*it comes from the equation when alice gives x candies                                                    and receives y candies and bob gives y candies and receives x\\n                                                                   so sum1-x+y=sum2+x-y\\n                                                                    y=(sum2-sum1)/2+x*/\\n        int res[]=new int[2];\\n        for(int i=0;i<aliceSizes.length;i++)\\n        {\\n            for(int j=0;j<bobSizes.length;j++)\\n            {\\n                if(aliceSizes[i]==bobSizes[j]+diff)\\n                {\\n                    res[0]=aliceSizes[i];\\n                    res[1]=bobSizes[j];\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(int i=0;i<aliceSizes.length;i++)  //find sum of alicesizes array\\n        {\\n            sum1=sum1+aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.length;i++)   //find sum of bobsizesarray\\n        {\\n            sum2=sum2+bobSizes[i];\\n        }\\n        \\n        int diff=(sum1-sum2)/2;  /*it comes from the equation when alice gives x candies                                                    and receives y candies and bob gives y candies and receives x\\n                                                                   so sum1-x+y=sum2+x-y\\n                                                                    y=(sum2-sum1)/2+x*/\\n        int res[]=new int[2];\\n        for(int i=0;i<aliceSizes.length;i++)\\n        {\\n            for(int j=0;j<bobSizes.length;j++)\\n            {\\n                if(aliceSizes[i]==bobSizes[j]+diff)\\n                {\\n                    res[0]=aliceSizes[i];\\n                    res[1]=bobSizes[j];\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716760,
                "title": "c-binary-search-mlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr,int target)\\n    {\\n        int left = 0, right = arr.size()-1,mid;\\n        while(left <=right)\\n        {\\n            mid = left + (right-left)/2;\\n            if(arr[mid] == target)\\n            {\\n                return 1;\\n            }\\n            if(arr[mid] > target)\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            {\\n                left = mid +1;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        sort(bobSizes.begin(), bobSizes.end());\\n        int a = accumulate(aliceSizes.begin(), aliceSizes.end(), 0),b = accumulate(bobSizes.begin(), bobSizes.end(), 0);\\n        int exc = (b-a)/2;\\n        vector<int> ans;\\n        // if box b - box a == exc, exchange them and get ans\\n        // for each box that alice has binary search box a + exc and thats your solution\\n        for(auto i : aliceSizes)\\n        {\\n            if(bs(bobSizes,i+exc))\\n            {\\n                ans.push_back(i);\\n                ans.push_back(i+exc);\\n                return ans;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr,int target)\\n    {\\n        int left = 0, right = arr.size()-1,mid;\\n        while(left <=right)\\n        {\\n            mid = left + (right-left)/2;\\n            if(arr[mid] == target)\\n            {\\n                return 1;\\n            }\\n            if(arr[mid] > target)\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            {\\n                left = mid +1;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        sort(bobSizes.begin(), bobSizes.end());\\n        int a = accumulate(aliceSizes.begin(), aliceSizes.end(), 0),b = accumulate(bobSizes.begin(), bobSizes.end(), 0);\\n        int exc = (b-a)/2;\\n        vector<int> ans;\\n        // if box b - box a == exc, exchange them and get ans\\n        // for each box that alice has binary search box a + exc and thats your solution\\n        for(auto i : aliceSizes)\\n        {\\n            if(bs(bobSizes,i+exc))\\n            {\\n                ans.push_back(i);\\n                ans.push_back(i+exc);\\n                return ans;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447364,
                "title": "java-with-self-explanatory-code-and-comments",
                "content": "Time Complexity - O(N)\\n\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int totalCandiesWithAlice = 0;\\n        int totalCandiesWithBob = 0;\\n        \\n        HashSet<Integer> setA = new HashSet<>();\\n        \\n        // calculate the total number of candies with Alice.\\n        // Also, construct a set so that it will store only unique box sizes(as we want to figure out only ANY answer and not all possible answers)\\n        for(int i=0; i<aliceSizes.length; i++)\\n        {\\n            totalCandiesWithAlice += aliceSizes[i];\\n            setA.add(aliceSizes[i]);\\n        }\\n        \\n        // calcualte the total number of candies with Bob\\n        for(int i=0; i< bobSizes.length; i++)\\n        {\\n            totalCandiesWithBob += bobSizes[i];\\n        }\\n        \\n        // THE CORE LOGIC OF THIS ANSWER IS DUE TO THE FOLLOWING ASSUMPTION - \"THERE EXISTS ATLEAST ONE ANSWER\".\\n        // So, the difference between atleast one element in the array should be even(divisble by 2) so that we can share half of it with the person with less candies.\\n        // As we constructed the set for Alice\\'s candy boxes, the intention is to search for the difference in that set. So, the difference should be total number of candies with Alice has minus total number of candies that Bob has\\n        int differenceToMatch = (totalCandiesWithAlice-totalCandiesWithBob)/2;\\n        \\n        // loop through all the boxes that bob has\\n        for(int i=0; i<bobSizes.length; i++)\\n        {\\n            // For every box that bob has, check if there exists a box with alice that can split the difference with Bob(this will ensure both of them will have same total count). When found, return the same.\\n            if(setA.contains(bobSizes[i]+differenceToMatch))\\n                return new int[]{bobSizes[i]+differenceToMatch, bobSizes[i]};\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int totalCandiesWithAlice = 0;\\n        int totalCandiesWithBob = 0;\\n        \\n        HashSet<Integer> setA = new HashSet<>();\\n        \\n        // calculate the total number of candies with Alice.\\n        // Also, construct a set so that it will store only unique box sizes(as we want to figure out only ANY answer and not all possible answers)\\n        for(int i=0; i<aliceSizes.length; i++)\\n        {\\n            totalCandiesWithAlice += aliceSizes[i];\\n            setA.add(aliceSizes[i]);\\n        }\\n        \\n        // calcualte the total number of candies with Bob\\n        for(int i=0; i< bobSizes.length; i++)\\n        {\\n            totalCandiesWithBob += bobSizes[i];\\n        }\\n        \\n        // THE CORE LOGIC OF THIS ANSWER IS DUE TO THE FOLLOWING ASSUMPTION - \"THERE EXISTS ATLEAST ONE ANSWER\".\\n        // So, the difference between atleast one element in the array should be even(divisble by 2) so that we can share half of it with the person with less candies.\\n        // As we constructed the set for Alice\\'s candy boxes, the intention is to search for the difference in that set. So, the difference should be total number of candies with Alice has minus total number of candies that Bob has\\n        int differenceToMatch = (totalCandiesWithAlice-totalCandiesWithBob)/2;\\n        \\n        // loop through all the boxes that bob has\\n        for(int i=0; i<bobSizes.length; i++)\\n        {\\n            // For every box that bob has, check if there exists a box with alice that can split the difference with Bob(this will ensure both of them will have same total count). When found, return the same.\\n            if(setA.contains(bobSizes[i]+differenceToMatch))\\n                return new int[]{bobSizes[i]+differenceToMatch, bobSizes[i]};\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357377,
                "title": "c-code-using-binary-search-o-nlogn",
                "content": "```\\n vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        vector<int> ans;\\n  \\n        \\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int sumalice=0,sumbob=0;\\n        \\n        for(auto x: bobSizes){\\n            sumbob+=x;\\n        }\\n        \\n        \\n        for(auto x: aliceSizes){\\n            sumalice+=x;\\n        }        \\n      \\n        \\n        int z=(sumbob - sumalice)/2;\\n        \\n        for(auto x: aliceSizes){\\n            \\n            int index=lower_bound(bobSizes.begin(),bobSizes.end(),z + x) - bobSizes.begin();\\n            \\n            if(bobSizes[index]==z + x){\\n                ans.push_back(x);\\n                ans.push_back(z + x);\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        vector<int> ans;\\n  \\n        \\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int sumalice=0,sumbob=0;\\n        \\n        for(auto x: bobSizes){\\n            sumbob+=x;\\n        }\\n        \\n        \\n        for(auto x: aliceSizes){\\n            sumalice+=x;\\n        }        \\n      \\n        \\n        int z=(sumbob - sumalice)/2;\\n        \\n        for(auto x: aliceSizes){\\n            \\n            int index=lower_bound(bobSizes.begin(),bobSizes.end(),z + x) - bobSizes.begin();\\n            \\n            if(bobSizes[index]==z + x){\\n                ans.push_back(x);\\n                ans.push_back(z + x);\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265407,
                "title": "python-3-solution-using-hash",
                "content": "**explanation:**\\n\\ntotal amount = total amount alice has + total amount bob has\\nbalance = total amount/2\\nextra amount alice needs to add/subtract = (asize-balance)\\n[if balance>asize, then extra amount will be negative, so (a-extra amount) will eventually end up adding extra amiunt to a]\\n\\nso we need to check\\nif a is the amount of one candy in alice\\'s collection, \\nbobs collection must contain (a-extra amount) as a counterpart.\\nfor that purpose, put b in hash and check for all (a-extra amount) against all a.\\n\\nThat\\'s it\\n```\\ndef fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n\\tasize, bsize = sum(aliceSizes), sum(bobSizes)\\n\\tbalance = (asize+bsize)//2\\n\\tadd = asize-balance\\n\\n\\tb = set(bobSizes)\\n\\n\\tfor a in aliceSizes:\\n\\t\\tif a-add in b:\\n\\t\\t\\treturn [a, a-add]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n\\tasize, bsize = sum(aliceSizes), sum(bobSizes)\\n\\tbalance = (asize+bsize)//2\\n\\tadd = asize-balance\\n\\n\\tb = set(bobSizes)\\n\\n\\tfor a in aliceSizes:\\n\\t\\tif a-add in b:\\n\\t\\t\\treturn [a, a-add]\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1196976,
                "title": "javascript-solution",
                "content": "```\\nvar fairCandySwap = function(A, B) {\\n    let tot = 0;\\n    \\n    const set = new Set();\\n    let sumA = 0;\\n    \\n    for (const num of A) {\\n        tot += num;\\n        sumA += num;\\n    }\\n    \\n    for (const num of B) {\\n        tot += num;\\n        set.add(num);\\n    }\\n    \\n    const half = tot / 2;\\n    \\n    for (const num of A) {\\n        const rem = sumA - num;\\n        const need = half - rem;\\n        \\n        if (set.has(need)) return [num, need];\\n    }\\n\\t\\n\\t// it is guaranteed that an answer exist, so we don\\'t need to return anything here\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fairCandySwap = function(A, B) {\\n    let tot = 0;\\n    \\n    const set = new Set();\\n    let sumA = 0;\\n    \\n    for (const num of A) {\\n        tot += num;\\n        sumA += num;\\n    }\\n    \\n    for (const num of B) {\\n        tot += num;\\n        set.add(num);\\n    }\\n    \\n    const half = tot / 2;\\n    \\n    for (const num of A) {\\n        const rem = sumA - num;\\n        const need = half - rem;\\n        \\n        if (set.has(need)) return [num, need];\\n    }\\n\\t\\n\\t// it is guaranteed that an answer exist, so we don\\'t need to return anything here\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950709,
                "title": "c-91",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(const vector<int>& a, vector<int>& b) {\\n        int diff=(accumulate(a.begin(),a.end(),0)-accumulate(b.begin(),b.end(),0))/2;\\n        sort(b.begin(),b.end());\\n        for(auto i:a)\\n            if(binary_search(b.begin(),b.end(),i-diff)) return {i,i-diff};\\n        return {0,0};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(const vector<int>& a, vector<int>& b) {\\n        int diff=(accumulate(a.begin(),a.end(),0)-accumulate(b.begin(),b.end(),0))/2;\\n        sort(b.begin(),b.end());\\n        for(auto i:a)\\n            if(binary_search(b.begin(),b.end(),i-diff)) return {i,i-diff};\\n        return {0,0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907579,
                "title": "python3-simple-amortized-o-n-with-set-beats-100-in-time",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        B_ = set(B)\\n        d = (sum(A) - sum(B)) // 2\\n        for a in A:\\n            if a - d in B_:\\n                return [a, a - d]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        B_ = set(B)\\n        d = (sum(A) - sum(B)) // 2\\n        for a in A:\\n            if a - d in B_:\\n                return [a, a - d]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484871,
                "title": "c-120ms-in-o-mlog-n",
                "content": "```\\n vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        vector <int> ans;\\n        int aSum,bSum;\\n        aSum = bSum = 0;\\n        sort(A.begin(),A.end());\\n        sort(B.begin(),B.end());\\n        aSum = accumulate(A.begin(),A.end(),0);\\n        bSum = accumulate(B.begin(),B.end(),0);\\n        int target = (aSum-bSum)/2;\\n        \\n        \\n            for(int i=0;i<A.size();i++)\\n            {\\n               // here apply binary search on B\\n                int left = 0;\\n                int right = B.size()-1;\\n                while(left<=right)\\n                {\\n                    int mid = (left+right)/2;\\n                    \\n                    if(B[mid]==A[i]-target)\\n                    {\\n                        ans.push_back(A[i]);\\n                        ans.push_back(B[mid]);\\n                        return ans;\\n                    }else if(A[i]-target<B[mid]){\\n                        right = mid -1;\\n                    }else{\\n                        left = mid+1;\\n                    }\\n                }\\n            }\\n        \\n                 \\n        return ans;         \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        vector <int> ans;\\n        int aSum,bSum;\\n        aSum = bSum = 0;\\n        sort(A.begin(),A.end());\\n        sort(B.begin(),B.end());\\n        aSum = accumulate(A.begin(),A.end(),0);\\n        bSum = accumulate(B.begin(),B.end(),0);\\n        int target = (aSum-bSum)/2;\\n        \\n        \\n            for(int i=0;i<A.size();i++)\\n            {\\n               // here apply binary search on B\\n                int left = 0;\\n                int right = B.size()-1;\\n                while(left<=right)\\n                {\\n                    int mid = (left+right)/2;\\n                    \\n                    if(B[mid]==A[i]-target)\\n                    {\\n                        ans.push_back(A[i]);\\n                        ans.push_back(B[mid]);\\n                        return ans;\\n                    }else if(A[i]-target<B[mid]){\\n                        right = mid -1;\\n                    }else{\\n                        left = mid+1;\\n                    }\\n                }\\n            }\\n        \\n                 \\n        return ans;         \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315803,
                "title": "easy-java-solution-11ms-40-4mb-using-hashset-o-n-m-time-complexity-o-m-space",
                "content": "```\\n    // sum1 - a[i] + b[j] = sum2 + a[i] - b[j]\\n    // sum1 - sum2 = 2*a[i] - 2*b[j]\\n    // b[j] = (2a[i] - sum1 + sum2) / 2 \\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sum1 = 0;\\n        for(int a : A){\\n            sum1+=a;\\n        }\\n        int sum2 = 0;\\n        Set<Integer> hsB = new HashSet<>();\\n        for(int b : B){\\n            sum2+=b;\\n            hsB.add(b);\\n        }\\n        for(int a : A){\\n            int b = (2*a - sum1 + sum2) / 2;\\n            if(hsB.contains(b))\\n                return new int[]{a, b};\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // sum1 - a[i] + b[j] = sum2 + a[i] - b[j]\\n    // sum1 - sum2 = 2*a[i] - 2*b[j]\\n    // b[j] = (2a[i] - sum1 + sum2) / 2 \\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sum1 = 0;\\n        for(int a : A){\\n            sum1+=a;\\n        }\\n        int sum2 = 0;\\n        Set<Integer> hsB = new HashSet<>();\\n        for(int b : B){\\n            sum2+=b;\\n            hsB.add(b);\\n        }\\n        for(int a : A){\\n            int b = (2*a - sum1 + sum2) / 2;\\n            if(hsB.contains(b))\\n                return new int[]{a, b};\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238894,
                "title": "fast-and-readable-c-solution",
                "content": "This C solution faster than 83% of C online Submission and use less than 100% in term of memory usage.\\n```\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* fairCandySwap(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    *returnSize = 2;\\n    int *rst = (int *) calloc(*returnSize, sizeof(int));\\n    int sumA = 0, sumB = 0;\\n    \\n    int i;\\n    for(i = 0; i < ASize; i++){\\n        sumA += A[i];\\n    }\\n    \\n    int minB = INT_MAX, maxB = INT_MIN;\\n    for(i = 0; i < BSize; i++){\\n        sumB += B[i];\\n        if(B[i] > maxB){\\n            maxB = B[i];\\n        }\\n        if(B[i] < minB){\\n            minB = B[i];\\n        }\\n    }\\n    \\n    int *map = (int *) calloc(maxB - minB + 1, sizeof(int));\\n    for(i = 0; i < BSize; i++){\\n        map[B[i] - minB]++;\\n    }\\n    \\n    int delta = (sumB - sumA) / 2;\\n    for(i = 0; i < ASize; A++){\\n        if((A[i] + delta >= minB) && (A[i] + delta <= maxB)){\\n            if(map[A[i] + delta - minB] > 0){\\n                rst[0] = A[i];\\n                rst[1] = A[i] + delta;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return rst;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* fairCandySwap(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    *returnSize = 2;\\n    int *rst = (int *) calloc(*returnSize, sizeof(int));\\n    int sumA = 0, sumB = 0;\\n    \\n    int i;\\n    for(i = 0; i < ASize; i++){\\n        sumA += A[i];\\n    }\\n    \\n    int minB = INT_MAX, maxB = INT_MIN;\\n    for(i = 0; i < BSize; i++){\\n        sumB += B[i];\\n        if(B[i] > maxB){\\n            maxB = B[i];\\n        }\\n        if(B[i] < minB){\\n            minB = B[i];\\n        }\\n    }\\n    \\n    int *map = (int *) calloc(maxB - minB + 1, sizeof(int));\\n    for(i = 0; i < BSize; i++){\\n        map[B[i] - minB]++;\\n    }\\n    \\n    int delta = (sumB - sumA) / 2;\\n    for(i = 0; i < ASize; A++){\\n        if((A[i] + delta >= minB) && (A[i] + delta <= maxB)){\\n            if(map[A[i] + delta - minB] > 0){\\n                rst[0] = A[i];\\n                rst[1] = A[i] + delta;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return rst;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 191392,
                "title": "javascript",
                "content": "```\nvar fairCandySwap = function(A, B) {\n    let sumA = 0, sumB = 0, result=[];\n    for(let a of A) {\n        sumA += a;\n    }\n    for(let b of B) {\n        sumB += b;\n    }\n    let mean = (sumA + sumB) / 2;\n    for(let i = 0; i < A.length; i++) {\n        let t = sumA - A[i];\n        let s = mean - t;\n        if(B.indexOf(s) >= 0 && (sumB - s + A[i] == mean)) {\n            result.push(A[i]);\n            result.push(s);\n            break;\n        }\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar fairCandySwap = function(A, B) {\n    let sumA = 0, sumB = 0, result=[];\n    for(let a of A) {\n        sumA += a;\n    }\n    for(let b of B) {\n        sumB += b;\n    }\n    let mean = (sumA + sumB) / 2;\n    for(let i = 0; i < A.length; i++) {\n        let t = sumA - A[i];\n        let s = mean - t;\n        if(B.indexOf(s) >= 0 && (sumB - s + A[i] == mean)) {\n            result.push(A[i]);\n            result.push(s);\n            break;\n        }\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186961,
                "title": "java-o-n-time-o-n-space-explanation",
                "content": "The idea is the following:\\nlet\\'s assume our arrays are:\\nA=[x1,x2,x3,....,k + d,....xn]\\nB=[y1,y2,y3,.....,k,...ym]\\nLet\\'s imagine we need to exchange only **k + d** and **k**. where **xk=k+d** and **yk=k**.\\nWhen we exchange these elements, aray sums will be the same, so let\\'s derive what are these sums now, before exchanging:\\n##### x1+x2+x3+...+ k +...xn == y1+y2+y3+...+k+d+...ym <->\\n##### x1+x2+x3+...+ k+d +...xn == y1+y2+y3+...+ k+d+d +...ym <->\\n\\u03A3A[] == \\u03A3B[] + 2d\\n\\nSo what we need to do:\\n1. find sums of each array (Java 8 stream)\\n2. find d \\n2. identify what sum is bigger (who is \"richer\"- Alice of Bob)\\n3. find paired elements from A[] and B[] that have d as a difference, taking into account who is richer (solution is similar to 2sum):\\n\\n```\\nclass FairCandySwap {\\n public int[] fairCandySwap(int[] A, int[] B) {\\n  int aliceSum = Arrays.stream(A).reduce(0, (x, y) -> x + y);\\n  int bobSum = Arrays.stream(B).reduce(0, (x, y) -> x + y);;\\n  boolean aliceRicher = (aliceSum - bobSum) > 0;\\n  return fairCandySwap(A, B, Math.abs(aliceSum - bobSum) / 2, aliceRicher);\\n }\\n public int[] fairCandySwap(int[] A, int[] B, int difference, boolean aliceRicher) {\\n  int[] res = new int[2];\\n  Set <Integer> differences = Arrays.stream(B).boxed()\\n   .map(x -> {\\n    if (aliceRicher) x += difference;\\n    else x -= difference;\\n    return x;\\n   })\\n   .collect(Collectors.toSet());\\n  for (int i = 0; i < A.length; i++) {\\n   if (differences.contains(A[i])) res[0] = A[i];\\n   if (aliceRicher) res[1] = res[0] - difference;\\n   else res[1] = res[0] + difference;\\n  }\\n  return res;\\n }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FairCandySwap {\\n public int[] fairCandySwap(int[] A, int[] B) {\\n  int aliceSum = Arrays.stream(A).reduce(0, (x, y) -> x + y);\\n  int bobSum = Arrays.stream(B).reduce(0, (x, y) -> x + y);;\\n  boolean aliceRicher = (aliceSum - bobSum) > 0;\\n  return fairCandySwap(A, B, Math.abs(aliceSum - bobSum) / 2, aliceRicher);\\n }\\n public int[] fairCandySwap(int[] A, int[] B, int difference, boolean aliceRicher) {\\n  int[] res = new int[2];\\n  Set <Integer> differences = Arrays.stream(B).boxed()\\n   .map(x -> {\\n    if (aliceRicher) x += difference;\\n    else x -= difference;\\n    return x;\\n   })\\n   .collect(Collectors.toSet());\\n  for (int i = 0; i < A.length; i++) {\\n   if (differences.contains(A[i])) res[0] = A[i];\\n   if (aliceRicher) res[1] = res[0] - difference;\\n   else res[1] = res[0] + difference;\\n  }\\n  return res;\\n }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161315,
                "title": "python-solution-very-easy-to-understand",
                "content": "We know the difference between two arrays.\\nLets call it diff.\\ncandy_alice is the candy alice gave to bob\\ncandy_bob is the candy bob gave to alice\\nAlice\\'s candy after exchange: sumA - candy_alice + candy_bob\\nBob\\'s candy after exchange : sumB - candy_bob + candy_alice\\nThese two should equal after exchange:\\nsumA - candy_alice + candy_bob = sumB - candy_bob + candy_alice\\nuse math we can get: sumA - sumB = 2*(candy_alice - candy_bob) = diff\\nWe can represent candy bob as: candy_alice - diff/2\\nthen, for each element in A, check if candy_alice - diff/2 is in B\\n\\n```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # calculate difference between A, B\\n        diff = sum(A) - sum(B)\\n        A = set(A)\\n        B = set(B)\\n        for item in A:\\n            item2 = item - float(diff/2)\\n            if item2 in B:\\n                return [item,int(item2)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # calculate difference between A, B\\n        diff = sum(A) - sum(B)\\n        A = set(A)\\n        B = set(B)\\n        for item in A:\\n            item2 = item - float(diff/2)\\n            if item2 in B:\\n                return [item,int(item2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944531,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum_A = aliceSizes.Sum();\\n        int sum_B = bobSizes.Sum();\\n        int[] answer = new int[2];\\n\\n        int diff = (sum_B - sum_A)/ 2;\\n        for (int i = 0; i < aliceSizes.Length; i++){\\n            if (bobSizes.Contains(aliceSizes[i] + diff)){\\n                answer[0] = aliceSizes[i];\\n                answer[1] = aliceSizes[i] + diff;\\n                break;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum_A = aliceSizes.Sum();\\n        int sum_B = bobSizes.Sum();\\n        int[] answer = new int[2];\\n\\n        int diff = (sum_B - sum_A)/ 2;\\n        for (int i = 0; i < aliceSizes.Length; i++){\\n            if (bobSizes.Contains(aliceSizes[i] + diff)){\\n                answer[0] = aliceSizes[i];\\n                answer[1] = aliceSizes[i] + diff;\\n                break;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936725,
                "title": "o-n-beginner-friendly-fully-explained",
                "content": "# Approach\\nTo find the candies that Alice and Bob need to exchange, we want to make the total number of candies held by both Alice and Bob equal. We\\'ll use a \"Two-Sum\" approach to find a candy from Alice and a candy from Bob that, when swapped, will lead to equal candy totals.\\n\\n**Logic:**\\n1. Calculate the total number of candies Alice and Bob have:\\n   - Iterate through both `aliceSizes` and `bobSizes` arrays and calculate the sum of candies Alice and Bob have, stored in `sumAlice` and `sumBob`.\\n\\n2. Create a HashSet for Bob\\'s candies:\\n   - Iterate through `bobSizes` and add each candy\\'s size to a HashSet named `bobSet`. This helps in fast lookups when we check if a certain candy is available in Bob\\'s collection.\\n\\n3. Calculate the target difference:\\n   - Calculate the target difference `targetDiff` between Alice and Bob\\'s total candies by subtracting `sumAlice` from `sumBob`.\\n\\n4. Find the candies for exchange:\\n   - Iterate through Alice\\'s candies using `aliceSizes`. For each candy size `aliceSize`, calculate the corresponding candy size `bobSize` that Bob would need to have a fair swap. Calculate this by adding `targetDiff` to `aliceSize`.\\n   - Check if `bobSet` contains the calculated `bobSize`. If it does, it means that a valid pair of candies for a fair swap has been found.\\n\\n5. Return the result:\\n   - If a valid pair is found, return an array containing Alice\\'s candy size and the calculated `bobSize` (the candy Bob needs to exchange).\\n   - If no valid pair is found, return a default array with zeros.\\n\\nThis approach ensures that Alice and Bob will have the same total number of candies after the swap. The \"Two-Sum\" technique simplifies the problem into finding a specific difference and checking if an element exists in a set, making the solution efficient and easy to understand.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(max(n, m))$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int[] ans = new int[2];\\n\\n        int sumAlice = 0;\\n        for (int a : aliceSizes)\\n            sumAlice += a;\\n\\n        int sumBob = 0;\\n        Set<Integer> bobSet = new HashSet<>();\\n        for (int b : bobSizes) {\\n            sumBob += b;\\n            bobSet.add(b);\\n        }\\n\\n        int targetDiff = (sumBob - sumAlice) / 2;\\n        for (int aliceSize : aliceSizes) {\\n            int bobSize = aliceSize + targetDiff;\\n            if (bobSet.contains(bobSize)) {\\n                ans[0] = aliceSize;\\n                ans[1] = bobSize;\\n                return ans;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int[] ans = new int[2];\\n\\n        int sumAlice = 0;\\n        for (int a : aliceSizes)\\n            sumAlice += a;\\n\\n        int sumBob = 0;\\n        Set<Integer> bobSet = new HashSet<>();\\n        for (int b : bobSizes) {\\n            sumBob += b;\\n            bobSet.add(b);\\n        }\\n\\n        int targetDiff = (sumBob - sumAlice) / 2;\\n        for (int aliceSize : aliceSizes) {\\n            int bobSize = aliceSize + targetDiff;\\n            if (bobSet.contains(bobSize)) {\\n                ans[0] = aliceSize;\\n                ans[1] = bobSize;\\n                return ans;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791647,
                "title": "java-two-pointer-binary-search-easy-solution",
                "content": "# Intuition\\nI have two approaches to solve this problem. \\n1- Two ponter\\n2- Binary Search.\\nI will explain both in below section.\\n# Approach\\n1 - Two Pointer approach :\\nA- first find total sum of alice and bob before exchange. \\nB- Now run the two loop and check what alice exchange by using this = aliceTotal - alicesize[i] + bobsize[j], means alice is giving one element and taking one element brom bob. \\nC- Do the same thing for bob exchange. \\nD- once you found both exchange then again compare with both sum of exchanges, if equal then return otherwise again check.\\n\\nNote :: I explaine this in a very nice way in my gitHub repo.\\nPlease check this one as well as:\\nhttps://github.com/Sufiyan33/Data-Structure\\n\\n2 - Binary Search\\nFirst four steps would be same as above :\\npublic static int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n\\t\\t// first we have to find total sum of each before exchanges.\\n\\t\\tint aliceTotal = 0;\\n\\t\\tint bobTotal = 0;\\n\\n\\t\\tfor (int aa : aliceSizes) {\\n\\t\\t\\taliceTotal += aa;\\n\\t\\t}\\n\\t\\tfor (int bb : bobSizes) {\\n\\t\\t\\tbobTotal += bb;\\n\\t\\t}\\n\\t\\t// Now iterate aliceSize array and then try to find out target so that we can do\\n\\t\\t// binary search.\\n\\n\\t\\tfor (int i = 0; i < aliceSizes.length; i++) {\\n\\t\\t\\t// here we will use some mathmatics to find mid value;\\n\\t\\t\\t/*\\n\\t\\t\\t * see as previouse example I explained very well. aliceTotal - aliceSizes[i] +\\n\\t\\t\\t * bobSizes[j] = bobTotal - bobSizes[j]+aliceSizes[i] aliceTotal = bobTotal +\\n\\t\\t\\t * aliceSizes[i] + aliceSizes[i] - bobSizes[j]-bobSizes[j] aliceTotal = bobTotal\\n\\t\\t\\t * + 2 * aliceSizes[i] - 2* bobSizes[j];\\n\\t\\t\\t * \\n\\t\\t\\t * 2 bobSizes[j] = bobTotal - aliceTotal + 2 * aliceSizes[i]; bobSizes[j] =\\n\\t\\t\\t * (bobTotal - aliceTotal + 2 * aliceSizes[i])/2\\n\\t\\t\\t */\\n\\n\\t\\t\\t/*\\n\\t\\t\\t * Here in this case we will take bobsize array as target to do binar search.\\n\\t\\t\\t * Hence we need to first sort bobsArray\\n\\t\\t\\t */\\n\\t\\t\\tint target = (bobTotal - aliceTotal + 2 * aliceSizes[i]) / 2;\\n\\t\\t\\tif (binarySearch(bobSizes, target)) {\\n\\t\\t\\t\\treturn new int[] { aliceSizes[i], target };\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new int[0];\\n\\t}\\n\\n\\tpublic static boolean binarySearch(int[] arr, int target) {\\n\\t\\tint start = 0;\\n\\t\\tint end = arr.length - 1;\\n\\t\\tint mid = start + (end - start) / 2;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tif (target > arr[mid])\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\tif (target < arr[mid])\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        //using two pinter approach.\\n        int aliceTotal = 0;\\n        int bobTotal = 0;\\n        //Find sum of alice candies before exchange.\\n        for(int aa : aliceSizes)\\n            aliceTotal += aa;\\n        //Find sum of bob candies before exchange.\\n        for(int bb : bobSizes)\\n            bobTotal += bb;\\n        \\n        for(int i = 0; i< aliceSizes.length; i++){\\n            for(int j = 0; j< bobSizes.length; j++){\\n                int aliceExchange = aliceTotal - aliceSizes[i] + bobSizes[j];\\n                int bobExchange = bobTotal - bobSizes[j] + aliceSizes[i];\\n                if(aliceExchange == bobExchange){\\n                    return new int[]{aliceSizes[i], bobSizes[j]};\\n                }\\n            }\\n        }\\n        return new int[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        //using two pinter approach.\\n        int aliceTotal = 0;\\n        int bobTotal = 0;\\n        //Find sum of alice candies before exchange.\\n        for(int aa : aliceSizes)\\n            aliceTotal += aa;\\n        //Find sum of bob candies before exchange.\\n        for(int bb : bobSizes)\\n            bobTotal += bb;\\n        \\n        for(int i = 0; i< aliceSizes.length; i++){\\n            for(int j = 0; j< bobSizes.length; j++){\\n                int aliceExchange = aliceTotal - aliceSizes[i] + bobSizes[j];\\n                int bobExchange = bobTotal - bobSizes[j] + aliceSizes[i];\\n                if(aliceExchange == bobExchange){\\n                    return new int[]{aliceSizes[i], bobSizes[j]};\\n                }\\n            }\\n        }\\n        return new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511718,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        bitset<200002> bf;\\n        int sumA = 0, sumB = 0;\\n        for(auto n: A) {\\n            sumA += n;\\n        }\\n        for(auto n: B) {\\n            sumB += n;\\n            bf.set(2*n);\\n        }\\n        int diff = sumA - sumB;\\n        for(auto n: A) {\\n            int det = 2*n - diff;\\n            if(det > 0 && det < 200002 && bf.test(det)) {\\n                return {n, (2*n-diff)/2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        \\n        x = (sum(aliceSizes)-sum(bobSizes)) / 2\\n\\n        sets = set(aliceSizes)\\n\\n        for y in bobSizes:\\n            if y + x in sets: \\n                return [y + x, y]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int aum = 0;\\n        boolean[] inAlice = new boolean[100001];\\n        for (int i = 0; i < aliceSizes.length; i++) {\\n            aum += aliceSizes[i];\\n            inAlice[aliceSizes[i]] = true;\\n        }\\n        int bum = 0;\\n        for (int i = 0; i < bobSizes.length; i++) {\\n            bum += bobSizes[i];\\n        }\\n        int diff = aum - bum;\\n        int[] ans = new int[2];\\n        for (int i = 0; i < bobSizes.length; i++) {\\n            int target = bobSizes[i] + diff / 2;\\n            if (target > 0 && target < 100001) {\\n                if (inAlice[target]) {\\n                    ans = new int[] {target, bobSizes[i]};\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        bitset<200002> bf;\\n        int sumA = 0, sumB = 0;\\n        for(auto n: A) {\\n            sumA += n;\\n        }\\n        for(auto n: B) {\\n            sumB += n;\\n            bf.set(2*n);\\n        }\\n        int diff = sumA - sumB;\\n        for(auto n: A) {\\n            int det = 2*n - diff;\\n            if(det > 0 && det < 200002 && bf.test(det)) {\\n                return {n, (2*n-diff)/2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```Python3 []\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        \\n        x = (sum(aliceSizes)-sum(bobSizes)) / 2\\n\\n        sets = set(aliceSizes)\\n\\n        for y in bobSizes:\\n            if y + x in sets: \\n                return [y + x, y]\\n```\n```Java []\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int aum = 0;\\n        boolean[] inAlice = new boolean[100001];\\n        for (int i = 0; i < aliceSizes.length; i++) {\\n            aum += aliceSizes[i];\\n            inAlice[aliceSizes[i]] = true;\\n        }\\n        int bum = 0;\\n        for (int i = 0; i < bobSizes.length; i++) {\\n            bum += bobSizes[i];\\n        }\\n        int diff = aum - bum;\\n        int[] ans = new int[2];\\n        for (int i = 0; i < bobSizes.length; i++) {\\n            int target = bobSizes[i] + diff / 2;\\n            if (target > 0 && target < 100001) {\\n                if (inAlice[target]) {\\n                    ans = new int[] {target, bobSizes[i]};\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3233167,
                "title": "java-solution-without-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA=0;\\n        int sumB = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int alice:aliceSizes){\\n            sumA+=alice;\\n            hs.add(alice);\\n        }\\n        for(int bob:bobSizes){\\n            sumB+=bob;\\n        }\\n        int diff = (sumA-sumB)/2;\\n        for(int i =0;i<bobSizes.length;i++){\\n            int target = diff+bobSizes[i];\\n            if(hs.contains(target)){\\n                return new int[]{target, bobSizes[i]};\\n            }\\n        }\\n        \\n        return null;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA=0;\\n        int sumB = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int alice:aliceSizes){\\n            sumA+=alice;\\n            hs.add(alice);\\n        }\\n        for(int bob:bobSizes){\\n            sumB+=bob;\\n        }\\n        int diff = (sumA-sumB)/2;\\n        for(int i =0;i<bobSizes.length;i++){\\n            int target = diff+bobSizes[i];\\n            if(hs.contains(target)){\\n                return new int[]{target, bobSizes[i]};\\n            }\\n        }\\n        \\n        return null;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211098,
                "title": "awesome-approaches-fully-explained-2-approaches-c",
                "content": "# Intuition\\nWe have to make the number of total candies equal by exchanging one box each. So after Exchanging our boxes,The sum for both person will become (sum1 + sum2) / 2 which will be our target.\\n\\nSince we can exchange only one boxes start traversing alice or bob, and suppose we want to exchange the curent box, if y is present on other side then return {curr,y} where y is\\n\\n=> sum1-curr = target-y\\n=> y = target-sum1+cur;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) || O(N)\\n\\n- Space complexity:\\nO(1) || O(N)\\n\\n# Approach\\n\\n1.) **O(NLogN) Time Complexity using Sorting**\\nFor searching y on bob side , If you are traversing in Alice Side,  You can sort Bob Boxes and then use binary search to find y.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        int sum1=0; \\n        int sum2=0;\\n\\n        for(auto i:aliceSizes) sum1+=i;\\n        for(auto i:bobSizes) sum2+=i;\\n\\n        int target = (sum1+sum2)/2; \\n\\n        sort(bobSizes.begin(),bobSizes.end());\\n\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int cur=aliceSizes[i];\\n            int y=target-sum1+cur;\\n            if(binary_search(bobSizes.begin(),bobSizes.end(),y)) return {cur,y};\\n        }\\n\\n        // Nothing is find (which is not possible according to question)\\n        return {};\\n    }\\n};\\n```\\n\\n2.) **O(N) Time Complexity Appraoch using Hashset/Hashmap**\\nFor searching y on Bob Side, You can first store Bob values in Hashset or Hashmap, Then you can search for y in O(1) Time\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        int sum1=0; \\n        int sum2=0; \\n\\n        for(auto i:aliceSizes) sum1+=i;\\n        \\n        for(auto i:bobSizes)\\n        {\\n            sum2+=i;\\n            bob.insert(i);\\n        }\\n\\n        int target = (sum1+sum2)/2; \\n\\n        unordered_set<int> bob;\\n\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int cur=aliceSizes[i]; \\n            int y=target-sum1+cur;\\n            if(bob.find(y)!=bob.end()) return {cur,y};\\n        }\\n\\n        return {};\\n    }\\n};\\n```\\n\\n\\n\\n\\nPLEASE UPVOTE ME IF MY SOLUTION HELPED YOU \\n![image.png](https://assets.leetcode.com/users/images/d820bc6f-f7ae-4b81-9ec7-df7f92e5359a_1676914309.4178846.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        int sum1=0; \\n        int sum2=0;\\n\\n        for(auto i:aliceSizes) sum1+=i;\\n        for(auto i:bobSizes) sum2+=i;\\n\\n        int target = (sum1+sum2)/2; \\n\\n        sort(bobSizes.begin(),bobSizes.end());\\n\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int cur=aliceSizes[i];\\n            int y=target-sum1+cur;\\n            if(binary_search(bobSizes.begin(),bobSizes.end(),y)) return {cur,y};\\n        }\\n\\n        // Nothing is find (which is not possible according to question)\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        int sum1=0; \\n        int sum2=0; \\n\\n        for(auto i:aliceSizes) sum1+=i;\\n        \\n        for(auto i:bobSizes)\\n        {\\n            sum2+=i;\\n            bob.insert(i);\\n        }\\n\\n        int target = (sum1+sum2)/2; \\n\\n        unordered_set<int> bob;\\n\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int cur=aliceSizes[i]; \\n            int y=target-sum1+cur;\\n            if(bob.find(y)!=bob.end()) return {cur,y};\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172928,
                "title": "easy-to-understand-c-solution-using-map-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        map <int,int> mp;\\n        vector <int> v(2);\\n        int sum1=0,sum2=0;\\n        for(int i:bobSizes){\\n            mp[i]++;\\n            sum2+=i;\\n        } \\n        for(int i:aliceSizes) sum1+=i;\\n        for(int i:aliceSizes){\\n            if(mp.find((sum2-sum1+i+i)/2)!=mp.end()){\\n                v[0]=i;\\n                v[1]=(sum2-sum1+i+i)/2;\\n                return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        map <int,int> mp;\\n        vector <int> v(2);\\n        int sum1=0,sum2=0;\\n        for(int i:bobSizes){\\n            mp[i]++;\\n            sum2+=i;\\n        } \\n        for(int i:aliceSizes) sum1+=i;\\n        for(int i:aliceSizes){\\n            if(mp.find((sum2-sum1+i+i)/2)!=mp.end()){\\n                v[0]=i;\\n                v[1]=(sum2-sum1+i+i)/2;\\n                return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111814,
                "title": "simplest-java-solution",
                "content": "**I know this code is little lengthy and slow but it is simplest that i can think at first thought**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : BruteForce , Linear Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    \\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        // calculating the sum of both candies and equal number of candies after swapping candies\\n        int sumAlice = sum(aliceSizes);\\n        int sumbob = sum(bobSizes);\\n        int equal = (sumAlice + sumbob)/2;\\n        \\n        //calculating the difference\\n        int diff;\\n        int vari;\\n        // vari is made to  vari  = alicesize[i] + diff\\n        /* \\n        aliceSizes[1,2,3,4,8,6]= 24 bobSizes[2,2,3,5,6,7,1] = 26\\n\\n        equal  = (24 + 26 )/2 = 25;\\n\\n        diff = 25 - 24 = 1;\\n\\n        var = diff + aliceSizes[0] == 1 + 1 = 2;\\n         \\n         linear search for  2 in bobsizes if found return [alicesSizes[0],bobSizes[i]];\\n\\n         if not then go for \\n\\n         var = diff + aliceSizes[1] = 1 + 2 = 3;\\n        \\n        now linear search  for three;\\n\\n        \\n        \\n        */\\n           if(sumAlice<equal){\\n               diff = equal - sumAlice;\\n               for(int i=0;i<aliceSizes.length;i++){\\n               vari = aliceSizes[i] + diff;\\n               for(int j=0;j<bobSizes.length;j++){\\n                   if(vari == bobSizes[j]){\\n                       return new int[]{aliceSizes[i],bobSizes[j]};\\n                   }\\n               }\\n                   \\n               }\\n           }\\n    \\n        if(sumbob<equal){\\n               diff = equal - sumbob;\\n               for(int i=0;i<bobSizes.length;i++){\\n               vari = bobSizes[i] + diff;\\n               for(int j=0;j<aliceSizes.length;j++){\\n                   if(vari == aliceSizes[j]){\\n                       return new int[]{aliceSizes[j],bobSizes[i]};\\n                   }\\n               }\\n                   \\n               }\\n           }\\n        \\n    return new int[]{0,0};\\n\\n\\n    }\\n    static int sum(int[] arr){\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n        }\\n        return sum;\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    \\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        // calculating the sum of both candies and equal number of candies after swapping candies\\n        int sumAlice = sum(aliceSizes);\\n        int sumbob = sum(bobSizes);\\n        int equal = (sumAlice + sumbob)/2;\\n        \\n        //calculating the difference\\n        int diff;\\n        int vari;\\n        // vari is made to  vari  = alicesize[i] + diff\\n        /* \\n        aliceSizes[1,2,3,4,8,6]= 24 bobSizes[2,2,3,5,6,7,1] = 26\\n\\n        equal  = (24 + 26 )/2 = 25;\\n\\n        diff = 25 - 24 = 1;\\n\\n        var = diff + aliceSizes[0] == 1 + 1 = 2;\\n         \\n         linear search for  2 in bobsizes if found return [alicesSizes[0],bobSizes[i]];\\n\\n         if not then go for \\n\\n         var = diff + aliceSizes[1] = 1 + 2 = 3;\\n        \\n        now linear search  for three;\\n\\n        \\n        \\n        */\\n           if(sumAlice<equal){\\n               diff = equal - sumAlice;\\n               for(int i=0;i<aliceSizes.length;i++){\\n               vari = aliceSizes[i] + diff;\\n               for(int j=0;j<bobSizes.length;j++){\\n                   if(vari == bobSizes[j]){\\n                       return new int[]{aliceSizes[i],bobSizes[j]};\\n                   }\\n               }\\n                   \\n               }\\n           }\\n    \\n        if(sumbob<equal){\\n               diff = equal - sumbob;\\n               for(int i=0;i<bobSizes.length;i++){\\n               vari = bobSizes[i] + diff;\\n               for(int j=0;j<aliceSizes.length;j++){\\n                   if(vari == aliceSizes[j]){\\n                       return new int[]{aliceSizes[j],bobSizes[i]};\\n                   }\\n               }\\n                   \\n               }\\n           }\\n        \\n    return new int[]{0,0};\\n\\n\\n    }\\n    static int sum(int[] arr){\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n        }\\n        return sum;\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078758,
                "title": "beating-94-using-only-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check ( vector < int > & b , int x , int sum1 , int sum2 ){\\n        int left =0  ; \\n        int right = b.size() - 1 ; \\n        while ( left <= right ){\\n            int mid = ( left + right ) / 2 ; \\n            int v = sum1 + b[mid] -x ; \\n            int c = sum2 + x - b[mid] ; \\n            if ( v == c)\\n             return mid ; \\n             if ( v < c ) \\n              left = mid + 1 ; \\n              else \\n              right = mid -1 ; \\n        }\\n        return -1 ; \\n    }\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n         sort ( b.begin() , b.end() ) ; \\n         int sum1 = 0 , sum2 = 0 ; \\n         for ( int i =0 ; i < a.size() ; i++) sum1 += a[i] ;\\n         for ( int i = 0 ; i < b.size() ; i++) sum2 +=b[i] ; \\n         vector < int > ans ( 2 ) ; \\n         for ( int i=0 ; i < a.size() ; i++) {\\n             int v = check ( b , a[i] , sum1 , sum2 ) ; \\n             if ( v == -1 ) continue;\\n             ans[0] = a[i] ; \\n             ans[1] = b[v] ; \\n             break;\\n         }\\n         return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check ( vector < int > & b , int x , int sum1 , int sum2 ){\\n        int left =0  ; \\n        int right = b.size() - 1 ; \\n        while ( left <= right ){\\n            int mid = ( left + right ) / 2 ; \\n            int v = sum1 + b[mid] -x ; \\n            int c = sum2 + x - b[mid] ; \\n            if ( v == c)\\n             return mid ; \\n             if ( v < c ) \\n              left = mid + 1 ; \\n              else \\n              right = mid -1 ; \\n        }\\n        return -1 ; \\n    }\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n         sort ( b.begin() , b.end() ) ; \\n         int sum1 = 0 , sum2 = 0 ; \\n         for ( int i =0 ; i < a.size() ; i++) sum1 += a[i] ;\\n         for ( int i = 0 ; i < b.size() ; i++) sum2 +=b[i] ; \\n         vector < int > ans ( 2 ) ; \\n         for ( int i=0 ; i < a.size() ; i++) {\\n             int v = check ( b , a[i] , sum1 , sum2 ) ; \\n             if ( v == -1 ) continue;\\n             ans[0] = a[i] ; \\n             ans[1] = b[v] ; \\n             break;\\n         }\\n         return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959108,
                "title": "my-c-solution-with-complexity-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int>v;\\n        map<int,int>m;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<aliceSizes.size();i++){\\n        sum1=sum1+aliceSizes[i];\\n\\n      }\\n        for(int i=0;i<bobSizes.size();i++){\\n        sum2=sum2+bobSizes[i];\\n        m[bobSizes[i]]=i;\\n        }\\n        int t=(sum1-sum2)/2;\\n        for(int i=0;i<aliceSizes.size();i++){\\n             if(m.count(aliceSizes[i]-t)){\\n                 v.push_back(aliceSizes[i]);\\n                 v.push_back(aliceSizes[i]-t);\\n                 break;\\n             }\\n        }\\n     \\n    \\n     return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int>v;\\n        map<int,int>m;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<aliceSizes.size();i++){\\n        sum1=sum1+aliceSizes[i];\\n\\n      }\\n        for(int i=0;i<bobSizes.size();i++){\\n        sum2=sum2+bobSizes[i];\\n        m[bobSizes[i]]=i;\\n        }\\n        int t=(sum1-sum2)/2;\\n        for(int i=0;i<aliceSizes.size();i++){\\n             if(m.count(aliceSizes[i]-t)){\\n                 v.push_back(aliceSizes[i]);\\n                 v.push_back(aliceSizes[i]-t);\\n                 break;\\n             }\\n        }\\n     \\n    \\n     return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748738,
                "title": "c-binary-search-easy-115-ms",
                "content": "```\\nint sum_a = 0, sum_b = 0;\\n        vector <int> ans;\\n        \\n        sort(bobSizes.begin(),bobSizes.end());\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n\\n        \\n        for(int i = 0; i < aliceSizes.size(); i++) {\\n            sum_a = aliceSizes[i] + sum_a;\\n        }\\n        \\n        for(int i = 0; i < bobSizes.size(); i++) {\\n            sum_b = bobSizes[i] + sum_b;\\n        }\\n        \\n        int diff = (sum_a - sum_b)/2;\\n        \\n        for(int i = 0 ; i <aliceSizes.size(); i++) {\\n        \\n        int s = 0;\\n        int e = bobSizes.size()-1;\\n        \\n        while(s<=e)\\n        {\\n            int mid = s + (e-s)/2;\\n            \\n            if(bobSizes[mid] == aliceSizes[i]-diff) {\\n                ans.push_back(aliceSizes[i]);\\n                ans.push_back(bobSizes[mid]);\\n                return ans;\\n            }\\n            \\n            else if(bobSizes[mid] < aliceSizes[i]-diff) {\\n                s = mid + 1;\\n            }\\n            \\n            else if(bobSizes[mid] > aliceSizes[i]-diff) {\\n                e = mid - 1;\\n            }\\n              \\n        }    \\n    }\\n        \\n        return ans;",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint sum_a = 0, sum_b = 0;\\n        vector <int> ans;\\n        \\n        sort(bobSizes.begin(),bobSizes.end());\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n\\n        \\n        for(int i = 0; i < aliceSizes.size(); i++) {\\n            sum_a = aliceSizes[i] + sum_a;\\n        }\\n        \\n        for(int i = 0; i < bobSizes.size(); i++) {\\n            sum_b = bobSizes[i] + sum_b;\\n        }\\n        \\n        int diff = (sum_a - sum_b)/2;\\n        \\n        for(int i = 0 ; i <aliceSizes.size(); i++) {\\n        \\n        int s = 0;\\n        int e = bobSizes.size()-1;\\n        \\n        while(s<=e)\\n        {\\n            int mid = s + (e-s)/2;\\n            \\n            if(bobSizes[mid] == aliceSizes[i]-diff) {\\n                ans.push_back(aliceSizes[i]);\\n                ans.push_back(bobSizes[mid]);\\n                return ans;\\n            }\\n            \\n            else if(bobSizes[mid] < aliceSizes[i]-diff) {\\n                s = mid + 1;\\n            }\\n            \\n            else if(bobSizes[mid] > aliceSizes[i]-diff) {\\n                e = mid - 1;\\n            }\\n              \\n        }    \\n    }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2707860,
                "title": "java",
                "content": "//brute force\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA=0,sumB=0;\\n        for(int i=0;i<aliceSizes.length;i++)\\n            sumA+=aliceSizes[i];\\n        for(int i=0;i<bobSizes.length;i++)\\n            sumB+=bobSizes[i];\\n\\n        int diff =(sumA-sumB)/2;\\n        \\n        for(int i=0;i<aliceSizes.length;i++)\\n            for(int j=0;j<bobSizes.length;j++)\\n                if(aliceSizes[i]-bobSizes[j]==diff)\\n                    return new int[]{aliceSizes[i],bobSizes[j]};\\n                return null;\\n         \\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA=0,sumB=0;\\n        for(int i=0;i<aliceSizes.length;i++)\\n            sumA+=aliceSizes[i];\\n        for(int i=0;i<bobSizes.length;i++)\\n            sumB+=bobSizes[i];\\n\\n        int diff =(sumA-sumB)/2;\\n        \\n        for(int i=0;i<aliceSizes.length;i++)\\n            for(int j=0;j<bobSizes.length;j++)\\n                if(aliceSizes[i]-bobSizes[j]==diff)\\n                    return new int[]{aliceSizes[i],bobSizes[j]}",
                "codeTag": "Java"
            },
            {
                "id": 2624282,
                "title": "find-the-difference-from-the-mid-i-e-sum-of-array1-and-array2-2-and-search-it-in-other-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& as, vector<int>& bs) {\\n        \\n        \\n        int n = as.size();\\n        int m = bs.size();\\n        \\n        int val1 = accumulate(as.begin(),as.end(),0);\\n        int val2 = accumulate(bs.begin(),bs.end(),0);\\n        unordered_map<int ,int> mp,mp2;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            mp[bs[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp2[as[i]] = i;\\n        }\\n        \\n        if(val1 == val2)\\n            return {0,0};\\n        \\n        int mid = (val1+val2)/2;\\n        if(mid>val1){\\n             for(int i=0;i<n;i++)\\n             {\\n                 int f = mid-(val1-as[i]);\\n                 if(mp.count(f))\\n                 {\\n                     return {as[i],f};\\n                 }\\n             }\\n        }\\n        \\n        if(mid>val2){\\n             for(int i=0;i<m;i++)\\n             {\\n                 int f= mid-(val2-bs[i]);\\n                 if(mp2.count(f))\\n                 {\\n                     return {f,bs[i]};\\n                 }\\n             }\\n        }\\n        \\n        return {0,0};\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& as, vector<int>& bs) {\\n        \\n        \\n        int n = as.size();\\n        int m = bs.size();\\n        \\n        int val1 = accumulate(as.begin(),as.end(),0);\\n        int val2 = accumulate(bs.begin(),bs.end(),0);\\n        unordered_map<int ,int> mp,mp2;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            mp[bs[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp2[as[i]] = i;\\n        }\\n        \\n        if(val1 == val2)\\n            return {0,0};\\n        \\n        int mid = (val1+val2)/2;\\n        if(mid>val1){\\n             for(int i=0;i<n;i++)\\n             {\\n                 int f = mid-(val1-as[i]);\\n                 if(mp.count(f))\\n                 {\\n                     return {as[i],f};\\n                 }\\n             }\\n        }\\n        \\n        if(mid>val2){\\n             for(int i=0;i<m;i++)\\n             {\\n                 int f= mid-(val2-bs[i]);\\n                 if(mp2.count(f))\\n                 {\\n                     return {f,bs[i]};\\n                 }\\n             }\\n        }\\n        \\n        return {0,0};\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570047,
                "title": "js-faster-than-100-best-solution-with-hashmap",
                "content": "![image](https://assets.leetcode.com/users/images/9d7beb52-cddd-4522-babd-83eaf30b4061_1663058151.6730382.png)\\n```\\nvar fairCandySwap = function(aliceSizes, bobSizes) {\\n    const totalAliceSize = aliceSizes.reduce((prev, current) => prev + current, 0);\\n    const totalBobSize = bobSizes.reduce((prev, current) => prev + current, 0);\\n    \\n    const resolve = (array1, array2, difference) => {\\n        const hashmap = new Map();\\n        for (let i = 0; i < array1.length; i++) {\\n            hashmap.set(array1[i], i);\\n        }\\n        \\n        for (let i = 0; i < array2.length; i++) {\\n            if (hashmap.has(array2[i] + difference/2)) return [array2[i] + difference/2, array2[i]];\\n        }\\n    }\\n    \\n    return resolve(aliceSizes, bobSizes, totalAliceSize - totalBobSize);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fairCandySwap = function(aliceSizes, bobSizes) {\\n    const totalAliceSize = aliceSizes.reduce((prev, current) => prev + current, 0);\\n    const totalBobSize = bobSizes.reduce((prev, current) => prev + current, 0);\\n    \\n    const resolve = (array1, array2, difference) => {\\n        const hashmap = new Map();\\n        for (let i = 0; i < array1.length; i++) {\\n            hashmap.set(array1[i], i);\\n        }\\n        \\n        for (let i = 0; i < array2.length; i++) {\\n            if (hashmap.has(array2[i] + difference/2)) return [array2[i] + difference/2, array2[i]];\\n        }\\n    }\\n    \\n    return resolve(aliceSizes, bobSizes, totalAliceSize - totalBobSize);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489838,
                "title": "c-short-solution-no-map-o-n-time-paperba1l",
                "content": "1) the final sum has to be equal to (aliceSum + bobSum) / 2, lets call it **sm**\\n2) Pick one array, either alice\\'s or bob\\'s does not matter.\\n3) remove one box from the selected list\\n4) the sum of the list reduces by box size which was removed \\n5) if we now want to make the total sum of the selected list  equal to **sm** then we need exactly **(sm2 - box_removed)** from the other list.\\n6) we can use a map, but can use an array to just flag the presence of an integer in a list.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sm1 = 0;\\n        int sm2 = 0;\\n        for(int s : aliceSizes) {\\n            sm1+=s;\\n        }\\n        \\n        int mpp[100000+4];\\n        memset(mpp, 0, sizeof(mpp));\\n        for(int s : bobSizes) {\\n            sm2+=s;\\n            mpp[s]++;\\n        }\\n        \\n        int sm = (sm2 + sm1);\\n        if((sm%2) == 1) {\\n            return {};\\n        }\\n        \\n        sm/=2;\\n        \\n        for(int s : aliceSizes) {\\n            int new_alice_sm = sm1 - s;\\n            if(new_alice_sm >= sm) {\\n                continue;\\n            }\\n            \\n            int extra_wt_needed = sm - new_alice_sm;\\n            if(extra_wt_needed > (1e5)) {\\n                continue;\\n            }\\n            if(mpp[extra_wt_needed] != 0) {\\n                return {s, extra_wt_needed};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sm1 = 0;\\n        int sm2 = 0;\\n        for(int s : aliceSizes) {\\n            sm1+=s;\\n        }\\n        \\n        int mpp[100000+4];\\n        memset(mpp, 0, sizeof(mpp));\\n        for(int s : bobSizes) {\\n            sm2+=s;\\n            mpp[s]++;\\n        }\\n        \\n        int sm = (sm2 + sm1);\\n        if((sm%2) == 1) {\\n            return {};\\n        }\\n        \\n        sm/=2;\\n        \\n        for(int s : aliceSizes) {\\n            int new_alice_sm = sm1 - s;\\n            if(new_alice_sm >= sm) {\\n                continue;\\n            }\\n            \\n            int extra_wt_needed = sm - new_alice_sm;\\n            if(extra_wt_needed > (1e5)) {\\n                continue;\\n            }\\n            if(mpp[extra_wt_needed] != 0) {\\n                return {s, extra_wt_needed};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489060,
                "title": "java-97-21-faster-solution-o-n",
                "content": "class Solution {\\n\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int totalA=0;\\n        int totalB=0;\\n        \\n        for(int a:aliceSizes){\\n            totalA = totalA + a;\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int b:bobSizes){\\n            totalB = totalB + b;\\n            set.add(b);\\n        }\\n        \\n        int delta = (totalB-totalA)/2;\\n        int ans[] = new int[2];\\n        for(int a:aliceSizes){\\n            if(set.contains(delta+a)){\\n                ans[0]=a;\\n                ans[1]=delta+a;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int totalA=0;\\n        int totalB=0;\\n        \\n        for(int a:aliceSizes){\\n            totalA = totalA + a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2423557,
                "title": "python-o-n-solution-using-set",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        sumAlice, sumBob, ans = sum(aliceSizes), sum(bobSizes), []\\n        diff = (sumBob - sumAlice) / 2\\n        setAliceSizes = set(aliceSizes)\\n        for bobItem in bobSizes:\\n            if bobItem - diff in setAliceSizes:\\n                ans.append(int(bobItem - diff))\\n                ans.append(bobItem)\\n                return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        sumAlice, sumBob, ans = sum(aliceSizes), sum(bobSizes), []\\n        diff = (sumBob - sumAlice) / 2\\n        setAliceSizes = set(aliceSizes)\\n        for bobItem in bobSizes:\\n            if bobItem - diff in setAliceSizes:\\n                ans.append(int(bobItem - diff))\\n                ans.append(bobItem)\\n                return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408387,
                "title": "java-solution-for-beginners-and-intermediate",
                "content": "Beginners ....sol works but very slow (brute force)\\n\\n```\\npublic int[] fairCandySwap(int[] arr1, int[] arr2) {\\n        \\n        int sum1 = IntStream.of(arr1).sum();\\n\\t\\tint sum2 = IntStream.of(arr2).sum();\\n        \\n        for(int i=0;i <arr1.length; i++) {\\n\\t\\t\\tfor(int j=0;j <arr2.length; j++) {\\n\\t\\t\\t\\tif((sum1-arr1[i]) + arr2[j] == (sum2-arr2[j])+arr1[i]) {\\n\\t\\t\\t\\t    return new int[] {arr1[i],arr2[j]};\\n\\t\\t     \\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new int[] {-1,-1};\\n    }\\n```\\n\\n\\nsol2 two pointer approach\\n\\nspeed is better\\n\\n```\\nArrays.sort(arr1);\\n        Arrays.sort(arr2);\\n       int sum1 = IntStream.of(arr1).sum();\\n\\t\\tint sum2 = IntStream.of(arr2).sum();\\n\\t\\t\\n\\t\\tint i=0,j=0;\\n\\t\\t\\n\\t\\twhile(i < arr1.length && j < arr2.length) {\\n\\t\\t\\t\\n\\t\\t\\tint sum1Replaced = (sum1-arr1[i]) + arr2[j];\\n\\t\\t\\tint sum2Replaced = (sum2-arr2[j]) + arr1[i];\\n\\n\\t\\t\\t\\n\\t\\t\\tif(sum1Replaced == sum2Replaced) {\\n\\t\\t\\t\\treturn new int[] {arr1[i],arr2[j]};\\n\\t\\t\\t}\\n\\t\\t\\tif(sum1Replaced > sum2Replaced) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn null;\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] fairCandySwap(int[] arr1, int[] arr2) {\\n        \\n        int sum1 = IntStream.of(arr1).sum();\\n\\t\\tint sum2 = IntStream.of(arr2).sum();\\n        \\n        for(int i=0;i <arr1.length; i++) {\\n\\t\\t\\tfor(int j=0;j <arr2.length; j++) {\\n\\t\\t\\t\\tif((sum1-arr1[i]) + arr2[j] == (sum2-arr2[j])+arr1[i]) {\\n\\t\\t\\t\\t    return new int[] {arr1[i],arr2[j]};\\n\\t\\t     \\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new int[] {-1,-1};\\n    }\\n```\n```\\nArrays.sort(arr1);\\n        Arrays.sort(arr2);\\n       int sum1 = IntStream.of(arr1).sum();\\n\\t\\tint sum2 = IntStream.of(arr2).sum();\\n\\t\\t\\n\\t\\tint i=0,j=0;\\n\\t\\t\\n\\t\\twhile(i < arr1.length && j < arr2.length) {\\n\\t\\t\\t\\n\\t\\t\\tint sum1Replaced = (sum1-arr1[i]) + arr2[j];\\n\\t\\t\\tint sum2Replaced = (sum2-arr2[j]) + arr1[i];\\n\\n\\t\\t\\t\\n\\t\\t\\tif(sum1Replaced == sum2Replaced) {\\n\\t\\t\\t\\treturn new int[] {arr1[i],arr2[j]};\\n\\t\\t\\t}\\n\\t\\t\\tif(sum1Replaced > sum2Replaced) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn null;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325365,
                "title": "c-2-apparoches-binary-search-set-easy-to-understand",
                "content": "Please Upvote if you like this apparoach\\n1 : Binary Search \\n```\\nclass Solution {\\nprivate:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int aSum = 0;\\n        int bSum = 0;\\n\\t\\t//Finding total size of Alice\\n        for(auto x: aliceSizes)\\n        {\\n            aSum += x;\\n        }\\n\\t\\t//Finding total size of Bob\\n        for(auto x: bobSizes)\\n        {\\n            bSum += x;\\n        }\\n        // we take elements one by one that if exchange this the total size got balance\\n        for(int i = 0;i<aliceSizes.size();i++)\\n        {\\n           int alice = aSum - aliceSizes[i];        //Remove the element for checking from total\\n           int bob = bSum + aliceSizes[i];       //Accept the element from alice\\n            \\n           int val = (bob - alice)/2;                //This size which now bob has to give to Alice\\n           int index = search(bobSizes,val);\\n           if(index != -1)                               //If the val is present in BobSizes than push both\\n           {                                                   //sizes in ans\\n               ans.push_back(aliceSizes[i]);\\n               ans.push_back(bobSizes[index]);\\n               return ans;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n2 : By set\\n\\n```\\n vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        int aSum = 0;\\n        int bSum = 0;\\n        for(auto x: aliceSizes)\\n        {\\n            aSum += x;\\n        }\\n        for(auto x: bobSizes)\\n        {\\n            bSum += x;\\n        }\\n        int delta = (bSum - aSum)/2;\\n        \\n        unordered_set<int> s(bobSizes.begin(),bobSizes.end());\\n        \\n        for(auto x : aliceSizes)\\n        {\\n              if(s.find(x + delta) != s.end())\\n              {\\n                  ans.push_back(x);\\n                  ans.push_back(x+delta);\\n                  break;\\n              }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int aSum = 0;\\n        int bSum = 0;\\n\\t\\t//Finding total size of Alice\\n        for(auto x: aliceSizes)\\n        {\\n            aSum += x;\\n        }\\n\\t\\t//Finding total size of Bob\\n        for(auto x: bobSizes)\\n        {\\n            bSum += x;\\n        }\\n        // we take elements one by one that if exchange this the total size got balance\\n        for(int i = 0;i<aliceSizes.size();i++)\\n        {\\n           int alice = aSum - aliceSizes[i];        //Remove the element for checking from total\\n           int bob = bSum + aliceSizes[i];       //Accept the element from alice\\n            \\n           int val = (bob - alice)/2;                //This size which now bob has to give to Alice\\n           int index = search(bobSizes,val);\\n           if(index != -1)                               //If the val is present in BobSizes than push both\\n           {                                                   //sizes in ans\\n               ans.push_back(aliceSizes[i]);\\n               ans.push_back(bobSizes[index]);\\n               return ans;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        int aSum = 0;\\n        int bSum = 0;\\n        for(auto x: aliceSizes)\\n        {\\n            aSum += x;\\n        }\\n        for(auto x: bobSizes)\\n        {\\n            bSum += x;\\n        }\\n        int delta = (bSum - aSum)/2;\\n        \\n        unordered_set<int> s(bobSizes.begin(),bobSizes.end());\\n        \\n        for(auto x : aliceSizes)\\n        {\\n              if(s.find(x + delta) != s.end())\\n              {\\n                  ans.push_back(x);\\n                  ans.push_back(x+delta);\\n                  break;\\n              }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2295325,
                "title": "fair-candy-swap",
                "content": "# ***python 3  Binary Search solution :***\\n```\\nclass Solution:\\n    def bs (self,arr,j):\\n        l=0\\n        r= len(arr)-1\\n        while l<=r:\\n            m = (l+r)//2\\n            if arr[m]==j:\\n                return True\\n            if  arr[m]<j:\\n                l=m+1\\n            else:\\n                r= m-1\\n        return False \\n    \\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        aliceSum= sum(aliceSizes)\\n        bobSum = sum(bobSizes)\\n        aliceSizes.sort()\\n        const = (aliceSum-bobSum)//2\\n        for i in bobSizes:\\n            diff = i+const\\n            x = self.bs(aliceSizes,diff)\\n            if x:\\n                return [diff,i]\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def bs (self,arr,j):\\n        l=0\\n        r= len(arr)-1\\n        while l<=r:\\n            m = (l+r)//2\\n            if arr[m]==j:\\n                return True\\n            if  arr[m]<j:\\n                l=m+1\\n            else:\\n                r= m-1\\n        return False \\n    \\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        aliceSum= sum(aliceSizes)\\n        bobSum = sum(bobSizes)\\n        aliceSizes.sort()\\n        const = (aliceSum-bobSum)//2\\n        for i in bobSizes:\\n            diff = i+const\\n            x = self.bs(aliceSizes,diff)\\n            if x:\\n                return [diff,i]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264776,
                "title": "fastest-java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int a=0,b=0;\\n        for(int i:aliceSizes)\\n            a+=i;\\n        HashSet<Integer> hset = new HashSet<>();\\n        for(int i:bobSizes)\\n        {\\n            b+=i;\\n            hset.add(i);\\n        }\\n        int del = (b-a)/2;\\n        for(int i:aliceSizes)\\n            if(hset.contains(i+del))\\n                return new int[]{i,i+del};\\n        return null;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int a=0,b=0;\\n        for(int i:aliceSizes)\\n            a+=i;\\n        HashSet<Integer> hset = new HashSet<>();\\n        for(int i:bobSizes)\\n        {\\n            b+=i;\\n            hset.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2254710,
                "title": "faster-than-86-java",
                "content": "```\\n\\n```import java.util.*;\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int k=0,l=0,m=0;\\n        for(int i=0;i<aliceSizes.length;i++)\\n             k+=aliceSizes[i];\\n        for(int i=0;i<bobSizes.length;i++)\\n            l+=bobSizes[i];\\n        int d= (l-k)/2;\\n        Arrays.sort(bobSizes);\\n        for(int i=0;i<aliceSizes.length;i++)\\n        {int y=bin(bobSizes,aliceSizes[i]+d);\\n            if(y!=-1)\\n                return new int[]{aliceSizes[i],bobSizes[y]};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n     int bin(int nums2[], int t){\\n       int s=0,e=nums2.length-1;\\n         while(s<=e)\\n         {\\n             int mid=s+(e-s)/2;\\n             if(nums2[mid]<t)\\n             {  s=mid+1;}\\n             else if (nums2[mid]>t) \\n             { e=mid-1;}\\n             else\\n             {return mid;}\\n         }\\n         return -1;\\n    }\\n\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2149984,
                "title": "c-simple-easy-to-understand-with-explanation",
                "content": "**Intuition:**\\nSuppose I have **m** candies and you have **n** candies. We should each have **(m + n) / 2** candies to have the same number of candies. So the net number of candies I should take from you is **(n - m) / 2** candies. If I give you **k** candies, I should take back **(n - m) / 2 + k** candies from you. In short, simply check if you have **(n - m) / 2 + k** candies for **k** candies I have in each box.\\n\\n**Code :**\\n```\\nclass Solution {\\n public:\\n  vector<int> FairCandySwap(const vector<int> &me, const vector<int> &you) {\\n    unordered_set<int> your_set(you.begin(), you.end());\\n    int give_me = (accumulate(you.begin(), you.end(), 0) -\\n                   accumulate(me.begin(), me.end(), 0)) / 2;\\n\\n    auto it = me.begin();\\n    while (!your_set.count(give_me + *it)) it++;\\n    return {*it, give_me + *it};\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> FairCandySwap(const vector<int> &me, const vector<int> &you) {\\n    unordered_set<int> your_set(you.begin(), you.end());\\n    int give_me = (accumulate(you.begin(), you.end(), 0) -\\n                   accumulate(me.begin(), me.end(), 0)) / 2;\\n\\n    auto it = me.begin();\\n    while (!your_set.count(give_me + *it)) it++;\\n    return {*it, give_me + *it};\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050865,
                "title": "simple-java-solution-without-hash-map",
                "content": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes){\\n      \\n\\n        int s1=0;\\n        int s2 =0;\\n        int p = aliceSizes.length;\\n        int q =  bobSizes.length;\\n        \\n        for (int i =0; i <p ; i++){\\n           s1 =  s1 + aliceSizes[i];     \\n        }\\n        \\n          for (int i =0; i <q ; i++){\\n           s2 =  s2 + bobSizes[i];     \\n    }\\n        int delta = (s1 -s2)/ 2;\\n        \\n   \\n        \\n        for (int i = 0;  i < p;i++){\\n            int x = aliceSizes[i];\\n            \\n            for (int j =0 ; j < q;j++){\\n                int y = bobSizes[j];\\n                if (y == x - delta){\\n                    return new int [] {x , y};\\n                }\\n            }\\n            \\n        }\\n        return  new int [] {-1,-1};\\n}\\n}****",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes){\\n      \\n\\n        int s1=0;\\n        int s2 =0;\\n        int p = aliceSizes.length;\\n        int q =  bobSizes.length;\\n        \\n        for (int i =0; i <p ; i++){\\n           s1 =  s1 + aliceSizes[i];     \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2016401,
                "title": "92-faster-java-simple-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        Set<Integer>set=new HashSet<>();\\n        int candy2=0,candy1=0;\\n        for(int c : bobSizes){\\n            set.add(c);\\n            candy2+=c;\\n        }\\n        for(int c : aliceSizes) candy1+=c;\\n        //transfer is no of more candies will alice finally get \\n        int transfer=(candy2-candy1)/2;\\n        for(int num  : aliceSizes){\\n            if(set.contains(num+trans)) return new int[]{num,num+trans};\\n        }\\n        return new int[]{};\\n    }\\n}\\n```\\n\\nTime : O(n) linear time\\nSpace : O(linear extra space)\\n\\nplease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        Set<Integer>set=new HashSet<>();\\n        int candy2=0,candy1=0;\\n        for(int c : bobSizes){\\n            set.add(c);\\n            candy2+=c;\\n        }\\n        for(int c : aliceSizes) candy1+=c;\\n        //transfer is no of more candies will alice finally get \\n        int transfer=(candy2-candy1)/2;\\n        for(int num  : aliceSizes){\\n            if(set.contains(num+trans)) return new int[]{num,num+trans};\\n        }\\n        return new int[]{};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989020,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int n=aliceSizes.length;\\n        int m=bobSizes.length;\\n        int []ans=new int [2];\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(int i:aliceSizes)\\n        {\\n            sum1=sum1+i;\\n        }\\n        for(int j:bobSizes)\\n        {\\n            sum2=sum2+j;\\n        }\\n        int target=(sum2-sum1)/2;\\n        \\n        \\n      ans=takeFairCandySwap(aliceSizes,bobSizes,target);\\n           return ans;\\n    }\\n    public int[] takeFairCandySwap(int []a,int []b,int target)\\n    {\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<b.length;j++)\\n            {\\n                if(b[j]==a[i]+target)            // we have to satisfy this condition for fair candy swap\\n                    return new int[]{a[i],b[j]};\\n            }\\n        }\\n        return new int[] {-1,-1};  \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int n=aliceSizes.length;\\n        int m=bobSizes.length;\\n        int []ans=new int [2];\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(int i:aliceSizes)\\n        {\\n            sum1=sum1+i;\\n        }\\n        for(int j:bobSizes)\\n        {\\n            sum2=sum2+j;\\n        }\\n        int target=(sum2-sum1)/2;\\n        \\n        \\n      ans=takeFairCandySwap(aliceSizes,bobSizes,target);\\n           return ans;\\n    }\\n    public int[] takeFairCandySwap(int []a,int []b,int target)\\n    {\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<b.length;j++)\\n            {\\n                if(b[j]==a[i]+target)            // we have to satisfy this condition for fair candy swap\\n                    return new int[]{a[i],b[j]};\\n            }\\n        }\\n        return new int[] {-1,-1};  \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959695,
                "title": "go-hashmap-binary-search-clear-solutions",
                "content": "HashMap:\\n```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n    alice, bob, aliceCandies := 0, 0, map[int]bool{}\\n    for _, candy := range aliceSizes { alice += candy; aliceCandies[candy] = true }\\n    for _, candy := range bobSizes { bob += candy }\\n    delta := (alice-bob)/2\\n    for _, b := range bobSizes { if aliceCandies[b+delta] { return []int{b+delta, b} } }\\n    return nil\\n}\\n```\\n\\nBinary Search:\\n```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n    alice, bob := 0, 0\\n    for _, candy := range aliceSizes { alice += candy }\\n    for _, candy := range bobSizes { bob += candy }\\n    delta := (alice-bob)/2\\n    sort.Ints(aliceSizes)\\n    for _, b := range bobSizes { if a := binarySearch(aliceSizes, b+delta); a != -1 { return []int{a, b} } }\\n    return nil\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    left, right := 0, len(arr)-1\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        if arr[mid] == target { return arr[mid] }\\n        if arr[mid] < target { left = mid+1 } else { right = mid-1 }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n    alice, bob, aliceCandies := 0, 0, map[int]bool{}\\n    for _, candy := range aliceSizes { alice += candy; aliceCandies[candy] = true }\\n    for _, candy := range bobSizes { bob += candy }\\n    delta := (alice-bob)/2\\n    for _, b := range bobSizes { if aliceCandies[b+delta] { return []int{b+delta, b} } }\\n    return nil\\n}\\n```\n```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n    alice, bob := 0, 0\\n    for _, candy := range aliceSizes { alice += candy }\\n    for _, candy := range bobSizes { bob += candy }\\n    delta := (alice-bob)/2\\n    sort.Ints(aliceSizes)\\n    for _, b := range bobSizes { if a := binarySearch(aliceSizes, b+delta); a != -1 { return []int{a, b} } }\\n    return nil\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    left, right := 0, len(arr)-1\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        if arr[mid] == target { return arr[mid] }\\n        if arr[mid] < target { left = mid+1 } else { right = mid-1 }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850451,
                "title": "java-sol-binary-search-approach",
                "content": "```\\nclass Solution {\\n    \\n    int sum(int[] arr){\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    \\n    boolean binarySearch(int[] arr,int target){\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low + (high-low)/2;\\n            if(arr[mid] == target){\\n                return true;\\n            }\\n            if(arr[mid] > target){\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int SumA = sum(aliceSizes);\\n        int SumB = sum(bobSizes);\\n        \\n        Arrays.sort(aliceSizes);\\n        Arrays.sort(bobSizes);\\n        \\n        int delta = ( SumB- SumA ) / 2;\\n        \\n        for(int i=0; i<aliceSizes.length; i++){\\n            if( binarySearch(bobSizes, aliceSizes[i] + delta) ){\\n                return new int[]{ aliceSizes[i], aliceSizes[i] + delta};\\n            }\\n        }\\n        throw null;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int sum(int[] arr){\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    \\n    boolean binarySearch(int[] arr,int target){\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low + (high-low)/2;\\n            if(arr[mid] == target){\\n                return true;\\n            }\\n            if(arr[mid] > target){\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int SumA = sum(aliceSizes);\\n        int SumB = sum(bobSizes);\\n        \\n        Arrays.sort(aliceSizes);\\n        Arrays.sort(bobSizes);\\n        \\n        int delta = ( SumB- SumA ) / 2;\\n        \\n        for(int i=0; i<aliceSizes.length; i++){\\n            if( binarySearch(bobSizes, aliceSizes[i] + delta) ){\\n                return new int[]{ aliceSizes[i], aliceSizes[i] + delta};\\n            }\\n        }\\n        throw null;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831641,
                "title": "python-2-solutions-o-n-and-o-nlog-n",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        totA = sum(aliceSizes)\\n        totB = 0\\n        setB = set()\\n        for n in bobSizes:\\n            totB += n\\n            setB.add(n)\\n        for boxA in aliceSizes:\\n\\t\\t    # new_totB = new_totA -->\\n\\t\\t    # totB - boxB + boxA = totA - boxA + boxB\\n            boxB = (totB + 2 * boxA - totA) // 2\\n            if boxB in setB:   # O(1)\\n                return [boxA, boxB]\\n```\\nTIME COMPLEXITY: O(n)\\n\\n```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        aliceSizes.sort()\\n        bobSizes.sort()\\n        totA , totB = sum(aliceSizes), sum(bobSizes)\\n        i, j = 0, 0\\n        while True:\\n            new_totA = totA - aliceSizes[i] + bobSizes[j]\\n            new_totB = totB - bobSizes[j] + aliceSizes[i]\\n            if new_totA == new_totB:\\n                return [aliceSizes[i], bobSizes[j]]\\n            elif new_totA > new_totB:\\n                i += 1\\n            else:\\n                j += 1\\n```\\nTIME COMPLEXITY: O(nlog(n))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        totA = sum(aliceSizes)\\n        totB = 0\\n        setB = set()\\n        for n in bobSizes:\\n            totB += n\\n            setB.add(n)\\n        for boxA in aliceSizes:\\n\\t\\t    # new_totB = new_totA -->\\n\\t\\t    # totB - boxB + boxA = totA - boxA + boxB\\n            boxB = (totB + 2 * boxA - totA) // 2\\n            if boxB in setB:   # O(1)\\n                return [boxA, boxB]\\n```\n```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        aliceSizes.sort()\\n        bobSizes.sort()\\n        totA , totB = sum(aliceSizes), sum(bobSizes)\\n        i, j = 0, 0\\n        while True:\\n            new_totA = totA - aliceSizes[i] + bobSizes[j]\\n            new_totB = totB - bobSizes[j] + aliceSizes[i]\\n            if new_totA == new_totB:\\n                return [aliceSizes[i], bobSizes[j]]\\n            elif new_totA > new_totB:\\n                i += 1\\n            else:\\n                j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769729,
                "title": "c-clear-solution-with-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        int sum1 = 0,sum2 = 0;\\n        int x = 0,y = 0;\\n        for(int i=0;i<aliceSizes.size();i++) sum1 += aliceSizes[i];\\n        for(int i=0;i<bobSizes.size();i++) sum2 += bobSizes[i];\\n        vector<int> ans;\\n        int tsum1 = sum1,tsum2 = sum2;\\n        while(x<aliceSizes.size() && y<bobSizes.size()){\\n            sum1 -= aliceSizes[x];\\n            sum1 += bobSizes[y];\\n            sum2 -= bobSizes[y];\\n            sum2 += aliceSizes[x];\\n            if(sum1==sum2){\\n                ans.push_back(aliceSizes[x]);\\n                ans.push_back(bobSizes[y]);\\n                break;\\n            }\\n            else if(sum1>sum2) x++;\\n            else y++;\\n            sum1 = tsum1;\\n            sum2 = tsum2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n   **Let me know if you want me to explain**",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        int sum1 = 0,sum2 = 0;\\n        int x = 0,y = 0;\\n        for(int i=0;i<aliceSizes.size();i++) sum1 += aliceSizes[i];\\n        for(int i=0;i<bobSizes.size();i++) sum2 += bobSizes[i];\\n        vector<int> ans;\\n        int tsum1 = sum1,tsum2 = sum2;\\n        while(x<aliceSizes.size() && y<bobSizes.size()){\\n            sum1 -= aliceSizes[x];\\n            sum1 += bobSizes[y];\\n            sum2 -= bobSizes[y];\\n            sum2 += aliceSizes[x];\\n            if(sum1==sum2){\\n                ans.push_back(aliceSizes[x]);\\n                ans.push_back(bobSizes[y]);\\n                break;\\n            }\\n            else if(sum1>sum2) x++;\\n            else y++;\\n            sum1 = tsum1;\\n            sum2 = tsum2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718367,
                "title": "java-solution",
                "content": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n      int sumA = 0;\\n        int sumB=0;\\n        for(int i=0 ;i<aliceSizes.length;i++){\\n        sumA += aliceSizes[i];\\n        }\\n        int[] ans = new int[2];\\n        Set<Integer> bob = new HashSet();\\n        \\n         for(int j=0 ;j<bobSizes.length;j++){\\n        sumB += bobSizes[j];\\n        bob.add(bobSizes[j]);\\n        }\\n        \\n        int delta = (sumB-sumA)/2;\\n        \\n        for(int x=0 ;x<aliceSizes.length;x++){\\n       if(bob.contains(aliceSizes[x]+delta)){\\n           ans[0]=aliceSizes[x];\\n           ans[1]=aliceSizes[x]+delta;\\n           return ans;\\n       }\\n        \\n        }\\n         \\n        \\n   return ans;     \\n      \\n      }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n      int sumA = 0;\\n        int sumB=0;\\n        for(int i=0 ;i<aliceSizes.length;i++){\\n        sumA += aliceSizes[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1690091,
                "title": "kotlin-solution-faster-than-60",
                "content": "```\\nclass Solution {\\n    fun fairCandySwap(aliceSizes: IntArray, bobSizes: IntArray): IntArray {\\n        val aliceSum = aliceSizes.sum()\\n        val bobSum = bobSizes.sum()\\n        val target = (aliceSum - bobSum) / 2\\n        val aliceHash = aliceSizes.toHashSet()\\n        val bobHash = bobSizes.toHashSet()\\n        var x: Int = 0\\n        var y: Int = 0\\n        for (a in aliceHash) {\\n\\t\\t// always calculating how many bob will get from alice\\n\\t\\t// can be (+) or can be (-)\\n            if (bobHash.contains(a - target)){\\n                x=a;\\n                y=a-target\\n            }\\n        }\\n        return intArrayOf(x,y)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun fairCandySwap(aliceSizes: IntArray, bobSizes: IntArray): IntArray {\\n        val aliceSum = aliceSizes.sum()\\n        val bobSum = bobSizes.sum()\\n        val target = (aliceSum - bobSum) / 2\\n        val aliceHash = aliceSizes.toHashSet()\\n        val bobHash = bobSizes.toHashSet()\\n        var x: Int = 0\\n        var y: Int = 0\\n        for (a in aliceHash) {\\n\\t\\t// always calculating how many bob will get from alice\\n\\t\\t// can be (+) or can be (-)\\n            if (bobHash.contains(a - target)){\\n                x=a;\\n                y=a-target\\n            }\\n        }\\n        return intArrayOf(x,y)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672645,
                "title": "java-not-optimal",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum1=0,sum2=0,n1=aliceSizes.length,n2=bobSizes.length;\\n        for(int i=0;i<n1;i++) //Number of candies Alice has\\n        {\\n            sum1+=aliceSizes[i];\\n        }\\n        for(int i=0;i<n2;i++) //Number of candies Bob has\\n        {\\n            sum2+=bobSizes[i];\\n        }\\n        int common=(sum1+sum2)/2; //Candies both should have\\n        sum1=common-sum1; //Candies Alice need\\n        int ans[]=new int[2];\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<n2;i++) //Put Bob\\'s candies in a set\\n        {\\n            set.add(bobSizes[i]);\\n        }\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(set.contains(aliceSizes[i]+sum1)) //aliceneed + aliceCandy == candy Bob has then \\n            {\\n                ans[0]=aliceSizes[i];\\n                ans[1]=aliceSizes[i]+sum1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum1=0,sum2=0,n1=aliceSizes.length,n2=bobSizes.length;\\n        for(int i=0;i<n1;i++) //Number of candies Alice has\\n        {\\n            sum1+=aliceSizes[i];\\n        }\\n        for(int i=0;i<n2;i++) //Number of candies Bob has\\n        {\\n            sum2+=bobSizes[i];\\n        }\\n        int common=(sum1+sum2)/2; //Candies both should have\\n        sum1=common-sum1; //Candies Alice need\\n        int ans[]=new int[2];\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<n2;i++) //Put Bob\\'s candies in a set\\n        {\\n            set.add(bobSizes[i]);\\n        }\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(set.contains(aliceSizes[i]+sum1)) //aliceneed + aliceCandy == candy Bob has then \\n            {\\n                ans[0]=aliceSizes[i];\\n                ans[1]=aliceSizes[i]+sum1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662643,
                "title": "python-simple-readable-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef fairCandySwap(self, aliceSizes, bobSizes):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type aliceSizes: List[int]\\n\\t\\t\\t:type bobSizes: List[int]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tsumA = sum(aliceSizes)\\n\\t\\t\\tsumB = sum(bobSizes)\\n\\n\\t\\t\\tsetB = set(bobSizes)\\n\\n\\t\\t\\tfor ele in aliceSizes:\\n\\t\\t\\t\\tdiff = ele+((sumB-sumA)/2)\\n\\t\\t\\t\\tif diff in setB:\\n\\t\\t\\t\\t\\treturn [ele,diff]\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef fairCandySwap(self, aliceSizes, bobSizes):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type aliceSizes: List[int]\\n\\t\\t\\t:type bobSizes: List[int]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tsumA = sum(aliceSizes)\\n\\t\\t\\tsumB = sum(bobSizes)\\n\\n\\t\\t\\tsetB = set(bobSizes)\\n\\n\\t\\t\\tfor ele in aliceSizes:\\n\\t\\t\\t\\tdiff = ele+((sumB-sumA)/2)\\n\\t\\t\\t\\tif diff in setB:\\n\\t\\t\\t\\t\\treturn [ele,diff]\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1641742,
                "title": "c-easy-approach",
                "content": "**Please do upvote if it helps you!**\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n         int sumA = 0;\\n    int sumB = 0;\\n    \\n    for (auto e : A)\\n        sumA += e;\\n    \\n    for (auto e : B)\\n        sumB += e;\\n    \\n    int delta = (sumA - sumB) / 2;\\n    \\n    set<int> searchA;\\n    for (auto x : A)\\n    {\\n        //cout << x << endl;\\n        searchA.insert(x);\\n    }\\n    \\n    \\n    //cout << endl;\\n    for (auto y : B)    \\n    {\\n        //cout << y << setw(5) << delta + y << endl;\\n        if (searchA.count(delta + y) > 0)\\n        {\\n            return vector<int>{delta + y, y};\\n        }\\n    }\\n    \\n    return vector<int>();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n         int sumA = 0;\\n    int sumB = 0;\\n    \\n    for (auto e : A)\\n        sumA += e;\\n    \\n    for (auto e : B)\\n        sumB += e;\\n    \\n    int delta = (sumA - sumB) / 2;\\n    \\n    set<int> searchA;\\n    for (auto x : A)\\n    {\\n        //cout << x << endl;\\n        searchA.insert(x);\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1614801,
                "title": "easiest-c-soln-using-binary-search",
                "content": "**Time Complexity: O(NlogN)**\\n(neglecting the differences in both array length)\\n\\n```\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int sum1=0,sum2=0;\\n        vector<int>ans;\\n        \\n        for(int i:aliceSizes)\\n            sum1+=i;\\n        for(int i:bobSizes)\\n            sum2+=i;\\n        \\n        int diff=(sum2-sum1)/2;\\n        \\n        for(int i:aliceSizes)\\n        {\\n            int lc=0,uc=bobSizes.size()-1,mid=0;\\n            while(lc<=uc)\\n            {\\n                mid=lc+(uc-lc)/2;\\n                if(i+diff==bobSizes[mid])\\n                {\\n                    ans.push_back(i);\\n                    ans.push_back(i+diff);\\n                    return ans;\\n                }\\n                else if(i+diff<bobSizes[mid])\\n                    uc=mid-1;\\n                else\\n                    lc=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nIf you liked my solution please hit an upvote.\\nIf you have any query regarding the solution, drop a comment below and lets discuss!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int sum1=0,sum2=0;\\n        vector<int>ans;\\n        \\n        for(int i:aliceSizes)\\n            sum1+=i;\\n        for(int i:bobSizes)\\n            sum2+=i;\\n        \\n        int diff=(sum2-sum1)/2;\\n        \\n        for(int i:aliceSizes)\\n        {\\n            int lc=0,uc=bobSizes.size()-1,mid=0;\\n            while(lc<=uc)\\n            {\\n                mid=lc+(uc-lc)/2;\\n                if(i+diff==bobSizes[mid])\\n                {\\n                    ans.push_back(i);\\n                    ans.push_back(i+diff);\\n                    return ans;\\n                }\\n                else if(i+diff<bobSizes[mid])\\n                    uc=mid-1;\\n                else\\n                    lc=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570739,
                "title": "python-3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        diff = (sum(aliceSizes) - sum(bobSizes)) // 2\\n        s = set(aliceSizes)\\n        for bag in bobSizes:\\n            if bag + diff in s:\\n                return [bag + diff, bag]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        diff = (sum(aliceSizes) - sum(bobSizes)) // 2\\n        s = set(aliceSizes)\\n        for bag in bobSizes:\\n            if bag + diff in s:\\n                return [bag + diff, bag]",
                "codeTag": "Java"
            },
            {
                "id": 1562473,
                "title": "java-easy-binary-search",
                "content": "* Sort bobSizes array to perform binary  search on it.\\n* with the help of for loop find total number of candies for both alice and bob.\\n* Iterate aliceSizes array and perform binary search on bobSizes array.\\n\\nEquation:\\naliceSizes - x + y = bobSizes + x - y\\ny = x + (bobSizes - aliceSizes)/2\\n\\nx number of candies from aliceSizes and y number of candies from bobSizes\\n\\nCode:\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int alice = 0,bob = 0;\\n        int[] ans = new int[2];\\n        Arrays.sort(bobSizes);\\n        for(int i=0;i<aliceSizes.length;i++){\\n            alice = alice + aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.length;i++){\\n            bob = bob + bobSizes[i];\\n        }\\n        for(int i=0;i<aliceSizes.length;i++){\\n            int l=0,r=bobSizes.length-1;\\n            int x = aliceSizes[i] + (bob-alice)/2;\\n            while(l<=r){\\n                int mid = l+(r-l)/2;\\n                if(bobSizes[mid] == x){\\n                    ans[1] = bobSizes[mid];\\n                    ans[0] = aliceSizes[i];\\n                    return ans;\\n                }else if(bobSizes[mid] < x){\\n                    l = mid + 1;\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int alice = 0,bob = 0;\\n        int[] ans = new int[2];\\n        Arrays.sort(bobSizes);\\n        for(int i=0;i<aliceSizes.length;i++){\\n            alice = alice + aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.length;i++){\\n            bob = bob + bobSizes[i];\\n        }\\n        for(int i=0;i<aliceSizes.length;i++){\\n            int l=0,r=bobSizes.length-1;\\n            int x = aliceSizes[i] + (bob-alice)/2;\\n            while(l<=r){\\n                int mid = l+(r-l)/2;\\n                if(bobSizes[mid] == x){\\n                    ans[1] = bobSizes[mid];\\n                    ans[0] = aliceSizes[i];\\n                    return ans;\\n                }else if(bobSizes[mid] < x){\\n                    l = mid + 1;\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561230,
                "title": "c-basic-math-approach-set",
                "content": "```\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        set<int>s;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            sum1+=aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            sum2+=bobSizes[i];\\n        }\\n        int diff=(sum2-sum1)/2;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            s.insert(bobSizes[i]);\\n        }\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            if(s.find(aliceSizes[i]+diff)!=s.end())\\n            {\\n                \\n                return {aliceSizes[i],aliceSizes[i]+diff};\\n            }\\n        }\\n        return {};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        set<int>s;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            sum1+=aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            sum2+=bobSizes[i];\\n        }\\n        int diff=(sum2-sum1)/2;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            s.insert(bobSizes[i]);\\n        }\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            if(s.find(aliceSizes[i]+diff)!=s.end())\\n            {\\n                \\n                return {aliceSizes[i],aliceSizes[i]+diff};\\n            }\\n        }\\n        return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1551239,
                "title": "javascript-simple-solution",
                "content": "\\t\\tvar fairCandySwap = function(aliceSizes, bobSizes) {\\n\\t\\t\\tconst aliceSum = aliceSizes.reduce((a,b)=> a + b)\\n\\t\\t\\tconst bobSum = bobSizes.reduce((a,b)=> a + b)\\n\\n\\t\\t\\tconst average = (aliceSum + bobSum)/2\\n\\n\\t\\t\\tfor(let i = 0; i < aliceSizes.length; i++){\\n\\t\\t\\t\\tlet found = average - (aliceSum - aliceSizes[i])\\n\\t\\t\\t\\tif(bobSizes.includes(found)){\\n\\t\\t\\t\\t\\treturn [aliceSizes[i], found]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "\\t\\tvar fairCandySwap = function(aliceSizes, bobSizes) {\\n\\t\\t\\tconst aliceSum = aliceSizes.reduce((a,b)=> a + b)\\n\\t\\t\\tconst bobSum = bobSizes.reduce((a,b)=> a + b)\\n\\n\\t\\t\\tconst average = (aliceSum + bobSum)/2\\n\\n\\t\\t\\tfor(let i = 0; i < aliceSizes.length; i++){\\n\\t\\t\\t\\tlet found = average - (aliceSum - aliceSizes[i])\\n\\t\\t\\t\\tif(bobSizes.includes(found)){\\n\\t\\t\\t\\t\\treturn [aliceSizes[i], found]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1536460,
                "title": "c-simplest-solution",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n        vector<int> result;\\n        set<int> s;\\n        int n = alice.size(), m = bob.size();\\n        \\n        int alicesum = 0 , bobsum = 0;\\n        \\n        for(int i=0 ; i<n ; ++i) alicesum += alice[i];\\n        \\n        for(int j=0 ; j<m ; ++j)\\n        {\\n            bobsum += bob[j];\\n            s.insert(bob[j]);\\n        }\\n        \\n        // y = x + (bobsum-alicesum)/2;\\n        int temp = (bobsum - alicesum)/2;\\n        for(int i=0 ; i<n ; ++i)\\n        {\\n            // y = alice[i] + temp;\\n            \\n            auto it = s.find(alice[i]+temp);\\n            if(it != s.end())\\n            {\\n                result.push_back(alice[i]);\\n                result.push_back(alice[i] + temp);\\n                return result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n        vector<int> result;\\n        set<int> s;\\n        int n = alice.size(), m = bob.size();\\n        \\n        int alicesum = 0 , bobsum = 0;\\n        \\n        for(int i=0 ; i<n ; ++i) alicesum += alice[i];\\n        \\n        for(int j=0 ; j<m ; ++j)\\n        {\\n            bobsum += bob[j];\\n            s.insert(bob[j]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1530132,
                "title": "simplest-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>& bobSizes,int target)\\n    {\\n        int i=0,l=bobSizes.size()-1;\\n        while(i<=l)\\n        {\\n            int mid =i+(l-i)/2;\\n            if(bobSizes[mid]==target)\\n            {\\n                return mid;\\n            }\\n            else if(bobSizes[mid]>target)\\n            {\\n                l=mid-1;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int alicesum=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            alicesum=alicesum+aliceSizes[i];\\n        }\\n        \\n        int bobsum=0;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            bobsum=bobsum+bobSizes[i];\\n        }\\n        \\n        vector<int> answer;\\n        \\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int target=(bobsum-alicesum+2*aliceSizes[i])/2;\\n            int temp=binarysearch(bobSizes,target);\\n            if(temp!=-1)\\n            {\\n                answer.push_back(aliceSizes[i]);\\n                answer.push_back(target);\\n                return answer;\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>& bobSizes,int target)\\n    {\\n        int i=0,l=bobSizes.size()-1;\\n        while(i<=l)\\n        {\\n            int mid =i+(l-i)/2;\\n            if(bobSizes[mid]==target)\\n            {\\n                return mid;\\n            }\\n            else if(bobSizes[mid]>target)\\n            {\\n                l=mid-1;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int alicesum=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            alicesum=alicesum+aliceSizes[i];\\n        }\\n        \\n        int bobsum=0;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            bobsum=bobsum+bobSizes[i];\\n        }\\n        \\n        vector<int> answer;\\n        \\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int target=(bobsum-alicesum+2*aliceSizes[i])/2;\\n            int temp=binarysearch(bobSizes,target);\\n            if(temp!=-1)\\n            {\\n                answer.push_back(aliceSizes[i]);\\n                answer.push_back(target);\\n                return answer;\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496060,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) \\n    {\\n        Arrays.sort(aliceSizes);\\n        Arrays.sort(bobSizes);\\n        long sum1=0 , sum2=0;\\n         for(int i=0;i<aliceSizes.length ; i++)      \\n            sum1 = sum1 + aliceSizes[i];\\n        for(int i=0;i<bobSizes.length ; i++)      \\n            sum2 = sum2 + bobSizes[i];\\n        int i=0 ; \\n        int j=0;\\n        if(sum1>sum2)\\n        {\\n            long dif = (sum1 - sum2)/2;\\n            while(i<aliceSizes.length && j<bobSizes.length)\\n            {\\n                if(aliceSizes[i] == bobSizes[j]+dif)    \\n                    return new int[]{aliceSizes[i] , bobSizes[j]};\\n                else if(aliceSizes[i]<bobSizes[j]+dif)\\n                    i++;\\n                else\\n                    j++;\\n            }\\n        }\\n        else\\n            {\\n            long dif = (sum2 - sum1)/2;\\n            while(i<aliceSizes.length && j<bobSizes.length)\\n            {\\n                if(aliceSizes[i] + dif  == bobSizes[j])    \\n                    return new int[]{aliceSizes[i] , bobSizes[j]};\\n                else if(aliceSizes[i]+ dif >bobSizes[j])\\n                    j++;\\n                else\\n                    i++;\\n            }\\n        }\\n       return new int[]{-1,-1};\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) \\n    {\\n        Arrays.sort(aliceSizes);\\n        Arrays.sort(bobSizes);\\n        long sum1=0 , sum2=0;\\n         for(int i=0;i<aliceSizes.length ; i++)      \\n            sum1 = sum1 + aliceSizes[i];\\n        for(int i=0;i<bobSizes.length ; i++)      \\n            sum2 = sum2 + bobSizes[i];\\n        int i=0 ; \\n        int j=0;\\n        if(sum1>sum2)\\n        {\\n            long dif = (sum1 - sum2)/2;\\n            while(i<aliceSizes.length && j<bobSizes.length)\\n            {\\n                if(aliceSizes[i] == bobSizes[j]+dif)    \\n                    return new int[]{aliceSizes[i] , bobSizes[j]};\\n                else if(aliceSizes[i]<bobSizes[j]+dif)\\n                    i++;\\n                else\\n                    j++;\\n            }\\n        }\\n        else\\n            {\\n            long dif = (sum2 - sum1)/2;\\n            while(i<aliceSizes.length && j<bobSizes.length)\\n            {\\n                if(aliceSizes[i] + dif  == bobSizes[j])    \\n                    return new int[]{aliceSizes[i] , bobSizes[j]};\\n                else if(aliceSizes[i]+ dif >bobSizes[j])\\n                    j++;\\n                else\\n                    i++;\\n            }\\n        }\\n       return new int[]{-1,-1};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460273,
                "title": "javascript-solution-with-comments",
                "content": "```\\nvar fairCandySwap = function(aliceSizes, bobSizes) {\\n    let sumA = 0;\\n    let sumB = 0;\\n    let setB = new Set();\\n    let diff = 0;\\n    let res = [];\\n    \\n    for (let i = 0; i < aliceSizes.length; i++) {\\n        sumA += aliceSizes[i];\\n    }\\n    \\n    for (let j = 0; j < bobSizes.length; j++) {\\n        sumB += bobSizes[j];\\n        setB.add(bobSizes[j]);\\n    }\\n    \\n    diff = (sumB - sumA) / 2;\\n    \\n    for (let i = 0; i < aliceSizes.length; i++) {\\n        //for each candy of alice we are checking if the value is same as diff + alice is present in the Bobs candy\\n        //Reason being: after solving the equation\\n        // y = x + (sumB - sumA) / 2 ==> y = x + diff\\n        if (setB.has(diff+aliceSizes[i])) {\\n            res[0] = aliceSizes[i];\\n            res[1] = diff+aliceSizes[i];\\n            break;\\n        };\\n    }\\n    return res; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fairCandySwap = function(aliceSizes, bobSizes) {\\n    let sumA = 0;\\n    let sumB = 0;\\n    let setB = new Set();\\n    let diff = 0;\\n    let res = [];\\n    \\n    for (let i = 0; i < aliceSizes.length; i++) {\\n        sumA += aliceSizes[i];\\n    }\\n    \\n    for (let j = 0; j < bobSizes.length; j++) {\\n        sumB += bobSizes[j];\\n        setB.add(bobSizes[j]);\\n    }\\n    \\n    diff = (sumB - sumA) / 2;\\n    \\n    for (let i = 0; i < aliceSizes.length; i++) {\\n        //for each candy of alice we are checking if the value is same as diff + alice is present in the Bobs candy\\n        //Reason being: after solving the equation\\n        // y = x + (sumB - sumA) / 2 ==> y = x + diff\\n        if (setB.has(diff+aliceSizes[i])) {\\n            res[0] = aliceSizes[i];\\n            res[1] = diff+aliceSizes[i];\\n            break;\\n        };\\n    }\\n    return res; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447435,
                "title": "py-candy-swap",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        each = (sum(aliceSizes) + sum(bobSizes))//2\\n        diff = each - sum(aliceSizes)\\n        for a in set(aliceSizes):\\n            if a + diff in set(bobSizes):\\n                return [a, a+diff]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        each = (sum(aliceSizes) + sum(bobSizes))//2\\n        diff = each - sum(aliceSizes)\\n        for a in set(aliceSizes):\\n            if a + diff in set(bobSizes):\\n                return [a, a+diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419942,
                "title": "two-approaches-using-set-and-binary-search",
                "content": "**Method 1 :**\\n\\n**Using set and it will take extra memory**\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n     int n=alice.size();\\n        int m=bob.size();\\n        int sa=0,sb=0;\\n        for(auto it:alice) sa+=it;\\n         set<int>b;\\n        vector<int>output;\\n        for(auto it:bob) \\n        {\\n            sb+=it;\\n            b.insert(it);\\n        }\\n        int x,y;\\n        y=(sb-sa)/2 ;\\n        for(auto it:alice){\\n            if(b.find(y+it)!=b.end()){\\n                output.push_back(it);\\n                 output.push_back(y+it);\\n                return output;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\n**Method 2 :**\\n\\n**Using binary search and using O(1) space**\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n     int n=alice.size();\\n        int m=bob.size();\\n        int sa=0,sb=0;\\n        for(auto it:alice) sa+=it;\\n        vector<int>output;\\n        for(auto it:bob) \\n        {\\n            sb+=it;\\n        }\\n        sort(bob.begin(),bob.end());\\n        int x,y;\\n        y=(sb-sa)/2 ;\\n        for(auto it:alice){\\n            if(binary_search(bob.begin(),bob.end(),it+y)==true){\\n                output.push_back(it);\\n                 output.push_back(y+it);\\n                return output;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n     int n=alice.size();\\n        int m=bob.size();\\n        int sa=0,sb=0;\\n        for(auto it:alice) sa+=it;\\n         set<int>b;\\n        vector<int>output;\\n        for(auto it:bob) \\n        {\\n            sb+=it;\\n            b.insert(it);\\n        }\\n        int x,y;\\n        y=(sb-sa)/2 ;\\n        for(auto it:alice){\\n            if(b.find(y+it)!=b.end()){\\n                output.push_back(it);\\n                 output.push_back(y+it);\\n                return output;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n     int n=alice.size();\\n        int m=bob.size();\\n        int sa=0,sb=0;\\n        for(auto it:alice) sa+=it;\\n        vector<int>output;\\n        for(auto it:bob) \\n        {\\n            sb+=it;\\n        }\\n        sort(bob.begin(),bob.end());\\n        int x,y;\\n        y=(sb-sa)/2 ;\\n        for(auto it:alice){\\n            if(binary_search(bob.begin(),bob.end(),it+y)==true){\\n                output.push_back(it);\\n                 output.push_back(y+it);\\n                return output;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391545,
                "title": "golang-map-solution-100",
                "content": "```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n\\taliceSum := 0\\n\\taliceBoxes := make(map[int]struct{}, len(aliceSizes))\\n\\tfor _, n := range aliceSizes {\\n\\t\\taliceSum += n\\n\\t\\taliceBoxes[n] = struct{}{}\\n\\t}\\n\\tbobSum := 0\\n\\tfor _, n := range bobSizes {\\n\\t\\tbobSum += n\\n\\t}\\n\\n\\ttarget := (aliceSum + bobSum) / 2\\n\\n\\tfor _, bobBox := range bobSizes {\\n\\t\\tif _, ok := aliceBoxes[aliceSum + bobBox- target]; ok {\\n\\t\\t\\treturn []int{aliceSum + bobBox - target, bobBox}\\n\\t\\t}\\n\\t}\\n\\tpanic(\"unreachable\")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n\\taliceSum := 0\\n\\taliceBoxes := make(map[int]struct{}, len(aliceSizes))\\n\\tfor _, n := range aliceSizes {\\n\\t\\taliceSum += n\\n\\t\\taliceBoxes[n] = struct{}{}\\n\\t}\\n\\tbobSum := 0\\n\\tfor _, n := range bobSizes {\\n\\t\\tbobSum += n\\n\\t}\\n\\n\\ttarget := (aliceSum + bobSum) / 2\\n\\n\\tfor _, bobBox := range bobSizes {\\n\\t\\tif _, ok := aliceBoxes[aliceSum + bobBox- target]; ok {\\n\\t\\t\\treturn []int{aliceSum + bobBox - target, bobBox}\\n\\t\\t}\\n\\t}\\n\\tpanic(\"unreachable\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1386588,
                "title": "rust-using-hashset-and-a-bit-of-an-explanation",
                "content": "The reasoning behind it: the total amount of candies that Alice has is `sum_a`. Similarly, the total amount of candies that Bob has is `sum_b`. For the candy swap to be fair, Alice gives a box `x` of candies to Bob and in exchange receives a box `y` of candies from Bob, such that `sum_a - x + y = sum_b - y + x`. If we move things around, then we get `((sum_a - sum_b) / 2) + y = x`. So, effectively, we need to check if there is a pair (`x`, `y`) that solves the equation. In other words, we iterate over Bob\\'s boxes of candies, `y`, and check if the `((sum_a - sum_b) / 2) + y` exists in Alice\\'s boxes of candies.\\n\\n```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn fair_candy_swap(alice_sizes: Vec<i32>, bob_sizes: Vec<i32>) -> Vec<i32> {\\n        let sum_a = alice_sizes.iter().sum::<i32>();\\n        let sum_b = bob_sizes.iter().sum::<i32>();\\n        let set_a = alice_sizes.iter().fold(HashSet::new(), |mut acc, x| {\\n            acc.insert(x);\\n            acc\\n        });\\n\\t\\t\\n        for y in bob_sizes.iter() {\\n            let x = (sum_a - sum_b) / 2 + y;\\n            if set_a.contains(&x) {\\n                return vec![x, *y];\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn fair_candy_swap(alice_sizes: Vec<i32>, bob_sizes: Vec<i32>) -> Vec<i32> {\\n        let sum_a = alice_sizes.iter().sum::<i32>();\\n        let sum_b = bob_sizes.iter().sum::<i32>();\\n        let set_a = alice_sizes.iter().fold(HashSet::new(), |mut acc, x| {\\n            acc.insert(x);\\n            acc\\n        });\\n\\t\\t\\n        for y in bob_sizes.iter() {\\n            let x = (sum_a - sum_b) / 2 + y;\\n            if set_a.contains(&x) {\\n                return vec![x, *y];\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341063,
                "title": "c-using-binary-search-o-n-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& m, vector<int>& n) {\\n        vector<int> v;\\n        int x, y;\\n        int s1 = 0, s2 = 0;\\n        for(int i = 0; i < m.size(); i++){\\n            s1 += m[i];\\n        }\\n        for(int i = 0; i < n.size(); i++){\\n            s2 += n[i];\\n        }\\n        sort(n.begin(), n.end());\\n        for(int i = 0; i < m.size(); i++){\\n            x = m[i];\\n            y = (s2 - s1)/2 + x;\\n            int lo = 0, hi = n.size() - 1;\\n            while(hi - lo > 1){\\n                int mid = (hi + lo) / 2;\\n                if(n[mid] > y)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid;\\n            }\\n            if(n[lo] == y){\\n                y = n[lo];\\n                v.push_back(x);\\n                v.push_back(y);\\n                break;\\n            }\\n            else if(n[hi] == y){\\n                y = n[hi];\\n                v.push_back(x);\\n                v.push_back(y);\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& m, vector<int>& n) {\\n        vector<int> v;\\n        int x, y;\\n        int s1 = 0, s2 = 0;\\n        for(int i = 0; i < m.size(); i++){\\n            s1 += m[i];\\n        }\\n        for(int i = 0; i < n.size(); i++){\\n            s2 += n[i];\\n        }\\n        sort(n.begin(), n.end());\\n        for(int i = 0; i < m.size(); i++){\\n            x = m[i];\\n            y = (s2 - s1)/2 + x;\\n            int lo = 0, hi = n.size() - 1;\\n            while(hi - lo > 1){\\n                int mid = (hi + lo) / 2;\\n                if(n[mid] > y)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid;\\n            }\\n            if(n[lo] == y){\\n                y = n[lo];\\n                v.push_back(x);\\n                v.push_back(y);\\n                break;\\n            }\\n            else if(n[hi] == y){\\n                y = n[hi];\\n                v.push_back(x);\\n                v.push_back(y);\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307263,
                "title": "python-hashmap-368ms",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        hmap={}\\n        ans=[]\\n        for i in range(len(bobSizes)):\\n            hmap[bobSizes[i]]=i\\n        s1=sum(aliceSizes)\\n        s2=sum(bobSizes)\\n        avg=(s1+s2)/2\\n        for i in range(len(aliceSizes)):\\n            key=avg-(s1-aliceSizes[i])\\n            if key in hmap:\\n                ans=[aliceSizes[i],bobSizes[hmap[key]]]\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        hmap={}\\n        ans=[]\\n        for i in range(len(bobSizes)):\\n            hmap[bobSizes[i]]=i\\n        s1=sum(aliceSizes)\\n        s2=sum(bobSizes)\\n        avg=(s1+s2)/2\\n        for i in range(len(aliceSizes)):\\n            key=avg-(s1-aliceSizes[i])\\n            if key in hmap:\\n                ans=[aliceSizes[i],bobSizes[hmap[key]]]\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294350,
                "title": "c-hash-map-using-an-equation",
                "content": "```\\n\\n/* Equation: sum1-num1+num2 = sum2-num2+num1\\n          => sum1-sum2(diff) = 2num1 - 2num2  */\\n\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        int sum1=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n            sum1+=aliceSizes[i];\\n            \\n        \\n        int sum2=0;\\n        for(int i=0;i<bobSizes.size();i++)\\n            sum2+=bobSizes[i];\\n        \\n        int diff=abs(sum1-sum2);\\n        \\n        vector<int> ans;\\n        \\n        if(sum2<=sum1)\\n        {\\n            unordered_set<int> ust;\\n            for(int i=0;i<aliceSizes.size();i++)\\n                ust.insert(aliceSizes[i]*2);\\n            \\n            for(int i=0;i<bobSizes.size();i++)\\n            {\\n                if(ust.find(diff+(2*bobSizes[i]))!=ust.end())\\n                {\\n                    ans.push_back((*ust.find(diff+(2*bobSizes[i])))/2);\\n                    ans.push_back(bobSizes[i]);\\n                    return(ans);\\n                }\\n            }\\n        }\\n        if(sum2>sum1)\\n        {\\n            unordered_set<int> ust;\\n            for(int i=0;i<bobSizes.size();i++)\\n                ust.insert(bobSizes[i]*2);\\n            \\n            for(int i=0;i<aliceSizes.size();i++)\\n            {\\n                if(ust.find(diff+(2*aliceSizes[i]))!=ust.end())\\n                {\\n                    ans.push_back(aliceSizes[i]);\\n                    ans.push_back((*ust.find(diff+(2*aliceSizes[i])))/2);\\n                    return(ans);\\n                }\\n            }\\n        }\\n        \\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/* Equation: sum1-num1+num2 = sum2-num2+num1\\n          => sum1-sum2(diff) = 2num1 - 2num2  */\\n\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        int sum1=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n            sum1+=aliceSizes[i];\\n            \\n        \\n        int sum2=0;\\n        for(int i=0;i<bobSizes.size();i++)\\n            sum2+=bobSizes[i];\\n        \\n        int diff=abs(sum1-sum2);\\n        \\n        vector<int> ans;\\n        \\n        if(sum2<=sum1)\\n        {\\n            unordered_set<int> ust;\\n            for(int i=0;i<aliceSizes.size();i++)\\n                ust.insert(aliceSizes[i]*2);\\n            \\n            for(int i=0;i<bobSizes.size();i++)\\n            {\\n                if(ust.find(diff+(2*bobSizes[i]))!=ust.end())\\n                {\\n                    ans.push_back((*ust.find(diff+(2*bobSizes[i])))/2);\\n                    ans.push_back(bobSizes[i]);\\n                    return(ans);\\n                }\\n            }\\n        }\\n        if(sum2>sum1)\\n        {\\n            unordered_set<int> ust;\\n            for(int i=0;i<bobSizes.size();i++)\\n                ust.insert(bobSizes[i]*2);\\n            \\n            for(int i=0;i<aliceSizes.size();i++)\\n            {\\n                if(ust.find(diff+(2*aliceSizes[i]))!=ust.end())\\n                {\\n                    ans.push_back(aliceSizes[i]);\\n                    ans.push_back((*ust.find(diff+(2*aliceSizes[i])))/2);\\n                    return(ans);\\n                }\\n            }\\n        }\\n        \\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164350,
                "title": "implementation-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n        int suma=0,sumb=0;\\n        for(int e:a){\\n            suma+=e;\\n        }\\n        for(int y:b)\\n            sumb+=y;\\n        for(int x:a){\\n            for(int y:b){\\n         if(suma-x+y==sumb-y+x) return{x,y};\\n            }\\n        }\\n        return{0,0};\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n        int suma=0,sumb=0;\\n        for(int e:a){\\n            suma+=e;\\n        }\\n        for(int y:b)\\n            sumb+=y;\\n        for(int x:a){\\n            for(int y:b){\\n         if(suma-x+y==sumb-y+x) return{x,y};\\n            }\\n        }\\n        return{0,0};\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084350,
                "title": "java-solution-jw",
                "content": "```\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int[] ans = new int[2];\\n        int sumA = 0, sumB = 0;\\n        for(int i: A){\\n            sumA += i;\\n        }\\n        for(int j: B){\\n            sumB += j;\\n        }\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        int temp = sumA-(sumA+sumB)/2;\\n        int i = 0, j = 0;\\n        while(i<A.length&&j<B.length){\\n            if(A[i]-B[j]==temp){\\n                ans[0] = A[i];\\n                ans[1] = B[j];\\n                break;\\n            }\\n            else if(A[i]-B[j]>temp){\\n                j++;\\n            }\\n            else if(A[i]-B[j]<temp){\\n                i++;\\n            }\\n        }\\n        return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int[] ans = new int[2];\\n        int sumA = 0, sumB = 0;\\n        for(int i: A){\\n            sumA += i;\\n        }\\n        for(int j: B){\\n            sumB += j;\\n        }\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        int temp = sumA-(sumA+sumB)/2;\\n        int i = 0, j = 0;\\n        while(i<A.length&&j<B.length){\\n            if(A[i]-B[j]==temp){\\n                ans[0] = A[i];\\n                ans[1] = B[j];\\n                break;\\n            }\\n            else if(A[i]-B[j]>temp){\\n                j++;\\n            }\\n            else if(A[i]-B[j]<temp){\\n                i++;\\n            }\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1021514,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        \\n        totalhalf = ( sum(A) + sum(B) ) // 2   # gives sum(A) or sum(B) after sharing candies\\n        \\n        B = set(B) # for removing duplicates\\n\\n        for j in range(len(A)) :\\n            if (totalhalf - (sum(A) - A[j])) in B :\\n                return [A[j],totalhalf-(sum(A) - A[j])]\\n            \\n            \\n            # [sum(A) - A[j]] ---> amount [A] without the element that is to be shared\\n            # [totalhalf - (sum(A) - A[j])] ---> gives the needed element from bobs list\\n            \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        \\n        totalhalf = ( sum(A) + sum(B) ) // 2   # gives sum(A) or sum(B) after sharing candies\\n        \\n        B = set(B) # for removing duplicates\\n\\n        for j in range(len(A)) :\\n            if (totalhalf - (sum(A) - A[j])) in B :\\n                return [A[j],totalhalf-(sum(A) - A[j])]\\n            \\n            \\n            # [sum(A) - A[j]] ---> amount [A] without the element that is to be shared\\n            # [totalhalf - (sum(A) - A[j])] ---> gives the needed element from bobs list\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019746,
                "title": "solution-with-explanation-o-n-m-c",
                "content": "Let remove x from A and y from B to make their sum equal\\n\\nTherefore, A-x+y = B+x-y \\n=> x - y = (A - B)/2 = diff\\n\\nNow find if any x = y+diff\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        vector<int> ans;\\n        \\n        int sum_A = accumulate(A.begin(),A.end(),0);\\n        int sum_B = accumulate(B.begin(),B.end(),0);\\n        \\n        int diff = (sum_A - sum_B)/2;\\n        \\n        map<int,bool> m;\\n        for(int i=0; i<n; i++)\\n             m[A[i]] = true;\\n        \\n\\t\\tint m = B.size();\\n        for(int i=0; i<m; i++){\\n            if(m[B[i] + diff]){ // to find any j such that A[j] - B[i] = diff\\n                ans.push_back(B[i]+diff); \\n                ans.push_back(B[i]);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        vector<int> ans;\\n        \\n        int sum_A = accumulate(A.begin(),A.end(),0);\\n        int sum_B = accumulate(B.begin(),B.end(),0);\\n        \\n        int diff = (sum_A - sum_B)/2;\\n        \\n        map<int,bool> m;\\n        for(int i=0; i<n; i++)\\n             m[A[i]] = true;\\n        \\n\\t\\tint m = B.size();\\n        for(int i=0; i<m; i++){\\n            if(m[B[i] + diff]){ // to find any j such that A[j] - B[i] = diff\\n                ans.push_back(B[i]+diff); \\n                ans.push_back(B[i]);\\n                return ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 995822,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        #\\n        difference = sum(A)-sum(B)\\n        B = set(B)\\n        for i in A:\\n            if i-difference//2 in B:\\n                return [i,i-difference//2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        #\\n        difference = sum(A)-sum(B)\\n        B = set(B)\\n        for i in A:\\n            if i-difference//2 in B:\\n                return [i,i-difference//2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970756,
                "title": "python-easy-solution-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/3e18ba1c-9f6d-4b7c-9798-7cd1a036df57_1607855688.0515661.png)\\n\\n```\\ndef fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(A) - sum(B)) // 2\\n        b = set(B)\\n        for x in A:\\n            if x - diff in b:\\n                return [x, x - diff]\\n        return []\\n\\t",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/3e18ba1c-9f6d-4b7c-9798-7cd1a036df57_1607855688.0515661.png)\\n\\n```\\ndef fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(A) - sum(B)) // 2\\n        b = set(B)\\n        for x in A:\\n            if x - diff in b:\\n                return [x, x - diff]\\n        return []\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 924473,
                "title": "python-simple-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        s = (sum(A) - sum(B)) // 2\\n        A = set(A)\\n        \\n        for n in B:\\n            if s + n in A:\\n                return [s + n, n]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        s = (sum(A) - sum(B)) // 2\\n        A = set(A)\\n        \\n        for n in B:\\n            if s + n in A:\\n                return [s + n, n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856146,
                "title": "c",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int sumA = accumulate(A.begin(), A.end(), 0);\\n        int sumB = accumulate(B.begin(), B.end(), 0);\\n        \\n        sort(A.begin(), A.end(), greater<int>());\\n        sort(B.begin(), B.end(), greater<int>());\\n        \\n        vector<int> ans;\\n        \\n        int avgSum = (sumA + sumB) / 2;\\n        \\n        int diff = abs(avgSum - sumA);\\n        \\n        for (const auto & a : A)\\n        {\\n            for (const auto & b : B)\\n            {\\n                if ( ( sumA > sumB && a - b == diff ) || ( sumB > sumA && b - a == diff ) )\\n                {\\n                    ans.push_back(a);\\n                    ans.push_back(b);\\n                    \\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n### [\\u53C2\\u8003](https://leetcode.com/problems/fair-candy-swap/solution/)\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int sumA = accumulate(A.begin(), A.end(), 0);\\n        int sumB = accumulate(B.begin(), B.end(), 0);\\n        \\n        int delta = (sumB - sumA) / 2;\\n        \\n        set<int> setB;\\n        \\n        for (const auto & item : B)\\n            setB.insert(item);\\n        \\n        vector<int> ans;\\n        \\n        for (const auto & item : A)\\n        {\\n            if (setB.count(item + delta))\\n                return {item, item+delta};\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int sumA = accumulate(A.begin(), A.end(), 0);\\n        int sumB = accumulate(B.begin(), B.end(), 0);\\n        \\n        sort(A.begin(), A.end(), greater<int>());\\n        sort(B.begin(), B.end(), greater<int>());\\n        \\n        vector<int> ans;\\n        \\n        int avgSum = (sumA + sumB) / 2;\\n        \\n        int diff = abs(avgSum - sumA);\\n        \\n        for (const auto & a : A)\\n        {\\n            for (const auto & b : B)\\n            {\\n                if ( ( sumA > sumB && a - b == diff ) || ( sumB > sumA && b - a == diff ) )\\n                {\\n                    ans.push_back(a);\\n                    ans.push_back(b);\\n                    \\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int sumA = accumulate(A.begin(), A.end(), 0);\\n        int sumB = accumulate(B.begin(), B.end(), 0);\\n        \\n        int delta = (sumB - sumA) / 2;\\n        \\n        set<int> setB;\\n        \\n        for (const auto & item : B)\\n            setB.insert(item);\\n        \\n        vector<int> ans;\\n        \\n        for (const auto & item : A)\\n        {\\n            if (setB.count(item + delta))\\n                return {item, item+delta};\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842951,
                "title": "python",
                "content": "\\tclass Solution:\\n\\t\\tdef fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n\\t\\t\\t\\n\\t\\t\\ta = sum(A)\\n\\t\\t\\tb = sum(B)\\n\\t\\t\\ttarget = (a+b)//2\\n\\n\\t\\t\\tif a<b:\\n\\t\\t\\t\\tdiff = target-a\\n\\t\\t\\t\\tfor q in A:\\n\\t\\t\\t\\t\\tif q+diff in B:\\n\\t\\t\\t\\t\\t\\treturn [q,q+diff]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdiff = target-b\\n\\t\\t\\t\\tfor q in B:\\n\\t\\t\\t\\t\\tif q+diff in A:\\n\\t\\t\\t\\t\\t\\treturn [q+diff,q]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n\\t\\t\\t\\n\\t\\t\\ta = sum(A)\\n\\t\\t\\tb = sum(B)\\n\\t\\t\\ttarget = (a+b)//2\\n\\n\\t\\t\\tif a<b:\\n\\t\\t\\t\\tdiff = target-a\\n\\t\\t\\t\\tfor q in A:\\n\\t\\t\\t\\t\\tif q+diff in B:\\n\\t\\t\\t\\t\\t\\treturn [q,q+diff]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdiff = target-b\\n\\t\\t\\t\\tfor q in B:\\n\\t\\t\\t\\t\\tif q+diff in A:\\n\\t\\t\\t\\t\\t\\treturn [q+diff,q]",
                "codeTag": "Java"
            },
            {
                "id": 840246,
                "title": "c-solution-using-binary-search-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(auto it : a) sum1+=it;\\n        \\n        for(auto it :b) sum2+=it;\\n        \\n       \\n        \\n        sort(b.begin(),b.end());\\n            \\n        for(int i=0;i<a.size();i++)\\n        {\\n            int y = a[i] - (sum1 - sum2)/2;\\n            if(binary_search(b.begin(), b.end(), y))\\n            {\\n               return {a[i],y};\\n            }\\n            \\n        }\\n        return {-1,-1};\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(auto it : a) sum1+=it;\\n        \\n        for(auto it :b) sum2+=it;\\n        \\n       \\n        \\n        sort(b.begin(),b.end());\\n            \\n        for(int i=0;i<a.size();i++)\\n        {\\n            int y = a[i] - (sum1 - sum2)/2;\\n            if(binary_search(b.begin(), b.end(), y))\\n            {\\n               return {a[i],y};\\n            }\\n            \\n        }\\n        return {-1,-1};\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776869,
                "title": "python-code-thank-you-looks-well",
                "content": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        aa=sum(A)\\n        bb=sum(B)\\n        for i in B:\\n             if (aa-bb+2*i)//2 in A:\\n                    return [(aa-bb+2*i)//2,i]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        aa=sum(A)\\n        bb=sum(B)\\n        for i in B:\\n             if (aa-bb+2*i)//2 in A:\\n                    return [(aa-bb+2*i)//2,i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695497,
                "title": "ruby-straightforward-simple-working-solution",
                "content": "##### Leetcode: 888. Fair Candy Swap.\\n\\n\\nFirst preparations calculate total amount of candy that Alice and Bob has. Next create a hash that stores what sizes of candy each sweets owner has, sizes will be keys in these Hash maps. Now iterating over all Alice candies solve such equity `Alice_sum - candy + x = Bob_sum + candy - x` and thus `2*x = (Bob_sum + candy) - (Alice_sum - candy)` and `x` will be candy size Bob need to return. Check that `2x` is positive, even, and `x` exists in Bobs hash. And return `[candy, 2x/2]`. Done.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 888. Fair Candy Swap.\\n# https://leetcode.com/problems/fair-candy-swap/\\n# Runtime: 452 ms, faster than 56.25% of Ruby online submissions for Fair Candy Swap.\\n# Memory Usage: 13.7 MB, less than 100.00% of Ruby online submissions for Fair Candy Swap.\\n# @param {Integer[]} a\\n# @param {Integer[]} b\\n# @return {Integer[]}\\ndef fair_candy_swap(a, b)\\n    asum, bsum = a.sum, b.sum\\n    ah, bh = a.zip(a).to_h, b.zip(b).to_h\\n    a.each do |swt|\\n        x2 = (bsum + swt) - (a.sum - swt)\\n        next if x2 <= 0\\n        next if x2.odd?\\n        next if bh[x2/2].nil?\\n        return [swt,x2/2]\\n        \\n    end\\n    raise \"Cannot find answer.\"\\n    \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 888. Fair Candy Swap.\\n# https://leetcode.com/problems/fair-candy-swap/\\n# Runtime: 452 ms, faster than 56.25% of Ruby online submissions for Fair Candy Swap.\\n# Memory Usage: 13.7 MB, less than 100.00% of Ruby online submissions for Fair Candy Swap.\\n# @param {Integer[]} a\\n# @param {Integer[]} b\\n# @return {Integer[]}\\ndef fair_candy_swap(a, b)\\n    asum, bsum = a.sum, b.sum\\n    ah, bh = a.zip(a).to_h, b.zip(b).to_h\\n    a.each do |swt|\\n        x2 = (bsum + swt) - (a.sum - swt)\\n        next if x2 <= 0\\n        next if x2.odd?\\n        next if bh[x2/2].nil?\\n        return [swt,x2/2]\\n        \\n    end\\n    raise \"Cannot find answer.\"\\n    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 694608,
                "title": "rust-hashset-8ms",
                "content": "```Rust\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn fair_candy_swap(a: Vec<i32>, b: Vec<i32>) -> Vec<i32>\\n    {\\n        let a_sum: i32 = a.iter().sum();\\n        let b_sum: i32 = b.iter().sum();\\n        let b_set: HashSet<i32> = HashSet::from_iter(b.into_iter());\\n        for x in a {\\n            let y = (b_sum - a_sum) / 2 + x;\\n            if b_set.contains(&y) {\\n                return vec![x, y];\\n            }\\n        }\\n        panic!(\"Impossible.\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn fair_candy_swap(a: Vec<i32>, b: Vec<i32>) -> Vec<i32>\\n    {\\n        let a_sum: i32 = a.iter().sum();\\n        let b_sum: i32 = b.iter().sum();\\n        let b_set: HashSet<i32> = HashSet::from_iter(b.into_iter());\\n        for x in a {\\n            let y = (b_sum - a_sum) / 2 + x;\\n            if b_set.contains(&y) {\\n                return vec![x, y];\\n            }\\n        }\\n        panic!(\"Impossible.\");\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657723,
                "title": "java-solutions-easy-to-read-with-complexities",
                "content": "From my understanding there can be a total of 3 solutions. Brute force, Binary Search, and a Set solution.\\n\\nMy brute force was straightforward, compute the sums first, and traverse through every candy bar combination until a middle ground is met by both Alice and Bob. This of course is not linear but it can be useful if we are in a memory constraint environment.\\n\\n```\\n\\t// O(N*M) Time | O(1) Space, N and M size of A and B\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int Atotal = 0, Btotal = 0;\\n        for (int i : A) Atotal += i;\\n        for (int i : B) Btotal += i;\\n        \\n        int middleGround = (Atotal + Btotal) / 2;\\n        \\n        for (int i : A) {\\n            for (int j : B) {\\n                int Asum = Atotal - i, Bsum = Btotal - j;\\n                if (Asum + j == middleGround && Bsum + i == middleGround) {\\n                    return new int[] {i, j};\\n                }\\n            }\\n        }\\n        return new int[2];\\n    }\\n```\\n\\nThe set solution is much more efficient. We first convert Bob\\'s input into a set.\\nThen we go through Alice\\'s input to see if bob has the appropriate candy bar if Alice were to give up one of hers.\\n\\n```\\n// O(N + M) Time | O(M) Space OR O(N +M) Time | O(N) Space\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int Atotal = 0, Btotal = 0;\\n        Set<Integer> bSet = new HashSet<>();\\n        for (int i : A) Atotal += i;\\n        for (int i : B) {\\n            Btotal += i;\\n            bSet.add(i);\\n        }\\n        \\n        int middleGround = (Atotal + Btotal) / 2;\\n        for (int i : A) {\\n            // if alice gives up her candy bar at i, she is expecting middleGround - (Atotal- i) from bob.\\n            if (bSet.contains(middleGround - (Atotal- i))) \\n                return new int[] {i, middleGround - (Atotal- i)};\\n        }\\n        return new int[2];\\n    }\\n```\\n\\nFor binary search instead of searching the set like we did in our previous solution, we simply run a binary search for the candy bar we are looking for. This assumes the input is sorted, which is not guaranteed in the description. At best this is a better version of the brute force.",
                "solutionTags": [],
                "code": "```\\n\\t// O(N*M) Time | O(1) Space, N and M size of A and B\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int Atotal = 0, Btotal = 0;\\n        for (int i : A) Atotal += i;\\n        for (int i : B) Btotal += i;\\n        \\n        int middleGround = (Atotal + Btotal) / 2;\\n        \\n        for (int i : A) {\\n            for (int j : B) {\\n                int Asum = Atotal - i, Bsum = Btotal - j;\\n                if (Asum + j == middleGround && Bsum + i == middleGround) {\\n                    return new int[] {i, j};\\n                }\\n            }\\n        }\\n        return new int[2];\\n    }\\n```\n```\\n// O(N + M) Time | O(M) Space OR O(N +M) Time | O(N) Space\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int Atotal = 0, Btotal = 0;\\n        Set<Integer> bSet = new HashSet<>();\\n        for (int i : A) Atotal += i;\\n        for (int i : B) {\\n            Btotal += i;\\n            bSet.add(i);\\n        }\\n        \\n        int middleGround = (Atotal + Btotal) / 2;\\n        for (int i : A) {\\n            // if alice gives up her candy bar at i, she is expecting middleGround - (Atotal- i) from bob.\\n            if (bSet.contains(middleGround - (Atotal- i))) \\n                return new int[] {i, middleGround - (Atotal- i)};\\n        }\\n        return new int[2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 646546,
                "title": "simple-clean-swift-solution-with-time-and-space-complexity",
                "content": "```\\n// Kevin Li - 7:50 PM - 5/22/20\\n\\n// https://leetcode.com/problems/fair-candy-swap/solution/\\n// Time: O(n)\\n// Space: O(n)\\n\\nclass Solution {\\n\\n    // In this solution, we solve for candySizeFromB\\n    // Equation: SumOfA - candySizeFromA + candySizeFromB = SumOfB + candySizeFromA - candySizeFromB\\n    // Equation(cont): 2 * candySizeFromB = (SumOfB - SumOfA) + (2 * candySizeFromA)\\n    // Equation(cont): candySizeFromB = ((SumOfB - SumOfA) / 2) + candySizeFromA\\n    func fairCandySwap(_ A: [Int], _ B: [Int]) -> [Int] {\\n        // complementCandySizes contains all the possible values that may\\n        // result from solving for sizeFromB in the above equation\\n        let complementCandySizes = Set(B)\\n        let sumOfA = A.reduce(0, +)\\n        let sumOfB = B.reduce(0, +)\\n        // delta represents how much sizeFromA will be shifted\\n        // in order to calculate sizeFromB\\n        let delta = (sumOfB - sumOfA) / 2\\n\\n        for candySizeFromA in A {\\n            let candySizeFromB = delta + candySizeFromA\\n            if complementCandySizes.contains(candySizeFromB) {\\n                return [candySizeFromA, candySizeFromB]\\n            }\\n        }\\n\\n        fatalError(\"Error: Problem specifies that solution is guaranteed to exist\")\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Kevin Li - 7:50 PM - 5/22/20\\n\\n// https://leetcode.com/problems/fair-candy-swap/solution/\\n// Time: O(n)\\n// Space: O(n)\\n\\nclass Solution {\\n\\n    // In this solution, we solve for candySizeFromB\\n    // Equation: SumOfA - candySizeFromA + candySizeFromB = SumOfB + candySizeFromA - candySizeFromB\\n    // Equation(cont): 2 * candySizeFromB = (SumOfB - SumOfA) + (2 * candySizeFromA)\\n    // Equation(cont): candySizeFromB = ((SumOfB - SumOfA) / 2) + candySizeFromA\\n    func fairCandySwap(_ A: [Int], _ B: [Int]) -> [Int] {\\n        // complementCandySizes contains all the possible values that may\\n        // result from solving for sizeFromB in the above equation\\n        let complementCandySizes = Set(B)\\n        let sumOfA = A.reduce(0, +)\\n        let sumOfB = B.reduce(0, +)\\n        // delta represents how much sizeFromA will be shifted\\n        // in order to calculate sizeFromB\\n        let delta = (sumOfB - sumOfA) / 2\\n\\n        for candySizeFromA in A {\\n            let candySizeFromB = delta + candySizeFromA\\n            if complementCandySizes.contains(candySizeFromB) {\\n                return [candySizeFromA, candySizeFromB]\\n            }\\n        }\\n\\n        fatalError(\"Error: Problem specifies that solution is guaranteed to exist\")\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642296,
                "title": "simplest-java",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int diff = sum(A) - sum(B);\\n        int[] swaps = new int[2];\\n        \\n            for(int i=0; i< A.length; i++) {\\n                for(int j=0;j < B.length; j++) {\\n                    if(diff == 2*(A[i]-B[j])){  //these need to be swapped.\\n                        swaps[0] = A[i];\\n                        swaps[1] = B[j];\\n                        return swaps;\\n                    }\\n                    \\n                }\\n            }\\n      \\n        return null;\\n    }\\n    \\n    int sum(int[] arr) {\\n        int sum = 0;\\n        for(int item: arr) {\\n            sum+= item;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int diff = sum(A) - sum(B);\\n        int[] swaps = new int[2];\\n        \\n            for(int i=0; i< A.length; i++) {\\n                for(int j=0;j < B.length; j++) {\\n                    if(diff == 2*(A[i]-B[j])){  //these need to be swapped.\\n                        swaps[0] = A[i];\\n                        swaps[1] = B[j];\\n                        return swaps;\\n                    }\\n                    \\n                }\\n            }\\n      \\n        return null;\\n    }\\n    \\n    int sum(int[] arr) {\\n        int sum = 0;\\n        for(int item: arr) {\\n            sum+= item;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636263,
                "title": "python-2-line-video",
                "content": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        diff, B = (sum(B) - sum(A)) / 2, set(B)\\n        return [[a, a+diff] for a in A if a + diff in B][0]\\n```\\n\\nmeaningless video: http://youtube.com/watch?v=VhqKC0HQXlM\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        diff, B = (sum(B) - sum(A)) / 2, set(B)\\n        return [[a, a+diff] for a in A if a + diff in B][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623527,
                "title": "simple-java-solution-with-arrays-easy-to-understand-anyone",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n         int[] candyPair = new int[2];\\n        int countCandiesA = 0, countCandiesB = 0;\\n        for (int i = 0; i < A.length; i++) {//counting candies in A\\n            countCandiesA += A[i];\\n        }\\n        for (int i = 0; i < B.length; i++) {//counting candies in B\\n            countCandiesB += B[i];\\n        }\\n        int candiesNeedToBeSwitched = Math.abs((countCandiesA - countCandiesB) / 2);//averaging for switch\\n        if (countCandiesA > countCandiesB) { // this case applicable when A has more candies than B\\n            for (int i = 0; i < A.length; i++) {\\n                for (int j = 0; j < B.length; j++) {\\n                    if (Math.abs(A[i] - B[j]) == candiesNeedToBeSwitched) {\\n                        if (A[i] - B[j] == candiesNeedToBeSwitched) {\\n                            candyPair[0] = A[i];\\n                            candyPair[1] = B[j];\\n                            return candyPair;\\n                        }\\n                    }\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i < A.length; i++) {\\n                for (int j = 0; j < B.length; j++) {\\n                    if (Math.abs(A[i] - B[j]) == candiesNeedToBeSwitched) {\\n                        if (B[j] - A[i] == candiesNeedToBeSwitched) {\\n                            candyPair[0] = A[i];\\n                            candyPair[1] = B[j];\\n                            return candyPair;\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n        return candyPair;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n         int[] candyPair = new int[2];\\n        int countCandiesA = 0, countCandiesB = 0;\\n        for (int i = 0; i < A.length; i++) {//counting candies in A\\n            countCandiesA += A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 604229,
                "title": "cpp-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int a=accumulate(begin(A),end(A),0);\\n        int b=accumulate(begin(B),end(B),0);\\n        \\n        if(a==b)\\n            return {};\\n        \\n        int d=a-b;\\n        unordered_set<int> aa(begin(A),end(A)),bb(begin(B),end(B));\\n        for(auto x:aa){\\n            if(bb.count(x-d/2))\\n                return {x,x-d/2};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int a=accumulate(begin(A),end(A),0);\\n        int b=accumulate(begin(B),end(B),0);\\n        \\n        if(a==b)\\n            return {};\\n        \\n        int d=a-b;\\n        unordered_set<int> aa(begin(A),end(A)),bb(begin(B),end(B));\\n        for(auto x:aa){\\n            if(bb.count(x-d/2))\\n                return {x,x-d/2};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570338,
                "title": "c-solution",
                "content": "SumA - A[i] + B[j] = SumB - B[j] + A[i]\\n=> **A[i] = (SumA - SumB) / 2 + B[j]**\\n```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B) {\\n        \\n        int[] res = new int[2];\\n        int sumA = A.Sum();\\n        int sumB = B.Sum();\\n        int diff = (sumA - sumB) / 2;\\n        \\n        HashSet<int> set = new HashSet<int>(A);\\n        for(int i = 0; i < B.Length; i++)\\n        {\\n            if(set.Contains(B[i] + diff))\\n            {\\n                res[0] = B[i] + diff;\\n                res[1] = B[i];\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B) {\\n        \\n        int[] res = new int[2];\\n        int sumA = A.Sum();\\n        int sumB = B.Sum();\\n        int diff = (sumA - sumB) / 2;\\n        \\n        HashSet<int> set = new HashSet<int>(A);\\n        for(int i = 0; i < B.Length; i++)\\n        {\\n            if(set.Contains(B[i] + diff))\\n            {\\n                res[0] = B[i] + diff;\\n                res[1] = B[i];\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494764,
                "title": "rust-12ms-2-3m-80",
                "content": "```rust\\nuse std::collections::HashSet;\\n\\npub fn fair_candy_swap(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n    let s1 = a.iter().fold(0, |acc, x| { acc + *x });\\n    let s2 = b.iter().fold(0, |acc, x| { acc + *x });\\n    let delta = (s2 - s1) / 2;\\n    let mut set = HashSet::<i32>::new();\\n    for x in b { set.insert(x); }\\n    for x in a {\\n        if set.contains(&(x + delta)) {\\n            return vec![x, x + delta];\\n        }\\n    }\\n    panic!()\\n}\\n\\n````",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\npub fn fair_candy_swap(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n    let s1 = a.iter().fold(0, |acc, x| { acc + *x });\\n    let s2 = b.iter().fold(0, |acc, x| { acc + *x });\\n    let delta = (s2 - s1) / 2;\\n    let mut set = HashSet::<i32>::new();\\n    for x in b { set.insert(x); }\\n    for x in a {\\n        if set.contains(&(x + delta)) {\\n            return vec![x, x + delta];\\n        }\\n    }\\n    panic!()\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399536,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        l = (sum(A) - sum(B)) // 2\\n\\t\\tfor i in set(A):\\n\\t\\t    if i - l in set(B):\\n\\t\\t        return [i, i-l]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        l = (sum(A) - sum(B)) // 2\\n\\t\\tfor i in set(A):\\n\\t\\t    if i - l in set(B):\\n\\t\\t        return [i, i-l]",
                "codeTag": "Java"
            },
            {
                "id": 395876,
                "title": "python-3-solution-beats-95",
                "content": "Algo\\nIn order for the candy sizes after swap to be equal, the diffrence of  swapped candy sizes must be one half of the difference in total size before swapping, i.e. \\n\\ndiff = (sum(B) - sum(A))//2\\n\\nAfter that, loop through elements in A and check if a candy larger than the current element of A by diff exists in B. If so, return the pair. \\n\\n```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(B) - sum(A))//2\\n        B = set(B)\\n        for a in A:\\n            if a + diff in B:\\n                return [a, a+diff]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(B) - sum(A))//2\\n        B = set(B)\\n        for a in A:\\n            if a + diff in B:\\n                return [a, a+diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381856,
                "title": "solution-in-python-3-two-lines",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n    \\td, SA, SB = (sum(A) - sum(B))//2, set(A), set(B)\\n    \\treturn [[i, i - d] for i in SA if i - d in SB][0]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n    \\td, SA, SB = (sum(A) - sum(B))//2, set(A), set(B)\\n    \\treturn [[i, i - d] for i in SA if i - d in SB][0]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 368353,
                "title": "easy-cpp-solution-using-hash",
                "content": "Runtime: 112 ms, faster than 86.51% of C++ online submissions for Fair Candy Swap.\\nMemory Usage: 23.7 MB, less than 10.00% of C++ online submissions for Fair Candy Swap.\\n\\n```\\nvector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        int m = B.size();\\n        unordered_set<int> mp;\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sum1 += A[i];\\n            mp.insert(A[i]);\\n        }\\n        \\n        for(int j=0; j<m; j++)\\n            sum2 += B[j];\\n        \\n        int diff = (sum1 - sum2)/2;\\n        \\n        for(int j=0; j<m; j++)\\n        {\\n            if(mp.find(B[j] + diff) != mp.end())\\n                return vector<int>{B[j]+diff, B[j]};\\n        }\\n        \\n        return vector<int>{};\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Runtime: 112 ms, faster than 86.51% of C++ online submissions for Fair Candy Swap.\\nMemory Usage: 23.7 MB, less than 10.00% of C++ online submissions for Fair Candy Swap.\\n\\n```\\nvector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        int m = B.size();\\n        unordered_set<int> mp;\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sum1 += A[i];\\n            mp.insert(A[i]);\\n        }\\n        \\n        for(int j=0; j<m; j++)\\n            sum2 += B[j];\\n        \\n        int diff = (sum1 - sum2)/2;\\n        \\n        for(int j=0; j<m; j++)\\n        {\\n            if(mp.find(B[j] + diff) != mp.end())\\n                return vector<int>{B[j]+diff, B[j]};\\n        }\\n        \\n        return vector<int>{};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 352194,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nsA-x+y = sB-y+x => 2x = sA+2y-sB\\n\\n```\\n    public int[] fairCandySwap(int[] a, int[] b) {\\n        int sA = 0, sB = 0;\\n        Set<Integer> setA = new HashSet<>();\\n        for(int x : a){\\n            setA.add(x);\\n            sA += x;\\n        }\\n        for(int y : b)\\n            sB += y;\\n        for(int y : b){\\n            int x = (sA+2*y-sB) / 2;\\n            if(setA.contains(x))\\n                return new int[]{x, y};\\n        }\\n        //never reaches\\n        return new int[2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] fairCandySwap(int[] a, int[] b) {\\n        int sA = 0, sB = 0;\\n        Set<Integer> setA = new HashSet<>();\\n        for(int x : a){\\n            setA.add(x);\\n            sA += x;\\n        }\\n        for(int y : b)\\n            sB += y;\\n        for(int y : b){\\n            int x = (sA+2*y-sB) / 2;\\n            if(setA.contains(x))\\n                return new int[]{x, y};\\n        }\\n        //never reaches\\n        return new int[2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308051,
                "title": "python-o-n-by-set",
                "content": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        b_set = set(B)\\n        sumA,sumB = sum(A),sum(B)\\n        diff = (sumB-sumA)/2\\n        \\n        for item in A:\\n            target = item+diff\\n            if target in b_set:\\n                return [item, item+diff]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        b_set = set(B)\\n        sumA,sumB = sum(A),sum(B)\\n        diff = (sumB-sumA)/2\\n        \\n        for item in A:\\n            target = item+diff\\n            if target in b_set:\\n                return [item, item+diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306497,
                "title": "o-nlogn-java-sol-with-no-extra-space-binary-search-93",
                "content": "```\\nclass Solution \\n{\\n    int sum(int a[])\\n    {\\n        int s=0;\\n        for(int i=0;i<a.length;i++)\\n            s=s+a[i];\\n        return s;\\n    }\\n    public int[] fairCandySwap(int[] a, int[] b) \\n    {\\n        int s1=sum(a);\\n        int s2=sum(b);\\n        int ans[]=new int[2];\\n        \\n        if(s1>s2)\\n        {\\n            int c=(s1-s2)/2;\\n            Arrays.sort(b);\\n            for(Integer i:a)\\n            {\\n                if(Arrays.binarySearch(b,i-c)>=0)\\n                {\\n                    ans[0]=i;\\n                    ans[1]=i-c;\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            int c=(s2-s1)/2;\\n            Arrays.sort(a);\\n            for(Integer i:b)\\n            {\\n                if(Arrays.binarySearch(a,i-c)>=0)\\n                {\\n                    ans[0]=i-c;\\n                    ans[1]=i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    int sum(int a[])\\n    {\\n        int s=0;\\n        for(int i=0;i<a.length;i++)\\n            s=s+a[i];\\n        return s;\\n    }\\n    public int[] fairCandySwap(int[] a, int[] b) \\n    {\\n        int s1=sum(a);\\n        int s2=sum(b);\\n        int ans[]=new int[2];\\n        \\n        if(s1>s2)\\n        {\\n            int c=(s1-s2)/2;\\n            Arrays.sort(b);\\n            for(Integer i:a)\\n            {\\n                if(Arrays.binarySearch(b,i-c)>=0)\\n                {\\n                    ans[0]=i;\\n                    ans[1]=i-c;\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            int c=(s2-s1)/2;\\n            Arrays.sort(a);\\n            for(Integer i:b)\\n            {\\n                if(Arrays.binarySearch(a,i-c)>=0)\\n                {\\n                    ans[0]=i-c;\\n                    ans[1]=i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295673,
                "title": "python3-simple-math",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(A) - sum(B)) // 2\\n        for num in A:\\n            if num - diff in B:\\n                return [num, num - diff]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(A) - sum(B)) // 2\\n        for num in A:\\n            if num - diff in B:\\n                return [num, num - diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284253,
                "title": "c-constant-space-o-n-ln-n-time",
                "content": "```\\n\\tpublic int[] FairCandySwap(int[] A, int[] B) {\\n        int dif = (A.Sum() - B.Sum()) / 2;\\n        Array.Sort(A);\\n        Array.Sort(B);\\n        int i = 0, j = 0;\\n        while (A[i] - B[j] != dif)\\n        {\\n            while (A[i] - B[j] > dif) j++;\\n            while (A[i] - B[j] < dif) i++;\\n        }\\n        return new int[] { A[i], B[j] };\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] FairCandySwap(int[] A, int[] B) {\\n        int dif = (A.Sum() - B.Sum()) / 2;\\n        Array.Sort(A);\\n        Array.Sort(B);\\n        int i = 0, j = 0;\\n        while (A[i] - B[j] != dif)\\n        {\\n            while (A[i] - B[j] > dif) j++;\\n            while (A[i] - B[j] < dif) i++;\\n        }\\n        return new int[] { A[i], B[j] };\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275850,
                "title": "javascript-o-n-100-readable",
                "content": "```\\nvar fairCandySwap = function(A, B) {    \\n    const sum = (first, next) => first + next;\\n    \\n    const sumA = A.reduce(sum);\\n    const sumB = B.reduce(sum);\\n    \\n    // sum of both together has to be even for this to work\\n    // if ( (sumA + sumB) % 2 !== 0 ) return false;\\n    \\n    const mid = (sumA + sumB) / 2;\\n    \\n    const setB = new Set(B);      \\n    \\n    for (let i=0; i< A.length; i++ ) {     \\n        const current = A[i];\\n        const withoutCurrent = sumA - current;\\n        const searchedItem = mid - withoutCurrent;\\n                       \\n        if ( setB.has(searchedItem) &&  sumB - searchedItem + current === mid ) {\\n            return [ A[i], searchedItem ];\\n        }        \\n    }      \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar fairCandySwap = function(A, B) {    \\n    const sum = (first, next) => first + next;\\n    \\n    const sumA = A.reduce(sum);\\n    const sumB = B.reduce(sum);\\n    \\n    // sum of both together has to be even for this to work\\n    // if ( (sumA + sumB) % 2 !== 0 ) return false;\\n    \\n    const mid = (sumA + sumB) / 2;\\n    \\n    const setB = new Set(B);      \\n    \\n    for (let i=0; i< A.length; i++ ) {     \\n        const current = A[i];\\n        const withoutCurrent = sumA - current;\\n        const searchedItem = mid - withoutCurrent;\\n                       \\n        if ( setB.has(searchedItem) &&  sumB - searchedItem + current === mid ) {\\n            return [ A[i], searchedItem ];\\n        }        \\n    }      \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236648,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int a_sum =0;\\n        int b_sum =0;\\n        int sum =0;\\n        int[] ans = new int[2];\\n        HashMap<Integer,Integer> b= new HashMap<Integer,Integer>();\\n        for(int i=0; i<A.length;i++){\\n           a_sum +=A[i];\\n        }\\n        for(int i=0; i<B.length;i++){\\n            b_sum +=B[i];\\n            b.put(B[i],i);\\n        }\\n        sum = (a_sum + b_sum)/2;\\n         for(int i=0; i<A.length;i++){\\n            int c = (sum-a_sum+A[i]); \\n             if(b.containsKey(c)){\\n                 ans[1]=c;\\n                 ans[0]=A[i];\\n                 break;\\n             }\\n         }\\n        \\n        \\n    return ans;}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int a_sum =0;\\n        int b_sum =0;\\n        int sum =0;\\n        int[] ans = new int[2];\\n        HashMap<Integer,Integer> b= new HashMap<Integer,Integer>();\\n        for(int i=0; i<A.length;i++){\\n           a_sum +=A[i];\\n        }\\n        for(int i=0; i<B.length;i++){\\n            b_sum +=B[i];\\n            b.put(B[i],i);\\n        }\\n        sum = (a_sum + b_sum)/2;\\n         for(int i=0; i<A.length;i++){\\n            int c = (sum-a_sum+A[i]); \\n             if(b.containsKey(c)){\\n                 ans[1]=c;\\n                 ans[0]=A[i];\\n                 break;\\n             }\\n         }\\n        \\n        \\n    return ans;}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234432,
                "title": "simple-python-with-explaination",
                "content": "The goal is to have both lists have to same sum after trading one item with each other. The value of the sum therefore has to be equal to the average of the two lists i.e [sum(listA) + sum(listB)] / 2 = (target sum value of each list individually)\\n\\nAfter finding the target sum, then take item out of listA and try to find the opposing value that satifies (listA - a) + b = target\\n\\n\\tdef fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sumA = 0\\n        sumB = 0\\n        setB = set()\\n        \\n        for a in A:\\n            sumA = sumA + a\\n        \\n        for b in B:\\n            sumB = sumB + b\\n            setB.add(b)\\n            \\n        target = (sumA + sumB)//2\\n        \\n        for a in A:\\n            need = (target - (sumA - a)) \\n\\n            if need in setB:\\n                return [a, need]",
                "solutionTags": [],
                "code": "The goal is to have both lists have to same sum after trading one item with each other. The value of the sum therefore has to be equal to the average of the two lists i.e [sum(listA) + sum(listB)] / 2 = (target sum value of each list individually)\\n\\nAfter finding the target sum, then take item out of listA and try to find the opposing value that satifies (listA - a) + b = target\\n\\n\\tdef fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sumA = 0\\n        sumB = 0\\n        setB = set()\\n        \\n        for a in A:\\n            sumA = sumA + a\\n        \\n        for b in B:\\n            sumB = sumB + b\\n            setB.add(b)\\n            \\n        target = (sumA + sumB)//2\\n        \\n        for a in A:\\n            need = (target - (sumA - a)) \\n\\n            if need in setB:\\n                return [a, need]",
                "codeTag": "Python3"
            },
            {
                "id": 175899,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun fairCandySwap(A: IntArray, B: IntArray): IntArray {\\n        val sumA = A.sum()\\n        val sumB = B.sum()\\n        val diff = (sumA - sumB) / 2\\n        val setB = B.toSet()\\n        val a = A.filter { setB.contains(it - diff) }.first()\\n        return intArrayOf(a, a - diff)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun fairCandySwap(A: IntArray, B: IntArray): IntArray {\\n        val sumA = A.sum()\\n        val sumB = B.sum()\\n        val diff = (sumA - sumB) / 2\\n        val setB = B.toSet()\\n        val a = A.filter { setB.contains(it - diff) }.first()\\n        return intArrayOf(a, a - diff)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170149,
                "title": "simple-scala-beats-100",
                "content": "Suppose the answer is `a` from A and `b` from B.\\nWe can get `A.sum - a + b = B.sum - b + a`, and then `b = a - (A.sum - B.sum)/2`.\\n```\\nobject Solution {\\n    def fairCandySwap(A: Array[Int], B: Array[Int]): Array[Int] = {\\n        val delta = A.sum - B.sum\\n        val bSet = B.toSet\\n        for (x <- A) {\\n            if (bSet contains (x - delta / 2))\\n                return Array(x, x - delta / 2)\\n        }\\n        Array() // no answer\\'s return \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def fairCandySwap(A: Array[Int], B: Array[Int]): Array[Int] = {\\n        val delta = A.sum - B.sum\\n        val bSet = B.toSet\\n        for (x <- A) {\\n            if (bSet contains (x - delta / 2))\\n                return Array(x, x - delta / 2)\\n        }\\n        Array() // no answer\\'s return \\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 169002,
                "title": "java-easy-solution-using-two-pointer",
                "content": "\\'\\'\\'\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0;\\n        int sumB = 0;\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        for (int i = 0; i <A.length ; i++) {\\n            sumA+=A[i];\\n        }\\n        for (int i = 0; i <B.length ; i++) {\\n            sumB+=B[i];\\n        }\\n        int dif = (sumA-sumB)/2;\\n        int i =0;int j =0;\\n        while (i<A.length||j<B.length){\\n            if(A[i]-B[j]<dif) i++;\\n            else if(A[i]-B[j]>dif) j++;\\n            else break;\\n        }\\n        return new int[]{A[i],B[j]};\\n    }\\n\\t\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0;\\n        int sumB = 0;\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        for (int i = 0; i <A.length ; i++) {\\n            sumA+=A[i];\\n        }\\n        for (int i = 0; i <B.length ; i++) {\\n            sumB+=B[i];\\n        }\\n        int dif = (sumA-sumB)/2;\\n        int i =0;int j =0;\\n        while (i<A.length||j<B.length){\\n            if(A[i]-B[j]<dif) i++;\\n            else if(A[i]-B[j]>dif) j++;\\n            else break;\\n        }\\n        return new int[]{A[i],B[j]};\\n    }\\n\\t\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 166309,
                "title": "c-readable-code",
                "content": "It is an easy level array algorithm. I wrote the algorithm but failed twice, I made the change to pass online judge. I like to share my C# code here. \\n\\n```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B)\\n        {\\n            if (A == null || B == null)\\n                return new int[0];\\n\\n            var sumA = A.Sum();\\n            var sumB = B.Sum();\\n\\n            if (sumA > sumB)\\n            {\\n                var result = FairCandySwap(B, A);\\n                return new int[] { result[1], result[0] };\\n            }\\n\\n            // A is small one\\n            var diff = sumB - sumA;\\n            var hashSet = new HashSet<int>(B);\\n\\n            foreach(var item in A)\\n            {\\n                var search = item + diff/2; \\n                if(hashSet.Contains(search))\\n                {\\n                    return new int[] { item, search };\\n                }\\n            }\\n\\n            return new int[0];\\n        }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B)\\n        {\\n            if (A == null || B == null)\\n                return new int[0];\\n\\n            var sumA = A.Sum();\\n            var sumB = B.Sum();\\n\\n            if (sumA > sumB)\\n            {\\n                var result = FairCandySwap(B, A);\\n                return new int[] { result[1], result[0] };\\n            }\\n\\n            // A is small one\\n            var diff = sumB - sumA;\\n            var hashSet = new HashSet<int>(B);\\n\\n            foreach(var item in A)\\n            {\\n                var search = item + diff/2; \\n                if(hashSet.Contains(search))\\n                {\\n                    return new int[] { item, search };\\n                }\\n            }\\n\\n            return new int[0];\\n        }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1629846,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1843504,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1567031,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1786853,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 2021303,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1952350,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1733578,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 2071103,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 2064271,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
        "question_content": "<p>Given a <code>m x n</code> binary matrix <code>mat</code>. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing <code>1</code> to <code>0</code> and <code>0</code> to <code>1</code>). A pair of cells are called neighbors if they share one edge.</p>\n\n<p>Return the <em>minimum number of steps</em> required to convert <code>mat</code> to a zero matrix or <code>-1</code> if you cannot.</p>\n\n<p>A <strong>binary matrix</strong> is a matrix with all cells equal to <code>0</code> or <code>1</code> only.</p>\n\n<p>A <strong>zero matrix</strong> is a matrix with all cells equal to <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/28/matrix.png\" style=\"width: 409px; height: 86px;\" />\n<pre>\n<strong>Input:</strong> mat = [[0,0],[0,1]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Given matrix is a zero matrix. We do not need to change it.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[1,0,0],[1,0,0]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> Given matrix cannot be a zero matrix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 3</code></li>\n\t<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 446342,
                "title": "java-python-3-convert-matrix-to-int-bfs-and-dfs-codes-w-explanation-comments-and-analysis",
                "content": "**Method 1: BFS**\\n\\n**Update**\\n**Q & A**\\n*Q1*: Could you please further explain about the logic of transferring the matrix to int?\\n`sum(cell << (i * n + j) for i, row in enumerate(mat) for j, cell in enumerate(row))`\\nI wonder how it works and why it works. \\n\\n*A1*: For Input: mat = [[0,0],[0,1]], map it to `0b1000`, that is, mapping mat[i][j] to the `(i * n + j)`th bit of an int. specifically,\\nmat[0][0] = 0, corresponds to `0th` bit, which is `0`;\\nmat[0][1] = 0, corresponds to `1st` bit, which is `0`;\\nmat[1][0] = 0, corresponds to `2nd` bit, which is `0`;\\nmat[1][1] = 1, corresponds to `3rd` bit, which is `1`;\\n\\nAfter mapping, **any operations on the binary cells of the `mat` are equals to the operations on the corresponding bits of the mapped int**. That\\'s why it works.\\n\\n*Q2*: Why do you use \"|\" to initialize the matrix and use \"^\" to calculate the next?\\n\\n*A2*: \\n1. When using `0 |= b`, where `b = 0 or 1`, the result is `b`; you can change it to\\n```\\nstart  += mat[i][j] << (i * n + j); \\n```\\n2. Use `next ^ 1 << k` (where k = i * n + j) to flip `kth` bit of `next`, which is equal to flipping the corresponding cell (i, j) in the matrix.\\n\\n*Q3*:  Why BFS solution is faster than DFS solution?\\n*A3*: BFS terminates once it has located the state with minimum flips, and it does NOT need to traverse all states; DFS need to traverse **ALL** states to get the required solution.\\n\\nTherefore, BFS is better than DFS in terms of time performance.\\n\\n*Q4*: Do all the states of the matrix will make up a tree?\\n*A4*: Yes. All the states are converted from the initial state by flipping bits.\\n**end of Q & A**\\n\\n----\\n1. Since `m < 3, n < 3` are given as constraints, there are at most `9` cells and an int has enough bits to store their values;\\n2. Map the `m * n` cells of the initial state of the matrix to the `0` ~ `m * n - 1`th bits of an int: `start`;\\n3. For each one of the `m * n` bits, flip it and its neighbors, then BFS to check if `0`, corresponding to an all `0`s matrix, is among the resulting states; if yes, return the minimum steps needed;\\n4. Use a Set to avoid duplicates;\\n5. If after the traversal of all states without finding `0`, return `-1`.\\n\\n```java\\n    private static final int[] d = {0, 0, 1, 0, -1, 0};\\n    public int minFlips(int[][] mat) {\\n        int start = 0, m = mat.length, n = mat[0].length;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                start |= mat[i][j] << (i * n + j); // convert the matrix to an int.\\n        Queue<Integer> q = new LinkedList<>(Arrays.asList(start));\\n        Set<Integer> seen = new HashSet<>(q);\\n        for (int step = 0; !q.isEmpty(); ++step) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                int cur = q.poll();\\n                if (cur == 0) // All 0s matrix found.\\n                    return step;\\n                for (int i = 0; i < m; ++i) { // traverse all m * n bits of cur.\\n                    for (int j = 0; j < n; ++j) {\\n                        int next = cur;\\n                        for (int k = 0; k < 5; ++k) { // flip the cell (i, j) and its neighbors.\\n                            int r = i + d[k], c = j + d[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n)\\n                                next ^= 1 << (r * n + c);\\n                        }\\n                        if (seen.add(next)) // seen it before ?\\n                            q.offer(next); // no, put it into the Queue.\\n                    }\\n                }    \\n            }\\n        }\\n        return -1; // impossible to get all 0s matrix.\\n    }\\n```\\n```python\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        start = sum(cell << (i * n + j) for i, row in enumerate(mat) for j, cell in enumerate(row))\\n        dq = collections.deque([(start, 0)])\\n        seen = {start}\\n        while dq:\\n            cur, step = dq.popleft()\\n            if not cur:\\n                return step\\n            for i in range(m):\\n                for j in range(n):\\n                    next = cur\\n                    for r, c in (i, j), (i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j):\\n                        if m > r >= 0 <= c < n:\\n                            next ^= 1 << (r * n + c)\\n                    if next not in seen:\\n                        seen.add(next)\\n                        dq.append((next, step + 1))\\n        return -1\\n```\\n**Analysis:**\\nTime: `O(m * n * 2 ^ (m * n))`, Space: `O(2 ^ (m * n))`.\\n\\n----\\n\\n**Method 2: DFS**\\n1. Use a Stack to store the status: current value and steps needed; Use a HashMap to update the status when encounering same value with less steps;\\n2. After exhaustion of all statuses, return the steps needed for `0`.\\n\\n```java\\n    private static final int[] d = {0, 0, 1, 0, -1, 0};\\n\\n    public int minFlips(int[][] mat) {\\n        int start = 0, m = mat.length, n = mat[0].length;\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                start |= mat[i][j] << i * n + j;\\n        Deque<int[]> stk = new ArrayDeque<>();\\n        stk.push(new int[]{start, 0});\\n        Map<Integer, Integer> seenSteps = new HashMap<>();\\n        seenSteps.put(start, 0);\\n        while (!stk.isEmpty()) {\\n            int[] a = stk.pop();\\n            int cur = a[0], step = a[1];\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    int next = cur;\\n                    for (int k = 0; k < 5; ++k) {\\n                        int r = i + d[k], c = j + d[k + 1];\\n                        if (r >= 0 && r < m && c >= 0 && c < n) {\\n                            next ^= 1 << r * n + c;\\n                        }\\n                    }\\n                    if (seenSteps.getOrDefault(next, Integer.MAX_VALUE) > step + 1) {\\n                        seenSteps.put(next, step + 1);\\n                        stk.push(new int[]{next, step + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return seenSteps.getOrDefault(0, -1);\\n    }\\n```\\n```python\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        start = sum(cell << i * n + j for i, row in enumerate(mat) for j, cell in enumerate(row))\\n        stack = [(start, 0)]\\n        seenSteps = {start : 0}\\n        while stack:\\n            cur, step = stack.pop()\\n            for i in range(m):\\n                for j in range(n):\\n                    next = cur\\n                    for r, c in (i, j), (i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j):\\n                        if m > r >= 0 <= c < n:\\n                            next ^= 1 << r * n + c\\n                    if seenSteps.get(next, float(\\'inf\\')) > step + 1:\\n                        seenSteps[next] = step + 1\\n                        stack.append((next, step + 1))\\n        return seenSteps.get(0, -1)\\n```\\n**Analysis:**\\nTime: `O(m * n * 2 ^ (m * n))`, Space: `O(2 ^ (m * n))`.",
                "solutionTags": [],
                "code": "```\\nstart  += mat[i][j] << (i * n + j); \\n```\n```java\\n    private static final int[] d = {0, 0, 1, 0, -1, 0};\\n    public int minFlips(int[][] mat) {\\n        int start = 0, m = mat.length, n = mat[0].length;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                start |= mat[i][j] << (i * n + j); // convert the matrix to an int.\\n        Queue<Integer> q = new LinkedList<>(Arrays.asList(start));\\n        Set<Integer> seen = new HashSet<>(q);\\n        for (int step = 0; !q.isEmpty(); ++step) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                int cur = q.poll();\\n                if (cur == 0) // All 0s matrix found.\\n                    return step;\\n                for (int i = 0; i < m; ++i) { // traverse all m * n bits of cur.\\n                    for (int j = 0; j < n; ++j) {\\n                        int next = cur;\\n                        for (int k = 0; k < 5; ++k) { // flip the cell (i, j) and its neighbors.\\n                            int r = i + d[k], c = j + d[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n)\\n                                next ^= 1 << (r * n + c);\\n                        }\\n                        if (seen.add(next)) // seen it before ?\\n                            q.offer(next); // no, put it into the Queue.\\n                    }\\n                }    \\n            }\\n        }\\n        return -1; // impossible to get all 0s matrix.\\n    }\\n```\n```python\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        start = sum(cell << (i * n + j) for i, row in enumerate(mat) for j, cell in enumerate(row))\\n        dq = collections.deque([(start, 0)])\\n        seen = {start}\\n        while dq:\\n            cur, step = dq.popleft()\\n            if not cur:\\n                return step\\n            for i in range(m):\\n                for j in range(n):\\n                    next = cur\\n                    for r, c in (i, j), (i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j):\\n                        if m > r >= 0 <= c < n:\\n                            next ^= 1 << (r * n + c)\\n                    if next not in seen:\\n                        seen.add(next)\\n                        dq.append((next, step + 1))\\n        return -1\\n```\n```java\\n    private static final int[] d = {0, 0, 1, 0, -1, 0};\\n\\n    public int minFlips(int[][] mat) {\\n        int start = 0, m = mat.length, n = mat[0].length;\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                start |= mat[i][j] << i * n + j;\\n        Deque<int[]> stk = new ArrayDeque<>();\\n        stk.push(new int[]{start, 0});\\n        Map<Integer, Integer> seenSteps = new HashMap<>();\\n        seenSteps.put(start, 0);\\n        while (!stk.isEmpty()) {\\n            int[] a = stk.pop();\\n            int cur = a[0], step = a[1];\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    int next = cur;\\n                    for (int k = 0; k < 5; ++k) {\\n                        int r = i + d[k], c = j + d[k + 1];\\n                        if (r >= 0 && r < m && c >= 0 && c < n) {\\n                            next ^= 1 << r * n + c;\\n                        }\\n                    }\\n                    if (seenSteps.getOrDefault(next, Integer.MAX_VALUE) > step + 1) {\\n                        seenSteps.put(next, step + 1);\\n                        stk.push(new int[]{next, step + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return seenSteps.getOrDefault(0, -1);\\n    }\\n```\n```python\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        start = sum(cell << i * n + j for i, row in enumerate(mat) for j, cell in enumerate(row))\\n        stack = [(start, 0)]\\n        seenSteps = {start : 0}\\n        while stack:\\n            cur, step = stack.pop()\\n            for i in range(m):\\n                for j in range(n):\\n                    next = cur\\n                    for r, c in (i, j), (i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j):\\n                        if m > r >= 0 <= c < n:\\n                            next ^= 1 << r * n + c\\n                    if seenSteps.get(next, float(\\'inf\\')) > step + 1:\\n                        seenSteps[next] = step + 1\\n                        stack.append((next, step + 1))\\n        return seenSteps.get(0, -1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 446306,
                "title": "c-bit-vector-regular-bfs",
                "content": "**Observation**\\nSince the problem constraints are so small we can easily come up with a BFS/DFS solution without worrying about TLE.\\nWe can improve upon the time by using bit vectors to store the state of the matrix. At each possible matrix state we can perform flip operation on any of the cells of the matrix and thus during BFS we need to consider this when traversing the neighbours of the nodes (This will be clearer when you go through the solution).\\n\\n**Note:** The solution may seem long as I have broken the operations down to different functons for readability. The solution however is very straightforward once you go through it. \\nAlso as pointed in one of the comments, you can make the code shorter by not creating the bit vectors but that would increase the runtime of the solution since each check and insertion on a hash set would be O(mn) as opposed to O(1) in this case.\\n\\n**Solution**\\n```c++\\nstatic vector<int> dirs={0,1,0,-1,0};\\nclass Solution {\\npublic:\\n    int m,n;                       //Stores #rows and #columns of the matrix.\\n    int createBitVec(vector<vector<int>>& mat)        //Creates bitVector using a matrix of `m` rows and `n` columns.\\n    {\\n        int bitvec=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                bitvec<<=1,bitvec|=mat[i][j];\\n        return bitvec;\\n    }\\n    int getFlip(int i,int j,int bitVec)       //Get flip of the matrix from position i,j and return it\\'s bit vector representation.\\n    {\\n        int x,y,pos=m*n-1-i*n-j;             //Get position in bit vector using i,j.\\n        bitVec^=1<<pos;\\n        for(int d=0;d<4;d++)\\n        {\\n            x=i+dirs[d],y=j+dirs[d+1];\\n            if(x>=0&&y>=0&&x<m&&y<n)\\n                pos=m*n-1-x*n-y,bitVec^=1<<pos;             //Get position in bit vector using x,y and flip it.\\n        }\\n        return bitVec;\\n    }\\n    int minFlips(vector<vector<int>>& mat) \\n    {\\n        m=mat.size(),n=mat[0].size();\\n        int bitvec=createBitVec(mat);                     //Bitvec stores initial state of the matrix\\n        if(!bitvec)\\n            return 0;\\n        queue<int> q;\\n        unordered_set<int> visited={bitvec};                      //To keep track of visited states.\\n        int distance=0,size;\\n        q.push(bitvec);\\t\\t\\t\\t\\t\\t//Push intial state to queue as starting state.\\n        while(!q.empty())                              //Regular BFS.\\n        {\\n            size=q.size();\\n            while(size--)\\n            {\\n                if(!q.front())\\n                    return distance;\\n                for(int i=0;i<m;i++)                   //Flip the matrix from every cell.\\n                    for(int j=0;j<n;j++)\\n                    {\\n                        bitvec=getFlip(i,j,q.front());  //Get bit vector for flip from position i,j.\\n                        if(!visited.count(bitvec))\\n                            q.push(bitvec),visited.insert(bitvec);\\n                    }\\n                q.pop();\\n            }\\n            distance++;\\n        }\\n        return -1;   \\n    }\\n};\\n```\\n**Complexity**\\nTime: `O(mn*2^mn)`.\\nSpace: `O(2^mn)`.\\n",
                "solutionTags": [],
                "code": "```c++\\nstatic vector<int> dirs={0,1,0,-1,0};\\nclass Solution {\\npublic:\\n    int m,n;                       //Stores #rows and #columns of the matrix.\\n    int createBitVec(vector<vector<int>>& mat)        //Creates bitVector using a matrix of `m` rows and `n` columns.\\n    {\\n        int bitvec=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                bitvec<<=1,bitvec|=mat[i][j];\\n        return bitvec;\\n    }\\n    int getFlip(int i,int j,int bitVec)       //Get flip of the matrix from position i,j and return it\\'s bit vector representation.\\n    {\\n        int x,y,pos=m*n-1-i*n-j;             //Get position in bit vector using i,j.\\n        bitVec^=1<<pos;\\n        for(int d=0;d<4;d++)\\n        {\\n            x=i+dirs[d],y=j+dirs[d+1];\\n            if(x>=0&&y>=0&&x<m&&y<n)\\n                pos=m*n-1-x*n-y,bitVec^=1<<pos;             //Get position in bit vector using x,y and flip it.\\n        }\\n        return bitVec;\\n    }\\n    int minFlips(vector<vector<int>>& mat) \\n    {\\n        m=mat.size(),n=mat[0].size();\\n        int bitvec=createBitVec(mat);                     //Bitvec stores initial state of the matrix\\n        if(!bitvec)\\n            return 0;\\n        queue<int> q;\\n        unordered_set<int> visited={bitvec};                      //To keep track of visited states.\\n        int distance=0,size;\\n        q.push(bitvec);\\t\\t\\t\\t\\t\\t//Push intial state to queue as starting state.\\n        while(!q.empty())                              //Regular BFS.\\n        {\\n            size=q.size();\\n            while(size--)\\n            {\\n                if(!q.front())\\n                    return distance;\\n                for(int i=0;i<m;i++)                   //Flip the matrix from every cell.\\n                    for(int j=0;j<n;j++)\\n                    {\\n                        bitvec=getFlip(i,j,q.front());  //Get bit vector for flip from position i,j.\\n                        if(!visited.count(bitvec))\\n                            q.push(bitvec),visited.insert(bitvec);\\n                    }\\n                q.pop();\\n            }\\n            distance++;\\n        }\\n        return -1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446712,
                "title": "c-easy-recursive-solution",
                "content": "- tip 1 :\\nIf you want to flip x, you can use **XOR**. \\nIf **x** is 0, **x ^ 1** is **1**.\\nIf **x** is 1, **x ^ 1** is **0**.\\nso, **x ^= 1** means **flip x**.\\n- tip 2\\nIf you select one cell and flip this cell with adjacent cell, matrix will be **changed**.\\nBut if you take this action **twice**(on the same cell), matrix will be **not changed**.\\n- tip 3\\nMatrix maximum size **9** in this problem.\\nIf you consider **all the case** in maxinum size matrix whether a cell flip or not, **512** cases exist.\\nSo bruteforce solution can be accepted without TL(Time Limit).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>>& flip(vector<vector<int>>& mat, int y, int x) {\\n        mat[y][x] ^= 1;\\n        if(y - 1 >= 0) mat[y-1][x] ^= 1;\\n        if(y + 1 <  n) mat[y+1][x] ^= 1;\\n        if(x - 1 >= 0) mat[y][x-1] ^= 1;\\n        if(x + 1 <  m) mat[y][x+1] ^= 1;\\n        return mat;\\n    }\\n\\n    bool isZeroMat(vector<vector<int>>& mat) {\\n        for(auto i = 0; i < n; ++i)\\n            for(auto j = 0; j < m; ++j)\\n                if(mat[i][j])\\n                    return false;\\n        return true;\\n    }\\n\\n    int FlipOrNotFlip(vector<vector<int>> mat, int y, int x) {\\n        if(x == m) y++, x = 0;\\n        if(y == n) return isZeroMat(mat) ? 0:10000;\\n\\n        auto ret1 = FlipOrNotFlip(mat, y, x+1);\\n        auto ret2 = FlipOrNotFlip(flip(mat, y, x), y, x+1) + 1;\\n        return min(ret1, ret2);\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size(), m = mat[0].size();\\n        auto ret = FlipOrNotFlip(mat, 0, 0);\\n        return (ret >= 10000 ? -1 : ret);\\n    }\\n};\\n```\\n\\nIn this code, ret1 means the count when (y, x) cell **not** flipped.\\n```\\nauto ret1 = FlipOrNotFlip(mat, y, x+1);\\n```\\n\\nIn this code, ret2 means the count when (y, x) cell flipped.\\n```\\nauto ret2 = FlipOrNotFlip(flip(mat, y, x), y, x+1) + 1;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>>& flip(vector<vector<int>>& mat, int y, int x) {\\n        mat[y][x] ^= 1;\\n        if(y - 1 >= 0) mat[y-1][x] ^= 1;\\n        if(y + 1 <  n) mat[y+1][x] ^= 1;\\n        if(x - 1 >= 0) mat[y][x-1] ^= 1;\\n        if(x + 1 <  m) mat[y][x+1] ^= 1;\\n        return mat;\\n    }\\n\\n    bool isZeroMat(vector<vector<int>>& mat) {\\n        for(auto i = 0; i < n; ++i)\\n            for(auto j = 0; j < m; ++j)\\n                if(mat[i][j])\\n                    return false;\\n        return true;\\n    }\\n\\n    int FlipOrNotFlip(vector<vector<int>> mat, int y, int x) {\\n        if(x == m) y++, x = 0;\\n        if(y == n) return isZeroMat(mat) ? 0:10000;\\n\\n        auto ret1 = FlipOrNotFlip(mat, y, x+1);\\n        auto ret2 = FlipOrNotFlip(flip(mat, y, x), y, x+1) + 1;\\n        return min(ret1, ret2);\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size(), m = mat[0].size();\\n        auto ret = FlipOrNotFlip(mat, 0, 0);\\n        return (ret >= 10000 ? -1 : ret);\\n    }\\n};\\n```\n```\\nauto ret1 = FlipOrNotFlip(mat, y, x+1);\\n```\n```\\nauto ret2 = FlipOrNotFlip(flip(mat, y, x), y, x+1) + 1;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446371,
                "title": "java-recursion-memoization-explained",
                "content": "##### Recursion + Memoization \\nIn this problem, we can think in a **brute manner first.**\\nWe will try to flip the element at each index of the 2D matrix once and let recursion get the answer for the flipped array.\\n* Now while doing this we need to take care that we don\\'t get trapped in a cycle (I have taken care of it by using a hashset).\\n* For eg consider the 2D matrix given below.\\n [1 0]\\n [1 0]\\n* Initially the call will be made by flipping the (0, 0) indexed element and its neighbors according to what is given in question.\\n* The 2D matrix changes to :-\\n [0 1]\\n [0 0]\\n* Now this configuration of the 2D array will make a recursive call by flipping the element at index (0, 0) and its neighbors. This will again give us an array configuration we had seen before in the same recursive branh (a cycle). \\n [1 0]\\n [1 0]\\n* To avoid cycles i have used a set.\\nSince the constraints of the problem are very weak, so using a string to memoize the state would not cost much on the runtime though concatenating strings is expensive.\\nIn this problem I have tried all possibilities of flipping all elements in a 2D array and made recursive calls to the resulting configurations. The recursive branch which brings the minimum no of steps will be a part of the solution. \\nIn the base case we check if all elements in the array are 0 or not.\\n(BFS is another way to come up with a solution in which you will be needing a visited array(to avoid cycle) and a queue).\\n```\\nclass Solution {\\n    \\n    public static boolean check(int[][] mat, int n, int m){\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(mat[i][j] == 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public static void flip(int[][] mat, int n, int m, int i, int j){\\n        mat[i][j] = mat[i][j] ^ 1;\\n        if(i - 1 >= 0) mat[i - 1][j] = mat[i - 1][j] ^ 1;\\n        if(j - 1 >= 0) mat[i][j - 1] = mat[i][j - 1] ^ 1;\\n        if(i + 1 < n) mat[i + 1][j] = mat[i + 1][j] ^ 1;\\n        if(j + 1 < m) mat[i][j + 1] = mat[i][j + 1] ^ 1;\\n    }\\n    \\n    public static int func(int[][] mat, int n, int m, HashSet<String> set, HashMap<String, Integer> dp){\\n        if(check(mat, n, m)) return 0;\\n        String t = \"\";\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                t += Integer.toString(mat[i][j]);\\n            }\\n        }\\n        \\n        if(dp.containsKey(t)) return dp.get(t);\\n        if(set.contains(t)) return Integer.MAX_VALUE;\\n        \\n        set.add(t);\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                flip(mat, n, m, i, j);\\n                int small = func(mat, n, m, set, dp);\\n                if(small != Integer.MAX_VALUE) min = Math.min(min, 1 + small);\\n                flip(mat, n, m, i, j);\\n            }\\n        }\\n        set.remove(t);\\n        dp.put(t, min);\\n        return min;\\n    }\\n    \\n    public int minFlips(int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        HashMap<String, Integer> dp = new HashMap<>();\\n        int ans = func(mat, n, m, new HashSet<>(), dp);\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public static boolean check(int[][] mat, int n, int m){\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(mat[i][j] == 1) return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 450538,
                "title": "java-regular-bfs-w-well-defined-class-simple-to-follow-with-comments",
                "content": "The idea is to use **BFS** by considering:\\n1. Initial matrix as source vertex.\\n2. Zero matrix as destination vertex. \\n3. For each vertex, the adjacent vertices would be all the matrices which can be generated by flipping once in the vertex. (There would be m\\\\*n such vertices for each matrix). \\n4. For marking a vertex as visited, we use a HashSet.\\n\\nThe following code covers the idea. I have defined a separate class Config to make things cleaner.\\n```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        // Instantiate initial config with zero steps\\n        Config init = new Config(mat, 0);\\n        if (init.isDone()) {\\n            return init.step;\\n        }\\n        \\n        // configs seen so far\\n        Set<String> visited = new HashSet<>();\\n        visited.add( init.toString());\\n        \\n        // BFS\\n        Queue<Config> q = new LinkedList<>();\\n        q.add(init);\\n        while(!q.isEmpty()) {\\n            Config c = q.poll();\\n            for(Config next: c.getNeighbours()) { // all configs generated by flipping once\\n                String nextStr = next.toString();\\n                if (!visited.contains(nextStr)) { // unvisited\\n                    if (next.isDone()) // reached solution\\n                        return next.step;\\n                    visited.add(nextStr);\\n                    q.add(next);\\n                }\\n            }\\n        }\\n        return -1; // not possible to reach destination from source\\n    } \\n    \\n    // Internal class to represent matrix config\\n    class Config {\\n        int[][] mat;\\n        int rows;\\n        int cols;\\n        int step; // number of steps taken to generate current config from initial matrix\\n        \\n        // constructor\\n        Config(int[][] mat, int step) {\\n            this.mat = mat;\\n            rows = mat.length;\\n            cols = mat[0].length;\\n            this.step = step;\\n        }\\n        \\n        // check if matrix is zero matrix\\n        private boolean isDone() {\\n            for (int i=0; i<mat.length; i++) {\\n                for (int val : mat[i])\\n                    if (val != 0)\\n                        return false;\\n            }\\n            return true;\\n        }\\n        \\n        // generate all (m*n) possible configs by flipping ONCE in current matrix\\n        public List<Config> getNeighbours() {\\n            List<Config> neighbours = new ArrayList<>();\\n            for (int i=0; i<rows; i++)\\n                for(int j=0; j<cols; j++)\\n                    neighbours.add(flip(i, j));\\n            return neighbours;\\n        }\\n        \\n        // next config by flipping value at (row,col) position (and neighbours)\\n        private Config flip(int row, int col) {\\n            // create a new copy of matrix\\n            int[][] next = new int[rows][cols];\\n            for (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\t\\tif ((i == row && j == col) || (i == row && j == col+1) || (i == row+1 && j == col) ||\\n\\t\\t\\t\\t\\t\\t(i == row && j == col-1) || (i == row-1 && j == col))\\n\\t\\t\\t\\t\\t\\tnext[i][j] = 1 - mat[i][j];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tnext[i][j] = mat[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n            // increment step by one in resultant matrix \\n            return new Config(next, step+1);\\n        }\\n\\t\\t\\n\\t\\t// generate string of 0s and 1s to represent matrix\\n        @Override\\n        public String toString() {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0; i<rows; i++) {\\n                for (int num: mat[i])\\n                    sb.append(num);\\n            }\\n            return sb.toString();\\n        }\\n    }  \\n}\\n```\\n**Time Complexity** - `O(2^(mn))`. The run time is bounded by `(mn)^k` where `k` is the number of steps to convert to zero matrix. This in turn is bounded by `2^(mn)` which is total possible configurations possible.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        // Instantiate initial config with zero steps\\n        Config init = new Config(mat, 0);\\n        if (init.isDone()) {\\n            return init.step;\\n        }\\n        \\n        // configs seen so far\\n        Set<String> visited = new HashSet<>();\\n        visited.add( init.toString());\\n        \\n        // BFS\\n        Queue<Config> q = new LinkedList<>();\\n        q.add(init);\\n        while(!q.isEmpty()) {\\n            Config c = q.poll();\\n            for(Config next: c.getNeighbours()) { // all configs generated by flipping once\\n                String nextStr = next.toString();\\n                if (!visited.contains(nextStr)) { // unvisited\\n                    if (next.isDone()) // reached solution\\n                        return next.step;\\n                    visited.add(nextStr);\\n                    q.add(next);\\n                }\\n            }\\n        }\\n        return -1; // not possible to reach destination from source\\n    } \\n    \\n    // Internal class to represent matrix config\\n    class Config {\\n        int[][] mat;\\n        int rows;\\n        int cols;\\n        int step; // number of steps taken to generate current config from initial matrix\\n        \\n        // constructor\\n        Config(int[][] mat, int step) {\\n            this.mat = mat;\\n            rows = mat.length;\\n            cols = mat[0].length;\\n            this.step = step;\\n        }\\n        \\n        // check if matrix is zero matrix\\n        private boolean isDone() {\\n            for (int i=0; i<mat.length; i++) {\\n                for (int val : mat[i])\\n                    if (val != 0)\\n                        return false;\\n            }\\n            return true;\\n        }\\n        \\n        // generate all (m*n) possible configs by flipping ONCE in current matrix\\n        public List<Config> getNeighbours() {\\n            List<Config> neighbours = new ArrayList<>();\\n            for (int i=0; i<rows; i++)\\n                for(int j=0; j<cols; j++)\\n                    neighbours.add(flip(i, j));\\n            return neighbours;\\n        }\\n        \\n        // next config by flipping value at (row,col) position (and neighbours)\\n        private Config flip(int row, int col) {\\n            // create a new copy of matrix\\n            int[][] next = new int[rows][cols];\\n            for (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\t\\tif ((i == row && j == col) || (i == row && j == col+1) || (i == row+1 && j == col) ||\\n\\t\\t\\t\\t\\t\\t(i == row && j == col-1) || (i == row-1 && j == col))\\n\\t\\t\\t\\t\\t\\tnext[i][j] = 1 - mat[i][j];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tnext[i][j] = mat[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n            // increment step by one in resultant matrix \\n            return new Config(next, step+1);\\n        }\\n\\t\\t\\n\\t\\t// generate string of 0s and 1s to represent matrix\\n        @Override\\n        public String toString() {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0; i<rows; i++) {\\n                for (int num: mat[i])\\n                    sb.append(num);\\n            }\\n            return sb.toString();\\n        }\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841955,
                "title": "python-bfs-two-important-observations",
                "content": "```html5\\n<b>Time Complexity: O(n&middot;2<sup>n</sup>) where n is the number of elements in mat\\nSpace Complexity: O(n&middot;2<sup>n</sup>)\\n```\\n\\n**Key observations:**\\n\\n**(#1) The order of the flips doesn\\'t matter.**\\n\\nHere is example 1 in the description performed in 3 different orders.\\nA solution is found in 3 steps regardless of the order of flips.  \\n```python\\n#start                        finish\\n[0, 0] -> [1, 0] -> [0, 1] -> [0, 0] # flipping positions 2, 1, 3\\n[0, 1]    [1, 0]    [1, 1]    [0, 0]\\n\\n[0, 0] -> [1, 1] -> [1, 0] -> [0, 0] # flipping positions 1, 2, 3\\n[0, 1]    [0, 0]    [1, 1]    [0, 0]\\n\\n[0, 0] -> [0, 1] -> [1, 1] -> [0, 0] # flipping positions 3, 2, 1\\n[0, 1]    [1, 0]    [0, 1]    [0, 0]\\n\\n[0, 1] # position numbers\\n[2, 3]\\n```\\n\\nThis is because the change in each location is just a superposition of all the flips that affect it.  \\n\\nBecause of this **we will never need to flip any position more than once**, since **2 flips = 0 flips** regardless of the order.  \\n\\n**(#2) The array will never be larger than 3 by 3.**\\n\\n<img src=\"https://assets.leetcode.com/users/images/888340cc-f867-431c-a321-8aa130fbc2d6_1599850596.3341503.png\" width=\"200px\">\\n\\nThis means all arrays will have beetween 1 and 9 (inclusive) elements.  Combine this information with the first observation and we find that there are at most **2<sup>9</sup> = 512** potential solutions to any array.  The 2<sup>9</sup> comes from 9 elements at most, and 2 choices for each element - we either flip the element or we don\\'t.  \\n\\nSince 512 is a relatively small space to search **we can try every possible combination of flipped positions.**  If a solution is not found then a solution does not exist.  \\n\\nIf a solution exists, **we can do better than trying every combination:**\\nSince we are looking for the \"***minimum** number of steps*\" to convert the matrix to all zeros, a **breadth first search approach makes the most sense** because we can stop searching as soon as any solution is found and know that it is the *minimum number of steps*.  \\n\\nThe code below shows a BFS solution.  It is annotated, but feel free to ask questions.   \\n\\n```python\\ndef minFlips(self, mat: List[List[int]]) -> int:\\n\\n\\tdef solved(arr: List[List[int]]) -> bool:\\n\\t\\t\\'\\'\\'Returns True if array consists of only zeros\\'\\'\\'\\n\\t\\treturn all(all(num == 0 for num in row) for row in arr)\\n\\n\\tR, C = len(mat), len(mat[0])       # (R) rows, (C) columns\\n\\tN = R*C                            # (N) number of elements in mat\\n\\tq = collections.deque([(0, mat)])  # (p) bit-masked list of locations flipped, (m) current matrix\\n\\tvisited = set()                    # Set of (p) that have already been tried\\n\\tbitmask = [1 << i for i in range(N)]\\n\\n\\twhile q:\\n\\n\\t\\tp, m = q.popleft()\\n\\n\\t\\t# 1. If the matrix consists of all 0, then a solution has been found, return the number of flips\\n\\t\\tif solved(m):\\n\\t\\t\\treturn bin(p).count(\\'1\\')\\n\\n\\t\\t# 2. Try flipping all locations (k) from location 0 to location N\\n\\t\\tfor k in range(N):\\n\\t\\t\\tmask = bitmask[k]\\n\\n\\t\\t\\t# 2.1 If the location was already flipped then so we wont flip it again (p&mask)\\n\\t\\t\\t#     If we flipped location 1 then 3, then don\\'t try flipping 3 then 1, it will have the same result (p|mask in visited)\\n\\t\\t\\tif (not p & mask) and (p|mask not in visited):\\n\\t\\t\\t\\tvisited.add(p | mask)\\n\\t\\t\\t\\tr, c = k//C, k%C\\n\\n\\t\\t\\t\\t# 2.2 Create a copy (temp_mat) of the current matrix (m) and flip location (row,col) and all it\\'s neighbors\\n\\t\\t\\t\\ttemp_mat = [row[:] for row in m]\\n\\t\\t\\t\\tfor i,j in ((r,c),(r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n\\t\\t\\t\\t\\tif (0 <= i < R) and (0 <= j < C):\\n\\t\\t\\t\\t\\t\\ttemp_mat[i][j] = 1 - temp_mat[i][j]\\n\\t\\t\\t\\tq.append((p|mask, temp_mat))\\n\\n\\treturn -1\\n```\\n<img src=\"https://assets.leetcode.com/users/images/0712bb7a-1efd-4bc3-a06a-b5cd9d0f773b_1599852865.5427718.png\" width=\"50%\">\\n\\n",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O(n&middot;2<sup>n</sup>) where n is the number of elements in mat\\nSpace Complexity: O(n&middot;2<sup>n</sup>)\\n```\n```python\\n#start                        finish\\n[0, 0] -> [1, 0] -> [0, 1] -> [0, 0] # flipping positions 2, 1, 3\\n[0, 1]    [1, 0]    [1, 1]    [0, 0]\\n\\n[0, 0] -> [1, 1] -> [1, 0] -> [0, 0] # flipping positions 1, 2, 3\\n[0, 1]    [0, 0]    [1, 1]    [0, 0]\\n\\n[0, 0] -> [0, 1] -> [1, 1] -> [0, 0] # flipping positions 3, 2, 1\\n[0, 1]    [1, 0]    [0, 1]    [0, 0]\\n\\n[0, 1] # position numbers\\n[2, 3]\\n```\n```python\\ndef minFlips(self, mat: List[List[int]]) -> int:\\n\\n\\tdef solved(arr: List[List[int]]) -> bool:\\n\\t\\t\\'\\'\\'Returns True if array consists of only zeros\\'\\'\\'\\n\\t\\treturn all(all(num == 0 for num in row) for row in arr)\\n\\n\\tR, C = len(mat), len(mat[0])       # (R) rows, (C) columns\\n\\tN = R*C                            # (N) number of elements in mat\\n\\tq = collections.deque([(0, mat)])  # (p) bit-masked list of locations flipped, (m) current matrix\\n\\tvisited = set()                    # Set of (p) that have already been tried\\n\\tbitmask = [1 << i for i in range(N)]\\n\\n\\twhile q:\\n\\n\\t\\tp, m = q.popleft()\\n\\n\\t\\t# 1. If the matrix consists of all 0, then a solution has been found, return the number of flips\\n\\t\\tif solved(m):\\n\\t\\t\\treturn bin(p).count(\\'1\\')\\n\\n\\t\\t# 2. Try flipping all locations (k) from location 0 to location N\\n\\t\\tfor k in range(N):\\n\\t\\t\\tmask = bitmask[k]\\n\\n\\t\\t\\t# 2.1 If the location was already flipped then so we wont flip it again (p&mask)\\n\\t\\t\\t#     If we flipped location 1 then 3, then don\\'t try flipping 3 then 1, it will have the same result (p|mask in visited)\\n\\t\\t\\tif (not p & mask) and (p|mask not in visited):\\n\\t\\t\\t\\tvisited.add(p | mask)\\n\\t\\t\\t\\tr, c = k//C, k%C\\n\\n\\t\\t\\t\\t# 2.2 Create a copy (temp_mat) of the current matrix (m) and flip location (row,col) and all it\\'s neighbors\\n\\t\\t\\t\\ttemp_mat = [row[:] for row in m]\\n\\t\\t\\t\\tfor i,j in ((r,c),(r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n\\t\\t\\t\\t\\tif (0 <= i < R) and (0 <= j < C):\\n\\t\\t\\t\\t\\t\\ttemp_mat[i][j] = 1 - temp_mat[i][j]\\n\\t\\t\\t\\tq.append((p|mask, temp_mat))\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 447012,
                "title": "o-2-mn",
                "content": "DFS row by row. For each cell in the *first* row, try both *without* and *with* flipping. Every later cell is forced by the cell directly above it (since no other remaining cells can still affect that cell above).\\n\\nIn other words, for each cell:\\n- If there\\'s no cell above or if the cell above is 0, then recurse without flipping.\\n- If there\\'s no cell above or if the cell above is 1, then recurse with flipping.\\n\\nThere are O(2<sup>n</sup>) ways for the first row, and each costs O(mn) to compute the rest of the matrix and check the last row.\\n\\nThis solves matrices of size 10&times;10 in about 250 ms (and this is Python, i.e., slow).\\n\\nCould be O(2<sup>min(m,n)</sup> mn) by transposing the matrix if it\\'s wider than tall.\\n\\n```\\ndef minFlips(self, mat: List[List[int]]) -> int:\\n    m, n = len(mat), len(mat[0])\\n    def flip(i, j):\\n        for i, j in (i, j), (i+1, j), (i-1, j), (i, j+1), (i, j-1):\\n            if 0 <= i < m and 0 <= j < n:\\n                mat[i][j] ^= 1\\n    possible = set()\\n    def dfs(i, j, flips):\\n        if j == n:\\n            i, j = i+1, 0\\n        if i == m:\\n            if not any(mat[-1]):\\n                possible.add(flips)\\n            return\\n        if i == 0 or mat[i-1][j] == 0:\\n            dfs(i, j+1, flips)\\n        if i == 0 or mat[i-1][j] == 1:\\n            flip(i, j)\\n            dfs(i, j+1, flips+1)\\n            flip(i, j)\\n    dfs(0, 0, 0)\\n    return min(possible, default=-1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef minFlips(self, mat: List[List[int]]) -> int:\\n    m, n = len(mat), len(mat[0])\\n    def flip(i, j):\\n        for i, j in (i, j), (i+1, j), (i-1, j), (i, j+1), (i, j-1):\\n            if 0 <= i < m and 0 <= j < n:\\n                mat[i][j] ^= 1\\n    possible = set()\\n    def dfs(i, j, flips):\\n        if j == n:\\n            i, j = i+1, 0\\n        if i == m:\\n            if not any(mat[-1]):\\n                possible.add(flips)\\n            return\\n        if i == 0 or mat[i-1][j] == 0:\\n            dfs(i, j+1, flips)\\n        if i == 0 or mat[i-1][j] == 1:\\n            flip(i, j)\\n            dfs(i, j+1, flips+1)\\n            flip(i, j)\\n    dfs(0, 0, 0)\\n    return min(possible, default=-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 446412,
                "title": "c-bfs-using-visited-set",
                "content": "Store the state in the queue as is (in matrix form) and run a regular BFS. Use a visited set to avoid adding an ancestor to a new level. Note: The visited map (or set) stores serialized matrices representing the states. \\n\\n```\\nclass Solution {\\npublic:\\n    string serialize(vector<vector<int>>& mat) {\\n        string s;\\n        int m = mat.size(), n = mat[0].size();\\n        for(int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                s = s + to_string(mat[i][j]);\\n            }\\n            s = s + \"#\";\\n        }\\n        return s;\\n    }\\n    \\n    bool good(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (mat[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void addNeighbors(vector<vector<int>>& mat, map<string, bool>& visited, queue<vector<vector<int>>>& myq) {\\n        int m = mat.size(), n = mat[0].size();\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                auto tmp = mat;\\n                tmp[i][j] = !tmp[i][j];\\n                if (i+1 < m) tmp[i+1][j] = !tmp[i+1][j];\\n                if (i-1 >= 0) tmp[i-1][j] = !tmp[i-1][j];\\n                if (j+1 < n) tmp[i][j+1] = !tmp[i][j+1];\\n                if (j-1 >= 0) tmp[i][j-1] = !tmp[i][j-1];\\n                \\n                auto s = serialize(tmp);\\n                if (!visited[s]) {\\n                    visited[s] = true;\\n                    myq.push(tmp);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        map<string, bool> visited;\\n        int level = 0;\\n        queue<vector<vector<int>>> myq;\\n        myq.push(mat);\\n        \\n        int m = mat.size(), n = mat[0].size();\\n        while (!myq.empty()) {\\n            int qs = myq.size();\\n            for (int i=0; i<qs; i++) {\\n                auto front = myq.front(); myq.pop();\\n                if (good(front)) return level;\\n                addNeighbors(front, visited, myq);\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string serialize(vector<vector<int>>& mat) {\\n        string s;\\n        int m = mat.size(), n = mat[0].size();\\n        for(int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                s = s + to_string(mat[i][j]);\\n            }\\n            s = s + \"#\";\\n        }\\n        return s;\\n    }\\n    \\n    bool good(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (mat[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void addNeighbors(vector<vector<int>>& mat, map<string, bool>& visited, queue<vector<vector<int>>>& myq) {\\n        int m = mat.size(), n = mat[0].size();\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                auto tmp = mat;\\n                tmp[i][j] = !tmp[i][j];\\n                if (i+1 < m) tmp[i+1][j] = !tmp[i+1][j];\\n                if (i-1 >= 0) tmp[i-1][j] = !tmp[i-1][j];\\n                if (j+1 < n) tmp[i][j+1] = !tmp[i][j+1];\\n                if (j-1 >= 0) tmp[i][j-1] = !tmp[i][j-1];\\n                \\n                auto s = serialize(tmp);\\n                if (!visited[s]) {\\n                    visited[s] = true;\\n                    myq.push(tmp);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        map<string, bool> visited;\\n        int level = 0;\\n        queue<vector<vector<int>>> myq;\\n        myq.push(mat);\\n        \\n        int m = mat.size(), n = mat[0].size();\\n        while (!myq.empty()) {\\n            int qs = myq.size();\\n            for (int i=0; i<qs; i++) {\\n                auto front = myq.front(); myq.pop();\\n                if (good(front)) return level;\\n                addNeighbors(front, visited, myq);\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446513,
                "title": "python-simple-and-short-dfs-with-cache",
                "content": "```\\ndef minFlips(self, mat: List[List[int]]) -> int:\\n        def flip(a):\\n            if all(x == 0  for v in a for x in v): return 0\\n            astr = str(list(chain.from_iterable(a)))\\n            if astr in cache: return cache[astr]\\n            if astr in visited: return math.inf\\n            visited.add(astr)\\n            res = math.inf\\n            for i in range(len(a)):\\n                for j in range(len(a[0])):\\n                    temp = deepcopy(a)\\n                    temp[i][j] ^= 1\\n                    for xoff, yoff in [(0,1), (0,-1), (1,0), (-1,0)]:\\n                        x,y = i+xoff, j+yoff\\n                        if 0 <= x < len(a) and 0 <= y < len(a[0]):\\n                            temp[x][y] ^= 1\\n                    res = min(res, 1+flip(temp))\\n            visited.remove(astr)\\n            cache[astr] = res\\n            return res\\n\\t\\tvisited, cache = set(), {}\\n        res = flip(mat)\\n        return -1 if res == math.inf else res\\n\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\ndef minFlips(self, mat: List[List[int]]) -> int:\\n        def flip(a):\\n            if all(x == 0  for v in a for x in v): return 0\\n            astr = str(list(chain.from_iterable(a)))\\n            if astr in cache: return cache[astr]\\n            if astr in visited: return math.inf\\n            visited.add(astr)\\n            res = math.inf\\n            for i in range(len(a)):\\n                for j in range(len(a[0])):\\n                    temp = deepcopy(a)\\n                    temp[i][j] ^= 1\\n                    for xoff, yoff in [(0,1), (0,-1), (1,0), (-1,0)]:\\n                        x,y = i+xoff, j+yoff\\n                        if 0 <= x < len(a) and 0 <= y < len(a[0]):\\n                            temp[x][y] ^= 1\\n                    res = min(res, 1+flip(temp))\\n            visited.remove(astr)\\n            cache[astr] = res\\n            return res\\n\\t\\tvisited, cache = set(), {}\\n        res = flip(mat)\\n        return -1 if res == math.inf else res\\n\\t\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 446456,
                "title": "beat-100-no-np-hard-o-nm-3-linear-algebra-solution",
                "content": "This is a simplified version of a google phone screen posted below:\\nhttps://leetcode.com/discuss/interview-question/422725/google-phone-screen-lights-out-puzzle/397815\\n\\nThe simplification here mainly refers to the fairly small constraints. With m and n both <=3, we can come up with brute force exponential solution. \\n\\nBut this is actually not a NP-hard problem in maths. Some good explanation can be found below:\\nhttps://www.youtube.com/watch?v=oCHCD_-nhg4\\nhttp://mathworld.wolfram.com/LightsOutPuzzle.html\\n\\nI will try to explain with a detailed example below.\\n\\nFirst, one observation is that the effect of click one cell n times is equivalently the same as click the cell n%2 times. So we either click a cell once or no click on that cell.\\n\\nNow assume initial board is:\\n0 0 \\n0 1 \\n\\nLet aij represents if we want to click cell (i,j), so aij is either 0 or 1. We can list the equations below:\\n1\\\\*a00 + 1\\\\*a01 + 1\\\\*a10 + 0\\\\*a11 = 0 (initial board[0][0])\\n1\\\\*a00 + 1\\\\*a01 + 0\\\\*a10 + 1\\\\*a11 = 0 (initial board[0][1])\\n1\\\\*a00 + 0\\\\*a01 + 1\\\\*a10 + 1\\\\*a11 = 0 (initial board[1][0])\\n0\\\\*a00 + 1\\\\*a01 + 1\\\\*a10 + 1\\\\*a11 = 1 (initial board[1][1])\\n\\nSolving the above equations, we will get values for each aij and the sum of all aij is our answer.\\n\\nIn linear algebra, the above equation is usually represented as:\\nC (Coefficient matrix)  =\\n1 1 1 0\\n1 1 0 1 \\n1 0 1 1\\n0 1 1 1\\n\\nA (Variable vectors) = [a00 a01 a10 a11]\\n\\nY (Y vectors) = [0 0 0 1]\\n\\nSo we have C * A\\u2019 = Y\\n\\nWe can use Gaussian elimination to solve the above equations:\\nPhase 1: convert to triangle matrix\\n<img width=\"177\" alt=\"Screen Shot 2019-12-07 at 8 48 57 PM\" src=\"https://user-images.githubusercontent.com/55373469/70384428-0cfaa200-1933-11ea-8757-f987b071b869.png\">\\n\\nPhase 2: convert to diagonal matrix\\n<img width=\"179\" alt=\"Screen Shot 2019-12-07 at 8 47 03 PM\" src=\"https://user-images.githubusercontent.com/55373469/70384405-d6bd2280-1932-11ea-8a1d-cea9f0027464.png\">\\n\\nSo we know that we need to click a01,a10,a11 and the minimum number of clicks needed is 3\\n\\n\\n\\nMy code is below, time comlexity is O((MN)^3), so should be able to handle some large M and N:\\n\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        board = mat\\n        M = len(board)\\n        N = len(board[0])\\n        coeff = [[0]*(N*M) for _ in range(M*N)]\\n        y = [0]*(N*M)\\n\\n        def zadd(coeff,y,i,j):\\n            for k in range(M*N):\\n                coeff[j][k] = (coeff[j][k] + coeff[i][k]) & 1\\n            y[j] = (y[i] + y[j]) & 1\\n\\n        if not board or not board[0]: return -1\\n\\n        ### Generate coeff matrix ###\\n        for i,row in enumerate(board):\\n            for j,n in enumerate(row):\\n                index=i*N+j\\n                if n==1: y[index] = 1\\n                for ii,jj in [(i-1,j),(i,j-1),(i,j),(i+1,j),(i,j+1)]:\\n                    if 0<=ii<M and 0<=jj<N:\\n                        coeff[index][ii*N+jj] = 1\\n\\n\\t\\t### Gaussian elimination phase 1 ###\\n        for i in range(M*N-1):\\n            for j in range(i,M*N):\\n                if coeff[j][i] == 1:\\n                    coeff[j],coeff[i] = coeff[i],coeff[j]\\n                    y[j],y[i] = y[i],y[j]\\n                    break\\n            else:\\n                continue\\n            for j in range(i+1,M*N):\\n                if coeff[j][i] == 1:\\n                    zadd(coeff,y,i,j)\\n\\t\\t\\n\\t\\t### Gaussian elimination phase 2 ###\\n        for i in range(M*N-1,0,-1):\\n            for j in range(i-1,-1,-1):\\n                if coeff[j][i] == 1:\\n                    zadd(coeff,y,i,j)\\n\\n\\t\\t### Validate and collect results ###\\n        clicks = []\\n        res = 0\\n        for i in range(M*N):\\n            if y[i]==1:\\n                if coeff[i][i]==1:\\n                    res += 1\\n                    clicks.append((i//N,i%N))\\n                else:\\n                    return -1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        board = mat\\n        M = len(board)\\n        N = len(board[0])\\n        coeff = [[0]*(N*M) for _ in range(M*N)]\\n        y = [0]*(N*M)\\n\\n        def zadd(coeff,y,i,j):\\n            for k in range(M*N):\\n                coeff[j][k] = (coeff[j][k] + coeff[i][k]) & 1\\n            y[j] = (y[i] + y[j]) & 1\\n\\n        if not board or not board[0]: return -1\\n\\n        ### Generate coeff matrix ###\\n        for i,row in enumerate(board):\\n            for j,n in enumerate(row):\\n                index=i*N+j\\n                if n==1: y[index] = 1\\n                for ii,jj in [(i-1,j),(i,j-1),(i,j),(i+1,j),(i,j+1)]:\\n                    if 0<=ii<M and 0<=jj<N:\\n                        coeff[index][ii*N+jj] = 1\\n\\n\\t\\t### Gaussian elimination phase 1 ###\\n        for i in range(M*N-1):\\n            for j in range(i,M*N):\\n                if coeff[j][i] == 1:\\n                    coeff[j],coeff[i] = coeff[i],coeff[j]\\n                    y[j],y[i] = y[i],y[j]\\n                    break\\n            else:\\n                continue\\n            for j in range(i+1,M*N):\\n                if coeff[j][i] == 1:\\n                    zadd(coeff,y,i,j)\\n\\t\\t\\n\\t\\t### Gaussian elimination phase 2 ###\\n        for i in range(M*N-1,0,-1):\\n            for j in range(i-1,-1,-1):\\n                if coeff[j][i] == 1:\\n                    zadd(coeff,y,i,j)\\n\\n\\t\\t### Validate and collect results ###\\n        clicks = []\\n        res = 0\\n        for i in range(M*N):\\n            if y[i]==1:\\n                if coeff[i][i]==1:\\n                    res += 1\\n                    clicks.append((i//N,i%N))\\n                else:\\n                    return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449143,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    map<vector<vector<int>>, int > visted;\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n     if(mat.empty()) return -1;     \\n        int steps = 0;\\n        queue<vector<vector<int> > > q;\\n        q.push(mat);\\n        visted[mat] = 1;\\n        while(!q.empty()) {\\n            int len = q.size();\\n            for(int i = 0; i < len; i++) {\\n                vector<vector<int> > v = q.front();\\n                q.pop();\\n                if(!check(v)) {\\n                    return steps;\\n                }\\n                for(int i = 0; i < v.size(); i++) {\\n                    for(int j = 0;j<v[0].size();j++) {\\n                        vector<vector<int> > temp = v;\\n                        changeMat(temp,i,j);\\n                        if(!visted[temp]) {\\n                            q.push(temp);\\n                            visted[temp] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    \\n    bool check(vector<vector<int>> mat) {\\n        int f = 0;\\n        for(int i = 0; i< mat.size();i++) {\\n            for(int j=0;j<mat[0].size();j++) {\\n                if(mat[i][j]) {\\n                    f=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return f;\\n    }\\n    \\n    void changeMat(vector<vector<int> > &v, int i,int j) {\\n        int n,m;\\n        n=v.size();\\n        m=v[0].size();\\n        \\n        v[i][j] = !v[i][j];\\n        \\n        if(i+1<n) {\\n            v[i+1][j] = !v[i+1][j];\\n        }\\n        \\n        if(j+1<m) {\\n             v[i][j+1] = !v[i][j+1];\\n        }\\n        \\n        if(i-1>=0) {\\n             v[i-1][j] = !v[i-1][j];\\n        }\\n        \\n        if(j-1>=0) {\\n             v[i][j-1] = !v[i][j-1];\\n        }\\n    }\\n };\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<vector<vector<int>>, int > visted;\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n     if(mat.empty()) return -1;     \\n        int steps = 0;\\n        queue<vector<vector<int> > > q;\\n        q.push(mat);\\n        visted[mat] = 1;\\n        while(!q.empty()) {\\n            int len = q.size();\\n            for(int i = 0; i < len; i++) {\\n                vector<vector<int> > v = q.front();\\n                q.pop();\\n                if(!check(v)) {\\n                    return steps;\\n                }\\n                for(int i = 0; i < v.size(); i++) {\\n                    for(int j = 0;j<v[0].size();j++) {\\n                        vector<vector<int> > temp = v;\\n                        changeMat(temp,i,j);\\n                        if(!visted[temp]) {\\n                            q.push(temp);\\n                            visted[temp] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    \\n    bool check(vector<vector<int>> mat) {\\n        int f = 0;\\n        for(int i = 0; i< mat.size();i++) {\\n            for(int j=0;j<mat[0].size();j++) {\\n                if(mat[i][j]) {\\n                    f=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return f;\\n    }\\n    \\n    void changeMat(vector<vector<int> > &v, int i,int j) {\\n        int n,m;\\n        n=v.size();\\n        m=v[0].size();\\n        \\n        v[i][j] = !v[i][j];\\n        \\n        if(i+1<n) {\\n            v[i+1][j] = !v[i+1][j];\\n        }\\n        \\n        if(j+1<m) {\\n             v[i][j+1] = !v[i][j+1];\\n        }\\n        \\n        if(i-1>=0) {\\n             v[i-1][j] = !v[i-1][j];\\n        }\\n        \\n        if(j-1>=0) {\\n             v[i][j-1] = !v[i][j-1];\\n        }\\n    }\\n };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446409,
                "title": "python-bfs-with-flatten-matrix",
                "content": "```\\nfrom copy import deepcopy\\nfrom collections import deque\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        #mat = [[1,0,0],[1,0,0]]\\n        m = len(mat)\\n        n = len(mat[0])\\n        flatten = []\\n        for x in mat:\\n            flatten.extend(x)\\n        stack = deque([(flatten,0)])\\n        visited = set(tuple(flatten))\\n        while stack:\\n            matrix,t = stack.popleft()\\n            if sum(matrix)==0:\\n                return t\\n            for i in range(m):\\n                for j in range(n):\\n                    temp = deepcopy(matrix)\\n                    for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1),(i,j)]:\\n                        if x>=0 and x<m and y>=0 and y<n:                            \\n                            temp[x*n+y] = 0 if temp[x*n+y] else 1\\n                    if tuple(temp) not in visited:\\n                        visited.add(tuple(temp))\\n                        stack.append((temp,t+1))\\n        return -1\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nfrom copy import deepcopy\\nfrom collections import deque\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        #mat = [[1,0,0],[1,0,0]]\\n        m = len(mat)\\n        n = len(mat[0])\\n        flatten = []\\n        for x in mat:\\n            flatten.extend(x)\\n        stack = deque([(flatten,0)])\\n        visited = set(tuple(flatten))\\n        while stack:\\n            matrix,t = stack.popleft()\\n            if sum(matrix)==0:\\n                return t\\n            for i in range(m):\\n                for j in range(n):\\n                    temp = deepcopy(matrix)\\n                    for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1),(i,j)]:\\n                        if x>=0 and x<m and y>=0 and y<n:                            \\n                            temp[x*n+y] = 0 if temp[x*n+y] else 1\\n                    if tuple(temp) not in visited:\\n                        visited.add(tuple(temp))\\n                        stack.append((temp,t+1))\\n        return -1\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 446856,
                "title": "readable-bfs-solution-similar-to-sliding-puzzle",
                "content": "I find this problem similar to [sliding puzzle](https://leetcode.com/problems/sliding-puzzle/description/)\\n```\\nprivate int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n    Set<String> set;\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length;\\n        if(m==0) {\\n            return 0;\\n        }\\n        int n = mat[0].length;\\n        StringBuilder result = new StringBuilder();\\n        for (int i=0;i<m*n;i++) {\\n            result.append(\"0\");\\n        }\\n        set = new HashSet<>();\\n        String hash = hash(mat);\\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(hash);\\n        set.add(hash);\\n        int ans=0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-->0) {\\n                String poll = queue.poll();\\n                if(poll.equals(result.toString())) {\\n                    return ans;\\n                }\\n                for (int i=0;i<poll.length();i++) {\\n                    int x = i/n;\\n                    int y = i%n;\\n                    Set<Integer> change = new HashSet<>(); // Set indicating which indexes to change.\\n                    change.add(i);\\n                    for (int k=0;k<4;k++) {\\n                        int nextX = x+dir[k][0];\\n                        int nextY = y+dir[k][1];\\n                        if(nextX>=0 && nextY>=0 && nextX<m && nextY<n) {\\n                            change.add(nextX*n+nextY);\\n                        }\\n                    }\\n                    StringBuilder sb = new StringBuilder();\\n                    for (int j=0;j<poll.length();j++) {\\n                        sb.append(!change.contains(j)?poll.charAt(j):(poll.charAt(j)==\\'1\\'?\\'0\\':\\'1\\'));\\n                    }\\n                    if(set.add(sb.toString())) {\\n                        queue.add(sb.toString());\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n\\n\\n    private String hash(int[][] mat) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int[] ints : mat) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                sb.append(ints[j]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate int[][] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n    Set<String> set;\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length;\\n        if(m==0) {\\n            return 0;\\n        }\\n        int n = mat[0].length;\\n        StringBuilder result = new StringBuilder();\\n        for (int i=0;i<m*n;i++) {\\n            result.append(\"0\");\\n        }\\n        set = new HashSet<>();\\n        String hash = hash(mat);\\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(hash);\\n        set.add(hash);\\n        int ans=0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-->0) {\\n                String poll = queue.poll();\\n                if(poll.equals(result.toString())) {\\n                    return ans;\\n                }\\n                for (int i=0;i<poll.length();i++) {\\n                    int x = i/n;\\n                    int y = i%n;\\n                    Set<Integer> change = new HashSet<>(); // Set indicating which indexes to change.\\n                    change.add(i);\\n                    for (int k=0;k<4;k++) {\\n                        int nextX = x+dir[k][0];\\n                        int nextY = y+dir[k][1];\\n                        if(nextX>=0 && nextY>=0 && nextX<m && nextY<n) {\\n                            change.add(nextX*n+nextY);\\n                        }\\n                    }\\n                    StringBuilder sb = new StringBuilder();\\n                    for (int j=0;j<poll.length();j++) {\\n                        sb.append(!change.contains(j)?poll.charAt(j):(poll.charAt(j)==\\'1\\'?\\'0\\':\\'1\\'));\\n                    }\\n                    if(set.add(sb.toString())) {\\n                        queue.add(sb.toString());\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n\\n\\n    private String hash(int[][] mat) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int[] ints : mat) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                sb.append(ints[j]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2836057,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>>& flip(vector<vector<int>>& mat, int y, int x) {\\n        mat[y][x] ^= 1;\\n        if(y - 1 >= 0) mat[y-1][x] ^= 1;\\n        if(y + 1 <  n) mat[y+1][x] ^= 1;\\n        if(x - 1 >= 0) mat[y][x-1] ^= 1;\\n        if(x + 1 <  m) mat[y][x+1] ^= 1;\\n        return mat;\\n    }\\n\\n    bool isZeroMat(vector<vector<int>>& mat) {\\n        for(auto i = 0; i < n; ++i)\\n            for(auto j = 0; j < m; ++j)\\n                if(mat[i][j])\\n                    return false;\\n        return true;\\n    }\\n\\n    int FlipOrNotFlip(vector<vector<int>> mat, int y, int x) {\\n        if(x == m) y++, x = 0;\\n        if(y == n) return isZeroMat(mat) ? 0:10000;\\n\\n        auto ret1 = FlipOrNotFlip(mat, y, x+1);\\n        auto ret2 = FlipOrNotFlip(flip(mat, y, x), y, x+1) + 1;\\n        return min(ret1, ret2);\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size(), m = mat[0].size();\\n        auto ret = FlipOrNotFlip(mat, 0, 0);\\n        return (ret >= 10000 ? -1 : ret);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>>& flip(vector<vector<int>>& mat, int y, int x) {\\n        mat[y][x] ^= 1;\\n        if(y - 1 >= 0) mat[y-1][x] ^= 1;\\n        if(y + 1 <  n) mat[y+1][x] ^= 1;\\n        if(x - 1 >= 0) mat[y][x-1] ^= 1;\\n        if(x + 1 <  m) mat[y][x+1] ^= 1;\\n        return mat;\\n    }\\n\\n    bool isZeroMat(vector<vector<int>>& mat) {\\n        for(auto i = 0; i < n; ++i)\\n            for(auto j = 0; j < m; ++j)\\n                if(mat[i][j])\\n                    return false;\\n        return true;\\n    }\\n\\n    int FlipOrNotFlip(vector<vector<int>> mat, int y, int x) {\\n        if(x == m) y++, x = 0;\\n        if(y == n) return isZeroMat(mat) ? 0:10000;\\n\\n        auto ret1 = FlipOrNotFlip(mat, y, x+1);\\n        auto ret2 = FlipOrNotFlip(flip(mat, y, x), y, x+1) + 1;\\n        return min(ret1, ret2);\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size(), m = mat[0].size();\\n        auto ret = FlipOrNotFlip(mat, 0, 0);\\n        return (ret >= 10000 ? -1 : ret);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440841,
                "title": "java-recursion-backtracking-memoisation",
                "content": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        return helper(mat, new int[512], new boolean[512]);\\n    }\\n    \\n    private int helper(int[][] mat, int[] dp, boolean[] visited){\\n        int n = mat.length, m = mat[0].length;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                sb.append(mat[i][j]);\\n\\t\\t\\t\\t\\n        int idx = Integer.parseInt(sb.toString(), 2);\\n        if(idx == 0)\\n            return 0;\\n\\t\\t\\t\\n        if(dp[idx] != 0)\\n            return dp[idx];\\n\\t\\t\\t\\n        if(visited[idx])\\n            return -1;\\n        \\n\\t\\tvisited[idx] = true;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                mat[i][j] = 1 - mat[i][j];\\n                if(i > 0)\\n                    mat[i - 1][j] = 1 - mat[i - 1][j];\\n                if(i < n - 1)\\n                    mat[i + 1][j] = 1 - mat[i + 1][j];\\n                if(j > 0)\\n                    mat[i][j - 1] = 1 - mat[i][j - 1];\\n                if(j < m - 1)\\n                    mat[i][j + 1] = 1 - mat[i][j + 1];\\n                \\n\\t\\t\\t\\tint x = helper(mat, dp, visited);\\n                if(x != -1)\\n                    min = Math.min(min, x);\\n                \\n\\t\\t\\t\\tmat[i][j] = 1 - mat[i][j];\\n                if(i > 0)\\n                    mat[i - 1][j] = 1 - mat[i - 1][j];\\n                if(i < n - 1)\\n                    mat[i + 1][j] = 1 - mat[i + 1][j];\\n                if(j > 0)\\n                    mat[i][j - 1] = 1 - mat[i][j - 1];\\n                if(j < m - 1)\\n                    mat[i][j + 1] = 1 - mat[i][j + 1];\\n            }\\n        }\\n\\t\\t\\n        visited[idx] = false;\\n        return dp[idx] = (min == Integer.MAX_VALUE ? -1 : min + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        return helper(mat, new int[512], new boolean[512]);\\n    }\\n    \\n    private int helper(int[][] mat, int[] dp, boolean[] visited){\\n        int n = mat.length, m = mat[0].length;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                sb.append(mat[i][j]);\\n\\t\\t\\t\\t\\n        int idx = Integer.parseInt(sb.toString(), 2);\\n        if(idx == 0)\\n            return 0;\\n\\t\\t\\t\\n        if(dp[idx] != 0)\\n            return dp[idx];\\n\\t\\t\\t\\n        if(visited[idx])\\n            return -1;\\n        \\n\\t\\tvisited[idx] = true;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                mat[i][j] = 1 - mat[i][j];\\n                if(i > 0)\\n                    mat[i - 1][j] = 1 - mat[i - 1][j];\\n                if(i < n - 1)\\n                    mat[i + 1][j] = 1 - mat[i + 1][j];\\n                if(j > 0)\\n                    mat[i][j - 1] = 1 - mat[i][j - 1];\\n                if(j < m - 1)\\n                    mat[i][j + 1] = 1 - mat[i][j + 1];\\n                \\n\\t\\t\\t\\tint x = helper(mat, dp, visited);\\n                if(x != -1)\\n                    min = Math.min(min, x);\\n                \\n\\t\\t\\t\\tmat[i][j] = 1 - mat[i][j];\\n                if(i > 0)\\n                    mat[i - 1][j] = 1 - mat[i - 1][j];\\n                if(i < n - 1)\\n                    mat[i + 1][j] = 1 - mat[i + 1][j];\\n                if(j > 0)\\n                    mat[i][j - 1] = 1 - mat[i][j - 1];\\n                if(j < m - 1)\\n                    mat[i][j + 1] = 1 - mat[i][j + 1];\\n            }\\n        }\\n\\t\\t\\n        visited[idx] = false;\\n        return dp[idx] = (min == Integer.MAX_VALUE ? -1 : min + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001973,
                "title": "java-3-approaches-bfs-2-ways-make-each-row-zero",
                "content": "**BFS (Type 1)**\\n\\nThink of it as a graph problem where each matrix represents a vertex and a flip operation on each of its indices represents an edge that connects this vertex to a different vertex corresponding to the transformed matrix. Since all edges have unit cost, we can use a BFS to find the shortest path from given matrix to desired matrix (i.e. zero matrix).\\n\\nSince inputs limits are pretty low, we can use an integer as a bitset to represent the whole matrix.\\n\\n```\\n// 2 ms. 74.36%\\nclass Solution {\\n    private static final int[][] dir = {{-1, 0}, {0, -1}, {0, 0}, {0, 1}, {1, 0}};\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, start = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                start |= mat[i][j] << (i * n + j);\\n            }\\n        }\\n        if(start == 0) return 0;\\n        boolean[] visited = new boolean[1 << (m * n)];\\n        Deque<Integer> Q = new LinkedList<>();\\n        visited[start] = true;\\n        Q.add(start);\\n        int res = 0;\\n        while(!Q.isEmpty()) {\\n            res++;\\n            int size = Q.size();\\n            while(size-- > 0) {\\n                int cur = Q.poll();\\n                for(int i = 0; i < m; i++) {\\n                    for(int j = 0; j < n; j++) {\\n                        int next = cur;\\n                        for(int[] d: dir) {\\n                            int x = i + d[0], y = j + d[1];\\n                            if(x >= 0 && x < m && y >= 0 && y < n) {\\n                                next ^= 1 << (x * n + y);\\n                            }\\n                        }\\n                        if(!visited[next]) {\\n                            if(next == 0) return res;\\n                            visited[next] = true;\\n                            Q.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nTime complexity: O(2<sup>mn</sup> mn)\\nSpace complexity: O(2<sup>mn</sup>)\\n\\n**BFS (Type 2)**\\n\\nNote that if we apply a flip operation to an index twice, the values get reverted to their old values (or equivalent to applying no operation). This means that we only need to apply 0 or 1 operation to every index in order to generate all possible matrices. So basically we can iterate over every possible subset of indices and apply 1 flip operation on them and return the subset of minimum size that leads to a zero matrix, if such subset exists. This hints a better way: directly iterate in the order of increasing subset sizes so that first subset that works is the answer. We can implement this idea using a BFS.\\n\\n```\\n// 6 ms. 29.74%\\nclass Solution {\\n    private static final int[][] dir = {{-1, 0}, {0, -1}, {0, 0}, {0, 1}, {1, 0}};\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, start = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                start |= mat[i][j] << (i * n + j);\\n            }\\n        }\\n        if(start == 0) return 0;\\n        int[] visited = new int[1 << (m * n)];\\n        Deque<Integer> Q = new LinkedList<>();\\n        visited[0] = start;\\n        Q.add(0);\\n        int res = 0;\\n        while(!Q.isEmpty()) {\\n            res++;\\n            int size = Q.size();\\n            while(size-- > 0) {\\n                int cur = Q.poll();\\n                for(int i = 0; i < m; i++) {\\n                    for(int j = 0; j < n; j++) {\\n                        if((cur & (1 << (i * n + j))) == 0) {\\n                            int next = cur | (1 << (i * n + j)), state = visited[cur];\\n                            for(int[] d: dir) {\\n                                int x = i + d[0], y = j + d[1];\\n                                if(x >= 0 && x < m && y >= 0 && y < n) {\\n                                    state ^= 1 << (x * n + y);\\n                                }\\n                            }\\n                            if(state == 0) return res;\\n                            visited[next] = state;\\n                            Q.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nTime complexity: O(2<sup>mn</sup> mn)\\nSpace complexity: O(2<sup>mn</sup>)\\n\\n**Make rows zero one by one**\\n\\nThis code is inspired from @StefanPochmann [post](https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/discuss/447012/O(2-mn)). Upvote that post :)\\nBasically the approach goes like this:\\nTry all subsets of first row indices and apply flip operations on them.\\nFor each arrangement of first row, all the cells from second row onwards have unique fate i.e. whether a flip operation should be applied on them or not.\\n\\n- If the previous row upper element i.e. A[i-1][j] is 0, then we can\\'t apply flip operation on current element i.e. A[i][j] (because otherwise there would be no way to make upper element 0 later).\\n- Similarly, if the previous row upper element i.e. A[i-1][j] is 1, then we must apply flip operation on current element i.e. A[i][j] (because otherwise there would be no way to make upper element 0 later).\\n\\nThis way, we iterate from second row to last row and make the previous row all 0\\'s. The only candidate that we need to check in the end for any remaining 1\\'s is the last row. If that is all 0\\'s too, then we\\'re done otherwise we ignore this branch.\\n\\nIf the number of rows are smaller than columns, then we can simply use this approach on column by column basis to reduce time complexity.\\n\\n```\\n// 0 ms. 100%\\nclass Solution {\\n    private static final int[][] dir = {{-1, 0}, {0, -1}, {0, 0}, {0, 1}, {1, 0}};\\n    private void flip(int[][] A, int i, int j) {\\n        for(int[] d: dir) {\\n            int x = i + d[0], y = j + d[1];\\n            if(x >= 0 && x < A.length && y >= 0 && y < A[0].length) {\\n                A[x][y] ^= 1;\\n            }\\n        }\\n    }\\n    private int helper(int[][] A, int col, int count) {\\n        if(col < A[0].length) {\\n            flip(A, 0, col);\\n            int res = helper(A, col + 1, count + 1);\\n            flip(A, 0, col);\\n            return Math.min(res, helper(A, col + 1, count));\\n        }\\n        int m = A.length, n = A[0].length;\\n        int[][] B = new int[m][];\\n        for(int i = 0; i < m; i++) {\\n            B[i] = A[i].clone();\\n        }\\n        for(int i = 1; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(B[i - 1][j] == 1) {\\n                    flip(B, i, j);\\n                    count++;\\n                }\\n            }\\n        }\\n        for(int j = 0; j < n; j++) {\\n            if(B[m - 1][j] == 1) return Integer.MAX_VALUE;\\n        }\\n        return count;\\n    }\\n    public int minFlips(int[][] mat) {\\n        int res = helper(mat, 0, 0);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```\\n\\nTime complexity: O(2<sup>min(m,n)</sup> mn)\\nSpace complexity: O(min(m,n)) [I am using additional array B (size = mn) in my code but it is not really needed. We can make this work with just n auxiliary space too.]",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 2 ms. 74.36%\\nclass Solution {\\n    private static final int[][] dir = {{-1, 0}, {0, -1}, {0, 0}, {0, 1}, {1, 0}};\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, start = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                start |= mat[i][j] << (i * n + j);\\n            }\\n        }\\n        if(start == 0) return 0;\\n        boolean[] visited = new boolean[1 << (m * n)];\\n        Deque<Integer> Q = new LinkedList<>();\\n        visited[start] = true;\\n        Q.add(start);\\n        int res = 0;\\n        while(!Q.isEmpty()) {\\n            res++;\\n            int size = Q.size();\\n            while(size-- > 0) {\\n                int cur = Q.poll();\\n                for(int i = 0; i < m; i++) {\\n                    for(int j = 0; j < n; j++) {\\n                        int next = cur;\\n                        for(int[] d: dir) {\\n                            int x = i + d[0], y = j + d[1];\\n                            if(x >= 0 && x < m && y >= 0 && y < n) {\\n                                next ^= 1 << (x * n + y);\\n                            }\\n                        }\\n                        if(!visited[next]) {\\n                            if(next == 0) return res;\\n                            visited[next] = true;\\n                            Q.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n// 6 ms. 29.74%\\nclass Solution {\\n    private static final int[][] dir = {{-1, 0}, {0, -1}, {0, 0}, {0, 1}, {1, 0}};\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, start = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                start |= mat[i][j] << (i * n + j);\\n            }\\n        }\\n        if(start == 0) return 0;\\n        int[] visited = new int[1 << (m * n)];\\n        Deque<Integer> Q = new LinkedList<>();\\n        visited[0] = start;\\n        Q.add(0);\\n        int res = 0;\\n        while(!Q.isEmpty()) {\\n            res++;\\n            int size = Q.size();\\n            while(size-- > 0) {\\n                int cur = Q.poll();\\n                for(int i = 0; i < m; i++) {\\n                    for(int j = 0; j < n; j++) {\\n                        if((cur & (1 << (i * n + j))) == 0) {\\n                            int next = cur | (1 << (i * n + j)), state = visited[cur];\\n                            for(int[] d: dir) {\\n                                int x = i + d[0], y = j + d[1];\\n                                if(x >= 0 && x < m && y >= 0 && y < n) {\\n                                    state ^= 1 << (x * n + y);\\n                                }\\n                            }\\n                            if(state == 0) return res;\\n                            visited[next] = state;\\n                            Q.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n// 0 ms. 100%\\nclass Solution {\\n    private static final int[][] dir = {{-1, 0}, {0, -1}, {0, 0}, {0, 1}, {1, 0}};\\n    private void flip(int[][] A, int i, int j) {\\n        for(int[] d: dir) {\\n            int x = i + d[0], y = j + d[1];\\n            if(x >= 0 && x < A.length && y >= 0 && y < A[0].length) {\\n                A[x][y] ^= 1;\\n            }\\n        }\\n    }\\n    private int helper(int[][] A, int col, int count) {\\n        if(col < A[0].length) {\\n            flip(A, 0, col);\\n            int res = helper(A, col + 1, count + 1);\\n            flip(A, 0, col);\\n            return Math.min(res, helper(A, col + 1, count));\\n        }\\n        int m = A.length, n = A[0].length;\\n        int[][] B = new int[m][];\\n        for(int i = 0; i < m; i++) {\\n            B[i] = A[i].clone();\\n        }\\n        for(int i = 1; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(B[i - 1][j] == 1) {\\n                    flip(B, i, j);\\n                    count++;\\n                }\\n            }\\n        }\\n        for(int j = 0; j < n; j++) {\\n            if(B[m - 1][j] == 1) return Integer.MAX_VALUE;\\n        }\\n        return count;\\n    }\\n    public int minFlips(int[][] mat) {\\n        int res = helper(mat, 0, 0);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251113,
                "title": "clean-and-concise-c-0ms-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dir[5] = {-1, 0, 1, 0, -1};\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size(), mask = 0;\\n        unordered_set<int>vis;\\n        queue<int>q;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                mask |= (mat[i][j] << (i*m+j));\\n\\n        q.push(mask);\\n        vis.insert(mask);\\n        int step = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int cur = q.front();\\n                q.pop();\\n                if(cur == 0) return step;\\n\\n                for(int i = 0; i < n; i++){\\n                    for(int j = 0; j < m; j++) {\\n                        int temp = cur;\\n                        temp ^= (1 << (i*m+j));\\n                        for(int k = 0; k < 4; k++){\\n                            int ni = i + dir[k];\\n                            int nj = j + dir[k+1];\\n                            if(min(ni, nj) >= 0 && ni < n && nj < m) {\\n                                temp ^= (1 << (ni*m + nj));\\n                            }\\n                        }\\n                        if(vis.find(temp) == vis.end()) {\\n                            vis.insert(temp);\\n                            q.push(temp);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[5] = {-1, 0, 1, 0, -1};\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size(), mask = 0;\\n        unordered_set<int>vis;\\n        queue<int>q;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                mask |= (mat[i][j] << (i*m+j));\\n\\n        q.push(mask);\\n        vis.insert(mask);\\n        int step = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int cur = q.front();\\n                q.pop();\\n                if(cur == 0) return step;\\n\\n                for(int i = 0; i < n; i++){\\n                    for(int j = 0; j < m; j++) {\\n                        int temp = cur;\\n                        temp ^= (1 << (i*m+j));\\n                        for(int k = 0; k < 4; k++){\\n                            int ni = i + dir[k];\\n                            int nj = j + dir[k+1];\\n                            if(min(ni, nj) >= 0 && ni < n && nj < m) {\\n                                temp ^= (1 << (ni*m + nj));\\n                            }\\n                        }\\n                        if(vis.find(temp) == vis.end()) {\\n                            vis.insert(temp);\\n                            q.push(temp);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624773,
                "title": "python-bfs-solution-with-explanations",
                "content": "When I saw the topic, I knew that this is a BFS problem since it is very similar to [127. Word Ladder](https://leetcode.com/problems/word-ladder/), [752. Open the Lock](https://leetcode.com/problems/open-the-lock/). However, I wasn\\'t able to think of a way to represent the grid efficiently.\\n\\n**Explanations**: To represent the grid efficiently, we need to use bit-manipulation. Therefore, we first set `start = 0 ` and each component in `mat`, we `or` with `start` [`start |= (mat[i][j] << (i * n + j))`].\\nAfter efficient grid representation, we can just fit BFS algorithm to this problem. When we poll out a previous state of number (`num`) out of queue, there are two scenario. Frist, `num = 0`, which means all cells in grid are 0, and we need to return `steps`. Second, `num` haven\\'t reached the final step yet. Hence, we need to flip every position in the grid to explore other candidates. [`def filp(enc, r, c)`]\\n\\n**Complexity**: Time (2^(M * N)), M is the row length of `mat` and N is col length of `mat`. Space (2^(M * N))\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        def filp(enc, r, c):\\n            for dx, dy in [(0, 0), (-1, 0), (0, 1), (1, 0), (0, -1)]:\\n                nr, nc = r + dx, c + dy\\n                if not(0 <= nr < m and 0 <= nc < n): continue\\n                enc ^= (1 << (nr * n + nc))\\n            return enc\\n        \\n        m, n = len(mat), len(mat[0])\\n        start = 0\\n        for i in range(m):\\n            for j in range(n):\\n                start |= (mat[i][j] << (i * n + j))\\n        q, seen = collections.deque([(start, 0)]), set([start])\\n        while q:\\n            num, steps = q.popleft()\\n            if num == 0: return steps\\n            for i in range(m):\\n                for j in range(n):\\n                    nxt = filp(num, i, j)\\n                    if nxt not in seen:\\n                        seen.add(nxt)\\n                        q.append((nxt, steps + 1))\\n        return -1\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        def filp(enc, r, c):\\n            for dx, dy in [(0, 0), (-1, 0), (0, 1), (1, 0), (0, -1)]:\\n                nr, nc = r + dx, c + dy\\n                if not(0 <= nr < m and 0 <= nc < n): continue\\n                enc ^= (1 << (nr * n + nc))\\n            return enc\\n        \\n        m, n = len(mat), len(mat[0])\\n        start = 0\\n        for i in range(m):\\n            for j in range(n):\\n                start |= (mat[i][j] << (i * n + j))\\n        q, seen = collections.deque([(start, 0)]), set([start])\\n        while q:\\n            num, steps = q.popleft()\\n            if num == 0: return steps\\n            for i in range(m):\\n                for j in range(n):\\n                    nxt = filp(num, i, j)\\n                    if nxt not in seen:\\n                        seen.add(nxt)\\n                        q.append((nxt, steps + 1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446466,
                "title": "javascript-bfs-with-explanation-2-approaches",
                "content": "# Version 1\\n```javascript\\n// I do realize that this isn\\'t using a real queue\\n// the real Queue class is implemented in version 2\\n\\n// This is similar to JSON.stringify but with a little less overhead\\n// you can substitute this function for simplicity with JSON.stringify\\nconst stringify = (matrix) => matrix.reduce((str, row) => `${str}-${row.join(\\'-\\')}`, \\'\\');\\n\\n// flips the element if it exists\\nconst flip = (matrix, row, col) => {\\n    if (matrix[row] && matrix[row][col] !== undefined) {\\n        matrix[row][col] = matrix[row][col] ? 0 : 1;\\n    }\\n}\\n\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n  // create a copy of the matrix with all elements as 0\\n  // stringify the copy so that it can be compared to another matrix in constant time\\n  const final = stringify(mat.map((row) => row.map(() => 0)));\\n  \\n  const seen = new Set();\\n  \\n  // queue holds the matrix and the number of flips for BFS\\n  const queue = [[mat, 0]];\\n  \\n  // directions are the delta from the current position in the format of [deltaRow, deltaCol]\\n  const directions = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];\\n  \\n  while (queue.length) {\\n    const [matrix, numFlips] = queue.shift();\\n\\t\\n\\t// stringify matrix so that you can see if it has been visited or is the final result in constant time;\\n    const strMatrix = stringify(matrix);\\n\\t\\n\\t// if all elements are 0, return the number of flips\\n    if (strMatrix === final) return numFlips;\\n\\t\\n\\t// skip this matrix if the matrix has already been attempted\\n    if (!seen.has(strMatrix)) {\\n      seen.add(strMatrix);\\n\\t  \\n\\t  // iterate through all elements in the matrix and flip each element;\\n      for (let i = 0; i < mat.length; i++) {\\n        for (let j = 0; j < mat[i].length; j++) {\\n\\t\\t\\n\\t\\t  // copy matrix\\n          const newMatrix = matrix.map((row) => [...row]) \\n\\t\\t  \\n\\t\\t  // flip each position corresponding to the current position\\n          directions.forEach(([down, right]) => flip(newMatrix, i + down, j + right))\\n\\t\\t  \\n\\t\\t  // push matrix into the queue\\n          queue.push([newMatrix, numFlips + 1]);\\n        }\\n      }\\n    }\\n  }\\n  \\n  // if no results were found return -1\\n  return -1;\\n};\\n```\\n# Version 2\\n```javascript\\n// this uses the the knowledge that you can easily make a copy of a deeply nested object with JSON.parse(JSON.stringify(object))\\n// with this knowledge we put the matrix through the JSON.stringify and enqueue this into the Queue\\n// since we will be enqueue-ing a string, we can allow the Queue to be smart and see if the matrix has been visited or not\\n// also since we are going to be dequeue-ing a stringified version of the matrix, we can JSON.parse this matrix and have a deeply copied matrix\\n\\n// stores reference to the queue and number of rows and columns\\nconst storeQueueAndValues = (queue, numRows, numCols) => {\\n  \\n  // directions holds the change in down and right movement from current position\\n  const directions = [[0,0], [0,1],[0,-1],[1,0],[-1,0]];\\n  \\n  // this will be returned so that we can call this function needing to pass only 2 arguments\\n  const flip = (strMatrix, numFlips) => {\\n   \\n   // iterate through the matrix\\n    for (let row = 0; row < numRows; row++) {\\n      for (let col = 0; col < numCols; col++) {\\n\\t  \\n\\t    // parses the string matrix to create a copy\\n        const matrix = JSON.parse(strMatrix);\\n\\t\\t\\n\\t\\t// flips elements corresponding to the current position\\n        for (let [down, right] of directions) {\\n          const [nextRow,nextCol] = [row + down, col + right];\\n          if (matrix[nextRow] && matrix[nextRow][nextCol] !== undefined) {\\n            matrix[nextRow][nextCol] = matrix[nextRow][nextCol] ? 0 : 1;\\n          }\\n        }\\n\\t\\t\\n\\t\\t// stringifies the matrix\\n        queue.enqueue({matrix: JSON.stringify(matrix), numFlips})\\n      }\\n    }\\n  }\\n  return flip\\n}\\n\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n  // make a copy with all elements as 0 and strigify to refence if we have hit the final matrix\\n  const final = JSON.stringify(mat.map(row => row.map(() => 0)));\\n  const queue = new Queue();\\n  \\n  // store the queue, number of rows and number of columns to have reference to in the function\\n  const flip = storeQueueAndValues(queue, mat.length, mat[0].length);\\n  queue.enqueue({ matrix: JSON.stringify(mat), numFlips: 0 });\\n  while (!queue.isEmpty()) {\\n  \\n    // since matrix is a stringified version of the matrix, we can compare it to the final stringified matrix in constant time\\n    let { matrix, numFlips } = queue.dequeue();\\n    if (matrix === final) return numFlips;\\n\\t\\n    // attempt to flip each position and neighboring positions in the matrix\\n    flip(matrix, numFlips + 1);\\n  }\\n  return -1;\\n};\\n\\n\\n// standard Queue class that only enqueues matrix that have not been seen before\\n// this can be referenced in the above function because of JavaScript hoisting\\nclass Queue {\\n    constructor() {\\n        this.head = new Node();\\n        this.tail = this.head;\\n        this.seen = new Set();\\n    }\\n\\n    isEmpty() {\\n      return this.head.next === null;\\n    }\\n\\n    enqueue(value) {\\n      const { matrix } = value;\\n      if (!this.seen.has(matrix)) {\\n        this.seen.add(matrix);\\n        this.tail.next = new Node(value);\\n        this.tail = this.tail.next;\\n      }\\n    }\\n\\n    dequeue() {\\n        const { next } = this.head;\\n        if (next === this.tail) this.tail = this.head;\\n        this.head.next = next.next;\\n        return next.value;\\n    }\\n}\\n\\nclass Node {\\n    constructor(value) {\\n        this.value = value;\\n        this.next = null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\n// I do realize that this isn\\'t using a real queue\\n// the real Queue class is implemented in version 2\\n\\n// This is similar to JSON.stringify but with a little less overhead\\n// you can substitute this function for simplicity with JSON.stringify\\nconst stringify = (matrix) => matrix.reduce((str, row) => `${str}-${row.join(\\'-\\')}`, \\'\\');\\n\\n// flips the element if it exists\\nconst flip = (matrix, row, col) => {\\n    if (matrix[row] && matrix[row][col] !== undefined) {\\n        matrix[row][col] = matrix[row][col] ? 0 : 1;\\n    }\\n}\\n\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n  // create a copy of the matrix with all elements as 0\\n  // stringify the copy so that it can be compared to another matrix in constant time\\n  const final = stringify(mat.map((row) => row.map(() => 0)));\\n  \\n  const seen = new Set();\\n  \\n  // queue holds the matrix and the number of flips for BFS\\n  const queue = [[mat, 0]];\\n  \\n  // directions are the delta from the current position in the format of [deltaRow, deltaCol]\\n  const directions = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];\\n  \\n  while (queue.length) {\\n    const [matrix, numFlips] = queue.shift();\\n\\t\\n\\t// stringify matrix so that you can see if it has been visited or is the final result in constant time;\\n    const strMatrix = stringify(matrix);\\n\\t\\n\\t// if all elements are 0, return the number of flips\\n    if (strMatrix === final) return numFlips;\\n\\t\\n\\t// skip this matrix if the matrix has already been attempted\\n    if (!seen.has(strMatrix)) {\\n      seen.add(strMatrix);\\n\\t  \\n\\t  // iterate through all elements in the matrix and flip each element;\\n      for (let i = 0; i < mat.length; i++) {\\n        for (let j = 0; j < mat[i].length; j++) {\\n\\t\\t\\n\\t\\t  // copy matrix\\n          const newMatrix = matrix.map((row) => [...row]) \\n\\t\\t  \\n\\t\\t  // flip each position corresponding to the current position\\n          directions.forEach(([down, right]) => flip(newMatrix, i + down, j + right))\\n\\t\\t  \\n\\t\\t  // push matrix into the queue\\n          queue.push([newMatrix, numFlips + 1]);\\n        }\\n      }\\n    }\\n  }\\n  \\n  // if no results were found return -1\\n  return -1;\\n};\\n```\n```javascript\\n// this uses the the knowledge that you can easily make a copy of a deeply nested object with JSON.parse(JSON.stringify(object))\\n// with this knowledge we put the matrix through the JSON.stringify and enqueue this into the Queue\\n// since we will be enqueue-ing a string, we can allow the Queue to be smart and see if the matrix has been visited or not\\n// also since we are going to be dequeue-ing a stringified version of the matrix, we can JSON.parse this matrix and have a deeply copied matrix\\n\\n// stores reference to the queue and number of rows and columns\\nconst storeQueueAndValues = (queue, numRows, numCols) => {\\n  \\n  // directions holds the change in down and right movement from current position\\n  const directions = [[0,0], [0,1],[0,-1],[1,0],[-1,0]];\\n  \\n  // this will be returned so that we can call this function needing to pass only 2 arguments\\n  const flip = (strMatrix, numFlips) => {\\n   \\n   // iterate through the matrix\\n    for (let row = 0; row < numRows; row++) {\\n      for (let col = 0; col < numCols; col++) {\\n\\t  \\n\\t    // parses the string matrix to create a copy\\n        const matrix = JSON.parse(strMatrix);\\n\\t\\t\\n\\t\\t// flips elements corresponding to the current position\\n        for (let [down, right] of directions) {\\n          const [nextRow,nextCol] = [row + down, col + right];\\n          if (matrix[nextRow] && matrix[nextRow][nextCol] !== undefined) {\\n            matrix[nextRow][nextCol] = matrix[nextRow][nextCol] ? 0 : 1;\\n          }\\n        }\\n\\t\\t\\n\\t\\t// stringifies the matrix\\n        queue.enqueue({matrix: JSON.stringify(matrix), numFlips})\\n      }\\n    }\\n  }\\n  return flip\\n}\\n\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n  // make a copy with all elements as 0 and strigify to refence if we have hit the final matrix\\n  const final = JSON.stringify(mat.map(row => row.map(() => 0)));\\n  const queue = new Queue();\\n  \\n  // store the queue, number of rows and number of columns to have reference to in the function\\n  const flip = storeQueueAndValues(queue, mat.length, mat[0].length);\\n  queue.enqueue({ matrix: JSON.stringify(mat), numFlips: 0 });\\n  while (!queue.isEmpty()) {\\n  \\n    // since matrix is a stringified version of the matrix, we can compare it to the final stringified matrix in constant time\\n    let { matrix, numFlips } = queue.dequeue();\\n    if (matrix === final) return numFlips;\\n\\t\\n    // attempt to flip each position and neighboring positions in the matrix\\n    flip(matrix, numFlips + 1);\\n  }\\n  return -1;\\n};\\n\\n\\n// standard Queue class that only enqueues matrix that have not been seen before\\n// this can be referenced in the above function because of JavaScript hoisting\\nclass Queue {\\n    constructor() {\\n        this.head = new Node();\\n        this.tail = this.head;\\n        this.seen = new Set();\\n    }\\n\\n    isEmpty() {\\n      return this.head.next === null;\\n    }\\n\\n    enqueue(value) {\\n      const { matrix } = value;\\n      if (!this.seen.has(matrix)) {\\n        this.seen.add(matrix);\\n        this.tail.next = new Node(value);\\n        this.tail = this.tail.next;\\n      }\\n    }\\n\\n    dequeue() {\\n        const { next } = this.head;\\n        if (next === this.tail) this.tail = this.head;\\n        this.head.next = next.next;\\n        return next.value;\\n    }\\n}\\n\\nclass Node {\\n    constructor(value) {\\n        this.value = value;\\n        this.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260434,
                "title": "c-backtracking-based-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int recurs(vector<vector<int>>&mat,vector<vector<int>>&visited)\\n    {\\n        int a=10000000;\\n        bool flag=true;\\n        \\n             for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j])\\n                {\\n                   flag=0; \\n                }\\n            }\\n        }\\n        \\n        if(flag)\\n            return 0;\\n        \\n        \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(!visited[i][j])\\n                {\\n\\n                    \\n                    visited[i][j]=1;\\n                    int b,c,d,e,f;\\n                    \\n                    if(i-1>=0)\\n                    {\\n                        b=mat[i-1][j];\\n                        mat[i-1][j]=1-mat[i-1][j]; \\n                    }\\n                     \\n                    if(j-1>=0)\\n                    {\\n                        c=mat[i][j-1];\\n                           mat[i][j-1]=1-mat[i][j-1];\\n                    }\\n                     \\n                    if(i+1<mat.size())\\n                    {\\n                        d= mat[i+1][j];\\n                         mat[i+1][j]=1-mat[i+1][j];\\n                    }\\n                       \\n                    if(j+1<mat[0].size())\\n                    {\\n                        e=mat[i][j+1];\\n                         mat[i][j+1]=1-mat[i][j+1];\\n                    }\\n                       \\n                    f=mat[i][j];\\n                    mat[i][j]=1-mat[i][j];\\n                    \\n                   a=min(a,1+recurs(mat,visited));\\n                    \\n                    \\n                    //------backtrack----------\\n                    \\n           \\n                    \\n                    if(i-1>=0)\\n                      mat[i-1][j]=b;\\n                    if(j-1>=0)\\n                        mat[i][j-1]=c;\\n                    if(i+1<mat.size())\\n                        mat[i+1][j]=d;\\n                    if(j+1<mat[0].size())\\n                        mat[i][j+1]=e;\\n                    mat[i][j]=f;\\n                    \\n                    \\n                    \\n                    visited[i][j]=0;\\n                    //------backtrack----------\\n                    \\n                }\\n            }\\n        }\\n        return a;\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        vector<vector<int>>visited(mat.size(),vector<int>(mat[0].size(),0));\\n        int a=recurs(mat,visited);\\n        \\n        if(a>=10000000)\\n            return -1;\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int recurs(vector<vector<int>>&mat,vector<vector<int>>&visited)\\n    {\\n        int a=10000000;\\n        bool flag=true;\\n        \\n             for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j])\\n                {\\n                   flag=0; \\n                }\\n            }\\n        }\\n        \\n        if(flag)\\n            return 0;\\n        \\n        \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(!visited[i][j])\\n                {\\n\\n                    \\n                    visited[i][j]=1;\\n                    int b,c,d,e,f;\\n                    \\n                    if(i-1>=0)\\n                    {\\n                        b=mat[i-1][j];\\n                        mat[i-1][j]=1-mat[i-1][j]; \\n                    }\\n                     \\n                    if(j-1>=0)\\n                    {\\n                        c=mat[i][j-1];\\n                           mat[i][j-1]=1-mat[i][j-1];\\n                    }\\n                     \\n                    if(i+1<mat.size())\\n                    {\\n                        d= mat[i+1][j];\\n                         mat[i+1][j]=1-mat[i+1][j];\\n                    }\\n                       \\n                    if(j+1<mat[0].size())\\n                    {\\n                        e=mat[i][j+1];\\n                         mat[i][j+1]=1-mat[i][j+1];\\n                    }\\n                       \\n                    f=mat[i][j];\\n                    mat[i][j]=1-mat[i][j];\\n                    \\n                   a=min(a,1+recurs(mat,visited));\\n                    \\n                    \\n                    //------backtrack----------\\n                    \\n           \\n                    \\n                    if(i-1>=0)\\n                      mat[i-1][j]=b;\\n                    if(j-1>=0)\\n                        mat[i][j-1]=c;\\n                    if(i+1<mat.size())\\n                        mat[i+1][j]=d;\\n                    if(j+1<mat[0].size())\\n                        mat[i][j+1]=e;\\n                    mat[i][j]=f;\\n                    \\n                    \\n                    \\n                    visited[i][j]=0;\\n                    //------backtrack----------\\n                    \\n                }\\n            }\\n        }\\n        return a;\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        vector<vector<int>>visited(mat.size(),vector<int>(mat[0].size(),0));\\n        int a=recurs(mat,visited);\\n        \\n        if(a>=10000000)\\n            return -1;\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600109,
                "title": "java-bfs-solution",
                "content": "```\\npublic int minFlips(int[][] mat) {\\n\\t\\tDeque<int[][]> queue = new LinkedList<>();\\n\\t\\tSet<String> visited = new HashSet<>();\\n\\t\\tif (isTarget(mat)) return 0;\\n\\t\\tqueue.offer(mat);\\n\\t\\tvisited.add(serialize(mat));\\n\\n\\t\\tint dist = 0;\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\twhile (size-- > 0) {\\n\\t\\t\\t\\tint[][] curMat = queue.poll();\\n\\t\\t\\t\\tfor (int[][] next : getNext(curMat)) {\\n\\t\\t\\t\\t\\tString strNext = serialize(next);\\n\\t\\t\\t\\t\\tif (!visited.contains(strNext)) {\\n\\t\\t\\t\\t\\t\\tif (isTarget(next)) return dist + 1;\\n\\t\\t\\t\\t\\t\\tqueue.offer(next);\\n\\t\\t\\t\\t\\t\\tvisited.add(strNext);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdist++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\n\\t}\\n\\n\\tprivate List<int[][]> getNext(int[][] mat) {\\n\\t\\tList<int[][]> list = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tlist.add(flip(mat, i, j));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n\\n\\tprivate int[][] flip(int[][] mat, int row, int col) {\\n\\t\\tint[][] next = new int[mat.length][mat[0].length];\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif ((i == row && j == col) || (i == row && j == col + 1) || (i == row + 1 && j == col) ||(i == row && j == col - 1) || (i == row - 1 && j == col))\\n\\t\\t\\t\\t\\tnext[i][j] = 1 - mat[i][j];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnext[i][j] = mat[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn next;\\n\\t}\\n\\n\\tprivate boolean isTarget(int[][] mat) {\\n\\t\\tfor (int[] row : mat) {\\n\\t\\t\\tfor (int n : row) {\\n\\t\\t\\t\\tif (n != 0) return false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n    \\n    private String serialize(int[][] board) {\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (int[] row : board) {\\n\\t\\t\\tfor (int n : row) {\\n\\t\\t\\t\\tsb.append(n);\\n\\t\\t\\t}\\n\\t\\t\\tsb.append(\\'.\\');\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minFlips(int[][] mat) {\\n\\t\\tDeque<int[][]> queue = new LinkedList<>();\\n\\t\\tSet<String> visited = new HashSet<>();\\n\\t\\tif (isTarget(mat)) return 0;\\n\\t\\tqueue.offer(mat);\\n\\t\\tvisited.add(serialize(mat));\\n\\n\\t\\tint dist = 0;\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\twhile (size-- > 0) {\\n\\t\\t\\t\\tint[][] curMat = queue.poll();\\n\\t\\t\\t\\tfor (int[][] next : getNext(curMat)) {\\n\\t\\t\\t\\t\\tString strNext = serialize(next);\\n\\t\\t\\t\\t\\tif (!visited.contains(strNext)) {\\n\\t\\t\\t\\t\\t\\tif (isTarget(next)) return dist + 1;\\n\\t\\t\\t\\t\\t\\tqueue.offer(next);\\n\\t\\t\\t\\t\\t\\tvisited.add(strNext);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdist++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\n\\t}\\n\\n\\tprivate List<int[][]> getNext(int[][] mat) {\\n\\t\\tList<int[][]> list = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tlist.add(flip(mat, i, j));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n\\n\\tprivate int[][] flip(int[][] mat, int row, int col) {\\n\\t\\tint[][] next = new int[mat.length][mat[0].length];\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif ((i == row && j == col) || (i == row && j == col + 1) || (i == row + 1 && j == col) ||(i == row && j == col - 1) || (i == row - 1 && j == col))\\n\\t\\t\\t\\t\\tnext[i][j] = 1 - mat[i][j];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnext[i][j] = mat[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn next;\\n\\t}\\n\\n\\tprivate boolean isTarget(int[][] mat) {\\n\\t\\tfor (int[] row : mat) {\\n\\t\\t\\tfor (int n : row) {\\n\\t\\t\\t\\tif (n != 0) return false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n    \\n    private String serialize(int[][] board) {\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (int[] row : board) {\\n\\t\\t\\tfor (int n : row) {\\n\\t\\t\\t\\tsb.append(n);\\n\\t\\t\\t}\\n\\t\\t\\tsb.append(\\'.\\');\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 446343,
                "title": "python-bfs",
                "content": "\\n```python\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        Flatten the matrix into a string, so we can use it as a state, then\\n        use BFS to find the target which would be \\'0000..000\\' depending on the size of the matrix.\\n        \\n        Nothing special. This problem is similar to 773. Sliding Puzzle.\\n        \\'\\'\\'\\n        rows, cols = len(mat), len(mat[0])\\n        initial = \\'\\'.join(str(cell) for row in mat for cell in row)\\n        target = \\'0\\' * (rows * cols)\\n        \\'\\'\\'bfs\\'\\'\\'\\n        flips = { \\'1\\': \\'0\\', \\'0\\': \\'1\\' }\\n        def flip(node, pos):\\n            node[pos] = flips[node[pos]]\\n            if pos % cols != 0:\\n                left = pos - 1\\n                node[left] = flips[node[left]]\\n            if pos % cols < cols - 1:\\n                right = pos + 1\\n                node[right] = flips[node[right]]\\n            if pos >= cols:\\n                top = pos - cols\\n                node[top] = flips[node[top]]\\n            if pos < (rows - 1) * cols:\\n                bottom = pos + cols\\n                node[bottom] = flips[node[bottom]]\\n        \\n        q = collections.deque([initial])\\n        steps = 0\\n        visited = set()\\n        while q:\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                if node == target:\\n                    return steps\\n                if node in visited:\\n                    continue\\n                visited.add(node)\\n                for i in range(len(node)):\\n                    nextNode = list(node)\\n                    flip(nextNode, i)\\n                    q.append(\\'\\'.join(nextNode))\\n            steps += 1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        Flatten the matrix into a string, so we can use it as a state, then\\n        use BFS to find the target which would be \\'0000..000\\' depending on the size of the matrix.\\n        \\n        Nothing special. This problem is similar to 773. Sliding Puzzle.\\n        \\'\\'\\'\\n        rows, cols = len(mat), len(mat[0])\\n        initial = \\'\\'.join(str(cell) for row in mat for cell in row)\\n        target = \\'0\\' * (rows * cols)\\n        \\'\\'\\'bfs\\'\\'\\'\\n        flips = { \\'1\\': \\'0\\', \\'0\\': \\'1\\' }\\n        def flip(node, pos):\\n            node[pos] = flips[node[pos]]\\n            if pos % cols != 0:\\n                left = pos - 1\\n                node[left] = flips[node[left]]\\n            if pos % cols < cols - 1:\\n                right = pos + 1\\n                node[right] = flips[node[right]]\\n            if pos >= cols:\\n                top = pos - cols\\n                node[top] = flips[node[top]]\\n            if pos < (rows - 1) * cols:\\n                bottom = pos + cols\\n                node[bottom] = flips[node[bottom]]\\n        \\n        q = collections.deque([initial])\\n        steps = 0\\n        visited = set()\\n        while q:\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                if node == target:\\n                    return steps\\n                if node in visited:\\n                    continue\\n                visited.add(node)\\n                for i in range(len(node)):\\n                    nextNode = list(node)\\n                    flip(nextNode, i)\\n                    q.append(\\'\\'.join(nextNode))\\n            steps += 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687730,
                "title": "c-simple-bfs-i-don-t-know-why-people-made-its-solution-difficult",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    void flip(int i, int j, vector<vector<int> > &adj) \\n    {\\n        int m = adj.size(), n = adj[0].size();\\n        \\n        adj[i][j] ^= 1;\\n        \\n        if(i-1 >= 0)\\n        {\\n            adj[i-1][j] ^= 1;\\n        }\\n        if(i+1 < m)\\n        {\\n            adj[i+1][j] ^= 1;\\n        }\\n        \\n        if(j-1>= 0)\\n        {\\n            adj[i][j-1] ^= 1;\\n        }\\n        if(j+1<n)\\n        {\\n            adj[i][j+1] ^= 1;\\n        }\\n    }\\n    \\n\\n    bool all_zero(vector<vector<int>>& mat)\\n    {\\n        \\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                if(mat[i][j] != 0)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    int minFlips(vector<vector<int>>& mat) \\n    {\\n       \\n        if(all_zero(mat))\\n        {\\n            return 0;\\n        }\\n        \\n        map<vector<vector<int>>,int> mp;\\n        \\n        queue<vector<vector<int>>> q;\\n        \\n        set<vector<vector<int>>> visited;\\n        \\n        q.push(mat);\\n        \\n        mp[mat] = 0;\\n        \\n        visited.insert(mat);\\n        \\n        while(!q.empty())\\n        {\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            auto adj = cur;\\n            \\n            for(int i=0; i<adj.size(); i++)\\n            {\\n                for(int j=0; j<adj[0].size(); j++)\\n                {\\n                    flip(i,j,adj);\\n                    \\n                    if(all_zero(adj))\\n                    {\\n                        return 1+mp[cur];\\n                    }\\n                    if(visited.find(adj) == visited.end())\\n                    {\\n                        visited.insert(adj);\\n                        mp[adj] = 1 + mp[cur];\\n                        q.push(adj);\\n                    }\\n                    \\n                    flip(i,j,adj);\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void flip(int i, int j, vector<vector<int> > &adj) \\n    {\\n        int m = adj.size(), n = adj[0].size();\\n        \\n        adj[i][j] ^= 1;\\n        \\n        if(i-1 >= 0)\\n        {\\n            adj[i-1][j] ^= 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976709,
                "title": "python-bfs-bit-operation",
                "content": "\\nclass Solution:\\n\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m,n=len(mat),len(mat[0])\\n        def convert_to_bit(M):\\n            start=0\\n            for i in range(m):\\n                for j in range(n):\\n                    start|=M[i][j]<<(i*n+j)\\n            return start\\n        init=convert_to_bit(mat)\\n        Q=deque([(0,init)])\\n        seen={init}\\n        while Q:\\n            step,curr=Q.popleft()\\n            if curr==0:\\n                return step\\n            for r in range(m):\\n                for c in range(n):\\n                    temp=curr\\n                    for dr,dc in [(0,0),(1,0),(-1,0),(0,1),(0,-1)]:\\n                        nr,nc=r+dr,c+dc\\n                        if 0<=nr<m and 0<=nc<n:\\n                            temp^=1<<(nr*n+nc)\\n                    if temp not in seen:\\n                        \\n                        Q.append((step+1,temp))\\n                        seen.add(temp)\\n                        \\n        return -1\\n                    \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m,n=len(mat),len(mat[0])\\n        def convert_to_bit(M):\\n            start=0\\n            for i in range(m):\\n                for j in range(n):\\n                    start|=M[i][j]<<(i*n+j)\\n            return start\\n        init=convert_to_bit(mat)\\n        Q=deque([(0,init)])\\n        seen={init}",
                "codeTag": "Java"
            },
            {
                "id": 815839,
                "title": "you-will-understand-me-pure-bfs-0ms-beat-100",
                "content": "cause m, n is so small, we encode matrix as an int, then just bfs ... if curr\\nstate is 0, return step\\n\\n```\\nint minFlips(vector<vector<int>>& mat) {\\n        const int M = mat.size();\\n        const int N = mat[0].size();\\n        const int B = M * N;\\n        int init = 0;\\n        for (int i = 0; i < M; ++i)\\n            for (int j = 0; j < N; ++j) {\\n                if (mat[i][j])\\n                    init |= (1 << (i * N + j));\\n            }\\n\\n        queue<int> que;\\n        vector<bool> visit(1 << B, false);\\n        que.push(init);\\n        visit[init] = true;\\n\\n        int step = 0;\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while (!que.empty()) {\\n            for (int sz = que.size(); sz > 0; --sz) {\\n                int front = que.front();\\n                que.pop();\\n\\n                if (front == 0)\\n                    return step;\\n\\n                for (int k = 0; k < B; ++k) {\\n                    int state = front;\\n                    state ^= (1 << k);\\n                    int i = k / N;\\n                    int j = k % N;\\n                    for (int d = 0; d < 4; ++d) {\\n                        int r = i + dir[d][0];\\n                        int c = j + dir[d][1];\\n                        if (0 <= r && r < M && 0 <= c && c < N)\\n                            state ^= (1 << (r * N + c));\\n                    }\\n\\n                    if (!visit[state]) {\\n                        que.push(state);\\n                        visit[state] = true;\\n                    }\\n                }\\n            }\\n\\n            ++step;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minFlips(vector<vector<int>>& mat) {\\n        const int M = mat.size();\\n        const int N = mat[0].size();\\n        const int B = M * N;\\n        int init = 0;\\n        for (int i = 0; i < M; ++i)\\n            for (int j = 0; j < N; ++j) {\\n                if (mat[i][j])\\n                    init |= (1 << (i * N + j));\\n            }\\n\\n        queue<int> que;\\n        vector<bool> visit(1 << B, false);\\n        que.push(init);\\n        visit[init] = true;\\n\\n        int step = 0;\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while (!que.empty()) {\\n            for (int sz = que.size(); sz > 0; --sz) {\\n                int front = que.front();\\n                que.pop();\\n\\n                if (front == 0)\\n                    return step;\\n\\n                for (int k = 0; k < B; ++k) {\\n                    int state = front;\\n                    state ^= (1 << k);\\n                    int i = k / N;\\n                    int j = k % N;\\n                    for (int d = 0; d < 4; ++d) {\\n                        int r = i + dir[d][0];\\n                        int c = j + dir[d][1];\\n                        if (0 <= r && r < M && 0 <= c && c < N)\\n                            state ^= (1 << (r * N + c));\\n                    }\\n\\n                    if (!visit[state]) {\\n                        que.push(state);\\n                        visit[state] = true;\\n                    }\\n                }\\n            }\\n\\n            ++step;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 448017,
                "title": "c-easy-o-n-2-m-solution-with-binary-operation",
                "content": "We could simply try to flip the first row with 2^m times of attempts. For each attempt to flip the first row, the minimum cost could be determined within O(n) times of binary operations.\\n\\n``` C++\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& input) {\\n        int n = input.size(), m = input[0].size();\\n        vector<int> mat(n + 2, 0);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                mat[i + 1] |= input[i][j] << j;\\n            }\\n        }\\n        int result = INT_MAX;\\n        for (int first_flip = 0, valid_space = (1 << m) - 1; first_flip <= valid_space; ++first_flip) {\\n            vector<int> buffer = mat;\\n            buffer[0] = first_flip;\\n            int current_count = 0;\\n            for (int i = 1; i <= n; ++i) {\\n                current_count += __builtin_popcount(buffer[i - 1]);\\n                buffer[i] ^= buffer[i - 1] ^ (buffer[i - 1] << 1 & valid_space) ^ (buffer[i - 1] >> 1);\\n                buffer[i + 1] ^= buffer[i - 1];\\n            }\\n            if (buffer[n] == 0) {\\n                result = min(result, current_count);\\n            }\\n        }\\n        return result == INT_MAX ? -1 : result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` C++\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& input) {\\n        int n = input.size(), m = input[0].size();\\n        vector<int> mat(n + 2, 0);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                mat[i + 1] |= input[i][j] << j;\\n            }\\n        }\\n        int result = INT_MAX;\\n        for (int first_flip = 0, valid_space = (1 << m) - 1; first_flip <= valid_space; ++first_flip) {\\n            vector<int> buffer = mat;\\n            buffer[0] = first_flip;\\n            int current_count = 0;\\n            for (int i = 1; i <= n; ++i) {\\n                current_count += __builtin_popcount(buffer[i - 1]);\\n                buffer[i] ^= buffer[i - 1] ^ (buffer[i - 1] << 1 & valid_space) ^ (buffer[i - 1] >> 1);\\n                buffer[i + 1] ^= buffer[i - 1];\\n            }\\n            if (buffer[n] == 0) {\\n                result = min(result, current_count);\\n            }\\n        }\\n        return result == INT_MAX ? -1 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446552,
                "title": "python-3-ten-lines-check-all-permutations",
                "content": "```\\nclass Solution:\\n    def minFlips(self, G: List[List[int]]) -> int:\\n        M, N = len(G), len(G[0])\\n        P = [(i,j) for i,j in itertools.product(range(M),range(N))]\\n        for n in range(M*N+1):\\n            for p in itertools.permutations(P,n):\\n                H = list(map(list,G))\\n                for (x,y) in p:\\n                    for (i,j) in (x,y-1),(x,y),(x,y+1),(x-1,y),(x+1,y):\\n                        if 0 <= i < M and 0 <= j < N: H[i][j] = 1 - H[i][j]\\n                if max(max(H)) == 0: return n\\n        return -1\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, G: List[List[int]]) -> int:\\n        M, N = len(G), len(G[0])\\n        P = [(i,j) for i,j in itertools.product(range(M),range(N))]\\n        for n in range(M*N+1):\\n            for p in itertools.permutations(P,n):\\n                H = list(map(list,G))\\n                for (x,y) in p:\\n                    for (i,j) in (x,y-1),(x,y),(x,y+1),(x-1,y),(x+1,y):\\n                        if 0 <= i < M and 0 <= j < N: H[i][j] = 1 - H[i][j]\\n                if max(max(H)) == 0: return n\\n        return -1\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 446367,
                "title": "java-brute-force-2ms",
                "content": "**Summary**: I find that sometimes, very efficient solutions are not necessary, especially not under such high time pressure as a contest. Therefore, in my consideration the important thing is to observe how many states there are to process, not do linear algebra when your solution is efficient enough. Doing a little notebook calculation leads to an observation.\\n\\n**Observation**: An interesting thing about this problem is we can note toggling a value twice causes the same effect as not touching it. So therefore we can exclude toggling a value more than once. Therefore, we simply try either toggling a value once or twice.\\n\\n```java\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        // Clicking on a cell twice is the same as not clicking on it at all! That means at max 2^9 way easy\\n        \\n        // Get the total number of cells\\n        int n = mat.length*mat[0].length;\\n\\t\\t// Set a minimum count\\n        int mincount = -1;\\n        \\n\\t\\t// For each state (represented by a binary integer) process state\\n        for(int a = 0; a < Math.pow(2, n); a++) {\\n            String binstr = Integer.toBinaryString(a);\\n            while(binstr.length() < n) {\\n                binstr = \"0\" + binstr;\\n            }\\n            // Do the puzzle\\n            // System.out.println(binstr);\\n            \\n            boolean broken = false;\\n            for(int i = 0; i < mat.length; i++) {\\n                for(int j = 0; j < mat[0].length; j++) {\\n                    int toggle = mat[i][j];\\n                    if(binstr.charAt(i*mat[0].length + j) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    if(j > 0 && binstr.charAt(i*mat[0].length + j - 1) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    if(j < mat[0].length - 1 && binstr.charAt(i*mat[0].length + j + 1) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    if(i > 0 && binstr.charAt((i - 1)*mat[0].length + j) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    if(i < mat.length - 1 && binstr.charAt((i + 1)*mat[0].length + j) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    \\n\\t\\t\\t\\t\\t// If not all zeroes break\\n                    if(toggle != 0) {\\n                        broken = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// If not broken see if less than minimum number of 1s (flips)\\n            if(!broken) {\\n                int sum = 0;\\n                for(int i = 0; i < binstr.length(); i++) {\\n                    if(binstr.charAt(i) == \\'1\\') {\\n                        sum ++;\\n                    }\\n                }\\n                if(mincount == -1) {\\n                    mincount = sum;\\n                }\\n                else {\\n                    mincount = Math.min(mincount, sum);\\n                }\\n            }\\n        }\\n        return mincount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```java\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        // Clicking on a cell twice is the same as not clicking on it at all! That means at max 2^9 way easy\\n        \\n        // Get the total number of cells\\n        int n = mat.length*mat[0].length;\\n\\t\\t// Set a minimum count\\n        int mincount = -1;\\n        \\n\\t\\t// For each state (represented by a binary integer) process state\\n        for(int a = 0; a < Math.pow(2, n); a++) {\\n            String binstr = Integer.toBinaryString(a);\\n            while(binstr.length() < n) {\\n                binstr = \"0\" + binstr;\\n            }\\n            // Do the puzzle\\n            // System.out.println(binstr);\\n            \\n            boolean broken = false;\\n            for(int i = 0; i < mat.length; i++) {\\n                for(int j = 0; j < mat[0].length; j++) {\\n                    int toggle = mat[i][j];\\n                    if(binstr.charAt(i*mat[0].length + j) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    if(j > 0 && binstr.charAt(i*mat[0].length + j - 1) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    if(j < mat[0].length - 1 && binstr.charAt(i*mat[0].length + j + 1) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    if(i > 0 && binstr.charAt((i - 1)*mat[0].length + j) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    if(i < mat.length - 1 && binstr.charAt((i + 1)*mat[0].length + j) == \\'1\\'){\\n                        toggle = toggle ^ 1;\\n                    }\\n                    \\n\\t\\t\\t\\t\\t// If not all zeroes break\\n                    if(toggle != 0) {\\n                        broken = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// If not broken see if less than minimum number of 1s (flips)\\n            if(!broken) {\\n                int sum = 0;\\n                for(int i = 0; i < binstr.length(); i++) {\\n                    if(binstr.charAt(i) == \\'1\\') {\\n                        sum ++;\\n                    }\\n                }\\n                if(mincount == -1) {\\n                    mincount = sum;\\n                }\\n                else {\\n                    mincount = Math.min(mincount, sum);\\n                }\\n            }\\n        }\\n        return mincount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463100,
                "title": "best-bfs-c",
                "content": "**UPVOTE IF U LIKE**\\n\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    bool chk(vector<vector<int>>& temp)\\n    {\\n        for(int i=0;i<temp.size();++i)\\n        {\\n            for(int j=0;j<temp[0].size();++j)\\n            {\\n                if(temp[i][j]==1)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        set<vector<vector<int>>> vis;\\n        queue<vector<vector<int>>> q;\\n        vis.insert(mat);\\n        q.push(mat);\\n        int move=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                if(chk(q.front()))\\n                {\\n                    return move;\\n                }\\n                for(int i=0;i<n;++i)\\n                {\\n                    for(int j=0;j<m;++j)\\n                    {\\n                        vector<vector<int>> t1=q.front();\\n                        t1[i][j]=1-t1[i][j];\\n                        for(int d=0;d<4;++d)\\n                        {\\n                            int ni=i+dx[d];\\n                            int nj=j+dy[d];\\n                            if(ni>=0 && nj>=0 && ni<n && nj<m)\\n                            {\\n                                t1[ni][nj]=1-t1[ni][nj];\\n                            }\\n                        }\\n                        if(vis.find(t1)==vis.end())\\n                        {\\n                            q.push(t1);\\n                            vis.insert(t1);\\n                        }\\n                    }\\n                }\\n                q.pop();\\n            }\\n            move++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    bool chk(vector<vector<int>>& temp)\\n    {\\n        for(int i=0;i<temp.size();++i)\\n        {\\n            for(int j=0;j<temp[0].size();++j)\\n            {\\n                if(temp[i][j]==1)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        set<vector<vector<int>>> vis;\\n        queue<vector<vector<int>>> q;\\n        vis.insert(mat);\\n        q.push(mat);\\n        int move=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                if(chk(q.front()))\\n                {\\n                    return move;\\n                }\\n                for(int i=0;i<n;++i)\\n                {\\n                    for(int j=0;j<m;++j)\\n                    {\\n                        vector<vector<int>> t1=q.front();\\n                        t1[i][j]=1-t1[i][j];\\n                        for(int d=0;d<4;++d)\\n                        {\\n                            int ni=i+dx[d];\\n                            int nj=j+dy[d];\\n                            if(ni>=0 && nj>=0 && ni<n && nj<m)\\n                            {\\n                                t1[ni][nj]=1-t1[ni][nj];\\n                            }\\n                        }\\n                        if(vis.find(t1)==vis.end())\\n                        {\\n                            q.push(t1);\\n                            vis.insert(t1);\\n                        }\\n                    }\\n                }\\n                q.pop();\\n            }\\n            move++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311616,
                "title": "c-100-88-44-0ms-6-9mb-o-n-2-2-n-2-o-2-n-2-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int f[9],w[5][2]={{0,0},{0,1},{0,-1},{1,0},{-1,0}},n,m,sz;\\n    char mp[1<<9];\\n    queue <pair<int,char>> q;\\n    int minFlips(vector<vector<int>>& mat) {\\n        n=mat.size();\\n        m=mat[0].size();\\n        int dec=0;\\n        for(int i=0;i<n;++i)\\n            for(int j=0;j<m;++j){\\n                dec*=2;\\n                dec+=mat[i][j];\\n                int fc=0;\\n                for(int k=0;k<5;++k)\\n                    if(i+w[k][0]>=0&&i+w[k][0]<n&&j+w[k][1]>=0&&j+w[k][1]<m)\\n                        fc|=(1<<((i+w[k][0])*m+j+w[k][1]));\\n                f[sz++]=fc;\\n            }\\n        q.push({dec,1});\\n        while(!mp[0]&&!q.empty()){\\n            pair<int,int> tp=q.front();\\n            if(tp.second>10)break;\\n            q.pop();\\n            if(mp[tp.first])continue;\\n            mp[tp.first]=tp.second;\\n            for(int i=0;i<sz;++i)\\n                q.push({tp.first^f[i],tp.second+1});\\n        }\\n        return mp[0]-1;\\n    }\\n};\\n```\\n1. Let {{0 1 0}{0 0 1}} -> 01001 = 8 + 1 = 9.\\nthan we can use n*m bits to represent all possible mat.\\n2. bfs is much faster than dfs.\\n3. All points that may be flipped can be dealt with first.\\n\\te.g. For the test capital {{0,0}{0,0}} , there are only 4 possible places for you to choose.\\n\\tAnd in any case, the calculation process of selecting those 4 positions will not change, it will only be a certain value of xor\\n4. The max answer in all case is less than 10 : )",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f[9],w[5][2]={{0,0},{0,1},{0,-1},{1,0},{-1,0}},n,m,sz;\\n    char mp[1<<9];\\n    queue <pair<int,char>> q;\\n    int minFlips(vector<vector<int>>& mat) {\\n        n=mat.size();\\n        m=mat[0].size();\\n        int dec=0;\\n        for(int i=0;i<n;++i)\\n            for(int j=0;j<m;++j){\\n                dec*=2;\\n                dec+=mat[i][j];\\n                int fc=0;\\n                for(int k=0;k<5;++k)\\n                    if(i+w[k][0]>=0&&i+w[k][0]<n&&j+w[k][1]>=0&&j+w[k][1]<m)\\n                        fc|=(1<<((i+w[k][0])*m+j+w[k][1]));\\n                f[sz++]=fc;\\n            }\\n        q.push({dec,1});\\n        while(!mp[0]&&!q.empty()){\\n            pair<int,int> tp=q.front();\\n            if(tp.second>10)break;\\n            q.pop();\\n            if(mp[tp.first])continue;\\n            mp[tp.first]=tp.second;\\n            for(int i=0;i<sz;++i)\\n                q.push({tp.first^f[i],tp.second+1});\\n        }\\n        return mp[0]-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279603,
                "title": "beats-100-java-intuitive-dfs-backtrack",
                "content": "Inspired by @wisest, we can simply try to go thru every possible option at every number, it is either we flip the number or we do a no-op. \\n\\nSo the DFS is very self-explaintory, by controling the DFS direction, we can prevent endless loop\\n\\n```\\nclass Solution {\\n    int m, n;\\n    int res = Integer.MAX_VALUE;\\n    \\n    public int minFlips(int[][] mat) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        dfs(mat, 0, 0, 0);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    \\n    private void dfs(int[][] mat, int x, int y, int step) {\\n        if (y == n) {\\n            dfs(mat, x + 1, 0, step);\\n            return;\\n        }\\n        \\n        if (x == m) {\\n            if (isZero(mat)) {\\n                res = Math.min(res, step);\\n            }\\n            return;\\n        }\\n        \\n        // flip the current position\\n        flip(mat, x, y);\\n        dfs(mat, x, y+1, step + 1);\\n        // backtrack\\n        flip(mat, x, y);\\n        \\n        // no - flip\\n        dfs(mat, x, y+1, step);\\n    }\\n    \\n    private void flip(int[][] mat, int x, int y) {\\n        mat[x][y] ^= 1;\\n        if (y-1 >=0)\\n            mat[x][y-1] ^= 1;\\n        if (y + 1 < n)\\n            mat[x][y+1] ^= 1;\\n        if (x-1 >= 0) \\n            mat[x-1][y] ^= 1;\\n        if (x+1 < m)\\n            mat[x+1][y] ^= 1;\\n    }\\n    \\n    private boolean isZero(int[][] mat) {\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                if (mat[i][j] != 0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int res = Integer.MAX_VALUE;\\n    \\n    public int minFlips(int[][] mat) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        dfs(mat, 0, 0, 0);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    \\n    private void dfs(int[][] mat, int x, int y, int step) {\\n        if (y == n) {\\n            dfs(mat, x + 1, 0, step);\\n            return;\\n        }\\n        \\n        if (x == m) {\\n            if (isZero(mat)) {\\n                res = Math.min(res, step);\\n            }\\n            return;\\n        }\\n        \\n        // flip the current position\\n        flip(mat, x, y);\\n        dfs(mat, x, y+1, step + 1);\\n        // backtrack\\n        flip(mat, x, y);\\n        \\n        // no - flip\\n        dfs(mat, x, y+1, step);\\n    }\\n    \\n    private void flip(int[][] mat, int x, int y) {\\n        mat[x][y] ^= 1;\\n        if (y-1 >=0)\\n            mat[x][y-1] ^= 1;\\n        if (y + 1 < n)\\n            mat[x][y+1] ^= 1;\\n        if (x-1 >= 0) \\n            mat[x-1][y] ^= 1;\\n        if (x+1 < m)\\n            mat[x+1][y] ^= 1;\\n    }\\n    \\n    private boolean isZero(int[][] mat) {\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                if (mat[i][j] != 0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220094,
                "title": "dfs-early-pruning-easy-to-understand-with-comments",
                "content": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n\\n        n_row, n_col, self.res, seen = len(mat), len(mat[0]), float(\\'inf\\'), {}\\n        \\n        def flip(row,col):\\n            for x, y in ((row,col),(row-1,col),(row+1,col),(row,col-1),(row,col+1)):\\n                if 0<=x<=n_row-1 and 0<=y<=n_col-1: mat[x][y] ^= 1\\n\\n        def dfs(steps,path):\\n            \\n            # if the the flipped cells (regardless of order) is seen or steps greater than any known solution, prune\\n            if tuple(sorted(path)) in seen or steps>=self.res:\\n                return\\n            else:\\n                # mark this sequence as seen so no repetition in other branches\\n                seen[tuple(sorted(path))]=True\\n            \\n            # if all digits are 0\\'s\\n            if all(all(not cell for cell in row) for row in mat):\\n                if self.res > steps:\\n                    self.res = steps\\n                return\\n                \\n            for i in range(n_row):\\n                for j in range(n_col):\\n                    # if the cell has not been flipped before\\n                    if (i,j) not in path:\\n                        # flip\\n                        flip(i,j)\\n                        dfs(steps+1,path+[(i,j)])\\n                        # reverse the operation for use in other branches\\n                        flip(i,j)\\n\\n        dfs(0,[])\\n        return self.res if self.res!=float(inf) else -1\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n\\n        n_row, n_col, self.res, seen = len(mat), len(mat[0]), float(\\'inf\\'), {}\\n        \\n        def flip(row,col):\\n            for x, y in ((row,col),(row-1,col),(row+1,col),(row,col-1),(row,col+1)):\\n                if 0<=x<=n_row-1 and 0<=y<=n_col-1: mat[x][y] ^= 1\\n\\n        def dfs(steps,path):\\n            \\n            # if the the flipped cells (regardless of order) is seen or steps greater than any known solution, prune\\n            if tuple(sorted(path)) in seen or steps>=self.res:\\n                return\\n            else:\\n                # mark this sequence as seen so no repetition in other branches\\n                seen[tuple(sorted(path))]=True\\n            \\n            # if all digits are 0\\'s\\n            if all(all(not cell for cell in row) for row in mat):\\n                if self.res > steps:\\n                    self.res = steps\\n                return\\n                \\n            for i in range(n_row):\\n                for j in range(n_col):\\n                    # if the cell has not been flipped before\\n                    if (i,j) not in path:\\n                        # flip\\n                        flip(i,j)\\n                        dfs(steps+1,path+[(i,j)])\\n                        # reverse the operation for use in other branches\\n                        flip(i,j)\\n\\n        dfs(0,[])\\n        return self.res if self.res!=float(inf) else -1\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732450,
                "title": "java-solution-with-top-down-dp-bit-mask",
                "content": "```\\nclass Solution {\\n    Integer[] dp;\\n    public int minFlips(int[][] mat) {\\n        dp = new Integer[513];\\n        int mask = getmask(mat);\\n        return dfs(mat, mask, 0, 0);\\n    }\\n    \\n    public int dfs(int[][] mat, int mask, int x, int y)\\n    {\\n        if(mask==0)return 0;\\n        if(x == mat.length){\\n            return -1;\\n        }\\n        \\n        if(y == mat[0].length)\\n        {\\n            return dfs(mat, mask, x+1, 0);\\n        }\\n        \\n        if(dp[mask]!=null)\\n        {\\n            return dp[mask];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        int ans1 = dfs(mat, getmask(mat), x, y+1);\\n        flip(mat, x, y);\\n        int ans2 = dfs(mat, getmask(mat), x, y+1);\\n        flip(mat, x, y);\\n        \\n        if(ans1!=-1)\\n        {\\n            res = Math.min(res, ans1);\\n        }\\n        \\n        if(ans2!=-1)\\n        {\\n            res = Math.min(res, ans2 + 1);\\n        }\\n        \\n        if(res==Integer.MAX_VALUE)res = -1;\\n        dp[mask] = res;\\n        return res;\\n    }\\n    \\n    public int getmask(int[][] mat)\\n    {\\n        int m = mat.length, n = mat[0].length;\\n        int mask = 0;\\n        int ind = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    mask |= (1 << (i * n + j));\\n                }\\n            }\\n        }\\n        \\n        return mask;\\n    }\\n    \\n    public void flip(int[][] mat, int i, int j)\\n    {\\n        int m = mat.length, n = mat[0].length;\\n        mat[i][j] ^= 1;\\n        if(i+1 < m)\\n        {\\n            mat[i+1][j] ^= 1;\\n        }\\n        \\n        if(i-1 >= 0)\\n        {\\n            mat[i-1][j] ^= 1;\\n        }\\n        \\n        if(j-1 >= 0)\\n        {\\n            mat[i][j-1] ^= 1;\\n        }\\n        \\n        if(j+1 < n)\\n        {\\n            mat[i][j+1] ^= 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[] dp;\\n    public int minFlips(int[][] mat) {\\n        dp = new Integer[513];\\n        int mask = getmask(mat);\\n        return dfs(mat, mask, 0, 0);\\n    }\\n    \\n    public int dfs(int[][] mat, int mask, int x, int y)\\n    {\\n        if(mask==0)return 0;\\n        if(x == mat.length){\\n            return -1;\\n        }\\n        \\n        if(y == mat[0].length)\\n        {\\n            return dfs(mat, mask, x+1, 0);\\n        }\\n        \\n        if(dp[mask]!=null)\\n        {\\n            return dp[mask];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        int ans1 = dfs(mat, getmask(mat), x, y+1);\\n        flip(mat, x, y);\\n        int ans2 = dfs(mat, getmask(mat), x, y+1);\\n        flip(mat, x, y);\\n        \\n        if(ans1!=-1)\\n        {\\n            res = Math.min(res, ans1);\\n        }\\n        \\n        if(ans2!=-1)\\n        {\\n            res = Math.min(res, ans2 + 1);\\n        }\\n        \\n        if(res==Integer.MAX_VALUE)res = -1;\\n        dp[mask] = res;\\n        return res;\\n    }\\n    \\n    public int getmask(int[][] mat)\\n    {\\n        int m = mat.length, n = mat[0].length;\\n        int mask = 0;\\n        int ind = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    mask |= (1 << (i * n + j));\\n                }\\n            }\\n        }\\n        \\n        return mask;\\n    }\\n    \\n    public void flip(int[][] mat, int i, int j)\\n    {\\n        int m = mat.length, n = mat[0].length;\\n        mat[i][j] ^= 1;\\n        if(i+1 < m)\\n        {\\n            mat[i+1][j] ^= 1;\\n        }\\n        \\n        if(i-1 >= 0)\\n        {\\n            mat[i-1][j] ^= 1;\\n        }\\n        \\n        if(j-1 >= 0)\\n        {\\n            mat[i][j-1] ^= 1;\\n        }\\n        \\n        if(j+1 < n)\\n        {\\n            mat[i][j+1] ^= 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724944,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int rSize, cSize;\\n    int oneCnt;\\n    int flipCnt;\\n    int res;\\n    \\n    int dir[5] = {0, 1, 0, -1, 0};\\n    \\n    void flip(int r, int c, vector<vector<int>> &mat) {\\n        if (r < 0 || c < 0 || r >= rSize || c >= cSize) return;\\n        oneCnt += mat[r][c] ? -1 : 1;\\n        mat[r][c] = !mat[r][c];\\n    }\\n    \\n    void flipSelfAdj(int r, int c, vector<vector<int>> &mat) {\\n        flip(r, c, mat);\\n        for (int i = 0; i < 4; i++) {\\n            flip(r + dir[i], c + dir[i + 1], mat);\\n        }\\n    }\\n    \\n    void flipSlot(int r, int c, vector<vector<int>> &mat) {\\n        flipSelfAdj(r, c, mat);\\n        flipCnt++;\\n    }\\n    \\n    void reverseFlipSlot(int r, int c, vector<vector<int>> &mat) {\\n        flipSelfAdj(r, c, mat);\\n        flipCnt--;\\n    }\\n    \\n\\t// Idea: for each slot, either flip it or not flip it\\n\\t// time complexity 2 ^ (mn), m * n slots, each slot we create 2 paths (take / not take)\\n    void dfs(int currR, int currC, vector<vector<int>> &mat) {\\n        \\n        int nextC = (currC + 1) % cSize;\\n        int nextR = currR + (nextC <= currC ? 1 : 0);\\n        \\n        // case 1: flip current slot\\n        flipSlot(currR, currC, mat);\\n        if (oneCnt == 0) {\\n            res = min(res, flipCnt);\\n            reverseFlipSlot(currR, currC, mat);\\n            return;\\n        }\\n        for (int r = nextR; r < rSize; r++) {\\n            for (int c = nextC; c < cSize; c++) {\\n                dfs(r, c, mat);\\n            }\\n        }\\n        reverseFlipSlot(currR, currC, mat);\\n        \\n        // case 2: don\\'t flip current slot\\n        for (int r = nextR; r < rSize; r++) {\\n            for (int c = nextC; c < cSize; c++) {\\n                dfs(r, c, mat);\\n            }\\n        }\\n    }\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        \\n        res = INT_MAX;\\n        \\n        oneCnt = 0;\\n        flipCnt = 0;\\n        \\n        rSize = mat.size();\\n        cSize = mat[0].size();\\n         \\n        // get initial 1 count\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                if (mat[r][c] == 1) oneCnt++;\\n            }\\n        }\\n        \\n\\t\\t// there is nothing to flip\\n        if (oneCnt == 0) return 0;\\n        \\n        dfs(0, 0, mat);\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int rSize, cSize;\\n    int oneCnt;\\n    int flipCnt;\\n    int res;\\n    \\n    int dir[5] = {0, 1, 0, -1, 0};\\n    \\n    void flip(int r, int c, vector<vector<int>> &mat) {\\n        if (r < 0 || c < 0 || r >= rSize || c >= cSize) return;\\n        oneCnt += mat[r][c] ? -1 : 1;\\n        mat[r][c] = !mat[r][c];\\n    }\\n    \\n    void flipSelfAdj(int r, int c, vector<vector<int>> &mat) {\\n        flip(r, c, mat);\\n        for (int i = 0; i < 4; i++) {\\n            flip(r + dir[i], c + dir[i + 1], mat);\\n        }\\n    }\\n    \\n    void flipSlot(int r, int c, vector<vector<int>> &mat) {\\n        flipSelfAdj(r, c, mat);\\n        flipCnt++;\\n    }\\n    \\n    void reverseFlipSlot(int r, int c, vector<vector<int>> &mat) {\\n        flipSelfAdj(r, c, mat);\\n        flipCnt--;\\n    }\\n    \\n\\t// Idea: for each slot, either flip it or not flip it\\n\\t// time complexity 2 ^ (mn), m * n slots, each slot we create 2 paths (take / not take)\\n    void dfs(int currR, int currC, vector<vector<int>> &mat) {\\n        \\n        int nextC = (currC + 1) % cSize;\\n        int nextR = currR + (nextC <= currC ? 1 : 0);\\n        \\n        // case 1: flip current slot\\n        flipSlot(currR, currC, mat);\\n        if (oneCnt == 0) {\\n            res = min(res, flipCnt);\\n            reverseFlipSlot(currR, currC, mat);\\n            return;\\n        }\\n        for (int r = nextR; r < rSize; r++) {\\n            for (int c = nextC; c < cSize; c++) {\\n                dfs(r, c, mat);\\n            }\\n        }\\n        reverseFlipSlot(currR, currC, mat);\\n        \\n        // case 2: don\\'t flip current slot\\n        for (int r = nextR; r < rSize; r++) {\\n            for (int c = nextC; c < cSize; c++) {\\n                dfs(r, c, mat);\\n            }\\n        }\\n    }\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        \\n        res = INT_MAX;\\n        \\n        oneCnt = 0;\\n        flipCnt = 0;\\n        \\n        rSize = mat.size();\\n        cSize = mat[0].size();\\n         \\n        // get initial 1 count\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                if (mat[r][c] == 1) oneCnt++;\\n            }\\n        }\\n        \\n\\t\\t// there is nothing to flip\\n        if (oneCnt == 0) return 0;\\n        \\n        dfs(0, 0, mat);\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673178,
                "title": "c-bfs-solution",
                "content": "Hope it will help you :)\\n```\\nclass Solution {\\npublic:\\n    int row;\\n    int col;\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        row = mat.size();\\n        col = mat[0].size();\\n        unordered_set<string> s;\\n        queue<pair<vector<vector<int>>,int>> q; // mat, age\\n        q.push({mat,0});\\n\\n        while(!q.empty()){\\n            auto pair = q.front();q.pop();\\n            vector<vector<int>> v = pair.first;\\n            int age = pair.second;\\n            string matStr = toString(v);\\n\\n            if(s.find(matStr) != s.end()) continue;\\n            s.insert(matStr);\\n         \\n            if(isZeroMatrix(v)) return age;\\n            \\n            for(int i = 0 ; i < row ; i++){\\n                for(int j = 0 ; j < col ; j++){\\n                    vector<vector<int>> fliped = getFliped(v, i,j);\\n                    q.push({fliped, age+1});\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n        \\n    }\\n    vector<vector<int>> getFliped(vector<vector<int>> mat,int i, int j){\\n        \\n        mat[i][j] = 1^mat[i][j];\\n        if(i-1>=0){\\n            mat[i-1][j] = 1^mat[i-1][j];\\n        }\\n        if (i+1 < row){\\n            mat[i+1][j] = 1^mat[i+1][j];\\n        }\\n        if(j-1>=0){\\n            mat[i][j-1] = 1^mat[i][j-1];\\n        }\\n        if (j+1 < col){\\n            mat[i][j+1] = 1^mat[i][j+1];\\n        }\\n   \\n        return mat;\\n    }\\n    bool isZeroMatrix(vector<vector<int>>& mat){\\n        for(int i = 0 ; i < row; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(mat[i][j] == 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    string toString(vector<vector<int>> & mat){\\n        string result = \"\";\\n        for(int i = 0 ; i < row; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                result+=to_string(mat[i][j]) + \" \";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int row;\\n    int col;\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        row = mat.size();\\n        col = mat[0].size();\\n        unordered_set<string> s;\\n        queue<pair<vector<vector<int>>,int>> q; // mat, age\\n        q.push({mat,0});\\n\\n        while(!q.empty()){\\n            auto pair = q.front();q.pop();\\n            vector<vector<int>> v = pair.first;\\n            int age = pair.second;\\n            string matStr = toString(v);\\n\\n            if(s.find(matStr) != s.end()) continue;\\n            s.insert(matStr);\\n         \\n            if(isZeroMatrix(v)) return age;\\n            \\n            for(int i = 0 ; i < row ; i++){\\n                for(int j = 0 ; j < col ; j++){\\n                    vector<vector<int>> fliped = getFliped(v, i,j);\\n                    q.push({fliped, age+1});\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n        \\n    }\\n    vector<vector<int>> getFliped(vector<vector<int>> mat,int i, int j){\\n        \\n        mat[i][j] = 1^mat[i][j];\\n        if(i-1>=0){\\n            mat[i-1][j] = 1^mat[i-1][j];\\n        }\\n        if (i+1 < row){\\n            mat[i+1][j] = 1^mat[i+1][j];\\n        }\\n        if(j-1>=0){\\n            mat[i][j-1] = 1^mat[i][j-1];\\n        }\\n        if (j+1 < col){\\n            mat[i][j+1] = 1^mat[i][j+1];\\n        }\\n   \\n        return mat;\\n    }\\n    bool isZeroMatrix(vector<vector<int>>& mat){\\n        for(int i = 0 ; i < row; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(mat[i][j] == 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    string toString(vector<vector<int>> & mat){\\n        string result = \"\";\\n        for(int i = 0 ; i < row; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                result+=to_string(mat[i][j]) + \" \";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647895,
                "title": "java-bfs",
                "content": "```\\n class Data {\\n        int[][] mat;\\n        int steps;\\n\\n        public Data(int[][] mat, int steps) {\\n            this.mat = mat;\\n            this.steps = steps;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Data data = (Data) o;\\n            return Arrays.deepEquals(mat, data.mat);\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Arrays.deepHashCode(mat);\\n        }\\n    }\\n\\n    boolean inside(int row, int col, int[][] m) {\\n        return row >= 0 && row < m.length && col >= 0 && col < m[row].length;\\n    }\\n\\n    public int minFlips(int[][] mat) {\\n        Queue<Data> queue = new LinkedList<>();\\n        queue.add(new Data(mat, 0));\\n        int[][] dest = new int[mat.length][mat[0].length];\\n        for (int[] row : dest) Arrays.fill(row, 0);\\n        HashSet<Data> visited = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            Data curr = queue.poll();\\n            if (Arrays.deepEquals(curr.mat, dest)) {\\n                return curr.steps;\\n            }\\n            if (!visited.contains(curr)) {\\n                visited.add(curr);\\n                int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n                int[][] copy = Arrays.stream(curr.mat).map(int[]::clone).toArray(int[][]::new);\\n                for (int i = 0; i < curr.mat.length; i++) {\\n                    for (int j = 0; j < curr.mat[i].length; j++) {\\n                        for (int[] dir : dirs) {\\n                            int nextR = i + dir[0];\\n                            int nextC = j + dir[1];\\n                            if (inside(nextR, nextC, mat)) {\\n                                copy[nextR][nextC] = 1 - copy[nextR][nextC];\\n                            }\\n                        }\\n                        copy[i][j] = 1 - copy[i][j];\\n                        queue.add(new Data(copy, curr.steps + 1));\\n                        copy = Arrays.stream(curr.mat).map(int[]::clone).toArray(int[][]::new);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n class Data {\\n        int[][] mat;\\n        int steps;\\n\\n        public Data(int[][] mat, int steps) {\\n            this.mat = mat;\\n            this.steps = steps;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Data data = (Data) o;\\n            return Arrays.deepEquals(mat, data.mat);\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Arrays.deepHashCode(mat);\\n        }\\n    }\\n\\n    boolean inside(int row, int col, int[][] m) {\\n        return row >= 0 && row < m.length && col >= 0 && col < m[row].length;\\n    }\\n\\n    public int minFlips(int[][] mat) {\\n        Queue<Data> queue = new LinkedList<>();\\n        queue.add(new Data(mat, 0));\\n        int[][] dest = new int[mat.length][mat[0].length];\\n        for (int[] row : dest) Arrays.fill(row, 0);\\n        HashSet<Data> visited = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            Data curr = queue.poll();\\n            if (Arrays.deepEquals(curr.mat, dest)) {\\n                return curr.steps;\\n            }\\n            if (!visited.contains(curr)) {\\n                visited.add(curr);\\n                int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n                int[][] copy = Arrays.stream(curr.mat).map(int[]::clone).toArray(int[][]::new);\\n                for (int i = 0; i < curr.mat.length; i++) {\\n                    for (int j = 0; j < curr.mat[i].length; j++) {\\n                        for (int[] dir : dirs) {\\n                            int nextR = i + dir[0];\\n                            int nextC = j + dir[1];\\n                            if (inside(nextR, nextC, mat)) {\\n                                copy[nextR][nextC] = 1 - copy[nextR][nextC];\\n                            }\\n                        }\\n                        copy[i][j] = 1 - copy[i][j];\\n                        queue.add(new Data(copy, curr.steps + 1));\\n                        copy = Arrays.stream(curr.mat).map(int[]::clone).toArray(int[][]::new);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1419262,
                "title": "c-bfs-solution-using-map",
                "content": "```c++\\nclass Solution {\\npublic:\\n    map<vector<vector<int>>, int> dist;\\n    int dx[4] = {-1, 0, 0, 1};\\n    int dy[4] = {0, -1, 1, 0};\\n    queue<vector<vector<int>>> q;\\n        \\n    vector<vector<int>> toggle(vector<vector<int>> state, int r, int c) {\\n        state[r][c] = 1-state[r][c];\\n        int n = (int)state.size();\\n        int m = (int)state[0].size();\\n        \\n        for (int i = 0; i < 4; i++) {\\n            if (r + dx[i] >= 0 && r + dx[i] < n && c + dy[i] >= 0 && c + dy[i] < m) {\\n                state[r + dx[i]][c + dy[i]] = 1 - state[r + dx[i]][c + dy[i]];\\n            }\\n        }\\n        return state;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = (int)mat.size();\\n        int m = (int)mat[0].size();\\n        \\n        dist[mat] = 0;\\n        q.push(mat);\\n        \\n        while (!q.empty()) {\\n            vector<vector<int>> state = q.front();\\n            q.pop();\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    vector<vector<int>> nextState = toggle(state, i, j);\\n                    if ((dist.find(nextState) == dist.end()) ||  (dist[state] + 1 < dist[nextState])) {\\n                        dist[nextState] = dist[state] + 1;\\n                        q.push(nextState);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> zero;\\n        for (int i = 0; i < n; i++) {\\n            vector<int> tmp;\\n            for (int j = 0; j < m; j++) {\\n                tmp.push_back(0);\\n            }\\n            zero.push_back(tmp);\\n        }\\n        \\n        if (dist.find(zero) == dist.end()) {\\n            return -1;\\n        }\\n        return dist[zero];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    map<vector<vector<int>>, int> dist;\\n    int dx[4] = {-1, 0, 0, 1};\\n    int dy[4] = {0, -1, 1, 0};\\n    queue<vector<vector<int>>> q;\\n        \\n    vector<vector<int>> toggle(vector<vector<int>> state, int r, int c) {\\n        state[r][c] = 1-state[r][c];\\n        int n = (int)state.size();\\n        int m = (int)state[0].size();\\n        \\n        for (int i = 0; i < 4; i++) {\\n            if (r + dx[i] >= 0 && r + dx[i] < n && c + dy[i] >= 0 && c + dy[i] < m) {\\n                state[r + dx[i]][c + dy[i]] = 1 - state[r + dx[i]][c + dy[i]];\\n            }\\n        }\\n        return state;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = (int)mat.size();\\n        int m = (int)mat[0].size();\\n        \\n        dist[mat] = 0;\\n        q.push(mat);\\n        \\n        while (!q.empty()) {\\n            vector<vector<int>> state = q.front();\\n            q.pop();\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    vector<vector<int>> nextState = toggle(state, i, j);\\n                    if ((dist.find(nextState) == dist.end()) ||  (dist[state] + 1 < dist[nextState])) {\\n                        dist[nextState] = dist[state] + 1;\\n                        q.push(nextState);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> zero;\\n        for (int i = 0; i < n; i++) {\\n            vector<int> tmp;\\n            for (int j = 0; j < m; j++) {\\n                tmp.push_back(0);\\n            }\\n            zero.push_back(tmp);\\n        }\\n        \\n        if (dist.find(zero) == dist.end()) {\\n            return -1;\\n        }\\n        return dist[zero];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351061,
                "title": "an-elegant-solution-using-dp-proud-it-worked-in-first-try-c",
                "content": "Not exactly in first try :P one runtime error and one bug \\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        map<int, long> dp;\\n        int ans = getMinFlips(mat, dp);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n    \\n    long getMinFlips(vector<vector<int>>& mat, map<int, long>& dp) {\\n        int state = getState(mat);\\n        if(state == 0) return 0;\\n        if(dp.find(state) != dp.end()) {\\n            return dp[state];\\n        }\\n        dp[state] = INT_MAX;\\n        for(int i=0; i<mat.size(); ++i) {\\n            for(int j=0; j<mat[0].size(); ++j) {\\n                flip(mat, i, j);\\n                dp[state] = min(dp[state], 1 + getMinFlips(mat, dp));\\n                flip(mat, i, j);\\n            }\\n        }\\n        return dp[state];\\n    }\\n    \\n    int getState(vector<vector<int>>& mat) {\\n        int state = 0;\\n        for(int i=0; i<mat.size(); ++i) {\\n            for(int j=0; j<mat[0].size(); ++j) {\\n                state = (state<<1) | mat[i][j];\\n            }\\n        }\\n        \\n        return state;\\n    }\\n    \\n    void flip(vector<vector<int>>& mat, int i, int j) {\\n        mat[i][j] = mat[i][j]^1;\\n        if(i+1 < mat.size()) mat[i+1][j] = mat[i+1][j]^1;\\n        if(i-1 >= 0) mat[i-1][j] = mat[i-1][j]^1;\\n        if(j+1 < mat[0].size()) mat[i][j+1] = mat[i][j+1]^1;\\n        if(j-1 >= 0) mat[i][j-1] = mat[i][j-1]^1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        map<int, long> dp;\\n        int ans = getMinFlips(mat, dp);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n    \\n    long getMinFlips(vector<vector<int>>& mat, map<int, long>& dp) {\\n        int state = getState(mat);\\n        if(state == 0) return 0;\\n        if(dp.find(state) != dp.end()) {\\n            return dp[state];\\n        }\\n        dp[state] = INT_MAX;\\n        for(int i=0; i<mat.size(); ++i) {\\n            for(int j=0; j<mat[0].size(); ++j) {\\n                flip(mat, i, j);\\n                dp[state] = min(dp[state], 1 + getMinFlips(mat, dp));\\n                flip(mat, i, j);\\n            }\\n        }\\n        return dp[state];\\n    }\\n    \\n    int getState(vector<vector<int>>& mat) {\\n        int state = 0;\\n        for(int i=0; i<mat.size(); ++i) {\\n            for(int j=0; j<mat[0].size(); ++j) {\\n                state = (state<<1) | mat[i][j];\\n            }\\n        }\\n        \\n        return state;\\n    }\\n    \\n    void flip(vector<vector<int>>& mat, int i, int j) {\\n        mat[i][j] = mat[i][j]^1;\\n        if(i+1 < mat.size()) mat[i+1][j] = mat[i+1][j]^1;\\n        if(i-1 >= 0) mat[i-1][j] = mat[i-1][j]^1;\\n        if(j+1 < mat[0].size()) mat[i][j+1] = mat[i][j+1]^1;\\n        if(j-1 >= 0) mat[i][j-1] = mat[i][j-1]^1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006247,
                "title": "java-solution-beats-95-bfs-1ms-o-m-n-2-m-n",
                "content": "\\n\\tclass Pair {\\n\\n\\t\\tint num;\\n\\t\\tint cost;\\n\\n\\t\\tpublic Pair(int num, int cost) {\\n\\t\\t\\tthis.num = num;\\n\\t\\t\\tthis.cost = cost;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int minFlips(int[][] mat) {\\n\\n\\t\\tint m = mat.length, n = mat[0].length;\\n\\t\\tHashSet<Integer> visited = new HashSet<Integer>();\\n\\t\\tQueue<Pair> queue = new LinkedList<>();\\n\\t\\tint begin = 0;\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (mat[i][j] == 1)\\n\\t\\t\\t\\t\\tbegin = begin | (1 << (i * n + j));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (begin == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tvisited.add(begin);\\n\\t\\tqueue.add(new Pair(begin, 0));\\n\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tPair rem = queue.remove();\\n\\t\\t\\tif (rem.num == 0)\\n\\t\\t\\t\\treturn rem.cost;\\n\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint ntemp = toggleBits(rem.num, i, j, m, n, dirs);\\n\\t\\t\\t\\t\\tif (!visited.contains(ntemp)) {\\n\\t\\t\\t\\t\\t\\tvisited.add(ntemp);\\n\\t\\t\\t\\t\\t\\tqueue.add(new Pair(ntemp, rem.cost + 1));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic int toggleBits(int curr, int i, int j, int m, int n, int[][] dirs) {\\n\\n\\t\\tint mask = 1 << (i * n + j);\\n\\t\\tcurr = curr ^ mask;\\n\\n\\t\\tfor (int[] dir : dirs) {\\n\\n\\t\\t\\tint row = i + dir[0];\\n\\t\\t\\tint col = j + dir[1];\\n\\n\\t\\t\\tif (row < 0 || col < 0 || row >= m || col >= n)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint mask2 = 1 << (row * n + col);\\n\\t\\t\\tcurr = curr ^ mask2;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn curr;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\tclass Pair {\\n\\n\\t\\tint num;\\n\\t\\tint cost;\\n\\n\\t\\tpublic Pair(int num, int cost) {\\n\\t\\t\\tthis.num = num;\\n\\t\\t\\tthis.cost = cost;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int minFlips(int[][] mat) {\\n\\n\\t\\tint m = mat.length, n = mat[0].length;\\n\\t\\tHashSet<Integer> visited = new HashSet<Integer>();\\n\\t\\tQueue<Pair> queue = new LinkedList<>();\\n\\t\\tint begin = 0;\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (mat[i][j] == 1)\\n\\t\\t\\t\\t\\tbegin = begin | (1 << (i * n + j));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (begin == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tvisited.add(begin);\\n\\t\\tqueue.add(new Pair(begin, 0));\\n\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tPair rem = queue.remove();\\n\\t\\t\\tif (rem.num == 0)\\n\\t\\t\\t\\treturn rem.cost;\\n\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint ntemp = toggleBits(rem.num, i, j, m, n, dirs);\\n\\t\\t\\t\\t\\tif (!visited.contains(ntemp)) {\\n\\t\\t\\t\\t\\t\\tvisited.add(ntemp);\\n\\t\\t\\t\\t\\t\\tqueue.add(new Pair(ntemp, rem.cost + 1));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic int toggleBits(int curr, int i, int j, int m, int n, int[][] dirs) {\\n\\n\\t\\tint mask = 1 << (i * n + j);\\n\\t\\tcurr = curr ^ mask;\\n\\n\\t\\tfor (int[] dir : dirs) {\\n\\n\\t\\t\\tint row = i + dir[0];\\n\\t\\t\\tint col = j + dir[1];\\n\\n\\t\\t\\tif (row < 0 || col < 0 || row >= m || col >= n)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tint mask2 = 1 << (row * n + col);\\n\\t\\t\\tcurr = curr ^ mask2;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn curr;\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 975172,
                "title": "simple-bfs-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e8;\\n    int MatrixToNumber(vector<vector<int>> &mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        int number = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int j = m - 1; j >= 0; j--) {\\n                number = number*2 + mat[i][j];\\n            }\\n        }\\n        return number;\\n    }\\n    \\n    vector<vector<int>> NumberToMatrix(int number, int n, int m) {\\n        vector<vector<int>> mat(n, vector<int>(m, 0));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                mat[i][j] = number % 2;\\n                number /= 2;\\n            }\\n        }\\n        return mat;\\n    }\\n    void print(vector<vector<int>> mat) {\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                cout << mat[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        cout << endl;\\n    }\\n    \\n    int solve(int mask, vector<bool> &vis, int n, int m) {\\n        queue<int> q;\\n        vector<int> cost(vis.size(), 0);\\n        int ans = INF;\\n        q.push(mask);\\n        vis[mask] = true;\\n        while(q.size() > 0) {\\n            mask = q.front(); q.pop();\\n            vector<vector<int>> mat = NumberToMatrix(mask, n, m);\\n            vector<int> dx = {0, 0, -1, 1};\\n            vector<int> dy = {-1, 1, 0, 0};\\n\\n            if(mask == 0) {\\n                ans = min(ans, cost[mask]);\\n            }\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    vector<vector<int>> newMat = mat;\\n                    newMat[i][j] ^= 1;\\n                    for(int l = 0; l < 4; l++) {\\n                        int ni = i + dx[l];\\n                        int nj = j + dy[l];\\n                        if(ni < 0 || nj < 0 || ni >= n || nj >= m)\\n                            continue;\\n                        newMat[ni][nj] ^= 1;\\n                    }\\n                    int number = MatrixToNumber(newMat);\\n                    if(vis[number] == false) {\\n                        q.push(number);\\n                        vis[number] = true;\\n                        cost[number] = cost[mask] + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        int number = MatrixToNumber(mat);\\n        vector<bool> vis((int)(pow(2, 9) + 5), false);\\n        int ans = solve(number, vis, n, m);\\n        \\n        return ((ans >= INF) ? (-1) : (ans));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e8;\\n    int MatrixToNumber(vector<vector<int>> &mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        int number = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int j = m - 1; j >= 0; j--) {\\n                number = number*2 + mat[i][j];\\n            }\\n        }\\n        return number;\\n    }\\n    \\n    vector<vector<int>> NumberToMatrix(int number, int n, int m) {\\n        vector<vector<int>> mat(n, vector<int>(m, 0));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                mat[i][j] = number % 2;\\n                number /= 2;\\n            }\\n        }\\n        return mat;\\n    }\\n    void print(vector<vector<int>> mat) {\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                cout << mat[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        cout << endl;\\n    }\\n    \\n    int solve(int mask, vector<bool> &vis, int n, int m) {\\n        queue<int> q;\\n        vector<int> cost(vis.size(), 0);\\n        int ans = INF;\\n        q.push(mask);\\n        vis[mask] = true;\\n        while(q.size() > 0) {\\n            mask = q.front(); q.pop();\\n            vector<vector<int>> mat = NumberToMatrix(mask, n, m);\\n            vector<int> dx = {0, 0, -1, 1};\\n            vector<int> dy = {-1, 1, 0, 0};\\n\\n            if(mask == 0) {\\n                ans = min(ans, cost[mask]);\\n            }\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    vector<vector<int>> newMat = mat;\\n                    newMat[i][j] ^= 1;\\n                    for(int l = 0; l < 4; l++) {\\n                        int ni = i + dx[l];\\n                        int nj = j + dy[l];\\n                        if(ni < 0 || nj < 0 || ni >= n || nj >= m)\\n                            continue;\\n                        newMat[ni][nj] ^= 1;\\n                    }\\n                    int number = MatrixToNumber(newMat);\\n                    if(vis[number] == false) {\\n                        q.push(number);\\n                        vis[number] = true;\\n                        cost[number] = cost[mask] + 1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        int number = MatrixToNumber(mat);\\n        vector<bool> vis((int)(pow(2, 9) + 5), false);\\n        int ans = solve(number, vis, n, m);\\n        \\n        return ((ans >= INF) ? (-1) : (ans));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 819269,
                "title": "python-dfs-backtracking-with-no-memo",
                "content": "Since the matrices are at most 3x3, it appears we can get away with a simple backtrack with no memo (with pretty good results speed wise).\\n\\nThe logic is then relatively simple in the backtracking. First, we extract the coordinates as a list (so we can index them with an integer). In the bactrack, the termination condition is if the sum of the matrix is 0. For a given index, TRY the flip operation on every index (or element of the matrix). Once you try to flip the index, you can only flip the remaining NM-1 indices (since as the hint suggests, performing the flip operation twice is doing nothing). So when we recurse, we need to increment our index or coordinate tracker by 1. If the dfs fails, then backtrack by undoing the flip operation.\\n\\nI have two helper functions: sum_matrix computes the sum of the matrix and flip_index which performs the requisite flip operation.\\n\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        \\n        N = len(mat);\\n        M = len(mat[0]);\\n        coordinates = [];\\n        for i in range(N):\\n            for j in range(M):\\n                coordinates.append((i,j))\\n        #print(coordinates)\\n        neighbors = [(-1,0),(1,0),(0,1),(0,-1)]\\n        #visited = [[0]*M for _ in range(N)]\\n        def sum_matrix(mat):\\n            return sum([sum(i) for i in mat])\\n             \\n        def flip_index(i,j):\\n            \\'\\'\\'\\n            call this twice and it\\'s an unflip or a reversal of a flip\\n            \\'\\'\\'\\n            mat[i][j] = (mat[i][j]+1)%2\\n            for dx, dy in neighbors:\\n                xn = i+dx; yn = j+dy;\\n                if(xn >=0 and xn < N and yn >= 0 and yn < M):\\n                    mat[xn][yn] = (mat[xn][yn]+1)%2\\n        \\n        #is a visited array really necessary? NO\\n        \\n        def dfs(index): #dfs returns moves\\n            if(sum_matrix(mat) == 0): ## this is what we memoize\\n                return 0;\\n            \\n            val = float(\\'Inf\\')\\n      \\n            ## we should exclusively propose flips here, \\n            for k in range(index,N*M): # only iterate coordinates that have not been touched yet\\n                # should we include j == index?; gets us stuck in a loop\\n                #print(index, k)\\n                #first execute flip at index\\n                xn, yn = coordinates[k]\\n                flip_index(xn, yn)\\n                val = min(val, 1+dfs(k+1));\\n                flip_index(xn, yn)\\n            return val\\n        #print(\\'ansr: \\',dfs(0));\\n        ansr = dfs(0);\\n        return ansr if ansr < float(\\'inf\\') else -1;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        \\n        N = len(mat);\\n        M = len(mat[0]);\\n        coordinates = [];\\n        for i in range(N):\\n            for j in range(M):\\n                coordinates.append((i,j))\\n        #print(coordinates)\\n        neighbors = [(-1,0),(1,0),(0,1),(0,-1)]\\n        #visited = [[0]*M for _ in range(N)]\\n        def sum_matrix(mat):\\n            return sum([sum(i) for i in mat])\\n             \\n        def flip_index(i,j):\\n            \\'\\'\\'\\n            call this twice and it\\'s an unflip or a reversal of a flip\\n            \\'\\'\\'\\n            mat[i][j] = (mat[i][j]+1)%2\\n            for dx, dy in neighbors:\\n                xn = i+dx; yn = j+dy;\\n                if(xn >=0 and xn < N and yn >= 0 and yn < M):\\n                    mat[xn][yn] = (mat[xn][yn]+1)%2\\n        \\n        #is a visited array really necessary? NO\\n        \\n        def dfs(index): #dfs returns moves\\n            if(sum_matrix(mat) == 0): ## this is what we memoize\\n                return 0;\\n            \\n            val = float(\\'Inf\\')\\n      \\n            ## we should exclusively propose flips here, \\n            for k in range(index,N*M): # only iterate coordinates that have not been touched yet\\n                # should we include j == index?; gets us stuck in a loop\\n                #print(index, k)\\n                #first execute flip at index\\n                xn, yn = coordinates[k]\\n                flip_index(xn, yn)\\n                val = min(val, 1+dfs(k+1));\\n                flip_index(xn, yn)\\n            return val\\n        #print(\\'ansr: \\',dfs(0));\\n        ansr = dfs(0);\\n        return ansr if ansr < float(\\'inf\\') else -1;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467062,
                "title": "c-bit-masking-observation",
                "content": "Observation:  \\n1. Order of execution of operation will not impact answer . \\n2. Any cell needs to toggle at max once . \\n```\\nclass Solution {\\npublic:\\n    \\n    int xlen,ylen;\\n    \\n    bool isvalidCell(int x,int y) {\\n        return (x<0 || y<0 || x>=xlen || y>=ylen) ? false : true;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        \\n        if(mat.empty()) return 0;\\n        \\n        xlen = mat.size();\\n        ylen = mat[0].size();\\n        \\n       \\n        int max = (1<< (xlen*ylen )) -1;\\n        \\n        int ans  = INT_MAX;\\n        \\n        for (int i = 0; i <= max; i++) {\\n            \\n            int tempans=0;\\n            vector<vector<int>> tempmat = mat;\\n            \\n            for (int j = 0;j < xlen;j++) {\\n                \\n                for (int k = 0; k < ylen; k++) {\\n                \\n                    int bitindex = j*ylen + k;\\n                    \\n                    if (i & (1<<bitindex)) {\\n                        \\n                        tempans++;\\n                        tempmat[j][k] = !tempmat[j][k];\\n                        if (isvalidCell(j-1,k)) tempmat[j-1][k] = !tempmat[j-1][k];\\n                        if (isvalidCell(j+1,k)) tempmat[j+1][k] = !tempmat[j+1][k];\\n                        if (isvalidCell(j,k-1)) tempmat[j][k-1] = !tempmat[j][k-1];\\n                        if (isvalidCell(j,k+1)) tempmat[j][k+1] = !tempmat[j][k+1];\\n                    }\\n                }\\n            }\\n            \\n            bool isvalid = true;\\n            for (int j = 0; j < xlen; j++) {\\n                for (int k = 0; k < ylen; k++)   {\\n                    if(tempmat[j][k]) isvalid = false;\\n                }         \\n            }\\n            \\n            if (isvalid) {\\n                ans = min(ans,tempans);\\n            }\\n        }\\n        \\n        if (ans == INT_MAX) return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int xlen,ylen;\\n    \\n    bool isvalidCell(int x,int y) {\\n        return (x<0 || y<0 || x>=xlen || y>=ylen) ? false : true;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        \\n        if(mat.empty()) return 0;\\n        \\n        xlen = mat.size();\\n        ylen = mat[0].size();\\n        \\n       \\n        int max = (1<< (xlen*ylen )) -1;\\n        \\n        int ans  = INT_MAX;\\n        \\n        for (int i = 0; i <= max; i++) {\\n            \\n            int tempans=0;\\n            vector<vector<int>> tempmat = mat;\\n            \\n            for (int j = 0;j < xlen;j++) {\\n                \\n                for (int k = 0; k < ylen; k++) {\\n                \\n                    int bitindex = j*ylen + k;\\n                    \\n                    if (i & (1<<bitindex)) {\\n                        \\n                        tempans++;\\n                        tempmat[j][k] = !tempmat[j][k];\\n                        if (isvalidCell(j-1,k)) tempmat[j-1][k] = !tempmat[j-1][k];\\n                        if (isvalidCell(j+1,k)) tempmat[j+1][k] = !tempmat[j+1][k];\\n                        if (isvalidCell(j,k-1)) tempmat[j][k-1] = !tempmat[j][k-1];\\n                        if (isvalidCell(j,k+1)) tempmat[j][k+1] = !tempmat[j][k+1];\\n                    }\\n                }\\n            }\\n            \\n            bool isvalid = true;\\n            for (int j = 0; j < xlen; j++) {\\n                for (int k = 0; k < ylen; k++)   {\\n                    if(tempmat[j][k]) isvalid = false;\\n                }         \\n            }\\n            \\n            if (isvalid) {\\n                ans = min(ans,tempans);\\n            }\\n        }\\n        \\n        if (ans == INT_MAX) return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446964,
                "title": "c-java-0-ms-bitmap-in-int-bfs-short-and-clean-code",
                "content": "The matrix is small so ```int``` is enough to keep the matrix state.\\nAlgo:\\n - Run BFS starting with initial matrix converted to int\\n - the ```togo``` list is updated on the go; remember it\\'s size to know when we make the next step\\n - the next state is calculated as the state ```toCheck``` plus 5 flipped bits: center + neighbors\\n\\nC++, 0 ms\\n```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        vector<vector<int>> dirs = {{0,1},{1,0},{0,0},{0,-1},{-1,0}};\\n        int rows=mat.size(), cols=mat[0].size();\\n        int matrix = 0, pos=0, steps=0;\\n\\n        for(auto& v : mat) for(int i:v) matrix |= (i<<(pos++)); // bitmask in int\\n\\n        list<int> togo; togo.push_back(matrix);\\n        unordered_set<int> visited; visited.emplace(matrix);\\n        \\n        while(togo.size()) {\\n            int sz = togo.size();\\n            for(int i=0;i<sz;i++) {\\n                int toCheck = togo.front(); togo.pop_front();\\n                if(toCheck==0) return steps;\\n                for(int r=0;r<rows;r++) {\\n                    for(int c=0;c<cols;c++) {\\n                        int newPos=toCheck; // then flip cells around [r][c]\\n                        for(auto& d:dirs) {\\n                            int rr=r+d[0], cc=c+d[1];\\n                            if(rr<0||rr>=rows||cc<0||cc>=cols) continue;\\n                            newPos ^= 1<<(rr*cols+cc); // flip\\n                        }\\n                        if(visited.count(newPos)) continue;\\n                        visited.emplace(newPos);\\n                        togo.push_back(newPos);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nJava, 3ms\\n```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int[][] dirs = {{0,1},{1,0},{0,0},{0,-1},{-1,0}};\\n        int rows=mat.length, cols=mat[0].length;\\n        int matrix = 0, pos=0, steps=0;\\n\\n        for(int[] v : mat) for(int i:v) matrix |= (i<<(pos++)); // bitmask in int\\n\\n        LinkedList<Integer> togo = new LinkedList<>(Arrays.asList(matrix));\\n        Set<Integer> visited = new HashSet<>(matrix);\\n        \\n        while(togo.size() > 0) {\\n            int sz = togo.size();\\n            for(int i=0;i<sz;i++) {\\n                int toCheck = togo.getFirst(); togo.removeFirst();\\n                if(toCheck==0) return steps;\\n                for(int r=0;r<rows;r++) {\\n                    for(int c=0;c<cols;c++) {\\n                        int newPos=toCheck; // then flip cells around [r][c]\\n                        for(int[] d:dirs) {\\n                            int rr=r+d[0], cc=c+d[1];\\n                            if(rr<0||rr>=rows||cc<0||cc>=cols) continue;\\n                            newPos ^= 1<<(rr*cols+cc); // flip\\n                        }\\n                        if(visited.contains(newPos)) continue;\\n                        visited.add(newPos);\\n                        togo.add(newPos);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```int```\n```togo```\n```toCheck```\n```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        vector<vector<int>> dirs = {{0,1},{1,0},{0,0},{0,-1},{-1,0}};\\n        int rows=mat.size(), cols=mat[0].size();\\n        int matrix = 0, pos=0, steps=0;\\n\\n        for(auto& v : mat) for(int i:v) matrix |= (i<<(pos++)); // bitmask in int\\n\\n        list<int> togo; togo.push_back(matrix);\\n        unordered_set<int> visited; visited.emplace(matrix);\\n        \\n        while(togo.size()) {\\n            int sz = togo.size();\\n            for(int i=0;i<sz;i++) {\\n                int toCheck = togo.front(); togo.pop_front();\\n                if(toCheck==0) return steps;\\n                for(int r=0;r<rows;r++) {\\n                    for(int c=0;c<cols;c++) {\\n                        int newPos=toCheck; // then flip cells around [r][c]\\n                        for(auto& d:dirs) {\\n                            int rr=r+d[0], cc=c+d[1];\\n                            if(rr<0||rr>=rows||cc<0||cc>=cols) continue;\\n                            newPos ^= 1<<(rr*cols+cc); // flip\\n                        }\\n                        if(visited.count(newPos)) continue;\\n                        visited.emplace(newPos);\\n                        togo.push_back(newPos);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int[][] dirs = {{0,1},{1,0},{0,0},{0,-1},{-1,0}};\\n        int rows=mat.length, cols=mat[0].length;\\n        int matrix = 0, pos=0, steps=0;\\n\\n        for(int[] v : mat) for(int i:v) matrix |= (i<<(pos++)); // bitmask in int\\n\\n        LinkedList<Integer> togo = new LinkedList<>(Arrays.asList(matrix));\\n        Set<Integer> visited = new HashSet<>(matrix);\\n        \\n        while(togo.size() > 0) {\\n            int sz = togo.size();\\n            for(int i=0;i<sz;i++) {\\n                int toCheck = togo.getFirst(); togo.removeFirst();\\n                if(toCheck==0) return steps;\\n                for(int r=0;r<rows;r++) {\\n                    for(int c=0;c<cols;c++) {\\n                        int newPos=toCheck; // then flip cells around [r][c]\\n                        for(int[] d:dirs) {\\n                            int rr=r+d[0], cc=c+d[1];\\n                            if(rr<0||rr>=rows||cc<0||cc>=cols) continue;\\n                            newPos ^= 1<<(rr*cols+cc); // flip\\n                        }\\n                        if(visited.contains(newPos)) continue;\\n                        visited.add(newPos);\\n                        togo.add(newPos);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446958,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    int[] dx = new int[] {0, 1, 0, -1};\\n    int[] dy = new int[] {1, 0, -1, 0};\\n    \\n    public int MinFlips(int[][] mat) \\n    {\\n        int r = mat.Length, c = mat[0].Length;\\n        var visited = new HashSet<int>();\\n        var queue = new Queue<int[][]>();\\n        queue.Enqueue(mat);\\n        visited.Add(ConvertToInt(mat));\\n        int depth = 0;\\n        \\n        while (queue.Count != 0) \\n        {\\n            int count = queue.Count;\\n            for(int cnt = 0; cnt < count; cnt++)\\n            {\\n                var curr = queue.Dequeue();\\n                if(ConvertToInt(curr) == 0) return depth;\\n                for(int x = 0; x < r; x++)\\n                {\\n                    for(int y = 0; y < c; y++)\\n                    {\\n                        var clone = CloneMatrix(curr);\\n                        clone[x][y] =  clone[x][y] == 1 ? 0 : 1;\\n                        for(int d = 0; d < 4; d++)\\n                        {\\n                            int nx = x + dx[d], ny = y + dy[d];\\n                            if(nx >= 0 && nx < r && ny >= 0 && ny < c)\\n                                clone[nx][ny] =  clone[nx][ny] == 1 ? 0 : 1;\\n                        }\\n                        \\n                        if(visited.Add(ConvertToInt(clone)))\\n                            queue.Enqueue(clone);\\n                    }\\n                }\\n            }\\n            \\n            depth++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int ConvertToInt(int[][] mat) \\n    {\\n        var result = 0;\\n        for(int i = 0; i < mat.Length; i++) \\n            for (int j = 0; j < mat[0].Length; j++) \\n                result = (result * 2) + mat[i][j];\\n        \\n        return result;\\n    }\\n    \\n    private int[][] CloneMatrix(int[][] mat)\\n    {\\n        int r = mat.Length, c = mat[0].Length;\\n        var result = new int[r][];\\n        for(int i = 0; i < r; i++)\\n            result[i] = (int[]) mat[i].Clone();\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    int[] dx = new int[] {0, 1, 0, -1};\\n    int[] dy = new int[] {1, 0, -1, 0};\\n    \\n    public int MinFlips(int[][] mat) \\n    {\\n        int r = mat.Length, c = mat[0].Length;\\n        var visited = new HashSet<int>();\\n        var queue = new Queue<int[][]>();\\n        queue.Enqueue(mat);\\n        visited.Add(ConvertToInt(mat));\\n        int depth = 0;\\n        \\n        while (queue.Count != 0) \\n        {\\n            int count = queue.Count;\\n            for(int cnt = 0; cnt < count; cnt++)\\n            {\\n                var curr = queue.Dequeue();\\n                if(ConvertToInt(curr) == 0) return depth;\\n                for(int x = 0; x < r; x++)\\n                {\\n                    for(int y = 0; y < c; y++)\\n                    {\\n                        var clone = CloneMatrix(curr);\\n                        clone[x][y] =  clone[x][y] == 1 ? 0 : 1;\\n                        for(int d = 0; d < 4; d++)\\n                        {\\n                            int nx = x + dx[d], ny = y + dy[d];\\n                            if(nx >= 0 && nx < r && ny >= 0 && ny < c)\\n                                clone[nx][ny] =  clone[nx][ny] == 1 ? 0 : 1;\\n                        }\\n                        \\n                        if(visited.Add(ConvertToInt(clone)))\\n                            queue.Enqueue(clone);\\n                    }\\n                }\\n            }\\n            \\n            depth++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int ConvertToInt(int[][] mat) \\n    {\\n        var result = 0;\\n        for(int i = 0; i < mat.Length; i++) \\n            for (int j = 0; j < mat[0].Length; j++) \\n                result = (result * 2) + mat[i][j];\\n        \\n        return result;\\n    }\\n    \\n    private int[][] CloneMatrix(int[][] mat)\\n    {\\n        int r = mat.Length, c = mat[0].Length;\\n        var result = new int[r][];\\n        for(int i = 0; i < r; i++)\\n            result[i] = (int[]) mat[i].Clone();\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446873,
                "title": "binary-encoding-in-javascript-it-s-possible-48ms",
                "content": "I use a bit mask to represent all the possible transformations, and I also encode the matrix in a binary encoding, then I do xor to \"flip.\"  No matrices involved in the driver code!\\n\\n``` javascript\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n    let X = mat.length;\\n    let Y = mat[0].length;\\n\\n    let binary = {\\n        0: 1,\\n        1: 2,\\n        2: 4,\\n        3: 8,\\n        4: 16,\\n        5: 32,\\n        6: 64,\\n        7: 128,\\n        8: 256\\n    };\\n\\n    let mask = [];\\n\\n    let state = 0;\\n    for (let i = 0; i < X; ++i) {\\n        for (let j = 0; j < Y; ++j) {\\n            let bit = 0;\\n            state += mat[i][j] * binary[Y * i + j];\\n            bit += binary[Y * i + j];\\n            if (i > 0) {\\n                bit += binary[Y * (i - 1) + j];\\n            }\\n            if (i < X - 1) {\\n                bit += binary[Y * (i + 1) + j];\\n            }\\n            if (j > 0) {\\n                bit += binary[Y * i + (j - 1)];\\n            }\\n            if (j < Y - 1) {\\n                bit += binary[Y * i + (j + 1)];\\n            }\\n            mask.push(bit);\\n        }\\n    }\\n\\n    if (state === 0) {\\n        return 0;\\n    }\\n\\n    let set = new Set();\\n    let q = [{ state: state, moves: 0 }];\\n\\n    while (q.length !== 0) {\\n        let cur = q.shift();\\n\\n        if (cur.state === 0) {\\n            return cur.moves;\\n        }\\n\\n        for (let i = 0; i < X * Y; ++i) {\\n            let newState = cur.state;\\n            newState ^= mask[i];\\n            if (!set.has(newState)) {\\n                set.add(newState);\\n                q.push({ state: newState, moves: cur.moves + 1 });\\n            }\\n        }\\n    }\\n\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n    let X = mat.length;\\n    let Y = mat[0].length;\\n\\n    let binary = {\\n        0: 1,\\n        1: 2,\\n        2: 4,\\n        3: 8,\\n        4: 16,\\n        5: 32,\\n        6: 64,\\n        7: 128,\\n        8: 256\\n    };\\n\\n    let mask = [];\\n\\n    let state = 0;\\n    for (let i = 0; i < X; ++i) {\\n        for (let j = 0; j < Y; ++j) {\\n            let bit = 0;\\n            state += mat[i][j] * binary[Y * i + j];\\n            bit += binary[Y * i + j];\\n            if (i > 0) {\\n                bit += binary[Y * (i - 1) + j];\\n            }\\n            if (i < X - 1) {\\n                bit += binary[Y * (i + 1) + j];\\n            }\\n            if (j > 0) {\\n                bit += binary[Y * i + (j - 1)];\\n            }\\n            if (j < Y - 1) {\\n                bit += binary[Y * i + (j + 1)];\\n            }\\n            mask.push(bit);\\n        }\\n    }\\n\\n    if (state === 0) {\\n        return 0;\\n    }\\n\\n    let set = new Set();\\n    let q = [{ state: state, moves: 0 }];\\n\\n    while (q.length !== 0) {\\n        let cur = q.shift();\\n\\n        if (cur.state === 0) {\\n            return cur.moves;\\n        }\\n\\n        for (let i = 0; i < X * Y; ++i) {\\n            let newState = cur.state;\\n            newState ^= mask[i];\\n            if (!set.has(newState)) {\\n                set.add(newState);\\n                q.push({ state: newState, moves: cur.moves + 1 });\\n            }\\n        }\\n    }\\n\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 446451,
                "title": "python3-bfs-easy-to-read",
                "content": "```python\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        row_count, col_count = len(mat), len(mat[0])\\n        \\n        # 2d list -> 2d tuple\\n        def matrix_to_state(matrix):\\n            return tuple([tuple(row) for row in matrix])\\n        \\n        # 2d tuple -> 2d list\\n        def state_to_matrix(state):\\n            return [list(row) for row in state]\\n        \\n        # state -> state\\n        def flip(state, ri, ci):\\n            matrix = state_to_matrix(state)\\n            for tmp_ri, tmp_ci in [(ri, ci), (ri+1, ci), (ri-1, ci), (ri, ci+1), (ri, ci-1)]:\\n                if (0 <= tmp_ri < row_count) and (0 <= tmp_ci < col_count):\\n                    matrix[tmp_ri][tmp_ci] = 1 - matrix[tmp_ri][tmp_ci]\\n            return matrix_to_state(matrix)\\n    \\n        # state -> bool\\n        def is_goal_state(state):\\n            return all([cell == 0 for row in state for cell in row])\\n        \\n        # BFS\\n        q = [(matrix_to_state(mat), 0)]\\n        visited_states = set()\\n        for state, steps in q:\\n            if is_goal_state(state):\\n                return steps\\n            \\n            if state in visited_states:\\n                continue\\n            visited_states.add(state)\\n            \\n            # try flip each cell\\n            for flip_ri in range(row_count):\\n                for flip_ci in range(col_count):\\n                    next_state = flip(state, flip_ri, flip_ci)\\n                    q.append((next_state, steps + 1))\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        row_count, col_count = len(mat), len(mat[0])\\n        \\n        # 2d list -> 2d tuple\\n        def matrix_to_state(matrix):\\n            return tuple([tuple(row) for row in matrix])\\n        \\n        # 2d tuple -> 2d list\\n        def state_to_matrix(state):\\n            return [list(row) for row in state]\\n        \\n        # state -> state\\n        def flip(state, ri, ci):\\n            matrix = state_to_matrix(state)\\n            for tmp_ri, tmp_ci in [(ri, ci), (ri+1, ci), (ri-1, ci), (ri, ci+1), (ri, ci-1)]:\\n                if (0 <= tmp_ri < row_count) and (0 <= tmp_ci < col_count):\\n                    matrix[tmp_ri][tmp_ci] = 1 - matrix[tmp_ri][tmp_ci]\\n            return matrix_to_state(matrix)\\n    \\n        # state -> bool\\n        def is_goal_state(state):\\n            return all([cell == 0 for row in state for cell in row])\\n        \\n        # BFS\\n        q = [(matrix_to_state(mat), 0)]\\n        visited_states = set()\\n        for state, steps in q:\\n            if is_goal_state(state):\\n                return steps\\n            \\n            if state in visited_states:\\n                continue\\n            visited_states.add(state)\\n            \\n            # try flip each cell\\n            for flip_ri in range(row_count):\\n                for flip_ci in range(col_count):\\n                    next_state = flip(state, flip_ri, flip_ci)\\n                    q.append((next_state, steps + 1))\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446423,
                "title": "c-recursion-no-memoization",
                "content": "* There are two options, either we can perform a fip operation or skip this index. If we flip, we add one to our answer.\\n* At base case, we would check if all are 0s.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> dx = { 0, -1, 0, 1 };\\n    vector<int> dy = { 1, 0, -1, 0 };\\n    \\n    int f(vector<vector<int>> A, int i, int j) {\\n        if(i == A.size()) {\\n            for(int x = 0; x < A.size(); x++) {\\n                for(int y = 0; y < A[0].size(); y++) {\\n                    if(A[x][y])\\n                        return 1e6;\\n                }\\n            }\\n            return 0;\\n        }\\n        int op1 = 1e6, op2 = 1e6;\\n        if(j < A[0].size() - 1) {\\n            op1 = f(A, i, j + 1);    \\n        }\\n        else {\\n            op1 = f(A, i + 1, 0);\\n        }\\n        vector<vector<int>> v = A;\\n        v[i][j] = (!v[i][j]);\\n        for(int k = 0; k < 4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && y >= 0 && x < A.size() && y < A[0].size()) {\\n                v[x][y] = (!v[x][y]);\\n            }\\n        }\\n        if(j < A[0].size() - 1) {\\n            op2 = 1 + f(v, i, j + 1);    \\n        }\\n        else {\\n            op2 = 1 + f(v, i + 1, 0);\\n        }\\n        return min(op1, op2);\\n    }\\n    \\n    int minFlips(vector<vector<int>>& A) {\\n        int ans = f(A, 0, 0);\\n        if(ans >= 1e6)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = { 0, -1, 0, 1 };\\n    vector<int> dy = { 1, 0, -1, 0 };\\n    \\n    int f(vector<vector<int>> A, int i, int j) {\\n        if(i == A.size()) {\\n            for(int x = 0; x < A.size(); x++) {\\n                for(int y = 0; y < A[0].size(); y++) {\\n                    if(A[x][y])\\n                        return 1e6;\\n                }\\n            }\\n            return 0;\\n        }\\n        int op1 = 1e6, op2 = 1e6;\\n        if(j < A[0].size() - 1) {\\n            op1 = f(A, i, j + 1);    \\n        }\\n        else {\\n            op1 = f(A, i + 1, 0);\\n        }\\n        vector<vector<int>> v = A;\\n        v[i][j] = (!v[i][j]);\\n        for(int k = 0; k < 4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && y >= 0 && x < A.size() && y < A[0].size()) {\\n                v[x][y] = (!v[x][y]);\\n            }\\n        }\\n        if(j < A[0].size() - 1) {\\n            op2 = 1 + f(v, i, j + 1);    \\n        }\\n        else {\\n            op2 = 1 + f(v, i + 1, 0);\\n        }\\n        return min(op1, op2);\\n    }\\n    \\n    int minFlips(vector<vector<int>>& A) {\\n        int ans = f(A, 0, 0);\\n        if(ans >= 1e6)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915284,
                "title": "java-flipping-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA. Odd flipping - 1,3,5,7 --> will result in same result\\nB. Even flipping will also result in same result;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Following steps are required to solve this problem \\n        1. count the number of 1 \\n        2. Back tracking - perform recursion on points where we have 1 \\n            1. flip it to zero based on rules\\n            2. flip it to 1 based on rules \\n        3. Check at any momemt the values of the count ==0 \\n            then return the steps \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    int count =0;\\n    public int minFlips(int[][] mat) {\\n       /**\\n        Following steps are required to solve this problem \\n        1. count the number of 1 \\n        2. Back tracking - perform recursion on points where we have 1 \\n            1. flip it to zero based on rules\\n            2. flip it to 1 based on rules \\n        3. Check at any momemt the values of the count ==0 \\n            then return the steps \\n        */ \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        for(int i=0; i< m ; i++){\\n            for(int j =0; j< n; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n        }\\n        int res = recursion(mat, 0);\\n        if(res == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return res;\\n    }\\n\\n    private int recursion(int [][]mat, int ci){\\n        if(count ==0){\\n            return 0;\\n        }\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        if(ci >= m*n){\\n            return Integer.MAX_VALUE;\\n        }\\n         int res = Integer.MAX_VALUE;\\n        int flip = Integer.MAX_VALUE;\\n        // without flipping \\n        int nonflip = recursion(mat,ci+1);\\n        res = Math.min(res, nonflip);\\n        // with flip\\n        flipMatrix(mat, ci);\\n        int curr = recursion(mat, ci+1);\\n        // because of overflow\\n        if(curr != Integer.MAX_VALUE){\\n            flip = 1+ curr;\\n        }\\n        flipMatrix(mat, ci);\\n        res = Math.min(flip, res);\\n        return res;\\n\\n    }\\n\\n    private void flipMatrix(int[][]mat, int ci){\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int r = ci/n;\\n        int c = ci%n;\\n\\n        if(mat[r][c] == 0){\\n            mat[r][c] = 1;\\n            count++;\\n        }else {\\n            mat[r][c] = 0;\\n            count--;\\n        }\\n\\n        int [][]dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        for(int []d : dirs){\\n            int nr = r + d[0];\\n            int nc = c + d[1];\\n\\n            if(nr <0 || nr>= m || nc< 0 || nc>=n){\\n                continue;\\n            }\\n            if(mat[nr][nc] == 1){\\n                mat[nr][nc] = 0;\\n                count--;\\n            }else {\\n                mat[nr][nc] = 1;\\n                count++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count =0;\\n    public int minFlips(int[][] mat) {\\n       /**\\n        Following steps are required to solve this problem \\n        1. count the number of 1 \\n        2. Back tracking - perform recursion on points where we have 1 \\n            1. flip it to zero based on rules\\n            2. flip it to 1 based on rules \\n        3. Check at any momemt the values of the count ==0 \\n            then return the steps \\n        */ \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        for(int i=0; i< m ; i++){\\n            for(int j =0; j< n; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n        }\\n        int res = recursion(mat, 0);\\n        if(res == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return res;\\n    }\\n\\n    private int recursion(int [][]mat, int ci){\\n        if(count ==0){\\n            return 0;\\n        }\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        if(ci >= m*n){\\n            return Integer.MAX_VALUE;\\n        }\\n         int res = Integer.MAX_VALUE;\\n        int flip = Integer.MAX_VALUE;\\n        // without flipping \\n        int nonflip = recursion(mat,ci+1);\\n        res = Math.min(res, nonflip);\\n        // with flip\\n        flipMatrix(mat, ci);\\n        int curr = recursion(mat, ci+1);\\n        // because of overflow\\n        if(curr != Integer.MAX_VALUE){\\n            flip = 1+ curr;\\n        }\\n        flipMatrix(mat, ci);\\n        res = Math.min(flip, res);\\n        return res;\\n\\n    }\\n\\n    private void flipMatrix(int[][]mat, int ci){\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int r = ci/n;\\n        int c = ci%n;\\n\\n        if(mat[r][c] == 0){\\n            mat[r][c] = 1;\\n            count++;\\n        }else {\\n            mat[r][c] = 0;\\n            count--;\\n        }\\n\\n        int [][]dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        for(int []d : dirs){\\n            int nr = r + d[0];\\n            int nc = c + d[1];\\n\\n            if(nr <0 || nr>= m || nc< 0 || nc>=n){\\n                continue;\\n            }\\n            if(mat[nr][nc] == 1){\\n                mat[nr][nc] = 0;\\n                count--;\\n            }else {\\n                mat[nr][nc] = 1;\\n                count++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699453,
                "title": "storing-state-of-the-matrix-0ms-c-solution",
                "content": "From given constraints, ```1<=m,n<=3```. This means that we can store all the indices in an ID-form (by mapping (```i,j```) to (```ni+j```)) in a mn sized bitmask, where if the kth bit is set in the bitmask, the kth cell in the matrix is 1. We will check all the possible states and if at a certain point all the cells are zero, i.e., the bits in our mask equal zero, we have had achieved the required state.\\n\\nWe will further memoise the masks in order to not run into previously visited states.\\n\\nI achieved 0ms runtime.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[(1<<9)+1];\\n    int dir[5]={-1,0,1,0,-1};\\n    int m, n;\\n    bool valid(int i, int j){\\n        return i>=0 and i<m and j>=0 and j<n;\\n    }\\n    void flipCurrent(int i, int j, int &mask){\\n        mask^=(1<<(n*i+j));\\n        for(int d=0; d<4; d++){\\n            int newI=i+dir[d], newJ=j+dir[d+1];\\n            if(!valid(newI,newJ)){ continue; }\\n            mask^=(1<<(n*newI+newJ));\\n        }\\n    }\\n    void print(int mask){\\n        cout<<mask<<\\' \\';\\n        for(int i=0; i<m*n; i++){\\n            if((mask&(1<<i))==0){ cout<<0; }\\n            else{ cout<<1; }\\n        }\\n        cout<<endl;\\n    }\\n    int find(int mask){\\n        // print(mask);\\n        if(mask==0){ return 0; }\\n        if(dp[mask]!=-1){ return dp[mask]; }\\n        int ans=1e9;\\n        dp[mask]=1e9;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                flipCurrent(i,j,mask);\\n                if(find(mask)!=1e9){\\n                    ans=min(ans,1+find(mask));\\n                }\\n                flipCurrent(i,j,mask);\\n            }\\n        }       \\n        return dp[mask]=ans;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        m=mat.size(), n=mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int mask=0;     // stores the state of the matrix\\n                        // if kth bit is set means cell with \\'k\\' id is 1\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j]==1){\\n                    int id=n*i+j;\\n                    mask|=(1<<id);\\n                    // cout<<id<<\"th bit is set\"<<endl;\\n                }\\n            }\\n        }\\n        int ans=find(mask);\\n        return ans==1e9?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```1<=m,n<=3```\n```i,j```\n```ni+j```\n```\\nclass Solution {\\npublic:\\n    int dp[(1<<9)+1];\\n    int dir[5]={-1,0,1,0,-1};\\n    int m, n;\\n    bool valid(int i, int j){\\n        return i>=0 and i<m and j>=0 and j<n;\\n    }\\n    void flipCurrent(int i, int j, int &mask){\\n        mask^=(1<<(n*i+j));\\n        for(int d=0; d<4; d++){\\n            int newI=i+dir[d], newJ=j+dir[d+1];\\n            if(!valid(newI,newJ)){ continue; }\\n            mask^=(1<<(n*newI+newJ));\\n        }\\n    }\\n    void print(int mask){\\n        cout<<mask<<\\' \\';\\n        for(int i=0; i<m*n; i++){\\n            if((mask&(1<<i))==0){ cout<<0; }\\n            else{ cout<<1; }\\n        }\\n        cout<<endl;\\n    }\\n    int find(int mask){\\n        // print(mask);\\n        if(mask==0){ return 0; }\\n        if(dp[mask]!=-1){ return dp[mask]; }\\n        int ans=1e9;\\n        dp[mask]=1e9;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                flipCurrent(i,j,mask);\\n                if(find(mask)!=1e9){\\n                    ans=min(ans,1+find(mask));\\n                }\\n                flipCurrent(i,j,mask);\\n            }\\n        }       \\n        return dp[mask]=ans;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        m=mat.size(), n=mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int mask=0;     // stores the state of the matrix\\n                        // if kth bit is set means cell with \\'k\\' id is 1\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(mat[i][j]==1){\\n                    int id=n*i+j;\\n                    mask|=(1<<id);\\n                    // cout<<id<<\"th bit is set\"<<endl;\\n                }\\n            }\\n        }\\n        int ans=find(mask);\\n        return ans==1e9?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3268638,
                "title": "c-beat100-solution-with-explain-using-back-tracing",
                "content": "method 1:\\nflipping the same point in the matrix two times equals flipping zero times.\\n\\nmethod 2:\\nThe order of flipping does not affect the result\\n\\nresult:\\nall the points in the matrix will be flip at most one time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int times,vector<vector<int>> &mat,vector<vector<bool>>& c,int counter,bool& checker,int ni)\\n    {\\n        if(checker) return;\\n        if(times==counter)\\n                {\\n                    if(check(mat)) {checker=true;return;}\\n                    else return;\\n                }\\n        for(int i=ni/mat[0].size();i<mat.size();i++)\\n        {\\n            for(int j=ni%mat[0].size();j<mat[i].size();j++)\\n            {\\n                \\n                if(!c[i][j])\\n                {\\n                    counter++;\\n                    c[i][j]=true;\\n                    flip(mat,i,j);\\n                    helper(times,mat,c,counter,checker,i*mat[0].size());\\n                    flip(mat,i,j);\\n                    c[i][j]=false;\\n                    counter--;\\n                }\\n            }\\n        }\\n\\n\\n\\n    }\\n    void flip(vector<vector<int>> & mat,int i,int j)\\n    {\\n        mat[i][j]^=1;\\n        if(i!=0){mat[i-1][j]^=1;}\\n      \\n        if(i!=mat.size()-1){mat[i+1][j]^=1;}\\n    \\n        if(j!=0){mat[i][j-1]^=1;}\\n      \\n        if(j!=mat[0].size()-1){mat[i][j+1]^=1;}\\n       \\n    }\\n    bool check(vector<vector<int>> &mat)\\n    {\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n         if(check(mat)) return 0;\\n         if(mat.size()==1&&mat[0].size()==1) return 1;\\n         vector<vector<bool>> c;\\n         vector<bool> v(mat[0].size(),false);\\n         bool checker=false;\\n             for(int j=0;j<mat.size();j++)\\n             {\\n                 c.push_back(v);\\n             }\\n         \\n         for(int i=1;i<mat.size()*mat[0].size()+1;i++)\\n         {\\n             helper(i,mat,c,0,checker,0);\\n             if(checker) return i;\\n         }\\n         return -1;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int times,vector<vector<int>> &mat,vector<vector<bool>>& c,int counter,bool& checker,int ni)\\n    {\\n        if(checker) return;\\n        if(times==counter)\\n                {\\n                    if(check(mat)) {checker=true;return;}\\n                    else return;\\n                }\\n        for(int i=ni/mat[0].size();i<mat.size();i++)\\n        {\\n            for(int j=ni%mat[0].size();j<mat[i].size();j++)\\n            {\\n                \\n                if(!c[i][j])\\n                {\\n                    counter++;\\n                    c[i][j]=true;\\n                    flip(mat,i,j);\\n                    helper(times,mat,c,counter,checker,i*mat[0].size());\\n                    flip(mat,i,j);\\n                    c[i][j]=false;\\n                    counter--;\\n                }\\n            }\\n        }\\n\\n\\n\\n    }\\n    void flip(vector<vector<int>> & mat,int i,int j)\\n    {\\n        mat[i][j]^=1;\\n        if(i!=0){mat[i-1][j]^=1;}\\n      \\n        if(i!=mat.size()-1){mat[i+1][j]^=1;}\\n    \\n        if(j!=0){mat[i][j-1]^=1;}\\n      \\n        if(j!=mat[0].size()-1){mat[i][j+1]^=1;}\\n       \\n    }\\n    bool check(vector<vector<int>> &mat)\\n    {\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n         if(check(mat)) return 0;\\n         if(mat.size()==1&&mat[0].size()==1) return 1;\\n         vector<vector<bool>> c;\\n         vector<bool> v(mat[0].size(),false);\\n         bool checker=false;\\n             for(int j=0;j<mat.size();j++)\\n             {\\n                 c.push_back(v);\\n             }\\n         \\n         for(int i=1;i<mat.size()*mat[0].size()+1;i++)\\n         {\\n             helper(i,mat,c,0,checker,0);\\n             if(checker) return i;\\n         }\\n         return -1;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169639,
                "title": "c-backtracking",
                "content": "***BACKTRACKING***\\n\\n![image.png](https://assets.leetcode.com/users/images/6e6e21c2-e32b-494c-88e4-6c45d6b7db08_1676062473.5129201.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    int ans;\\n    void flip(vector<vector<int>>& mat,int i,int j){\\n        mat[i][j]=!mat[i][j];\\n        if(i>0) mat[i-1][j]=!mat[i-1][j];\\n        if(j>0) mat[i][j-1]=!mat[i][j-1];\\n        if(i<m-1) mat[i+1][j]=!mat[i+1][j];\\n        if(j<n-1) mat[i][j+1]=!mat[i][j+1];\\n    }\\n    bool zeromat(vector<vector<int>>& mat){\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j])return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void backtrack(vector<vector<int>>& mat , int steps, int i, int j){\\n        if(j==n){\\n            j=0;\\n            i++;\\n        }\\n        if(i==m){\\n            if(zeromat(mat)) ans = min(steps,ans);\\n            return;\\n        }\\n        if((i>0 && j>0)&& mat[i-1][j-1]==1) return;\\n        backtrack(mat,steps,i,j+1);\\n        flip(mat,i,j);\\n        backtrack(mat,steps+1,i,j+1);\\n        flip(mat,i,j);\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        if(m==1 && n==1)return mat[0][0];\\n        ans = INT_MAX;\\n        backtrack(mat,0,0,0);\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    int ans;\\n    void flip(vector<vector<int>>& mat,int i,int j){\\n        mat[i][j]=!mat[i][j];\\n        if(i>0) mat[i-1][j]=!mat[i-1][j];\\n        if(j>0) mat[i][j-1]=!mat[i][j-1];\\n        if(i<m-1) mat[i+1][j]=!mat[i+1][j];\\n        if(j<n-1) mat[i][j+1]=!mat[i][j+1];\\n    }\\n    bool zeromat(vector<vector<int>>& mat){\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j])return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void backtrack(vector<vector<int>>& mat , int steps, int i, int j){\\n        if(j==n){\\n            j=0;\\n            i++;\\n        }\\n        if(i==m){\\n            if(zeromat(mat)) ans = min(steps,ans);\\n            return;\\n        }\\n        if((i>0 && j>0)&& mat[i-1][j-1]==1) return;\\n        backtrack(mat,steps,i,j+1);\\n        flip(mat,i,j);\\n        backtrack(mat,steps+1,i,j+1);\\n        flip(mat,i,j);\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        if(m==1 && n==1)return mat[0][0];\\n        ans = INT_MAX;\\n        backtrack(mat,0,0,0);\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843918,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n//from rony_the_loser\\nclass Solution {\\npublic:\\n    void flip(int i, int j, vector<vector<int> > &adj) \\n{\\n    int m = adj.size(), n = adj[0].size();\\n    \\n    adj[i][j] ^= 1;\\n    \\n    if(i-1 >= 0)\\n    {\\n        adj[i-1][j] ^= 1;\\n    }\\n    if(i+1 < m)\\n    {\\n        adj[i+1][j] ^= 1;\\n    }\\n    \\n    if(j-1>= 0)\\n    {\\n        adj[i][j-1] ^= 1;\\n    }\\n    if(j+1<n)\\n    {\\n        adj[i][j+1] ^= 1;\\n    }\\n}\\n\\n\\nbool all_zero(vector<vector<int>>& mat)\\n{\\n    \\n    for(int i=0; i<mat.size(); i++)\\n    {\\n        for(int j=0; j<mat[0].size(); j++)\\n        {\\n            if(mat[i][j] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    return true;\\n}\\nint minFlips(vector<vector<int>>& mat) \\n{\\n   \\n    if(all_zero(mat))\\n    {\\n        return 0;\\n    }\\n    \\n    map<vector<vector<int>>,int> mp;\\n    \\n    queue<vector<vector<int>>> q;\\n    \\n    set<vector<vector<int>>> visited;\\n    \\n    q.push(mat);\\n    \\n    mp[mat] = 0;\\n    \\n    visited.insert(mat);\\n    \\n    while(!q.empty())\\n    {\\n        auto cur = q.front();\\n        q.pop();\\n        \\n        auto adj = cur;\\n        \\n        for(int i=0; i<adj.size(); i++)\\n        {\\n            for(int j=0; j<adj[0].size(); j++)\\n            {\\n                flip(i,j,adj);\\n                \\n                if(all_zero(adj))\\n                {\\n                    return 1+mp[cur];\\n                }\\n                if(visited.find(adj) == visited.end())\\n                {\\n                    visited.insert(adj);\\n                    mp[adj] = 1 + mp[cur];\\n                    q.push(adj);\\n                }\\n                \\n                flip(i,j,adj);\\n            }\\n        }\\n    }\\n    \\n    return -1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from rony_the_loser\\nclass Solution {\\npublic:\\n    void flip(int i, int j, vector<vector<int> > &adj) \\n{\\n    int m = adj.size(), n = adj[0].size();\\n    \\n    adj[i][j] ^= 1;\\n    \\n    if(i-1 >= 0)\\n    {\\n        adj[i-1][j] ^= 1;\\n    }\\n    if(i+1 < m)\\n    {\\n        adj[i+1][j] ^= 1;\\n    }\\n    \\n    if(j-1>= 0)\\n    {\\n        adj[i][j-1] ^= 1;\\n    }\\n    if(j+1<n)\\n    {\\n        adj[i][j+1] ^= 1;\\n    }\\n}\\n\\n\\nbool all_zero(vector<vector<int>>& mat)\\n{\\n    \\n    for(int i=0; i<mat.size(); i++)\\n    {\\n        for(int j=0; j<mat[0].size(); j++)\\n        {\\n            if(mat[i][j] != 0)\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    return true;\\n}\\nint minFlips(vector<vector<int>>& mat) \\n{\\n   \\n    if(all_zero(mat))\\n    {\\n        return 0;\\n    }\\n    \\n    map<vector<vector<int>>,int> mp;\\n    \\n    queue<vector<vector<int>>> q;\\n    \\n    set<vector<vector<int>>> visited;\\n    \\n    q.push(mat);\\n    \\n    mp[mat] = 0;\\n    \\n    visited.insert(mat);\\n    \\n    while(!q.empty())\\n    {\\n        auto cur = q.front();\\n        q.pop();\\n        \\n        auto adj = cur;\\n        \\n        for(int i=0; i<adj.size(); i++)\\n        {\\n            for(int j=0; j<adj[0].size(); j++)\\n            {\\n                flip(i,j,adj);\\n                \\n                if(all_zero(adj))\\n                {\\n                    return 1+mp[cur];\\n                }\\n                if(visited.find(adj) == visited.end())\\n                {\\n                    visited.insert(adj);\\n                    mp[adj] = 1 + mp[cur];\\n                    q.push(adj);\\n                }\\n                \\n                flip(i,j,adj);\\n            }\\n        }\\n    }\\n    \\n    return -1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607250,
                "title": "bfs-clean-code-c-striver-bhaiya-s-way",
                "content": "```\\nclass Solution {\\npublic:\\n    //to check if all the elements in the matrix are 0 or not\\n    bool check(vector<vector<int>>&matrix){\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    //to flip the matrix\\n    void flipMatrix(vector<vector<int>>&matrix,int row,int column){\\n        int rows=matrix.size();\\n        int columns=matrix[0].size();\\n        \\n        matrix[row][column]=1^matrix[row][column];\\n        \\n        vector<int>delRow={-1,0,1,0};\\n        vector<int>delColumn={0,1,0,-1};\\n        \\n        for(int i=0;i<4;i++){\\n            int nrow=row+delRow[i];\\n            int ncolumn=column+delColumn[i];\\n            \\n            if(nrow>=0 and nrow<rows and ncolumn>=0 and ncolumn<columns)\\n                matrix[nrow][ncolumn]=1^matrix[nrow][ncolumn];\\n        }\\n    }\\n    \\n    //bfs approach\\n    int minFlips(vector<vector<int>>& mat) {\\n       \\n        map<vector<vector<int>>,int> visited;\\n        queue<pair<vector<vector<int>>,int>>q;\\n        \\n        q.push({mat,0});\\n        visited[mat]=1;\\n        \\n        while(!q.empty()){\\n            vector<vector<int>>temp=q.front().first;\\n            int steps=q.front().second;\\n            q.pop();\\n                \\n            if(check(temp))\\n                return steps;\\n                \\n            for(int row=0;row<mat.size();row++){\\n                for(int column=0;column<mat[0].size();column++){\\n                    vector<vector<int>>v=temp;\\n                    flipMatrix(v,row,column);\\n                    if(visited[v]==0){\\n                        q.push({v,steps+1});\\n                        visited[v]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //to check if all the elements in the matrix are 0 or not\\n    bool check(vector<vector<int>>&matrix){\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    //to flip the matrix\\n    void flipMatrix(vector<vector<int>>&matrix,int row,int column){\\n        int rows=matrix.size();\\n        int columns=matrix[0].size();\\n        \\n        matrix[row][column]=1^matrix[row][column];\\n        \\n        vector<int>delRow={-1,0,1,0};\\n        vector<int>delColumn={0,1,0,-1};\\n        \\n        for(int i=0;i<4;i++){\\n            int nrow=row+delRow[i];\\n            int ncolumn=column+delColumn[i];\\n            \\n            if(nrow>=0 and nrow<rows and ncolumn>=0 and ncolumn<columns)\\n                matrix[nrow][ncolumn]=1^matrix[nrow][ncolumn];\\n        }\\n    }\\n    \\n    //bfs approach\\n    int minFlips(vector<vector<int>>& mat) {\\n       \\n        map<vector<vector<int>>,int> visited;\\n        queue<pair<vector<vector<int>>,int>>q;\\n        \\n        q.push({mat,0});\\n        visited[mat]=1;\\n        \\n        while(!q.empty()){\\n            vector<vector<int>>temp=q.front().first;\\n            int steps=q.front().second;\\n            q.pop();\\n                \\n            if(check(temp))\\n                return steps;\\n                \\n            for(int row=0;row<mat.size();row++){\\n                for(int column=0;column<mat[0].size();column++){\\n                    vector<vector<int>>v=temp;\\n                    flipMatrix(v,row,column);\\n                    if(visited[v]==0){\\n                        q.push({v,steps+1});\\n                        visited[v]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500637,
                "title": "bfs-make-matrix-into-string-then-make-it-zero-string",
                "content": "class Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int c=0,n=mat[0].size(),m=mat.size();\\n        string nz=\"\";\\n        string s=\"\";\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                s+=to_string(mat[i][j]);\\n                    nz+=\"0\";\\n                \\n            }\\n        }\\n            if(nz==s)\\n                return 0;\\n            unordered_map<string,bool>vis;\\n            queue<string>q;\\n            q.push(s);\\n            vis[s]=1;\\n            \\n            while(!q.empty()){\\n                int sz=q.size();\\n                c++;\\n                while(sz--){\\n                    string cur=q.front();\\n                    q.pop();\\n                    for(int k=0;k<cur.size();k++){\\n                        int i=k/n;\\n                        int j=k-i*n;\\n                        string t=cur;\\n                        t[k]=(char)(int(t[k])^1);\\n                        \\n                        // flip(c) neighbours\\n                        \\n                        //bottom\\n                        int ni=j+(i+1)*n;\\n                        if(ni<m*n && ni>=0)\\n                             t[ni]=(char)(int(t[ni])^1);\\n                        \\n                        //top\\n                         ni=j+(i-1)*n;\\n                        if(ni<m*n && ni>=0)\\n                             t[ni]=(char)(int(t[ni])^1);\\n                        \\n                        //right (new condition for avoid diagonal link)\\n                         ni=(j+1)+i*n;\\n                        if(ni<m*n && ni>=0 && j!=n-1)\\n                             t[ni]=(char)(int(t[ni])^1);\\n                        \\n                        //left (new condition for avoid diagonal link)\\n                         ni=(j-1)+i*n;\\n                        if(ni<m*n && ni>=0 && j!=0)\\n                             t[ni]=(char)(int(t[ni])^1);\\n                        \\n                        if(t==nz)\\n                            return c;\\n                        \\n                        if(!vis[t]){\\n                            q.push(t);\\n                            vis[t]=1;\\n                        }\\n                        \\n                    }\\n                }\\n            \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int c=0,n=mat[0].size(),m=mat.size();\\n        string nz=\"\";\\n        string s=\"\";\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                s+=to_string(mat[i][j]);\\n                    nz+=\"0\";\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2133275,
                "title": "c-backtracking-bfs-state-management",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    queue<pair<pair<int, int>, vector<vector<int>>>> q;\\n    unordered_set<string> set;\\n    vector<int> DIR = {1, 0, -1, 0, 1};    \\n    string ans = \"\";\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size(), m = mat[0].size();\\n        ans = string(n * m, \\'0\\');\\n        string s = serialize(mat);\\n        if(s == ans) return 0;\\n        set.insert(s);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(mat[i][j])\\n                    add(i, j, mat);\\n        return helper();\\n    }\\n    string serialize(vector<vector<int>>& A){\\n        string result = \"\";\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                result += A[i][j] + \\'0\\';\\n        return result;\\n    }\\n    void add(int r, int c, vector<vector<int>>& state){\\n        q.push({{r,c}, state});\\n        for(int k = 0; k < 4; k++){\\n            int nr = r + DIR[k], nc = c + DIR[k + 1];\\n            if(nr < 0 || nc < 0 || nr == n || nc == m)\\n                continue;\\n            q.push({{nr, nc}, state});\\n        }\\n    }\\n    int helper(){\\n        int count = 1;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++){\\n                auto temp = q.front();\\n                // {{coordinates}, state}\\n                q.pop();\\n                auto [r, c] = temp.first;\\n                auto state = temp.second;\\n                string a = serialize(state);\\n                state[r][c] += state[r][c] == 0 ? 1 : -1;\\n                for(int k = 0; k < 4; k++){\\n                    int nr = r + DIR[k], nc = c + DIR[k + 1];\\n                        if(nr < 0 || nc < 0 || nr == n || nc == m)\\n                            continue;\\n                    state[nr][nc] += state[nr][nc] == 0 ? 1 : -1;\\n                }\\n                string s = serialize(state);\\n                if(s == ans) return count;\\n                if(set.find(s) != set.end()) continue;\\n                set.insert(s);\\n                for(int i = 0; i < n; i++)\\n                    for(int j = 0; j < m; j++)\\n                        if(state[i][j])\\n                            add(i, j, state);\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    queue<pair<pair<int, int>, vector<vector<int>>>> q;\\n    unordered_set<string> set;\\n    vector<int> DIR = {1, 0, -1, 0, 1};    \\n    string ans = \"\";\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size(), m = mat[0].size();\\n        ans = string(n * m, \\'0\\');\\n        string s = serialize(mat);\\n        if(s == ans) return 0;\\n        set.insert(s);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(mat[i][j])\\n                    add(i, j, mat);\\n        return helper();\\n    }\\n    string serialize(vector<vector<int>>& A){\\n        string result = \"\";\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                result += A[i][j] + \\'0\\';\\n        return result;\\n    }\\n    void add(int r, int c, vector<vector<int>>& state){\\n        q.push({{r,c}, state});\\n        for(int k = 0; k < 4; k++){\\n            int nr = r + DIR[k], nc = c + DIR[k + 1];\\n            if(nr < 0 || nc < 0 || nr == n || nc == m)\\n                continue;\\n            q.push({{nr, nc}, state});\\n        }\\n    }\\n    int helper(){\\n        int count = 1;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++){\\n                auto temp = q.front();\\n                // {{coordinates}, state}\\n                q.pop();\\n                auto [r, c] = temp.first;\\n                auto state = temp.second;\\n                string a = serialize(state);\\n                state[r][c] += state[r][c] == 0 ? 1 : -1;\\n                for(int k = 0; k < 4; k++){\\n                    int nr = r + DIR[k], nc = c + DIR[k + 1];\\n                        if(nr < 0 || nc < 0 || nr == n || nc == m)\\n                            continue;\\n                    state[nr][nc] += state[nr][nc] == 0 ? 1 : -1;\\n                }\\n                string s = serialize(state);\\n                if(s == ans) return count;\\n                if(set.find(s) != set.end()) continue;\\n                set.insert(s);\\n                for(int i = 0; i < n; i++)\\n                    for(int j = 0; j < m; j++)\\n                        if(state[i][j])\\n                            add(i, j, state);\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121093,
                "title": "java-bfs-simple-solution",
                "content": "```\\npublic int minFlips(int[][] mat) {\\n        if (mat == null || mat.length == 0 || mat[0] == null || mat[0].length == 0) return 0;\\n        \\n        Queue<int[][]> qu = new LinkedList<>();\\n        Set<String> set = new HashSet<>();\\n        int count = 0;\\n        qu.offer(mat);\\n        set.add(getKey(mat));\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] dirs = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        while(!qu.isEmpty()) {\\n            int size = qu.size();\\n            for(int ii = 0; ii < size; ii++) {\\n                int[][] cur = qu.poll();\\n                if (isAns(cur)) return count;\\n                \\n                // add possible stuff into queue\\n                for(int i = 0; i < m; i++) {\\n                    for(int j = 0; j < n; j++) {\\n                        int[][] copy = deepCopy(cur);\\n                        \\n                        copy[i][j] = 1 - copy[i][j];\\n                        \\n                        for(int[] dir : dirs) {\\n                            int x = i + dir[0];\\n                            int y = j + dir[1];\\n                            \\n                            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n                            copy[x][y] = 1 - copy[x][y];\\n                        }\\n                        String key = getKey(copy);\\n                        if (set.contains(key)) continue;\\n                        set.add(key);\\n                        qu.offer(copy);\\n                    }\\n                }\\n            }\\n            \\n            count++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private String getKey(int[][] mat) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                sb.append(mat[i][j]+\"\");\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private boolean isAns(int[][] mat) {\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if (mat[i][j] != 0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int[][] deepCopy(int[][] mat) {\\n        int[][] res = new int[mat.length][mat[0].length];\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                res[i][j] = mat[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minFlips(int[][] mat) {\\n        if (mat == null || mat.length == 0 || mat[0] == null || mat[0].length == 0) return 0;\\n        \\n        Queue<int[][]> qu = new LinkedList<>();\\n        Set<String> set = new HashSet<>();\\n        int count = 0;\\n        qu.offer(mat);\\n        set.add(getKey(mat));\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] dirs = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        while(!qu.isEmpty()) {\\n            int size = qu.size();\\n            for(int ii = 0; ii < size; ii++) {\\n                int[][] cur = qu.poll();\\n                if (isAns(cur)) return count;\\n                \\n                // add possible stuff into queue\\n                for(int i = 0; i < m; i++) {\\n                    for(int j = 0; j < n; j++) {\\n                        int[][] copy = deepCopy(cur);\\n                        \\n                        copy[i][j] = 1 - copy[i][j];\\n                        \\n                        for(int[] dir : dirs) {\\n                            int x = i + dir[0];\\n                            int y = j + dir[1];\\n                            \\n                            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n                            copy[x][y] = 1 - copy[x][y];\\n                        }\\n                        String key = getKey(copy);\\n                        if (set.contains(key)) continue;\\n                        set.add(key);\\n                        qu.offer(copy);\\n                    }\\n                }\\n            }\\n            \\n            count++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private String getKey(int[][] mat) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                sb.append(mat[i][j]+\"\");\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private boolean isAns(int[][] mat) {\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if (mat[i][j] != 0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int[][] deepCopy(int[][] mat) {\\n        int[][] res = new int[mat.length][mat[0].length];\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                res[i][j] = mat[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2056800,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    private int minFlips;\\n    private int[][] matrix;\\n    private int[][] visited;\\n    \\n    public int minFlips(int[][] mat) {\\n        this.matrix = mat;\\n        this.visited = new int[mat.length][mat[0].length];\\n        this.minFlips = -1;\\n        \\n        backtrack(0);\\n        \\n        return this.minFlips;\\n    }\\n    \\n    private void backtrack(int flips) {\\n        if (isZero(matrix)) {\\n            this.minFlips = this.minFlips == -1 ? flips : Math.min(this.minFlips, flips);\\n            return;\\n        }\\n        \\n        for (int i = 0; i < matrix.length; i ++) {\\n            for (int j = 0; j < matrix[i].length; j ++) {\\n                if (visited[i][j] == 1) {\\n                    continue;\\n                }\\n                \\n                flip(i, j);\\n                \\n                backtrack(flips + 1);\\n                \\n                flip(i, j);\\n            }\\n        }\\n    }\\n    \\n    private boolean isZero(int[][] mat) {\\n        for (int[] r : mat) {\\n            for (int c : r) {\\n                if (c > 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void flip(int row, int col) {\\n        matrix[row][col] ^= 1;\\n        visited[row][col] ^= 1;\\n\\n        int left = col - 1;\\n        if (left >= 0) {\\n            matrix[row][left] ^= 1;\\n        }\\n        int right = col + 1;\\n        if (right < matrix[row].length) {\\n            matrix[row][right] ^= 1;\\n        }\\n        int top = row - 1;\\n        if (top >= 0) {\\n            matrix[top][col] ^= 1;\\n        }\\n        int bottom = row + 1;\\n        if (bottom < matrix.length) {\\n            matrix[bottom][col] ^= 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int minFlips;\\n    private int[][] matrix;\\n    private int[][] visited;\\n    \\n    public int minFlips(int[][] mat) {\\n        this.matrix = mat;\\n        this.visited = new int[mat.length][mat[0].length];\\n        this.minFlips = -1;\\n        \\n        backtrack(0);\\n        \\n        return this.minFlips;\\n    }\\n    \\n    private void backtrack(int flips) {\\n        if (isZero(matrix)) {\\n            this.minFlips = this.minFlips == -1 ? flips : Math.min(this.minFlips, flips);\\n            return;\\n        }\\n        \\n        for (int i = 0; i < matrix.length; i ++) {\\n            for (int j = 0; j < matrix[i].length; j ++) {\\n                if (visited[i][j] == 1) {\\n                    continue;\\n                }\\n                \\n                flip(i, j);\\n                \\n                backtrack(flips + 1);\\n                \\n                flip(i, j);\\n            }\\n        }\\n    }\\n    \\n    private boolean isZero(int[][] mat) {\\n        for (int[] r : mat) {\\n            for (int c : r) {\\n                if (c > 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private void flip(int row, int col) {\\n        matrix[row][col] ^= 1;\\n        visited[row][col] ^= 1;\\n\\n        int left = col - 1;\\n        if (left >= 0) {\\n            matrix[row][left] ^= 1;\\n        }\\n        int right = col + 1;\\n        if (right < matrix[row].length) {\\n            matrix[row][right] ^= 1;\\n        }\\n        int top = row - 1;\\n        if (top >= 0) {\\n            matrix[top][col] ^= 1;\\n        }\\n        int bottom = row + 1;\\n        if (bottom < matrix.length) {\\n            matrix[bottom][col] ^= 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970784,
                "title": "java-bfs-with-bitmask",
                "content": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        \\n        int[][] dirs = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        \\n        Queue<Integer> q = new ArrayDeque<>();\\n        int steps = 0;\\n        \\n        int state = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (mat[i][j] == 1)\\n                    state += 1 << (i * m + j);\\n            }\\n        }\\n        \\n        visited.add(state);\\n        q.add(state);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            \\n            while (size-- > 0) {\\n                state = q.poll();\\n                \\n                if (state == 0)\\n                    return steps;\\n                \\n                for (int i = 0; i < n; i++) {\\n                    for (int j = 0; j < m; j++) {\\n                        int newState = state;\\n\\n                        newState += flip(newState, i * m + j);\\n\\n                        for (int[] d : dirs) {\\n                            int ni = i + d[0];\\n                            int nj = j + d[1];\\n\\n                            if (ni < 0 || ni == n || nj < 0 || nj == m)\\n                                continue;\\n\\n                            newState += flip(newState, ni * m + nj);                                                                \\n                        }\\n\\n                        if (visited.contains(newState))\\n                            continue;\\n\\n                        visited.add(newState);\\n                        q.add(newState);\\n                    }\\n                }\\n            }\\n            \\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n\\n    private int flip(int state, int i) {\\n        return (state & (1 << i)) == (1 << i) ? -(1 << i) : 1 << i;\\n    }\\n}\\n\\n// 100\\n// 000\\n// 000\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        \\n        int[][] dirs = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        \\n        Queue<Integer> q = new ArrayDeque<>();\\n        int steps = 0;\\n        \\n        int state = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (mat[i][j] == 1)\\n                    state += 1 << (i * m + j);\\n            }\\n        }\\n        \\n        visited.add(state);\\n        q.add(state);\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            \\n            while (size-- > 0) {\\n                state = q.poll();\\n                \\n                if (state == 0)\\n                    return steps;\\n                \\n                for (int i = 0; i < n; i++) {\\n                    for (int j = 0; j < m; j++) {\\n                        int newState = state;\\n\\n                        newState += flip(newState, i * m + j);\\n\\n                        for (int[] d : dirs) {\\n                            int ni = i + d[0];\\n                            int nj = j + d[1];\\n\\n                            if (ni < 0 || ni == n || nj < 0 || nj == m)\\n                                continue;\\n\\n                            newState += flip(newState, ni * m + nj);                                                                \\n                        }\\n\\n                        if (visited.contains(newState))\\n                            continue;\\n\\n                        visited.add(newState);\\n                        q.add(newState);\\n                    }\\n                }\\n            }\\n            \\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n\\n    private int flip(int state, int i) {\\n        return (state & (1 << i)) == (1 << i) ? -(1 << i) : 1 << i;\\n    }\\n}\\n\\n// 100\\n// 000\\n// 000\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873826,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinFlips(int[][] mat) \\n    {\\n        HashSet<string> visited = new();\\n        string matrixString = RepMatrixAsString(mat);\\n        \\n        Queue<(int[][] myMat, int flips)> qu = new();\\n        qu.Enqueue((mat,0));\\n        \\n        visited.Add(matrixString);\\n        \\n        while(qu.Count>0)\\n        {\\n            var cur = qu.Dequeue();\\n            \\n            if(IsZeroMatrix(cur.myMat))\\n                return cur.flips;\\n            \\n            for(int i=0; i<cur.myMat.Length; i++)\\n            {\\n                for(int j=0; j<cur.myMat[0].Length; j++)\\n                {\\n                    Flip(cur.myMat,i,j);\\n                    string matAsString = RepMatrixAsString(cur.myMat);\\n                    \\n                    if(visited.Contains(matAsString))\\n                    {\\n                        Flip(cur.myMat,i,j);\\n                        continue;\\n                    }\\n                    \\n                    visited.Add(matAsString);\\n                    qu.Enqueue((GetNewMatrix(cur.myMat),cur.flips+1));\\n                    Flip(cur.myMat,i,j);\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private int[][] GetNewMatrix(int[][] mat) => mat.Select(a => a.ToArray()).ToArray();\\n    \\n    private bool IsZeroMatrix(int[][] mat)\\n    {\\n        for(int i=0; i<mat.Length; i++)\\n        {\\n            for(int j=0; j<mat[0].Length; j++)\\n            {\\n                if(mat[i][j]==1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private string RepMatrixAsString(int[][] mat)\\n    {\\n        StringBuilder sb = new();\\n        \\n        for(int i=0; i<mat.Length; i++)\\n        {\\n            for(int j=0; j<mat[0].Length; j++)\\n            {\\n                sb.Append(Convert.ToString(mat[i][j]) + \"-\");\\n            }\\n        }\\n        \\n        return sb.ToString();\\n    }\\n    \\n    private void Flip(int[][] mat, int x, int y)\\n    {\\n        int[] xDir = {-1,1,0,0};\\n        int[] yDir = {0,0,-1,1};\\n        \\n        mat[x][y] = mat[x][y] == 0 ? 1 : 0;\\n        \\n        for(int i=0;i<4;i++)\\n        {\\n            int m = x + xDir[i];\\n            int n = y + yDir[i];\\n            \\n            if(m<0 || m>=mat.Length || n<0 || n>=mat[0].Length)\\n                continue;\\n            \\n            mat[m][n] = mat[m][n] == 0 ? 1 : 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinFlips(int[][] mat) \\n    {\\n        HashSet<string> visited = new();\\n        string matrixString = RepMatrixAsString(mat);\\n        \\n        Queue<(int[][] myMat, int flips)> qu = new();\\n        qu.Enqueue((mat,0));\\n        \\n        visited.Add(matrixString);\\n        \\n        while(qu.Count>0)\\n        {\\n            var cur = qu.Dequeue();\\n            \\n            if(IsZeroMatrix(cur.myMat))\\n                return cur.flips;\\n            \\n            for(int i=0; i<cur.myMat.Length; i++)\\n            {\\n                for(int j=0; j<cur.myMat[0].Length; j++)\\n                {\\n                    Flip(cur.myMat,i,j);\\n                    string matAsString = RepMatrixAsString(cur.myMat);\\n                    \\n                    if(visited.Contains(matAsString))\\n                    {\\n                        Flip(cur.myMat,i,j);\\n                        continue;\\n                    }\\n                    \\n                    visited.Add(matAsString);\\n                    qu.Enqueue((GetNewMatrix(cur.myMat),cur.flips+1));\\n                    Flip(cur.myMat,i,j);\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private int[][] GetNewMatrix(int[][] mat) => mat.Select(a => a.ToArray()).ToArray();\\n    \\n    private bool IsZeroMatrix(int[][] mat)\\n    {\\n        for(int i=0; i<mat.Length; i++)\\n        {\\n            for(int j=0; j<mat[0].Length; j++)\\n            {\\n                if(mat[i][j]==1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private string RepMatrixAsString(int[][] mat)\\n    {\\n        StringBuilder sb = new();\\n        \\n        for(int i=0; i<mat.Length; i++)\\n        {\\n            for(int j=0; j<mat[0].Length; j++)\\n            {\\n                sb.Append(Convert.ToString(mat[i][j]) + \"-\");\\n            }\\n        }\\n        \\n        return sb.ToString();\\n    }\\n    \\n    private void Flip(int[][] mat, int x, int y)\\n    {\\n        int[] xDir = {-1,1,0,0};\\n        int[] yDir = {0,0,-1,1};\\n        \\n        mat[x][y] = mat[x][y] == 0 ? 1 : 0;\\n        \\n        for(int i=0;i<4;i++)\\n        {\\n            int m = x + xDir[i];\\n            int n = y + yDir[i];\\n            \\n            if(m<0 || m>=mat.Length || n<0 || n>=mat[0].Length)\\n                continue;\\n            \\n            mat[m][n] = mat[m][n] == 0 ? 1 : 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863773,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToString(vector<vector<int>> m)\\n    {\\n        string ans = \"\";\\n        for (int i=0; i<m.size(); i++)\\n        {\\n            for (int j=0; j<m[0].size(); j++)\\n            {\\n                ans += to_string(m[i][j]);\\n            }\\n        }\\n        //cout<<ans<<endl;\\n        return ans;\\n    }\\n    \\n    vector<vector<int>> flip(vector<vector<int>> mat, int i, int j)\\n    {\\n        vector<vector<int>> dir = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        int r = mat.size(), c = mat[0].size();\\n        \\n        mat[i][j] ^= 1;\\n        \\n        for(auto d :dir)\\n        {\\n            int x = i + d[0], y = j+d[1];\\n            if (x<0 || x >= r || y < 0 || y >= c)\\n                continue;\\n            mat[x][y] ^= 1;\\n        }\\n        return mat;\\n    }\\n    \\n    int getSum(vector<vector<int>> mat)\\n    {\\n        int sum = 0;\\n        for (int i=0; i<mat.size(); i++)\\n        {\\n            for (int j=0; j<mat[0].size(); j++)\\n                sum += mat[i][j];\\n        }\\n        //cout<<sum<<endl;\\n        return sum;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        \\n        unordered_set<string> visited;\\n        int m = mat.size(), n = mat[0].size();\\n        queue<vector<vector<int>>> q;\\n        q.push(mat);\\n        \\n        int step = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for (int i=0; i<size; i++)\\n            {\\n                vector<vector<int>> node = q.front();\\n                q.pop();\\n                if (getSum(node) == 0)\\n                    return step;\\n                for (int j=0; j<m; j++)\\n                {\\n                    for (int k=0; k<n; k++)\\n                    {\\n                        vector<vector<int>> newNode = flip(node, j, k);\\n                        string hashNode = convertToString(newNode);\\n                        \\n                        if (visited.find(hashNode) != visited.end())\\n                            continue;\\n                        \\n                        q.push(newNode);\\n                        visited.insert(hashNode);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToString(vector<vector<int>> m)\\n    {\\n        string ans = \"\";\\n        for (int i=0; i<m.size(); i++)\\n        {\\n            for (int j=0; j<m[0].size(); j++)\\n            {\\n                ans += to_string(m[i][j]);\\n            }\\n        }\\n        //cout<<ans<<endl;\\n        return ans;\\n    }\\n    \\n    vector<vector<int>> flip(vector<vector<int>> mat, int i, int j)\\n    {\\n        vector<vector<int>> dir = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        int r = mat.size(), c = mat[0].size();\\n        \\n        mat[i][j] ^= 1;\\n        \\n        for(auto d :dir)\\n        {\\n            int x = i + d[0], y = j+d[1];\\n            if (x<0 || x >= r || y < 0 || y >= c)\\n                continue;\\n            mat[x][y] ^= 1;\\n        }\\n        return mat;\\n    }\\n    \\n    int getSum(vector<vector<int>> mat)\\n    {\\n        int sum = 0;\\n        for (int i=0; i<mat.size(); i++)\\n        {\\n            for (int j=0; j<mat[0].size(); j++)\\n                sum += mat[i][j];\\n        }\\n        //cout<<sum<<endl;\\n        return sum;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        \\n        unordered_set<string> visited;\\n        int m = mat.size(), n = mat[0].size();\\n        queue<vector<vector<int>>> q;\\n        q.push(mat);\\n        \\n        int step = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for (int i=0; i<size; i++)\\n            {\\n                vector<vector<int>> node = q.front();\\n                q.pop();\\n                if (getSum(node) == 0)\\n                    return step;\\n                for (int j=0; j<m; j++)\\n                {\\n                    for (int k=0; k<n; k++)\\n                    {\\n                        vector<vector<int>> newNode = flip(node, j, k);\\n                        string hashNode = convertToString(newNode);\\n                        \\n                        if (visited.find(hashNode) != visited.end())\\n                            continue;\\n                        \\n                        q.push(newNode);\\n                        visited.insert(hashNode);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1858263,
                "title": "python-3-bfs-and-bit-manipulation-approach-with-comments",
                "content": "Vote up if you like. Leave comments when you have any questions. \\n```\\ndef minFlips(self, mat: List[List[int]]) -> int:\\n\\t\\'\\'\\'\\n\\tbasic idea: convert mat to integers\\n\\tsuch as [[1,0],[0,0]] to 0001 which is 1, [[1,0],[1,0]] to 0101 which is 5\\n\\tthen use BFS to traverse and flip all elements\\n\\t\\'\\'\\'\\n\\tm, n = len(mat), len(mat[0])\\n\\tdirs = [0, 1, 0, -1, 0, 0]\\n\\tstart = 0\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\t#intial status, collect all 1s\\n\\t\\t\\tstart |= (mat[i][j] << (i * n + j))\\n\\n\\tdef flip(s, x, y):\\n\\t\\t\\'\\'\\'\\n\\t\\tflip  up, down, left, right elements, including istelf\\n\\t\\t\\'\\'\\'\\n\\t\\tfor i in range(5):\\n\\t\\t\\tnewx, newy = x + dirs[i], y + dirs[i+1]\\n\\t\\t\\tif 0 <= newx < m and 0 <= newy < n:\\n\\t\\t\\t\\t#flip, use XOR\\n\\t\\t\\t\\ts ^= (1 << (newx*n + newy))\\n\\t\\treturn s \\n\\n\\tque = collections.deque()\\n\\tque.append(start)\\n\\tstep = 0\\n\\t#do not flip more than 1 time. from 0001 to 1111. 1 to 2^(m*n)-1\\n\\tseen = [0] * (1 << m*n)\\n\\tseen[start] = 1\\n\\t#BFS\\n\\twhile que:\\n\\t\\tlength = len(que)\\n\\t\\tfor _ in range(length):\\n\\t\\t\\ts = que.popleft()\\n\\t\\t\\t#all 0, then return step\\n\\t\\t\\tif s == 0:\\n\\t\\t\\t\\treturn step\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tflipped = flip(s, i, j)\\n\\t\\t\\t\\t\\tif seen[flipped] == 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tseen[flipped] = 1\\n\\t\\t\\t\\t\\tque.append(flipped)\\n\\t\\t#print(seen)\\n\\t\\tstep += 1\\n\\treturn -1\\n```\\n\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minFlips(self, mat: List[List[int]]) -> int:\\n\\t\\'\\'\\'\\n\\tbasic idea: convert mat to integers\\n\\tsuch as [[1,0],[0,0]] to 0001 which is 1, [[1,0],[1,0]] to 0101 which is 5\\n\\tthen use BFS to traverse and flip all elements\\n\\t\\'\\'\\'\\n\\tm, n = len(mat), len(mat[0])\\n\\tdirs = [0, 1, 0, -1, 0, 0]\\n\\tstart = 0\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\t#intial status, collect all 1s\\n\\t\\t\\tstart |= (mat[i][j] << (i * n + j))\\n\\n\\tdef flip(s, x, y):\\n\\t\\t\\'\\'\\'\\n\\t\\tflip  up, down, left, right elements, including istelf\\n\\t\\t\\'\\'\\'\\n\\t\\tfor i in range(5):\\n\\t\\t\\tnewx, newy = x + dirs[i], y + dirs[i+1]\\n\\t\\t\\tif 0 <= newx < m and 0 <= newy < n:\\n\\t\\t\\t\\t#flip, use XOR\\n\\t\\t\\t\\ts ^= (1 << (newx*n + newy))\\n\\t\\treturn s \\n\\n\\tque = collections.deque()\\n\\tque.append(start)\\n\\tstep = 0\\n\\t#do not flip more than 1 time. from 0001 to 1111. 1 to 2^(m*n)-1\\n\\tseen = [0] * (1 << m*n)\\n\\tseen[start] = 1\\n\\t#BFS\\n\\twhile que:\\n\\t\\tlength = len(que)\\n\\t\\tfor _ in range(length):\\n\\t\\t\\ts = que.popleft()\\n\\t\\t\\t#all 0, then return step\\n\\t\\t\\tif s == 0:\\n\\t\\t\\t\\treturn step\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tflipped = flip(s, i, j)\\n\\t\\t\\t\\t\\tif seen[flipped] == 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tseen[flipped] = 1\\n\\t\\t\\t\\t\\tque.append(flipped)\\n\\t\\t#print(seen)\\n\\t\\tstep += 1\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1817907,
                "title": "python-dfs-solution-with-explanation",
                "content": "Key observations needed to solve this prob are as below.\\n\\n1) There is no need to push the same button twice, as it doesn\\'t make any change.\\n\\n2) Sequence of buttons doesn\\'t matter. In the provided example, a possible solution was (1,0)->(0,1)->(1,1). However, any sequences of the three buttons produce the same result.\\n\\n \\n\\nFunctions we need:\\n\\n1) isComplete(): checks whether matrix only has zeros or not\\n\\n2) push(button): pushes the button(int). Here, we use ^ (XOR) operation. (using the fact that 1 ^ 1 = 0 and 1 ^ 0 = 1)\\n\\n \\n\\nFinally: DFS to go through all the cases\\n\\n \\n\\nTime complexity is O(9 * 2 ** 9). That is becasue we have 2**(M*N) cases, and we have to check M*N cells in each case where M, N <= 3.\\n\\n\\\\* # of cases: XC0 + XC1 + XC2 + ... + XCX = 2 ** X, where X=M*N\\n\\n ```\\n class Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        self.mat = mat\\n        m, n = len(self.mat), len(self.mat[0])\\n        buttons = [i for i in range(m*n)]\\n        self.ret = 10\\n        self.dfs(buttons, [])\\n        return self.ret if self.ret != 10 else -1\\n        \\n    def dfs(self, buttons, visited):\\n        if self.isComplete():\\n            self.ret = min(self.ret, len(visited))\\n            return\\n        for i, button in enumerate(buttons):\\n            self.push(button)\\n            self.dfs(buttons[i+1:], visited+[button])\\n            self.push(button)\\n        \\n    def isComplete(self):\\n        m, n = len(self.mat), len(self.mat[0])\\n        for y in range(m):\\n            for x in range(n):\\n                if self.mat[y][x] != 0:\\n                    return False\\n        return True\\n    \\n    def push(self, button):\\n        m, n = len(self.mat), len(self.mat[0])\\n        y, x = button // n, button - button // n * n\\n        self.mat[y][x] ^= 1\\n        dy, dx = [0, 1, 0, -1], [1, 0, -1, 0]\\n        for d in range(4):\\n            next_y, next_x = y + dy[d], x + dx[d]\\n            if 0 <= next_y < m and 0 <= next_x < n:\\n                self.mat[next_y][next_x] ^= 1\\n ```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n class Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        self.mat = mat\\n        m, n = len(self.mat), len(self.mat[0])\\n        buttons = [i for i in range(m*n)]\\n        self.ret = 10\\n        self.dfs(buttons, [])\\n        return self.ret if self.ret != 10 else -1\\n        \\n    def dfs(self, buttons, visited):\\n        if self.isComplete():\\n            self.ret = min(self.ret, len(visited))\\n            return\\n        for i, button in enumerate(buttons):\\n            self.push(button)\\n            self.dfs(buttons[i+1:], visited+[button])\\n            self.push(button)\\n        \\n    def isComplete(self):\\n        m, n = len(self.mat), len(self.mat[0])\\n        for y in range(m):\\n            for x in range(n):\\n                if self.mat[y][x] != 0:\\n                    return False\\n        return True\\n    \\n    def push(self, button):\\n        m, n = len(self.mat), len(self.mat[0])\\n        y, x = button // n, button - button // n * n\\n        self.mat[y][x] ^= 1\\n        dy, dx = [0, 1, 0, -1], [1, 0, -1, 0]\\n        for d in range(4):\\n            next_y, next_x = y + dy[d], x + dx[d]\\n            if 0 <= next_y < m and 0 <= next_x < n:\\n                self.mat[next_y][next_x] ^= 1\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1814391,
                "title": "python-3-convert-matrix-to-string-no-bit-manipulation-bfs-on-strings-code-w-explanation",
                "content": "This is one of the first solutions I am writing. I saw the solutions in the discussion and most of them are to do with bit manipulation. I am not very comfortable with bit manipulation techniques. Hence I decided to make the input matrix hashable by converting it to a string and then using a BFS on the resulting candidates from each string.\\n\\nTime complexity: O(2^mn)\\nSpace complexity: O(2^mn)\\n\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def convertMatrixToString(self, mat):\\n        result = []\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                result.append(str(mat[i][j]))\\n        return \"\".join(result)\\n    \\n    def findCandidates(self, string, m, n):\\n        stringList = list(string)\\n        result = []\\n        for s in range(len(stringList)):\\n            i, j = s//n, s%n\\n            switches = [[i, j], [i-1,j], [i+1,j], [i, j-1], [i, j+1]]\\n            sList = stringList.copy()\\n            for switch in switches:\\n                if 0 <= switch[0] < m and 0<= switch[1] <n:\\n                    can = sList[switch[0]*n + switch[1]]\\n                    if can == \"0\":\\n                        sList[switch[0]*n + switch[1]] = \"1\"\\n                    else:\\n                        sList[switch[0]*n + switch[1]] = \"0\"\\n            result.append(\"\".join(sList))       \\n        return result\\n\\n    \\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat) , len(mat[0])\\n        tot = m * n\\n        target = \"0\" * tot\\n        queue = deque()\\n        queue.append((self.convertMatrixToString(mat), 0))\\n        memo = set()\\n        while queue:\\n            stringMat, count = queue.popleft()\\n            if stringMat == target:\\n                return count\\n            memo.add(stringMat)\\n            candidates = self.findCandidates(stringMat, m, n)\\n            for c in candidates:\\n                if c not in memo:\\n                    memo.add(c)\\n                    if c == target:\\n                        return count + 1\\n                    queue.append((c, count + 1))\\n        return - 1\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def convertMatrixToString(self, mat):\\n        result = []\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                result.append(str(mat[i][j]))\\n        return \"\".join(result)\\n    \\n    def findCandidates(self, string, m, n):\\n        stringList = list(string)\\n        result = []\\n        for s in range(len(stringList)):\\n            i, j = s//n, s%n\\n            switches = [[i, j], [i-1,j], [i+1,j], [i, j-1], [i, j+1]]\\n            sList = stringList.copy()\\n            for switch in switches:\\n                if 0 <= switch[0] < m and 0<= switch[1] <n:\\n                    can = sList[switch[0]*n + switch[1]]\\n                    if can == \"0\":\\n                        sList[switch[0]*n + switch[1]] = \"1\"\\n                    else:\\n                        sList[switch[0]*n + switch[1]] = \"0\"\\n            result.append(\"\".join(sList))       \\n        return result\\n\\n    \\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat) , len(mat[0])\\n        tot = m * n\\n        target = \"0\" * tot\\n        queue = deque()\\n        queue.append((self.convertMatrixToString(mat), 0))\\n        memo = set()\\n        while queue:\\n            stringMat, count = queue.popleft()\\n            if stringMat == target:\\n                return count\\n            memo.add(stringMat)\\n            candidates = self.findCandidates(stringMat, m, n)\\n            for c in candidates:\\n                if c not in memo:\\n                    memo.add(c)\\n                    if c == target:\\n                        return count + 1\\n                    queue.append((c, count + 1))\\n        return - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725655,
                "title": "can-anyone-tell-me-what-is-t-c-of-my-code",
                "content": "I think it is (2^(m*n))*(m*n) .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int check(vector<vector<int>>& mat)\\n    {\\n        int count = 0;\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)if(mat[i][j] == 0)count++;\\n        }\\n        return count == (int)mat.size()*mat[0].size();\\n    }\\n    string convert(vector<vector<int>>& mat)\\n    {\\n        string a;\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)a += \\'0\\' + mat[i][j];\\n        }\\n        return a;\\n    }\\n    \\n    void change(int i,int j,vector<vector<int>>& mat)\\n    {\\n        mat[i][j] = 1 - mat[i][j];\\n        if(i-1>=0)mat[i-1][j] = 1 - mat[i-1][j];\\n        if(i+1<mat.size())mat[i+1][j] = 1 - mat[i+1][j];\\n        if(j-1>=0)mat[i][j-1] = 1 - mat[i][j-1];\\n        if(j+1<mat[0].size())mat[i][j+1] = 1 - mat[i][j+1];\\n    }\\n    \\n    int fun(vector<vector<int>>& mat,unordered_set<string>&mp,unordered_map<string,int>&st)\\n    {\\n        string str = convert(mat);\\n        if(check(mat))return 0;\\n        int ans = 1e6;\\n        if(mp.find(str)!=mp.end())\\n        {\\n            if(st.find(str)!=st.end())return st[str];\\n            return ans;\\n        }\\n        mp.insert(str);\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                change(i,j,mat);\\n                string s = convert(mat);\\n                ans = min(ans,1+fun(mat,mp,st));\\n                change(i,j,mat);\\n            }\\n        }\\n        return st[str] = ans;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        unordered_set<string>mp;\\n        unordered_map<string,int>st;\\n        int val = fun(mat,mp,st);\\n        return val<1000 ? val : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<vector<int>>& mat)\\n    {\\n        int count = 0;\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)if(mat[i][j] == 0)count++;\\n        }\\n        return count == (int)mat.size()*mat[0].size();\\n    }\\n    string convert(vector<vector<int>>& mat)\\n    {\\n        string a;\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)a += \\'0\\' + mat[i][j];\\n        }\\n        return a;\\n    }\\n    \\n    void change(int i,int j,vector<vector<int>>& mat)\\n    {\\n        mat[i][j] = 1 - mat[i][j];\\n        if(i-1>=0)mat[i-1][j] = 1 - mat[i-1][j];\\n        if(i+1<mat.size())mat[i+1][j] = 1 - mat[i+1][j];\\n        if(j-1>=0)mat[i][j-1] = 1 - mat[i][j-1];\\n        if(j+1<mat[0].size())mat[i][j+1] = 1 - mat[i][j+1];\\n    }\\n    \\n    int fun(vector<vector<int>>& mat,unordered_set<string>&mp,unordered_map<string,int>&st)\\n    {\\n        string str = convert(mat);\\n        if(check(mat))return 0;\\n        int ans = 1e6;\\n        if(mp.find(str)!=mp.end())\\n        {\\n            if(st.find(str)!=st.end())return st[str];\\n            return ans;\\n        }\\n        mp.insert(str);\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                change(i,j,mat);\\n                string s = convert(mat);\\n                ans = min(ans,1+fun(mat,mp,st));\\n                change(i,j,mat);\\n            }\\n        }\\n        return st[str] = ans;\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        unordered_set<string>mp;\\n        unordered_map<string,int>st;\\n        int val = fun(mat,mp,st);\\n        return val<1000 ? val : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681963,
                "title": "c-0ms-backtracking-bit-masking-solution",
                "content": "For each entry, we can choose to flip the entry or not flip it. It is no reason to flip an entry twice. Since m, n are limited to 3, there are at most 9 entries, and the search space is only `2^(9)`. It is reasonable to use backtracking to explore all the possibility.\\n\\nBacktrack function with argument (row, column) will do\\n1. Termination condition: number of ones in the matrix is 0, update result, no need to further backtracking\\n2. Termination condition: (row, column) reach (m-1, n), terminate\\n2. Try not to flip the entry, and then backtrack the next entry(e.g. (0, 0) -> (1, 0); (0, n-1) -> (1, 0))\\n3. Try to flip the entry (i, j) and its four neighbors, backtrack the next entry, and then undo the flip operation on matrix\\n\\nI use bitmask represent the operation done so far. For example a `1` at position 2 in the bitmask of a `3*3` grid represents a flip at `(2/3, 2%3) = (0, 2)`.  \\n\\nThe time complexity is `O(2^(m*n))`, space complexity is `O(m*n)`\\n\\n```\\nint dirs[5] = {-1, 0, 1, 0, -1};\\n\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        m = mat.size(), n = mat[0].size();\\n        \\n        int numone = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (mat[i][j]) {++numone;}\\n            }\\n        }\\n        \\n        int flip = 0;\\n        int res = INT_MAX;\\n        backtrack(mat, flip, 0, numone, res);\\n        return res==INT_MAX?-1:res;\\n    }\\n    \\n    \\n    void backtrack(vector<vector<int>>& mat, int flip, int pos, int & numone, int & res) {\\n        if (numone == 0) {\\n            res = min(res, cnt(flip));\\n            return;\\n        }\\n        if (pos == m * n) { return; }\\n        \\n        // don\\'t flip at pos\\n        backtrack(mat, flip, pos+1, numone, res);\\n        \\n        // flip at row = pos/n, colum = pos%n\\n        int r = pos/n, c = pos%n;\\n        int nr, nc;\\n        \\n        numone = numone + (mat[r][c]?-1:1);\\n        mat[r][c] = mat[r][c]?0:1;\\n        for (int i = 0; i < 4; ++i) {\\n            nr = r + dirs[i];\\n            nc = c + dirs[i+1];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n) {\\n                continue;\\n            }\\n            numone = numone + (mat[nr][nc]?-1:1);\\n            mat[nr][nc] = mat[nr][nc]?0:1;\\n        }\\n        \\n        backtrack(mat, flip|(1<<pos), pos+1, numone, res);\\n        \\n        // resume matrix\\n        numone = numone + (mat[r][c]?-1:1);\\n        mat[r][c] = mat[r][c]?0:1;\\n        for (int i = 0; i < 4; ++i) {\\n            nr = r + dirs[i];\\n            nc = c + dirs[i+1];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n) {\\n                continue;\\n            }\\n            numone = numone + (mat[nr][nc]?-1:1);\\n            mat[nr][nc] = mat[nr][nc]?0:1;\\n        }\\n    }\\n    \\n    inline int cnt(int flip) {\\n        int res = 0;\\n        for (int i = 0; i < 10; ++i) {\\n            if (flip & (1<<i)) {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    int m, n;\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nint dirs[5] = {-1, 0, 1, 0, -1};\\n\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        m = mat.size(), n = mat[0].size();\\n        \\n        int numone = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (mat[i][j]) {++numone;}\\n            }\\n        }\\n        \\n        int flip = 0;\\n        int res = INT_MAX;\\n        backtrack(mat, flip, 0, numone, res);\\n        return res==INT_MAX?-1:res;\\n    }\\n    \\n    \\n    void backtrack(vector<vector<int>>& mat, int flip, int pos, int & numone, int & res) {\\n        if (numone == 0) {\\n            res = min(res, cnt(flip));\\n            return;\\n        }\\n        if (pos == m * n) { return; }\\n        \\n        // don\\'t flip at pos\\n        backtrack(mat, flip, pos+1, numone, res);\\n        \\n        // flip at row = pos/n, colum = pos%n\\n        int r = pos/n, c = pos%n;\\n        int nr, nc;\\n        \\n        numone = numone + (mat[r][c]?-1:1);\\n        mat[r][c] = mat[r][c]?0:1;\\n        for (int i = 0; i < 4; ++i) {\\n            nr = r + dirs[i];\\n            nc = c + dirs[i+1];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n) {\\n                continue;\\n            }\\n            numone = numone + (mat[nr][nc]?-1:1);\\n            mat[nr][nc] = mat[nr][nc]?0:1;\\n        }\\n        \\n        backtrack(mat, flip|(1<<pos), pos+1, numone, res);\\n        \\n        // resume matrix\\n        numone = numone + (mat[r][c]?-1:1);\\n        mat[r][c] = mat[r][c]?0:1;\\n        for (int i = 0; i < 4; ++i) {\\n            nr = r + dirs[i];\\n            nc = c + dirs[i+1];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n) {\\n                continue;\\n            }\\n            numone = numone + (mat[nr][nc]?-1:1);\\n            mat[nr][nc] = mat[nr][nc]?0:1;\\n        }\\n    }\\n    \\n    inline int cnt(int flip) {\\n        int res = 0;\\n        for (int i = 0; i < 10; ++i) {\\n            if (flip & (1<<i)) {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    int m, n;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655042,
                "title": "javascript-bfs-detailed-explanation",
                "content": "The main concept in this approach is converting the matrix to an integer. How can we do that?\\nStarting from LSB (bit at 0 index) we can set each bit in its correct index, for example `(0, 0)` is the `0` bit,\\n`(0, 1)` is the `1` bit, `(1, 0)` is the `2` bit, etc.\\n\\nOr to generalize, to set the `(row, col)` bit, we need to set the `row * cols + col` bit.\\n\\n![matrix to integer](https://assets.leetcode.com/users/images/0bf33e7e-d685-4879-b0bd-254461eceb50_1640795882.212234.png)\\n\\nWith this knowledge in mind, we can model the problem as graph. Each vertex is a matrix state and the edges are the possible flips.\\n\\nTo construct a matrix state as integer from matrix we can follow the below code:\\n\\n```\\nlet state = 0;\\nfor (let row = 0; row < rows; row++) {\\n\\tfor (let col = 0; col < cols; col++) {\\n\\t\\tif (mat[row][col] === 1) {\\n\\t\\t\\tstate |= (1 << (row * cols + col));\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nTo flip a bit, instead of using logical OR `|`, we use logical XOR `^` with 1 at the correct index.\\nAnd since we know how to flip a bit at the `(row, col)` position, we can also flip all adjacent cells, that is for `(row, col)` to flip:\\n1) Up - `(row - 1, col)`\\n2) Right - `(row, col + 1)`\\n3) Down - `(row + 1, col)`\\n4) Left - `(row, col - 1)`\\n\\nWe only need to check we are not out of bounds.\\n\\nPutting it all together:\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n    const rows = mat.length;\\n    const cols = mat[0].length;\\n    \\n    // construct source vertex from input matrix\\n    // (0, 0) is the 0 index bit\\n    // (0, 1) is the 1 index bit\\n    // (1, 0) is the 2 index bit\\n    // (1, 1) is the 3 index bit\\n    // (row, col) is the (row * cols + col) index bit\\n    let source = 0;\\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            if (mat[row][col] === 1) {\\n                source |= (1 << (row * cols + col));\\n            }\\n        }\\n    }\\n    \\n    const queue = [source];\\n    const visited = new Set();\\n    let steps = 0;\\n    \\n    while (queue.length) {\\n        // size is the current vertices `steps` steps away from source\\n        const size = queue.length;\\n        \\n        // consume all current vertices and add next states\\n        for (let i = 0; i < size; i++) {\\n            const state = queue.shift();\\n            \\n            if (state === 0) {\\n                return steps;\\n            }\\n            \\n            // try to flip each bit in current state\\n            for (let row = 0; row < rows; row++) {\\n                for (let col = 0; col < cols; col++) {\\n                    const neighbor = flip(state, row, col, rows, cols);\\n                    \\n                    if (!visited.has(neighbor)) {\\n                        visited.add(neighbor);\\n                        queue.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        steps += 1;\\n    }\\n    \\n    return -1;\\n};\\n\\n// to flip a bit at (row, col) we need to flip the bit\\n// at index (row * cols + col)\\n// with this logic, and the fact that:\\n// up = row - 1, right = col + 1, down = row + 1 and left = col - 1\\n// we can flip all adjacent bits\\nfunction flip(state, row, col, rows, cols) {\\n    // flip current bit\\n    state ^= (1 << (row * cols + col))\\n    \\n    // flip left\\n    if (col > 0) {\\n        state ^= (1 << (row * cols + col - 1))\\n    }\\n    \\n    // flip right\\n    if (col < cols - 1) {\\n        state ^= (1 << (row * cols + col + 1));\\n    }\\n    \\n    // flip up\\n    if (row > 0) {\\n        state ^= (1 << ((row - 1) * cols + col));\\n    }\\n    \\n    // flip down\\n    if (row < rows - 1) {\\n        state ^= (1 << ((row + 1) * cols + col));\\n    }\\n    \\n    return state;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nlet state = 0;\\nfor (let row = 0; row < rows; row++) {\\n\\tfor (let col = 0; col < cols; col++) {\\n\\t\\tif (mat[row][col] === 1) {\\n\\t\\t\\tstate |= (1 << (row * cols + col));\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n    const rows = mat.length;\\n    const cols = mat[0].length;\\n    \\n    // construct source vertex from input matrix\\n    // (0, 0) is the 0 index bit\\n    // (0, 1) is the 1 index bit\\n    // (1, 0) is the 2 index bit\\n    // (1, 1) is the 3 index bit\\n    // (row, col) is the (row * cols + col) index bit\\n    let source = 0;\\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            if (mat[row][col] === 1) {\\n                source |= (1 << (row * cols + col));\\n            }\\n        }\\n    }\\n    \\n    const queue = [source];\\n    const visited = new Set();\\n    let steps = 0;\\n    \\n    while (queue.length) {\\n        // size is the current vertices `steps` steps away from source\\n        const size = queue.length;\\n        \\n        // consume all current vertices and add next states\\n        for (let i = 0; i < size; i++) {\\n            const state = queue.shift();\\n            \\n            if (state === 0) {\\n                return steps;\\n            }\\n            \\n            // try to flip each bit in current state\\n            for (let row = 0; row < rows; row++) {\\n                for (let col = 0; col < cols; col++) {\\n                    const neighbor = flip(state, row, col, rows, cols);\\n                    \\n                    if (!visited.has(neighbor)) {\\n                        visited.add(neighbor);\\n                        queue.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        steps += 1;\\n    }\\n    \\n    return -1;\\n};\\n\\n// to flip a bit at (row, col) we need to flip the bit\\n// at index (row * cols + col)\\n// with this logic, and the fact that:\\n// up = row - 1, right = col + 1, down = row + 1 and left = col - 1\\n// we can flip all adjacent bits\\nfunction flip(state, row, col, rows, cols) {\\n    // flip current bit\\n    state ^= (1 << (row * cols + col))\\n    \\n    // flip left\\n    if (col > 0) {\\n        state ^= (1 << (row * cols + col - 1))\\n    }\\n    \\n    // flip right\\n    if (col < cols - 1) {\\n        state ^= (1 << (row * cols + col + 1));\\n    }\\n    \\n    // flip up\\n    if (row > 0) {\\n        state ^= (1 << ((row - 1) * cols + col));\\n    }\\n    \\n    // flip down\\n    if (row < rows - 1) {\\n        state ^= (1 << ((row + 1) * cols + col));\\n    }\\n    \\n    return state;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653777,
                "title": "c-simple-and-easy-dfs-solution",
                "content": "Why everyone is making it so complicated with BFS and bit manipulation while it can be simply solved by DFS ?\\n\\nThe time complexity here is O(2^MN).\\n\\nThe key observation is that regardless how many times a cell gets flipped, the order in which all those flips happens DOES NOT matter, which means we can traverse the matrix in arbitrary order (row by row just by convention).\\n\\nAt each cell, there are only two options here, flip it or not.\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n, count, ans;\\n    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        ans = INT_MAX;\\n        m = mat.size(), n = mat[0].size();    \\n        for(int r=0; r<m; r++)\\n        {\\n            for(int c=0; c<n; c++)\\n            {\\n                count += mat[r][c];\\n            }\\n        }\\n        \\n        dfs(mat, 0, 0, 0);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& mat, int r, int c, int steps)\\n    {\\n        if(!count) \\n        {\\n            ans = min(ans, steps);\\n            return;\\n        }\\n        \\n        if(r == m) return;\\n        \\n        int nr = c == n-1 ? (r + 1) : r;\\n        int nc = c == n-1 ? 0 : (c + 1);\\n                \\n        flip(mat, r, c);\\n        dfs(mat, nr, nc, steps + 1);\\n        \\n        flip(mat, r, c);\\n        dfs(mat, nr, nc, steps);\\n    }\\n    \\n    void flip(vector<vector<int>>& mat, int r, int c)\\n    {\\n        flipCell(mat, r, c);\\n        \\n        for(int d=0; d<4; d++)\\n        {\\n            int _r = r + dir[d][0];\\n            int _c = c + dir[d][1];\\n            if(_r>=0 && _r<m && _c>=0 && _c<n)\\n            {\\n                flipCell(mat, _r, _c);\\n            }\\n        }\\n    }\\n    \\n    void flipCell(vector<vector<int>>& mat, int r, int c)\\n    {\\n        mat[r][c] ^= 1;\\n        count += mat[r][c] ? 1 : -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n, count, ans;\\n    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        ans = INT_MAX;\\n        m = mat.size(), n = mat[0].size();    \\n        for(int r=0; r<m; r++)\\n        {\\n            for(int c=0; c<n; c++)\\n            {\\n                count += mat[r][c];\\n            }\\n        }\\n        \\n        dfs(mat, 0, 0, 0);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& mat, int r, int c, int steps)\\n    {\\n        if(!count) \\n        {\\n            ans = min(ans, steps);\\n            return;\\n        }\\n        \\n        if(r == m) return;\\n        \\n        int nr = c == n-1 ? (r + 1) : r;\\n        int nc = c == n-1 ? 0 : (c + 1);\\n                \\n        flip(mat, r, c);\\n        dfs(mat, nr, nc, steps + 1);\\n        \\n        flip(mat, r, c);\\n        dfs(mat, nr, nc, steps);\\n    }\\n    \\n    void flip(vector<vector<int>>& mat, int r, int c)\\n    {\\n        flipCell(mat, r, c);\\n        \\n        for(int d=0; d<4; d++)\\n        {\\n            int _r = r + dir[d][0];\\n            int _c = c + dir[d][1];\\n            if(_r>=0 && _r<m && _c>=0 && _c<n)\\n            {\\n                flipCell(mat, _r, _c);\\n            }\\n        }\\n    }\\n    \\n    void flipCell(vector<vector<int>>& mat, int r, int c)\\n    {\\n        mat[r][c] ^= 1;\\n        count += mat[r][c] ? 1 : -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635428,
                "title": "java-bitwise-bfs-90-speed-explained",
                "content": "1. Log the state with an normal integer because an `int` has 32 bits and the max constraint only requires us to use at most 9 bits to record all the states.\\n2. Use either a `HashSet` or a `boolean[]` to record the state that we\\'ve visited.\\n3. A standard BFS is good enough for this problem\\n4. During the flipping operation, it is a good idea to just convert the position we are flipping back to 2D array indexes, so there will be no edge cases.\\n```\\nclass Solution {\\n    private static int N;\\n    private static int M;\\n\\n    public int minFlips(int[][] mat) {\\n        N = mat.length;\\n        M = mat[0].length;\\n        int state = 0;\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < M; j++)\\n                state = (state << 1) | mat[i][j]; //initiate state\\n\\n        boolean[] seen = new boolean[1 << 9]; //max constraint\\n        seen[state] = true; //mark visited\\n\\n        Queue<Integer> queue = new ArrayDeque<>(); //arrayDeque is faster than linkedlist\\n        queue.offer(state);\\n        int step = 0;\\n\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(--size >= 0){\\n                int cur = queue.poll();\\n                if (cur == 0) return step; //found, return step\\n\\n                for (int i = 0; i < N * M; i++){\\n                    int next = flip(cur, i); //flip it one by one \\n                    if (seen[next]) continue; //skip it if we\\'ve seen it\\n                    queue.offer(next);\\n                    seen[next] = true; //mark visited \\n                }\\n            }\\n            step++;\\n        }\\n\\n        return -1; //not found\\n    }\\n\\n    private static int flip(int state, int pos){\\n        int r = pos / M; //its row index \\n        int c = pos % M; //its col index\\n        int[][] dirs = {{0, 0}, {1, 0}, {0, 1}, {-1, 0}, {0, -1}}; //itself and 4 neighbors\\n        for (int[] d : dirs){\\n            int nr = r + d[0];\\n            int nc = c + d[1];\\n            if (nr < 0 || nr == N || nc < 0 || nc == M) continue; //don\\'t consider those out of bound\\n            state ^= (1 << (nr * M + nc)); //flip it!\\n        }\\n\\n        return state;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static int N;\\n    private static int M;\\n\\n    public int minFlips(int[][] mat) {\\n        N = mat.length;\\n        M = mat[0].length;\\n        int state = 0;\\n        for (int i = 0; i < N; i++)\\n            for (int j = 0; j < M; j++)\\n                state = (state << 1) | mat[i][j]; //initiate state\\n\\n        boolean[] seen = new boolean[1 << 9]; //max constraint\\n        seen[state] = true; //mark visited\\n\\n        Queue<Integer> queue = new ArrayDeque<>(); //arrayDeque is faster than linkedlist\\n        queue.offer(state);\\n        int step = 0;\\n\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(--size >= 0){\\n                int cur = queue.poll();\\n                if (cur == 0) return step; //found, return step\\n\\n                for (int i = 0; i < N * M; i++){\\n                    int next = flip(cur, i); //flip it one by one \\n                    if (seen[next]) continue; //skip it if we\\'ve seen it\\n                    queue.offer(next);\\n                    seen[next] = true; //mark visited \\n                }\\n            }\\n            step++;\\n        }\\n\\n        return -1; //not found\\n    }\\n\\n    private static int flip(int state, int pos){\\n        int r = pos / M; //its row index \\n        int c = pos % M; //its col index\\n        int[][] dirs = {{0, 0}, {1, 0}, {0, 1}, {-1, 0}, {0, -1}}; //itself and 4 neighbors\\n        for (int[] d : dirs){\\n            int nr = r + d[0];\\n            int nc = c + d[1];\\n            if (nr < 0 || nr == N || nc < 0 || nc == M) continue; //don\\'t consider those out of bound\\n            state ^= (1 << (nr * M + nc)); //flip it!\\n        }\\n\\n        return state;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633519,
                "title": "simple-c-code-for-dummies",
                "content": "isZero Function-Checks whether each cell of matrix is zero or not!\\n\\nflip function-Just flip the value of cell and its neighbours!\\n\\nsolve function- We are just checking whether i should flip this particular cell value or not.\\nIf we not flip it we just move forward and if we want to flip it the we call flip function and goes on!\\nits like a subset type of problem where we check whether to include this element or not.\\nHope it helps!\\n\\n\\n```\\nclass Solution {\\n    bool isZero(vector<vector<int>>& mat)\\n    {\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    vector<vector<int>> flip(vector<vector<int>> mat,int i,int j,int m,int n)\\n    {\\n        mat[i][j]=mat[i][j]^1;\\n        if(i>0)\\n        {\\n            mat[i-1][j]^=1;\\n        }\\n        if(i<m-1)\\n        {\\n            mat[i+1][j]^=1;\\n        }\\n        if(j>0)\\n        {\\n             mat[i][j-1]^=1;\\n        }\\n        if(j<n-1)\\n        {\\n             mat[i][j+1]^=1;\\n        }\\n        return mat;\\n        \\n        \\n    }\\n    int solve(vector<vector<int>> mat,int i,int j,int m,int n)\\n    {\\n        if(j==n)\\n        {\\n            i++;\\n            j=0;\\n        }\\n        if(i==m)\\n        {\\n            if(isZero(mat))\\n            {\\n                return 0;\\n            }\\n            return 10000;\\n        }\\n        \\n        int a1=solve(mat,i,j+1,m,n);\\n        int a2=solve(flip(mat,i,j,m,n),i,j+1,m,n)+1;\\n        return min(a1,a2);\\n        \\n        \\n    }\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int re=solve(mat,0,0,m,n);\\n        return re>=10000?-1:re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isZero(vector<vector<int>>& mat)\\n    {\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    vector<vector<int>> flip(vector<vector<int>> mat,int i,int j,int m,int n)\\n    {\\n        mat[i][j]=mat[i][j]^1;\\n        if(i>0)\\n        {\\n            mat[i-1][j]^=1;\\n        }\\n        if(i<m-1)\\n        {\\n            mat[i+1][j]^=1;\\n        }\\n        if(j>0)\\n        {\\n             mat[i][j-1]^=1;\\n        }\\n        if(j<n-1)\\n        {\\n             mat[i][j+1]^=1;\\n        }\\n        return mat;\\n        \\n        \\n    }\\n    int solve(vector<vector<int>> mat,int i,int j,int m,int n)\\n    {\\n        if(j==n)\\n        {\\n            i++;\\n            j=0;\\n        }\\n        if(i==m)\\n        {\\n            if(isZero(mat))\\n            {\\n                return 0;\\n            }\\n            return 10000;\\n        }\\n        \\n        int a1=solve(mat,i,j+1,m,n);\\n        int a2=solve(flip(mat,i,j,m,n),i,j+1,m,n)+1;\\n        return min(a1,a2);\\n        \\n        \\n    }\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int re=solve(mat,0,0,m,n);\\n        return re>=10000?-1:re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480496,
                "title": "python3-backtracking",
                "content": "```\\ndxs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n\\n\\ndef all_zero(arr):\\n    return all(y == 0 for x in arr for y in x)\\n\\n\\ndef validate_move(x, y, n, m):\\n    return 0 <= x < n and 0 <= y < m\\n\\n\\ndef flip_adjacent(i, j, n, m, mat):\\n    mat[i][j] ^= 1\\n    for dx, dy in dxs:\\n        a, b = i + dx, j + dy\\n        if validate_move(a, b, n, m):\\n            mat[a][b] ^= 1\\n\\n\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        n, m = len(mat), len(mat[0])\\n        def helper(x, y):\\n            if x >= n:\\n                if all_zero(mat):\\n                    return 0\\n                return float(\"inf\")\\n\\n            ans = float(\"inf\")\\n            next_x = x if ((y + 1) < m) else x + 1\\n            next_y = y + 1 if y + 1 < m else 0\\n\\n            # take it\\n            # 1. flip\\n            flip_adjacent(x, y, n, m, mat)\\n            ans = min(ans, 1 + helper(next_x, next_y))\\n\\n            # backtrack\\n            flip_adjacent(x, y, n, m, mat)\\n            ans = min(ans, helper(next_x, next_y))\\n\\n            return ans\\n\\n        res = helper(0, 0)\\n        return res if res < float(\"inf\") else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndxs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n\\n\\ndef all_zero(arr):\\n    return all(y == 0 for x in arr for y in x)\\n\\n\\ndef validate_move(x, y, n, m):\\n    return 0 <= x < n and 0 <= y < m\\n\\n\\ndef flip_adjacent(i, j, n, m, mat):\\n    mat[i][j] ^= 1\\n    for dx, dy in dxs:\\n        a, b = i + dx, j + dy\\n        if validate_move(a, b, n, m):\\n            mat[a][b] ^= 1\\n\\n\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        n, m = len(mat), len(mat[0])\\n        def helper(x, y):\\n            if x >= n:\\n                if all_zero(mat):\\n                    return 0\\n                return float(\"inf\")\\n\\n            ans = float(\"inf\")\\n            next_x = x if ((y + 1) < m) else x + 1\\n            next_y = y + 1 if y + 1 < m else 0\\n\\n            # take it\\n            # 1. flip\\n            flip_adjacent(x, y, n, m, mat)\\n            ans = min(ans, 1 + helper(next_x, next_y))\\n\\n            # backtrack\\n            flip_adjacent(x, y, n, m, mat)\\n            ans = min(ans, helper(next_x, next_y))\\n\\n            return ans\\n\\n        res = helper(0, 0)\\n        return res if res < float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337333,
                "title": "c-breadth-first-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int rownum[4]={-1,0,0,1};\\n    int colnum[4]={0,-1,1,0};\\n    int minFlips(vector<vector<int>>& mat) {\\n        queue<pair<int,vector<vector<int>>>>q;\\n        set<vector<vector<int>>>visited;\\n        vector<vector<int>>dest(mat.size(),vector<int>(mat[0].size()));\\n        q.push({0,mat});\\n        while(!q.empty()){\\n            pair<int,vector<vector<int>>>curr=q.front();\\n            q.pop();\\n            if(curr.second==dest) return curr.first;\\n            for(int i=0;i<curr.second.size();i++){\\n                for(int j=0;j<curr.second[0].size();j++){\\n                    curr.second[i][j]=1-curr.second[i][j];\\n                    for(int k=0;k<4;k++){\\n                        int nr=i+rownum[k];\\n                        int nc=j+colnum[k];\\n                        if(nr>=0&&nr<curr.second.size()&&nc>=0&&nc<curr.second[0].size()){\\n                            curr.second[nr][nc]=1-curr.second[nr][nc];\\n                        }\\n                    }\\n                    if(visited.find(curr.second)!=visited.end()) ;\\n                    else{\\n                        visited.insert(curr.second);\\n                        q.push({curr.first+1,curr.second});\\n                    }\\n                    curr.second[i][j]=1-curr.second[i][j];\\n                    for(int k=0;k<4;k++){\\n                        int nr=i+rownum[k];\\n                        int nc=j+colnum[k];\\n                        if(nr>=0&&nr<curr.second.size()&&nc>=0&&nc<curr.second[0].size()){\\n                            curr.second[nr][nc]=1-curr.second[nr][nc];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rownum[4]={-1,0,0,1};\\n    int colnum[4]={0,-1,1,0};\\n    int minFlips(vector<vector<int>>& mat) {\\n        queue<pair<int,vector<vector<int>>>>q;\\n        set<vector<vector<int>>>visited;\\n        vector<vector<int>>dest(mat.size(),vector<int>(mat[0].size()));\\n        q.push({0,mat});\\n        while(!q.empty()){\\n            pair<int,vector<vector<int>>>curr=q.front();\\n            q.pop();\\n            if(curr.second==dest) return curr.first;\\n            for(int i=0;i<curr.second.size();i++){\\n                for(int j=0;j<curr.second[0].size();j++){\\n                    curr.second[i][j]=1-curr.second[i][j];\\n                    for(int k=0;k<4;k++){\\n                        int nr=i+rownum[k];\\n                        int nc=j+colnum[k];\\n                        if(nr>=0&&nr<curr.second.size()&&nc>=0&&nc<curr.second[0].size()){\\n                            curr.second[nr][nc]=1-curr.second[nr][nc];\\n                        }\\n                    }\\n                    if(visited.find(curr.second)!=visited.end()) ;\\n                    else{\\n                        visited.insert(curr.second);\\n                        q.push({curr.first+1,curr.second});\\n                    }\\n                    curr.second[i][j]=1-curr.second[i][j];\\n                    for(int k=0;k<4;k++){\\n                        int nr=i+rownum[k];\\n                        int nc=j+colnum[k];\\n                        if(nr>=0&&nr<curr.second.size()&&nc>=0&&nc<curr.second[0].size()){\\n                            curr.second[nr][nc]=1-curr.second[nr][nc];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290398,
                "title": "java-bfs-imagine-as-1d-instead-of-2d-w-explanation",
                "content": "Typical BFS problem similar to Sliding Puzzle (773)\\n\\nWe visualize each state of the matrix as a node of the graph.\\nEvery possible state from this state are its children.\\n\\nVisualize the matrix as a 1D array or string instead.\\nIn the 1st given example,our start state is  \"0001\" and target state is \"0000\"\\n\\nIf a mxn 2D matrix is represented in 1D form,then the index of an element at mat[i][j] will be (i * j + n) in the 1D form.\\n\\nWe also maintain a prevIndex variable to keep track of the index that was flipped to reach the current State so that we dont flip it again as this will lead us to getting stuck in a cycle.\\n\\n```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        HashSet<String> seen = new HashSet<>();\\n  \\n        int count = 0;\\n        \\n        String src = \"\";\\n        String target = \"\";\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                src += Integer.toString(mat[i][j]);\\n                target += Integer.toString(0);\\n            }\\n        }\\n        \\n        Queue<Pair<String,Integer>>states = new LinkedList<>();\\n        states.add(new Pair<>(src,-1));\\n        seen.add(src);\\n        \\n        while(!states.isEmpty())\\n        {\\n            int size = states.size();\\n            for(int k=0;k<size;k++)\\n            {\\n                Pair<String,Integer>currPair = states.poll();\\n                String currState = currPair.getKey();\\n                Integer prevFlipped = currPair.getValue();\\n\\n                if(currState.equals(target))\\n                    return count;\\n\\n                for(int i=0;i<m;i++)\\n                {\\n                  for(int j=0;j<n;j++)\\n                  {\\n                      int index = i*n + j;\\n                      if(index != prevFlipped)\\n                      {\\n                          String nextState = flip(currState,index,m,n);\\n                          if(!seen.contains(nextState))\\n                          {\\n                              states.add(new Pair<>(nextState,index));\\n                              seen.add(nextState);\\n                          }\\n                          \\n                      }\\n                  }\\n                }\\n            }\\n           \\n            \\n            count++;\\n        }\\n\\n        return -1;\\n            \\n       \\n    } \\n    \\n    private String flip(String original,int index,int m,int n)\\n    {\\n        StringBuilder flipped = new StringBuilder(original);\\n        \\n        //flip the character itself\\n        flipped.setCharAt(index,(char) (flipped.charAt(index) ^ 1));\\n            \\n        //flip left and right\\n        if(index - 1 >=0 && (index - 1)%n != n-1)\\n            flipped.setCharAt(index-1, (char) (flipped.charAt(index-1) ^ 1)); \\n        if(index + 1 <=(m*n - 1) && (index + 1)%n != 0)\\n            flipped.setCharAt(index+1,(char) (flipped.charAt(index+1) ^ 1));\\n            \\n        //flip top and bottom\\n        if(index - n >= 0)\\n            flipped.setCharAt(index-n,(char) (flipped.charAt(index-n) ^ 1));\\n        if(index + n <= (m*n - 1))\\n             flipped.setCharAt(index+n,(char) (flipped.charAt(index+n) ^ 1));\\n            \\n        return flipped.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        HashSet<String> seen = new HashSet<>();\\n  \\n        int count = 0;\\n        \\n        String src = \"\";\\n        String target = \"\";\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                src += Integer.toString(mat[i][j]);\\n                target += Integer.toString(0);\\n            }\\n        }\\n        \\n        Queue<Pair<String,Integer>>states = new LinkedList<>();\\n        states.add(new Pair<>(src,-1));\\n        seen.add(src);\\n        \\n        while(!states.isEmpty())\\n        {\\n            int size = states.size();\\n            for(int k=0;k<size;k++)\\n            {\\n                Pair<String,Integer>currPair = states.poll();\\n                String currState = currPair.getKey();\\n                Integer prevFlipped = currPair.getValue();\\n\\n                if(currState.equals(target))\\n                    return count;\\n\\n                for(int i=0;i<m;i++)\\n                {\\n                  for(int j=0;j<n;j++)\\n                  {\\n                      int index = i*n + j;\\n                      if(index != prevFlipped)\\n                      {\\n                          String nextState = flip(currState,index,m,n);\\n                          if(!seen.contains(nextState))\\n                          {\\n                              states.add(new Pair<>(nextState,index));\\n                              seen.add(nextState);\\n                          }\\n                          \\n                      }\\n                  }\\n                }\\n            }\\n           \\n            \\n            count++;\\n        }\\n\\n        return -1;\\n            \\n       \\n    } \\n    \\n    private String flip(String original,int index,int m,int n)\\n    {\\n        StringBuilder flipped = new StringBuilder(original);\\n        \\n        //flip the character itself\\n        flipped.setCharAt(index,(char) (flipped.charAt(index) ^ 1));\\n            \\n        //flip left and right\\n        if(index - 1 >=0 && (index - 1)%n != n-1)\\n            flipped.setCharAt(index-1, (char) (flipped.charAt(index-1) ^ 1)); \\n        if(index + 1 <=(m*n - 1) && (index + 1)%n != 0)\\n            flipped.setCharAt(index+1,(char) (flipped.charAt(index+1) ^ 1));\\n            \\n        //flip top and bottom\\n        if(index - n >= 0)\\n            flipped.setCharAt(index-n,(char) (flipped.charAt(index-n) ^ 1));\\n        if(index + n <= (m*n - 1))\\n             flipped.setCharAt(index+n,(char) (flipped.charAt(index+n) ^ 1));\\n            \\n        return flipped.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249165,
                "title": "python-bit-masks-brute-force-o-mn-2-mn",
                "content": "1. Cells are numbered from 0 to MN-1\\n2. For each i, nei[i] is a bit mask of all cells neighboring to i, including itself.\\n3. We just try all combination of cells (2^MN combinations) and test if flipping them makes target matrix (coded as bitmask) from zero matrix.\\n\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        M = len(mat)\\n        N = len(mat[0])\\n        MN = M*N\\n        nei = [ None for _ in range(MN)]\\n        matcode = 0\\n        for r in range(M):\\n            for c in range(N):\\n                i = r*N+c\\n                l = [i]\\n                if r>0: l.append(i-N)\\n                if r<M-1: l.append(i+N)\\n                if c>0: l.append(i-1)\\n                if c<N-1: l.append(i+1)\\n                nei[i] = sum(1<<t for t in l)\\n                if mat[r][c]:\\n                    matcode |= (1<<i)\\n        \\n        best = MN+1\\n        for code in range(2**MN):\\n            m = 0\\n            bits = 0\\n            for t in range(MN):\\n                if code&(1<<t):\\n                    m ^= nei[t]\\n                    bits += 1\\n            if m==matcode:\\n                best = min(best,bits)\\n        return best if best<=MN else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        M = len(mat)\\n        N = len(mat[0])\\n        MN = M*N\\n        nei = [ None for _ in range(MN)]\\n        matcode = 0\\n        for r in range(M):\\n            for c in range(N):\\n                i = r*N+c\\n                l = [i]\\n                if r>0: l.append(i-N)\\n                if r<M-1: l.append(i+N)\\n                if c>0: l.append(i-1)\\n                if c<N-1: l.append(i+1)\\n                nei[i] = sum(1<<t for t in l)\\n                if mat[r][c]:\\n                    matcode |= (1<<i)\\n        \\n        best = MN+1\\n        for code in range(2**MN):\\n            m = 0\\n            bits = 0\\n            for t in range(MN):\\n                if code&(1<<t):\\n                    m ^= nei[t]\\n                    bits += 1\\n            if m==matcode:\\n                best = min(best,bits)\\n        return best if best<=MN else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117316,
                "title": "bfs-and-encode-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    using imatrix = vector<vector<int>>;\\n    vector<int> dx = { 0,0,1,-1 };\\n    vector<int> dy = { 1,-1,0,0 };\\n\\n    short to_int(imatrix& mat)\\n    {\\n        short ret = 0;\\n        for (auto i : mat)\\n            for (auto j : i)\\n                ret = (ret << 1) + j;\\n\\n        return ret;\\n    }\\n\\n    void flip(int i, int j, imatrix& mat, int m, int n)\\n    {\\n        mat[i][j] ^= 1;\\n        for (int d = 0; d < 4; d++) \\n        {\\n            int ni = i + dx[d];\\n            int nj = j + dy[d];\\n\\n            if (!(ni == -1 || nj == -1 || ni == n || nj == m))\\n                mat[ni][nj] ^= 1;\\n        }\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        if (n == 0 || m == 0)\\n            return 0;\\n        \\n        queue<imatrix> q;\\n        vector<int> visited((short)1 << (n * m), INT_MAX);\\n\\n        visited[to_int(mat)] = 0;\\n        q.push(mat);\\n\\n        while (!q.empty() && to_int(q.front()) != 0) \\n        {\\n            imatrix v = q.front();\\n            q.pop();\\n            imatrix u = v;\\n\\n            for (int i = 0; i < n; i++) \\n            {\\n                for (int j = 0; j < m; j++) \\n                {\\n                    flip(i, j, u, m, n);\\n\\n                    if (visited[to_int(u)] == INT_MAX) \\n                    {\\n                        q.push(u);\\n                        visited[to_int(u)] = visited[to_int(v)] + 1;\\n                    }\\n                    flip(i, j, u, m, n);\\n                }\\n            }\\n        }\\n\\n        if (q.empty())\\n            return -1;\\n\\n        return visited[0];\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using imatrix = vector<vector<int>>;\\n    vector<int> dx = { 0,0,1,-1 };\\n    vector<int> dy = { 1,-1,0,0 };\\n\\n    short to_int(imatrix& mat)\\n    {\\n        short ret = 0;\\n        for (auto i : mat)\\n            for (auto j : i)\\n                ret = (ret << 1) + j;\\n\\n        return ret;\\n    }\\n\\n    void flip(int i, int j, imatrix& mat, int m, int n)\\n    {\\n        mat[i][j] ^= 1;\\n        for (int d = 0; d < 4; d++) \\n        {\\n            int ni = i + dx[d];\\n            int nj = j + dy[d];\\n\\n            if (!(ni == -1 || nj == -1 || ni == n || nj == m))\\n                mat[ni][nj] ^= 1;\\n        }\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        if (n == 0 || m == 0)\\n            return 0;\\n        \\n        queue<imatrix> q;\\n        vector<int> visited((short)1 << (n * m), INT_MAX);\\n\\n        visited[to_int(mat)] = 0;\\n        q.push(mat);\\n\\n        while (!q.empty() && to_int(q.front()) != 0) \\n        {\\n            imatrix v = q.front();\\n            q.pop();\\n            imatrix u = v;\\n\\n            for (int i = 0; i < n; i++) \\n            {\\n                for (int j = 0; j < m; j++) \\n                {\\n                    flip(i, j, u, m, n);\\n\\n                    if (visited[to_int(u)] == INT_MAX) \\n                    {\\n                        q.push(u);\\n                        visited[to_int(u)] = visited[to_int(v)] + 1;\\n                    }\\n                    flip(i, j, u, m, n);\\n                }\\n            }\\n        }\\n\\n        if (q.empty())\\n            return -1;\\n\\n        return visited[0];\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046975,
                "title": "c-easy-to-understand-by-bfs-bitmasking",
                "content": "class Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int ans = INT_MAX;\\n        vector<pair<int,int>> p;\\n        for(int i = 0;i<n;i++)\\n        {\\n        for(int j = 0;j<m;j++)\\n        {\\n            p.push_back({i,j});\\n        }\\n        }\\n        int sz = p.size();\\n        int tot = 1<<sz;\\n        for(int mask= 0;mask<tot;mask++)\\n        {\\n            vector<pair<int,int>> v;\\n            for(int i = 0;i<sz;i++)\\n            {\\n                if(mask&(1<<i))\\n                {\\n                    v.push_back({p[i].first,p[i].second});\\n                }\\n            }\\n            \\n          vector<vector<int>> grid = mat;\\n         for(auto x : v)\\n             {\\n                 grid[x.first][x.second] = 1^grid[x.first][x.second];\\n                 if(x.first-1>=0) grid[x.first-1][x.second] = 1^grid[x.first-1][x.second];\\n                 if(x.first+1<n) grid[x.first+1][x.second] = 1^grid[x.first+1][x.second];\\n                 if(x.second+1<m) grid[x.first][x.second+1] = 1^grid[x.first][x.second+1];\\n                 if(x.second-1>=0) grid[x.first][x.second-1] = 1^grid[x.first][x.second-1];\\n             }\\n            int ct = 0;\\n            for(auto x : grid)\\n            {\\n                for(auto y : x)\\n                {\\n                    if(y==0) ct++;\\n                }\\n            }\\n            if(ct==n*m)\\n            {\\n                ans = min(ans,(int)v.size());\\n            }\\n    }\\n     if(ans==INT_MAX) return -1;\\n        return ans;\\n            \\n        }\\n         };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        int ans = INT_MAX;\\n        vector<pair<int,int>> p;\\n        for(int i = 0;i<n;i++)\\n        {\\n        for(int j = 0;j<m;j++)\\n        {\\n            p.push_back({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1029249,
                "title": "java-memoization-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int res = minFlips(mat, 0, new boolean[m][n], new HashMap<>());\\n        \\n        if(res > m * n){\\n            return -1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int minFlips(int[][] mat, int flips, boolean[][] visited, HashMap<Integer, Integer> map){\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int hashing = 0;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                hashing = hashing * 10 + mat[i][j];\\n            }\\n        }\\n        \\n        if(map.containsKey(hashing)){\\n            return map.get(hashing);\\n        }\\n        \\n        int ans = m * n + 1;    // maximum value of result can be m * n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// because each cell can be flipped once\\n\\t\\t\\n        boolean isOnePresent = false;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                if(mat[i][j] == 1){\\n                    isOnePresent = true;\\n                }\\n                    \\n                if(flips >= m * n && isOnePresent){\\n                    return flips;\\n                }\\n                \\n                if(visited[i][j]){\\n                    continue;\\n                }\\n                    \\n                toggle(mat, i, j);\\n                \\n                visited[i][j] = true;\\n                \\n                int rr = minFlips(mat, flips + 1, visited, map) + 1;\\n                \\n                visited[i][j] = false;\\n                    \\n                ans = Math.min(ans, rr);\\n                    \\n                toggle(mat, i, j);\\n            }\\n        }\\n        \\n        if(!isOnePresent){    // works as a base case when it is a zero matrix\\n            ans = 0;\\n        }\\n        \\n        map.put(hashing, ans);\\n        \\n        return ans;\\n    }\\n    \\n    public void toggle(int[][] mat, int i, int j){\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        if(i + 1 < m){\\n            mat[i + 1][j] = mat[i + 1][j] ^ 1;\\n        }\\n                    \\n        if(i - 1 >= 0){\\n            mat[i - 1][j] = mat[i - 1][j] ^ 1;\\n        }\\n                    \\n        if(j + 1 < n){\\n            mat[i][j + 1] = mat[i][j + 1] ^ 1;\\n        }\\n                    \\n        if(j - 1 >= 0){\\n            mat[i][j - 1] = mat[i][j - 1] ^ 1;\\n        }\\n                    \\n        mat[i][j] = mat[i][j] ^ 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int res = minFlips(mat, 0, new boolean[m][n], new HashMap<>());\\n        \\n        if(res > m * n){\\n            return -1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int minFlips(int[][] mat, int flips, boolean[][] visited, HashMap<Integer, Integer> map){\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int hashing = 0;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                hashing = hashing * 10 + mat[i][j];\\n            }\\n        }\\n        \\n        if(map.containsKey(hashing)){\\n            return map.get(hashing);\\n        }\\n        \\n        int ans = m * n + 1;    // maximum value of result can be m * n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// because each cell can be flipped once\\n\\t\\t\\n        boolean isOnePresent = false;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                if(mat[i][j] == 1){\\n                    isOnePresent = true;\\n                }\\n                    \\n                if(flips >= m * n && isOnePresent){\\n                    return flips;\\n                }\\n                \\n                if(visited[i][j]){\\n                    continue;\\n                }\\n                    \\n                toggle(mat, i, j);\\n                \\n                visited[i][j] = true;\\n                \\n                int rr = minFlips(mat, flips + 1, visited, map) + 1;\\n                \\n                visited[i][j] = false;\\n                    \\n                ans = Math.min(ans, rr);\\n                    \\n                toggle(mat, i, j);\\n            }\\n        }\\n        \\n        if(!isOnePresent){    // works as a base case when it is a zero matrix\\n            ans = 0;\\n        }\\n        \\n        map.put(hashing, ans);\\n        \\n        return ans;\\n    }\\n    \\n    public void toggle(int[][] mat, int i, int j){\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        if(i + 1 < m){\\n            mat[i + 1][j] = mat[i + 1][j] ^ 1;\\n        }\\n                    \\n        if(i - 1 >= 0){\\n            mat[i - 1][j] = mat[i - 1][j] ^ 1;\\n        }\\n                    \\n        if(j + 1 < n){\\n            mat[i][j + 1] = mat[i][j + 1] ^ 1;\\n        }\\n                    \\n        if(j - 1 >= 0){\\n            mat[i][j - 1] = mat[i][j - 1] ^ 1;\\n        }\\n                    \\n        mat[i][j] = mat[i][j] ^ 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023950,
                "title": "java-100-bfs-with-bits-instead-of-serialization",
                "content": "The algorithm\\'s time complexity cannot be reduced further, but we can reduce our constant time operations to further improve our performance.\\n\\nNote `1 <= m, n <= 3`, and there are `32` bits within a `int32`. For every `y,x` coordinate is either `1` or `0` meaning we can encode every `y,x` into a bit. \\n\\nTo perform flips, we do `^` bit manipulation to flip `1 <-> 0`, and calculate which bit positions depending on the `y` and `x` coordinates.\\n\\n```java\\npublic int minFlips(int[][] mat) {\\n\\tint hash = hash(mat);\\n\\tif (hash == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint M = mat.length;\\n\\tint N = mat[0].length;\\n\\n\\t// If there are M rows and N columns, there are M*N bits or possible matrix combinations to set.\\n\\tboolean[] visited = new boolean[(1 << (N*M))];\\n\\n\\tQueue<Integer> queue = new ArrayDeque<>();\\n\\tqueue.add(hash);\\n\\tvisited[hash] = true;\\n\\n\\tint steps = 1;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tfor (int i = queue.size(); i > 0; i--) {\\n\\t\\t\\thash = queue.poll();\\n\\n\\t\\t\\tfor (int y = 0; y < M; y++) {\\n\\t\\t\\t\\tfor (int x = 0; x < N; x++) {\\n\\t\\t\\t\\t\\tint flippedHash = flipHash(hash, y, x, M, N);\\n\\t\\t\\t\\t\\tif (flippedHash == 0) {\\n\\t\\t\\t\\t\\t\\treturn steps;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (visited[flippedHash]) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tqueue.add(flippedHash);\\n\\t\\t\\t\\t\\tvisited[flippedHash] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\n\\treturn -1;\\n}\\n\\n// Flip the coordinate and it\\'s four neighbors.\\nprivate int flipHash(int hash, int y, int x, int M, int N) {\\n\\tif (y > 0) {\\n\\t\\thash = flip(hash, y-1, x, M, N);\\n\\t}\\n\\tif (x > 0) {\\n\\t\\thash = flip(hash, y, x-1, M, N);\\n\\t}\\n\\tif (y+1 < M) {\\n\\t\\thash = flip(hash, y+1, x, M, N);\\n\\t}\\n\\tif (x+1 < N) {\\n\\t\\thash = flip(hash, y, x+1, M, N);\\n\\t}\\n\\treturn flip(hash, y, x, M, N);\\n}\\n\\n// Get initial hash of the matrix.\\npublic int hash(int[][] mat) {\\n\\tint hash = 0;\\n\\n\\tfor (int y = mat.length-1; y >= 0; y--) {\\n\\t\\tfor (int x = mat[y].length-1; x >= 0; x--) {\\n\\t\\t\\thash <<= 1;\\n\\t\\t\\thash += mat[y][x];\\n\\t\\t}\\n\\t}\\n\\treturn hash;\\n}\\n\\n// Perform the flipping of 1 <-> 0 depending on the (y, x).\\nprivate int flip(int hash, int y, int x, int M, int N) {\\n\\treturn hash ^ (1 << ((y * N) + x));\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int minFlips(int[][] mat) {\\n\\tint hash = hash(mat);\\n\\tif (hash == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint M = mat.length;\\n\\tint N = mat[0].length;\\n\\n\\t// If there are M rows and N columns, there are M*N bits or possible matrix combinations to set.\\n\\tboolean[] visited = new boolean[(1 << (N*M))];\\n\\n\\tQueue<Integer> queue = new ArrayDeque<>();\\n\\tqueue.add(hash);\\n\\tvisited[hash] = true;\\n\\n\\tint steps = 1;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tfor (int i = queue.size(); i > 0; i--) {\\n\\t\\t\\thash = queue.poll();\\n\\n\\t\\t\\tfor (int y = 0; y < M; y++) {\\n\\t\\t\\t\\tfor (int x = 0; x < N; x++) {\\n\\t\\t\\t\\t\\tint flippedHash = flipHash(hash, y, x, M, N);\\n\\t\\t\\t\\t\\tif (flippedHash == 0) {\\n\\t\\t\\t\\t\\t\\treturn steps;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (visited[flippedHash]) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tqueue.add(flippedHash);\\n\\t\\t\\t\\t\\tvisited[flippedHash] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\n\\treturn -1;\\n}\\n\\n// Flip the coordinate and it\\'s four neighbors.\\nprivate int flipHash(int hash, int y, int x, int M, int N) {\\n\\tif (y > 0) {\\n\\t\\thash = flip(hash, y-1, x, M, N);\\n\\t}\\n\\tif (x > 0) {\\n\\t\\thash = flip(hash, y, x-1, M, N);\\n\\t}\\n\\tif (y+1 < M) {\\n\\t\\thash = flip(hash, y+1, x, M, N);\\n\\t}\\n\\tif (x+1 < N) {\\n\\t\\thash = flip(hash, y, x+1, M, N);\\n\\t}\\n\\treturn flip(hash, y, x, M, N);\\n}\\n\\n// Get initial hash of the matrix.\\npublic int hash(int[][] mat) {\\n\\tint hash = 0;\\n\\n\\tfor (int y = mat.length-1; y >= 0; y--) {\\n\\t\\tfor (int x = mat[y].length-1; x >= 0; x--) {\\n\\t\\t\\thash <<= 1;\\n\\t\\t\\thash += mat[y][x];\\n\\t\\t}\\n\\t}\\n\\treturn hash;\\n}\\n\\n// Perform the flipping of 1 <-> 0 depending on the (y, x).\\nprivate int flip(int hash, int y, int x, int M, int N) {\\n\\treturn hash ^ (1 << ((y * N) + x));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023277,
                "title": "java-classic-bfs-with-a-simple-way-to-serialize-board",
                "content": "This question is a classic bfs problem -- find minimum number of flips. The tricky part is about how to serialize & deserialize the board to generate next steps. Please see ```getNextStep()``` method for how to do it. Other than that, the code is pretty straightforward.\\n\\n```\\nclass Solution {\\n    int m;\\n    int[] dirs;\\n    public int minFlips(int[][] mat) {\\n        this.m = mat[0].length;\\n        this.dirs = m == 1 ? new int[]{-1, 1} : new int[]{-1, 1, -m, m};\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int[] row : mat) {\\n\\t\\t\\tfor (int n : row) {\\n\\t\\t\\t\\tsb.append(n);\\n\\t\\t\\t}\\n\\t\\t}\\n        String serializedMap = sb.toString();\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(serializedMap);\\n        Set<String> visited = new HashSet<>();\\n        visited.add(serializedMap);\\n        \\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i<size; i++) {\\n                String cur = queue.poll();\\n                if (cur.indexOf(\"1\") == -1) {\\n                    return steps;\\n                }\\n                \\n                List<String> next = getNextStep(cur);\\n                for (String n: next) {\\n                    if (!visited.contains(n)) {\\n                        visited.add(n);\\n                        queue.add(n);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private List<String> getNextStep(String mat) {\\n        List<String> nexts = new ArrayList<>();\\n        int i = 0;\\n        for (i = 0; i<mat.length(); i++) {\\n            StringBuilder sb = new StringBuilder(mat);\\n            for (int dir: dirs) {\\n                int x = i + dir;\\n                if (m == 1 && (x < 0 || x >= mat.length())) {\\n                    continue;\\n                }\\n                if (m != 1 && (x < 0 || x >= mat.length() || (x % m == 0 && dir == 1) || (i % m == 0 && dir == -1))) {\\n                    continue;\\n                }\\n                \\n                int c = sb.charAt(x) - \\'0\\';\\n                sb.setCharAt(x, (char)((1 - c) + \\'0\\'));\\n            }\\n            int o = sb.charAt(i) - \\'0\\';\\n            sb.setCharAt(i, (char)((1 - o) + \\'0\\'));\\n            nexts.add(sb.toString());\\n        }\\n        return nexts;\\n\\t}\\n}\\n```\\n\\n\\nAnother BFS question that is nothing hard but just requires to serialize board is: https://leetcode.com/problems/sliding-puzzle/",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```getNextStep()```\n```\\nclass Solution {\\n    int m;\\n    int[] dirs;\\n    public int minFlips(int[][] mat) {\\n        this.m = mat[0].length;\\n        this.dirs = m == 1 ? new int[]{-1, 1} : new int[]{-1, 1, -m, m};\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int[] row : mat) {\\n\\t\\t\\tfor (int n : row) {\\n\\t\\t\\t\\tsb.append(n);\\n\\t\\t\\t}\\n\\t\\t}\\n        String serializedMap = sb.toString();\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(serializedMap);\\n        Set<String> visited = new HashSet<>();\\n        visited.add(serializedMap);\\n        \\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i<size; i++) {\\n                String cur = queue.poll();\\n                if (cur.indexOf(\"1\") == -1) {\\n                    return steps;\\n                }\\n                \\n                List<String> next = getNextStep(cur);\\n                for (String n: next) {\\n                    if (!visited.contains(n)) {\\n                        visited.add(n);\\n                        queue.add(n);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private List<String> getNextStep(String mat) {\\n        List<String> nexts = new ArrayList<>();\\n        int i = 0;\\n        for (i = 0; i<mat.length(); i++) {\\n            StringBuilder sb = new StringBuilder(mat);\\n            for (int dir: dirs) {\\n                int x = i + dir;\\n                if (m == 1 && (x < 0 || x >= mat.length())) {\\n                    continue;\\n                }\\n                if (m != 1 && (x < 0 || x >= mat.length() || (x % m == 0 && dir == 1) || (i % m == 0 && dir == -1))) {\\n                    continue;\\n                }\\n                \\n                int c = sb.charAt(x) - \\'0\\';\\n                sb.setCharAt(x, (char)((1 - c) + \\'0\\'));\\n            }\\n            int o = sb.charAt(i) - \\'0\\';\\n            sb.setCharAt(i, (char)((1 - o) + \\'0\\'));\\n            nexts.add(sb.toString());\\n        }\\n        return nexts;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973631,
                "title": "finding-all-possible-flip-using-bit-operation",
                "content": "```\\n\\tint m,n;\\n    bool isZeroMatrix(vector<vector<int>>& mat)\\n    {\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void flip(int i,int j,vector<vector<int>>& mat)\\n    {\\n        mat[i][j]=!mat[i][j];\\n        if(i-1>=0)\\n            mat[i-1][j]=!mat[i-1][j];\\n        if(i+1<m)\\n            mat[i+1][j]=!mat[i+1][j];\\n        if(j-1>=0)\\n            mat[i][j-1]=!mat[i][j-1];\\n        if(j+1<n)\\n            mat[i][j+1]=!mat[i][j+1];\\n    }\\n\\tint minFlips(vector<vector<int>>& mat) {\\n        \\n        vector<vector<int>>temp;\\n        \\n        m=mat.size();\\n        n=mat[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int>a;\\n            for(int j=0;j<n;j++)\\n                a.push_back(mat[i][j]);\\n            temp.push_back(a);\\n        }\\n\\n        int t=pow(2,m*n);\\n        int ans =INT_MAX;\\n    \\n        for(int i=0;i<t;i++)\\n        {\\n            int x=i;\\n            int cnt=0;\\n            \\n            // copy matrix into temporary array\\n            for(int row=0;row<m;row++)\\n            {\\n                for(int col=0;col<n;col++)\\n                    temp[row][col]=mat[row][col];\\n            }\\n            for(int j=0;j<m*n;j++)\\n            {\\n                if(x&1)\\n                {\\n                    cnt++;\\n                    flip(j/n,j%n,temp);\\n                }\\n                x=x>>1;\\n            }\\n            if(isZeroMatrix(temp) && cnt<ans)\\n                ans=cnt;\\n        }\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tint m,n;\\n    bool isZeroMatrix(vector<vector<int>>& mat)\\n    {\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void flip(int i,int j,vector<vector<int>>& mat)\\n    {\\n        mat[i][j]=!mat[i][j];\\n        if(i-1>=0)\\n            mat[i-1][j]=!mat[i-1][j];\\n        if(i+1<m)\\n            mat[i+1][j]=!mat[i+1][j];\\n        if(j-1>=0)\\n            mat[i][j-1]=!mat[i][j-1];\\n        if(j+1<n)\\n            mat[i][j+1]=!mat[i][j+1];\\n    }\\n\\tint minFlips(vector<vector<int>>& mat) {\\n        \\n        vector<vector<int>>temp;\\n        \\n        m=mat.size();\\n        n=mat[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            vector<int>a;\\n            for(int j=0;j<n;j++)\\n                a.push_back(mat[i][j]);\\n            temp.push_back(a);\\n        }\\n\\n        int t=pow(2,m*n);\\n        int ans =INT_MAX;\\n    \\n        for(int i=0;i<t;i++)\\n        {\\n            int x=i;\\n            int cnt=0;\\n            \\n            // copy matrix into temporary array\\n            for(int row=0;row<m;row++)\\n            {\\n                for(int col=0;col<n;col++)\\n                    temp[row][col]=mat[row][col];\\n            }\\n            for(int j=0;j<m*n;j++)\\n            {\\n                if(x&1)\\n                {\\n                    cnt++;\\n                    flip(j/n,j%n,temp);\\n                }\\n                x=x>>1;\\n            }\\n            if(isZeroMatrix(temp) && cnt<ans)\\n                ans=cnt;\\n        }\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927330,
                "title": "java-bfs-7-ms-faster-than-35-94-38-6-mb-less-than-11-98",
                "content": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        int steps = 0;\\n        int bits = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                bits = (bits << 1) | mat[i][j];\\n            }\\n        }\\n        q.offer(bits);\\n        visited.add(bits);\\n        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while (!q.isEmpty()) {\\n            for (int k = q.size(); k > 0; --k) {\\n                int b = q.poll();\\n                if (b == 0) {\\n                    return steps;\\n                }\\n                for (int i = 0; i < m; ++i) {\\n                    for (int j = 0; j < n; ++j) {\\n                        int copy = b;\\n                        copy ^= 1 << (i * n + j);\\n                        for (int[] d : dirs) {\\n                            int x = d[0] + i;\\n                            int y = d[1] + j;\\n                            if (0 <= x & x < m && 0 <= y && y < n) {\\n                                copy ^= 1 << (x * n + y);\\n                            }\\n                        }\\n                        if (!visited.contains(copy)) {\\n                            visited.add(copy);\\n                            q.offer(copy);\\n                        }\\n                    }\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        int steps = 0;\\n        int bits = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                bits = (bits << 1) | mat[i][j];\\n            }\\n        }\\n        q.offer(bits);\\n        visited.add(bits);\\n        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while (!q.isEmpty()) {\\n            for (int k = q.size(); k > 0; --k) {\\n                int b = q.poll();\\n                if (b == 0) {\\n                    return steps;\\n                }\\n                for (int i = 0; i < m; ++i) {\\n                    for (int j = 0; j < n; ++j) {\\n                        int copy = b;\\n                        copy ^= 1 << (i * n + j);\\n                        for (int[] d : dirs) {\\n                            int x = d[0] + i;\\n                            int y = d[1] + j;\\n                            if (0 <= x & x < m && 0 <= y && y < n) {\\n                                copy ^= 1 << (x * n + y);\\n                            }\\n                        }\\n                        if (!visited.contains(copy)) {\\n                            visited.add(copy);\\n                            q.offer(copy);\\n                        }\\n                    }\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876567,
                "title": "rust-translated-0ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_flips(mat: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::{HashSet, VecDeque};\\n\\n        const NEIGHBORS: [i32; 6] = [0, 0, 1, 0, -1, 0];\\n        let mut start = 0;\\n\\n        let m = mat.len();\\n        let n = mat[0].len();\\n        for i in 0..m {\\n            for j in 0..n {\\n                start |= mat[i][j] << (i * n + j);\\n            }\\n        }\\n        let mut q = VecDeque::<i32>::new();\\n        let mut visited = HashSet::<i32>::new();\\n        q.push_back(start);\\n        visited.insert(start);\\n        let mut step = 0;\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let cur = q.pop_front().unwrap();\\n                if cur == 0 {\\n                    return step;\\n                }\\n                for i in 0..m {\\n                    for j in 0..n {\\n                        let mut next = cur;\\n                        for k in 0..5 {\\n                            let r = i as i32 + NEIGHBORS[k];\\n                            let c = j as i32 + NEIGHBORS[k + 1];\\n                            if r >= 0 && r < m as i32 && c >= 0 && c < n as i32 {\\n                                next ^= 1 << (r * n as i32 + c);\\n                            }\\n                        }\\n                        if visited.insert(next) {\\n                            q.push_back(next);\\n                        }\\n                    }\\n                }\\n            }\\n            step += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n    #[test]\\n    fn test_min_flips() {\\n        assert_eq!(Solution::min_flips(vec![vec![0, 0], vec![0, 1]]), 3);\\n    }\\n    #[test]\\n    fn test_min_flips_02() {\\n        assert_eq!(Solution::min_flips(vec![vec![0]]), 0);\\n    }\\n\\n    #[test]\\n    fn test_min_flips_03() {\\n        assert_eq!(\\n            Solution::min_flips(vec![vec![1, 1, 1], vec![1, 0, 1], vec![0, 0, 0]]),\\n            6\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_flips_04() {\\n        assert_eq!(Solution::min_flips(vec![vec![1, 0, 0], vec![1, 0, 0]]), -1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_flips(mat: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::{HashSet, VecDeque};\\n\\n        const NEIGHBORS: [i32; 6] = [0, 0, 1, 0, -1, 0];\\n        let mut start = 0;\\n\\n        let m = mat.len();\\n        let n = mat[0].len();\\n        for i in 0..m {\\n            for j in 0..n {\\n                start |= mat[i][j] << (i * n + j);\\n            }\\n        }\\n        let mut q = VecDeque::<i32>::new();\\n        let mut visited = HashSet::<i32>::new();\\n        q.push_back(start);\\n        visited.insert(start);\\n        let mut step = 0;\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let cur = q.pop_front().unwrap();\\n                if cur == 0 {\\n                    return step;\\n                }\\n                for i in 0..m {\\n                    for j in 0..n {\\n                        let mut next = cur;\\n                        for k in 0..5 {\\n                            let r = i as i32 + NEIGHBORS[k];\\n                            let c = j as i32 + NEIGHBORS[k + 1];\\n                            if r >= 0 && r < m as i32 && c >= 0 && c < n as i32 {\\n                                next ^= 1 << (r * n as i32 + c);\\n                            }\\n                        }\\n                        if visited.insert(next) {\\n                            q.push_back(next);\\n                        }\\n                    }\\n                }\\n            }\\n            step += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n    #[test]\\n    fn test_min_flips() {\\n        assert_eq!(Solution::min_flips(vec![vec![0, 0], vec![0, 1]]), 3);\\n    }\\n    #[test]\\n    fn test_min_flips_02() {\\n        assert_eq!(Solution::min_flips(vec![vec![0]]), 0);\\n    }\\n\\n    #[test]\\n    fn test_min_flips_03() {\\n        assert_eq!(\\n            Solution::min_flips(vec![vec![1, 1, 1], vec![1, 0, 1], vec![0, 0, 0]]),\\n            6\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_flips_04() {\\n        assert_eq!(Solution::min_flips(vec![vec![1, 0, 0], vec![1, 0, 0]]), -1);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823445,
                "title": "c-concise-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {        \\n        const int n=mat.size(), m=mat[0].size();\\n        A dest = vector(n, vector(m, 0));\\n        if(dest == mat) return 0;\\n        set<A> visited = {mat};\\n        queue<pair<A, int>> q;\\n        q.push(pair(mat, 0));\\n        while(!q.empty()){\\n            auto [a, step] = move(q.front()); q.pop();\\n            for(auto neighbor : getNeighbors(a, n, m)){\\n                if(neighbor == dest) return step+1;\\n                if(visited.count(neighbor)) continue;\\n                visited.insert(neighbor);\\n                q.push(pair(move(neighbor), step+1));\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    using A = vector<vector<int>>;\\n    vector<A> getNeighbors(const A& mat, const int n, const int m){\\n        vector<A> res;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                res.emplace_back(transfer(mat, n, m, i, j));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    A transfer(const A& mat, const int n, const int m, int i, int j){\\n        static const vector<pair<int,int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        auto res = mat;\\n        res[i][j] ^= 1;\\n        for(auto [dx, dy] : dirs){\\n            int x = i+dx, y=j+dy;\\n            if(x>=0 && x<n && y>=0 && y<m) res[x][y] ^= 1;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {        \\n        const int n=mat.size(), m=mat[0].size();\\n        A dest = vector(n, vector(m, 0));\\n        if(dest == mat) return 0;\\n        set<A> visited = {mat}",
                "codeTag": "Java"
            },
            {
                "id": 796759,
                "title": "java-bfs-solution-with-hashset-string",
                "content": "1. Main idea is convert matrix to a string, then the problem is how many time can we get the targetString \"0000\"?\\n2. For each string, for each index, we try to get all neighbors, if exists in matrix, replace it.\\n3. Use hashset to avoid the visited string.\\n```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        if (mat.length == 0) {\\n            return 0;\\n        }\\n        final int n = mat[0].length;\\n        final String endString = \"0\".repeat(mat.length * n);\\n        final StringBuilder startStringBuilder = new StringBuilder();\\n        for (int[] ints : mat) {\\n            for (int i : ints) {\\n                startStringBuilder.append(i);\\n            }\\n        }\\n        final String startString = startStringBuilder.toString();\\n        if (endString.equals(startString)) {\\n            return 0;\\n        }\\n        final Queue<String> queue = new LinkedList<>();\\n        final Set<String> visited = new HashSet<>();\\n        queue.offer(startString);\\n        visited.add(startString);\\n\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            final int currentSize = queue.size();\\n            for (int size = 0; size < currentSize; size++) {\\n                final String current = queue.poll();\\n                if (endString.equals(current)) {\\n                    return level;\\n                }\\n                for (int aimIndex = 0; aimIndex < current.length(); aimIndex++) {\\n                    final int currentX = aimIndex / n;\\n                    final int currentY = aimIndex % n;\\n                    final StringBuilder newStringBuilder =\\n                            new StringBuilder(current);\\n                    change(newStringBuilder, aimIndex);\\n                    for (int index = 0; index < 4; index++) {\\n                        final int nextX = currentX + deltaX[index];\\n                        final int nextY = currentY + deltaY[index];\\n                        if (inBound(mat, nextX, nextY)) {\\n                            change(newStringBuilder, nextX * n + nextY);\\n                        }\\n                    }\\n                    final String newString = newStringBuilder.toString();\\n                    if (!visited.contains(newString)) {\\n                        queue.offer(newString);\\n                        visited.add(newString);\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        return -1;\\n    }\\n\\n    private void change(StringBuilder stringBuilder, int i) {\\n        if (stringBuilder.charAt(i) == \\'0\\') {\\n            stringBuilder.setCharAt(i, \\'1\\');\\n        } else {\\n            stringBuilder.setCharAt(i, \\'0\\');\\n        }\\n    }\\n\\n    private final int[] deltaX = {0, 0, -1, 1};\\n    private final int[] deltaY = {-1, 1, 0, 0};\\n\\n    private boolean inBound(\\n            int[][] grid,\\n            int x,\\n            int y\\n    ) {\\n        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        if (mat.length == 0) {\\n            return 0;\\n        }\\n        final int n = mat[0].length;\\n        final String endString = \"0\".repeat(mat.length * n);\\n        final StringBuilder startStringBuilder = new StringBuilder();\\n        for (int[] ints : mat) {\\n            for (int i : ints) {\\n                startStringBuilder.append(i);\\n            }\\n        }\\n        final String startString = startStringBuilder.toString();\\n        if (endString.equals(startString)) {\\n            return 0;\\n        }\\n        final Queue<String> queue = new LinkedList<>();\\n        final Set<String> visited = new HashSet<>();\\n        queue.offer(startString);\\n        visited.add(startString);\\n\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            final int currentSize = queue.size();\\n            for (int size = 0; size < currentSize; size++) {\\n                final String current = queue.poll();\\n                if (endString.equals(current)) {\\n                    return level;\\n                }\\n                for (int aimIndex = 0; aimIndex < current.length(); aimIndex++) {\\n                    final int currentX = aimIndex / n;\\n                    final int currentY = aimIndex % n;\\n                    final StringBuilder newStringBuilder =\\n                            new StringBuilder(current);\\n                    change(newStringBuilder, aimIndex);\\n                    for (int index = 0; index < 4; index++) {\\n                        final int nextX = currentX + deltaX[index];\\n                        final int nextY = currentY + deltaY[index];\\n                        if (inBound(mat, nextX, nextY)) {\\n                            change(newStringBuilder, nextX * n + nextY);\\n                        }\\n                    }\\n                    final String newString = newStringBuilder.toString();\\n                    if (!visited.contains(newString)) {\\n                        queue.offer(newString);\\n                        visited.add(newString);\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        return -1;\\n    }\\n\\n    private void change(StringBuilder stringBuilder, int i) {\\n        if (stringBuilder.charAt(i) == \\'0\\') {\\n            stringBuilder.setCharAt(i, \\'1\\');\\n        } else {\\n            stringBuilder.setCharAt(i, \\'0\\');\\n        }\\n    }\\n\\n    private final int[] deltaX = {0, 0, -1, 1};\\n    private final int[] deltaY = {-1, 1, 0, 0};\\n\\n    private boolean inBound(\\n            int[][] grid,\\n            int x,\\n            int y\\n    ) {\\n        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738115,
                "title": "java-very-clean-and-easy-to-understand-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        int required = hash(mat);\\n        if (required == 0) {\\n            return 0;\\n        }\\n        \\n        queue.add(new Pair(0, 0));\\n        visited.add(0);\\n        \\n        while (!queue.isEmpty()) {\\n            Pair<Integer, Integer> cur = queue.poll();\\n            \\n            for (int pos = 0; pos < mat.length * mat[0].length; pos++) {\\n                int next = flip(cur.getValue(), pos, mat.length, mat[0].length);\\n                \\n                if (next == required) {\\n                    return cur.getKey() + 1;\\n                }\\n                \\n                if (visited.contains(next)) {\\n                    continue;\\n                }\\n                \\n                visited.add(next);\\n                queue.add(new Pair(cur.getKey() + 1, next));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int hash(int[][] mat) {\\n        int val = 0;\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[i].length; j++) {\\n                int idx = i * mat[i].length + j;\\n                val |= mat[i][j] << idx;\\n            }\\n        }\\n        \\n        return val;\\n    }\\n    \\n    private int flip(int num, int pos, int n, int m) {\\n        num ^= 1 << pos;\\n        \\n        if (pos % m != 0) num ^= 1 << (pos - 1);\\n        if (pos % m != m - 1) num ^= 1 << (pos + 1);\\n        if (pos / m > 0) num ^= 1 << (pos - m);\\n        if (pos / m != n - 1) num ^= 1 << (pos + m);\\n        \\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        int required = hash(mat);\\n        if (required == 0) {\\n            return 0;\\n        }\\n        \\n        queue.add(new Pair(0, 0));\\n        visited.add(0);\\n        \\n        while (!queue.isEmpty()) {\\n            Pair<Integer, Integer> cur = queue.poll();\\n            \\n            for (int pos = 0; pos < mat.length * mat[0].length; pos++) {\\n                int next = flip(cur.getValue(), pos, mat.length, mat[0].length);\\n                \\n                if (next == required) {\\n                    return cur.getKey() + 1;\\n                }\\n                \\n                if (visited.contains(next)) {\\n                    continue;\\n                }\\n                \\n                visited.add(next);\\n                queue.add(new Pair(cur.getKey() + 1, next));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int hash(int[][] mat) {\\n        int val = 0;\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[i].length; j++) {\\n                int idx = i * mat[i].length + j;\\n                val |= mat[i][j] << idx;\\n            }\\n        }\\n        \\n        return val;\\n    }\\n    \\n    private int flip(int num, int pos, int n, int m) {\\n        num ^= 1 << pos;\\n        \\n        if (pos % m != 0) num ^= 1 << (pos - 1);\\n        if (pos % m != m - 1) num ^= 1 << (pos + 1);\\n        if (pos / m > 0) num ^= 1 << (pos - m);\\n        if (pos / m != n - 1) num ^= 1 << (pos + m);\\n        \\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651781,
                "title": "c-clean-code-adityarev",
                "content": "```\\nstruct Node {\\n    int value;\\n    int count;\\n};\\n\\nclass Solution {\\nprivate:\\n    int row;\\n    int col;\\n    list<Node> bfs;\\n    vector<bool> visited;\\n    \\n    void init(vector<vector<int>>& mat) {\\n        row = (int)mat.size();\\n        col = (int)mat[0].size();\\n        bfs.clear();\\n        visited = vector<bool>(pow(2, row * col), false);\\n    }\\n    \\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        init(mat);\\n        \\n        int initial_value = get_initial_value(mat);\\n        mark_node({initial_value, 0});\\n        \\n        while (!bfs.empty()) {\\n            Node node = bfs.front();\\n            bfs.pop_front();\\n            \\n            if (node.value == 0)\\n                return node.count;\\n            \\n            vector<Node> future_nodes = get_future_nodes(node);\\n            \\n            for (Node& future_node: future_nodes)\\n                mark_node(future_node);\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    vector<Node> get_future_nodes(Node& node) {\\n        vector<Node> future_nodes;\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                Node future_node = get_future_node(node, i, j);\\n                future_nodes.push_back(future_node);\\n            }\\n        }\\n        \\n        return future_nodes;\\n    }\\n    \\n    Node get_future_node(Node& node, int i, int j) {\\n        static vector<vector<int>> moves = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        \\n        int index = get_index(i, j);\\n        vector<int> flipped_indices = {index};\\n        \\n        for (vector<int>& move: moves) {\\n            int dx = move[0];\\n            int dy = move[1];\\n            int moved_index = get_moved_index(index, dx, dy);\\n            \\n            if (moved_index != -1)\\n                flipped_indices.push_back(moved_index);\\n        }\\n        \\n        int value = node.value;\\n        int count = node.count + 1;\\n        \\n        for (int& flipped_index: flipped_indices) {\\n            int mask = (1 << flipped_index);\\n            value ^= mask;\\n        }\\n        \\n        return {value, count};\\n    }\\n    \\n    void mark_node(Node node) {\\n        if (!visited[node.value]) {\\n            bfs.push_back(node);\\n            visited[node.value] = true;\\n        }\\n    }\\n    \\n    int get_initial_value(vector<vector<int>>& mat) {\\n        int value = 0;\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                int index = get_index(i, j);\\n                value |= (mat[i][j] << index);\\n            }\\n        }\\n        \\n        return value;\\n    }\\n    \\n    int get_index(int x, int y) {\\n        return x * col + y;\\n    }\\n    \\n    int get_moved_index(int index, int dx, int dy) {\\n        int i = index / col;\\n        int j = index % col;\\n        int x = i + dx;\\n        int y = j + dy;\\n        \\n        return (x < 0 || y < 0 || x >= row || y >= col) ? -1 : get_index(x, y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nstruct Node {\\n    int value;\\n    int count;\\n};\\n\\nclass Solution {\\nprivate:\\n    int row;\\n    int col;\\n    list<Node> bfs;\\n    vector<bool> visited;\\n    \\n    void init(vector<vector<int>>& mat) {\\n        row = (int)mat.size();\\n        col = (int)mat[0].size();\\n        bfs.clear();\\n        visited = vector<bool>(pow(2, row * col), false);\\n    }\\n    \\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        init(mat);\\n        \\n        int initial_value = get_initial_value(mat);\\n        mark_node({initial_value, 0});\\n        \\n        while (!bfs.empty()) {\\n            Node node = bfs.front();\\n            bfs.pop_front();\\n            \\n            if (node.value == 0)\\n                return node.count;\\n            \\n            vector<Node> future_nodes = get_future_nodes(node);\\n            \\n            for (Node& future_node: future_nodes)\\n                mark_node(future_node);\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    vector<Node> get_future_nodes(Node& node) {\\n        vector<Node> future_nodes;\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                Node future_node = get_future_node(node, i, j);\\n                future_nodes.push_back(future_node);\\n            }\\n        }\\n        \\n        return future_nodes;\\n    }\\n    \\n    Node get_future_node(Node& node, int i, int j) {\\n        static vector<vector<int>> moves = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        \\n        int index = get_index(i, j);\\n        vector<int> flipped_indices = {index};\\n        \\n        for (vector<int>& move: moves) {\\n            int dx = move[0];\\n            int dy = move[1];\\n            int moved_index = get_moved_index(index, dx, dy);\\n            \\n            if (moved_index != -1)\\n                flipped_indices.push_back(moved_index);\\n        }\\n        \\n        int value = node.value;\\n        int count = node.count + 1;\\n        \\n        for (int& flipped_index: flipped_indices) {\\n            int mask = (1 << flipped_index);\\n            value ^= mask;\\n        }\\n        \\n        return {value, count};\\n    }\\n    \\n    void mark_node(Node node) {\\n        if (!visited[node.value]) {\\n            bfs.push_back(node);\\n            visited[node.value] = true;\\n        }\\n    }\\n    \\n    int get_initial_value(vector<vector<int>>& mat) {\\n        int value = 0;\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                int index = get_index(i, j);\\n                value |= (mat[i][j] << index);\\n            }\\n        }\\n        \\n        return value;\\n    }\\n    \\n    int get_index(int x, int y) {\\n        return x * col + y;\\n    }\\n    \\n    int get_moved_index(int index, int dx, int dy) {\\n        int i = index / col;\\n        int j = index % col;\\n        int x = i + dx;\\n        int y = j + dy;\\n        \\n        return (x < 0 || y < 0 || x >= row || y >= col) ? -1 : get_index(x, y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637740,
                "title": "c-dp-bitmasking-backtracking",
                "content": "```\\ninline bool inside(int x, int y, int n, int m) {\\n  return (x >= 0 && x < n) && (y >= 0 && y < m);\\n}\\n\\nconst int pinf = std::numeric_limits<int>::max();\\n\\nclass Solution {\\n public:\\n  int minFlips(vector<vector<int>>& mat) {\\n    int n = mat.size();\\n    int m = mat[0].size();\\n    int total = (1 << (n * m));\\n    vector <bool> seen(total, false);\\n    vector <int> dp(total, -1);\\n    function <int(int)> get = [&] (int mask) -> int {\\n      if (mask == 0) {\\n        return 0;\\n      }\\n      if (dp[mask] != -1) return dp[mask];\\n      if (seen[mask]) return pinf;\\n      seen[mask] = true;\\n      int ans = pinf;\\n      for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n          int u = i * m + j;\\n          int temp = mask;\\n          temp ^= (1 << u);\\n          for (int dx = -1; dx <= 1; dx++) {\\n            for (int dy = -1; dy <= 1; dy++) {\\n              if (abs(dx) + abs(dy) == 1) {\\n                int vx = i + dx;\\n                int vy = j + dy;\\n                if (inside(vx, vy, n, m)) {\\n                  int v = vx * m + vy;\\n                  temp ^= (1 << v);\\n                } \\n              } \\n            } \\n          }\\n          int ret = get(temp);\\n          if (ret != pinf) {\\n            ans = min(ans, ret + 1);\\n          } \\n        } \\n      } \\n      seen[mask] = false;\\n      return dp[mask] = ans; \\n    };\\n    int mask = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (mat[i][j] == 1) {\\n          int u = i * m + j;\\n          mask |= (1 << u);\\n        } \\n      } \\n    } \\n    int ans = get(mask);\\n    return ans == pinf ? -1 : ans;\\n  }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\ninline bool inside(int x, int y, int n, int m) {\\n  return (x >= 0 && x < n) && (y >= 0 && y < m);\\n}\\n\\nconst int pinf = std::numeric_limits<int>::max();\\n\\nclass Solution {\\n public:\\n  int minFlips(vector<vector<int>>& mat) {\\n    int n = mat.size();\\n    int m = mat[0].size();\\n    int total = (1 << (n * m));\\n    vector <bool> seen(total, false);\\n    vector <int> dp(total, -1);\\n    function <int(int)> get = [&] (int mask) -> int {\\n      if (mask == 0) {\\n        return 0;\\n      }\\n      if (dp[mask] != -1) return dp[mask];\\n      if (seen[mask]) return pinf;\\n      seen[mask] = true;\\n      int ans = pinf;\\n      for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n          int u = i * m + j;\\n          int temp = mask;\\n          temp ^= (1 << u);\\n          for (int dx = -1; dx <= 1; dx++) {\\n            for (int dy = -1; dy <= 1; dy++) {\\n              if (abs(dx) + abs(dy) == 1) {\\n                int vx = i + dx;\\n                int vy = j + dy;\\n                if (inside(vx, vy, n, m)) {\\n                  int v = vx * m + vy;\\n                  temp ^= (1 << v);\\n                } \\n              } \\n            } \\n          }\\n          int ret = get(temp);\\n          if (ret != pinf) {\\n            ans = min(ans, ret + 1);\\n          } \\n        } \\n      } \\n      seen[mask] = false;\\n      return dp[mask] = ans; \\n    };\\n    int mask = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (mat[i][j] == 1) {\\n          int u = i * m + j;\\n          mask |= (1 << u);\\n        } \\n      } \\n    } \\n    int ans = get(mask);\\n    return ans == pinf ? -1 : ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632677,
                "title": "java-bfs-clean-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minFlips(int[][] mat){\\n\\t\\t\\t\\tif(mat == null || mat.length == 0)\\n\\t\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\t\\tQueue<int[][]> queue = new LinkedList<>();\\n\\t\\t\\t\\tqueue.add(mat);\\n\\t\\t\\t\\tSet<Integer> visited = new HashSet<>();\\n\\t\\t\\t\\tint count = 0;\\n\\n\\t\\t\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\t\\t\\tint size = queue.size();\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tfor(int i = 0; i < size; i++){\\n\\t\\t\\t\\t\\t\\tint[][] cur = queue.poll();\\n\\t\\t\\t\\t\\t\\tif(convert(cur) == 0)\\n\\t\\t\\t\\t\\t\\t\\treturn count - 1;\\n\\n\\t\\t\\t\\t\\t\\tfor(int r = 0; r < mat.length; r++){\\n\\t\\t\\t\\t\\t\\t\\tfor(int c = 0; c < mat[0].length; c++){\\n\\t\\t\\t\\t\\t\\t\\t\\tint[][] fl = deepCopy(flip(cur, r, c));\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!visited.contains(convert(fl)))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tqueue.add(fl);\\n\\t\\t\\t\\t\\t\\t\\t\\tvisited.add(convert(fl));\\n\\t\\t\\t\\t\\t\\t\\t\\tcur = flip(cur, r, c);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate int[][] deepCopy(int[][] A){\\n\\t\\t\\t\\tint[][] B = new int[A.length][A[0].length];\\n\\t\\t\\t\\tfor(int i = 0; i < A.length; i++){\\n\\t\\t\\t\\t\\tfor(int j = 0; j < A[0].length; j++){\\n\\t\\t\\t\\t\\t\\tB[i][j] = A[i][j];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn B;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate int[][] flip(int[][] mat, int i, int j){\\n\\t\\t\\t\\tmat[i][j] = (mat[i][j] + 1) % 2;\\n\\t\\t\\t\\tif(i + 1 < mat.length)\\n\\t\\t\\t\\t\\tmat[i + 1][j] = (mat[i + 1][j] + 1) % 2;\\n\\t\\t\\t\\tif(j + 1 < mat[0].length)\\n\\t\\t\\t\\t\\tmat[i][j + 1] = (mat[i][j + 1] + 1) % 2;\\n\\t\\t\\t\\tif(i - 1 >= 0)\\n\\t\\t\\t\\t\\tmat[i - 1][j] = (mat[i - 1][j] + 1) % 2;\\n\\t\\t\\t\\tif(j - 1 >= 0)\\n\\t\\t\\t\\t\\tmat[i][j - 1] = (mat[i][j - 1] + 1) % 2;\\n\\n\\t\\t\\t\\treturn mat;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate int convert(int[][] mat){\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < mat.length; i++){\\n\\t\\t\\t\\t\\tfor(int j = 0; j < mat[0].length; j++){\\n\\t\\t\\t\\t\\t\\tif(mat[i][j] == 1)\\n\\t\\t\\t\\t\\t\\t\\tres += 1 << (mat[0].length * (mat.length - i) + (mat[0].length -j));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minFlips(int[][] mat){\\n\\t\\t\\t\\tif(mat == null || mat.length == 0)\\n\\t\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\t\\tQueue<int[][]> queue = new LinkedList<>();\\n\\t\\t\\t\\tqueue.add(mat);\\n\\t\\t\\t\\tSet<Integer> visited = new HashSet<>();\\n\\t\\t\\t\\tint count = 0;\\n\\n\\t\\t\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\t\\t\\tint size = queue.size();\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tfor(int i = 0; i < size; i++){\\n\\t\\t\\t\\t\\t\\tint[][] cur = queue.poll();\\n\\t\\t\\t\\t\\t\\tif(convert(cur) == 0)\\n\\t\\t\\t\\t\\t\\t\\treturn count - 1;\\n\\n\\t\\t\\t\\t\\t\\tfor(int r = 0; r < mat.length; r++){\\n\\t\\t\\t\\t\\t\\t\\tfor(int c = 0; c < mat[0].length; c++){\\n\\t\\t\\t\\t\\t\\t\\t\\tint[][] fl = deepCopy(flip(cur, r, c));\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!visited.contains(convert(fl)))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tqueue.add(fl);\\n\\t\\t\\t\\t\\t\\t\\t\\tvisited.add(convert(fl));\\n\\t\\t\\t\\t\\t\\t\\t\\tcur = flip(cur, r, c);\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 535079,
                "title": "c-easy-to-understand-recursion-100-sc",
                "content": "Using @mongsiry013 solution\\n\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>> flip(vector<vector<int>> mat, int i, int j) {\\n        mat[i][j] ^= 1;\\n        if(i>0)mat[i-1][j]^=1;\\n        if(j>0)mat[i][j-1]^=1;\\n        if(i<m-1)mat[i+1][j]^=1;\\n        if(j<n-1)mat[i][j+1]^=1;\\n        return mat;\\n    }\\n    \\n    bool zeroMat(vector<vector<int>> mat) {\\n        for(int i = 0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(mat[i][j])return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int decide(vector<vector<int>> mat, int x, int y, int count) {\\n        if(x==m) {\\n            x = 0;\\n            y++;\\n        }\\n        if(y == n) {\\n            return zeroMat(mat)?count:INT_MAX;\\n        }  \\n        int op1 = decide(mat,x+1,y,count);\\n        int op2 = decide(flip(mat,x,y),x+1,y,count+1) ;\\n        return min(op1,op2);\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        int ans = decide(mat,0,0,0);\\n        return (ans == INT_MAX)?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>> flip(vector<vector<int>> mat, int i, int j) {\\n        mat[i][j] ^= 1;\\n        if(i>0)mat[i-1][j]^=1;\\n        if(j>0)mat[i][j-1]^=1;\\n        if(i<m-1)mat[i+1][j]^=1;\\n        if(j<n-1)mat[i][j+1]^=1;\\n        return mat;\\n    }\\n    \\n    bool zeroMat(vector<vector<int>> mat) {\\n        for(int i = 0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(mat[i][j])return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int decide(vector<vector<int>> mat, int x, int y, int count) {\\n        if(x==m) {\\n            x = 0;\\n            y++;\\n        }\\n        if(y == n) {\\n            return zeroMat(mat)?count:INT_MAX;\\n        }  \\n        int op1 = decide(mat,x+1,y,count);\\n        int op2 = decide(flip(mat,x,y),x+1,y,count+1) ;\\n        return min(op1,op2);\\n    }\\n    \\n    int minFlips(vector<vector<int>>& mat) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        int ans = decide(mat,0,0,0);\\n        return (ans == INT_MAX)?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533739,
                "title": "clean-and-readable-bitvector-c-beats-100-speed-100-space-0-ms-7-4-mb",
                "content": "```\\nclass Solution {\\nprivate: \\n    int M;\\n    int N;\\n    int MinFlipsSoFar;\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int MAGIC_CONSTANT = 200;\\n        \\n        // configure\\n        this->MinFlipsSoFar = MAGIC_CONSTANT;\\n        this->M = mat.size();\\n        this->N = mat[0].size();\\n        \\n        if (this->M * this->N >= MAGIC_CONSTANT) throw \"this won\\'t work\";\\n        \\n        // set up intial state\\n        int state = 0;        \\n        for (int i = 0; i < M*N; i++) state |= (mat[i/N][i%N] == 1 ? 1 << i : 0);\\n        if (state == 0) return 0;\\n        \\n        //dfs - sets internal field to min on runtime\\n        dfs(state, M*N - 1, 0);\\n        \\n        // return -1 if we never found a zero matrix\\n        return MinFlipsSoFar == MAGIC_CONSTANT ? -1 : this->MinFlipsSoFar;\\n    }\\n    \\n    \\n    void dfs(int state, int index, int flips) {\\n        // check termination conditions\\n        if (flips == this->MinFlipsSoFar || index < 0) return;\\n        \\n        // make sure our assumptions are maintained\\n        if (index >= ((this->M) * (this-> N)) || flips > this->MinFlipsSoFar) throw \"err\";\\n\\n        // create an newstate and check\\n        int newstate = this->getNewState(state, index);\\n        if (newstate == 0) this->MinFlipsSoFar = flips + 1;\\n        \\n        // dfs the powerset\\n        dfs(newstate, index-1, flips + 1);\\n        dfs(state, index-1, flips);\\n    }\\n    \\n    int getNewState(int state, int toFlip) {\\n        // recover row/column representation\\n        int r = toFlip/(this->N), c = toFlip % (this->N);\\n        \\n        //use row/column to check bounds, but otherwise modify state with neighbors\\n        if (r - 1 >= 0)      state ^= 1 << (toFlip - N);\\n        if (r + 1 < this->M) state ^= 1 << (toFlip + N);\\n        if (c - 1 >= 0)      state ^= 1 << (toFlip - 1);\\n        if (c + 1 < this->N) state ^= 1 << (toFlip + 1);\\n        state ^= (1 << toFlip);\\n        return state;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate: \\n    int M;\\n    int N;\\n    int MinFlipsSoFar;\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int MAGIC_CONSTANT = 200;\\n        \\n        // configure\\n        this->MinFlipsSoFar = MAGIC_CONSTANT;\\n        this->M = mat.size();\\n        this->N = mat[0].size();\\n        \\n        if (this->M * this->N >= MAGIC_CONSTANT) throw \"this won\\'t work\";\\n        \\n        // set up intial state\\n        int state = 0;        \\n        for (int i = 0; i < M*N; i++) state |= (mat[i/N][i%N] == 1 ? 1 << i : 0);\\n        if (state == 0) return 0;\\n        \\n        //dfs - sets internal field to min on runtime\\n        dfs(state, M*N - 1, 0);\\n        \\n        // return -1 if we never found a zero matrix\\n        return MinFlipsSoFar == MAGIC_CONSTANT ? -1 : this->MinFlipsSoFar;\\n    }\\n    \\n    \\n    void dfs(int state, int index, int flips) {\\n        // check termination conditions\\n        if (flips == this->MinFlipsSoFar || index < 0) return;\\n        \\n        // make sure our assumptions are maintained\\n        if (index >= ((this->M) * (this-> N)) || flips > this->MinFlipsSoFar) throw \"err\";\\n\\n        // create an newstate and check\\n        int newstate = this->getNewState(state, index);\\n        if (newstate == 0) this->MinFlipsSoFar = flips + 1;\\n        \\n        // dfs the powerset\\n        dfs(newstate, index-1, flips + 1);\\n        dfs(state, index-1, flips);\\n    }\\n    \\n    int getNewState(int state, int toFlip) {\\n        // recover row/column representation\\n        int r = toFlip/(this->N), c = toFlip % (this->N);\\n        \\n        //use row/column to check bounds, but otherwise modify state with neighbors\\n        if (r - 1 >= 0)      state ^= 1 << (toFlip - N);\\n        if (r + 1 < this->M) state ^= 1 << (toFlip + N);\\n        if (c - 1 >= 0)      state ^= 1 << (toFlip - 1);\\n        if (c + 1 < this->N) state ^= 1 << (toFlip + 1);\\n        state ^= (1 << toFlip);\\n        return state;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512782,
                "title": "c-bfs-bitmap-0ms-o-2-m-n",
                "content": "```\\nint minFlips(vector<vector<int>>& mat) {\\n\\tint m = mat.size(), n = mat[0].size(), mn = m * n;\\n\\tif (mn == 1) return mat[0][0] == 1;\\n\\tint p = 0;\\n\\tfor (int i = 0; i < mn; ++i) {\\n\\t\\tp += (1 << i) * mat[i / n][i%n];\\n\\t}\\n\\tif (!p) return 0;\\n\\tvector<bool> vt(1034, false);\\n\\tqueue<int> Q;\\n\\tQ.push(p);\\n\\tvt[p] = true;\\n\\tvector<int> dx{ 0,1,0,-1 }, dy{ 1,0,-1,0 };\\n\\tint res = 0;\\n\\twhile (!Q.empty()) {\\n\\t\\tres++;\\n\\t\\tfor (int k = Q.size(); k > 0; --k) {\\n\\t\\t\\tint y = Q.front();\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tfor (int i = 0; i < m; ++i) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\t\\tint x = y;\\n\\t\\t\\t\\t\\tint t = n * i + j;\\n\\t\\t\\t\\t\\tx = x & (1 << t) ? x - (1 << t) : x + (1 << t);\\n\\t\\t\\t\\t\\tfor (int k = 0; k < 4; ++k) {\\n\\t\\t\\t\\t\\t\\tint nx = dx[k] + i, ny = dy[k] + j;\\n\\t\\t\\t\\t\\t\\tif (nx >= 0 && nx < m && ny >= 0 && ny < n) {\\n\\t\\t\\t\\t\\t\\t\\tint y = (1 << (nx * n + ny));\\n\\t\\t\\t\\t\\t\\t\\tx = x & y ? x - y : x + y;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!x) return res;\\n\\t\\t\\t\\t\\tif (!vt[x]) {\\n\\t\\t\\t\\t\\t\\tQ.push(x);\\n\\t\\t\\t\\t\\t\\tvt[x] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint minFlips(vector<vector<int>>& mat) {\\n\\tint m = mat.size(), n = mat[0].size(), mn = m * n;\\n\\tif (mn == 1) return mat[0][0] == 1;\\n\\tint p = 0;\\n\\tfor (int i = 0; i < mn; ++i) {\\n\\t\\tp += (1 << i) * mat[i / n][i%n];\\n\\t}\\n\\tif (!p) return 0;\\n\\tvector<bool> vt(1034, false);\\n\\tqueue<int> Q;\\n\\tQ.push(p);\\n\\tvt[p] = true;\\n\\tvector<int> dx{ 0,1,0,-1 }, dy{ 1,0,-1,0 };\\n\\tint res = 0;\\n\\twhile (!Q.empty()) {\\n\\t\\tres++;\\n\\t\\tfor (int k = Q.size(); k > 0; --k) {\\n\\t\\t\\tint y = Q.front();\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tfor (int i = 0; i < m; ++i) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\t\\tint x = y;\\n\\t\\t\\t\\t\\tint t = n * i + j;\\n\\t\\t\\t\\t\\tx = x & (1 << t) ? x - (1 << t) : x + (1 << t);\\n\\t\\t\\t\\t\\tfor (int k = 0; k < 4; ++k) {\\n\\t\\t\\t\\t\\t\\tint nx = dx[k] + i, ny = dy[k] + j;\\n\\t\\t\\t\\t\\t\\tif (nx >= 0 && nx < m && ny >= 0 && ny < n) {\\n\\t\\t\\t\\t\\t\\t\\tint y = (1 << (nx * n + ny));\\n\\t\\t\\t\\t\\t\\t\\tx = x & y ? x - y : x + y;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!x) return res;\\n\\t\\t\\t\\t\\tif (!vt[x]) {\\n\\t\\t\\t\\t\\t\\tQ.push(x);\\n\\t\\t\\t\\t\\t\\tvt[x] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 495050,
                "title": "c-bitmap-short-solution",
                "content": "```\\nstatic vector<int> dirs = {0, 0, 1, 0, -1, 0};\\n\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& m) {\\n        unordered_set<int> v;\\n        queue<int> q;\\n        \\n        int s = getState(m);\\n        \\n        v.insert(s);\\n        q.push(s);\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                int t = q.front();\\n                q.pop();\\n                \\n                if(t == 0) return step;\\n                \\n                for(int i = 0; i < m.size(); i++) {\\n                    for(int j = 0; j < m[0].size(); j++) {\\n                        int nxt = getNextState(t, i, j, m.size(), m[0].size());\\n                        if(v.insert(nxt).second) q.push(nxt);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    \\n    int getNextState(int s, int i, int j, int m, int n) {\\n        for(int k = 0; k < dirs.size()-1; k++) {\\n            int x = i + dirs[k], y = j + dirs[k+1];\\n            if(x < 0 || x == m || y < 0 || y == n) continue;\\n            int p = x*n + y;\\n            s ^= 1 << p;\\n        }\\n        return s;\\n    }\\n    \\n    int getState(vector<vector<int>>& m) {\\n        int res = 0;\\n        for(int i = 0; i < m.size(); i++) {\\n            for(int j = 0; j < m[0].size(); j++) {\\n                res <<= 1;\\n                res |= m[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic vector<int> dirs = {0, 0, 1, 0, -1, 0};\\n\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& m) {\\n        unordered_set<int> v;\\n        queue<int> q;\\n        \\n        int s = getState(m);\\n        \\n        v.insert(s);\\n        q.push(s);\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                int t = q.front();\\n                q.pop();\\n                \\n                if(t == 0) return step;\\n                \\n                for(int i = 0; i < m.size(); i++) {\\n                    for(int j = 0; j < m[0].size(); j++) {\\n                        int nxt = getNextState(t, i, j, m.size(), m[0].size());\\n                        if(v.insert(nxt).second) q.push(nxt);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n    \\n    \\n    \\n    int getNextState(int s, int i, int j, int m, int n) {\\n        for(int k = 0; k < dirs.size()-1; k++) {\\n            int x = i + dirs[k], y = j + dirs[k+1];\\n            if(x < 0 || x == m || y < 0 || y == n) continue;\\n            int p = x*n + y;\\n            s ^= 1 << p;\\n        }\\n        return s;\\n    }\\n    \\n    int getState(vector<vector<int>>& m) {\\n        int res = 0;\\n        for(int i = 0; i < m.size(); i++) {\\n            for(int j = 0; j < m[0].size(); j++) {\\n                res <<= 1;\\n                res |= m[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493539,
                "title": "no-need-for-cache-it-is-a-subset-problem",
                "content": "\\'\\'\\'\\nfrom typing import List\\nclass Solution:\\n\\n    # Tips:\\n    # 1. Flipping the second time will restore.\\n    # 2. Flipping is not order dependent. Flipping  point 1 and then point 2 is the same as flipping point 2 and then point 1.\\n    # \\n    # Given the above, we only need to go over all M*N points once in order, for each point, we need to try two path: flip it and unflip it.\\n    # This problem is reduced to a standard subset problem of choosing subset of flip points in all M*N. The complexity is O(2^(mn)).\\n\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        self.res = float(\\'inf\\')\\n        M, N = len(mat), len(mat[0])\\n\\n        # flip point i, j and its neighbors\\n        def flip(i, j):\\n            if i - 1 >= 0:\\n                mat[i - 1][j] ^= 1\\n            if i + 1 < M:\\n                mat[i + 1][j] ^= 1\\n            if j - 1 >= 0:\\n                mat[i][j - 1] ^= 1\\n            if j + 1 < N:\\n                mat[i][j + 1] ^= 1\\n            mat[i][j] ^= 1\\n\\n        def next(i, j):\\n            if j == N - 1:\\n                return (i + 1, 0)\\n            else:\\n                return (i, j + 1)\\n\\n        def recurse(i, j, num):\\n            s = sum([sum(r) for r in mat])\\n            if s == 0:\\n                self.res = min(self.res, num)\\n                return # no need to look further\\n\\n            while i < M and j < N:\\n                flip(i, j) # path with flipping i,j\\n                i1, j1 = next(i, j)\\n                recurse(i1, j1, num + 1)\\n                flip(i, j) # unflip i, j. path without flipping i,j\\n                i, j = i1, j1\\n\\n        recurse(0, 0, 0)\\n        if self.res == float(\\'inf\\'):\\n            self.res = -1\\n        return self.res\\n\\ns = Solution()\\nassert s.minFlips([[0,0],[0,1]]) == 3\\nassert s.minFlips([[1,1,1],[1,0,1],[0,0,0]]) == 6\\nassert s.minFlips([[1,0,0],[1,0,0]]) == -1\\nassert s.minFlips([[0,1,0],[1,1,1]]) == 1\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nfrom typing import List\\nclass Solution:\\n\\n    # Tips:\\n    # 1. Flipping the second time will restore.\\n    # 2. Flipping is not order dependent. Flipping  point 1 and then point 2 is the same as flipping point 2 and then point 1.\\n    # \\n    # Given the above, we only need to go over all M*N points once in order, for each point, we need to try two path: flip it and unflip it.\\n    # This problem is reduced to a standard subset problem of choosing subset of flip points in all M*N. The complexity is O(2^(mn)).\\n\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        self.res = float(\\'inf\\')\\n        M, N = len(mat), len(mat[0])\\n\\n        # flip point i, j and its neighbors\\n        def flip(i, j):\\n            if i - 1 >= 0:\\n                mat[i - 1][j] ^= 1\\n            if i + 1 < M:\\n                mat[i + 1][j] ^= 1\\n            if j - 1 >= 0:\\n                mat[i][j - 1] ^= 1\\n            if j + 1 < N:\\n                mat[i][j + 1] ^= 1\\n            mat[i][j] ^= 1\\n\\n        def next(i, j):\\n            if j == N - 1:\\n                return (i + 1, 0)\\n            else:\\n                return (i, j + 1)\\n\\n        def recurse(i, j, num):\\n            s = sum([sum(r) for r in mat])\\n            if s == 0:\\n                self.res = min(self.res, num)\\n                return # no need to look further\\n\\n            while i < M and j < N:\\n                flip(i, j) # path with flipping i,j\\n                i1, j1 = next(i, j)\\n                recurse(i1, j1, num + 1)\\n                flip(i, j) # unflip i, j. path without flipping i,j\\n                i, j = i1, j1\\n\\n        recurse(0, 0, 0)\\n        if self.res == float(\\'inf\\'):\\n            self.res = -1\\n        return self.res\\n\\ns = Solution()\\nassert s.minFlips([[0,0],[0,1]]) == 3\\nassert s.minFlips([[1,1,1],[1,0,1],[0,0,0]]) == 6\\nassert s.minFlips([[1,0,0],[1,0,0]]) == -1\\nassert s.minFlips([[0,1,0],[1,1,1]]) == 1\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 454527,
                "title": "python-simple-bfs-solution",
                "content": "transform matrix to number, regard each row as binary representation=>number.\\neach row\\'s number< 1<<n, thus tranform to (1<<n)-ary base number by x<<n+y.\\n```\\nclass Solution(object):\\n    def minFlips(self, mat):\\n        def mat2num(mat):\\n            return reduce(lambda x,y:(x<<n)+y,[reduce(lambda x,y:2*x+y,lis) for lis in mat])\\n        \\n        def flip(mat,i,j):\\n            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1),(0,0)]:\\n                if 0<=i+dx<m and 0<=j+dy<n:\\n                    mat[i+dx][j+dy]^=1\\n            \\n            \\n        m,n=len(mat),len(mat[0])\\n        st=mat2num(mat)\\n        if st==0:\\n            return 0\\n        seen={st}\\n        tmp=mat\\n        q=collections.deque([(mat,0)])\\n        while q:\\n            mat,steps=q.popleft()\\n            \\n            for i in range(m):\\n                for j in range(n): \\n                    flip(mat,i,j)\\n                    val=mat2num(mat)\\n                    if val==0:\\n                        return steps+1\\n                    if val not in seen:\\n                        q.append(([lis[:] for lis in mat],steps+1))\\n                        seen.add(val)\\n                    flip(mat,i,j)\\n        return -1",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def minFlips(self, mat):\\n        def mat2num(mat):\\n            return reduce(lambda x,y:(x<<n)+y,[reduce(lambda x,y:2*x+y,lis) for lis in mat])\\n        \\n        def flip(mat,i,j):\\n            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1),(0,0)]:\\n                if 0<=i+dx<m and 0<=j+dy<n:\\n                    mat[i+dx][j+dy]^=1\\n            \\n            \\n        m,n=len(mat),len(mat[0])\\n        st=mat2num(mat)\\n        if st==0:\\n            return 0\\n        seen={st}",
                "codeTag": "Java"
            },
            {
                "id": 453432,
                "title": "java-bfs-solution-2ms-100-memory",
                "content": "Comments are inside the code:\\n\\n\\tclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int numelems = mat.length * mat[0].length;   \\n        int[] path = new int[(int)Math.pow(2, numelems) + 1];\\n        int flips = getFlips(mat, path, mat.length, mat[0].length);\\n        return flips;\\n    }\\n    \\n     private int getFlips(int[][] mat, int[] path, int height, int width) {\\n         // check original matrix, if it\\'s already 0\\n        int firstBit = mat2bit(mat);\\n        if ((firstBit^0) == 0) return mat[0][0];\\n         \\n        // original matrix is not 0, therefore wi put it\\'s numeric representation in queue\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.add(firstBit);\\n        \\n        while (!q.isEmpty()) {\\n            // take first available queue element\\n            int curBit = q.remove();\\n            // convert it to matrix\\n            int[][]m = bit2mat(curBit, height, width);\\n            \\n            // consider each element of matrix\\n            for (int i = 0; i < m.length; i++) {\\n                for (int j = 0; j < m[i].length; j++) {\\n                    // flip matrix at point (i,j)\\n                    m = flip(m, i, j); // matrix snippet\\n                    // calculate it\\'s number\\n                    int mbit = mat2bit(m);\\n                   \\n                    // if mbit corresponds to the original matrix, we do not consider mbit\\n                    // check number of paths we arrived to this number mbit\\n                    if (mbit!=firstBit && (path[mbit]==0 || path[mbit]>path[curBit]+1)) {\\n                        path[mbit] = path[curBit] + 1;\\n                        // if mbit corresponds to 0-matrix, we are done\\n                        if ((mbit^0) == 0) return path[0];\\n                         // otherwise, add mbit to queue\\n                        q.add(mbit);\\n                    } \\n                    \\n                    // return snippet to the original state before flipping\\n                    m = flip(m, i, j); // return m to original state\\n                }\\n            }\\n        }\\n         // we did not exit before and queue is empty, there is no solution therefore\\n        return -1;\\n    }\\n    \\n    // converts number to binary matrix\\n    private int mat2bit (int[][]mat) {\\n        int res = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[i].length; j++) {\\n                res = res * 2 + mat[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // converts binary matrix to number\\n    private int[][]bit2mat(int num, int height, int width) {\\n        int res[][] = new int[height][width];\\n        for (int i = height-1; i>=0; i--) {\\n            for (int j = width-1; j>=0; j--) {\\n                res[i][j] = (int)num % 2;\\n                num = num/2;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // flips matrix startinng from element (i,j)\\n    private int[][] flip(int[][]mat, int i, int j) {\\n        mat[i][j] = mat[i][j] == 1 ? 0 : 1;\\n        if (i>0) mat[i-1][j] = mat[i-1][j]==1 ? 0 : 1;\\n        if (i<mat.length-1) mat[i+1][j] = mat[i+1][j] == 1 ? 0 : 1;\\n        if (j>0) mat[i][j-1] = mat[i][j-1] == 1 ? 0 : 1;\\n        if (j<mat[i].length-1) mat[i][j+1] = mat[i][j+1] == 1 ? 0 : 1;\\n        return mat;\\n    }\\n    \\n    private void printMatrix(int[][]matrix) {\\n        for (int i = 0; i < matrix.length; i++) {         \\n         for (int j = 0; j < matrix[i].length; j++) {  \\n            System.out.print(matrix[i][j] + \" \");\\n         }\\n         System.out.println(); //change line on console as row comes to end in the matrix.\\n      }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int minFlips(int[][] mat) {\\n        int numelems = mat.length * mat[0].length;   \\n        int[] path = new int[(int)Math.pow(2, numelems) + 1];\\n        int flips = getFlips(mat, path, mat.length, mat[0].length);\\n        return flips;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 451100,
                "title": "bfs-solution-explained",
                "content": "Use queue to store matrix states, set to store the code generated from a given matrix.\\nPush the start element into queue. Do following \\n1. pop first element from queue.\\n2. Generate possible matrices from the popped matrix and their respective code.\\n3. Enqueue the generated matrices, if the generated code is not seen before.\\n4. If generated code is 0, we have reached the target matrix.\\nIf no where in the traversal we get generated code as 0, return -1\\n```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        if(checkZeroMatrix(mat)) {\\n            return 0;\\n        }\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        Queue<int[][]> q = new LinkedList<>();\\n        Set<Integer> set = new HashSet<>();\\n        q.add(mat);\\n        set.add(generateCode(mat));\\n        int steps = 0;\\n        while(!q.isEmpty()) {\\n            steps++;\\n            int size = q.size();\\n            while(size > 0) {\\n                int[][] temp = q.poll();\\n                size--;\\n                for(int i = 0; i < row; i++) {\\n                    for(int j = 0; j < col; j++) {\\n                        int newMat[][] = new int[row][col];\\n                        clone(newMat, temp);\\n                        newMat[i][j] = 1 - newMat[i][j];\\n                        if(i-1>=0) {\\n                            newMat[i-1][j] = 1 - newMat[i-1][j];\\n                        }\\n                        if(j-1>=0) {\\n                            newMat[i][j-1] = 1 - newMat[i][j-1];\\n                        }\\n\\n                        if(i+1<row) {\\n                            newMat[i+1][j] = 1 - newMat[i+1][j];\\n                        }\\n                        if(j+1< col) {\\n                            newMat[i][j+1] = 1 - newMat[i][j+1];\\n                        }\\n\\n                        int code = generateCode(newMat);\\n\\n                        if(!set.contains(code)) {\\n                            set.add(code);\\n                            q.add(newMat);\\n                        }\\n                    }\\n                }\\n                if(set.contains(0)) {\\n                    return steps;\\n                }\\n            }\\n          \\n        }\\n        return -1;\\n    }\\n    boolean checkZeroMatrix(int [][] mat) {\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        int res = 0;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(mat[i][j] == 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int generateCode(int[][] mat) {\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        int res = 0;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(mat[i][j] == 1) {\\n                    int index = i * col + j;\\n                    res = res | (1 << index);    \\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void clone(int[][] newMat, int[][] temp) {\\n        int row = temp.length;\\n        int col = temp[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                newMat[i][j] = temp[i][j];\\n            }\\n        } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        if(checkZeroMatrix(mat)) {\\n            return 0;\\n        }\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        Queue<int[][]> q = new LinkedList<>();\\n        Set<Integer> set = new HashSet<>();\\n        q.add(mat);\\n        set.add(generateCode(mat));\\n        int steps = 0;\\n        while(!q.isEmpty()) {\\n            steps++;\\n            int size = q.size();\\n            while(size > 0) {\\n                int[][] temp = q.poll();\\n                size--;\\n                for(int i = 0; i < row; i++) {\\n                    for(int j = 0; j < col; j++) {\\n                        int newMat[][] = new int[row][col];\\n                        clone(newMat, temp);\\n                        newMat[i][j] = 1 - newMat[i][j];\\n                        if(i-1>=0) {\\n                            newMat[i-1][j] = 1 - newMat[i-1][j];\\n                        }\\n                        if(j-1>=0) {\\n                            newMat[i][j-1] = 1 - newMat[i][j-1];\\n                        }\\n\\n                        if(i+1<row) {\\n                            newMat[i+1][j] = 1 - newMat[i+1][j];\\n                        }\\n                        if(j+1< col) {\\n                            newMat[i][j+1] = 1 - newMat[i][j+1];\\n                        }\\n\\n                        int code = generateCode(newMat);\\n\\n                        if(!set.contains(code)) {\\n                            set.add(code);\\n                            q.add(newMat);\\n                        }\\n                    }\\n                }\\n                if(set.contains(0)) {\\n                    return steps;\\n                }\\n            }\\n          \\n        }\\n        return -1;\\n    }\\n    boolean checkZeroMatrix(int [][] mat) {\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        int res = 0;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(mat[i][j] == 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int generateCode(int[][] mat) {\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        int res = 0;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(mat[i][j] == 1) {\\n                    int index = i * col + j;\\n                    res = res | (1 << index);    \\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void clone(int[][] newMat, int[][] temp) {\\n        int row = temp.length;\\n        int col = temp[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                newMat[i][j] = temp[i][j];\\n            }\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448895,
                "title": "bfs-using-bit-vectors-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        int start = 0;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (mat[i][j])\\n                    start |= (1 << (i * n + j));\\n        \\n        if (start == 0)\\n            return 0;\\n        \\n        queue<pair<int, int>> q;\\n        unordered_set<int> seen;\\n        \\n        q.push({start, 0});\\n        seen.insert(start);\\n        \\n        static const vector<vector<int>> moves{{0, 0}, {-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        while (!q.empty()) {\\n            auto cur = q.front(); q.pop();\\n            \\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    int state = cur.first;\\n                    for (auto& move: moves) {\\n                        int x = i + move[0], y = j + move[1];\\n                        if (x >= 0 && x < m && y >= 0 && y < n)\\n                            state ^= (1 << (x * n + y));\\n                    }\\n                    \\n                    if (state == 0)\\n                        return cur.second + 1;\\n                    \\n                    if (!seen.count(state)) {\\n                        seen.insert(state);\\n                        q.push({state, cur.second + 1});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        int start = 0;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (mat[i][j])\\n                    start |= (1 << (i * n + j));\\n        \\n        if (start == 0)\\n            return 0;\\n        \\n        queue<pair<int, int>> q;\\n        unordered_set<int> seen;\\n        \\n        q.push({start, 0});\\n        seen.insert(start);\\n        \\n        static const vector<vector<int>> moves{{0, 0}, {-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        while (!q.empty()) {\\n            auto cur = q.front(); q.pop();\\n            \\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    int state = cur.first;\\n                    for (auto& move: moves) {\\n                        int x = i + move[0], y = j + move[1];\\n                        if (x >= 0 && x < m && y >= 0 && y < n)\\n                            state ^= (1 << (x * n + y));\\n                    }\\n                    \\n                    if (state == 0)\\n                        return cur.second + 1;\\n                    \\n                    if (!seen.count(state)) {\\n                        seen.insert(state);\\n                        q.push({state, cur.second + 1});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448155,
                "title": "javascript-easy-to-understand-bfs-2-solutions",
                "content": "### SOLUTION 1\\n\\nTo find out the minimum number of flips for the matrix, the first thing that stands out from my brain is BFS. So I write down this code according to the BFS strategy. I got 68ms as the best for this strategy.\\nThere are some little tricks which I like to use:\\n\\n- Check the init value before the main loop.\\n- Use `^` operator to do the flip.\\n- Serialize the matrix to a number for visited checking.\\n- Use `JSON` methods to do deep copy for pure data.\\n\\n```js\\nconst minFlips = mat => {\\n  const row = mat.length - 1;\\n  const col = mat[0].length - 1;\\n  const initVal = serialize(mat);\\n  if (initVal === 0) return 0;\\n  const visited = new Set([initVal]);\\n  let queue = [mat];\\n  let step = 0;\\n\\n  while (queue.length) {\\n    const next = [];\\n    ++step;\\n    for (let i = 0; i < queue.length; ++i) {\\n      for (let x = 0; x <= row; ++x) {\\n        for (let y = 0; y <= col; ++y) {\\n          const fliped = flip(queue[i], x, y);\\n          const val = serialize(fliped);\\n          if (val === 0) return step;\\n          if (visited.has(val)) continue;\\n          visited.add(val);\\n          next.push(fliped)\\n        }\\n      }\\n    }\\n    queue = next;\\n  }\\n\\n  return -1;\\n\\n  function serialize(arr) {\\n    let value = 0;\\n    for (let i = 0; i <= row; ++i) {\\n      for (let j = 0; j <= col; ++j) {\\n        value = (value << 1) + arr[i][j];\\n      }\\n    }\\n    return value;\\n  }\\n\\n  function flip(arr, x, y) {\\n    const ret = JSON.parse(JSON.stringify(arr));\\n    ret[x][y] ^= 1;\\n    x > 0 && (ret[x - 1][y] ^= 1);\\n    y > 0 && (ret[x][y - 1] ^= 1);\\n    x < row && (ret[x + 1][y] ^= 1);\\n    y < col && (ret[x][y + 1] ^= 1);\\n    return ret;\\n  }\\n};\\n```\\n\\n### SOLUTION 2\\n\\nAfter I finished solution 1, I saw the title \"[C++] Bit vector + Regular BFS\" of [this post](https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/discuss/446306/C%2B%2B-Bit-vector-%2B-Regular-BFS). Then I recognized that I was so stupid. I\\'ve serialized the matrix to a number via bit operation. But I still create a 2D array every time and do the flip. Why not just flip the number?\\nSo I changed my code as follows whose best is 40ms.\\n\\n```js\\nconst minFlips = mat => {\\n  const BIT = [0, 1, 2, 4, 8, 16, 32, 64, 128, 256];\\n  const row = mat.length;\\n  const col = mat[0].length;\\n  const total = row * col;\\n\\n  let initVal = 0;\\n  for (let i = 0; i < row; ++i) {\\n    for (let j = 0; j < col; ++j) {\\n      initVal = (initVal << 1) + mat[i][j];\\n    }\\n  }\\n\\n  if (initVal === 0) return 0;\\n\\n  const visited = new Set([initVal]);\\n  let queue = [initVal];\\n  let step = 0;\\n\\n  while (queue.length) {\\n    const next = [];\\n    ++step;\\n    for (let i = 0; i < queue.length; ++i) {\\n      for (let x = 0; x < row; ++x) {\\n        for (let y = 0; y < col; ++y) {\\n          const diff = total - x * col - y;\\n          let fliped = queue[i] ^ BIT[diff];\\n          x > 0 && (fliped ^= BIT[diff + col]);\\n          x < row - 1 && (fliped ^= BIT[diff -col]);\\n          y > 0 && (fliped ^= BIT[diff + 1]);\\n          y < col - 1 && (fliped ^= BIT[diff - 1]);\\n          if (fliped === 0) return step;\\n          if (visited.has(fliped)) continue;\\n          visited.add(fliped);\\n          next.push(fliped)\\n        }\\n      }\\n    }\\n    queue = next;\\n  }\\n\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minFlips = mat => {\\n  const row = mat.length - 1;\\n  const col = mat[0].length - 1;\\n  const initVal = serialize(mat);\\n  if (initVal === 0) return 0;\\n  const visited = new Set([initVal]);\\n  let queue = [mat];\\n  let step = 0;\\n\\n  while (queue.length) {\\n    const next = [];\\n    ++step;\\n    for (let i = 0; i < queue.length; ++i) {\\n      for (let x = 0; x <= row; ++x) {\\n        for (let y = 0; y <= col; ++y) {\\n          const fliped = flip(queue[i], x, y);\\n          const val = serialize(fliped);\\n          if (val === 0) return step;\\n          if (visited.has(val)) continue;\\n          visited.add(val);\\n          next.push(fliped)\\n        }\\n      }\\n    }\\n    queue = next;\\n  }\\n\\n  return -1;\\n\\n  function serialize(arr) {\\n    let value = 0;\\n    for (let i = 0; i <= row; ++i) {\\n      for (let j = 0; j <= col; ++j) {\\n        value = (value << 1) + arr[i][j];\\n      }\\n    }\\n    return value;\\n  }\\n\\n  function flip(arr, x, y) {\\n    const ret = JSON.parse(JSON.stringify(arr));\\n    ret[x][y] ^= 1;\\n    x > 0 && (ret[x - 1][y] ^= 1);\\n    y > 0 && (ret[x][y - 1] ^= 1);\\n    x < row && (ret[x + 1][y] ^= 1);\\n    y < col && (ret[x][y + 1] ^= 1);\\n    return ret;\\n  }\\n};\\n```\n```js\\nconst minFlips = mat => {\\n  const BIT = [0, 1, 2, 4, 8, 16, 32, 64, 128, 256];\\n  const row = mat.length;\\n  const col = mat[0].length;\\n  const total = row * col;\\n\\n  let initVal = 0;\\n  for (let i = 0; i < row; ++i) {\\n    for (let j = 0; j < col; ++j) {\\n      initVal = (initVal << 1) + mat[i][j];\\n    }\\n  }\\n\\n  if (initVal === 0) return 0;\\n\\n  const visited = new Set([initVal]);\\n  let queue = [initVal];\\n  let step = 0;\\n\\n  while (queue.length) {\\n    const next = [];\\n    ++step;\\n    for (let i = 0; i < queue.length; ++i) {\\n      for (let x = 0; x < row; ++x) {\\n        for (let y = 0; y < col; ++y) {\\n          const diff = total - x * col - y;\\n          let fliped = queue[i] ^ BIT[diff];\\n          x > 0 && (fliped ^= BIT[diff + col]);\\n          x < row - 1 && (fliped ^= BIT[diff -col]);\\n          y > 0 && (fliped ^= BIT[diff + 1]);\\n          y < col - 1 && (fliped ^= BIT[diff - 1]);\\n          if (fliped === 0) return step;\\n          if (visited.has(fliped)) continue;\\n          visited.add(fliped);\\n          next.push(fliped)\\n        }\\n      }\\n    }\\n    queue = next;\\n  }\\n\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 447314,
                "title": "java-dfs",
                "content": "```\\nimport java.util.Arrays;\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        return dfs(mat, 0, 0);\\n    }\\n\\n    int dfs(int[][] mat, int i, int j){\\n        int m=mat.length, n=mat[0].length;\\n        if(test(mat)) return 0;\\n        if(i<0 || i>=m || j<0 || j>=n) return -1;\\n        //not flip\\n        int nc = j==n-1 ? dfs(copyArray(mat), i+1, 0) : dfs(copyArray(mat), i, j+1);\\n        //flip\\n        int[][] flipA = copyArray(mat);\\n        flip(flipA, i, j);\\n        int fc = j==n-1 ? dfs(flipA, i+1, 0) : dfs(flipA, i, j+1);\\n        //result\\n        if(nc==-1 && fc==-1) return -1;\\n        if(nc==-1) return fc+1;\\n        if(fc==-1) return nc;\\n        return Math.min(nc, fc+1);\\n    }\\n    \\n    boolean test(int[][] arr){\\n        int m=arr.length, n=arr[0].length;        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(arr[i][j]==1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int[][] dire= {{-1,0},{0,1},{1,0},{0,-1}};\\n    void flip(int[][] arr, int i, int j){\\n        int m=arr.length, n=arr[0].length;\\n        arr[i][j]=1-arr[i][j];\\n        for(int[] d:dire){\\n            int x=i+d[0], y=j+d[1];\\n            if(x<0 || x>=m || y<0 || y>=n) continue;\\n            arr[x][y] = 1-arr[x][y];\\n        }\\n    }\\n    \\n    int[][] copyArray(int[][] orig){\\n        int m=orig.length, n=orig[0].length;        \\n        int[][] na=new int[m][n];\\n        for(int i=0;i<m;i++)\\n            na[i]=Arrays.copyOf(orig[i], n);\\n        return na;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        return dfs(mat, 0, 0);\\n    }\\n\\n    int dfs(int[][] mat, int i, int j){\\n        int m=mat.length, n=mat[0].length;\\n        if(test(mat)) return 0;\\n        if(i<0 || i>=m || j<0 || j>=n) return -1;\\n        //not flip\\n        int nc = j==n-1 ? dfs(copyArray(mat), i+1, 0) : dfs(copyArray(mat), i, j+1);\\n        //flip\\n        int[][] flipA = copyArray(mat);\\n        flip(flipA, i, j);\\n        int fc = j==n-1 ? dfs(flipA, i+1, 0) : dfs(flipA, i, j+1);\\n        //result\\n        if(nc==-1 && fc==-1) return -1;\\n        if(nc==-1) return fc+1;\\n        if(fc==-1) return nc;\\n        return Math.min(nc, fc+1);\\n    }\\n    \\n    boolean test(int[][] arr){\\n        int m=arr.length, n=arr[0].length;        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(arr[i][j]==1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int[][] dire= {{-1,0},{0,1},{1,0},{0,-1}};\\n    void flip(int[][] arr, int i, int j){\\n        int m=arr.length, n=arr[0].length;\\n        arr[i][j]=1-arr[i][j];\\n        for(int[] d:dire){\\n            int x=i+d[0], y=j+d[1];\\n            if(x<0 || x>=m || y<0 || y>=n) continue;\\n            arr[x][y] = 1-arr[x][y];\\n        }\\n    }\\n    \\n    int[][] copyArray(int[][] orig){\\n        int m=orig.length, n=orig[0].length;        \\n        int[][] na=new int[m][n];\\n        for(int i=0;i<m;i++)\\n            na[i]=Arrays.copyOf(orig[i], n);\\n        return na;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447197,
                "title": "javascript-bfs-solution-92ms-easy-to-understand",
                "content": "bfs try all the possibility...\\n( for each cell, you click and put the next matrix into next arr, then recursive until you find a matrix with all 0 cells )\\n\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n    \\n  let h = mat.length;\\n  if(h === 0) return 0;\\n  let w = mat[0].length;\\n  if(w === 0) return 0;\\n  \\n  const check = (arr) => {\\n      return arr.some(m => {\\n          let sum = 0;\\n          m.forEach(x => {\\n              x.forEach(y => sum += y);\\n          });\\n          \\n          return sum === 0;\\n      });\\n  };\\n  \\n  const cvt = (matrix) => {\\n      let tem = \"\";\\n      matrix.forEach(row => tem += row.join(\"\"));\\n      return tem;\\n  };\\n  \\n  let next = [mat];\\n  let res = 0;\\n  let used = {};\\n  let found = false;\\n  \\n  while(!found && next.length > 0){\\n      found = check(next);\\n      if(!found){\\n          let curr = next;\\n          next = [];\\n          \\n          curr.forEach(m => {\\n              let key = cvt(m);\\n              if(used[key] === undefined){\\n                  used[key] = 1;\\n                  m.forEach((row, i) => {\\n                      row.forEach((cell, j) => {\\n                          let tem = new Array(h).fill(0).map(x => new Array(w).fill(0));\\n                          //console.log(tem);\\n                          tem.forEach((rr, ii) => {\\n                              rr.forEach((cc, jj) => {\\n                                  if( (i===ii && j === jj) || (i===ii && Math.abs(j-jj) === 1) || (j===jj && Math.abs(i-ii) === 1) ){\\n                                      \\n                                      tem[ii][jj] = m[ii][jj] == 0 ? 1 : 0;\\n                                  } else {\\n                                      tem[ii][jj] = m[ii][jj];\\n                                  }\\n                              });\\n                          });\\n                          \\n                          next.push(tem);\\n                      });\\n                  });\\n                  \\n              }\\n          });\\n          res++;\\n      }\\n      \\n  }\\n  \\n  if(!found) return -1;\\n  return res;   \\n};",
                "solutionTags": [],
                "code": "bfs try all the possibility...\\n( for each cell, you click and put the next matrix into next arr, then recursive until you find a matrix with all 0 cells )\\n\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n    \\n  let h = mat.length;\\n  if(h === 0) return 0;\\n  let w = mat[0].length;\\n  if(w === 0) return 0;\\n  \\n  const check = (arr) => {\\n      return arr.some(m => {\\n          let sum = 0;\\n          m.forEach(x => {\\n              x.forEach(y => sum += y);\\n          });\\n          \\n          return sum === 0;\\n      });\\n  };\\n  \\n  const cvt = (matrix) => {\\n      let tem = \"\";\\n      matrix.forEach(row => tem += row.join(\"\"));\\n      return tem;\\n  };\\n  \\n  let next = [mat];\\n  let res = 0;\\n  let used = {};\\n  let found = false;\\n  \\n  while(!found && next.length > 0){\\n      found = check(next);\\n      if(!found){\\n          let curr = next;\\n          next = [];\\n          \\n          curr.forEach(m => {\\n              let key = cvt(m);\\n              if(used[key] === undefined){\\n                  used[key] = 1;\\n                  m.forEach((row, i) => {\\n                      row.forEach((cell, j) => {\\n                          let tem = new Array(h).fill(0).map(x => new Array(w).fill(0));\\n                          //console.log(tem);\\n                          tem.forEach((rr, ii) => {\\n                              rr.forEach((cc, jj) => {\\n                                  if( (i===ii && j === jj) || (i===ii && Math.abs(j-jj) === 1) || (j===jj && Math.abs(i-ii) === 1) ){\\n                                      \\n                                      tem[ii][jj] = m[ii][jj] == 0 ? 1 : 0;\\n                                  } else {\\n                                      tem[ii][jj] = m[ii][jj];\\n                                  }\\n                              });\\n                          });\\n                          \\n                          next.push(tem);\\n                      });\\n                  });\\n                  \\n              }\\n          });\\n          res++;\\n      }\\n      \\n  }\\n  \\n  if(!found) return -1;\\n  return res;   \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 446932,
                "title": "python-dfs-ans-bfs-use-flatten-mat",
                "content": "DFS (Backtracking) solution\\nUse a hashmap to memoization calculated solution, and this is also a top-down dp process\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        vector = [] # flat matrix as vector\\n        for row in mat:\\n            for num in row:\\n                vector.append(num)\\n\\t    ans = self.dfs(vector, 0, {}, len(mat[0]))\\n        return ans if ans != float(\"inf\") else -1\\n    \\n    def dfs(self, vector, start, memo, row_len):\\n        this_str = \\'\\'.join(str(num) for num in vector) # convert the vector to string, which is used as the key for dict\\n        if this_str in memo: # if the key is already calculated, return the result\\n            return memo[this_str]\\n        if sum(vector) == 0: # This is all zero, return, and put the key in the dict\\n            memo[this_str] = 0\\n            return memo[this_str]\\n        \\n        ans = float(\"inf\")\\n        for i in range(start, len(vector)):\\n            self.flip(vector, i, row_len)\\n            next_str = \\'\\'.join(str(num) for num in vector)\\n            ans = min(ans, self.dfs(vector, start + 1,memo, row_len) + 1) \\n            self.flip(vector, i, row_len) # flip back, this is the back track process\\n        memo[this_str] = ans\\n        return memo[this_str]\\n    \\n    def flip(self, vector, i, row_len):\\n        vector[i] = 0 if vector[i] == 1 else 1\\n        if i - row_len >= 0:\\n            vector[i - row_len] = 0 if vector[i - row_len] == 1 else 1\\n        if i + row_len < len(vector):\\n            vector[i + row_len] = 0 if vector[i + row_len] == 1 else 1\\n        if i % row_len != 0:\\n            vector[i - 1] = 0 if vector[i - 1] == 1 else 1\\n        if i % row_len != row_len - 1:\\n            vector[i + 1] = 0 if vector[i + 1] == 1 else 1\\n```\\n\\nBFS:\\nBFS use a set instead of a dict that keep track of visited situation\\n\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        visited = set()\\n        vector = []\\n        for row in mat:\\n            for d in row:\\n                vector.append(d)\\n        visited = set()\\n        visited.add(\\'\\'.join(str(e) for e in vector))\\n        queue = [vector]\\n        flip = 0\\n        while queue:\\n            level_len = len(queue)\\n            for i in range(level_len):\\n                this_vec = queue.pop(0)\\n                if sum(this_vec) == 0:\\n                    return flip\\n                for i in range(len(this_vec)):\\n                    next_vec = self.flip(this_vec, i, len(mat[0]))\\n                    next_str = \\'\\'.join(str(e) for e in next_vec)\\n                    if next_str not in visited:\\n                        queue.append(next_vec)\\n                        visited.add(\\'\\'.join(str(e) for e in next_vec))\\n            flip += 1\\n        return -1\\n    \\n    def flip(self, vec, i, row_len):\\n        ans = vec[:]\\n        ans[i] = 0 if ans[i] == 1 else 1\\n        if i - row_len >= 0:\\n            ans[i - row_len] = 0 if ans[i - row_len] == 1 else 1\\n        if i + row_len < len(vec):\\n            ans[i + row_len] = 0 if ans[i + row_len] == 1 else 1\\n        if i % row_len != 0:\\n            ans[i - 1] = 0 if ans[i - 1] == 1 else 1\\n        if i % row_len != row_len - 1:\\n            ans[i + 1] = 0 if ans[i + 1] == 1 else 1\\n        return ans\\n        \\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        vector = [] # flat matrix as vector\\n        for row in mat:\\n            for num in row:\\n                vector.append(num)\\n\\t    ans = self.dfs(vector, 0, {}, len(mat[0]))\\n        return ans if ans != float(\"inf\") else -1\\n    \\n    def dfs(self, vector, start, memo, row_len):\\n        this_str = \\'\\'.join(str(num) for num in vector) # convert the vector to string, which is used as the key for dict\\n        if this_str in memo: # if the key is already calculated, return the result\\n            return memo[this_str]\\n        if sum(vector) == 0: # This is all zero, return, and put the key in the dict\\n            memo[this_str] = 0\\n            return memo[this_str]\\n        \\n        ans = float(\"inf\")\\n        for i in range(start, len(vector)):\\n            self.flip(vector, i, row_len)\\n            next_str = \\'\\'.join(str(num) for num in vector)\\n            ans = min(ans, self.dfs(vector, start + 1,memo, row_len) + 1) \\n            self.flip(vector, i, row_len) # flip back, this is the back track process\\n        memo[this_str] = ans\\n        return memo[this_str]\\n    \\n    def flip(self, vector, i, row_len):\\n        vector[i] = 0 if vector[i] == 1 else 1\\n        if i - row_len >= 0:\\n            vector[i - row_len] = 0 if vector[i - row_len] == 1 else 1\\n        if i + row_len < len(vector):\\n            vector[i + row_len] = 0 if vector[i + row_len] == 1 else 1\\n        if i % row_len != 0:\\n            vector[i - 1] = 0 if vector[i - 1] == 1 else 1\\n        if i % row_len != row_len - 1:\\n            vector[i + 1] = 0 if vector[i + 1] == 1 else 1\\n```\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        visited = set()\\n        vector = []\\n        for row in mat:\\n            for d in row:\\n                vector.append(d)\\n        visited = set()\\n        visited.add(\\'\\'.join(str(e) for e in vector))\\n        queue = [vector]\\n        flip = 0\\n        while queue:\\n            level_len = len(queue)\\n            for i in range(level_len):\\n                this_vec = queue.pop(0)\\n                if sum(this_vec) == 0:\\n                    return flip\\n                for i in range(len(this_vec)):\\n                    next_vec = self.flip(this_vec, i, len(mat[0]))\\n                    next_str = \\'\\'.join(str(e) for e in next_vec)\\n                    if next_str not in visited:\\n                        queue.append(next_vec)\\n                        visited.add(\\'\\'.join(str(e) for e in next_vec))\\n            flip += 1\\n        return -1\\n    \\n    def flip(self, vec, i, row_len):\\n        ans = vec[:]\\n        ans[i] = 0 if ans[i] == 1 else 1\\n        if i - row_len >= 0:\\n            ans[i - row_len] = 0 if ans[i - row_len] == 1 else 1\\n        if i + row_len < len(vec):\\n            ans[i + row_len] = 0 if ans[i + row_len] == 1 else 1\\n        if i % row_len != 0:\\n            ans[i - 1] = 0 if ans[i - 1] == 1 else 1\\n        if i % row_len != row_len - 1:\\n            ans[i + 1] = 0 if ans[i + 1] == 1 else 1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 446541,
                "title": "c-simple-brute-force",
                "content": "Code from nhho, 2nd on the leaderboard. \\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& x) {\\n        int n = x.size();\\n        int m =x[0].size();\\n        int ans = -1;\\n        for (int i = 0; i < (1 << (n * m)); i++) {\\n            auto y = x;\\n            int cnt = 0;\\n            for (int j = 0; j < n * m; j++) {\\n                if (i & (1 << j)) {\\n                    cnt++;\\n                    int a = j / m;\\n                    int b = j % m;\\n                    y[a][b] ^= 1;\\n                    if (a)\\n                        y[a - 1][b] ^= 1;\\n                    if (b)\\n                        y[a][b - 1] ^= 1;\\n                    if (a != n - 1)\\n                        y[a + 1][b] ^= 1;\\n                    if (b != m- 1)\\n                        y[a][b + 1] ^= 1;\\n\\t\\t\\t    }\\n            }\\n            bool ok= 1;\\n            for (auto& j : y)for (int k : j) if (k)ok = 0;\\n            if (ok && (ans == -1 || cnt < ans))\\n                ans = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThe essence of beauty lies in the if statement\\n```\\nif (i & (1 << j))\\n```\\nwhich gives the following combinations\\ni=1,  j=0\\ni=2,  j=1\\ni=3,  j=0, 1\\ni=4,  j=2\\ni=5,  j=2, 0\\ni=6,  j=2, 1\\ni=7,  j=2, 1, 0\\ni=8,  j=3\\ni=9,  j=3, 0\\ni=10,  j=3, 1\\ni=11,  j=3, 1, 0\\ni=12,  j=3, 2\\ni=13,  j=3, 2, 0\\ni=14,  j=3 ,2 ,1\\ni=15,  j=3, 2, 1, 0\\n...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& x) {\\n        int n = x.size();\\n        int m =x[0].size();\\n        int ans = -1;\\n        for (int i = 0; i < (1 << (n * m)); i++) {\\n            auto y = x;\\n            int cnt = 0;\\n            for (int j = 0; j < n * m; j++) {\\n                if (i & (1 << j)) {\\n                    cnt++;\\n                    int a = j / m;\\n                    int b = j % m;\\n                    y[a][b] ^= 1;\\n                    if (a)\\n                        y[a - 1][b] ^= 1;\\n                    if (b)\\n                        y[a][b - 1] ^= 1;\\n                    if (a != n - 1)\\n                        y[a + 1][b] ^= 1;\\n                    if (b != m- 1)\\n                        y[a][b + 1] ^= 1;\\n\\t\\t\\t    }\\n            }\\n            bool ok= 1;\\n            for (auto& j : y)for (int k : j) if (k)ok = 0;\\n            if (ok && (ans == -1 || cnt < ans))\\n                ans = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nif (i & (1 << j))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446531,
                "title": "java-use-int-represent-status",
                "content": "```\\nclass Solution {\\n public int minFlips(int[][] mat) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int target = 0;\\n        int ori = 0;\\n        for (int i = 0; i < m; i ++) {\\n            for (int j = 0; j < n; j ++) {\\n                if (mat[i][j] == 1)\\n                ori = ori | (1 << (i * n + j));\\n            }\\n        }\\n        HashSet<Integer> visited = new HashSet<>();\\n        visited.add(ori);\\n        queue.add(ori);\\n        int result = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i ++) {\\n                int mids = queue.poll();\\n                if (mids == target){\\n                    return result;\\n                }\\n                for (int j = 0; j < m * n; j ++) {\\n                    int next = next(mids, m, n, j);\\n                    if (!visited.contains(next)) {\\n                        queue.add(next);\\n                        visited.add(next);\\n                    }\\n\\n                }\\n            }\\n            result ++;\\n        }\\n        return -1;\\n    }\\n    int[][] ds = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int next(int s, int m, int n, int num) {\\n        int i = num / n;\\n        int j = num % n;\\n        s = s ^ (1 << (num));\\n        for (int[] d: ds) {\\n            int nr = d[0] + i;\\n            int nc = d[1] + j;\\n            if (nr < m && nr >= 0 && nc < n && nc >= 0) {\\n                s = s ^ (1 << (nr * n + nc));\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public int minFlips(int[][] mat) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int target = 0;\\n        int ori = 0;\\n        for (int i = 0; i < m; i ++) {\\n            for (int j = 0; j < n; j ++) {\\n                if (mat[i][j] == 1)\\n                ori = ori | (1 << (i * n + j));\\n            }\\n        }\\n        HashSet<Integer> visited = new HashSet<>();\\n        visited.add(ori);\\n        queue.add(ori);\\n        int result = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i ++) {\\n                int mids = queue.poll();\\n                if (mids == target){\\n                    return result;\\n                }\\n                for (int j = 0; j < m * n; j ++) {\\n                    int next = next(mids, m, n, j);\\n                    if (!visited.contains(next)) {\\n                        queue.add(next);\\n                        visited.add(next);\\n                    }\\n\\n                }\\n            }\\n            result ++;\\n        }\\n        return -1;\\n    }\\n    int[][] ds = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int next(int s, int m, int n, int num) {\\n        int i = num / n;\\n        int j = num % n;\\n        s = s ^ (1 << (num));\\n        for (int[] d: ds) {\\n            int nr = d[0] + i;\\n            int nc = d[1] + j;\\n            if (nr < m && nr >= 0 && nc < n && nc >= 0) {\\n                s = s ^ (1 << (nr * n + nc));\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446511,
                "title": "python-bfs",
                "content": "```\\nclass Solution(object):\\n    def minFlips(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n        m, n = len(mat), len(mat[0])\\n\\n        def flip(xmat, x, y):\\n            new_mat = copy.deepcopy(xmat)\\n            new_mat[x][y] ^= 1\\n            for x1, y1 in dirs:\\n                xn, yn = x+x1, y+y1\\n                if 0 <= xn < m and 0 <= yn < n:\\n                    new_mat[xn][yn] ^= 1\\n            return new_mat\\n        \\n        visited = set()\\n        queue = collections.deque([[mat, 0]])\\n        while queue:\\n            for _ in xrange(len(queue)):\\n                cmat, cnt = queue.popleft()\\n                if sum(map(sum, cmat)) == 0: return cnt\\n                for i in xrange(m):\\n                    for j in xrange(n):\\n                        nmat = flip(cmat, i, j)\\n                        cur = tuple(map(tuple, nmat))\\n                        if cur in visited: continue\\n                        queue.append([nmat, cnt+1])\\n                        visited.add(cur)\\n        return -1\\n```\\nTime complexity O(2^(m*n))\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minFlips(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n        m, n = len(mat), len(mat[0])\\n\\n        def flip(xmat, x, y):\\n            new_mat = copy.deepcopy(xmat)\\n            new_mat[x][y] ^= 1\\n            for x1, y1 in dirs:\\n                xn, yn = x+x1, y+y1\\n                if 0 <= xn < m and 0 <= yn < n:\\n                    new_mat[xn][yn] ^= 1\\n            return new_mat\\n        \\n        visited = set()\\n        queue = collections.deque([[mat, 0]])\\n        while queue:\\n            for _ in xrange(len(queue)):\\n                cmat, cnt = queue.popleft()\\n                if sum(map(sum, cmat)) == 0: return cnt\\n                for i in xrange(m):\\n                    for j in xrange(n):\\n                        nmat = flip(cmat, i, j)\\n                        cur = tuple(map(tuple, nmat))\\n                        if cur in visited: continue\\n                        queue.append([nmat, cnt+1])\\n                        visited.add(cur)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446418,
                "title": "c-o-2-m-n",
                "content": "This is a brute-force solution, where you start with the given matrix and try out every possible flip at every position. At every flip, save the current matrix to `memo` to mark as visited.\\nTime: `O(2^(m*n))`\\nSpace: `O(2^(m*n))`\\nExplanation: there are `2^(m*n)` different states for a binary matrix of size `m*n`.\\nRefer [here](http://mathworld.wolfram.com/LightsOutPuzzle.html) for further optimization.\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size(), m = mat[0].size();\\n        memo[0] = 0;\\n        return helper(mat);\\n    }\\nprivate:\\n    unordered_map<int,int> memo;\\n    int n = 0, m = 0;\\n    int helper(vector<vector<int>> mat) {\\n        int hash_val = hash(mat);\\n        if (memo.count(hash_val)) {\\n            return memo[hash_val];\\n        }\\n        int result = INT_MAX;\\n        memo[hash_val] = -1; // visited\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                flip(mat, i, j);\\n                int temp_result = helper(mat);\\n                if (temp_result != -1) {\\n                    result = min(result, 1 + temp_result);\\n                    memo[hash_val] = result;\\n                }\\n                flip(mat, i, j);\\n            }\\n        }\\n        return memo[hash_val];\\n    }\\n    void flip(vector<vector<int>>& mat, int x, int y) {\\n        int dx[5] = { -1, 1, 0, 0, 0 };\\n        int dy[5] = {  0, 0,-1, 1, 0 };\\n        for (int i = 0; i < 5; i++) {\\n            int neighbor_x = x + dx[i], neighbor_y = y + dy[i];\\n            if (neighbor_x >= 0 && neighbor_y >= 0 && neighbor_x < n && neighbor_y < m) {\\n                mat[neighbor_x][neighbor_y] ^= 1;\\n            }\\n        }\\n    }\\n\\t// hash function to hash 2d binary matrix to memo, given this problem\\'s constraint\\n    int hash(const vector<vector<int>>& mat) { \\n        int hash_val = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                hash_val ^= (mat[i][j] << (i*m + j));\\n            }\\n        }\\n        return hash_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size(), m = mat[0].size();\\n        memo[0] = 0;\\n        return helper(mat);\\n    }\\nprivate:\\n    unordered_map<int,int> memo;\\n    int n = 0, m = 0;\\n    int helper(vector<vector<int>> mat) {\\n        int hash_val = hash(mat);\\n        if (memo.count(hash_val)) {\\n            return memo[hash_val];\\n        }\\n        int result = INT_MAX;\\n        memo[hash_val] = -1; // visited\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                flip(mat, i, j);\\n                int temp_result = helper(mat);\\n                if (temp_result != -1) {\\n                    result = min(result, 1 + temp_result);\\n                    memo[hash_val] = result;\\n                }\\n                flip(mat, i, j);\\n            }\\n        }\\n        return memo[hash_val];\\n    }\\n    void flip(vector<vector<int>>& mat, int x, int y) {\\n        int dx[5] = { -1, 1, 0, 0, 0 };\\n        int dy[5] = {  0, 0,-1, 1, 0 };\\n        for (int i = 0; i < 5; i++) {\\n            int neighbor_x = x + dx[i], neighbor_y = y + dy[i];\\n            if (neighbor_x >= 0 && neighbor_y >= 0 && neighbor_x < n && neighbor_y < m) {\\n                mat[neighbor_x][neighbor_y] ^= 1;\\n            }\\n        }\\n    }\\n\\t// hash function to hash 2d binary matrix to memo, given this problem\\'s constraint\\n    int hash(const vector<vector<int>>& mat) { \\n        int hash_val = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                hash_val ^= (mat[i][j] << (i*m + j));\\n            }\\n        }\\n        return hash_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446400,
                "title": "easy-and-simple-bfs-solution-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    static constexpr std::array< std::pair< int, int >, 4 > moves_ = { {\\n        { -1,  0 },\\n        {  1,  0 },\\n        {  0,  1 },\\n        {  0, -1 }\\n    } };\\n    \\n    struct Matrix {\\n        Matrix( const std::vector< std::vector< int > > & m )\\n        :   m_( m )\\n        {\\n            rows_ = m_.size();\\n            cols_ = m_.front().size();\\n        }\\n        \\n        int posEncoding() {\\n            int result = 0;\\n            int position = 0;\\n            for( int row = 0; row < rows_; row++ ) {\\n                for( int col = 0; col < cols_; col++ ) {\\n                    if( m_[ row ][ col ] != 0 ) {\\n                        result += ( 1 << position );\\n                    }\\n                    position++;\\n                }\\n            }\\n            return result;\\n        }\\n        \\n        Matrix flip( int row, int col ) const {\\n            std::vector< std::vector< int > > m( m_ );\\n            for( const auto & move : moves_ ) {\\n                int r = row + move.first;\\n                int c = col + move.second;\\n                if( r < 0 || r >= rows_ ) {\\n                    continue;\\n                }\\n                if( c < 0 || c >= cols_ ) {\\n                    continue;\\n                }\\n                \\n                m[ r ][ c ] = ( m[ r ][ c ] + 1 ) % 2;\\n            }\\n            \\n            m[ row ][ col ] = ( m[ row ][ col ] + 1 ) % 2;\\n            return Matrix( m );\\n        }\\n        \\n        int rows() const {\\n            return rows_;\\n        }\\n        \\n        int cols() const {\\n            return cols_;\\n        }\\n        \\n    private:\\n        std::vector< std::vector< int > > m_;\\n        int rows_;\\n        int cols_;\\n    };\\n    \\npublic:\\n    int minFlips( std::vector< std::vector< int > > & mat ) {\\n        if( mat.empty() || mat.front().empty() ) {\\n            return 0;\\n        }\\n        \\n        int level = 0;\\n        Matrix matrix( mat );\\n        std::queue< Matrix > queue( { matrix } );\\n        std::unordered_set< int > used( { matrix.posEncoding() } );\\n        \\n        while( !queue.empty() ) {\\n            int level_size = queue.size();\\n            for( int i = 0; i < level_size; i++ ) {\\n                Matrix m = queue.front();\\n                queue.pop();\\n                \\n                if( m.posEncoding() == 0 ) {\\n                    return level;\\n                }\\n                \\n                for( int row = 0; row < m.rows(); row++ ) {\\n                    for( int col = 0; col < m.cols(); col++ ) {\\n                        Matrix flipped = m.flip( row, col );\\n                        int encoding = flipped.posEncoding();\\n                        if( used.count( encoding ) ) {\\n                            continue;\\n                        }\\n                        \\n                        used.insert( encoding );\\n                        queue.push( flipped );\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    static constexpr std::array< std::pair< int, int >, 4 > moves_ = { {\\n        { -1,  0 },\\n        {  1,  0 },\\n        {  0,  1 },\\n        {  0, -1 }\\n    } };\\n    \\n    struct Matrix {\\n        Matrix( const std::vector< std::vector< int > > & m )\\n        :   m_( m )\\n        {\\n            rows_ = m_.size();\\n            cols_ = m_.front().size();\\n        }\\n        \\n        int posEncoding() {\\n            int result = 0;\\n            int position = 0;\\n            for( int row = 0; row < rows_; row++ ) {\\n                for( int col = 0; col < cols_; col++ ) {\\n                    if( m_[ row ][ col ] != 0 ) {\\n                        result += ( 1 << position );\\n                    }\\n                    position++;\\n                }\\n            }\\n            return result;\\n        }\\n        \\n        Matrix flip( int row, int col ) const {\\n            std::vector< std::vector< int > > m( m_ );\\n            for( const auto & move : moves_ ) {\\n                int r = row + move.first;\\n                int c = col + move.second;\\n                if( r < 0 || r >= rows_ ) {\\n                    continue;\\n                }\\n                if( c < 0 || c >= cols_ ) {\\n                    continue;\\n                }\\n                \\n                m[ r ][ c ] = ( m[ r ][ c ] + 1 ) % 2;\\n            }\\n            \\n            m[ row ][ col ] = ( m[ row ][ col ] + 1 ) % 2;\\n            return Matrix( m );\\n        }\\n        \\n        int rows() const {\\n            return rows_;\\n        }\\n        \\n        int cols() const {\\n            return cols_;\\n        }\\n        \\n    private:\\n        std::vector< std::vector< int > > m_;\\n        int rows_;\\n        int cols_;\\n    };\\n    \\npublic:\\n    int minFlips( std::vector< std::vector< int > > & mat ) {\\n        if( mat.empty() || mat.front().empty() ) {\\n            return 0;\\n        }\\n        \\n        int level = 0;\\n        Matrix matrix( mat );\\n        std::queue< Matrix > queue( { matrix } );\\n        std::unordered_set< int > used( { matrix.posEncoding() } );\\n        \\n        while( !queue.empty() ) {\\n            int level_size = queue.size();\\n            for( int i = 0; i < level_size; i++ ) {\\n                Matrix m = queue.front();\\n                queue.pop();\\n                \\n                if( m.posEncoding() == 0 ) {\\n                    return level;\\n                }\\n                \\n                for( int row = 0; row < m.rows(); row++ ) {\\n                    for( int col = 0; col < m.cols(); col++ ) {\\n                        Matrix flipped = m.flip( row, col );\\n                        int encoding = flipped.posEncoding();\\n                        if( used.count( encoding ) ) {\\n                            continue;\\n                        }\\n                        \\n                        used.insert( encoding );\\n                        queue.push( flipped );\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446362,
                "title": "python-bfs",
                "content": "```\\nclass Solution(object):\\n    def minFlips(self, mat):\\n        m, n = len(mat), len(mat[0])\\n        queue = collections.deque()\\n        visited = set()\\n        tmp = []\\n        for each in mat:\\n            tmp += each[:]\\n        visited.add(tuple(tmp))\\n        queue.append([mat, 0])\\n        while queue:\\n            mat, step = queue.pop()\\n            if mat == [[0 for i in range(n)] for j in range(m)]:\\n                return step\\n            for i in range(m):\\n                for j in range(n):\\n                    neighs = [[i-1, j], [i+1, j], [i, j-1], [i, j+1]]\\n                    self.flip(mat, neighs)\\n                    mat[i][j] = abs(1-mat[i][j])\\n                    tmp = []\\n                    for each in mat:\\n                        tmp += each[:]\\n                    if tuple(tmp) in visited:\\n                        self.flip(mat, neighs)\\n                        mat[i][j] = abs(1-mat[i][j])\\n                        continue\\n                    visited.add(tuple(tmp))\\n                    queue.appendleft([[each[:]for each in mat], step+1])\\n                    self.flip(mat, neighs)\\n                    mat[i][j] = abs(1-mat[i][j])\\n        return -1\\n                    \\n    def flip(self, mat, neighs):\\n        m, n = len(mat), len(mat[0])\\n        for (ni, nj) in neighs:\\n            if 0 <= ni < m and 0 <= nj < n:\\n                mat[ni][nj] = abs(1-mat[ni][nj])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minFlips(self, mat):\\n        m, n = len(mat), len(mat[0])\\n        queue = collections.deque()\\n        visited = set()\\n        tmp = []\\n        for each in mat:\\n            tmp += each[:]\\n        visited.add(tuple(tmp))\\n        queue.append([mat, 0])\\n        while queue:\\n            mat, step = queue.pop()\\n            if mat == [[0 for i in range(n)] for j in range(m)]:\\n                return step\\n            for i in range(m):\\n                for j in range(n):\\n                    neighs = [[i-1, j], [i+1, j], [i, j-1], [i, j+1]]\\n                    self.flip(mat, neighs)\\n                    mat[i][j] = abs(1-mat[i][j])\\n                    tmp = []\\n                    for each in mat:\\n                        tmp += each[:]\\n                    if tuple(tmp) in visited:\\n                        self.flip(mat, neighs)\\n                        mat[i][j] = abs(1-mat[i][j])\\n                        continue\\n                    visited.add(tuple(tmp))\\n                    queue.appendleft([[each[:]for each in mat], step+1])\\n                    self.flip(mat, neighs)\\n                    mat[i][j] = abs(1-mat[i][j])\\n        return -1\\n                    \\n    def flip(self, mat, neighs):\\n        m, n = len(mat), len(mat[0])\\n        for (ni, nj) in neighs:\\n            if 0 <= ni < m and 0 <= nj < n:\\n                mat[ni][nj] = abs(1-mat[ni][nj])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446352,
                "title": "java-dfs-with-memoization-and-incode-with-interger-value",
                "content": "1. incode the mat with integer. Since m <=3 and n <= 3, we only need 9 bits to represent a mat, and it can be incoded within the integer range.\\n2. dfs with HashMap as cache (memoization).\\n\\n```java\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        Map<Integer, Integer> step = new HashMap<>();\\n        int val = incode(mat);\\n        int res = dfs(val, 0, step, m, n);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    private int dfs(int cur, int target, Map<Integer, Integer> step, int m, int n) {\\n        if (step.containsKey(cur)) return step.get(cur);\\n        if (cur == target) return 0;\\n        step.put(cur, Integer.MAX_VALUE);\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                min = Math.min(min, dfs(flip(cur, i, j, m, n), target, step, m, n));\\n            }\\n        }\\n        int res = min == Integer.MAX_VALUE ? Integer.MAX_VALUE : min + 1;\\n        step.put(cur, res);\\n        return res;\\n    }\\n    private int flip(int val, int i, int j, int m, int n) {\\n        val ^= 1 << (i * n + j);\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (int[] dir : dirs) {\\n            int x = i + dir[0];\\n            int y = j + dir[1];\\n            if (x >= 0 && x < m && y >= 0 && y < n) {\\n                val ^= 1 << (x * n + y);\\n            }\\n        }\\n        return val;\\n    }\\n    private int incode(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int val = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) val |= 1 << (i * n + j);\\n            }\\n        }\\n        return val;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        Map<Integer, Integer> step = new HashMap<>();\\n        int val = incode(mat);\\n        int res = dfs(val, 0, step, m, n);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    private int dfs(int cur, int target, Map<Integer, Integer> step, int m, int n) {\\n        if (step.containsKey(cur)) return step.get(cur);\\n        if (cur == target) return 0;\\n        step.put(cur, Integer.MAX_VALUE);\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                min = Math.min(min, dfs(flip(cur, i, j, m, n), target, step, m, n));\\n            }\\n        }\\n        int res = min == Integer.MAX_VALUE ? Integer.MAX_VALUE : min + 1;\\n        step.put(cur, res);\\n        return res;\\n    }\\n    private int flip(int val, int i, int j, int m, int n) {\\n        val ^= 1 << (i * n + j);\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (int[] dir : dirs) {\\n            int x = i + dir[0];\\n            int y = j + dir[1];\\n            if (x >= 0 && x < m && y >= 0 && y < n) {\\n                val ^= 1 << (x * n + y);\\n            }\\n        }\\n        return val;\\n    }\\n    private int incode(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int val = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) val |= 1 << (i * n + j);\\n            }\\n        }\\n        return val;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446333,
                "title": "java-dp-topdown-memoization-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        List<Integer> cells = new ArrayList();\\n        List<Integer> terminal = new ArrayList();\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                cells.add(mat[i][j]);\\n                terminal.add(0);\\n            }\\n        }\\n        Map<List<Integer>, Integer> cache = new HashMap();\\n        cache.put(terminal, 0);\\n        return aux(cells, cache, mat.length, mat[0].length);\\n    }\\n    \\n    private int aux(List<Integer> cells, Map<List<Integer>, Integer> cache, int m, int n) {\\n        if (cache.containsKey(cells)) return cache.get(cells);\\n        \\n        cache.put(cells, -1);\\n        int min = 1_000_000_000;\\n        for (int i = 0; i < cells.size(); i++) {\\n            List<Integer> newCells = flip(cells, i, m, n);\\n            int step = aux(newCells, cache, m, n);\\n            if (step != -1) min = Math.min(min, 1 + step);\\n        }\\n        \\n        if (min == 1_000_000_000) min = -1;\\n        cache.put(cells, min);\\n        return min;\\n    }\\n    \\n    private List<Integer> flip(List<Integer> cells, int pos, int m, int n) {\\n        List<Integer> newCells = new ArrayList();\\n        int i = pos/n, j = pos%n;\\n        for (int k = 0; k < cells.size(); k++) {\\n            int x = k/n, y = k%n; \\n            if (x == i && y == j ||\\n                x == i && (y == j-1 || y == j+1) ||\\n                y == j && (x == i-1 || x == i+1)\\n               ) {\\n                newCells.add(cells.get(k) == 0 ? 1 : 0);\\n            } else {\\n                newCells.add(cells.get(k));\\n            }\\n        }\\n        return newCells;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        List<Integer> cells = new ArrayList();\\n        List<Integer> terminal = new ArrayList();\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                cells.add(mat[i][j]);\\n                terminal.add(0);\\n            }\\n        }\\n        Map<List<Integer>, Integer> cache = new HashMap();\\n        cache.put(terminal, 0);\\n        return aux(cells, cache, mat.length, mat[0].length);\\n    }\\n    \\n    private int aux(List<Integer> cells, Map<List<Integer>, Integer> cache, int m, int n) {\\n        if (cache.containsKey(cells)) return cache.get(cells);\\n        \\n        cache.put(cells, -1);\\n        int min = 1_000_000_000;\\n        for (int i = 0; i < cells.size(); i++) {\\n            List<Integer> newCells = flip(cells, i, m, n);\\n            int step = aux(newCells, cache, m, n);\\n            if (step != -1) min = Math.min(min, 1 + step);\\n        }\\n        \\n        if (min == 1_000_000_000) min = -1;\\n        cache.put(cells, min);\\n        return min;\\n    }\\n    \\n    private List<Integer> flip(List<Integer> cells, int pos, int m, int n) {\\n        List<Integer> newCells = new ArrayList();\\n        int i = pos/n, j = pos%n;\\n        for (int k = 0; k < cells.size(); k++) {\\n            int x = k/n, y = k%n; \\n            if (x == i && y == j ||\\n                x == i && (y == j-1 || y == j+1) ||\\n                y == j && (x == i-1 || x == i+1)\\n               ) {\\n                newCells.add(cells.get(k) == 0 ? 1 : 0);\\n            } else {\\n                newCells.add(cells.get(k));\\n            }\\n        }\\n        return newCells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446329,
                "title": "standard-bfs-python",
                "content": "```python\\nfrom collections import deque\\nclass Solution:\\n    def minFlips(self, A: List[List[int]]) -> int:\\n        R, C = len(A), len(A[0])\\n        a = [str(A[i][j]) for i in range(R) for j in range(C)]\\n        a = \\'\\'.join(a)\\n        if a == \\'0\\'*(R*C):return 0 \\n        def bfs(a):\\n            flip = {\\'0\\':\\'1\\', \\'1\\':\\'0\\'}\\n            open_list = deque([(a, 0)])\\n            seen = {a}\\n            while open_list:\\n                state, d = open_list.popleft()\\n                for i in range(R):\\n                    for j in range(C):\\n                        valids = [(i+di, j+dj) for di, dj in [(0, 1),(0, -1),(1, 0),(-1, 0)] if 0<=i+di<R and 0<=j+dj<C]\\n                        state_l = list(state)\\n                        for ii, jj in valids+[(i, j)]:\\n                            idx = C*ii + jj\\n                            state_l[idx] = flip[state_l[idx]] \\n                        state_new = \\'\\'.join(state_l)\\n                        if state_new == \\'0\\'*(R*C):return d+1\\n                        if state_new not in seen:\\n                            seen.add(state_new)\\n                            open_list.append((state_new, d+1))\\n            return -1\\n        return bfs(a)\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\nclass Solution:\\n    def minFlips(self, A: List[List[int]]) -> int:\\n        R, C = len(A), len(A[0])\\n        a = [str(A[i][j]) for i in range(R) for j in range(C)]\\n        a = \\'\\'.join(a)\\n        if a == \\'0\\'*(R*C):return 0 \\n        def bfs(a):\\n            flip = {\\'0\\':\\'1\\', \\'1\\':\\'0\\'}\\n            open_list = deque([(a, 0)])\\n            seen = {a}\\n            while open_list:\\n                state, d = open_list.popleft()\\n                for i in range(R):\\n                    for j in range(C):\\n                        valids = [(i+di, j+dj) for di, dj in [(0, 1),(0, -1),(1, 0),(-1, 0)] if 0<=i+di<R and 0<=j+dj<C]\\n                        state_l = list(state)\\n                        for ii, jj in valids+[(i, j)]:\\n                            idx = C*ii + jj\\n                            state_l[idx] = flip[state_l[idx]] \\n                        state_new = \\'\\'.join(state_l)\\n                        if state_new == \\'0\\'*(R*C):return d+1\\n                        if state_new not in seen:\\n                            seen.add(state_new)\\n                            open_list.append((state_new, d+1))\\n            return -1\\n        return bfs(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446304,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    boolean[][] visited;\\n    public int minFlips(int[][] mat) {\\n        int n = mat.length; \\n        int m = mat[0].length;\\n        visited = new boolean[n][m];\\n        long result = helper(mat);\\n        return result >= Integer.MAX_VALUE ? -1 : (int)result;\\n    }\\n    long helper(int[][] mat) {\\n        if (check(mat)) {\\n            return 0;\\n        }\\n        long min = Integer.MAX_VALUE;\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                if (visited[i][j]) {\\n                    continue;\\n                }\\n                mat[i][j] = mat[i][j] ^ 1;\\n                if (i - 1 >= 0) {\\n                    mat[i - 1][j] = mat[i - 1][j] ^ 1;\\n                }\\n                if (i + 1 < mat.length) {\\n                    mat[i + 1][j] = mat[i + 1][j] ^ 1;\\n                }\\n                if (j - 1 >= 0) {\\n                    mat[i][j - 1] = mat[i][j - 1] ^ 1;\\n                }\\n                if (j + 1 < mat[0].length) {\\n                    mat[i][j + 1] = mat[i][j + 1] ^ 1;\\n                }\\n                visited[i][j] = true;\\n                min = Math.min(helper(mat) + 1, min);\\n                visited[i][j] = false;\\n                mat[i][j] = mat[i][j] ^ 1;\\n                if (i - 1 >= 0) {\\n                    mat[i - 1][j] = mat[i - 1][j] ^ 1;\\n                }\\n                if (i + 1 < mat.length) {\\n                    mat[i + 1][j] = mat[i + 1][j] ^ 1;\\n                }\\n                if (j - 1 >= 0) {\\n                    mat[i][j - 1] = mat[i][j - 1] ^ 1;\\n                }\\n                if (j + 1 < mat[0].length) {\\n                    mat[i][j + 1] = mat[i][j + 1] ^ 1;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n    boolean check(int[][] mat) {\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                if (mat[i][j] != 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean[][] visited;\\n    public int minFlips(int[][] mat) {\\n        int n = mat.length; \\n        int m = mat[0].length;\\n        visited = new boolean[n][m];\\n        long result = helper(mat);\\n        return result >= Integer.MAX_VALUE ? -1 : (int)result;\\n    }\\n    long helper(int[][] mat) {\\n        if (check(mat)) {\\n            return 0;\\n        }\\n        long min = Integer.MAX_VALUE;\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                if (visited[i][j]) {\\n                    continue;\\n                }\\n                mat[i][j] = mat[i][j] ^ 1;\\n                if (i - 1 >= 0) {\\n                    mat[i - 1][j] = mat[i - 1][j] ^ 1;\\n                }\\n                if (i + 1 < mat.length) {\\n                    mat[i + 1][j] = mat[i + 1][j] ^ 1;\\n                }\\n                if (j - 1 >= 0) {\\n                    mat[i][j - 1] = mat[i][j - 1] ^ 1;\\n                }\\n                if (j + 1 < mat[0].length) {\\n                    mat[i][j + 1] = mat[i][j + 1] ^ 1;\\n                }\\n                visited[i][j] = true;\\n                min = Math.min(helper(mat) + 1, min);\\n                visited[i][j] = false;\\n                mat[i][j] = mat[i][j] ^ 1;\\n                if (i - 1 >= 0) {\\n                    mat[i - 1][j] = mat[i - 1][j] ^ 1;\\n                }\\n                if (i + 1 < mat.length) {\\n                    mat[i + 1][j] = mat[i + 1][j] ^ 1;\\n                }\\n                if (j - 1 >= 0) {\\n                    mat[i][j - 1] = mat[i][j - 1] ^ 1;\\n                }\\n                if (j + 1 < mat[0].length) {\\n                    mat[i][j + 1] = mat[i][j + 1] ^ 1;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n    boolean check(int[][] mat) {\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                if (mat[i][j] != 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103009,
                "title": "kotlin-bitset-100-100-when-posted",
                "content": "# Approach\\nPretty sure that score is just because nobody else has bothered to solve this in Kotlin. Anyway... Seemed straight forward. Converted matrix to BitSet for performance (flipping and checking all positions are zero), then ran BFS. One possible improvement could be to replace the start state initialization with a double for loop to avoid division, but since the matrix isn\\'t very large anyway, I\\'m not going to bother.\\n\\n# Code\\n```\\nclass Solution {\\n    fun minFlips(mat: Array<IntArray>): Int {\\n        val height = mat.size\\n        val width = mat[0].size\\n        val visited = mutableSetOf<BitSet>()\\n\\n        // KMM BitSet\\n        // val start = BitSet(height * width) { i -> mat[i / width][i % width]}\\n\\n        // Java BitSet\\n        val start = BitSet(height * width)\\n\\n        for (i in 0 until height * width) {\\n            start.set(i, mat[i / width][i % width] == 1)\\n        }\\n\\n        var queue: Queue<BitSet> = LinkedList()\\n\\n        queue.add(start)\\n        visited.add(start)\\n\\n        var flips = 0\\n        \\n        while (!queue.isEmpty()) {\\n            val newQueue: Queue<BitSet> = LinkedList()\\n\\n            while (!queue.isEmpty()) {\\n                val state = queue.remove()\\n\\n                if (state.isEmpty()) return flips\\n\\n                for (j in 0 until height) {\\n                    for (i in 0 until width) {\\n                        // KMM BitSet\\n                        // val newState = flip(height, width, BitSet(height * width) { i-> state.get(i) }, j, i)\\n\\n                        // Java BitSet\\n                        val newState = flip(height, width, state.clone() as BitSet, j, i)\\n\\n                        if (!visited.contains(newState)) {\\n                            visited.add(newState)\\n                            newQueue.add(newState)\\n                        }\\n                    }\\n                }\\n            }\\n            queue = newQueue\\n            flips++\\n        }\\n\\n        return -1\\n    }\\n\\n    fun flip(h: Int, w: Int, bitSet: BitSet, y: Int, x: Int): BitSet {\\n        bitSet.flip(w * y + x)\\n\\n        if (y > 0) {\\n            bitSet.flip(w * (y - 1) + x)\\n        }\\n\\n        if (y < h - 1) {\\n            bitSet.flip(w * (y + 1) + x)\\n        }   \\n\\n        if (x > 0) {\\n            bitSet.flip(w * y + x - 1)\\n        }\\n\\n        if (x < w - 1) {\\n            bitSet.flip(w * y + x + 1)\\n        }\\n\\n        return bitSet\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    fun minFlips(mat: Array<IntArray>): Int {\\n        val height = mat.size\\n        val width = mat[0].size\\n        val visited = mutableSetOf<BitSet>()\\n\\n        // KMM BitSet\\n        // val start = BitSet(height * width) { i -> mat[i / width][i % width]}\\n\\n        // Java BitSet\\n        val start = BitSet(height * width)\\n\\n        for (i in 0 until height * width) {\\n            start.set(i, mat[i / width][i % width] == 1)\\n        }\\n\\n        var queue: Queue<BitSet> = LinkedList()\\n\\n        queue.add(start)\\n        visited.add(start)\\n\\n        var flips = 0\\n        \\n        while (!queue.isEmpty()) {\\n            val newQueue: Queue<BitSet> = LinkedList()\\n\\n            while (!queue.isEmpty()) {\\n                val state = queue.remove()\\n\\n                if (state.isEmpty()) return flips\\n\\n                for (j in 0 until height) {\\n                    for (i in 0 until width) {\\n                        // KMM BitSet\\n                        // val newState = flip(height, width, BitSet(height * width) { i-> state.get(i) }, j, i)\\n\\n                        // Java BitSet\\n                        val newState = flip(height, width, state.clone() as BitSet, j, i)\\n\\n                        if (!visited.contains(newState)) {\\n                            visited.add(newState)\\n                            newQueue.add(newState)\\n                        }\\n                    }\\n                }\\n            }\\n            queue = newQueue\\n            flips++\\n        }\\n\\n        return -1\\n    }\\n\\n    fun flip(h: Int, w: Int, bitSet: BitSet, y: Int, x: Int): BitSet {\\n        bitSet.flip(w * y + x)\\n\\n        if (y > 0) {\\n            bitSet.flip(w * (y - 1) + x)\\n        }\\n\\n        if (y < h - 1) {\\n            bitSet.flip(w * (y + 1) + x)\\n        }   \\n\\n        if (x > 0) {\\n            bitSet.flip(w * y + x - 1)\\n        }\\n\\n        if (x < w - 1) {\\n            bitSet.flip(w * y + x + 1)\\n        }\\n\\n        return bitSet\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070329,
                "title": "python3-bitwise-operations",
                "content": "# Code\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        mx, nx = len(mat), len(mat[0])\\n        bv = 1\\n        m = defaultdict(int)\\n        \\n        c = 0\\n        for i in range(mx):\\n            for j in range(nx):\\n                m[(i, j)] = bv\\n                \\n                if mat[i][j]:\\n                    c += bv\\n                bv *= 2\\n        if c == 0:\\n            return 0\\n        f = set()\\n        for i in range(mx):\\n            for j in range(nx):\\n                f.add(m[(i,j)] + m[(i+1,j)] + m[(i-1,j)] + m[(i,j+1)] + m[(i,j-1)])\\n        mvs = [999 for i in range(bv)]\\n        mvs[c] = 0\\n        moves = {c}\\n        while moves:\\n            c = moves.pop()\\n            k = mvs[c]\\n            for i in f:\\n                if mvs[c ^ i] > k + 1:\\n                    moves.add(c^i)\\n                    mvs[c^i] = 1 + k\\n        if mvs[0] < 999:\\n            return mvs[0]\\n        return -1\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        mx, nx = len(mat), len(mat[0])\\n        bv = 1\\n        m = defaultdict(int)\\n        \\n        c = 0\\n        for i in range(mx):\\n            for j in range(nx):\\n                m[(i, j)] = bv\\n                \\n                if mat[i][j]:\\n                    c += bv\\n                bv *= 2\\n        if c == 0:\\n            return 0\\n        f = set()\\n        for i in range(mx):\\n            for j in range(nx):\\n                f.add(m[(i,j)] + m[(i+1,j)] + m[(i-1,j)] + m[(i,j+1)] + m[(i,j-1)])\\n        mvs = [999 for i in range(bv)]\\n        mvs[c] = 0\\n        moves = {c}\\n        while moves:\\n            c = moves.pop()\\n            k = mvs[c]\\n            for i in f:\\n                if mvs[c ^ i] > k + 1:\\n                    moves.add(c^i)\\n                    mvs[c^i] = 1 + k\\n        if mvs[0] < 999:\\n            return mvs[0]\\n        return -1\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046106,
                "title": "c-graph-easy-to-understand-graph-based-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe light out algorithm might be hard to understand. But given the constraint of n,m < 3, we can brute force this question.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild a graph of n node where n = 2 ^ (n * m). Given the contraint, it is at most 2 ^ 9 nodes. For all the node, we can connect edges to other nodes based on the flip rule. \\n\\nOnce we have the graph ready, just run the BFS starting from mat to 0. If we cannot reach node 0, then return -1, return the depth level otherwise.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    // graph and directions\\n    vector<vector<int>> g;\\n    const vector<pair<int,int>> dirs{{-1,0}, {1,0}, {0,0}, {0,1}, {0,-1}};\\n    int minFlips(vector<vector<int>>& mat) {\\n        // m,n is 3 so we just brute force dfs with backtracking\\n        int n = size(mat), m = size(mat[0]);\\n        int l = n * m;\\n        // node, edges\\n        g = vector<vector<int>>(1 << l);\\n\\n        // helper mat shape n * m\\n        auto mm = mat;\\n\\n        // turn a mat into int\\n        auto intfy = [&] (vector<vector<int>>& ma) {\\n            int res = 0;\\n            int k = 0;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    res += ma[i][j] << k++;\\n                }\\n            }\\n            return res;\\n        };\\n\\n        // from a node, turn it back into mat\\n        // flip the value at ii and jj\\n        // turn it back to int\\n        auto flip = [&] (int a, int ii, int jj) {\\n            // change int to mat\\n            int k = 0;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    mm[i][j] = (a >> k++) & 1;\\n                }\\n            }\\n\\n            for (auto &[dx, dy] : dirs) {\\n                auto x = ii + dx, y = jj + dy;\\n                if (x >= 0 and x < n and y >= 0 and y < m) {\\n                    mm[x][y] = !mm[x][y];\\n                } \\n            }\\n\\n            return intfy(mm);\\n        };\\n\\n        auto initial = intfy(mat);\\n\\n        // attach edges by flip every position of the graph\\n        auto attach_edges = [&] (int a) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    int p = flip(a, i, j);\\n                    g[a].push_back(p);\\n                }\\n            }\\n        };\\n\\n        // build a graph, attach all the edgegs and then run bfs\\n        for (int i = 0; i < 1 << l; i++) {\\n            attach_edges(i);\\n        }\\n\\n        // bfs with visited record\\n        vector<int> vis(1 << l);\\n        deque<int> p, q;\\n        auto level = 0;\\n        p.push_back(initial);\\n\\n        // special trick to double deque with level\\n        while (!empty(p)) {\\n            while (!empty(p)) {\\n                auto a = p.front();\\n                p.pop_front();\\n                vis[a] = 1;\\n                if (a == 0) return level;\\n\\n                for (auto aa : g[a]) {\\n                    if (!vis[aa]) q.push_back(aa);\\n                }\\n\\n            }\\n            swap(p,q);\\n            level++;\\n        }\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    // graph and directions\\n    vector<vector<int>> g;\\n    const vector<pair<int,int>> dirs{{-1,0}, {1,0}, {0,0}, {0,1}, {0,-1}};\\n    int minFlips(vector<vector<int>>& mat) {\\n        // m,n is 3 so we just brute force dfs with backtracking\\n        int n = size(mat), m = size(mat[0]);\\n        int l = n * m;\\n        // node, edges\\n        g = vector<vector<int>>(1 << l);\\n\\n        // helper mat shape n * m\\n        auto mm = mat;\\n\\n        // turn a mat into int\\n        auto intfy = [&] (vector<vector<int>>& ma) {\\n            int res = 0;\\n            int k = 0;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    res += ma[i][j] << k++;\\n                }\\n            }\\n            return res;\\n        };\\n\\n        // from a node, turn it back into mat\\n        // flip the value at ii and jj\\n        // turn it back to int\\n        auto flip = [&] (int a, int ii, int jj) {\\n            // change int to mat\\n            int k = 0;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    mm[i][j] = (a >> k++) & 1;\\n                }\\n            }\\n\\n            for (auto &[dx, dy] : dirs) {\\n                auto x = ii + dx, y = jj + dy;\\n                if (x >= 0 and x < n and y >= 0 and y < m) {\\n                    mm[x][y] = !mm[x][y];\\n                } \\n            }\\n\\n            return intfy(mm);\\n        };\\n\\n        auto initial = intfy(mat);\\n\\n        // attach edges by flip every position of the graph\\n        auto attach_edges = [&] (int a) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    int p = flip(a, i, j);\\n                    g[a].push_back(p);\\n                }\\n            }\\n        };\\n\\n        // build a graph, attach all the edgegs and then run bfs\\n        for (int i = 0; i < 1 << l; i++) {\\n            attach_edges(i);\\n        }\\n\\n        // bfs with visited record\\n        vector<int> vis(1 << l);\\n        deque<int> p, q;\\n        auto level = 0;\\n        p.push_back(initial);\\n\\n        // special trick to double deque with level\\n        while (!empty(p)) {\\n            while (!empty(p)) {\\n                auto a = p.front();\\n                p.pop_front();\\n                vis[a] = 1;\\n                if (a == 0) return level;\\n\\n                for (auto aa : g[a]) {\\n                    if (!vis[aa]) q.push_back(aa);\\n                }\\n\\n            }\\n            swap(p,q);\\n            level++;\\n        }\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043726,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2^(nm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] row={0,0,1,-1};\\n    int[] col={1,-1,0,0};\\n    public int minFlips(int[][] mat) {\\n        boolean ok=true;\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        boolean[][] visited=new boolean[n][m];\\n        int ans= solve(mat,n,m,visited);\\n        if(ans>=Integer.MAX_VALUE-1)return -1;\\n        return ans;\\n    }\\n    public int solve(int[][] mat,int n,int m,boolean[][] visited){\\n        int ans=Integer.MAX_VALUE-1;\\n         if(check(mat,n,m)==true)return 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                   if(!visited[i][j]){\\n                       flip(mat,i,j,n,m);\\n                       visited[i][j]=true;\\n                   int count=solve(mat,n,m,visited);\\n                     ans=Math.min(ans,count+1);\\n                      flip(mat,i,j,n,m); // backtrack\\n                     visited[i][j]=false; // backtrack\\n                   }\\n                }\\n            }\\n        return ans;\\n    }\\n// flip current cell and neighbour node.\\n    public void flip(int[][] mat,int i,int j,int n,int m){\\n            mat[i][j]=mat[i][j]^1;\\n             for(int r=0;r<4;r++){\\n                int x=i+row[r];\\n                int y=j+col[r];\\n                if(x<0 || y<0 || x>=n || y>=m)continue;\\n                mat[x][y]=mat[x][y]^1;\\n             }\\n    }\\n// check if there is no 1 in the matrix.\\n    public boolean check(int[][] mat,int n,int m){\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               if(mat[i][j]==1)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int[] row={0,0,1,-1};\\n    int[] col={1,-1,0,0};\\n    public int minFlips(int[][] mat) {\\n        boolean ok=true;\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        boolean[][] visited=new boolean[n][m];\\n        int ans= solve(mat,n,m,visited);\\n        if(ans>=Integer.MAX_VALUE-1)return -1;\\n        return ans;\\n    }\\n    public int solve(int[][] mat,int n,int m,boolean[][] visited){\\n        int ans=Integer.MAX_VALUE-1;\\n         if(check(mat,n,m)==true)return 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                   if(!visited[i][j]){\\n                       flip(mat,i,j,n,m);\\n                       visited[i][j]=true;\\n                   int count=solve(mat,n,m,visited);\\n                     ans=Math.min(ans,count+1);\\n                      flip(mat,i,j,n,m); // backtrack\\n                     visited[i][j]=false; // backtrack\\n                   }\\n                }\\n            }\\n        return ans;\\n    }\\n// flip current cell and neighbour node.\\n    public void flip(int[][] mat,int i,int j,int n,int m){\\n            mat[i][j]=mat[i][j]^1;\\n             for(int r=0;r<4;r++){\\n                int x=i+row[r];\\n                int y=j+col[r];\\n                if(x<0 || y<0 || x>=n || y>=m)continue;\\n                mat[x][y]=mat[x][y]^1;\\n             }\\n    }\\n// check if there is no 1 in the matrix.\\n    public boolean check(int[][] mat,int n,int m){\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               if(mat[i][j]==1)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998068,
                "title": "dfs-with-memorization-solution-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n\\n    const dp = {};\\n\\n    const visited = {};\\n\\n\\n    const getKey = () => JSON.stringify(mat);\\n\\n    const dir = [[0,1],[0,-1],[1,0],[-1,0]]\\n\\n    const flip = (i,j) => {\\n\\n        mat[i][j] = 1-mat[i][j];\\n        for(let [nI,nJ] of dir){\\n            if(i+nI>=0 && i+nI<mat.length && j+nJ>=0 && j+nJ<mat[i].length) {\\n                mat[i+nI][j+nJ] = 1-mat[i+nI][j+nJ];\\n            }\\n        }\\n    }\\n\\n    const oneExist = () => {\\n        for(let i=0;i<mat.length;i++){\\n            for(let j=0;j<mat[i].length;j++){\\n                if(mat[i][j]===1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    const dfs = (i,j)=>{\\n\\n        let key = getKey();\\n        if(dp[key]!==undefined) return dp[key];\\n        if(visited[key]) return Infinity;\\n        visited[key] = true;\\n        if(oneExist()) {\\n            dp[key] = 0;\\n            return 0;\\n        }\\n        let min = Infinity;\\n\\n        for(let nI=0;nI<mat.length;nI++){\\n            for(let nJ=0;nJ<mat[nI].length;nJ++){\\n                flip(nI,nJ);\\n                min = Math.min(dfs(nI,nJ)+1,min);\\n                flip(nI,nJ);\\n            }\\n        }\\n\\n        dp[key] = min;\\n        return min;\\n\\n    }\\n    dfs(0,0);\\n\\n\\n    return dp[getKey()]===Infinity?-1:dp[getKey()];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n\\n    const dp = {};\\n\\n    const visited = {};\\n\\n\\n    const getKey = () => JSON.stringify(mat);\\n\\n    const dir = [[0,1],[0,-1],[1,0],[-1,0]]\\n\\n    const flip = (i,j) => {\\n\\n        mat[i][j] = 1-mat[i][j];\\n        for(let [nI,nJ] of dir){\\n            if(i+nI>=0 && i+nI<mat.length && j+nJ>=0 && j+nJ<mat[i].length) {\\n                mat[i+nI][j+nJ] = 1-mat[i+nI][j+nJ];\\n            }\\n        }\\n    }\\n\\n    const oneExist = () => {\\n        for(let i=0;i<mat.length;i++){\\n            for(let j=0;j<mat[i].length;j++){\\n                if(mat[i][j]===1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    const dfs = (i,j)=>{\\n\\n        let key = getKey();\\n        if(dp[key]!==undefined) return dp[key];\\n        if(visited[key]) return Infinity;\\n        visited[key] = true;\\n        if(oneExist()) {\\n            dp[key] = 0;\\n            return 0;\\n        }\\n        let min = Infinity;\\n\\n        for(let nI=0;nI<mat.length;nI++){\\n            for(let nJ=0;nJ<mat[nI].length;nJ++){\\n                flip(nI,nJ);\\n                min = Math.min(dfs(nI,nJ)+1,min);\\n                flip(nI,nJ);\\n            }\\n        }\\n\\n        dp[key] = min;\\n        return min;\\n\\n    }\\n    dfs(0,0);\\n\\n\\n    return dp[getKey()]===Infinity?-1:dp[getKey()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959451,
                "title": "bitmask",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // dimentions\\n    int n,m;\\n\\n    // nei dirs\\n    vector<int>dir={1,0,-1,0,1};\\n\\n    // matrix to number\\n    int m2n(vector<vector<int>>& mat){\\n        int res=0;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                res=res<<1;\\n                res=res|(mat[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    // number to matrix\\n    vector<vector<int>> n2m(int num){\\n        vector mat(n,vector<int>(m,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                mat[i][j]=num&1;\\n                num>>=1;\\n            }\\n        }\\n        return mat;\\n    }\\n\\n    // flip neighbour\\n    int flip(int &num,int &x,int &y){\\n        vector<vector<int>>mat=n2m(num);\\n        for(int i=0;i<4;i++){\\n            int nx=x+dir[i],ny=y+dir[i+1];\\n            if(nx>=0 and ny>=0 and nx<n and ny<m){\\n                mat[nx][ny]=abs(1-mat[nx][ny]);\\n            }\\n        }\\n        mat[x][y]=abs(1-mat[x][y]);\\n        return m2n(mat);\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        n=mat.size(),m=mat[0].size();\\n        int num=m2n(mat);\\n        queue<int>q;\\n        q.push(num);\\n        int steps=0;\\n        set<int>store;\\n        store.insert(num);\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                int num=q.front();\\n                q.pop();\\n                if(__builtin_popcount(num)==0)return steps;\\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                        int newNum=flip(num,i,j);\\n                        if(store.count(newNum)==0){\\n                            store.insert(newNum);\\n                            q.push(newNum);\\n                        }\\n                    }\\n                }\\n            } \\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // dimentions\\n    int n,m;\\n\\n    // nei dirs\\n    vector<int>dir={1,0,-1,0,1};\\n\\n    // matrix to number\\n    int m2n(vector<vector<int>>& mat){\\n        int res=0;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                res=res<<1;\\n                res=res|(mat[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    // number to matrix\\n    vector<vector<int>> n2m(int num){\\n        vector mat(n,vector<int>(m,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                mat[i][j]=num&1;\\n                num>>=1;\\n            }\\n        }\\n        return mat;\\n    }\\n\\n    // flip neighbour\\n    int flip(int &num,int &x,int &y){\\n        vector<vector<int>>mat=n2m(num);\\n        for(int i=0;i<4;i++){\\n            int nx=x+dir[i],ny=y+dir[i+1];\\n            if(nx>=0 and ny>=0 and nx<n and ny<m){\\n                mat[nx][ny]=abs(1-mat[nx][ny]);\\n            }\\n        }\\n        mat[x][y]=abs(1-mat[x][y]);\\n        return m2n(mat);\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        n=mat.size(),m=mat[0].size();\\n        int num=m2n(mat);\\n        queue<int>q;\\n        q.push(num);\\n        int steps=0;\\n        set<int>store;\\n        store.insert(num);\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                int num=q.front();\\n                q.pop();\\n                if(__builtin_popcount(num)==0)return steps;\\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                        int newNum=flip(num,i,j);\\n                        if(store.count(newNum)==0){\\n                            store.insert(newNum);\\n                            q.push(newNum);\\n                        }\\n                    }\\n                }\\n            } \\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940791,
                "title": "concise-solution-on-python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n\\n        n = len(mat)\\n        m = len(mat[0])\\n\\n        def ins(i, j):\\n            return 0 <= i < n and 0 <= j < m\\n\\n        def swipe(i, j):\\n            mat[i][j] ^= 1\\n\\n            if ins(i-1, j):\\n                mat[i-1][j] ^= 1\\n\\n            if ins(i+1, j):\\n                mat[i+1][j] ^= 1\\n\\n            if ins(i, j-1):\\n                mat[i][j-1] ^= 1\\n\\n            if ins(i, j+1):\\n                mat[i][j+1] ^= 1\\n\\n        def check():\\n            for i in range(n):\\n                for j in range(m):\\n                    if mat[i][j] == 1:\\n                        return False\\n            return True\\n\\n        def go(i, j, cnt):\\n            if j == m:\\n                i += 1\\n                j = 0\\n\\n            if i == n:\\n                if check():\\n                    nonlocal ans\\n                    ans = min(ans, cnt)\\n                return\\n\\n            # do not swipe\\n            go(i, j+1, cnt)\\n\\n            # do swipe\\n            swipe(i, j)\\n            go(i, j+1, cnt+1)\\n            swipe(i, j)\\n\\n\\n        ans = float(\\'inf\\')\\n        go(0, 0, 0)\\n\\n        return ans if ans != float(\\'inf\\') else -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n\\n        n = len(mat)\\n        m = len(mat[0])\\n\\n        def ins(i, j):\\n            return 0 <= i < n and 0 <= j < m\\n\\n        def swipe(i, j):\\n            mat[i][j] ^= 1\\n\\n            if ins(i-1, j):\\n                mat[i-1][j] ^= 1\\n\\n            if ins(i+1, j):\\n                mat[i+1][j] ^= 1\\n\\n            if ins(i, j-1):\\n                mat[i][j-1] ^= 1\\n\\n            if ins(i, j+1):\\n                mat[i][j+1] ^= 1\\n\\n        def check():\\n            for i in range(n):\\n                for j in range(m):\\n                    if mat[i][j] == 1:\\n                        return False\\n            return True\\n\\n        def go(i, j, cnt):\\n            if j == m:\\n                i += 1\\n                j = 0\\n\\n            if i == n:\\n                if check():\\n                    nonlocal ans\\n                    ans = min(ans, cnt)\\n                return\\n\\n            # do not swipe\\n            go(i, j+1, cnt)\\n\\n            # do swipe\\n            swipe(i, j)\\n            go(i, j+1, cnt+1)\\n            swipe(i, j)\\n\\n\\n        ans = float(\\'inf\\')\\n        go(0, 0, 0)\\n\\n        return ans if ans != float(\\'inf\\') else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935618,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minFlips(vector<vector<int>>& mat) {\\n    const int m = mat.size();\\n    const int n = mat[0].size();\\n    const int hash = getHash(mat, m, n);\\n    if (hash == 0)\\n      return 0;\\n\\n    const vector<int> dirs{0, 1, 0, -1, 0};\\n    queue<int> q{{hash}};\\n    unordered_set<int> seen{hash};\\n\\n    for (int step = 1; !q.empty(); ++step) {\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const int curr = q.front();\\n        q.pop();\\n        for (int i = 0; i < m; ++i) {\\n          for (int j = 0; j < n; ++j) {\\n            int next = curr ^ 1 << (i * n + j);\\n            // Flip four neighbors\\n            for (int k = 0; k < 4; ++k) {\\n              const int x = i + dirs[k];\\n              const int y = j + dirs[k + 1];\\n              if (x < 0 || x == m || y < 0 || y == n)\\n                continue;\\n              next ^= 1 << (x * n + y);\\n            }\\n            if (next == 0)\\n              return step;\\n            if (seen.count(next))\\n              continue;\\n            q.push(next);\\n            seen.insert(next);\\n          }\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n\\n private:\\n  int getHash(const vector<vector<int>>& mat, int m, int n) {\\n    int hash = 0;\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (mat[i][j])\\n          hash |= 1 << (i * n + j);\\n    return hash;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minFlips(vector<vector<int>>& mat) {\\n    const int m = mat.size();\\n    const int n = mat[0].size();\\n    const int hash = getHash(mat, m, n);\\n    if (hash == 0)\\n      return 0;\\n\\n    const vector<int> dirs{0, 1, 0, -1, 0};\\n    queue<int> q{{hash}};\\n    unordered_set<int> seen{hash};\\n\\n    for (int step = 1; !q.empty(); ++step) {\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const int curr = q.front();\\n        q.pop();\\n        for (int i = 0; i < m; ++i) {\\n          for (int j = 0; j < n; ++j) {\\n            int next = curr ^ 1 << (i * n + j);\\n            // Flip four neighbors\\n            for (int k = 0; k < 4; ++k) {\\n              const int x = i + dirs[k];\\n              const int y = j + dirs[k + 1];\\n              if (x < 0 || x == m || y < 0 || y == n)\\n                continue;\\n              next ^= 1 << (x * n + y);\\n            }\\n            if (next == 0)\\n              return step;\\n            if (seen.count(next))\\n              continue;\\n            q.push(next);\\n            seen.insert(next);\\n          }\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n\\n private:\\n  int getHash(const vector<vector<int>>& mat, int m, int n) {\\n    int hash = 0;\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (mat[i][j])\\n          hash |= 1 << (i * n + j);\\n    return hash;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879631,
                "title": "understandable-solution",
                "content": "*\\u2705*Italic**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n           \\n\\n           // first handle edge cases  ; \\n\\n\\n           if( mat.length == 1 && mat[0].length == 1)\\n           { \\n                 if( mat[0][0] == 0)\\n                 return 0 ; \\n                 else\\n                 return 1 ; \\n           }\\n\\n        // since the value of m and n is very less , and we have to return minimum \\n        // number of steps , so we can use , recursion for it ; \\n\\n          boolean visited[][]  = new boolean[mat.length][mat[0].length] ; \\n\\n          if(isAllZero(mat) == true)\\n          return 0 ; \\n\\n          return helper( mat , visited) ; \\n\\n\\n    }\\n    public int helper( int mat[][] , boolean visited[][])\\n    {\\n        int count = Integer.MAX_VALUE ; \\n\\n         if(isAllZero(mat) == true)\\n         return 0 ; \\n\\n\\n         for( int i = 0 ; i < mat.length ; i++)\\n         {\\n             for( int j = 0 ; j < mat[0].length ; j++)\\n             {\\n                  if( visited[i][j] == true)\\n                  continue ; \\n                  \\n\\n                  flip( mat , i , j) ; \\n                  visited[i][j] = true ; \\n\\n                  int temp = helper(mat , visited) ; \\n\\n                  visited[i][j] = false ; \\n                  flip(mat , i , j) ;  // backtrack karte wakt phle jaise kar denge ; \\n\\n                  if( temp != -1 && temp < count)\\n                  count = temp ; \\n\\n             }\\n         }\\n\\n\\n          if( count == Integer.MAX_VALUE)\\n          return -1 ; \\n          else\\n         return count+1 ; \\n    }\\n    public void flip ( int mat[][] , int i , int j )\\n    {\\n          if( mat[i][j] == 1)\\n          mat[i][j] = 0 ; \\n          else\\n          mat[i][j] = 1 ; \\n\\n\\n          if( i-1 >= 0  )\\n          {\\n                 if( mat[i-1][j] == 1)\\n          mat[i-1][j] = 0 ; \\n          else\\n          mat[i-1][j] = 1 ;\\n          }\\n\\n\\n          if( i+1 < mat.length)\\n          {\\n                if( mat[i+1][j] == 1)\\n          mat[i+1][j] = 0 ; \\n          else\\n          mat[i+1][j] = 1 ;\\n          }\\n\\n\\n          if( j-1 >= 0)\\n          {\\n              if( mat[i][j-1] == 1)\\n          mat[i][j-1] = 0 ; \\n          else\\n          mat[i][j-1] = 1 ;\\n          }\\n\\n\\n          if( j+1 < mat[0].length)\\n          {\\n                if( mat[i][j+1] == 1)\\n          mat[i][j+1] = 0 ; \\n          else\\n          mat[i][j+1] = 1 ;\\n          }\\n    }\\n    public boolean isAllZero( int mat[][])\\n    {\\n        for( int i = 0 ; i < mat.length ; i++)\\n        {\\n            for( int j = 0 ; j < mat[0].length ; j++)\\n            {\\n                if( mat[i][j] == 1 )\\n                return false ; \\n            }\\n        }\\n\\n\\n        return true ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n           \\n\\n           // first handle edge cases  ; \\n\\n\\n           if( mat.length == 1 && mat[0].length == 1)\\n           { \\n                 if( mat[0][0] == 0)\\n                 return 0 ; \\n                 else\\n                 return 1 ; \\n           }\\n\\n        // since the value of m and n is very less , and we have to return minimum \\n        // number of steps , so we can use , recursion for it ; \\n\\n          boolean visited[][]  = new boolean[mat.length][mat[0].length] ; \\n\\n          if(isAllZero(mat) == true)\\n          return 0 ; \\n\\n          return helper( mat , visited) ; \\n\\n\\n    }\\n    public int helper( int mat[][] , boolean visited[][])\\n    {\\n        int count = Integer.MAX_VALUE ; \\n\\n         if(isAllZero(mat) == true)\\n         return 0 ; \\n\\n\\n         for( int i = 0 ; i < mat.length ; i++)\\n         {\\n             for( int j = 0 ; j < mat[0].length ; j++)\\n             {\\n                  if( visited[i][j] == true)\\n                  continue ; \\n                  \\n\\n                  flip( mat , i , j) ; \\n                  visited[i][j] = true ; \\n\\n                  int temp = helper(mat , visited) ; \\n\\n                  visited[i][j] = false ; \\n                  flip(mat , i , j) ;  // backtrack karte wakt phle jaise kar denge ; \\n\\n                  if( temp != -1 && temp < count)\\n                  count = temp ; \\n\\n             }\\n         }\\n\\n\\n          if( count == Integer.MAX_VALUE)\\n          return -1 ; \\n          else\\n         return count+1 ; \\n    }\\n    public void flip ( int mat[][] , int i , int j )\\n    {\\n          if( mat[i][j] == 1)\\n          mat[i][j] = 0 ; \\n          else\\n          mat[i][j] = 1 ; \\n\\n\\n          if( i-1 >= 0  )\\n          {\\n                 if( mat[i-1][j] == 1)\\n          mat[i-1][j] = 0 ; \\n          else\\n          mat[i-1][j] = 1 ;\\n          }\\n\\n\\n          if( i+1 < mat.length)\\n          {\\n                if( mat[i+1][j] == 1)\\n          mat[i+1][j] = 0 ; \\n          else\\n          mat[i+1][j] = 1 ;\\n          }\\n\\n\\n          if( j-1 >= 0)\\n          {\\n              if( mat[i][j-1] == 1)\\n          mat[i][j-1] = 0 ; \\n          else\\n          mat[i][j-1] = 1 ;\\n          }\\n\\n\\n          if( j+1 < mat[0].length)\\n          {\\n                if( mat[i][j+1] == 1)\\n          mat[i][j+1] = 0 ; \\n          else\\n          mat[i][j+1] = 1 ;\\n          }\\n    }\\n    public boolean isAllZero( int mat[][])\\n    {\\n        for( int i = 0 ; i < mat.length ; i++)\\n        {\\n            for( int j = 0 ; j < mat[0].length ; j++)\\n            {\\n                if( mat[i][j] == 1 )\\n                return false ; \\n            }\\n        }\\n\\n\\n        return true ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865794,
                "title": "c-bfs-string",
                "content": "# Code\\n```\\nclass Solution {\\n    int drc[5] = {1 , 0 , -1 , 0 , 1};\\npublic:\\n    bool check(string &str){\\n        for(auto x : str){\\n            if(x != \\'0\\')return false;\\n        }\\n        return true;\\n    }\\n    int findIndex (int m , int i , int j){\\n             return (i*m + (j));\\n    } \\n    void flipBit(string &str , int index){\\n        if(str[index]==\\'0\\')str[index] = \\'1\\';\\n        else str[index] = \\'0\\';\\n    }\\n    int solve(vector<vector<int>>& mat , int n , int m){\\n        queue<string> q;\\n        string temp = \"\";\\n        for(int i = 0; i < n ; i++)for(int j = 0 ; j < m ; j++)temp+=(mat[i][j]+\\'0\\');\\n        int stringSize = temp.size();\\n        q.push(temp);\\n        unordered_set<string> st;\\n        st.insert(temp);\\n        int result = 0;\\n        while(q.size()){\\n              int count = q.size();\\n              for(int i = 0 ; i < count ; i++){\\n                  string temp = q.front();\\n                  q.pop();\\n                  if(check(temp))return result;\\n                  for(int index = 0 ; index < stringSize ; index++){\\n                           string curr = temp;\\n                           flipBit(curr , index);\\n                           int row = index/m;\\n                           int col = index%m;\\n\\n                           for(int d = 0 ; d < 4 ; d++){\\n                               int newRow = row + drc[d];\\n                               int newCol = col + drc[d+1];\\n                               if(newRow < 0 || newCol < 0 || newRow>=n || newCol>=m)continue;\\n                               int newIndex = findIndex(m , newRow , newCol);\\n                               flipBit(curr , newIndex);\\n                           }\\n\\n                           if(!st.count(curr)){\\n                                q.push(curr);\\n                                st.insert(curr);\\n                           }\\n                  }\\n              }\\n                  result++;\\n        }\\n        return -1;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n         queue<string> q;\\n         int n = mat.size();\\n         int m = mat[0].size();\\n         if(n == 1 && m == 1){\\n             if(mat[0][0]==0)return 0;\\n             else return 1;\\n         }else{\\n            bool flag = false;\\n            for(int i = 0 ; i < n ; i++){\\n                for(int j = 0 ; j < m ; j++){\\n                    if(mat[i][j]!=0){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag)return 0;\\n         }\\n\\n        return solve(mat , n , m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int drc[5] = {1 , 0 , -1 , 0 , 1};\\npublic:\\n    bool check(string &str){\\n        for(auto x : str){\\n            if(x != \\'0\\')return false;\\n        }\\n        return true;\\n    }\\n    int findIndex (int m , int i , int j){\\n             return (i*m + (j));\\n    } \\n    void flipBit(string &str , int index){\\n        if(str[index]==\\'0\\')str[index] = \\'1\\';\\n        else str[index] = \\'0\\';\\n    }\\n    int solve(vector<vector<int>>& mat , int n , int m){\\n        queue<string> q;\\n        string temp = \"\";\\n        for(int i = 0; i < n ; i++)for(int j = 0 ; j < m ; j++)temp+=(mat[i][j]+\\'0\\');\\n        int stringSize = temp.size();\\n        q.push(temp);\\n        unordered_set<string> st;\\n        st.insert(temp);\\n        int result = 0;\\n        while(q.size()){\\n              int count = q.size();\\n              for(int i = 0 ; i < count ; i++){\\n                  string temp = q.front();\\n                  q.pop();\\n                  if(check(temp))return result;\\n                  for(int index = 0 ; index < stringSize ; index++){\\n                           string curr = temp;\\n                           flipBit(curr , index);\\n                           int row = index/m;\\n                           int col = index%m;\\n\\n                           for(int d = 0 ; d < 4 ; d++){\\n                               int newRow = row + drc[d];\\n                               int newCol = col + drc[d+1];\\n                               if(newRow < 0 || newCol < 0 || newRow>=n || newCol>=m)continue;\\n                               int newIndex = findIndex(m , newRow , newCol);\\n                               flipBit(curr , newIndex);\\n                           }\\n\\n                           if(!st.count(curr)){\\n                                q.push(curr);\\n                                st.insert(curr);\\n                           }\\n                  }\\n              }\\n                  result++;\\n        }\\n        return -1;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n         queue<string> q;\\n         int n = mat.size();\\n         int m = mat[0].size();\\n         if(n == 1 && m == 1){\\n             if(mat[0][0]==0)return 0;\\n             else return 1;\\n         }else{\\n            bool flag = false;\\n            for(int i = 0 ; i < n ; i++){\\n                for(int j = 0 ; j < m ; j++){\\n                    if(mat[i][j]!=0){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag)return 0;\\n         }\\n\\n        return solve(mat , n , m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862118,
                "title": "c-solution-backtracking",
                "content": "Code\\n```\\nclass Solution {\\npublic:\\n    int n, m, ans;\\n    void backtrack(vector<vector<int>>& mat, int step, int i, int j){\\n        if(j == m){\\n            j = 0;\\n            i++;\\n        }\\n        if(i == n){\\n            bool ok = true;\\n            for(int r=0;r<n;r++){\\n                for(int c=0;c<m;c++){\\n                    if(mat[r][c]){\\n                        ok = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(ok){\\n                ans = min(ans, step);\\n            }\\n            return;\\n        }\\n        // not changing\\n        backtrack(mat, step, i, j+1);\\n        mat[i][j] = !mat[i][j];\\n        if(i-1 >= 0) mat[i-1][j] = !mat[i-1][j];\\n        if(i+1 < n) mat[i+1][j] = !mat[i+1][j];\\n        if(j-1 >= 0) mat[i][j-1] = !mat[i][j-1];\\n        if(j+1 < m) mat[i][j+1] = !mat[i][j+1];\\n        // changing\\n        backtrack(mat, step+1, i, j+1);\\n        mat[i][j] = !mat[i][j];\\n        if(i-1 >= 0) mat[i-1][j] = !mat[i-1][j];\\n        if(i+1 < n) mat[i+1][j] = !mat[i+1][j];\\n        if(j-1 >= 0) mat[i][j-1] = !mat[i][j-1];\\n        if(j+1 < m) mat[i][j+1] = !mat[i][j+1];\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size();\\n        m = mat[0].size();\\n        ans = INT_MAX;\\n        backtrack(mat, 0, 0, 0);\\n        if(ans == INT_MAX) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m, ans;\\n    void backtrack(vector<vector<int>>& mat, int step, int i, int j){\\n        if(j == m){\\n            j = 0;\\n            i++;\\n        }\\n        if(i == n){\\n            bool ok = true;\\n            for(int r=0;r<n;r++){\\n                for(int c=0;c<m;c++){\\n                    if(mat[r][c]){\\n                        ok = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(ok){\\n                ans = min(ans, step);\\n            }\\n            return;\\n        }\\n        // not changing\\n        backtrack(mat, step, i, j+1);\\n        mat[i][j] = !mat[i][j];\\n        if(i-1 >= 0) mat[i-1][j] = !mat[i-1][j];\\n        if(i+1 < n) mat[i+1][j] = !mat[i+1][j];\\n        if(j-1 >= 0) mat[i][j-1] = !mat[i][j-1];\\n        if(j+1 < m) mat[i][j+1] = !mat[i][j+1];\\n        // changing\\n        backtrack(mat, step+1, i, j+1);\\n        mat[i][j] = !mat[i][j];\\n        if(i-1 >= 0) mat[i-1][j] = !mat[i-1][j];\\n        if(i+1 < n) mat[i+1][j] = !mat[i+1][j];\\n        if(j-1 >= 0) mat[i][j-1] = !mat[i][j-1];\\n        if(j+1 < m) mat[i][j+1] = !mat[i][j+1];\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size();\\n        m = mat[0].size();\\n        ans = INT_MAX;\\n        backtrack(mat, 0, 0, 0);\\n        if(ans == INT_MAX) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838210,
                "title": "0ms-faster-than-100-easy-to-understand-solution",
                "content": "# Intuition\\nConvert the matrix into 9 bit mask and use recursion to solve all the possible solutions \\n\\n# Approach\\n  Bit masking and dp\\n# Complexity\\n- Time complexity:\\n   O(mn(2^mn)) ==> O((2^12))\\n   1<= m*n <= 9\\n- Space complexity:\\n   O(2^9)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[513]; // dp array to store min steps for each mask possible\\n    int vis[513]; // visited matrix for storing the visited masks\\n    int r,c;\\n    int dir[5] = {1,0,-1,0,1}; // helper array tracking the position of adjacents \\n    int solve(int mask){\\n        // if mask is 0 return 0 ==>> final position\\n        if(mask == 0)return 0;\\n        // apply dp\\n        if(dp[mask]!=-1 )return dp[mask];\\n        // create a visited matrix of same size as dp to avoid looping cycles.\\n        if(vis[mask])return INT_MAX; \\n        vis[mask]=1;\\n        int res = INT_MAX;\\n        //for each bit set there will be 2 cases possible\\n        // case-1 flip the bitset and all the adjacents to it and move to next iteration in recursion\\n        // case-2 do not flip the bit set and iterate in for loop for next bit.\\n        for(int i=0;i<9;i++){\\n                int col = i%c;\\n                int row = i/c;\\n                int sudo = mask;\\n                sudo = sudo ^ (1<<i); // flip the bit set\\n                for(int p = 1; p<5;p++){\\n                    int cl = col+dir[p];\\n                    int rw = row + dir[p-1];\\n                    if(cl>=0 && cl<c && rw>=0 && rw<r){\\n                         int pos = c*rw+cl;\\n        sudo = (sudo & 1<<pos)?(sudo^(1<<pos)):sudo|(1<<pos) ; // flipping the adjacent bits \\n                    }\\n                }\\n                int ans = solve(sudo); // recurrsion to next steps\\n                if(ans!=INT_MAX)res = min(res,1+ans);\\n        }\\n        \\n        return dp[mask]=res; // storing the res\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        //step-1 :: convert the matrix into a bitmask \\n        int mask = 0;\\n        r = mat.size();\\n        c = mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        for(int i = 0; i< mat.size(); i++){\\n            for(int j=0;j<mat[0].size(); j++){\\n               if(mat[i][j]==1)\\n                     mask = mask | 1<<((c*i)+j); //mask the pos of 1 \\n                 }}\\n        int res = solve(mask); \\n        return (res == INT_MAX)?-1:res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[513]; // dp array to store min steps for each mask possible\\n    int vis[513]; // visited matrix for storing the visited masks\\n    int r,c;\\n    int dir[5] = {1,0,-1,0,1}; // helper array tracking the position of adjacents \\n    int solve(int mask){\\n        // if mask is 0 return 0 ==>> final position\\n        if(mask == 0)return 0;\\n        // apply dp\\n        if(dp[mask]!=-1 )return dp[mask];\\n        // create a visited matrix of same size as dp to avoid looping cycles.\\n        if(vis[mask])return INT_MAX; \\n        vis[mask]=1;\\n        int res = INT_MAX;\\n        //for each bit set there will be 2 cases possible\\n        // case-1 flip the bitset and all the adjacents to it and move to next iteration in recursion\\n        // case-2 do not flip the bit set and iterate in for loop for next bit.\\n        for(int i=0;i<9;i++){\\n                int col = i%c;\\n                int row = i/c;\\n                int sudo = mask;\\n                sudo = sudo ^ (1<<i); // flip the bit set\\n                for(int p = 1; p<5;p++){\\n                    int cl = col+dir[p];\\n                    int rw = row + dir[p-1];\\n                    if(cl>=0 && cl<c && rw>=0 && rw<r){\\n                         int pos = c*rw+cl;\\n        sudo = (sudo & 1<<pos)?(sudo^(1<<pos)):sudo|(1<<pos) ; // flipping the adjacent bits \\n                    }\\n                }\\n                int ans = solve(sudo); // recurrsion to next steps\\n                if(ans!=INT_MAX)res = min(res,1+ans);\\n        }\\n        \\n        return dp[mask]=res; // storing the res\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        //step-1 :: convert the matrix into a bitmask \\n        int mask = 0;\\n        r = mat.size();\\n        c = mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        for(int i = 0; i< mat.size(); i++){\\n            for(int j=0;j<mat[0].size(); j++){\\n               if(mat[i][j]==1)\\n                     mask = mask | 1<<((c*i)+j); //mask the pos of 1 \\n                 }}\\n        int res = solve(mask); \\n        return (res == INT_MAX)?-1:res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817249,
                "title": "swift-with-comments-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    func minFlips(_ mat: [[Int]]) -> Int {\\n        var mat = mat\\n        var minSteps = Int.max\\n\\n        func dfs(_ x: Int, _ y: Int, _ steps: Int) {\\n            if y == mat[0].count {\\n                dfs(x + 1, 0, steps) // move to next row ( down ) now as this row is all done one by one!\\n                return\\n            }\\n\\n            if x == mat.count { // all the row and cols covered now, record the steps if its a zero matrix!\\n                if isZero() {\\n                    minSteps = min(minSteps, steps)\\n                }\\n                return\\n            }\\n\\n            flip(x, y)\\n            dfs(x, y + 1, steps + 1) // go to next element in the same row!\\n            flip(x, y)\\n\\n            dfs(x, y + 1, steps)\\n        }\\n\\n\\n        func flip(_ x: Int, _ y: Int) {\\n            mat[x][y] = mat[x][y] == 0 ? 1 : 0\\n            var dir = [[1, 0],[-1, 0],[0, -1],[0, 1]]\\n            for d in dir {\\n                let newX = x + d[0]\\n                let newY = y + d[1]\\n                if newX < 0 || newY < 0 || newX >= mat.count || newY >= mat[0].count {\\n                    continue\\n                }\\n                mat[newX][newY] = mat[newX][newY] == 0 ? 1 : 0\\n            }\\n        }\\n\\n        func isZero() -> Bool {\\n            for i in 0 ..< mat.count {\\n                for j in 0 ..< mat[0].count {\\n                    if mat[i][j] == 1 {\\n                        return false\\n                    }\\n                }\\n            }\\n            return true\\n        }\\n\\n        dfs(0, 0, 0)\\n        \\n        return minSteps == Int.max ? -1 : minSteps\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func minFlips(_ mat: [[Int]]) -> Int {\\n        var mat = mat\\n        var minSteps = Int.max\\n\\n        func dfs(_ x: Int, _ y: Int, _ steps: Int) {\\n            if y == mat[0].count {\\n                dfs(x + 1, 0, steps) // move to next row ( down ) now as this row is all done one by one!\\n                return\\n            }\\n\\n            if x == mat.count { // all the row and cols covered now, record the steps if its a zero matrix!\\n                if isZero() {\\n                    minSteps = min(minSteps, steps)\\n                }\\n                return\\n            }\\n\\n            flip(x, y)\\n            dfs(x, y + 1, steps + 1) // go to next element in the same row!\\n            flip(x, y)\\n\\n            dfs(x, y + 1, steps)\\n        }\\n\\n\\n        func flip(_ x: Int, _ y: Int) {\\n            mat[x][y] = mat[x][y] == 0 ? 1 : 0\\n            var dir = [[1, 0],[-1, 0],[0, -1],[0, 1]]\\n            for d in dir {\\n                let newX = x + d[0]\\n                let newY = y + d[1]\\n                if newX < 0 || newY < 0 || newX >= mat.count || newY >= mat[0].count {\\n                    continue\\n                }\\n                mat[newX][newY] = mat[newX][newY] == 0 ? 1 : 0\\n            }\\n        }\\n\\n        func isZero() -> Bool {\\n            for i in 0 ..< mat.count {\\n                for j in 0 ..< mat[0].count {\\n                    if mat[i][j] == 1 {\\n                        return false\\n                    }\\n                }\\n            }\\n            return true\\n        }\\n\\n        dfs(0, 0, 0)\\n        \\n        return minSteps == Int.max ? -1 : minSteps\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813893,
                "title": "bitmask-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat[0].size();\\n        int mnSteps = INT_MAX;\\n        int m = mat.size();\\n        for(int i=0; i<(1<<n); i++){\\n            vector<vector<int>> t(mat.begin(), mat.end());\\n            int stepsCount = 0;\\n            for(int j=0; j<n; j++){\\n               if(i&(1<<j)){\\n                  t[0][j] = !t[0][j];\\n                  stepsCount++;\\n\\n                  if(j-1>=0) t[0][j-1] = !t[0][j-1];\\n                      \\n                  if(j+1<n) t[0][j+1] = !t[0][j+1];\\n                      \\n                  if(0+1 <m) t[1][j] = !t[1][j];        \\n                \\n               }\\n            }\\n            for(int k=1; k<m; k++){\\n               for(int l=0; l<n; l++){\\n                   if(t[k-1][l] != 0){\\n                       t[k-1][l] = !t[k-1][l];\\n                       t[k][l] = !t[k][l];\\n                       stepsCount++;\\n\\n                       if(l-1>=0) t[k][l-1] = !t[k][l-1];\\n                        \\n                       if(l+1<n) t[k][l+1] = !t[k][l+1];\\n\\n                       if(k+1<m) t[k+1][l] = !t[k+1][l];               \\n                   }\\n               }\\n            }\\n            bool f =0;\\n            for(int i=0; i<n; i++){\\n                if(t[m-1][i] != 0) {\\n                    f=1;\\n                break;\\n                }\\n            }\\n            if(f) continue;\\n            mnSteps = min(mnSteps,stepsCount );\\n        }\\n        if(mnSteps == INT_MAX) return -1;\\n        return mnSteps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n = mat[0].size();\\n        int mnSteps = INT_MAX;\\n        int m = mat.size();\\n        for(int i=0; i<(1<<n); i++){\\n            vector<vector<int>> t(mat.begin(), mat.end());\\n            int stepsCount = 0;\\n            for(int j=0; j<n; j++){\\n               if(i&(1<<j)){\\n                  t[0][j] = !t[0][j];\\n                  stepsCount++;\\n\\n                  if(j-1>=0) t[0][j-1] = !t[0][j-1];\\n                      \\n                  if(j+1<n) t[0][j+1] = !t[0][j+1];\\n                      \\n                  if(0+1 <m) t[1][j] = !t[1][j];        \\n                \\n               }\\n            }\\n            for(int k=1; k<m; k++){\\n               for(int l=0; l<n; l++){\\n                   if(t[k-1][l] != 0){\\n                       t[k-1][l] = !t[k-1][l];\\n                       t[k][l] = !t[k][l];\\n                       stepsCount++;\\n\\n                       if(l-1>=0) t[k][l-1] = !t[k][l-1];\\n                        \\n                       if(l+1<n) t[k][l+1] = !t[k][l+1];\\n\\n                       if(k+1<m) t[k+1][l] = !t[k+1][l];               \\n                   }\\n               }\\n            }\\n            bool f =0;\\n            for(int i=0; i<n; i++){\\n                if(t[m-1][i] != 0) {\\n                    f=1;\\n                break;\\n                }\\n            }\\n            if(f) continue;\\n            mnSteps = min(mnSteps,stepsCount );\\n        }\\n        if(mnSteps == INT_MAX) return -1;\\n        return mnSteps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776140,
                "title": "beats-100-time-using-bitwise-operations",
                "content": "# Intuition\\nObservation 1: the grid state can be represented by a binary number\\ne.g.\\n1 0\\n1 1\\ncan be represented as 1011\\n\\nObservation 2: a number in the grid can be flipped with a double xor operation: to flip the kth bit of a binary n:\\nn ^= 1<<(k-1);\\nn ^= 0;\\n\\nObservation 3: a grid state only needs to be checked once\\n\\n# Approach\\nphase 1: turning the grid into binary and initialising visited for checking whether a grid state has been checked.\\n\\nphase 2: creating a queue for the grid states that needs to be checked \\n\\nThe first value of the item in the queue represents the grid state, while the second value represents the number of flips to reach that state.\\n\\nFor every iteration of the for loop, we try flipping each index of the grid and push into the queue if there is an unchecked grid state\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n// phase 1\\n        int temp = 0,o,num;\\n        int m = mat.size(), n = mat[0].size();\\n        int ref = (1<<m*n)+1;\\n        vector<bool> visited(ref);\\n        queue<pair<int,int>> q;\\n       \\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if(mat[i][j])temp|=(1<<(n*i+j));\\n            }\\n        }\\n// phase 2\\n        q.push({temp,0});\\n        visited[temp] = true;\\n        if(temp == 0)return 0;\\n        while(!q.empty()){\\n            temp = q.front().first;\\n            num = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < m; ++i){\\n                for(int j = 0; j < n; ++j){\\n                    o = temp;\\n                    o^=(1<<(n*i+j));\\n                    o^=0;\\n                    if(i>0){\\n                        o^=(1<<(n*(i-1)+j));\\n                        o^=0;\\n                    }\\n                    if(i<m-1){\\n                        o^=(1<<(n*(i+1)+j));\\n                        o^= 0;\\n                    }\\n                    if(j>0){\\n                        o^=(1<<(n*i+(j-1)));\\n                        o^=0;\\n                    }\\n                    if(j<n-1){\\n                        o^=(1<<(n*i+(j+1)));\\n                        o^=0;\\n                    }\\n                    if(o == 0)return num+1;\\n                    if(!visited[o]){\\n                        visited[o] = true;\\n                        q.push({o,num+1});\\n                    }\\n                }\\n            }\\n        } \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n// phase 1\\n        int temp = 0,o,num;\\n        int m = mat.size(), n = mat[0].size();\\n        int ref = (1<<m*n)+1;\\n        vector<bool> visited(ref);\\n        queue<pair<int,int>> q;\\n       \\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if(mat[i][j])temp|=(1<<(n*i+j));\\n            }\\n        }\\n// phase 2\\n        q.push({temp,0});\\n        visited[temp] = true;\\n        if(temp == 0)return 0;\\n        while(!q.empty()){\\n            temp = q.front().first;\\n            num = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < m; ++i){\\n                for(int j = 0; j < n; ++j){\\n                    o = temp;\\n                    o^=(1<<(n*i+j));\\n                    o^=0;\\n                    if(i>0){\\n                        o^=(1<<(n*(i-1)+j));\\n                        o^=0;\\n                    }\\n                    if(i<m-1){\\n                        o^=(1<<(n*(i+1)+j));\\n                        o^= 0;\\n                    }\\n                    if(j>0){\\n                        o^=(1<<(n*i+(j-1)));\\n                        o^=0;\\n                    }\\n                    if(j<n-1){\\n                        o^=(1<<(n*i+(j+1)));\\n                        o^=0;\\n                    }\\n                    if(o == 0)return num+1;\\n                    if(!visited[o]){\\n                        visited[o] = true;\\n                        q.push({o,num+1});\\n                    }\\n                }\\n            }\\n        } \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763908,
                "title": "c-dfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    int invert(vector<vector<int>>& mat, int i, int j) {\\n        int diff = 0;\\n        mat[i][j] = !mat[i][j];\\n        diff += mat[i][j] - !mat[i][j]; \\n        if (i-1 >= 0) {\\n            mat[i-1][j] = !mat[i-1][j];\\n            diff += mat[i-1][j] - !mat[i-1][j]; \\n        }\\n        if (j-1 >= 0) {\\n            mat[i][j-1] = !mat[i][j-1];\\n            diff += mat[i][j-1] - !mat[i][j-1];\\n        }\\n        if (i+1 < mat.size()) {\\n            mat[i+1][j] = !mat[i+1][j];\\n            diff += mat[i+1][j] - !mat[i+1][j];\\n        }\\n        if (j+1 < mat[0].size()) {\\n            mat[i][j+1] = !mat[i][j+1];\\n            diff += mat[i][j+1] - !mat[i][j+1];\\n        }\\n        return diff;\\n    }\\n    void dfs(vector<vector<int>>& mat, int sum, int& ans,int i = 0, int j = 0,  int level = 0) {\\n        if (sum == 0) {\\n            if (ans == -1) {\\n                ans = level;\\n            } else {\\n                ans = min(ans, level);\\n            }\\n            return;\\n        }\\n        if (i >= mat.size()) {\\n            return;\\n        }\\n        int nextI = (j+1) < mat[0].size() ? i: i+1;\\n        int nextJ = (j+1) < mat[0].size() ? j+1: 0;\\n        dfs(mat, sum, ans, nextI, nextJ, level);\\n        sum += invert(mat, i, j);\\n        dfs(mat, sum, ans, nextI, nextJ, level+1);\\n        sum += invert(mat, i, j);\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        int sum = 0;\\n        int ans = -1;\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        dfs(mat, sum, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    int invert(vector<vector<int>>& mat, int i, int j) {\\n        int diff = 0;\\n        mat[i][j] = !mat[i][j];\\n        diff += mat[i][j] - !mat[i][j]; \\n        if (i-1 >= 0) {\\n            mat[i-1][j] = !mat[i-1][j];\\n            diff += mat[i-1][j] - !mat[i-1][j]; \\n        }\\n        if (j-1 >= 0) {\\n            mat[i][j-1] = !mat[i][j-1];\\n            diff += mat[i][j-1] - !mat[i][j-1];\\n        }\\n        if (i+1 < mat.size()) {\\n            mat[i+1][j] = !mat[i+1][j];\\n            diff += mat[i+1][j] - !mat[i+1][j];\\n        }\\n        if (j+1 < mat[0].size()) {\\n            mat[i][j+1] = !mat[i][j+1];\\n            diff += mat[i][j+1] - !mat[i][j+1];\\n        }\\n        return diff;\\n    }\\n    void dfs(vector<vector<int>>& mat, int sum, int& ans,int i = 0, int j = 0,  int level = 0) {\\n        if (sum == 0) {\\n            if (ans == -1) {\\n                ans = level;\\n            } else {\\n                ans = min(ans, level);\\n            }\\n            return;\\n        }\\n        if (i >= mat.size()) {\\n            return;\\n        }\\n        int nextI = (j+1) < mat[0].size() ? i: i+1;\\n        int nextJ = (j+1) < mat[0].size() ? j+1: 0;\\n        dfs(mat, sum, ans, nextI, nextJ, level);\\n        sum += invert(mat, i, j);\\n        dfs(mat, sum, ans, nextI, nextJ, level+1);\\n        sum += invert(mat, i, j);\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        int sum = 0;\\n        int ans = -1;\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        dfs(mat, sum, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733553,
                "title": "cute-bfs-bitmasking-solution",
                "content": "I used an array of lambda functions to make it cleaner\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, a: List[List[int]]) -> int:\\n        n, m, inf = len(a), len(a[0]), int(1e9)\\n\\n        dp = [inf for i in range(1<<(n*m))]\\n        dp[0] = 0\\n        q, i = [], 0\\n        q.append([0,0])\\n\\n        transforms = [\\n            lambda x : [x, x-1][int(x%m != 0)],\\n            lambda x : [x, x+1][int((x+1)%m != 0)],\\n            lambda x : [x, x+m][int(x//m != n-1)],\\n            lambda x : [x, x-m][int(x//m != 0)]\\n            ]\\n\\n        while i != len(q):\\n            cur = q[i]\\n            i += 1\\n            mask, cost = cur[0], cur[1]\\n\\n            for bit in range(n*m):\\n                anti = 1<<bit\\n                for t in transforms:\\n                    anti |= 1<<t(bit)\\n                if dp[mask^anti] > cost + 1:\\n                    dp[mask^anti] = cost + 1\\n                    q.append([mask^anti, cost+1])\\n\\n        mask = 0\\n        for i in range(n):\\n            for j in range(m):\\n                mask |= a[i][j] * (1 << (i*m + j))\\n        \\n        return [-1, dp[mask]][dp[mask] != inf]\\n\\n\\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, a: List[List[int]]) -> int:\\n        n, m, inf = len(a), len(a[0]), int(1e9)\\n\\n        dp = [inf for i in range(1<<(n*m))]\\n        dp[0] = 0\\n        q, i = [], 0\\n        q.append([0,0])\\n\\n        transforms = [\\n            lambda x : [x, x-1][int(x%m != 0)],\\n            lambda x : [x, x+1][int((x+1)%m != 0)],\\n            lambda x : [x, x+m][int(x//m != n-1)],\\n            lambda x : [x, x-m][int(x//m != 0)]\\n            ]\\n\\n        while i != len(q):\\n            cur = q[i]\\n            i += 1\\n            mask, cost = cur[0], cur[1]\\n\\n            for bit in range(n*m):\\n                anti = 1<<bit\\n                for t in transforms:\\n                    anti |= 1<<t(bit)\\n                if dp[mask^anti] > cost + 1:\\n                    dp[mask^anti] = cost + 1\\n                    q.append([mask^anti, cost+1])\\n\\n        mask = 0\\n        for i in range(n):\\n            for j in range(m):\\n                mask |= a[i][j] * (1 << (i*m + j))\\n        \\n        return [-1, dp[mask]][dp[mask] != inf]\\n\\n\\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727216,
                "title": "c-striver-solution-well-commented-easy-to-understand",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void set(int& no,int pos){\\n        no=(no|(1<<pos));\\n    }\\n    void unset(int& no,int pos){\\n        no=(no & ~(1<<pos));\\n    }\\n    void flipbit(int& no,int pos){\\n        \\n        if((no & (1<<pos))==0){\\n            set(no,pos);\\n        }else{\\n            unset(no,pos);\\n        }\\n        \\n    }\\n    bool isValid(int r,int c,int n,int m){\\n        if(r>=0 && r<n && c>=0 && c<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        int total=n*m;\\n        vector<bool> vis(pow(2,total),false);\\n        vector<int> dir{-1,0,1,0,-1};\\n        int no=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int pos=i*m+j;\\n                if(mat[i][j]==1){\\n                    set(no,pos);\\n                }else{\\n                    unset(no,pos);\\n                }\\n            }\\n        }\\n        queue<int> q;\\n        q.push(no);\\n        int c=0;\\n        vis[no]=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int curr_no=q.front();\\n                if(curr_no==0){\\n                    return c;\\n                }\\n                q.pop();\\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                        int position=i*m+j;\\n                        int temp=curr_no;\\n                        //flip the curr bit\\n                        flipbit(temp,position);\\n                        //flip the adjacent bit\\n                        for(int k=0;k<dir.size()-1;k++){\\n                            int curr_r=i+dir[k];\\n                            int curr_c=j+dir[k+1];\\n                            \\n                            if(isValid(curr_r,curr_c,n,m)){\\n                                position=curr_r*m+curr_c;\\n                                flipbit(temp,position);\\n                            }\\n                        }\\n                        if(!vis[temp]){\\n                            vis[temp]=true;\\n                            q.push(temp);\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            c++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void set(int& no,int pos){\\n        no=(no|(1<<pos));\\n    }\\n    void unset(int& no,int pos){\\n        no=(no & ~(1<<pos));\\n    }\\n    void flipbit(int& no,int pos){\\n        \\n        if((no & (1<<pos))==0){\\n            set(no,pos);\\n        }else{\\n            unset(no,pos);\\n        }\\n        \\n    }\\n    bool isValid(int r,int c,int n,int m){\\n        if(r>=0 && r<n && c>=0 && c<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        int total=n*m;\\n        vector<bool> vis(pow(2,total),false);\\n        vector<int> dir{-1,0,1,0,-1};\\n        int no=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int pos=i*m+j;\\n                if(mat[i][j]==1){\\n                    set(no,pos);\\n                }else{\\n                    unset(no,pos);\\n                }\\n            }\\n        }\\n        queue<int> q;\\n        q.push(no);\\n        int c=0;\\n        vis[no]=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int curr_no=q.front();\\n                if(curr_no==0){\\n                    return c;\\n                }\\n                q.pop();\\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                        int position=i*m+j;\\n                        int temp=curr_no;\\n                        //flip the curr bit\\n                        flipbit(temp,position);\\n                        //flip the adjacent bit\\n                        for(int k=0;k<dir.size()-1;k++){\\n                            int curr_r=i+dir[k];\\n                            int curr_c=j+dir[k+1];\\n                            \\n                            if(isValid(curr_r,curr_c,n,m)){\\n                                position=curr_r*m+curr_c;\\n                                flipbit(temp,position);\\n                            }\\n                        }\\n                        if(!vis[temp]){\\n                            vis[temp]=true;\\n                            q.push(temp);\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            c++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721992,
                "title": "java-brute-force-solution-bitwise-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code uses a brute-force approach to find the minimum number of flips required to make the matrix contain all zeros. It generates all possible combinations of flipping cells and checks if the resulting matrix contains all zeros.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach in the code involves iterating through all possible combinations of flipping cells. It uses a nested loop to generate the combinations and performs the flip operation on a deep copy of the original matrix. For each combination, it checks if the resulting matrix contains all zeros. The minimum number of flips required to achieve an all-zero matrix is stored and returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is exponential. Generating all possible combinations of flipping cells requires checking 2^(rows * cols) combinations. Therefore, the time complexity is O(2^(rows * cols)).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is linear. The space required is determined by the deep copy of the original matrix, which is proportional to the number of elements in the matrix (rows * cols). Therefore, the space complexity is O(rows * cols).\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        if (zeroChecking(mat)) {\\n            return 0;\\n        }\\n\\n        int minSteps = Integer.MAX_VALUE;\\n        int rows = mat.length;\\n        int cols = mat[0].length;\\n        int length = (int) Math.pow(2, rows * cols);\\n        int totalElements = rows * cols;\\n\\n        for (int i = 0; i < length; i++) {\\n            int n = i;\\n            int counter = -1;\\n\\n            // Deep copy of mat\\n            int[][] newArray = new int[mat.length][];\\n            for (int j = 0; j < mat.length; j++) {\\n                newArray[j] = mat[j].clone();\\n            }\\n\\n            for (int j = totalElements - 1; n != 0; j--) {\\n                if ((n & 1) == 1) {\\n                    int r = j / cols;\\n                    int c = j % cols;\\n                    flip(newArray, r, c);\\n                    counter++;\\n                }\\n                n >>= 1;\\n            }\\n\\n            if (zeroChecking(newArray)) {\\n                minSteps = Math.min(minSteps, counter + 1);\\n            }\\n        }\\n\\n        return minSteps == Integer.MAX_VALUE ? -1 : minSteps;\\n    }\\n\\n    // Check if all elements in the matrix are zero\\n    boolean zeroChecking(int[][] mat) {\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                if (mat[i][j] == 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // Flip the cell and its adjacent cells\\n    void flip(int[][] matrix, int r, int c) {\\n        matrix[r][c] = matrix[r][c] == 1 ? 0 : 1;\\n        if (c < matrix[0].length - 1) {\\n            matrix[r][c + 1] = matrix[r][c + 1] == 1 ? 0 : 1;\\n        }\\n        if (c > 0) {\\n            matrix[r][c - 1] = matrix[r][c - 1] == 1 ? 0 : 1;\\n        }\\n        if (r < matrix.length - 1) {\\n            matrix[r + 1][c] = matrix[r + 1][c] == 1 ? 0 : 1;\\n        }\\n        if (r > 0) {\\n            matrix[r - 1][c] = matrix[r - 1][c] == 1 ? 0 : 1;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        if (zeroChecking(mat)) {\\n            return 0;\\n        }\\n\\n        int minSteps = Integer.MAX_VALUE;\\n        int rows = mat.length;\\n        int cols = mat[0].length;\\n        int length = (int) Math.pow(2, rows * cols);\\n        int totalElements = rows * cols;\\n\\n        for (int i = 0; i < length; i++) {\\n            int n = i;\\n            int counter = -1;\\n\\n            // Deep copy of mat\\n            int[][] newArray = new int[mat.length][];\\n            for (int j = 0; j < mat.length; j++) {\\n                newArray[j] = mat[j].clone();\\n            }\\n\\n            for (int j = totalElements - 1; n != 0; j--) {\\n                if ((n & 1) == 1) {\\n                    int r = j / cols;\\n                    int c = j % cols;\\n                    flip(newArray, r, c);\\n                    counter++;\\n                }\\n                n >>= 1;\\n            }\\n\\n            if (zeroChecking(newArray)) {\\n                minSteps = Math.min(minSteps, counter + 1);\\n            }\\n        }\\n\\n        return minSteps == Integer.MAX_VALUE ? -1 : minSteps;\\n    }\\n\\n    // Check if all elements in the matrix are zero\\n    boolean zeroChecking(int[][] mat) {\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                if (mat[i][j] == 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // Flip the cell and its adjacent cells\\n    void flip(int[][] matrix, int r, int c) {\\n        matrix[r][c] = matrix[r][c] == 1 ? 0 : 1;\\n        if (c < matrix[0].length - 1) {\\n            matrix[r][c + 1] = matrix[r][c + 1] == 1 ? 0 : 1;\\n        }\\n        if (c > 0) {\\n            matrix[r][c - 1] = matrix[r][c - 1] == 1 ? 0 : 1;\\n        }\\n        if (r < matrix.length - 1) {\\n            matrix[r + 1][c] = matrix[r + 1][c] == 1 ? 0 : 1;\\n        }\\n        if (r > 0) {\\n            matrix[r - 1][c] = matrix[r - 1][c] == 1 ? 0 : 1;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719830,
                "title": "bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        Queue<int[][]> queue = new LinkedList<>();\\n        queue.add(mat);\\n        Set<String> visited = new HashSet<>();\\n        int depth = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i_ = 0;i_ < size;i_++) {\\n                int[][] matrix = queue.poll();\\n                String hash = hash(matrix);\\n                if (!visited.add(hash)) {\\n                    continue;\\n                }\\n\\n                if (allZeros(matrix)) {\\n                    return depth;\\n                }\\n                \\n                for (int i = 0;i < matrix.length;i++) {\\n                    for (int j = 0;j < matrix[i].length;j++) {\\n                        int[][] copy = copy(matrix);\\n\\n                        if (i + 1 < matrix.length) {\\n                            copy[i+1][j] = flip(copy[i+1][j]);\\n                        }\\n\\n                        if (j + 1 < matrix[0].length) {\\n                            copy[i][j+1] = flip(copy[i][j+1]);\\n                        }\\n\\n                        if (i - 1 >= 0) {\\n                            copy[i-1][j] = flip(copy[i-1][j]);\\n                        }\\n\\n                        if (j - 1 >= 0) {\\n                            copy[i][j-1] = flip(copy[i][j-1]);\\n                        }\\n\\n                        copy[i][j] = flip(copy[i][j]);\\n\\n                        queue.add(copy);\\n\\n                    }\\n                }\\n\\n            }\\n            depth++;\\n        }\\n        return -1;\\n    }\\n\\n    public boolean allZeros(int[][] mat) {\\n        for (int i = 0;i < mat.length;i++) {\\n            for (int j = 0;j < mat[i].length;j++) {\\n                if (mat[i][j] != 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[][] copy(int[][] mat) {\\n        int[][] copy = new int[mat.length][mat[0].length];\\n        for (int i = 0;i < mat.length;i++) {\\n            for (int j = 0;j < mat[i].length;j++) {\\n                copy[i][j] = mat[i][j];\\n            }\\n        }\\n\\n        return copy;\\n    }\\n\\n    public int flip(int binary) {\\n        if (binary == 0) {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    public String hash(int[][] mat) {\\n        StringBuilder hash = new StringBuilder();\\n        for (int[] row : mat) {\\n            hash.append(Arrays.toString(row));\\n        }\\n        return hash.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFlips(int[][] mat) {\\n        Queue<int[][]> queue = new LinkedList<>();\\n        queue.add(mat);\\n        Set<String> visited = new HashSet<>();\\n        int depth = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i_ = 0;i_ < size;i_++) {\\n                int[][] matrix = queue.poll();\\n                String hash = hash(matrix);\\n                if (!visited.add(hash)) {\\n                    continue;\\n                }\\n\\n                if (allZeros(matrix)) {\\n                    return depth;\\n                }\\n                \\n                for (int i = 0;i < matrix.length;i++) {\\n                    for (int j = 0;j < matrix[i].length;j++) {\\n                        int[][] copy = copy(matrix);\\n\\n                        if (i + 1 < matrix.length) {\\n                            copy[i+1][j] = flip(copy[i+1][j]);\\n                        }\\n\\n                        if (j + 1 < matrix[0].length) {\\n                            copy[i][j+1] = flip(copy[i][j+1]);\\n                        }\\n\\n                        if (i - 1 >= 0) {\\n                            copy[i-1][j] = flip(copy[i-1][j]);\\n                        }\\n\\n                        if (j - 1 >= 0) {\\n                            copy[i][j-1] = flip(copy[i][j-1]);\\n                        }\\n\\n                        copy[i][j] = flip(copy[i][j]);\\n\\n                        queue.add(copy);\\n\\n                    }\\n                }\\n\\n            }\\n            depth++;\\n        }\\n        return -1;\\n    }\\n\\n    public boolean allZeros(int[][] mat) {\\n        for (int i = 0;i < mat.length;i++) {\\n            for (int j = 0;j < mat[i].length;j++) {\\n                if (mat[i][j] != 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[][] copy(int[][] mat) {\\n        int[][] copy = new int[mat.length][mat[0].length];\\n        for (int i = 0;i < mat.length;i++) {\\n            for (int j = 0;j < mat[i].length;j++) {\\n                copy[i][j] = mat[i][j];\\n            }\\n        }\\n\\n        return copy;\\n    }\\n\\n    public int flip(int binary) {\\n        if (binary == 0) {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n\\n    public String hash(int[][] mat) {\\n        StringBuilder hash = new StringBuilder();\\n        for (int[] row : mat) {\\n            hash.append(Arrays.toString(row));\\n        }\\n        return hash.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611439,
                "title": "dfs-cache-brute-force",
                "content": "# Intuition\\nWe need to check 2^(N*M) different combinations of flips in our matrix. Make sure we dont visit the same cell during our recursion since visiting the same cell twice just undos what we previously fliped, effectively doing nothing. Also we would recurse infinitely, continuing to undo flips. This solution will TLE without us additionally keeping track of the already visited matrices. We can use a string representation of matrix to keep track of the current matrix state, I use @cache for brevity.\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        visited = set()\\n\\n        def flip_mat(matrix, r, c, ones, bin_matrix):\\n            M = len(matrix[0])\\n            for i, j in [(1,0),(0,1),(-1,0),(0,-1),(0,0)]:\\n                if r+i < len(matrix) and r+i >=0 and c+j < len(matrix[0]) and c+j >= 0:\\n                    ones += -1 if matrix[r+i][c+j] else 1\\n                    matrix[r+i][c+j] = int(not matrix[r+i][c+j])\\n                    bin_matrix = bin_matrix[:(r+i)*M+(c+j)] + str(matrix[r+i][c+j]) + bin_matrix[(r+i)*M+(c+j)+1:]\\n\\n            return ones, bin_matrix\\n\\n        @cache\\n        def dfs(flips, ones, bin_mat):\\n            if not ones:\\n                return flips\\n            res = float(\\'inf\\')\\n            for r in range(len(mat)):\\n                for c in range(len(mat[0])):\\n                    if not (r,c) in visited:\\n                        ones, bin_mat = flip_mat(mat,r,c, ones, bin_mat)\\n                        visited.add((r,c))\\n                        res = min(res, dfs(flips+1, ones, bin_mat))\\n                        ones, bin_mat = flip_mat(mat,r,c, ones, bin_mat)\\n                        visited.remove((r,c))\\n            return res\\n\\n        ones = 0\\n        bin_mat = \"\"\\n        for r in range(len(mat)):\\n            for c in range(len(mat[0])):\\n                bin_mat += str(mat[r][c])\\n                if mat[r][c]:\\n                    ones += 1\\n        min_flips = dfs(0, ones, bin_mat)\\n        return min_flips if min_flips != float(\\'inf\\') else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        visited = set()\\n\\n        def flip_mat(matrix, r, c, ones, bin_matrix):\\n            M = len(matrix[0])\\n            for i, j in [(1,0),(0,1),(-1,0),(0,-1),(0,0)]:\\n                if r+i < len(matrix) and r+i >=0 and c+j < len(matrix[0]) and c+j >= 0:\\n                    ones += -1 if matrix[r+i][c+j] else 1\\n                    matrix[r+i][c+j] = int(not matrix[r+i][c+j])\\n                    bin_matrix = bin_matrix[:(r+i)*M+(c+j)] + str(matrix[r+i][c+j]) + bin_matrix[(r+i)*M+(c+j)+1:]\\n\\n            return ones, bin_matrix\\n\\n        @cache\\n        def dfs(flips, ones, bin_mat):\\n            if not ones:\\n                return flips\\n            res = float(\\'inf\\')\\n            for r in range(len(mat)):\\n                for c in range(len(mat[0])):\\n                    if not (r,c) in visited:\\n                        ones, bin_mat = flip_mat(mat,r,c, ones, bin_mat)\\n                        visited.add((r,c))\\n                        res = min(res, dfs(flips+1, ones, bin_mat))\\n                        ones, bin_mat = flip_mat(mat,r,c, ones, bin_mat)\\n                        visited.remove((r,c))\\n            return res\\n\\n        ones = 0\\n        bin_mat = \"\"\\n        for r in range(len(mat)):\\n            for c in range(len(mat[0])):\\n                bin_mat += str(mat[r][c])\\n                if mat[r][c]:\\n                    ones += 1\\n        min_flips = dfs(0, ones, bin_mat)\\n        return min_flips if min_flips != float(\\'inf\\') else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556718,
                "title": "efficient-js-bits-manipulation-bfs-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/39684c57-4349-4ccd-9ff6-c04332081971_1684867432.9490886.png)\\n\\n\\n# Complexity\\n- Time complexity: O(mn * 2^(m+n))\\n- Space complexity: O(2^(m+n))\\n\\n\\n# Code\\n```js\\nconst POW2 = [1,2,4,8,16,32,64,128,256,512];\\nconst DIRS = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n  const rows = mat.length;\\n  const cols = mat[0].length;\\n\\n  function getEncodedIndex(r, c) {\\n    return r * cols + c;\\n  }\\n  function getFlipOptions(r, c) {\\n    let result = POW2[getEncodedIndex(r,c)];\\n    DIRS.forEach(dir => {\\n      const nr = r + dir[0];\\n      const nc = c + dir[1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols)\\n        result ^= POW2[getEncodedIndex(nr,nc)];\\n    })\\n\\n    return result;\\n  }\\n\\n  let encoded = 0;\\n  const flipOptions = [];\\n  for (let r = 0; r < rows; r++) {\\n    for (let c = 0; c < cols; c++) {\\n      if (mat[r][c])\\n        encoded ^= POW2[getEncodedIndex(r,c)];\\n      const flipOption = getFlipOptions(r,c);\\n      if (!flipOptions.includes(flipOption))\\n        flipOptions.push(flipOption);\\n    }\\n  }\\n  if (!encoded) return 0;\\n\\n  function bfs(start) {\\n    const queue = [start];\\n    let bottom = 0;\\n    const visit = { [start]: 0 };\\n\\n    while (bottom < queue.length) {\\n      const v = queue[bottom];\\n      bottom++;\\n\\n      for (let fo of flipOptions) {\\n        const nv = v ^ fo;\\n        if (!nv) return visit[v]+1;\\n        if (visit[nv] === undefined) {\\n          visit[nv] = visit[v]+1;\\n          queue.push(nv);\\n        }\\n      }\\n    }\\n\\n    return -1\\n  }\\n\\n  return bfs(encoded);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst POW2 = [1,2,4,8,16,32,64,128,256,512];\\nconst DIRS = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n  const rows = mat.length;\\n  const cols = mat[0].length;\\n\\n  function getEncodedIndex(r, c) {\\n    return r * cols + c;\\n  }\\n  function getFlipOptions(r, c) {\\n    let result = POW2[getEncodedIndex(r,c)];\\n    DIRS.forEach(dir => {\\n      const nr = r + dir[0];\\n      const nc = c + dir[1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols)\\n        result ^= POW2[getEncodedIndex(nr,nc)];\\n    })\\n\\n    return result;\\n  }\\n\\n  let encoded = 0;\\n  const flipOptions = [];\\n  for (let r = 0; r < rows; r++) {\\n    for (let c = 0; c < cols; c++) {\\n      if (mat[r][c])\\n        encoded ^= POW2[getEncodedIndex(r,c)];\\n      const flipOption = getFlipOptions(r,c);\\n      if (!flipOptions.includes(flipOption))\\n        flipOptions.push(flipOption);\\n    }\\n  }\\n  if (!encoded) return 0;\\n\\n  function bfs(start) {\\n    const queue = [start];\\n    let bottom = 0;\\n    const visit = { [start]: 0 };\\n\\n    while (bottom < queue.length) {\\n      const v = queue[bottom];\\n      bottom++;\\n\\n      for (let fo of flipOptions) {\\n        const nv = v ^ fo;\\n        if (!nv) return visit[v]+1;\\n        if (visit[nv] === undefined) {\\n          visit[nv] = visit[v]+1;\\n          queue.push(nv);\\n        }\\n      }\\n    }\\n\\n    return -1\\n  }\\n\\n  return bfs(encoded);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490811,
                "title": "c-0ms-solution-brutforce-bfs-with-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust try all possible ways and orders of flipping since m,n->3 it would not cost you must time but never flip one cell again and again  \\nthis approach with using vectors will also get accepted but what makes it a bit manipulation ques is the use of bitmaks to optimlly use the space as 3*3-> 9 is far samller than 32 so bitmasks can be effectively used\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbfs + bitmaksing\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^m*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mxn)\\n\\n![image.png](https://assets.leetcode.com/users/images/115aff67-3ded-40ff-9cea-60439a662622_1683317099.9233358.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        queue<pair<int,int>> q;\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        bool temp=1;\\n        int arr=0;\\n        int visited=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]){\\n                    arr|=(1<<(i*n+j));\\n                }\\n                if(mat[i][j]) temp=0;\\n            }\\n        }\\n        if(temp) return 0;\\n        int edg[5]={0,1,0,-1,0};\\n        q.push({arr,visited});\\n        \\n        int ans=-1;\\n        while(q.size()){\\n            ans++;\\n            int s=q.size();\\n            while(s--){\\n                auto [a,vis]=q.front();\\n                q.pop();\\n                if(a==0) return ans;\\n                for(int i=0;i<m;i++){\\n                    for(int j=0;j<n;j++){\\n                        int ind=i*n+j;\\n                        if((vis & (1<<ind))==0){\\n                            a^=(1<<ind);\\n                            for(int k=0;k<4;k++){\\n                                int r=i+edg[k];\\n                                int c=j+edg[k+1];\\n                                if(r>=0 && r<m && c>=0 && c<n){\\n                                    int x=r*n+c;\\n                                    a^=(1<<x);\\n                                }\\n                            }\\n                            vis|=(1<<ind);\\n                            q.push({a,vis});\\n                            a^=(1<<ind);\\n                            for(int k=0;k<4;k++){\\n                                int r=i+edg[k];\\n                                int c=j+edg[k+1];\\n                                if(r>=0 && r<m && c>=0 && c<n){\\n                                    int x=r*n+c;\\n                                    a^=(1<<x);\\n                                }\\n                            }\\n                            vis|=(1<<ind);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        queue<pair<int,int>> q;\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        bool temp=1;\\n        int arr=0;\\n        int visited=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]){\\n                    arr|=(1<<(i*n+j));\\n                }\\n                if(mat[i][j]) temp=0;\\n            }\\n        }\\n        if(temp) return 0;\\n        int edg[5]={0,1,0,-1,0};\\n        q.push({arr,visited});\\n        \\n        int ans=-1;\\n        while(q.size()){\\n            ans++;\\n            int s=q.size();\\n            while(s--){\\n                auto [a,vis]=q.front();\\n                q.pop();\\n                if(a==0) return ans;\\n                for(int i=0;i<m;i++){\\n                    for(int j=0;j<n;j++){\\n                        int ind=i*n+j;\\n                        if((vis & (1<<ind))==0){\\n                            a^=(1<<ind);\\n                            for(int k=0;k<4;k++){\\n                                int r=i+edg[k];\\n                                int c=j+edg[k+1];\\n                                if(r>=0 && r<m && c>=0 && c<n){\\n                                    int x=r*n+c;\\n                                    a^=(1<<x);\\n                                }\\n                            }\\n                            vis|=(1<<ind);\\n                            q.push({a,vis});\\n                            a^=(1<<ind);\\n                            for(int k=0;k<4;k++){\\n                                int r=i+edg[k];\\n                                int c=j+edg[k+1];\\n                                if(r>=0 && r<m && c>=0 && c<n){\\n                                    int x=r*n+c;\\n                                    a^=(1<<x);\\n                                }\\n                            }\\n                            vis|=(1<<ind);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486519,
                "title": "my-solutions",
                "content": "**1. Use the BFS**\\n```\\n/**\\n * Time Complexity: O(rows * cols * (2 ^ (rows * cols)))\\n * Space Complexity: O(2 ^ (rows * cols))\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    \\n    queue<uint16_t> q({layout});\\n    bool visited[1 << (rows * cols)];\\n    memset(visited, 0, sizeof(visited));\\n    visited[layout] = true;\\n    int steps = -1;\\n    while (!q.empty()) {\\n      ++steps;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const uint16_t current_layout = q.front();\\n        if (current_layout == 0) {\\n          return steps;\\n        }\\n        \\n        q.pop();\\n        for (int r = 0; r < rows; ++r) {\\n          for (int c = 0; c < cols; ++c) {\\n            uint16_t next_layout = current_layout;\\n            next_layout ^= 1 << (r * cols + c);\\n            for (int d = 0; d < n_directions; ++d) {\\n              const int nr = r + directions[d];\\n              const int nc = c + directions[d + 1];\\n              if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n                next_layout ^= 1 << (nr * cols + nc);\\n              }\\n            }\\n            \\n            if (!visited[next_layout]) {\\n              q.emplace(next_layout);\\n              visited[next_layout] = true;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```\\n**2. Use the memorized DFS**\\n```\\n/**\\n * Time Complexity: O(rows * cols * (2 ^ (rows * cols)))\\n * Space Complexity: O(2 ^ (rows * cols))\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n private:\\n  static constexpr int uninitialized = -2;\\n  static constexpr int unreachable = -1;\\n  \\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    \\n    const int n_layouts = 1 << (rows * cols);\\n    int memo[n_layouts];\\n    fill(memo, memo + n_layouts, uninitialized);\\n    return dfs(layout, rows, cols, memo);\\n  }\\n  \\n private:\\n  int dfs(const uint16_t current_layout,\\n          const int rows,\\n          const int cols,\\n          int *memo) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    \\n    if (current_layout == 0) {\\n      return 0;\\n    }\\n    \\n    int &ret = memo[current_layout];\\n    if (ret != uninitialized) {\\n      return ret;\\n    }\\n    \\n    ret = unreachable;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        uint16_t next_layout = current_layout;\\n        next_layout ^= 1 << (r * cols + c);\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n            next_layout ^= 1 << (nr * cols + nc);\\n          }\\n        }\\n        \\n        const int item = dfs(next_layout, rows, cols, memo);\\n        if (item == unreachable) {\\n          continue;\\n        }\\n        ret = ret == unreachable ? item + 1 : min(ret, item + 1);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**3. Use the DFS**\\n```\\n/**\\n * Time Complexity: O(2 ^ (rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    \\n    uint32_t ret = -1U;\\n    dfs(layout, rows, cols, 0, 0, 0U, ret);\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  void dfs(const uint16_t current_layout,\\n           const int rows,\\n           const int cols,\\n           const int r,\\n           const int c,\\n           const uint32_t steps,\\n           uint32_t &result) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    \\n    if (steps >= result) {\\n      return;\\n    }\\n    \\n    if (current_layout == 0) {\\n      result = steps;\\n      return;\\n    }\\n    \\n    if (c == cols) {\\n      return dfs(current_layout, rows, cols, r + 1, 0, steps, result);\\n    }\\n    \\n    if (r == rows) {\\n      return;\\n    }\\n    \\n    // option 1: don\\'t flip\\n    dfs(current_layout, rows, cols, r, c + 1, steps, result);\\n    \\n    // option 2: flip\\n    uint16_t next_layout = current_layout;\\n    next_layout ^= 1 << (r * cols + c);\\n    for (int d = 0; d < n_directions; ++d) {\\n      const int nr = r + directions[d];\\n      const int nc = c + directions[d + 1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n        next_layout ^= 1 << (nr * cols + nc);\\n      }\\n    }\\n    dfs(next_layout, rows, cols, r, c + 1, steps + 1, result);\\n  }\\n};\\n```\\n**4. Use the optimized DFS, the options of flipping or not flipping of the cells of non-first lines depends on the value of the cells of the first line**\\n```\\n/**\\n * Time Complexity: O(rows * cols * (2 ^ cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    \\n    uint32_t ret = -1U;\\n    dfs(layout, rows, cols, 0, 0, 0U, ret);\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  void dfs(const uint16_t current_layout,\\n           const int rows,\\n           const int cols,\\n           const int r,\\n           const int c,\\n           const uint32_t steps,\\n           uint32_t &result) {\\n    if (steps >= result) {\\n      return;\\n    }\\n    \\n    if (current_layout == 0) {\\n      result = steps;\\n      return;\\n    }\\n    \\n    if (c == cols) {\\n      return dfs(current_layout, rows, cols, r + 1, 0, steps, result);\\n    }\\n    \\n    if (r == rows) {\\n      return;\\n    }\\n    \\n    if (r == 0) {\\n      // option 1: don\\'t flip\\n      dfs(current_layout, rows, cols, r, c + 1, steps, result);\\n\\n      // option 2: flip\\n      uint16_t next_layout = flip(current_layout, rows, cols, r, c);\\n      dfs(next_layout, rows, cols, r, c + 1, steps + 1, result);\\n      return;\\n    }\\n    \\n    // r > 0\\n    if ((current_layout & (1 << (r - 1) * cols + c)) == 0) {\\n      // the current cell should be flipped\\n      dfs(current_layout, rows, cols, r, c + 1, steps, result);\\n    } else {\\n      // the current cell should be flipped\\n      uint16_t next_layout = flip(current_layout, rows, cols, r, c);\\n      dfs(next_layout, rows, cols, r, c + 1, steps + 1, result);\\n    }\\n  }\\n  \\n  uint16_t flip(const uint16_t current_layout, const int rows, const int cols, const int r, const int c) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    uint16_t ret = current_layout;\\n    ret ^= 1 << (r * cols + c);\\n    for (int d = 0; d < n_directions; ++d) {\\n      const int nr = r + directions[d];\\n      const int nc = c + directions[d + 1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n        ret ^= 1 << (nr * cols + nc);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**5. Iterate all possible layouts (flip or not flip) of the first line, the rest of the lines depend on the first line**\\n```\\n/**\\n * Time Complexity: O(rows * cols * (2 ^ cols))\\n * Space Complexity: O(1)\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    if (layout == 0) {\\n      return 0;\\n    }\\n    \\n    uint32_t ret = -1U;\\n    int first_line_layouts = 1 << cols;\\n    for (int first_line_layout = 0; first_line_layout < first_line_layouts; ++first_line_layout) {\\n      uint32_t steps = 0;\\n      bool reached = false;\\n      int current_layout = layout;\\n      \\n      for (int r = 0; steps < ret && !reached && r < rows; ++r) {\\n        for (int c = 0; c < cols; ++c) {\\n          if ((r == 0 && (first_line_layout & (1 << c)) != 0) ||\\n              (r > 0 && (current_layout & (1 << (r - 1) * cols + c)) != 0)) {\\n            // the current cell should be flipped\\n            if (++steps >= ret) {\\n              break;\\n            }\\n            current_layout = flip(current_layout, rows, cols, r, c);\\n            if (current_layout == 0) {\\n              reached = true;\\n              break;\\n            }\\n          }\\n        }\\n      }\\n      \\n      if (reached) {\\n        ret = steps;\\n      }\\n    }\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  uint16_t flip(const uint16_t current_layout, const int rows, const int cols, const int r, const int c) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    uint16_t ret = current_layout;\\n    ret ^= 1 << (r * cols + c);\\n    for (int d = 0; d < n_directions; ++d) {\\n      const int nr = r + directions[d];\\n      const int nc = c + directions[d + 1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n        ret ^= 1 << (nr * cols + nc);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * (2 ^ (rows * cols)))\\n * Space Complexity: O(2 ^ (rows * cols))\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    \\n    queue<uint16_t> q({layout});\\n    bool visited[1 << (rows * cols)];\\n    memset(visited, 0, sizeof(visited));\\n    visited[layout] = true;\\n    int steps = -1;\\n    while (!q.empty()) {\\n      ++steps;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const uint16_t current_layout = q.front();\\n        if (current_layout == 0) {\\n          return steps;\\n        }\\n        \\n        q.pop();\\n        for (int r = 0; r < rows; ++r) {\\n          for (int c = 0; c < cols; ++c) {\\n            uint16_t next_layout = current_layout;\\n            next_layout ^= 1 << (r * cols + c);\\n            for (int d = 0; d < n_directions; ++d) {\\n              const int nr = r + directions[d];\\n              const int nc = c + directions[d + 1];\\n              if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n                next_layout ^= 1 << (nr * cols + nc);\\n              }\\n            }\\n            \\n            if (!visited[next_layout]) {\\n              q.emplace(next_layout);\\n              visited[next_layout] = true;\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(rows * cols * (2 ^ (rows * cols)))\\n * Space Complexity: O(2 ^ (rows * cols))\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n private:\\n  static constexpr int uninitialized = -2;\\n  static constexpr int unreachable = -1;\\n  \\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    \\n    const int n_layouts = 1 << (rows * cols);\\n    int memo[n_layouts];\\n    fill(memo, memo + n_layouts, uninitialized);\\n    return dfs(layout, rows, cols, memo);\\n  }\\n  \\n private:\\n  int dfs(const uint16_t current_layout,\\n          const int rows,\\n          const int cols,\\n          int *memo) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    \\n    if (current_layout == 0) {\\n      return 0;\\n    }\\n    \\n    int &ret = memo[current_layout];\\n    if (ret != uninitialized) {\\n      return ret;\\n    }\\n    \\n    ret = unreachable;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        uint16_t next_layout = current_layout;\\n        next_layout ^= 1 << (r * cols + c);\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n            next_layout ^= 1 << (nr * cols + nc);\\n          }\\n        }\\n        \\n        const int item = dfs(next_layout, rows, cols, memo);\\n        if (item == unreachable) {\\n          continue;\\n        }\\n        ret = ret == unreachable ? item + 1 : min(ret, item + 1);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(2 ^ (rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    \\n    uint32_t ret = -1U;\\n    dfs(layout, rows, cols, 0, 0, 0U, ret);\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  void dfs(const uint16_t current_layout,\\n           const int rows,\\n           const int cols,\\n           const int r,\\n           const int c,\\n           const uint32_t steps,\\n           uint32_t &result) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    \\n    if (steps >= result) {\\n      return;\\n    }\\n    \\n    if (current_layout == 0) {\\n      result = steps;\\n      return;\\n    }\\n    \\n    if (c == cols) {\\n      return dfs(current_layout, rows, cols, r + 1, 0, steps, result);\\n    }\\n    \\n    if (r == rows) {\\n      return;\\n    }\\n    \\n    // option 1: don\\'t flip\\n    dfs(current_layout, rows, cols, r, c + 1, steps, result);\\n    \\n    // option 2: flip\\n    uint16_t next_layout = current_layout;\\n    next_layout ^= 1 << (r * cols + c);\\n    for (int d = 0; d < n_directions; ++d) {\\n      const int nr = r + directions[d];\\n      const int nc = c + directions[d + 1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n        next_layout ^= 1 << (nr * cols + nc);\\n      }\\n    }\\n    dfs(next_layout, rows, cols, r, c + 1, steps + 1, result);\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(rows * cols * (2 ^ cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    \\n    uint32_t ret = -1U;\\n    dfs(layout, rows, cols, 0, 0, 0U, ret);\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  void dfs(const uint16_t current_layout,\\n           const int rows,\\n           const int cols,\\n           const int r,\\n           const int c,\\n           const uint32_t steps,\\n           uint32_t &result) {\\n    if (steps >= result) {\\n      return;\\n    }\\n    \\n    if (current_layout == 0) {\\n      result = steps;\\n      return;\\n    }\\n    \\n    if (c == cols) {\\n      return dfs(current_layout, rows, cols, r + 1, 0, steps, result);\\n    }\\n    \\n    if (r == rows) {\\n      return;\\n    }\\n    \\n    if (r == 0) {\\n      // option 1: don\\'t flip\\n      dfs(current_layout, rows, cols, r, c + 1, steps, result);\\n\\n      // option 2: flip\\n      uint16_t next_layout = flip(current_layout, rows, cols, r, c);\\n      dfs(next_layout, rows, cols, r, c + 1, steps + 1, result);\\n      return;\\n    }\\n    \\n    // r > 0\\n    if ((current_layout & (1 << (r - 1) * cols + c)) == 0) {\\n      // the current cell should be flipped\\n      dfs(current_layout, rows, cols, r, c + 1, steps, result);\\n    } else {\\n      // the current cell should be flipped\\n      uint16_t next_layout = flip(current_layout, rows, cols, r, c);\\n      dfs(next_layout, rows, cols, r, c + 1, steps + 1, result);\\n    }\\n  }\\n  \\n  uint16_t flip(const uint16_t current_layout, const int rows, const int cols, const int r, const int c) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    uint16_t ret = current_layout;\\n    ret ^= 1 << (r * cols + c);\\n    for (int d = 0; d < n_directions; ++d) {\\n      const int nr = r + directions[d];\\n      const int nc = c + directions[d + 1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n        ret ^= 1 << (nr * cols + nc);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(rows * cols * (2 ^ cols))\\n * Space Complexity: O(1)\\n * where `rows` is the number of the rows of the binary matrix `mat`\\n *       `cols` is the number of the columns of the binary matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int minFlips(const vector<vector<int>> &mat) {\\n    constexpr int one = 1;\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    uint16_t layout = 0;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (mat[r][c] == one) {\\n          layout |= 1 << (r * cols + c);\\n        }\\n      }\\n    }\\n    if (layout == 0) {\\n      return 0;\\n    }\\n    \\n    uint32_t ret = -1U;\\n    int first_line_layouts = 1 << cols;\\n    for (int first_line_layout = 0; first_line_layout < first_line_layouts; ++first_line_layout) {\\n      uint32_t steps = 0;\\n      bool reached = false;\\n      int current_layout = layout;\\n      \\n      for (int r = 0; steps < ret && !reached && r < rows; ++r) {\\n        for (int c = 0; c < cols; ++c) {\\n          if ((r == 0 && (first_line_layout & (1 << c)) != 0) ||\\n              (r > 0 && (current_layout & (1 << (r - 1) * cols + c)) != 0)) {\\n            // the current cell should be flipped\\n            if (++steps >= ret) {\\n              break;\\n            }\\n            current_layout = flip(current_layout, rows, cols, r, c);\\n            if (current_layout == 0) {\\n              reached = true;\\n              break;\\n            }\\n          }\\n        }\\n      }\\n      \\n      if (reached) {\\n        ret = steps;\\n      }\\n    }\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  uint16_t flip(const uint16_t current_layout, const int rows, const int cols, const int r, const int c) {\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    uint16_t ret = current_layout;\\n    ret ^= 1 << (r * cols + c);\\n    for (int d = 0; d < n_directions; ++d) {\\n      const int nr = r + directions[d];\\n      const int nc = c + directions[d + 1];\\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\\n        ret ^= 1 << (nr * cols + nc);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457737,
                "title": "python3-dfs",
                "content": "# Intuition\\nThe problem can be solved using depth-first search (DFS). We will try to flip every cell and its neighbors, and move forward to explore all possible combinations of flips. In the end, we will return the minimum number of flips required to convert the given binary matrix to a zero matrix.\\n\\n# Approach\\n1. Define a helper function `flip()` that takes a cell\\'s coordinates and the grid, and flips the cell and its neighbors.\\n2. Define another helper function `dfs()` that takes the current grid, the current cell\\'s coordinates, and the current number of steps.\\n3. In the `dfs()` function, when we reach the end of a row, we move to the next row. When we reach the end of the last row, we check if the entire grid is a zero matrix. If it is, we return the number of steps, otherwise, we return infinity.\\n4. For each cell, we explore two possibilities: not flipping the cell and flipping the cell. We call the `dfs()` function recursively for both cases.\\n5. Flip the cell back after the recursive call to backtrack.\\n6. Return the minimum number of steps required to convert the matrix to a zero matrix or -1 if it\\'s not possible.\\n\\n# Complexity\\n- Time complexity: $$O(2^{m*n} * (m * n))$$, where m and n are the dimensions of the matrix. In the worst case, we will try to flip every cell, resulting in $$2^{m*n}$$ combinations.\\n- Space complexity: $$O(m*n)$$, for the depth of the DFS recursion.\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        def flip(x: int, y: int, grid: List[List[int]]) -> None:\\n            grid[x][y] ^= 1\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    grid[nx][ny] ^= 1\\n\\n        def dfs(grid: List[List[int]], x: int, y: int, steps: int) -> int:\\n            if x == m:\\n                y += 1\\n                x = 0\\n            if y == n:\\n                return steps if all(val == 0 for row in grid for val in row) else float(\\'inf\\')\\n            res = dfs(grid, x + 1, y, steps)\\n            flip(x, y, grid)\\n            res = min(res, dfs(grid, x + 1, y, steps + 1))\\n            flip(x, y, grid)\\n            return res\\n\\n        res = dfs(mat, 0, 0, 0)\\n        return res if res != float(\\'inf\\') else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        def flip(x: int, y: int, grid: List[List[int]]) -> None:\\n            grid[x][y] ^= 1\\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    grid[nx][ny] ^= 1\\n\\n        def dfs(grid: List[List[int]], x: int, y: int, steps: int) -> int:\\n            if x == m:\\n                y += 1\\n                x = 0\\n            if y == n:\\n                return steps if all(val == 0 for row in grid for val in row) else float(\\'inf\\')\\n            res = dfs(grid, x + 1, y, steps)\\n            flip(x, y, grid)\\n            res = min(res, dfs(grid, x + 1, y, steps + 1))\\n            flip(x, y, grid)\\n            return res\\n\\n        res = dfs(mat, 0, 0, 0)\\n        return res if res != float(\\'inf\\') else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433719,
                "title": "python-bfs-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nuse bfs to enumerate all status, \\nwe can encode where the numbers are 1 with bit manipulation, e.g. mat[0, 2] = 1, the thrid bit is 1.\\nIn the bfs, we try to flip each position for each status, if we have seen the status after flipped, not to enqueue.\\n\\ntc is O(m*n*2^(m*n)), sc is O(2^(m*n))\\n\\n\\n\\'\\'\\'\\nfrom collections import deque\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        rowNum, colNum = len(mat), len(mat[0])\\n        status = 0\\n        mapping = lambda r, c: r * colNum + c\\n        for i, r in enumerate(mat):\\n            for j, n in enumerate(r):\\n                if n: status |= 1 << mapping(i, j)\\n        if status == 0: return 0\\n        q = deque([status])\\n        visited = set()\\n        visited.add(status)\\n        step = 0\\n        while q:\\n            step += 1\\n            for _ in range(len(q)):\\n                s = q.popleft()\\n                for i in range(rowNum):\\n                    for j in range(colNum):\\n                        cur = s\\n                        for neiR, neiC in ((i-1, j), (i+1, j), (i, j-1), (i, j+1), (i, j)):\\n                            if 0 <= neiR < rowNum and 0 <= neiC < colNum:\\n                                cur ^= 1 << mapping(neiR, neiC)\\n                        if cur == 0: return step\\n                        elif cur not in visited: \\n                            q.append(cur)\\n                            visited.add(cur)\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```python\\n\\'\\'\\'\\nuse bfs to enumerate all status, \\nwe can encode where the numbers are 1 with bit manipulation, e.g. mat[0, 2] = 1, the thrid bit is 1.\\nIn the bfs, we try to flip each position for each status, if we have seen the status after flipped, not to enqueue.\\n\\ntc is O(m*n*2^(m*n)), sc is O(2^(m*n))\\n\\n\\n\\'\\'\\'\\nfrom collections import deque\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        rowNum, colNum = len(mat), len(mat[0])\\n        status = 0\\n        mapping = lambda r, c: r * colNum + c\\n        for i, r in enumerate(mat):\\n            for j, n in enumerate(r):\\n                if n: status |= 1 << mapping(i, j)\\n        if status == 0: return 0\\n        q = deque([status])\\n        visited = set()\\n        visited.add(status)\\n        step = 0\\n        while q:\\n            step += 1\\n            for _ in range(len(q)):\\n                s = q.popleft()\\n                for i in range(rowNum):\\n                    for j in range(colNum):\\n                        cur = s\\n                        for neiR, neiC in ((i-1, j), (i+1, j), (i, j-1), (i, j+1), (i, j)):\\n                            if 0 <= neiR < rowNum and 0 <= neiC < colNum:\\n                                cur ^= 1 << mapping(neiR, neiC)\\n                        if cur == 0: return step\\n                        elif cur not in visited: \\n                            q.append(cur)\\n                            visited.add(cur)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417928,
                "title": "c-bfs",
                "content": "# Intuition\\nWalk through each changes by BFS until it reachs all 0.\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity:\\nO(N * M * N * M) \\n\\n- Space complexity:\\nO(N * M * N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool all_zero(string tmp) {\\n        for (int i = 0; i < tmp.size(); i++)\\n            if (tmp[i] != \\'0\\')\\n                return false;\\n        return true;\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        set<string> visited_set;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int res = 0;\\n        int move[4][2] = {{1, 0}, {0,1}, {-1, 0}, {0, -1}};\\n        string tmp_string;\\n        queue<string> tmp;\\n\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                tmp_string += to_string(mat[i][j]);\\n\\n        if (all_zero(tmp_string))\\n            return 0;\\n\\n        tmp.push(tmp_string);\\n        while(!tmp.empty()) {\\n            int size = tmp.size();\\n\\n            for (int k = 0; k < size; k++) {\\n                string top = tmp.front();\\n                tmp.pop();\\n                visited_set.insert(top);\\n                for (int i = 0; i < top.size(); i++) {\\n                    int x = i / n;\\n                    int y = i % n;\\n                    string next_string = top;\\n\\n                    if (next_string[i] == \\'0\\')\\n                        next_string[i] = \\'1\\';\\n                    else\\n                        next_string[i] = \\'0\\';\\n                    for (int j = 0; j < 4; j++) {\\n                        int next_x = x + move[j][0];\\n                        int next_y = y + move[j][1];\\n                        int flip_idx;\\n\\n                        if (next_x < 0 || next_x >= m || next_y < 0 || next_y >= n)\\n                            continue;\\n                    \\n                        flip_idx = next_x * n + next_y;\\n                        if (next_string[flip_idx] == \\'0\\')\\n                            next_string[flip_idx] = \\'1\\';\\n                        else\\n                            next_string[flip_idx] = \\'0\\';\\n                    }\\n \\n                    if (visited_set.find(next_string) != visited_set.end())\\n                        continue;\\n\\n                    if (all_zero(next_string))\\n                        return ++res;\\n\\n                    tmp.push(next_string);\\n                }\\n            }\\n            res++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool all_zero(string tmp) {\\n        for (int i = 0; i < tmp.size(); i++)\\n            if (tmp[i] != \\'0\\')\\n                return false;\\n        return true;\\n    }\\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        set<string> visited_set;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int res = 0;\\n        int move[4][2] = {{1, 0}, {0,1}, {-1, 0}, {0, -1}};\\n        string tmp_string;\\n        queue<string> tmp;\\n\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                tmp_string += to_string(mat[i][j]);\\n\\n        if (all_zero(tmp_string))\\n            return 0;\\n\\n        tmp.push(tmp_string);\\n        while(!tmp.empty()) {\\n            int size = tmp.size();\\n\\n            for (int k = 0; k < size; k++) {\\n                string top = tmp.front();\\n                tmp.pop();\\n                visited_set.insert(top);\\n                for (int i = 0; i < top.size(); i++) {\\n                    int x = i / n;\\n                    int y = i % n;\\n                    string next_string = top;\\n\\n                    if (next_string[i] == \\'0\\')\\n                        next_string[i] = \\'1\\';\\n                    else\\n                        next_string[i] = \\'0\\';\\n                    for (int j = 0; j < 4; j++) {\\n                        int next_x = x + move[j][0];\\n                        int next_y = y + move[j][1];\\n                        int flip_idx;\\n\\n                        if (next_x < 0 || next_x >= m || next_y < 0 || next_y >= n)\\n                            continue;\\n                    \\n                        flip_idx = next_x * n + next_y;\\n                        if (next_string[flip_idx] == \\'0\\')\\n                            next_string[flip_idx] = \\'1\\';\\n                        else\\n                            next_string[flip_idx] = \\'0\\';\\n                    }\\n \\n                    if (visited_set.find(next_string) != visited_set.end())\\n                        continue;\\n\\n                    if (all_zero(next_string))\\n                        return ++res;\\n\\n                    tmp.push(next_string);\\n                }\\n            }\\n            res++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405768,
                "title": "similar-to-sliding-puzzle-solution-in-c-using-bfs",
                "content": "//Below is my sliding puzzle solution the pattern is similar to this problem\\nhttps://leetcode.com/problems/sliding-puzzle/solutions/3388117/simple-solution-using-bfs-and-hashset-to-cache-previous-states-in-c/?orderBy=most_votes\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinFlips(int[][] mat) {\\n        HashSet<string> map = new HashSet<string>();\\n\\n        Queue<(int row, int col, int cost, int[][] state)> q =\\n        new Queue<(int, int, int, int[][])>();\\n        for(int i=0;i<mat.Length;i++){\\n          for(int j=0;j<mat[0].Length;j++){\\n            q.Enqueue((i,j,0,mat));\\n          }\\n        }\\n        \\n        while(q.Count > 0){\\n          //remove first\\n          int row = q.Peek().row;\\n          int col = q.Peek().col;\\n          int cost = q.Peek().cost;\\n          int[][] state = q.Peek().state;\\n\\n          q.Dequeue();\\n\\n          if(IsInCache(map,row,col, state)) continue;\\n\\n          //check if all neighbours are zero;\\n          if(checkZero(state)) return cost;\\n          int[][] m = copyMatrix(state);\\n            if(m[row][col] == 0) {\\n              m[row][col] = 1;\\n            }\\n            else m[row][col] = 0;\\n\\n          if(row-1 >= 0){\\n\\n            int v = m[row-1][col];\\n            if(v == 0) m[row-1][col] = 1;\\n            else m[row-1][col] = 0;\\n          }\\n          if(row + 1 <= state.Length-1){\\n\\n            int v = m[row+1][col];\\n            if(v == 0) m[row+1][col] = 1;\\n            else m[row+1][col] = 0;  \\n        \\n          }\\n          if(col - 1 >= 0){\\n\\n            int v = m[row][col-1];\\n            if(v == 0) m[row][col-1] = 1;\\n            else m[row][col-1] = 0;\\n          }\\n          if(col + 1 <= state[0].Length-1){\\n\\n            int v = m[row][col+1];\\n            if(v == 0) m[row][col+1] = 1;\\n            else m[row][col+1] = 0;\\n          }\\n          for(int i=0;i<mat.Length;i++){\\n            for(int j=0;j<mat[0].Length;j++){\\n                  q.Enqueue((i,j,cost+1, m));\\n            }\\n          }\\n        }\\n        \\n        return -1;\\n    }\\n    private bool IsInCache(HashSet<string> map,int row, int col, int[][] state){\\n      bool IsInMap = false;\\n      string str= \"r\"+row+\"c\"+col;\\n      for(int i=0; i<state.Length;i++){\\n          for(int j=0;j<state[0].Length;j++){\\n            str = str + state[i][j];\\n          }\\n        }\\n      if(map.Count == 0){\\n        map.Add(str);\\n      }\\n      else{\\n        if(map.Contains(str))\\n          IsInMap = true;\\n        else map.Add(str);\\n      }\\n      return IsInMap;\\n    }\\n    private int[][] copyMatrix(int[][] mat){\\n      int[][] x = new int[mat.Length][];\\n      for(int i=0;i<mat.Length;i++){\\n        x[i] = new int[mat[i].Length];\\n        for(int j=0;j<mat[i].Length;j++){\\n          x[i][j] = mat[i][j];\\n        }\\n      }\\n\\n      return x;\\n    }\\n\\n    private bool checkZero(int[][] mat){\\n      bool isZero = true;\\n      for(int i=0;i<mat.Length;i++){\\n        for(int j=0;j<mat[0].Length;j++){\\n            if(mat[i][j] != 0) {\\n              isZero = false;\\n              break;\\n            }\\n        }\\n      }\\n      return isZero;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinFlips(int[][] mat) {\\n        HashSet<string> map = new HashSet<string>();\\n\\n        Queue<(int row, int col, int cost, int[][] state)> q =\\n        new Queue<(int, int, int, int[][])>();\\n        for(int i=0;i<mat.Length;i++){\\n          for(int j=0;j<mat[0].Length;j++){\\n            q.Enqueue((i,j,0,mat));\\n          }\\n        }\\n        \\n        while(q.Count > 0){\\n          //remove first\\n          int row = q.Peek().row;\\n          int col = q.Peek().col;\\n          int cost = q.Peek().cost;\\n          int[][] state = q.Peek().state;\\n\\n          q.Dequeue();\\n\\n          if(IsInCache(map,row,col, state)) continue;\\n\\n          //check if all neighbours are zero;\\n          if(checkZero(state)) return cost;\\n          int[][] m = copyMatrix(state);\\n            if(m[row][col] == 0) {\\n              m[row][col] = 1;\\n            }\\n            else m[row][col] = 0;\\n\\n          if(row-1 >= 0){\\n\\n            int v = m[row-1][col];\\n            if(v == 0) m[row-1][col] = 1;\\n            else m[row-1][col] = 0;\\n          }\\n          if(row + 1 <= state.Length-1){\\n\\n            int v = m[row+1][col];\\n            if(v == 0) m[row+1][col] = 1;\\n            else m[row+1][col] = 0;  \\n        \\n          }\\n          if(col - 1 >= 0){\\n\\n            int v = m[row][col-1];\\n            if(v == 0) m[row][col-1] = 1;\\n            else m[row][col-1] = 0;\\n          }\\n          if(col + 1 <= state[0].Length-1){\\n\\n            int v = m[row][col+1];\\n            if(v == 0) m[row][col+1] = 1;\\n            else m[row][col+1] = 0;\\n          }\\n          for(int i=0;i<mat.Length;i++){\\n            for(int j=0;j<mat[0].Length;j++){\\n                  q.Enqueue((i,j,cost+1, m));\\n            }\\n          }\\n        }\\n        \\n        return -1;\\n    }\\n    private bool IsInCache(HashSet<string> map,int row, int col, int[][] state){\\n      bool IsInMap = false;\\n      string str= \"r\"+row+\"c\"+col;\\n      for(int i=0; i<state.Length;i++){\\n          for(int j=0;j<state[0].Length;j++){\\n            str = str + state[i][j];\\n          }\\n        }\\n      if(map.Count == 0){\\n        map.Add(str);\\n      }\\n      else{\\n        if(map.Contains(str))\\n          IsInMap = true;\\n        else map.Add(str);\\n      }\\n      return IsInMap;\\n    }\\n    private int[][] copyMatrix(int[][] mat){\\n      int[][] x = new int[mat.Length][];\\n      for(int i=0;i<mat.Length;i++){\\n        x[i] = new int[mat[i].Length];\\n        for(int j=0;j<mat[i].Length;j++){\\n          x[i][j] = mat[i][j];\\n        }\\n      }\\n\\n      return x;\\n    }\\n\\n    private bool checkZero(int[][] mat){\\n      bool isZero = true;\\n      for(int i=0;i<mat.Length;i++){\\n        for(int j=0;j<mat[0].Length;j++){\\n            if(mat[i][j] != 0) {\\n              isZero = false;\\n              break;\\n            }\\n        }\\n      }\\n      return isZero;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386236,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int m, n ;\\n    vector<vector<int>>dirs{{1,0},{-1,0},{0,1},{0,-1},{0,0}} ;\\n    bool check(vector<vector<int>>mat, int state)\\n    {\\n        for(int i = 0; i < m*n; i++){\\n            if(state % 2 == 1 ){\\n                int r = i/n ;\\n                int c = i%n ;\\n                for(int k = 0; k < 5; k++){\\n                    int x = r + dirs[k][0] ;\\n                    int y = c + dirs[k][1] ;\\n                    if(x < 0 || y < 0 || x >= m || y >= n)\\n                        continue ;\\n                    mat[x][y] = 1 - mat[x][y] ;\\n                }\\n            }\\n            state /= 2 ;\\n        }\\n        for(int i = 0; i < m; i++){\\n            for(int j  = 0; j <n; j++){\\n                if(mat[i][j])\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        m = mat.size() ;\\n        n = mat[0].size() ;\\n        int ret = INT_MAX ;\\n        for(int state = 0; state < (1 << (m*n)); state++ )\\n        {\\n            if(check(mat, state))\\n            {\\n                int ones = __builtin_popcount(state);\\n                ret = min(ret, ones) ;\\n            }\\n        }\\n        return (ret == INT_MAX) ? -1 : ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m, n ;\\n    vector<vector<int>>dirs{{1,0},{-1,0},{0,1},{0,-1},{0,0}} ;\\n    bool check(vector<vector<int>>mat, int state)\\n    {\\n        for(int i = 0; i < m*n; i++){\\n            if(state % 2 == 1 ){\\n                int r = i/n ;\\n                int c = i%n ;\\n                for(int k = 0; k < 5; k++){\\n                    int x = r + dirs[k][0] ;\\n                    int y = c + dirs[k][1] ;\\n                    if(x < 0 || y < 0 || x >= m || y >= n)\\n                        continue ;\\n                    mat[x][y] = 1 - mat[x][y] ;\\n                }\\n            }\\n            state /= 2 ;\\n        }\\n        for(int i = 0; i < m; i++){\\n            for(int j  = 0; j <n; j++){\\n                if(mat[i][j])\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        m = mat.size() ;\\n        n = mat[0].size() ;\\n        int ret = INT_MAX ;\\n        for(int state = 0; state < (1 << (m*n)); state++ )\\n        {\\n            if(check(mat, state))\\n            {\\n                int ones = __builtin_popcount(state);\\n                ret = min(ret, ones) ;\\n            }\\n        }\\n        return (ret == INT_MAX) ? -1 : ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378474,
                "title": "beats-100-backtracking-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans=1e9;\\nprivate:\\n    void fun(int row,int col,int step,int n,int m,vector<vector<int>>&mat){\\n        if(col==m){\\n            col=0;\\n            row++;\\n            \\n        }\\n        if(row==n){\\n            int count=0;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(mat[i][j]==0){\\n                        count++;\\n                    }\\n                }\\n            }\\n            if(count==n*m){\\n                ans=min(ans,step);\\n            }\\n            return;\\n        }\\n        \\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        if(mat[row][col]==1){\\n            mat[row][col]=0;\\n        }\\n        else if(mat[row][col]==0){\\n            mat[row][col]=1;\\n        }\\n        for(int k=0;k<4;k++){\\n            int nrow=row+drow[k];\\n            int ncol=col+dcol[k];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m){\\n                if(mat[nrow][ncol]==1){\\n                    mat[nrow][ncol]=0;\\n                }\\n                else if(mat[nrow][ncol]==0){\\n                    mat[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n        fun(row,col+1,step+1,n,m,mat);\\n       \\n        if(mat[row][col]==1){\\n            mat[row][col]=0;\\n        }\\n        else if(mat[row][col]==0){\\n            mat[row][col]=1;\\n        }\\n        for(int k=0;k<4;k++){\\n            int nrow=row+drow[k];\\n            int ncol=col+dcol[k];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m){\\n                if(mat[nrow][ncol]==1){\\n                    mat[nrow][ncol]=0;\\n                }\\n                else if(mat[nrow][ncol]==0){\\n                    mat[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n        fun(row,col+1,step,n,m,mat);\\n\\n    }\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        if(n==1 && m==1){\\n            return mat[0][0];\\n        }\\n        fun(0,0,0,n,m,mat);\\n        if(ans==1e9){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int ans=1e9;\\nprivate:\\n    void fun(int row,int col,int step,int n,int m,vector<vector<int>>&mat){\\n        if(col==m){\\n            col=0;\\n            row++;\\n            \\n        }\\n        if(row==n){\\n            int count=0;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(mat[i][j]==0){\\n                        count++;\\n                    }\\n                }\\n            }\\n            if(count==n*m){\\n                ans=min(ans,step);\\n            }\\n            return;\\n        }\\n        \\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        if(mat[row][col]==1){\\n            mat[row][col]=0;\\n        }\\n        else if(mat[row][col]==0){\\n            mat[row][col]=1;\\n        }\\n        for(int k=0;k<4;k++){\\n            int nrow=row+drow[k];\\n            int ncol=col+dcol[k];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m){\\n                if(mat[nrow][ncol]==1){\\n                    mat[nrow][ncol]=0;\\n                }\\n                else if(mat[nrow][ncol]==0){\\n                    mat[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n        fun(row,col+1,step+1,n,m,mat);\\n       \\n        if(mat[row][col]==1){\\n            mat[row][col]=0;\\n        }\\n        else if(mat[row][col]==0){\\n            mat[row][col]=1;\\n        }\\n        for(int k=0;k<4;k++){\\n            int nrow=row+drow[k];\\n            int ncol=col+dcol[k];\\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m){\\n                if(mat[nrow][ncol]==1){\\n                    mat[nrow][ncol]=0;\\n                }\\n                else if(mat[nrow][ncol]==0){\\n                    mat[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n        fun(row,col+1,step,n,m,mat);\\n\\n    }\\npublic:\\n    int minFlips(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        if(n==1 && m==1){\\n            return mat[0][0];\\n        }\\n        fun(0,0,0,n,m,mat);\\n        if(ans==1e9){\\n            return -1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367208,
                "title": "c-simple-bfs-solution",
                "content": "\\n\\n# Approach\\nFirst we apply simple BFS, by tracing all elements and fliping every array element. \\n**functions**\\n=> Check() : check if every element in array is zero.\\n=> flip() : flip (i,j)th array element and its neighbours.\\n**Data structures**\\n=> q (queue): storing every possibility of array after fliping.\\n=> vis (set): to visit every possibility only once we store every array we have encountered upto now. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int n,m;\\n    bool check(vector<vector<int>>& a){\\n        for(int i=0;i<n;i++){\\n            for(int j=  0;j<m;j++){\\n                if(a[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> flip(vector<vector<int>> a,int i,int j){\\n        a[i][j]^=1;\\n        for(auto ele:dir){\\n            int X= ele[0]+i;\\n            int Y = ele[1]+j;\\n            if(X <0 || Y <0 || X>=n || Y>=m)continue;\\n            a[X][Y]^=1;\\n        }\\n        return a;\\n    }\\n   \\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size();\\n        m=mat[0].size();\\n        set<vector<vector<int>>> vis;\\n        vis.insert(mat);\\n        queue<vector<vector<int>>> q;\\n        q.push(mat);\\n        int count = 0;\\n        while(!q.empty()){\\n            int sz= q.size();\\n            while(sz--){\\n                vector<vector<int>> a = q.front();\\n            q.pop();\\n            if(check(a)) return count;\\n            // considering all posibility\\n            for(int i =0 ;i<n;i++){\\n                for(int j = 0;j<m;j++){\\n                    vector<vector<int>> t = flip(a,i,j);\\n                    if(vis.find(t) == vis.end()){\\n                        q.push(t);\\n                        vis.insert(t);\\n                    } \\n                }\\n            }\\n            }\\n            count++;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int n,m;\\n    bool check(vector<vector<int>>& a){\\n        for(int i=0;i<n;i++){\\n            for(int j=  0;j<m;j++){\\n                if(a[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> flip(vector<vector<int>> a,int i,int j){\\n        a[i][j]^=1;\\n        for(auto ele:dir){\\n            int X= ele[0]+i;\\n            int Y = ele[1]+j;\\n            if(X <0 || Y <0 || X>=n || Y>=m)continue;\\n            a[X][Y]^=1;\\n        }\\n        return a;\\n    }\\n   \\n\\n    int minFlips(vector<vector<int>>& mat) {\\n        n = mat.size();\\n        m=mat[0].size();\\n        set<vector<vector<int>>> vis;\\n        vis.insert(mat);\\n        queue<vector<vector<int>>> q;\\n        q.push(mat);\\n        int count = 0;\\n        while(!q.empty()){\\n            int sz= q.size();\\n            while(sz--){\\n                vector<vector<int>> a = q.front();\\n            q.pop();\\n            if(check(a)) return count;\\n            // considering all posibility\\n            for(int i =0 ;i<n;i++){\\n                for(int j = 0;j<m;j++){\\n                    vector<vector<int>> t = flip(a,i,j);\\n                    if(vis.find(t) == vis.end()){\\n                        q.push(t);\\n                        vis.insert(t);\\n                    } \\n                }\\n            }\\n            }\\n            count++;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316901,
                "title": "dfs-dp-explanation-for-using-dp-why-dp-easy-understanding-recursive-memoized-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought we get by seeing statement and constraints in brute force(try to flip all cells) and backtracking.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every cell we will flip (along with neighbours) and check whether is it possible to get zero matrix.This can be done with DFS but finding base case is our actual task.\\nWe need to observe that flipping a cell 2 times(even times) will not change the value (ex: 1->0->1   (->is flip)).This will remain same  throughout the recursion. \\nSo to avoid fliping a cell more than once we maintain set. \\nTraverse the matrix, flip a cell, convert indexes to string (or pairs can be added to set) add to set, call next DFS with new flipped matrix.\\n\\nAbove method leads to TLE because we keep on solving repetitive matrices.\\nWe get repetitive matrix for ex:\\noriginal        final (flipped (0,0) ->(0,1) )\\n0 0       1 1       0 0\\n0 1       1 1       1 0\\noriginal        final (flipped (0,1) ->(0,0) )\\n0 0       1 1       0 0\\n0 1       0 0       1 0\\n\\nFrom above illustration we can see that one matrix state can be achieved by choosing different sequence of cells to flip. Therefore DP will help.\\n\\nTherefore memoize the matrix by converting it to string.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   unordered_map<string,int>dp;\\n    void flip(int i,int j,vector<vector<int>>& m) {\\n        if(i+1<m.size())\\n            m[i+1][j]^=1;   //flips 1 to 0 and 0 to 1 by XOR \\n        if(j+1<m[0].size())\\n            m[i][j+1]^=1;\\n        if(i>0)\\n            m[i-1][j]^=1;\\n        if(j>0)\\n            m[i][j-1]^=1;\\n        m[i][j]^=1;\\n    }\\n    int f(vector<vector<int>>& m, unordered_set<string>&s) {\\n        int one=0;\\n        string dpk=\"\";  // key for matrix \\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size();j++){\\n                if(m[i][j]){\\n                    one=1;\\n                }\\n                dpk+=to_string(m[i][j]);    //converting matrix to string\\n            }\\n        }\\n        if(dp.count(dpk))\\n            return dp[dpk];\\n        if(!one)  //if no ones are present in matrix\\n          return 0;\\n        int c=1,a=1e8;\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size();j++){\\n                string key=to_string(i)+\" \"+to_string(j); //key to veisited cells\\n                if(s.count(key)) //if already visited continue\\n                    continue;\\n                flip(i,j,m);\\n                s.insert(key);\\n                a=min(a,f(m,s)+1);\\n                // backtracking\\n                s.erase(key);\\n                flip(i,j,m);\\n            }\\n        }\\n         return dp[dpk]=a;\\n    }\\n    int minFlips(vector<vector<int>>& m) {\\n        unordered_set<string>s;\\n        int x=f(m,s);\\n        if(x>=1e8)\\n            return -1;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   unordered_map<string,int>dp;\\n    void flip(int i,int j,vector<vector<int>>& m) {\\n        if(i+1<m.size())\\n            m[i+1][j]^=1;   //flips 1 to 0 and 0 to 1 by XOR \\n        if(j+1<m[0].size())\\n            m[i][j+1]^=1;\\n        if(i>0)\\n            m[i-1][j]^=1;\\n        if(j>0)\\n            m[i][j-1]^=1;\\n        m[i][j]^=1;\\n    }\\n    int f(vector<vector<int>>& m, unordered_set<string>&s) {\\n        int one=0;\\n        string dpk=\"\";  // key for matrix \\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size();j++){\\n                if(m[i][j]){\\n                    one=1;\\n                }\\n                dpk+=to_string(m[i][j]);    //converting matrix to string\\n            }\\n        }\\n        if(dp.count(dpk))\\n            return dp[dpk];\\n        if(!one)  //if no ones are present in matrix\\n          return 0;\\n        int c=1,a=1e8;\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size();j++){\\n                string key=to_string(i)+\" \"+to_string(j); //key to veisited cells\\n                if(s.count(key)) //if already visited continue\\n                    continue;\\n                flip(i,j,m);\\n                s.insert(key);\\n                a=min(a,f(m,s)+1);\\n                // backtracking\\n                s.erase(key);\\n                flip(i,j,m);\\n            }\\n        }\\n         return dp[dpk]=a;\\n    }\\n    int minFlips(vector<vector<int>>& m) {\\n        unordered_set<string>s;\\n        int x=f(m,s);\\n        if(x>=1e8)\\n            return -1;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298858,
                "title": "easy-undestandable-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dx={0,0,1,-1};\\n    vector<int>dy={1,-1,0,0};\\n\\n    int minFlips(vector<vector<int>>& mat) \\n    {\\n        int n = mat.size(), m = mat[0].size(), mask = 0;\\n        unordered_set<int>vis;\\n        queue<int>q;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                mask |= (mat[i][j] << (i*m+j));\\n\\n        q.push(mask);\\n        vis.insert(mask);\\n        int step = 0;\\n        while(!q.empty()) \\n        {\\n            int sz = q.size();\\n            while(sz--) \\n            {\\n                int cur = q.front();\\n                q.pop();\\n                if(cur == 0) return step;\\n                for(int i = 0; i < n; i++)\\n                {\\n                    for(int j = 0; j < m; j++) \\n                    {\\n                        int temp = cur;\\n                        temp ^= (1 << (i*m+j)); // flip the (i,j) bit\\n                        for(int k = 0; k < 4; k++) // flip the neighbours\\n                        {\\n                            int ni = i + dx[k];\\n                            int nj = j + dy[k];\\n                            if(ni>= 0 && ni < n && nj>=0 && nj < m) temp ^= (1 << (ni*m + nj));\\n                        }\\n                        if(vis.find(temp) == vis.end()) \\n                        {\\n                            vis.insert(temp);\\n                            q.push(temp);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dx={0,0,1,-1};\\n    vector<int>dy={1,-1,0,0};\\n\\n    int minFlips(vector<vector<int>>& mat) \\n    {\\n        int n = mat.size(), m = mat[0].size(), mask = 0;\\n        unordered_set<int>vis;\\n        queue<int>q;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                mask |= (mat[i][j] << (i*m+j));\\n\\n        q.push(mask);\\n        vis.insert(mask);\\n        int step = 0;\\n        while(!q.empty()) \\n        {\\n            int sz = q.size();\\n            while(sz--) \\n            {\\n                int cur = q.front();\\n                q.pop();\\n                if(cur == 0) return step;\\n                for(int i = 0; i < n; i++)\\n                {\\n                    for(int j = 0; j < m; j++) \\n                    {\\n                        int temp = cur;\\n                        temp ^= (1 << (i*m+j)); // flip the (i,j) bit\\n                        for(int k = 0; k < 4; k++) // flip the neighbours\\n                        {\\n                            int ni = i + dx[k];\\n                            int nj = j + dy[k];\\n                            if(ni>= 0 && ni < n && nj>=0 && nj < m) temp ^= (1 << (ni*m + nj));\\n                        }\\n                        if(vis.find(temp) == vis.end()) \\n                        {\\n                            vis.insert(temp);\\n                            q.push(temp);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266781,
                "title": "python-3-bit-mask-bfs",
                "content": "# Code\\n```\\nclass Solution:\\n    DIRECTIONS = (-1, 0), (1, 0), (0, 0), (0, -1), (0, 1)\\n\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        mask = 0\\n        for row in reversed(mat):\\n            for cell in reversed(row):\\n                mask = (mask << 1) | cell\\n        if not mask:\\n            return 0\\n        q = collections.deque([(mask, 0)])\\n        visited = {mask}\\n        while q:\\n            mask, steps = q.popleft()\\n            steps += 1\\n            for i in range(m):\\n                for j in range(n):\\n                    new = mask\\n                    for di, dj in Solution.DIRECTIONS:\\n                        r, c = i + di, j + dj\\n                        if 0 <= r < m and 0 <= c < n:\\n                            new ^= 1 << (n*r + c)\\n                    if not new:\\n                        return steps\\n                    if new not in visited:\\n                        q.append((new, steps))\\n                        visited.add(new)\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    DIRECTIONS = (-1, 0), (1, 0), (0, 0), (0, -1), (0, 1)\\n\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        mask = 0\\n        for row in reversed(mat):\\n            for cell in reversed(row):\\n                mask = (mask << 1) | cell\\n        if not mask:\\n            return 0\\n        q = collections.deque([(mask, 0)])\\n        visited = {mask}\\n        while q:\\n            mask, steps = q.popleft()\\n            steps += 1\\n            for i in range(m):\\n                for j in range(n):\\n                    new = mask\\n                    for di, dj in Solution.DIRECTIONS:\\n                        r, c = i + di, j + dj\\n                        if 0 <= r < m and 0 <= c < n:\\n                            new ^= 1 << (n*r + c)\\n                    if not new:\\n                        return steps\\n                    if new not in visited:\\n                        q.append((new, steps))\\n                        visited.add(new)\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262286,
                "title": "python3-dfs-recursive-iterate-through-all-the-cells-either-by-flipping-or-not-flipping-o-2-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGo through each cell, like the hint states, with either flipping it, or not flipping it. And make sure to reverse the flip in the current stack of DFS. Don\\'t worry about iterating through all the cells, the matrix is really small. I started off with prematurely optimizing for the matrix cells.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Write a function to flip a matrix, in place.\\n2. Write a function to check whether a matrix is all zeroes.\\n3. Write a function to calculate steps for either flipping or not flipping. Ensure matrix is unflipped otherwise there will be dirty writes.\\n4. In the above function, if you have crossed a boundary row-wise, get to the next column from row zero. If you have crossed the boundary column wise as well, check whether all are zeroes else, return infinity.\\n5. The above point is the termination condition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^(m*n)) because we iterate through all the cells. And each cell has 2 choices.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) in the sense we do not use any additional variable space. We keep changing the matrix in-place. But the code does use O(m*n) space from the input.\\n\\n# Code\\n```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n\\n        m, n = len(mat), len(mat[0])\\n\\n        def flip(mat, x, y):\\n            nonlocal m, n\\n            mat[x][y] ^= 1\\n            if x > 0:\\n                mat[x-1][y] ^= 1\\n            if x < m-1:\\n                mat[x+1][y] ^= 1\\n            if y > 0:\\n                mat[x][y-1] ^= 1\\n            if y < n-1:\\n                mat[x][y+1] ^= 1\\n            return mat\\n\\n        def is_zero_mat(mat):\\n            nonlocal m, n\\n            for i in range(m):\\n                for j in range(n):\\n                    if mat[i][j]:\\n                        return False\\n            return True\\n\\n        def flip_or_not_flip(mat, x, y):\\n            if y == n:\\n                x += 1\\n                y = 0\\n            if x == m:\\n                if is_zero_mat(mat):\\n                    return 0\\n                return float(\\'inf\\')\\n            not_flip = flip_or_not_flip(mat, x, y+1)\\n            flip(mat, x, y)\\n            flipped = 1 + flip_or_not_flip(mat, x, y+1)\\n            flip(mat, x, y)\\n            return min(not_flip, flipped)\\n\\n        steps = flip_or_not_flip(mat, 0, 0)\\n        if steps != float(\\'inf\\'):\\n            return steps\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n\\n        m, n = len(mat), len(mat[0])\\n\\n        def flip(mat, x, y):\\n            nonlocal m, n\\n            mat[x][y] ^= 1\\n            if x > 0:\\n                mat[x-1][y] ^= 1\\n            if x < m-1:\\n                mat[x+1][y] ^= 1\\n            if y > 0:\\n                mat[x][y-1] ^= 1\\n            if y < n-1:\\n                mat[x][y+1] ^= 1\\n            return mat\\n\\n        def is_zero_mat(mat):\\n            nonlocal m, n\\n            for i in range(m):\\n                for j in range(n):\\n                    if mat[i][j]:\\n                        return False\\n            return True\\n\\n        def flip_or_not_flip(mat, x, y):\\n            if y == n:\\n                x += 1\\n                y = 0\\n            if x == m:\\n                if is_zero_mat(mat):\\n                    return 0\\n                return float(\\'inf\\')\\n            not_flip = flip_or_not_flip(mat, x, y+1)\\n            flip(mat, x, y)\\n            flipped = 1 + flip_or_not_flip(mat, x, y+1)\\n            flip(mat, x, y)\\n            return min(not_flip, flipped)\\n\\n        steps = flip_or_not_flip(mat, 0, 0)\\n        if steps != float(\\'inf\\'):\\n            return steps\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243723,
                "title": "javascript-1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nlet dirs = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n    [0, 0],\\n];\\n\\nfunction binaryMatrix2Decimal(mat, m, n) {\\n    let x = 0;\\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            x = x * 2 + mat[i][j];\\n        }\\n    }\\n    return x;\\n}\\n\\nfunction decimal2binaryMatrix(x, m, n) {\\n    let mat = Array.from({ length: m }, () => new Array(n));\\n    for (let i = m - 1; i >= 0; --i) {\\n        for (let j = n - 1; j >= 0; --j) {\\n            mat[i][j] = x & 1;\\n            x >>= 1;\\n        }\\n    }\\n    return mat;\\n}\\n\\nfunction flipSelfAndNeighbors(mat, m, n, i, j) {\\n    for (let k = 0; k < 5; ++k) {\\n        let ni = i + dirs[k][0],\\n            nj = j + dirs[k][1];\\n        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\\n            mat[ni][nj] ^= 1;\\n        }\\n    }\\n}\\n\\nfunction minFlips(mat) {\\n    let m = mat.length,\\n        n = mat[0].length;\\n\\n    let x_start = binaryMatrix2Decimal(mat, m, n),\\n        steps = 0;\\n    if (x_start == 0) {\\n        return steps;\\n    }\\n\\n    let q = [x_start];\\n    let visited = new Set([x_start]);\\n    while (q.length) {\\n        ++steps;\\n        let len = q.length;\\n        while (len--) {\\n            let mat_cur = decimal2binaryMatrix(q.shift(), m, n);\\n            for (let i = 0; i < m; ++i) {\\n                for (let j = 0; j < n; ++j) {\\n                    flipSelfAndNeighbors(mat_cur, m, n, i, j);\\n                    let x_cur = binaryMatrix2Decimal(mat_cur, m, n);\\n                    if (x_cur === 0) {\\n                        return steps;\\n                    }\\n                    if (!visited.has(x_cur)) {\\n                        visited.add(x_cur);\\n                        q.push(x_cur);\\n                    }\\n\\n                    flipSelfAndNeighbors(mat_cur, m, n, i, j);\\n                }\\n            }\\n        }\\n    }\\n\\n    return -1;\\n}\\n```\\n\\n2\\n```\\nfunction flipSelfAndNeighbors(mat, m, n, i, j) {\\n    for (let k = 0; k < 5; ++k) {\\n        let ni = i + dirs[k][0],\\n            nj = j + dirs[k][1];\\n        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\\n            mat[ni][nj] ^= 1;\\n        }\\n    }\\n}\\n\\nfunction minFlips(mat) {\\n    let ans = 1e9;\\n\\n    function dfs(mat, m, n, pos, flip_cnt) {\\n        if (pos == m * n) {\\n            let flag = true;\\n            for (let i = 0; i < m; ++i) {\\n                for (let j = 0; j < n; ++j) {\\n                    if (mat[i][j] != 0) {\\n                        flag = false;\\n                        break; // NEW\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans = Math.min(ans, flip_cnt);\\n            }\\n            return;\\n        }\\n\\n        let i = ~~(pos / n),\\n            j = pos % n;\\n        {\\n            //\\n            // not flip\\n            dfs(mat, m, n, pos + 1, flip_cnt);\\n            // flip\\n            flipSelfAndNeighbors(mat, m, n, i, j);\\n            dfs(mat, m, n, pos + 1, flip_cnt + 1);\\n\\n            flipSelfAndNeighbors(mat, m, n, i, j);\\n        }\\n    }\\n    let m = mat.length,\\n        n = mat[0].length;\\n    dfs(mat, m, n, 0, 0);\\n    return ans != 1e9 ? ans : -1;\\n}\\n```\\n\\n3\\n```\\nfunction flipSelfAndNeighbors(mat, m, n, i, j) {\\n    for (let k = 0; k < 5; ++k) {\\n        let ni = i + dirs[k][0],\\n            nj = j + dirs[k][1];\\n        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\\n            mat[ni][nj] ^= 1;\\n        }\\n    }\\n}\\n\\nfunction minFlips(mat) {\\n    let ans = 1e9;\\n\\n    function dfs(mat, m, n, pos, flip_cnt) {\\n        if (pos == m * n) {\\n            let flag = true;\\n            {\\n                for (let j = 0; j < n; ++j) {\\n                    if (mat[m - 1][j] != 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans = Math.min(ans, flip_cnt);\\n            }\\n            return;\\n        }\\n\\n        let i = ~~(pos / n),\\n            j = pos % n;\\n        if (i == 0) {\\n            // in the first line we can choose either flip or not flip\\n            // not flip\\n            dfs(mat, m, n, pos + 1, flip_cnt);\\n            // flip\\n            flipSelfAndNeighbors(mat, m, n, i, j);\\n            dfs(mat, m, n, pos + 1, flip_cnt + 1);\\n\\n            flipSelfAndNeighbors(mat, m, n, i, j);\\n        } else {\\n            // otherwise it depends on the upper grid\\n            if (mat[i - 1][j] == 0) {\\n                dfs(mat, m, n, pos + 1, flip_cnt);\\n            } else {\\n                flipSelfAndNeighbors(mat, m, n, i, j);\\n                dfs(mat, m, n, pos + 1, flip_cnt + 1);\\n\\n                flipSelfAndNeighbors(mat, m, n, i, j);\\n            }\\n        }\\n    }\\n    let m = mat.length,\\n        n = mat[0].length;\\n    dfs(mat, m, n, 0, 0);\\n    return ans != 1e9 ? ans : -1;\\n}\\n```\\n\\n4\\n```\\nfunction flipSelfAndNeighbors(mat, m, n, i, j) {\\n    for (let k = 0; k < 5; ++k) {\\n        let ni = i + dirs[k][0],\\n            nj = j + dirs[k][1];\\n        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\\n            mat[ni][nj] ^= 1;\\n        }\\n    }\\n}\\nfunction minFlips(mat) {\\n    let m = mat.length,\\n        n = mat[0].length;\\n    let ans = 1e9;\\n\\n    for (let bin = 0; bin < 1 << n; ++bin) {\\n        let mat_copy = mat.map((r) => [...r]);\\n\\n        let flip_cnt = 0;\\n\\n        // first line, flip at all 1 s\\n        for (let j = 0; j < n; ++j) {\\n            if (bin & (1 << j)) {\\n                ++flip_cnt;\\n                flipSelfAndNeighbors(mat_copy, m, n, 0, j);\\n            }\\n        }\\n        // otherwise\\n        for (let i = 1; i < m; ++i) {\\n            for (let j = 0; j < n; ++j) {\\n                if (mat_copy[i - 1][j] == 1) {\\n                    ++flip_cnt;\\n                    flipSelfAndNeighbors(mat_copy, m, n, i, j);\\n                }\\n            }\\n        }\\n\\n        let flag = true;\\n        for (let j = 0; j < n; ++j) {\\n            if (mat_copy[m - 1][j] != 0) {\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if (flag) {\\n            ans = Math.min(ans, flip_cnt);\\n        }\\n    }\\n    return ans != 1e9 ? ans : -1;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet dirs = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n    [0, 0],\\n];\\n\\nfunction binaryMatrix2Decimal(mat, m, n) {\\n    let x = 0;\\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            x = x * 2 + mat[i][j];\\n        }\\n    }\\n    return x;\\n}\\n\\nfunction decimal2binaryMatrix(x, m, n) {\\n    let mat = Array.from({ length: m }, () => new Array(n));\\n    for (let i = m - 1; i >= 0; --i) {\\n        for (let j = n - 1; j >= 0; --j) {\\n            mat[i][j] = x & 1;\\n            x >>= 1;\\n        }\\n    }\\n    return mat;\\n}\\n\\nfunction flipSelfAndNeighbors(mat, m, n, i, j) {\\n    for (let k = 0; k < 5; ++k) {\\n        let ni = i + dirs[k][0],\\n            nj = j + dirs[k][1];\\n        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\\n            mat[ni][nj] ^= 1;\\n        }\\n    }\\n}\\n\\nfunction minFlips(mat) {\\n    let m = mat.length,\\n        n = mat[0].length;\\n\\n    let x_start = binaryMatrix2Decimal(mat, m, n),\\n        steps = 0;\\n    if (x_start == 0) {\\n        return steps;\\n    }\\n\\n    let q = [x_start];\\n    let visited = new Set([x_start]);\\n    while (q.length) {\\n        ++steps;\\n        let len = q.length;\\n        while (len--) {\\n            let mat_cur = decimal2binaryMatrix(q.shift(), m, n);\\n            for (let i = 0; i < m; ++i) {\\n                for (let j = 0; j < n; ++j) {\\n                    flipSelfAndNeighbors(mat_cur, m, n, i, j);\\n                    let x_cur = binaryMatrix2Decimal(mat_cur, m, n);\\n                    if (x_cur === 0) {\\n                        return steps;\\n                    }\\n                    if (!visited.has(x_cur)) {\\n                        visited.add(x_cur);\\n                        q.push(x_cur);\\n                    }\\n\\n                    flipSelfAndNeighbors(mat_cur, m, n, i, j);\\n                }\\n            }\\n        }\\n    }\\n\\n    return -1;\\n}\\n```\n```\\nfunction flipSelfAndNeighbors(mat, m, n, i, j) {\\n    for (let k = 0; k < 5; ++k) {\\n        let ni = i + dirs[k][0],\\n            nj = j + dirs[k][1];\\n        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\\n            mat[ni][nj] ^= 1;\\n        }\\n    }\\n}\\n\\nfunction minFlips(mat) {\\n    let ans = 1e9;\\n\\n    function dfs(mat, m, n, pos, flip_cnt) {\\n        if (pos == m * n) {\\n            let flag = true;\\n            for (let i = 0; i < m; ++i) {\\n                for (let j = 0; j < n; ++j) {\\n                    if (mat[i][j] != 0) {\\n                        flag = false;\\n                        break; // NEW\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans = Math.min(ans, flip_cnt);\\n            }\\n            return;\\n        }\\n\\n        let i = ~~(pos / n),\\n            j = pos % n;\\n        {\\n            //\\n            // not flip\\n            dfs(mat, m, n, pos + 1, flip_cnt);\\n            // flip\\n            flipSelfAndNeighbors(mat, m, n, i, j);\\n            dfs(mat, m, n, pos + 1, flip_cnt + 1);\\n\\n            flipSelfAndNeighbors(mat, m, n, i, j);\\n        }\\n    }\\n    let m = mat.length,\\n        n = mat[0].length;\\n    dfs(mat, m, n, 0, 0);\\n    return ans != 1e9 ? ans : -1;\\n}\\n```\n```\\nfunction flipSelfAndNeighbors(mat, m, n, i, j) {\\n    for (let k = 0; k < 5; ++k) {\\n        let ni = i + dirs[k][0],\\n            nj = j + dirs[k][1];\\n        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\\n            mat[ni][nj] ^= 1;\\n        }\\n    }\\n}\\n\\nfunction minFlips(mat) {\\n    let ans = 1e9;\\n\\n    function dfs(mat, m, n, pos, flip_cnt) {\\n        if (pos == m * n) {\\n            let flag = true;\\n            {\\n                for (let j = 0; j < n; ++j) {\\n                    if (mat[m - 1][j] != 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans = Math.min(ans, flip_cnt);\\n            }\\n            return;\\n        }\\n\\n        let i = ~~(pos / n),\\n            j = pos % n;\\n        if (i == 0) {\\n            // in the first line we can choose either flip or not flip\\n            // not flip\\n            dfs(mat, m, n, pos + 1, flip_cnt);\\n            // flip\\n            flipSelfAndNeighbors(mat, m, n, i, j);\\n            dfs(mat, m, n, pos + 1, flip_cnt + 1);\\n\\n            flipSelfAndNeighbors(mat, m, n, i, j);\\n        } else {\\n            // otherwise it depends on the upper grid\\n            if (mat[i - 1][j] == 0) {\\n                dfs(mat, m, n, pos + 1, flip_cnt);\\n            } else {\\n                flipSelfAndNeighbors(mat, m, n, i, j);\\n                dfs(mat, m, n, pos + 1, flip_cnt + 1);\\n\\n                flipSelfAndNeighbors(mat, m, n, i, j);\\n            }\\n        }\\n    }\\n    let m = mat.length,\\n        n = mat[0].length;\\n    dfs(mat, m, n, 0, 0);\\n    return ans != 1e9 ? ans : -1;\\n}\\n```\n```\\nfunction flipSelfAndNeighbors(mat, m, n, i, j) {\\n    for (let k = 0; k < 5; ++k) {\\n        let ni = i + dirs[k][0],\\n            nj = j + dirs[k][1];\\n        if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\\n            mat[ni][nj] ^= 1;\\n        }\\n    }\\n}\\nfunction minFlips(mat) {\\n    let m = mat.length,\\n        n = mat[0].length;\\n    let ans = 1e9;\\n\\n    for (let bin = 0; bin < 1 << n; ++bin) {\\n        let mat_copy = mat.map((r) => [...r]);\\n\\n        let flip_cnt = 0;\\n\\n        // first line, flip at all 1 s\\n        for (let j = 0; j < n; ++j) {\\n            if (bin & (1 << j)) {\\n                ++flip_cnt;\\n                flipSelfAndNeighbors(mat_copy, m, n, 0, j);\\n            }\\n        }\\n        // otherwise\\n        for (let i = 1; i < m; ++i) {\\n            for (let j = 0; j < n; ++j) {\\n                if (mat_copy[i - 1][j] == 1) {\\n                    ++flip_cnt;\\n                    flipSelfAndNeighbors(mat_copy, m, n, i, j);\\n                }\\n            }\\n        }\\n\\n        let flag = true;\\n        for (let j = 0; j < n; ++j) {\\n            if (mat_copy[m - 1][j] != 0) {\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if (flag) {\\n            ans = Math.min(ans, flip_cnt);\\n        }\\n    }\\n    return ans != 1e9 ? ans : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112813,
                "title": "javascript-bfs-solution",
                "content": "It is very similar with [773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/description/)\\nYou can take more pratice after you finish this.\\n\\nThe concept here is to see all the possible result and skip those already have seen. \\nUsing BFS is because BFS can test all the result of same level and return it as soon as the result found.\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n    let visited = {}\\n    let start = mat.flat().join(\\'\\')\\n    let queue = [start]\\n    let level = 0\\n\\n    while(queue.length) {\\n        let size = queue.length\\n\\n        for(let i = 0; i < size; i++) {\\n            let cur = queue.shift()\\n\\n            if(visited[cur]) continue\\n            visited[cur] = true\\n\\n            if(allZero(cur)) return level\\n\\n            for(let row = 0; row < mat.length; row++) {\\n                for(let col = 0; col < mat[0].length; col++) {\\n                    let next = getNext(cur, [row, col], mat.length, mat[0].length)\\n\\n                    if(next) queue.push(next)\\n                }\\n            }\\n        }\\n        level++\\n    }\\n\\n    return -1\\n};\\n\\nconst getNext = (cur, [curRow, curCol], height, width) => {\\n    let mat = []\\n\\n    for(let i = 0; i < height; i++) {\\n        for(let j = 0; j < width; j++) {\\n            mat[i] ||= []\\n            mat[i][j] = cur[i * width + j]\\n        }\\n    }\\n\\n    let neighbors = [[0, 1], [1, 0], [0, -1], [-1, 0], [0, 0]]\\n\\n    for(let [row, col] of neighbors) {\\n        let [nextRow, nextCol] = [curRow + row, curCol + col]\\n        if(nextRow < 0 || nextCol < 0 || nextRow >= height || nextCol >= width) continue\\n        \\n        mat[nextRow][nextCol] ^= 1\\n    }\\n\\n    return mat.flat().join(\\'\\')\\n}\\n\\nconst allZero = cur => cur.split(\\'\\').every(c => c === \\'0\\')\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar minFlips = function(mat) {\\n    let visited = {}\\n    let start = mat.flat().join(\\'\\')\\n    let queue = [start]\\n    let level = 0\\n\\n    while(queue.length) {\\n        let size = queue.length\\n\\n        for(let i = 0; i < size; i++) {\\n            let cur = queue.shift()\\n\\n            if(visited[cur]) continue\\n            visited[cur] = true\\n\\n            if(allZero(cur)) return level\\n\\n            for(let row = 0; row < mat.length; row++) {\\n                for(let col = 0; col < mat[0].length; col++) {\\n                    let next = getNext(cur, [row, col], mat.length, mat[0].length)\\n\\n                    if(next) queue.push(next)\\n                }\\n            }\\n        }\\n        level++\\n    }\\n\\n    return -1\\n};\\n\\nconst getNext = (cur, [curRow, curCol], height, width) => {\\n    let mat = []\\n\\n    for(let i = 0; i < height; i++) {\\n        for(let j = 0; j < width; j++) {\\n            mat[i] ||= []\\n            mat[i][j] = cur[i * width + j]\\n        }\\n    }\\n\\n    let neighbors = [[0, 1], [1, 0], [0, -1], [-1, 0], [0, 0]]\\n\\n    for(let [row, col] of neighbors) {\\n        let [nextRow, nextCol] = [curRow + row, curCol + col]\\n        if(nextRow < 0 || nextCol < 0 || nextRow >= height || nextCol >= width) continue\\n        \\n        mat[nextRow][nextCol] ^= 1\\n    }\\n\\n    return mat.flat().join(\\'\\')\\n}\\n\\nconst allZero = cur => cur.split(\\'\\').every(c => c === \\'0\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3066155,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minFlips(self, mat):\\n        m, n = len(mat), len(mat[0])\\n\\n        def func_flip(nmat,x,y):\\n            new_mat = copy.deepcopy(nmat)\\n\\n            new_mat[x][y]^=1\\n\\n            for nx,ny in [(x-1,y),(x+1,y),(x,y+1),(x,y-1)]:\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    new_mat[nx][ny] ^= 1\\n\\n            return new_mat\\n\\n        stack, visited = [(0,mat)], set()\\n\\n        while stack:\\n            count, board = stack.pop(0)\\n\\n            if board == [[0]*n for _ in range(m)]: return count\\n\\n            for i in range(m):\\n                for j in range(n):\\n                    new_mat = func_flip(board,i,j)\\n                    cur = tuple(map(tuple,new_mat))\\n                    if cur not in visited:\\n                        stack.append((count+1,new_mat))\\n                        visited.add(cur)\\n\\n        return -1\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFlips(self, mat):\\n        m, n = len(mat), len(mat[0])\\n\\n        def func_flip(nmat,x,y):\\n            new_mat = copy.deepcopy(nmat)\\n\\n            new_mat[x][y]^=1\\n\\n            for nx,ny in [(x-1,y),(x+1,y),(x,y+1),(x,y-1)]:\\n                if 0 <= nx < m and 0 <= ny < n:\\n                    new_mat[nx][ny] ^= 1\\n\\n            return new_mat\\n\\n        stack, visited = [(0,mat)], set()\\n\\n        while stack:\\n            count, board = stack.pop(0)\\n\\n            if board == [[0]*n for _ in range(m)]: return count\\n\\n            for i in range(m):\\n                for j in range(n):\\n                    new_mat = func_flip(board,i,j)\\n                    cur = tuple(map(tuple,new_mat))\\n                    if cur not in visited:\\n                        stack.append((count+1,new_mat))\\n                        visited.add(cur)\\n\\n        return -1\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049864,
                "title": "bitmask-100-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict,deque\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n\\n        n=len(mat)\\n        m=len(mat[0])\\n        dirr=[(1,0),(0,1),(-1,0),(0,-1)]\\n        d=defaultdict(list)\\n        start=0\\n        for i in range(n):\\n            for j in range(m):\\n                if mat[i][j]==1:\\n\\n                    start+=2**(i*m + j)\\n                for k in dirr:\\n                    if i+k[0] in range(n) and j+k[1] in range(m):\\n                        d[(i*m)+j].append(((i+k[0])*m+(j+k[1]))) \\n        if start==0:\\n            return 0\\n        stc=deque()\\n        stc.append([start,0])\\n        visit=set()\\n        visit.add(start)\\n        while stc:\\n            #print(\\'--------\\')\\n            #print(\\'stc \\',stc)\\n            k=stc.popleft()\\n            #print(\\'k \\',k)\\n            if k[0]==0:\\n                return k[1]\\n            for i in range(n*m):\\n                #print(\\'+++++++++\\')\\n                #print(\\'i \\',i)\\n                t=k[0]\\n                #print(\\'t \\',t)\\n                #print(\\'1<<i \\',1<<i)\\n                if 1<<i & t:\\n                    #print(\\'1\\')\\n                    t-=2**(i)\\n                else:\\n                    #print(\\'2\\')\\n                    t+=2**(i)\\n                #print(\\'final t \\',t)\\n                for a in d[i]:\\n                    #print(\\'^^^^^\\')\\n                    #print(\\'a \\',a)\\n                    if 1<<a & t:\\n                        t-=2**(a)\\n                    else:\\n                        t+=2**(a)\\n                if t not in visit:\\n                    visit.add(t)\\n                    stc.append([t,k[1]+1])\\n        return -1\\n            \\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict,deque\\nclass Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n\\n        n=len(mat)\\n        m=len(mat[0])\\n        dirr=[(1,0),(0,1),(-1,0),(0,-1)]\\n        d=defaultdict(list)\\n        start=0\\n        for i in range(n):\\n            for j in range(m):\\n                if mat[i][j]==1:\\n\\n                    start+=2**(i*m + j)\\n                for k in dirr:\\n                    if i+k[0] in range(n) and j+k[1] in range(m):\\n                        d[(i*m)+j].append(((i+k[0])*m+(j+k[1]))) \\n        if start==0:\\n            return 0\\n        stc=deque()\\n        stc.append([start,0])\\n        visit=set()\\n        visit.add(start)\\n        while stc:\\n            #print(\\'--------\\')\\n            #print(\\'stc \\',stc)\\n            k=stc.popleft()\\n            #print(\\'k \\',k)\\n            if k[0]==0:\\n                return k[1]\\n            for i in range(n*m):\\n                #print(\\'+++++++++\\')\\n                #print(\\'i \\',i)\\n                t=k[0]\\n                #print(\\'t \\',t)\\n                #print(\\'1<<i \\',1<<i)\\n                if 1<<i & t:\\n                    #print(\\'1\\')\\n                    t-=2**(i)\\n                else:\\n                    #print(\\'2\\')\\n                    t+=2**(i)\\n                #print(\\'final t \\',t)\\n                for a in d[i]:\\n                    #print(\\'^^^^^\\')\\n                    #print(\\'a \\',a)\\n                    if 1<<a & t:\\n                        t-=2**(a)\\n                    else:\\n                        t+=2**(a)\\n                if t not in visit:\\n                    visit.add(t)\\n                    stc.append([t,k[1]+1])\\n        return -1\\n            \\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047841,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet getMapCopy = (mat) => {\\n    let newMat = new Array(mat.length).fill().map(() => new Array(mat[0].length))\\n    \\n    for (let row=0; row<mat.length; row++) {\\n        for (let col=0; col<mat[0].length; col++) {\\n            newMat[row][col] = mat[row][col]\\n        }\\n    }\\n    \\n    return newMat\\n}\\n\\nconst isGoal = (mat) => { \\n    for (let row=0; row<mat.length; row++) {\\n        for (let col=0; col<mat[0].length; col++) {\\n            if (mat[row][col] !== 0) return false\\n        }\\n    }\\n    \\n    return true\\n}\\n\\nvar minFlips = function(mat) {\\n    if (isGoal(mat)) return 0\\n    \\n    let queue = [mat]\\n    let seen = new Set([`${mat}`])\\n    let switches = 0\\n    \\n    let flip = {0: 1, 1: 0}\\n    \\n    while (queue.length) {\\n        switches++\\n        for (let i=queue.length-1; i>=0; i--) {\\n            let matNode = queue.shift()\\n            \\n            for (let row=0; row<mat.length; row++) {\\n                for (let col=0; col<mat[0].length; col++) {                   \\n                    let matCopy = getMapCopy(matNode)\\n\\n                    matCopy[row][col] = flip[matCopy[row][col]]\\n                    \\n                    //for each flip, toggle its neighbours\\n                    for (let [nr, nc] of [[row+1, col], [row-1, col], [row, col+1], [row, col-1]]) {\\n                        //check boundary\\n                        if (nr < 0 || nr > mat.length-1) continue \\n                        if (nc < 0 || nc > mat[0].length-1) continue\\n                        \\n                        matCopy[nr][nc] = flip[matCopy[nr][nc]]\\n                    }\\n                    \\n                    if (seen.has(`${matCopy}`)) continue \\n\\t\\t\\t\\t\\tseen.add(`${matCopy}`)\\n\\n                    if (isGoal(matCopy)) return switches\\n\\t\\t\\t\\t\\t\\n                    queue.push(matCopy)\\n                }\\n            }    \\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet getMapCopy = (mat) => {\\n    let newMat = new Array(mat.length).fill().map(() => new Array(mat[0].length))\\n    \\n    for (let row=0; row<mat.length; row++) {\\n        for (let col=0; col<mat[0].length; col++) {\\n            newMat[row][col] = mat[row][col]\\n        }\\n    }\\n    \\n    return newMat\\n}\\n\\nconst isGoal = (mat) => { \\n    for (let row=0; row<mat.length; row++) {\\n        for (let col=0; col<mat[0].length; col++) {\\n            if (mat[row][col] !== 0) return false\\n        }\\n    }\\n    \\n    return true\\n}\\n\\nvar minFlips = function(mat) {\\n    if (isGoal(mat)) return 0\\n    \\n    let queue = [mat]\\n    let seen = new Set([`${mat}`])\\n    let switches = 0\\n    \\n    let flip = {0: 1, 1: 0}\\n    \\n    while (queue.length) {\\n        switches++\\n        for (let i=queue.length-1; i>=0; i--) {\\n            let matNode = queue.shift()\\n            \\n            for (let row=0; row<mat.length; row++) {\\n                for (let col=0; col<mat[0].length; col++) {                   \\n                    let matCopy = getMapCopy(matNode)\\n\\n                    matCopy[row][col] = flip[matCopy[row][col]]\\n                    \\n                    //for each flip, toggle its neighbours\\n                    for (let [nr, nc] of [[row+1, col], [row-1, col], [row, col+1], [row, col-1]]) {\\n                        //check boundary\\n                        if (nr < 0 || nr > mat.length-1) continue \\n                        if (nc < 0 || nc > mat[0].length-1) continue\\n                        \\n                        matCopy[nr][nc] = flip[matCopy[nr][nc]]\\n                    }\\n                    \\n                    if (seen.has(`${matCopy}`)) continue \\n\\t\\t\\t\\t\\tseen.add(`${matCopy}`)\\n\\n                    if (isGoal(matCopy)) return switches\\n\\t\\t\\t\\t\\t\\n                    queue.push(matCopy)\\n                }\\n            }    \\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1826059,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "\"A pair of cells are called neighbors if they share one edge.\"\\nWhat a horrible way to describe things! What \"edge\"? Confused the hell out of me and drove me into write flip routines that flip the entire first and last rows and columns."
                    },
                    {
                        "username": "joanromano",
                        "content": "It would be good for the next time to check all your parsers work properly before the context. Literally had almost one hour left in the contest with only this question left and couldn\\'t even attempt it, really frustrating experience\\n\\n![image](https://assets.leetcode.com/users/joanromano/image_1575777871.png)\\n"
                    },
                    {
                        "username": "UtpalMat",
                        "content": "Hi -\\n\\nFrom instructions: \\n\\n**Question 1)**\\nWhy does flipping this matrix require 3 steps? The index at (1,1) is a neighbor of index (0,0) - so it should be only one step? \\n\\nOr are we looking at 3 neighbors, so 3 steps?\\n\\nInput: `mat = [[0,0],[0,1]]`\\nOutput: 3\\nExplanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\\n\\nAlso -\\n\\n**Question 2)**\\n\\nWhy cant this matrix be flipped? \\n\\nInput: mat = `[[1,0,0],[1,0,0]]`\\nOutput: -1\\nExplanation: Given matrix can\\'t be a zero matrix\\n \\nConstraints:\\n`\\nm == mat.length\\n\\nn == mat[0].length\\n\\n1 <= m <= 3\\n\\n1 <= n <= 3\\n`\\n\\nmat[i][j] is 0 or 1."
                    },
                    {
                        "username": "charonme",
                        "content": "Answer 1) the index at (1,1) is NOT a neighbor of index (0,0), only indexes (-1,0), (1,0), (0,-1) and (0,1) are. (1,1) is diagonally from (0,0), so it's not a neighbor of (0,0).\nAnswer 2) because even when you try all the flipping permutations you will not get a zero matrix. Their given \"explanation\" is wrong and doesn't make sense."
                    }
                ]
            },
            {
                "id": 1573244,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "\"A pair of cells are called neighbors if they share one edge.\"\\nWhat a horrible way to describe things! What \"edge\"? Confused the hell out of me and drove me into write flip routines that flip the entire first and last rows and columns."
                    },
                    {
                        "username": "joanromano",
                        "content": "It would be good for the next time to check all your parsers work properly before the context. Literally had almost one hour left in the contest with only this question left and couldn\\'t even attempt it, really frustrating experience\\n\\n![image](https://assets.leetcode.com/users/joanromano/image_1575777871.png)\\n"
                    },
                    {
                        "username": "UtpalMat",
                        "content": "Hi -\\n\\nFrom instructions: \\n\\n**Question 1)**\\nWhy does flipping this matrix require 3 steps? The index at (1,1) is a neighbor of index (0,0) - so it should be only one step? \\n\\nOr are we looking at 3 neighbors, so 3 steps?\\n\\nInput: `mat = [[0,0],[0,1]]`\\nOutput: 3\\nExplanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\\n\\nAlso -\\n\\n**Question 2)**\\n\\nWhy cant this matrix be flipped? \\n\\nInput: mat = `[[1,0,0],[1,0,0]]`\\nOutput: -1\\nExplanation: Given matrix can\\'t be a zero matrix\\n \\nConstraints:\\n`\\nm == mat.length\\n\\nn == mat[0].length\\n\\n1 <= m <= 3\\n\\n1 <= n <= 3\\n`\\n\\nmat[i][j] is 0 or 1."
                    },
                    {
                        "username": "charonme",
                        "content": "Answer 1) the index at (1,1) is NOT a neighbor of index (0,0), only indexes (-1,0), (1,0), (0,-1) and (0,1) are. (1,1) is diagonally from (0,0), so it's not a neighbor of (0,0).\nAnswer 2) because even when you try all the flipping permutations you will not get a zero matrix. Their given \"explanation\" is wrong and doesn't make sense."
                    }
                ]
            },
            {
                "id": 1575098,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "\"A pair of cells are called neighbors if they share one edge.\"\\nWhat a horrible way to describe things! What \"edge\"? Confused the hell out of me and drove me into write flip routines that flip the entire first and last rows and columns."
                    },
                    {
                        "username": "joanromano",
                        "content": "It would be good for the next time to check all your parsers work properly before the context. Literally had almost one hour left in the contest with only this question left and couldn\\'t even attempt it, really frustrating experience\\n\\n![image](https://assets.leetcode.com/users/joanromano/image_1575777871.png)\\n"
                    },
                    {
                        "username": "UtpalMat",
                        "content": "Hi -\\n\\nFrom instructions: \\n\\n**Question 1)**\\nWhy does flipping this matrix require 3 steps? The index at (1,1) is a neighbor of index (0,0) - so it should be only one step? \\n\\nOr are we looking at 3 neighbors, so 3 steps?\\n\\nInput: `mat = [[0,0],[0,1]]`\\nOutput: 3\\nExplanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\\n\\nAlso -\\n\\n**Question 2)**\\n\\nWhy cant this matrix be flipped? \\n\\nInput: mat = `[[1,0,0],[1,0,0]]`\\nOutput: -1\\nExplanation: Given matrix can\\'t be a zero matrix\\n \\nConstraints:\\n`\\nm == mat.length\\n\\nn == mat[0].length\\n\\n1 <= m <= 3\\n\\n1 <= n <= 3\\n`\\n\\nmat[i][j] is 0 or 1."
                    },
                    {
                        "username": "charonme",
                        "content": "Answer 1) the index at (1,1) is NOT a neighbor of index (0,0), only indexes (-1,0), (1,0), (0,-1) and (0,1) are. (1,1) is diagonally from (0,0), so it's not a neighbor of (0,0).\nAnswer 2) because even when you try all the flipping permutations you will not get a zero matrix. Their given \"explanation\" is wrong and doesn't make sense."
                    }
                ]
            }
        ]
    }
]