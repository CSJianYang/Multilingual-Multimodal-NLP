[
    {
        "title": "Sum of Numbers With Units Digit K",
        "question_content": "Given two integers num and k, consider a set of positive integers with the following properties:\n\n\tThe units digit of each integer is k.\n\tThe sum of the integers is num.\n\nReturn the minimum possible size of such a set, or -1 if no such set exists.\nNote:\n\n\tThe set can contain multiple instances of the same integer, and the sum of an empty set is considered 0.\n\tThe units digit of a number is the rightmost digit of the number.\n\n&nbsp;\nExample 1:\n\nInput: num = 58, k = 9\nOutput: 2\nExplanation:\nOne valid set is [9,49], as the sum is 58 and each integer has a units digit of 9.\nAnother valid set is [19,39].\nIt can be shown that 2 is the minimum possible size of a valid set.\n\nExample 2:\n\nInput: num = 37, k = 2\nOutput: -1\nExplanation: It is not possible to obtain a sum of 37 using only integers that have a units digit of 2.\n\nExample 3:\n\nInput: num = 0, k = 7\nOutput: 0\nExplanation: The sum of an empty set is considered 0.\n\n&nbsp;\nConstraints:\n\n\t0 <= num <= 3000\n\t0 <= k <= 9",
        "solutions": [
            {
                "id": 2168211,
                "title": "c-short-and-easy-with-math",
                "content": "Assume the size of the set is `n`, and the numbers in the set are A1, A2,..., An\\n```\\nA1 + A2 + ... + An = sum\\n```\\n\\nAll numbers must have k as the unit digit\\nSo `A1 + A2 + ... + An = n*k + 10*(a1 + a2 + .. + an) = sum`\\n\\nWhich `(a1 + a2 + .. + an)` can be any number.\\n\\nFor example: \\n`sum = 58, k = 9` => we have `n*k = 2*9 = 18`, and `10*(a1 + a2) = 58 - 18 = 40`. So `a1 + a2 = 4`\\n\\nJust find the minimum number satisfying the condition `(n*k)%10==sum%10`, because `10*(a1 + a2 + .. + an)%10` allways equal to `0`\\n\\n```C++\\nclass Solution {\\npublic:\\n    int minimumNumbers(int sum, int k) {\\n        if (sum == 0) return 0;\\n        for (int i = 1; i <= 10; ++i)\\n            if ((i * k) % 10 == sum % 10 && i * k <= sum) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nA1 + A2 + ... + An = sum\\n```\n```C++\\nclass Solution {\\npublic:\\n    int minimumNumbers(int sum, int k) {\\n        if (sum == 0) return 0;\\n        for (int i = 1; i <= 10; ++i)\\n            if ((i * k) % 10 == sum % 10 && i * k <= sum) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168185,
                "title": "coin-change-variation-infinite-supply-dp-pattern-cpp",
                "content": "**DP Pattern**\\n * DP on Subsequence / infinite supply problem\\n* this given question is just a variation of coin change problem (https://leetcode.com/problems/coin-change/)\\n     since question says\\n```\\nNote:\\nThe set can contain multiple instances of the same integer, and the sum of an empty set is considered 0.\\n The units digit of a number is the rightmost digit of the number.\\n```\\n    \\n```\\nclass Solution {\\npublic:\\n   \\n    //same code as that of coin change\\n    int coinChange(vector<int>& coins, int amount) {\\n        int Max = amount + 1;\\n        vector<int> dp(amount + 1, INT_MAX);\\n        dp[0] = 0;\\n        for (int i = 0; i <= amount; i++) {\\n            for (int j = 0; j < coins.size(); j++) {\\n                if (coins[j] <= i && dp[i-coins[j]] !=INT_MAX) {\\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\\n                }\\n            }\\n        }\\n        return dp[amount] == INT_MAX ? -1 : dp[amount];\\n    }\\n \\n    \\n    \\n    int minimumNumbers(int num, int k) {\\n    vector<int>res;\\n    for (int i = 0; i <= num; i++){\\n        if (i % 10 == k)\\n           res.push_back(i);\\n        }\\n       return coinChange(res, num);\\n\\n       \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nNote:\\nThe set can contain multiple instances of the same integer, and the sum of an empty set is considered 0.\\n The units digit of a number is the rightmost digit of the number.\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    //same code as that of coin change\\n    int coinChange(vector<int>& coins, int amount) {\\n        int Max = amount + 1;\\n        vector<int> dp(amount + 1, INT_MAX);\\n        dp[0] = 0;\\n        for (int i = 0; i <= amount; i++) {\\n            for (int j = 0; j < coins.size(); j++) {\\n                if (coins[j] <= i && dp[i-coins[j]] !=INT_MAX) {\\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\\n                }\\n            }\\n        }\\n        return dp[amount] == INT_MAX ? -1 : dp[amount];\\n    }\\n \\n    \\n    \\n    int minimumNumbers(int num, int k) {\\n    vector<int>res;\\n    for (int i = 0; i <= num; i++){\\n        if (i % 10 == k)\\n           res.push_back(i);\\n        }\\n       return coinChange(res, num);\\n\\n       \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168323,
                "title": "java-c-python-enumerate-from-1-to-10",
                "content": "\\n# **Explanation**\\nif `num == 0`, then empty set valid, return 0.\\n\\nThen we enumerate the size of set from 1 to 10 and check the conditions:\\n\\n1. The units digit of each integer is k.\\n2. The sum of the integers is num.\\n\\nThese two condistion equals to\\n1. `size * k <= num`\\n2. `size * k % 10 == num % 10`\\n\\nReturn the minimum valid size.\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        for (int i = 1; i * k <= num && i <= 10; ++i)\\n            if (k * i % 10 == num % 10)\\n                return i;\\n        return -1;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        for (int i = 1; i * k <= num && i <= 10; ++i)\\n            if (k * i % 10 == num % 10)\\n                return i;\\n        return -1;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumNumbers(self, num, k):\\n        if num == 0: return 0\\n        for i in range(1, 11):\\n            if k * i % 10 == num % 10 and i * k <= num:\\n                return i\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        for (int i = 1; i * k <= num && i <= 10; ++i)\\n            if (k * i % 10 == num % 10)\\n                return i;\\n        return -1;\\n    }\\n```\n```cpp\\n    int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        for (int i = 1; i * k <= num && i <= 10; ++i)\\n            if (k * i % 10 == num % 10)\\n                return i;\\n        return -1;\\n    }\\n```\n```py\\n    def minimumNumbers(self, num, k):\\n        if num == 0: return 0\\n        for i in range(1, 11):\\n            if k * i % 10 == num % 10 and i * k <= num:\\n                return i\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2168113,
                "title": "java-easy-to-understand",
                "content": "**Original  Thought**\\n1. num = 0, k >= 0 -> Since the target sum itself is 0, the set size is 0\\n2. num >= 0, k = 0\\n\\t2.1 If num is a multiple of 10, it can be done using num itself (set size = 1)\\n\\t2.2 If num is not a multiple of 10, it is not possible, so -1\\n3. For every other case, simply multiply the value k with increasing set size(i) and look for matching units\\' digit (%10)\\n4. -1 If not returned already.\\n\\n```\\nclass Solution\\n{\\n    public int minimumNumbers(int num, int k)\\n    {\\n        if(num == 0)\\n            return 0;\\n        if(k == 0)\\n            if(num % 10 == 0) //E.g. 20,1590,3000\\n                return 1;\\n            else\\n                return -1;\\n        for(int i = 1; i <= num/k; i++) // Start with set size 1 and look for set having unit\\'s digit equal to that of num\\n            if(num % 10 == ((i*k)%10)) // Look for equal unit\\'s digit\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```\\n   \\n**Shorter code**\\n\\nSince the unit\\'s digit starts repeating after 10 iterations, it can be limited to 10. Further, the k == 0 conditionals can be removed by modifying the loop using multiplication instead of division\\n```\\nclass Solution\\n{\\n    public int minimumNumbers(int num, int k)\\n    {\\n        if(num == 0)\\n            return 0;\\n        for(int i = 1; i*k <= num && i <= 10; i++) // Start with set size 1 and look for set having unit\\'s digit equal to that of num\\n            if(num % 10 == ((i*k)%10)) // Look for equal unit\\'s digit\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int minimumNumbers(int num, int k)\\n    {\\n        if(num == 0)\\n            return 0;\\n        if(k == 0)\\n            if(num % 10 == 0) //E.g. 20,1590,3000\\n                return 1;\\n            else\\n                return -1;\\n        for(int i = 1; i <= num/k; i++) // Start with set size 1 and look for set having unit\\'s digit equal to that of num\\n            if(num % 10 == ((i*k)%10)) // Look for equal unit\\'s digit\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int minimumNumbers(int num, int k)\\n    {\\n        if(num == 0)\\n            return 0;\\n        for(int i = 1; i*k <= num && i <= 10; i++) // Start with set size 1 and look for set having unit\\'s digit equal to that of num\\n            if(num % 10 == ((i*k)%10)) // Look for equal unit\\'s digit\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168437,
                "title": "o-1",
                "content": "Another deceptive problem. \\n\\nSay we have `n` numbers in a set. Then, that set is good if:\\n- `n * k` <= `num`\\n- `num - n * k` has zero as a unit digit.\\n\\nNote that `n` will not exceed `10` (the worst case is when `k % 10  == 1` and `num % 10 == 10`.\\n\\nSo, we increment `n` starting from `1`, and check if a set is good. We need to watch for a corner case when `num == 0` (always return zero).\\n\\nThe corner case when `k == 0` is handled by the existing code, since we limit the number iterations.\\n\\n**C++**\\n```cpp\\nint minimumNumbers(int num, int k) {\\n    if (num == 0)\\n        return 0;\\n    for (int n = 1; n <= 10 && n * k <= num; ++n)\\n        if ((num - n * k) % 10 == 0)\\n            return n;\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimumNumbers(int num, int k) {\\n    if (num == 0)\\n        return 0;\\n    for (int n = 1; n <= 10 && n * k <= num; ++n)\\n        if ((num - n * k) % 10 == 0)\\n            return n;\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168430,
                "title": "c-easy-approach-3-liner",
                "content": "It\\u2019s a simple approach , \\nIn every set we take multiple of k like if k value is 5 \\nWe will take 5,15,25,35,45,55 like this and after this we will check every last number of temp sum and given sum . \\n\\nthe loop is running till 10 only because :\\nif num is 0 we will return 0\\n9 * 1 = 9\\n9 * 11 = 99\\n9 * 2 = 18\\n9 * 12 = 108\\n9 * 3 = 27\\n9 * 13 = 117\\nand so on ..\\n\\n```\\nclass Solution { \\npublic: \\n    int minimumNumbers(int N, int k) { \\n        if(N==0) return 0; \\n        for(int i=1;i<=10;i++){ \\n            int res=i*k; \\n            if(res%10==N%10 and res<=N){ \\n                return i; \\n            } \\n        } \\n        return -1; \\n    } \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution { \\npublic: \\n    int minimumNumbers(int N, int k) { \\n        if(N==0) return 0; \\n        for(int i=1;i<=10;i++){ \\n            int res=i*k; \\n            if(res%10==N%10 and res<=N){ \\n                return i; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2172088,
                "title": "o-1-solution-using-a-simple-math-trick",
                "content": "**Sum of Numbers with units Digit k**\\n\\nSo, initially one might think thats its actually a dynamic programming question but guess what it can be optimised further. \\n\\n![image](https://assets.leetcode.com/users/images/c7e11785-f802-4c62-9db6-a203ed7768ac_1655671885.1312203.jpeg)\\n\\n\\nLet\\'s get straight to the approach, the catch here is as follows:\\n\\n1. Looking at 9\\'s table closely, You realise that it\\'s multiples cover every unit digit from 0 to 9.\\n2. The 2\\'s table covers unit digits 2, 4, 6, 8, 0.\\n3. 3\\'s multiples cover these unit digit: 1, 2, 3, 4, 5, 6, 7, 8, 9, 0. \\n4. 5\\'s multiples only cover 0 and 5.\\n\\n\\n* This makes it very clear that we **can not** generate numbers with unit digit 1, 2, 3, 4, 6, 7, 8, 9 using unit digit 5. \\n* Suppose the number is , 55 clearly **2\\'s set** of unit digit **does\\'t cover 5** so we **can\\'t generate** that.\\n* Incase k=0, which can only generate strings with 0. i.e. 10, 20, 30.\\n\\n\\n![image](https://assets.leetcode.com/users/images/1466df1e-b8fe-4a92-98ed-9fa0683afabe_1656053627.315123.jpeg)\\n\\n\\n**So, the multiples of every unit digit can \"Generate only a set of unit digits.\"**  Let\\'s take few examples to see how that helps :\\n\\n**n=91, k=9**\\n*We know that 9 has 1 in it\\'s set, so 91 can be generated using this, Also that 1 can be unit digit if and only if we multiply k by 9 (see the image), let\\'s start with 19 and add 9 eight times to make it 91 and the answer is 1+8=9.*\\n\\n\\n**n=17, k=9**\\n*Now, 9 has 7 in it\\'s set but it can\\'t be generated because 17<27. In such cases, return -1.*\\n*Similiary, 9 can\\'t generate 11 but can generate the all numbers with unit digit 1 and greater than equal to 81.* \\n\\n**n=17, k=2**\\n*Clearly, 2 doesn\\'t have 7 as a unit digit in its set. In such cases, return -1.*\\n\\n**n=107, k=9**\\n*Unit digit, 7 can be generated with 9,  by adding 9 three times as 9, 9 and 89.*\\n\\n**This gives you the clue that generating minimum set for any number as generating that unit digit for n%10.**\\n\\nRefer the image and try to generate few numbers. And you are all set to slay the solution.\\nCode is as simple just use a loop from 1 to 10 to generate k\\'s table. At any point if unit digit matches, return i if number is greater tham or equal to k*i else return -1.\\n\\nHave a look at it\\'s code too:\\n\\n```\\nclass Solution {\\n    public int minimumNumbers(int nums, int k) {\\n\\t//Base Case Check\\n        if(nums==0) return 0;\\n        int x=nums%10;\\n     \\n        for(int i=1; i<=10; i++){\\n\\t\\t//check if the unit digits are equal for any case\\n            if((k*i)%10==x) {\\n\\t\\t//if yes,  check if n>k*i and return accordingly\\n                if(nums>=k*i) return i;\\n                else return -1;\\n            }\\n        }\\n       //in case nothing matches\\n        return -1;       \\n    }\\n}\\n```\\n\\nThe loop runs from 1 to 10, thus the time complexity is O(1). Drop your doubts in the comments.\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int nums, int k) {\\n\\t//Base Case Check\\n        if(nums==0) return 0;\\n        int x=nums%10;\\n     \\n        for(int i=1; i<=10; i++){\\n\\t\\t//check if the unit digits are equal for any case\\n            if((k*i)%10==x) {\\n\\t\\t//if yes,  check if n>k*i and return accordingly\\n                if(nums>=k*i) return i;\\n                else return -1;\\n            }\\n        }\\n       //in case nothing matches\\n        return -1;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168448,
                "title": "c-o-1-time-and-space",
                "content": "```\\nint minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        for(int i=1; i<=10; i++){\\n            if(i*k > num) break;\\n            if((i*k) % 10 == num % 10) return i;\\n        }\\n        return -1;\\n    }\\n```\\nPlease upvote if you like the solution. :)",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nint minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        for(int i=1; i<=10; i++){\\n            if(i*k > num) break;\\n            if((i*k) % 10 == num % 10) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2170895,
                "title": "math-sieve-of-erathosthenes-c-different-approach",
                "content": "The idea is to use something like sieve of Erathosthenes to get the count of the number of integers that sum up to `num`. \\n\\n1. First, create an array `cntIntegers` of max size `num+1` to store the count of integers that sum up to `num`. i.e., `countIntegers[i]` represents the number of integers that sum up to `i`. \\n\\n2. Start with `val` = `k` and increment `val` by 10 each time to get the next number whose unit digit is `k`. End the loop once `val` becomes greater than `num`.\\n\\n3. Every time initialize the `cntIntegers[val]` to 1 since the no. of integers that sum up to `val` is one and that\\'s the number itself. We are taking the `min` since sometimes `cntIntegers[val]` can have a greater value because of the `val` considered before.\\n\\n\\tEx: For `k`=2, `num`=12; For the first time when `val`=`2`, `cntIntegers[12]` would be `6` since six `2` would sum up to `12`. But, in the next iteration when `12` is considered, `cntIntegers[12]` would be `1` since one `12` is enough to make a sum of 12.\\n\\n4. Now, for every `j` starting from `1`, if `cntIntegers[j]` is `INT_MAX`, indicates that we couldnt find any integers that sum up to `j`. So, we skip.\\nElse, the value for  `j+val` would be: `number of integers that sum up to j+val` = 1 + `number of integers that sum up to j`\\n\\n5. `cntIntegers[num]` indicates the number of integers that summed up to `num` and is the final answer. If `cntIntegers[num]` is `INT_MAX` indicates that we couldnt find the set of integers that sum up to `num`\\n\\n```\\n int minimumNumbers(int num, int k) {\\n        if(num == 0)\\n            return 0;\\n        \\n        int val = k;\\n        vector<int> cntIntegers(num+1, INT_MAX);\\n        while(val <= num){\\n            cntIntegers[val] = min(cntIntegers[val], 1);\\n            for(int j=1; j+val<=num; ++j){\\n                if(cntIntegers[j] != INT_MAX)\\n                    cntIntegers[j+val] = 1+cntIntegers[j];\\n            }\\n            val += 10;\\n        }\\n        return cntIntegers[num] == INT_MAX ? -1 : cntIntegers[num];\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n int minimumNumbers(int num, int k) {\\n        if(num == 0)\\n            return 0;\\n        \\n        int val = k;\\n        vector<int> cntIntegers(num+1, INT_MAX);\\n        while(val <= num){\\n            cntIntegers[val] = min(cntIntegers[val], 1);\\n            for(int j=1; j+val<=num; ++j){\\n                if(cntIntegers[j] != INT_MAX)\\n                    cntIntegers[j+val] = 1+cntIntegers[j];\\n            }\\n            val += 10;\\n        }\\n        return cntIntegers[num] == INT_MAX ? -1 : cntIntegers[num];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168121,
                "title": "very-easy-greedy-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n        if(num==0)\\n            return 0;\\n        \\n        if(k==0)\\n        {\\n            if(num%10==0)\\n            {\\n               return 1;\\n            }\\n            else\\n                return -1;\\n                \\n        }\\n            \\n        \\n        int p =num;\\n        vector<int>ans;\\n        while(p>0)\\n        {\\n            if(p%10==k)\\n            {\\n                return ans.size()+1;\\n            }\\n            else\\n            {\\n                ans.push_back(k);\\n                p-=k;\\n            }\\n        }\\n        \\n        if(p==0)\\n        {\\n            return ans.size();\\n        }\\n        else\\n            return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n        if(num==0)\\n            return 0;\\n        \\n        if(k==0)\\n        {\\n            if(num%10==0)\\n            {\\n               return 1;\\n            }\\n            else\\n                return -1;\\n                \\n        }\\n            \\n        \\n        int p =num;\\n        vector<int>ans;\\n        while(p>0)\\n        {\\n            if(p%10==k)\\n            {\\n                return ans.size()+1;\\n            }\\n            else\\n            {\\n                ans.push_back(k);\\n                p-=k;\\n            }\\n        }\\n        \\n        if(p==0)\\n        {\\n            return ans.size();\\n        }\\n        else\\n            return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168461,
                "title": "python-math-explained",
                "content": "Say the `n` numbers are `10 * a_1 + k, 10 * a_2 + k, ... , 10 * a_n + k`. Then their sum is\\n```\\n\\tnum = 10 * (a_1 + a_2 + ... + a_n) + n * k\\n```\\nthus\\n```\\n\\tnum - n * k = 10 * (a_1 + a_2 + ... + a_n)\\n```\\nso we need to find the smallest `n` for which `(num - n * k) % 10 == 0`.\\n* **Update:** Proof that such `a_i`\\'s exist iff `(num - n * k) % 10 == 0` in the comments section.\\n\\n&#8718;\\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        \\n        if k == 0:\\n            return 1 if num % 10 == 0 else -1\\n        \\n        for n in range(1, min(num // k, 10) + 1):\\n            if (num - n * k) % 10 == 0:\\n                return n\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n\\tnum = 10 * (a_1 + a_2 + ... + a_n) + n * k\\n```\n```\\n\\tnum - n * k = 10 * (a_1 + a_2 + ... + a_n)\\n```\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        \\n        if k == 0:\\n            return 1 if num % 10 == 0 else -1\\n        \\n        for n in range(1, min(num // k, 10) + 1):\\n            if (num - n * k) % 10 == 0:\\n                return n\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168151,
                "title": "linear-dp-c",
                "content": "This problem can be approached in a bottom up manner starting from 1 to n . \\nTime Complexity : O(n*n)\\nSpace Complexity : O(n)\\n```\\n  vector<int> vec(num+1,-1);\\n        if(num==0)return 0;\\n        if(k == 0)vec[0] = 0; \\n        for(int i =1;i<=num;i++){\\n            if(i%10==k){\\n                vec[i] = 1;\\n                continue;\\n            }\\n            int s = k;\\n            int mini = INT_MAX-1000; // so that int don\\'t overflow when we do +1\\n            while(i-s>=0){\\n            \\n                if(vec[i-s]!=-1){\\n                      int a = vec[i-s]+1;   \\n                     mini = min(mini,a);\\n                }   \\n                s+=10;\\n            }\\n            vec[i] = mini;\\n             \\n        }\\n        \\n        if(vec[num]>num)return -1;\\n        \\n        return vec[num];\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<int> vec(num+1,-1);\\n        if(num==0)return 0;\\n        if(k == 0)vec[0] = 0; \\n        for(int i =1;i<=num;i++){\\n            if(i%10==k){\\n                vec[i] = 1;\\n                continue;\\n            }\\n            int s = k;\\n            int mini = INT_MAX-1000; // so that int don\\'t overflow when we do +1\\n            while(i-s>=0){\\n            \\n                if(vec[i-s]!=-1){\\n                      int a = vec[i-s]+1;   \\n                     mini = min(mini,a);\\n                }   \\n                s+=10;\\n            }\\n            vec[i] = mini;\\n             \\n        }\\n        \\n        if(vec[num]>num)return -1;\\n        \\n        return vec[num];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2170204,
                "title": "c-shortest-east-to-understand-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n       if(num==0) return 0;\\n        for(int i=1;i<=100;i++)\\n            if(num-k*i>=0 and (num-k*i)%10==0) return i;\\n        return -1;\\n    }\\n};\\n```\\n**Please Upvote the solution.If it was helpful.**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n       if(num==0) return 0;\\n        for(int i=1;i<=100;i++)\\n            if(num-k*i>=0 and (num-k*i)%10==0) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168743,
                "title": "c-use-maths-logic-simple-and-efficient-solution",
                "content": "**TC: O(N/k)\\nSC: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        if(num==0) return 0; //if num==0 so we need 0 integer in set\\n        if(k==0) \\n        {\\n            return num%10==0 ? 1 : -1; //for cases like num=1000, k=0\\n        }\\n        \\n        for(int i=1; i*k<=num; i++) //we want interger less than num\\n            if((num - i*k)%10==0)  //when rightmost digit of num and i*k is same then i will be our ans\\n                return i;\\n        \\n        return -1;\\n        \\n    }\\n};\\n```\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        if(num==0) return 0; //if num==0 so we need 0 integer in set\\n        if(k==0) \\n        {\\n            return num%10==0 ? 1 : -1; //for cases like num=1000, k=0\\n        }\\n        \\n        for(int i=1; i*k<=num; i++) //we want interger less than num\\n            if((num - i*k)%10==0)  //when rightmost digit of num and i*k is same then i will be our ans\\n                return i;\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168291,
                "title": "multiplication-table-simple-greedy",
                "content": "## Idea \\n\\n- If a num\\'s unit digit is in the multiplication table of k \\n- Then it will always be possible, and the ans will the its multiplicative inverse \\n- Barring some edge cases\\n\\n## Example \\n\\n- 7s multiplication table - [ 7 14 21 28 35 ........] \\n- Now if we are to find num = 24 and  k = 7 \\n- we find 4 in the unit digit of 14 ie 7X2 = 14 \\n- So, 24 can always be formed by two nums who have 7 at unit digits \\n- by 7 + 7 + 10 we can form 24, we might as well append 10 to one of the 7 and get the ans \\n- 17 +7 == 24 \\n\\n## Edge Cases \\n\\n- if num < k \\n- if k*(idx) > k ( eg num = 4, k = 7 , then although 14\\'s unit digit is 4 but 14 > 4 )  \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if( !num )\\n            return 0;\\n        if( (k%2 == 0 and num%2 != 0) or num < k )\\n            return -1;\\n             \\n        vector <int> possiblity;        \\n        for( int i = 1 ; i <= 10 ; i++){\\n            int currNum = k*i;\\n            possiblity.push_back(currNum%10);\\n        }\\n        \\n        int ans = find(possiblity.begin(), possiblity.end(), num%10) - possiblity.begin();\\n        if( ans == possiblity.size() )\\n            return -1;\\n        else\\n            ans += 1;\\n        \\n        if( k*ans > num )\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if( !num )\\n            return 0;\\n        if( (k%2 == 0 and num%2 != 0) or num < k )\\n            return -1;\\n             \\n        vector <int> possiblity;        \\n        for( int i = 1 ; i <= 10 ; i++){\\n            int currNum = k*i;\\n            possiblity.push_back(currNum%10);\\n        }\\n        \\n        int ans = find(possiblity.begin(), possiblity.end(), num%10) - possiblity.begin();\\n        if( ans == possiblity.size() )\\n            return -1;\\n        else\\n            ans += 1;\\n        \\n        if( k*ans > num )\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168233,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0){\\n            return 0;\\n        }\\n        if(k==0){\\n            if(num%10==0){\\n                return 1;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        if(num<=9){\\n            if(num%k!=0){\\n                return -1; //if num is divisble by k then we simply return num/k;\\n            }\\n            else{\\n                return num/k;\\n            }\\n        }\\n        else{\\n            if((num%10)==k){\\n                return 1;    //Here  we checking whether k is equal or not equal to Unit digit of integer\\n            }\\n            int s=num%10;\\n            if(s%k==0 &&s!=0){\\n                return s/k;\\n            }\\n            s=s+10;\\n            if(s%k==0 ){\\n                return s/k;\\n            }\\n            int z=num/10;z--;\\n            while(z>=0){\\n                if(s%k==0 ){\\n                    return s/k;\\n                }\\n                else{\\n                    s=s+10;\\n                }\\n                z--;\\n            }\\n            return -1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0){\\n            return 0;\\n        }\\n        if(k==0){\\n            if(num%10==0){\\n                return 1;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        if(num<=9){\\n            if(num%k!=0){\\n                return -1; //if num is divisble by k then we simply return num/k;\\n            }\\n            else{\\n                return num/k;\\n            }\\n        }\\n        else{\\n            if((num%10)==k){\\n                return 1;    //Here  we checking whether k is equal or not equal to Unit digit of integer\\n            }\\n            int s=num%10;\\n            if(s%k==0 &&s!=0){\\n                return s/k;\\n            }\\n            s=s+10;\\n            if(s%k==0 ){\\n                return s/k;\\n            }\\n            int z=num/10;z--;\\n            while(z>=0){\\n                if(s%k==0 ){\\n                    return s/k;\\n                }\\n                else{\\n                    s=s+10;\\n                }\\n                z--;\\n            }\\n            return -1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170389,
                "title": "similar-to-coin-change-infinite-supply",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     int yesno(int amount, int idx, vector<int> &coins, vector<vector<int>> &dp){\\n        if(amount < 0)\\n            return INT_MAX;\\n        \\n        if(amount == 0)\\n            return 0;\\n        \\n        if(idx == coins.size())\\n            return INT_MAX;\\n        \\n        if(dp[amount][idx] != -1)\\n            return dp[amount][idx];\\n        \\n        int yes = yesno(amount - coins[idx],idx,coins,dp);\\n         \\n        if(yes != INT_MAX)\\n            yes++;\\n         \\n        int no = yesno(amount,idx + 1,coins,dp); \\n        \\n        return dp[amount][idx] = min(yes,no);\\n        \\n    }\\n    \\n    \\n    int minimumNumbers(int num, int k) {\\n        \\n        //empty subset\\n        if(num == 0)return 0;\\n        \\n        if(k == 0){\\n            if(num % 10 == k)\\n            return 1;\\n            \\n            else\\n                return -1;\\n        }\\n        \\n        \\n        vector<int> arr;\\n        \\n        for(int i = k;i<=3000;i+=10){\\n            arr.push_back(i);\\n        }\\n        \\n        vector<vector<int>> dp(num + 1,vector<int>(arr.size() + 1 , - 1));\\n        \\n        int ans = yesno(num,0,arr,dp);\\n        \\n        if(ans == INT_MAX)\\n            return -1;\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     int yesno(int amount, int idx, vector<int> &coins, vector<vector<int>> &dp){\\n        if(amount < 0)\\n            return INT_MAX;\\n        \\n        if(amount == 0)\\n            return 0;\\n        \\n        if(idx == coins.size())\\n            return INT_MAX;\\n        \\n        if(dp[amount][idx] != -1)\\n            return dp[amount][idx];\\n        \\n        int yes = yesno(amount - coins[idx],idx,coins,dp);\\n         \\n        if(yes != INT_MAX)\\n            yes++;\\n         \\n        int no = yesno(amount,idx + 1,coins,dp); \\n        \\n        return dp[amount][idx] = min(yes,no);\\n        \\n    }\\n    \\n    \\n    int minimumNumbers(int num, int k) {\\n        \\n        //empty subset\\n        if(num == 0)return 0;\\n        \\n        if(k == 0){\\n            if(num % 10 == k)\\n            return 1;\\n            \\n            else\\n                return -1;\\n        }\\n        \\n        \\n        vector<int> arr;\\n        \\n        for(int i = k;i<=3000;i+=10){\\n            arr.push_back(i);\\n        }\\n        \\n        vector<vector<int>> dp(num + 1,vector<int>(arr.size() + 1 , - 1));\\n        \\n        int ans = yesno(num,0,arr,dp);\\n        \\n        if(ans == INT_MAX)\\n            return -1;\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168478,
                "title": "c-simple-logic-easy-to-understand",
                "content": "**Please Upvote If You like It \\uD83D\\uDE0A**\\n\\n```\\nAssume the size of the set is n, and the numbers in the set are A1, A2,..., An\\n\\nA1 + A2 + ... + An = sum\\n\\nAll numbers must have k as the unit digit\\nSo A1 + A2 + ... + An = n*k + 10*(a1 + a2 + .. + an)\\n\\nFor example:\\nsum = 58, k = 9 \\nwe have n*k = 2*9 = 18 and 10*(a1 + a2) = 58 - 18 = 40. So a1 + a2 = 4\\n\\nif you see then you can observe that modulo of (n*k)=(18%10) and modulo of num(58%10) are same\\n\\nSo this the condition where we can say this is our ans\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        // if given num is zero then there is no such set so return 0\\n        if (num == 0) return 0;\\n        \\n        for (int i = 1; i <= num; ++i)\\n        {\\n            // unit digit should be k so multiply with k \\n            if ((i * k) % 10 == num % 10 && i * k <= num) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nAssume the size of the set is n, and the numbers in the set are A1, A2,..., An\\n\\nA1 + A2 + ... + An = sum\\n\\nAll numbers must have k as the unit digit\\nSo A1 + A2 + ... + An = n*k + 10*(a1 + a2 + .. + an)\\n\\nFor example:\\nsum = 58, k = 9 \\nwe have n*k = 2*9 = 18 and 10*(a1 + a2) = 58 - 18 = 40. So a1 + a2 = 4\\n\\nif you see then you can observe that modulo of (n*k)=(18%10) and modulo of num(58%10) are same\\n\\nSo this the condition where we can say this is our ans\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        // if given num is zero then there is no such set so return 0\\n        if (num == 0) return 0;\\n        \\n        for (int i = 1; i <= num; ++i)\\n        {\\n            // unit digit should be k so multiply with k \\n            if ((i * k) % 10 == num % 10 && i * k <= num) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168387,
                "title": "c-solution-dynamic-programming-unbounded-knapsack-coin-change",
                "content": "It is a problem similar to the coin change problem ( unbounded knapsack).\\n\\n```\\n int minimumNumbers(int num, int k) {\\n        vector<int> ans;\\n        if( num==0) return 0;\\n        if( num==k) return 1;\\n        if( num<k) return -1;\\n        for( int i=k; i<=num ; i=i+10){\\n            if( i!=0)\\n                ans.emplace_back(i);\\n        }\\n        \\n        if (ans.size()==0) return -1;\\n        int n = ans.size();\\n        int dp[n+1][num+1];\\n        \\n        if( n==0) return 0;\\n        for(int i=0; i<n+1;i++){\\n            for( int j=0; j<num+1; j++){\\n                if( j==0) dp[i][j]=0;\\n                if( i==0) dp[i][j]= INT_MAX;\\n            }\\n        }\\n        for(int j=1 ; j<num+1; j++){\\n            if( j%ans[0]==0) dp[1][j] = j/ans[0];\\n            else\\n                dp[1][j] = INT_MAX-1;\\n        }\\n        \\n        for( int i=2; i<n+1; i++){\\n            for( int j=1; j<num+1; j++){\\n                if( ans[i-1]<=j){\\n                    dp[i][j] = min(1+ dp[i][j-ans[i-1]], dp[i-1][j]);\\n                    \\n                }\\n                else{\\n                    dp[i][j]= dp[i-1][j];\\n                }\\n            }\\n        }\\n        int ans1= dp[n][num];\\n        if(ans1 == INT_MAX-1) return -1;\\n        return ans1;\\n    }\\n```\\n\\nplease upvote if you understood the approach ;}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int minimumNumbers(int num, int k) {\\n        vector<int> ans;\\n        if( num==0) return 0;\\n        if( num==k) return 1;\\n        if( num<k) return -1;\\n        for( int i=k; i<=num ; i=i+10){\\n            if( i!=0)\\n                ans.emplace_back(i);\\n        }\\n        \\n        if (ans.size()==0) return -1;\\n        int n = ans.size();\\n        int dp[n+1][num+1];\\n        \\n        if( n==0) return 0;\\n        for(int i=0; i<n+1;i++){\\n            for( int j=0; j<num+1; j++){\\n                if( j==0) dp[i][j]=0;\\n                if( i==0) dp[i][j]= INT_MAX;\\n            }\\n        }\\n        for(int j=1 ; j<num+1; j++){\\n            if( j%ans[0]==0) dp[1][j] = j/ans[0];\\n            else\\n                dp[1][j] = INT_MAX-1;\\n        }\\n        \\n        for( int i=2; i<n+1; i++){\\n            for( int j=1; j<num+1; j++){\\n                if( ans[i-1]<=j){\\n                    dp[i][j] = min(1+ dp[i][j-ans[i-1]], dp[i-1][j]);\\n                    \\n                }\\n                else{\\n                    dp[i][j]= dp[i-1][j];\\n                }\\n            }\\n        }\\n        int ans1= dp[n][num];\\n        if(ans1 == INT_MAX-1) return -1;\\n        return ans1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168164,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n        if(num==0) return 0;\\n        \\n        for(int i=1;i<=10;i++)\\n        {\\n            if((k*i)%10==num%10)\\n            {\\n                if(k*i<=num)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n        if(num==0) return 0;\\n        \\n        for(int i=1;i<=10;i++)\\n        {\\n            if((k*i)%10==num%10)\\n            {\\n                if(k*i<=num)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491545,
                "title": "c-o-1-space-o-1-time",
                "content": "```\\nint minimumNumbers(int num, int k) {\\n        \\n        if(num==0)\\n            return 0;\\n        bool flag=false;\\n        int i;\\n        for(i=1;i<=10;i++)\\n            if(k*i % 10 == num % 10 && i*k<=num)\\n            { flag=true; break; }\\n        \\n        if(!flag)return -1;\\n        return i;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minimumNumbers(int num, int k) {\\n        \\n        if(num==0)\\n            return 0;\\n        bool flag=false;\\n        int i;\\n        for(i=1;i<=10;i++)\\n            if(k*i % 10 == num % 10 && i*k<=num)\\n            { flag=true; break; }\\n        \\n        if(!flag)return -1;\\n        return i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191689,
                "title": "c-short-and-clean-code-complete-explanation",
                "content": "**Explanation:**\\nIf n numbers  with unit digit k gives a sum \\'sum\\', then it canbe represented as below:\\nA[n] =>   A1    +   A2    + ---- +    An     = sum\\n    \\n=>     (a1 * 10+k) + (a2 * 10+k) + ---- + (an * 10+k) = sum {a1,a2---,an canbe any integer}\\n    \\n=> (a1+a2+ ---- + an) * 10 + n * k = sum  [we need to return this size \\'n\\'] ------- Eqn1\\n    \\n**Observations:**\\n(sum-(n * k))==(a1+a2+ --- + an) * 10 -------[Rearranging Eqn1]\\nwhich means **(sum-(n * k))%10==0**\\nHence,  \\n**sum%10 == (n * k)%10**  ---condition\\nWe iterate the loop only 10 times because *after the 10 iterations unit place start repeating itself*\\nso, if we are not able to get the \\'condition\\' true in 10 iterations then return -1.\\n**example**: \\n* 9 * 1=9 ,9 * 11=99\\n* 14 * 3=42,14 * 13=182\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int sum, int k) {\\n        if(sum==0) return 0;\\n        for(int i = 1;i<=10;i++){\\n            if((i*k)%10==sum%10 && i*k<=sum) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nUpvote if this post is useful",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int sum, int k) {\\n        if(sum==0) return 0;\\n        for(int i = 1;i<=10;i++){\\n            if((i*k)%10==sum%10 && i*k<=sum) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174683,
                "title": "c-math-tc-o-1",
                "content": "**Explanation**\\n![image](https://assets.leetcode.com/users/images/5967a5e3-cb6a-433b-b2f1-02112d3b7fb1_1655731342.315466.jpeg)\\n\\n\\n\\n\\n```\\n int minimumNumbers(int num, int k)\\n   {\\n       if(num==0) return 0; // base case;\\n       \\n       for(int n=1;n<=10 && n*k<=num ;n++)  // n is number of elements in set\\n       {\\n           if((num-n*k)%10 == 0)   \\n           return n;\\n               \\n       }\\n       return -1;\\n   }\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n int minimumNumbers(int num, int k)\\n   {\\n       if(num==0) return 0; // base case;\\n       \\n       for(int n=1;n<=10 && n*k<=num ;n++)  // n is number of elements in set\\n       {\\n           if((num-n*k)%10 == 0)   \\n           return n;\\n               \\n       }\\n       return -1;\\n   }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168770,
                "title": "c-memoized-knapsack-0-1-225ms",
                "content": "**Explanation:**\\n* The problem gets reduced to 0/1 knapsack problem, being the limited choices of \\'unit\\' place digit numbers, which can be taken or not.\\n* Tricky concept here is that memoized variables chosen here are - `current sum` and `remaining target sum`. Otherwise memoization will not work properly.\\n\\n**Memoized Code**\\n```cpp\\nvector<int> nums;\\nvector<vector<int>> dp;\\n\\nint solve(int target, int num, int cnt = 0){\\n    if(target == 0) return cnt;\\n    if(num > target) return INT_MAX;\\n\\n    if(dp[num][target] != -1) return dp[num][target];\\n\\n    int take = INT_MAX, dontTake;\\n    if(num <= target){\\n        take = solve(target-num, num, cnt+1);\\n    }\\n\\n    dontTake = solve(target, num+10, cnt);\\n    return dp[num][target] = min(take, dontTake);\\n}\\n\\nint minimumNumbers(int num, int k) {\\n    if(num == 0 && k == 0) return 0;\\n    if(k == 0) \\n        return num%10 == k ? 1 : -1;\\n\\n    dp.resize(num+1, vector<int>(num+1, -1));\\n\\n    int res = solve(num, k);\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\\n\\n**Upvote if it helps :)**",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```cpp\\nvector<int> nums;\\nvector<vector<int>> dp;\\n\\nint solve(int target, int num, int cnt = 0){\\n    if(target == 0) return cnt;\\n    if(num > target) return INT_MAX;\\n\\n    if(dp[num][target] != -1) return dp[num][target];\\n\\n    int take = INT_MAX, dontTake;\\n    if(num <= target){\\n        take = solve(target-num, num, cnt+1);\\n    }\\n\\n    dontTake = solve(target, num+10, cnt);\\n    return dp[num][target] = min(take, dontTake);\\n}\\n\\nint minimumNumbers(int num, int k) {\\n    if(num == 0 && k == 0) return 0;\\n    if(k == 0) \\n        return num%10 == k ? 1 : -1;\\n\\n    dp.resize(num+1, vector<int>(num+1, -1));\\n\\n    int res = solve(num, k);\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168733,
                "title": "c-coin-change-problem-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n\\t\\n\\t\\t// Handeling the corner cases\\n\\t\\t\\n        if(num==0) return 0;\\n        if(k>num) return -1;\\n        int sum=k;\\n        if(k==0)\\n        {\\n            if(num%10==0) return 1;\\n            else return -1;\\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// Let\\'s create a vector temp of numbers that can be in the set like--\\n\\t\\t// for num=58 , k=9\\n\\t\\t// temp = [9,19,29,39,49]\\n\\t\\t\\n        vector<int>temp;\\n        while(sum<=num)\\n        {\\n            temp.push_back(sum) ;\\n            sum+=10;\\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// Now the problem becomes Coin Change Problem\\n\\t\\t// As here we are given a vector( temp) with some number \\n\\t\\t// and We have to find min no. of number(s) that make up to the given sum(here 58)\\n\\t\\t\\n        return coinChange(temp , num);\\n    }\\n\\t\\n    int coinChange(vector<int>& coins, int sum) {\\n        int n = coins.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++) dp[i][0]=0;\\n        for(int i=0;i<sum+1;i++) dp[0][i] = INT_MAX-1;\\n        for(int i=1;i<sum+1;i++)\\n        {\\n            if(i%coins[0]==0) dp[1][i] = i/coins[0];\\n            else dp[1][i] = INT_MAX-1;\\n        }\\n        \\n        for(int i=2;i<n+1;i++)\\n        {\\n            for(int j=1;j<sum+1;j++)\\n            {\\n                if(coins[i-1]<=j)\\n                    dp[i][j] = min(dp[i-1][j], 1+ dp[i][j-coins[i-1]]);\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        int value = dp[n][sum];\\n        if(value==INT_MAX || value==INT_MAX-1) return -1;\\n        else return value;\\n    }\\n};\\n```\\n// I couldn\\'t solve this during the contest  \\uD83D\\uDE14",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n\\t\\n\\t\\t// Handeling the corner cases\\n\\t\\t\\n        if(num==0) return 0;\\n        if(k>num) return -1;\\n        int sum=k;\\n        if(k==0)\\n        {\\n            if(num%10==0) return 1;\\n            else return -1;\\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// Let\\'s create a vector temp of numbers that can be in the set like--\\n\\t\\t// for num=58 , k=9\\n\\t\\t// temp = [9,19,29,39,49]\\n\\t\\t\\n        vector<int>temp;\\n        while(sum<=num)\\n        {\\n            temp.push_back(sum) ;\\n            sum+=10;\\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// Now the problem becomes Coin Change Problem\\n\\t\\t// As here we are given a vector( temp) with some number \\n\\t\\t// and We have to find min no. of number(s) that make up to the given sum(here 58)\\n\\t\\t\\n        return coinChange(temp , num);\\n    }\\n\\t\\n    int coinChange(vector<int>& coins, int sum) {\\n        int n = coins.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++) dp[i][0]=0;\\n        for(int i=0;i<sum+1;i++) dp[0][i] = INT_MAX-1;\\n        for(int i=1;i<sum+1;i++)\\n        {\\n            if(i%coins[0]==0) dp[1][i] = i/coins[0];\\n            else dp[1][i] = INT_MAX-1;\\n        }\\n        \\n        for(int i=2;i<n+1;i++)\\n        {\\n            for(int j=1;j<sum+1;j++)\\n            {\\n                if(coins[i-1]<=j)\\n                    dp[i][j] = min(dp[i-1][j], 1+ dp[i][j-coins[i-1]]);\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        int value = dp[n][sum];\\n        if(value==INT_MAX || value==INT_MAX-1) return -1;\\n        else return value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168517,
                "title": "c-o-num-k-simple-math-solution",
                "content": "**Intuition:-**\\n-> We have to find the **minimum size of a set with sum=num.**\\n-> The **unit digit of every number in set should k**.\\n-> At each time we try to find the **minimum number near number which will give a solution.**.\\n-> The first number with the unit digit k gives the answer.\\n-> If at last the nums unit digit is not k that means no solution exists.\\n-> We have to return **count+1** at last.\\n\\n**Complexity:-**\\n\\n**Time=O(num/k) in worst case.\\n**Space=O(1)**.\\n\\n**Dry Run:-**\\n\\n**num=58   \\nk=2**\\n58 -> 56 -> 54 -> 52 (got the first number)  ->    count=4\\n\\n**num=58 \\nk=3**\\n58-> 55-> 52->49->46->43 (got the first number)   ->  count=6.\\n\\n**num=58\\nk=5**\\n58->53->48->.....................->3 (unit digit!=k)       no solution -> count=-1.\\n\\nLike this you can check for any num,k.\\n\\nHoping you understood the solution :)\\nPlease **upvote** if you found it usefull !\\n\\n**Thank you.. \\uD83D\\uDE0A**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        int count=0;\\n        if(num==0){                    // if num=0 then 0 is ans\\n            return 0;\\n        }\\n        if(num%2!=0 and k%2==0){       // if num is odd and k is even no solution\\n            return -1;\\n        }\\n        if(k==0){                      // for k=0 \\n            if(num%10==0){\\n                return 1;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n\\t\\t\\n        while(num-k>0 and num%10!=k){\\n            num-=k;\\n            count++;\\n        }\\n\\t\\t\\n        if(num%10!=k){\\n            return -1;\\n        }\\n\\t\\t\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        int count=0;\\n        if(num==0){                    // if num=0 then 0 is ans\\n            return 0;\\n        }\\n        if(num%2!=0 and k%2==0){       // if num is odd and k is even no solution\\n            return -1;\\n        }\\n        if(k==0){                      // for k=0 \\n            if(num%10==0){\\n                return 1;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n\\t\\t\\n        while(num-k>0 and num%10!=k){\\n            num-=k;\\n            count++;\\n        }\\n\\t\\t\\n        if(num%10!=k){\\n            return -1;\\n        }\\n\\t\\t\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168163,
                "title": "unbounded-knapsack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int cand, int sum, int unit,vector<vector<int>>&dp){\\n        \\n        \\n        if(sum == 0){\\n            return 0;\\n        }\\n        if(cand>sum || sum < 0){\\n            return 1e9;\\n        }\\n        if(dp[cand][sum] != -1){\\n            return dp[cand][sum];\\n        }\\n        \\n        int no = f(cand+10,sum,unit,dp);\\n        int yes = 0;\\n        if(sum-cand >= 0){\\n            yes = 1+f(cand,sum-cand,unit,dp);\\n        }\\n        \\n        return dp[cand][sum]=min(yes,no);\\n    }\\n    int minimumNumbers(int num, int k) {\\n        if( k== 0 && num == 0){\\n            return 0;\\n        }\\n        if(k == 0){\\n            return num%10 == 0? 1:-1;\\n        }\\n        if(num == 0){\\n            return 0;\\n        }\\n        vector<vector<int>>dp(num+1,vector<int>(num+1,-1));\\n        int len = f(k,num,k,dp);\\n        return (len >= 1e9) ? -1: len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int cand, int sum, int unit,vector<vector<int>>&dp){\\n        \\n        \\n        if(sum == 0){\\n            return 0;\\n        }\\n        if(cand>sum || sum < 0){\\n            return 1e9;\\n        }\\n        if(dp[cand][sum] != -1){\\n            return dp[cand][sum];\\n        }\\n        \\n        int no = f(cand+10,sum,unit,dp);\\n        int yes = 0;\\n        if(sum-cand >= 0){\\n            yes = 1+f(cand,sum-cand,unit,dp);\\n        }\\n        \\n        return dp[cand][sum]=min(yes,no);\\n    }\\n    int minimumNumbers(int num, int k) {\\n        if( k== 0 && num == 0){\\n            return 0;\\n        }\\n        if(k == 0){\\n            return num%10 == 0? 1:-1;\\n        }\\n        if(num == 0){\\n            return 0;\\n        }\\n        vector<vector<int>>dp(num+1,vector<int>(num+1,-1));\\n        int len = f(k,num,k,dp);\\n        return (len >= 1e9) ? -1: len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176147,
                "title": "java-binary-search-easy-and-well-explained-binary-search-solution",
                "content": "Using Binary Search --\\nSo basically the idea is if with a certain size, can we get an answer , if yes that means anything above that size can give me an answer, so we find the last possible size such that anything above that will give me an answer and everything below that won\\'t give an answer.\\nCheck code for more clarity.\\n\\nfor example -- num = 58 and k = 9 \\nhere suppose we take 26 as size then everything above 26 will give an answer whereas if we take 1 then 1 and below 1 will never give an answer.\\nSo we can find our answer from 1 to num, considering the condition\\nnum = 5 and k = 1, in such case our ans set will be [1,1,1,1,1] which is of length num = 5.\\n\\n\\'\\'\\'\\n\\n    public int minimumNumbers(int num, int k) {\\n\\t\\n\\t//starting with -1 because if we don\\'t get an answer, we return -1\\n        int res = -1;\\n\\t\\t\\n\\t\\t//since num = 0 can have an empty set\\n        if(num == 0) return 0;\\n\\t\\t\\n\\t\\t//if k > num that means we can never add elements of set to get num so,\\n        if( k > num) return -1;\\n\\t\\t\\n\\t\\t//if k == 0 then if num is divisible by 10 then it will always have size 1\\n\\t\\t//or else we can not get an ans e.g. num 10 and k = 0 can give ans [10] \\n\\t\\t//whereas num = 8 and k = 0 can never give an ans since [8,0] is not valid\\n\\t\\t\\n\\t\\tif(k == 0){\\n            if(num%10 == 0) return 1;\\n\\t\\t\\t\\treturn -1;\\n        }\\n\\t\\t\\n\\t\\t//search space\\n        int low = 1, high = num;\\n        \\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n\\t\\t\\t\\n\\t\\t\\t// make sure to use a duplicate integer since you don\\'t want to change original num\\'s value\\n            int temp = num;\\n            if(isValid(mid, temp, num, k)){\\n                // if we get an ans that means this mid can be my ans but we go left to find a smaller one\\n                res = mid;\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        \\n\\t\\t//at last whatever is in res is my ans\\n        return res;\\n    }\\n    \\n    public boolean isValid(int mid, int nums, int tar, int k){\\n\\t\\t\\n\\t\\t//cnt is basically the size of set that we can make, following all the conditions given\\n        int cnt = 0;\\n        \\n        while(nums >= 0){\\n            if(nums % 10 == k){\\n                cnt++;\\n                return cnt <= mid;\\n            }else{\\n                cnt++;\\n                nums = nums - k;\\n            }\\n        }\\n        \\n\\t\\t//just to explain this suppose we have num = 58 ans k = 9, here since 58%10 != 9\\n\\t\\t//we will have 9 in our set and then subtract the num and check if it\\'s unit digit is k,\\n\\t\\t//if yes then there is no need to go further since we want minimum length.\\n\\t\\t//another example num = 8 and k = 2, so set and num goes like \\n\\t\\t// num = 8 , set = [ ]\\n\\t\\t// num = 6, set = [2]\\n\\t\\t// num = 4 , set = [2,2]\\n\\t\\t// num = 2 , set = [2,2,2]\\n\\t\\t// num = 0 , set = [2,2,2,2] and then num goes less than 0 so it comes out of the loop\\n        \\n\\t\\t//if you can not get an answer then your return false\\n        return false;\\n    }\\n\\'\\'\\'\\n\\nTC -> O(num)\\nSC -> O(1)\\n\\nHope this helps and if it does please upvote it really motivates me, if any query feel free to ask.\\nThank You!!",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Using Binary Search --\\nSo basically the idea is if with a certain size, can we get an answer , if yes that means anything above that size can give me an answer, so we find the last possible size such that anything above that will give me an answer and everything below that won\\'t give an answer.\\nCheck code for more clarity.\\n\\nfor example -- num = 58 and k = 9 \\nhere suppose we take 26 as size then everything above 26 will give an answer whereas if we take 1 then 1 and below 1 will never give an answer.\\nSo we can find our answer from 1 to num, considering the condition\\nnum = 5 and k = 1, in such case our ans set will be [1,1,1,1,1] which is of length num = 5.\\n\\n\\'\\'\\'\\n\\n    public int minimumNumbers(int num, int k) {\\n\\t\\n\\t//starting with -1 because if we don\\'t get an answer, we return -1\\n        int res = -1;\\n\\t\\t\\n\\t\\t//since num = 0 can have an empty set\\n        if(num == 0) return 0;\\n\\t\\t\\n\\t\\t//if k > num that means we can never add elements of set to get num so,\\n        if( k > num) return -1;\\n\\t\\t\\n\\t\\t//if k == 0 then if num is divisible by 10 then it will always have size 1\\n\\t\\t//or else we can not get an ans e.g. num 10 and k = 0 can give ans [10] \\n\\t\\t//whereas num = 8 and k = 0 can never give an ans since [8,0] is not valid\\n\\t\\t\\n\\t\\tif(k == 0){\\n            if(num%10 == 0) return 1;\\n\\t\\t\\t\\treturn -1;\\n        }\\n\\t\\t\\n\\t\\t//search space\\n        int low = 1, high = num;\\n        \\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n\\t\\t\\t\\n\\t\\t\\t// make sure to use a duplicate integer since you don\\'t want to change original num\\'s value\\n            int temp = num;\\n            if(isValid(mid, temp, num, k)){\\n                // if we get an ans that means this mid can be my ans but we go left to find a smaller one\\n                res = mid;\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        \\n\\t\\t//at last whatever is in res is my ans\\n        return res;\\n    }\\n    \\n    public boolean isValid(int mid, int nums, int tar, int k){\\n\\t\\t\\n\\t\\t//cnt is basically the size of set that we can make, following all the conditions given\\n        int cnt = 0;\\n        \\n        while(nums >= 0){\\n            if(nums % 10 == k){\\n                cnt++;\\n                return cnt <= mid;\\n            }else{\\n                cnt++;\\n                nums = nums - k;\\n            }\\n        }\\n        \\n\\t\\t//just to explain this suppose we have num = 58 ans k = 9, here since 58%10 != 9\\n\\t\\t//we will have 9 in our set and then subtract the num and check if it\\'s unit digit is k,\\n\\t\\t//if yes then there is no need to go further since we want minimum length.\\n\\t\\t//another example num = 8 and k = 2, so set and num goes like \\n\\t\\t// num = 8 , set = [ ]\\n\\t\\t// num = 6, set = [2]\\n\\t\\t// num = 4 , set = [2,2]\\n\\t\\t// num = 2 , set = [2,2,2]\\n\\t\\t// num = 0 , set = [2,2,2,2] and then num goes less than 0 so it comes out of the loop\\n        \\n\\t\\t//if you can not get an answer then your return false\\n        return false;\\n    }\\n\\'\\'\\'\\n\\nTC -> O(num)\\nSC -> O(1)\\n\\nHope this helps and if it does please upvote it really motivates me, if any query feel free to ask.\\nThank You!!",
                "codeTag": "Unknown"
            },
            {
                "id": 2168573,
                "title": "java-easy-solution-beginner-friendly",
                "content": "```\\n    public int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n\\n        int sum = k, size = 1, temp = num % 10;\\n\\n        while(size <= 10) {\\n            if(sum % 10 == temp) return size;\\n            if(sum > num) return -1;\\n            \\n            sum += k;\\n            size++;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    public int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n\\n        int sum = k, size = 1, temp = num % 10;\\n\\n        while(size <= 10) {\\n            if(sum % 10 == temp) return size;\\n            if(sum > num) return -1;\\n            \\n            sum += k;\\n            size++;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168432,
                "title": "simple-math-cpp",
                "content": "With the given digit k, we calculate all the possibilities k can generate by adding numbers ending with k, and store it in an array of size 10. \\nNow, any number can be generated if the last digit of this number say `num`  is present in the previous array . \\n\\n`Index + 1 ` in the array `v `stores the total number of `k` required to get to that number ending with digit` v[index]  `\\n\\nLets say we have num = 140 and k =7\\nthen since v[9+1] ==0 matches 140%10, i.e 0, we return the ans as 9+1= 10\\n`In this case, the  set would look like : [77,7,7,7,7,7,7,7,7,7]`\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0; \\n        vector<int> v; \\n        for(int i=1; i<=10; i++){\\n            v.push_back((i*k)%10); \\n        }\\n        int x = num%10; \\n        for(int i=0; i<v.size(); i++){\\n            if(v[i]==x && (i+1)*k<=num){\\n                return i+1; \\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0; \\n        vector<int> v; \\n        for(int i=1; i<=10; i++){\\n            v.push_back((i*k)%10); \\n        }\\n        int x = num%10; \\n        for(int i=0; i<v.size(); i++){\\n            if(v[i]==x && (i+1)*k<=num){\\n                return i+1; \\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168395,
                "title": "c-short-and-easy-with-math",
                "content": "```\\nint minimumNumbers(int num, int k) {\\n       if(num==0) return 0;\\n       if(k==0){\\n         string temp=to_string(num);\\n         if(temp[temp.length()-1]==\\'0\\') return 1;\\n         return -1;\\n       }\\n       int x=num,flag=false,count=0;\\n       while(x>=0){\\n         if(x%10==0 && count>0){\\n             flag=1;\\n             break;\\n         }\\n         count++,x-=k;\\n       }\\n       if(!flag) return -1;\\n       return count;\\n    }",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint minimumNumbers(int num, int k) {\\n       if(num==0) return 0;\\n       if(k==0){\\n         string temp=to_string(num);\\n         if(temp[temp.length()-1]==\\'0\\') return 1;\\n         return -1;\\n       }\\n       int x=num,flag=false,count=0;\\n       while(x>=0){\\n         if(x%10==0 && count>0){\\n             flag=1;\\n             break;\\n         }\\n         count++,x-=k;\\n       }\\n       if(!flag) return -1;\\n       return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2168275,
                "title": "python-simple-solution",
                "content": "All the numbers end by digit k can be represented as 10*a + k*b\\nFor example:\\nk, 10 + k, 20 + k.... etc\\nwhere a, b are a non-negative numbers\\nSo we can use the condition to judge whether a number is valid\\n\\n```Python\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n                \\n        if not num: return 0\\n        if k == 0:\\n            if num % 10 == 0: return 1\\n            else: return -1\\n            \\n        for i in range(1,  num // k + 1):\\n            if (num - i * k) % 10 == 0:\\n                return i\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n                \\n        if not num: return 0\\n        if k == 0:\\n            if num % 10 == 0: return 1\\n            else: return -1\\n            \\n        for i in range(1,  num // k + 1):\\n            if (num - i * k) % 10 == 0:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168139,
                "title": "python-math-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumNumbers(self, num: int, k: int) -> int:\\n\\t\\t\\tif num == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif num < k:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tunitsDigit = int(str(num)[-1])\\n\\t\\t\\ts = k\\n\\t\\t\\tres = 1\\n\\t\\t\\twhile res <= 10 and int(str(k * res)[-1]) != unitsDigit:\\n\\t\\t\\t\\ts += k\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn res if res <= 10 and s <= num else -1",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumNumbers(self, num: int, k: int) -> int:\\n\\t\\t\\tif num == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif num < k:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tunitsDigit = int(str(num)[-1])\\n\\t\\t\\ts = k\\n\\t\\t\\tres = 1\\n\\t\\t\\twhile res <= 10 and int(str(k * res)[-1]) != unitsDigit:\\n\\t\\t\\t\\ts += k\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn res if res <= 10 and s <= num else -1",
                "codeTag": "Java"
            },
            {
                "id": 2472295,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int n, int k) {\\n        if(n == 0) return 0;\\n        for(int i = 1; i <= 10; i++) {\\n            if(k * i > n) break;\\n            if((k * i) % 10 == n % 10) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int n, int k) {\\n        if(n == 0) return 0;\\n        for(int i = 1; i <= 10; i++) {\\n            if(k * i > n) break;\\n            if((k * i) % 10 == n % 10) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415724,
                "title": "python-simplest-solution",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        if k == 0:\\n            if num%10 == 0:\\n                return 1\\n            return -1\\n        count = 1\\n        while num%10 != k and num > 0:\\n            num -= k\\n            count += 1\\n        if num > 0 and num %10 == k:\\n            return count\\n        return -1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        if k == 0:\\n            if num%10 == 0:\\n                return 1\\n            return -1\\n        count = 1\\n        while num%10 != k and num > 0:\\n            num -= k\\n            count += 1\\n        if num > 0 and num %10 == k:\\n            return count\\n        return -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2356330,
                "title": "sum-of-numbers-with-units-digit-k-java-easy-coin-change-dp",
                "content": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0){\\n            return 0;\\n        }\\n        ArrayList<Integer> al=new ArrayList<>();\\n        int n=k;\\n        while(n<=num){\\n            if(n==num){\\n                return 1;\\n            }\\n            \\n            al.add(n);\\n            n+=10;\\n        }\\n        \\n        int []dp=new int[num+1];\\n        Arrays.fill(dp,(int)1e9);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=num;i++){\\n            for(int c=0;c<al.size();c++){\\n                int coin=al.get(c);\\n                \\n                if(coin>i){\\n                    continue;\\n                }\\n                \\n                dp[i]=Math.min(dp[i],dp[i-coin]+1);\\n            }\\n        }\\n        \\n        return dp[num]>=(int)1e9?-1:dp[num];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0){\\n            return 0;\\n        }\\n        ArrayList<Integer> al=new ArrayList<>();\\n        int n=k;\\n        while(n<=num){\\n            if(n==num){\\n                return 1;\\n            }\\n            \\n            al.add(n);\\n            n+=10;\\n        }\\n        \\n        int []dp=new int[num+1];\\n        Arrays.fill(dp,(int)1e9);\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=num;i++){\\n            for(int c=0;c<al.size();c++){\\n                int coin=al.get(c);\\n                \\n                if(coin>i){\\n                    continue;\\n                }\\n                \\n                dp[i]=Math.min(dp[i],dp[i-coin]+1);\\n            }\\n        }\\n        \\n        return dp[num]>=(int)1e9?-1:dp[num];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225989,
                "title": "100-faster-with-just-2-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if (num==0)\\n            return 0;\\n        if(num<k){\\n            return -1;\\n        }\\n        for(int i=1;i<=10;i++){\\n            if((k*i)%10==num%10){\\n                if(k*i<=num){\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if (num==0)\\n            return 0;\\n        if(num<k){\\n            return -1;\\n        }\\n        for(int i=1;i<=10;i++){\\n            if((k*i)%10==num%10){\\n                if(k*i<=num){\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202950,
                "title": "c-noob-logic-easy-to-understand",
                "content": "Let me know if you have any queries down in the comment section\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        if(num<k) return -1;\\n        for(int i=1;i<=10;++i){\\n            int ans=(k*i)%10;\\n            if(num%10==ans&&(num>=(k*i))){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        if(num<k) return -1;\\n        for(int i=1;i<=10;++i){\\n            int ans=(k*i)%10;\\n            if(num%10==ans&&(num>=(k*i))){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200519,
                "title": "python-knapsack-sc-o-n",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        \\n        if num==0:\\n            return 0\\n           \\n        cand = [x for x in range(1, num+1) if x%10==k ]\\n        \\n        if len(cand)==0:\\n            return -1\\n\\n        \\n        #knapsack on cand\\n        n=len(cand)\\n\\n        \\n        dp=[500]*(num+1)\\n\\n        dp[cand[0]]=1\\n        dp[0]=0\\n        \\n        for j in range(num+1):\\n            for i in range(n):\\n                if j-cand[i]>=0:\\n                    dp[j]=min(dp[j], 1+dp[j-cand[i]])\\n        \\n        if dp[num]==500:\\n            return -1\\n        else:\\n            return dp[num]\\n                    \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        \\n        if num==0:\\n            return 0\\n           \\n        cand = [x for x in range(1, num+1) if x%10==k ]\\n        \\n        if len(cand)==0:\\n            return -1\\n\\n        \\n        #knapsack on cand\\n        n=len(cand)\\n\\n        \\n        dp=[500]*(num+1)\\n\\n        dp[cand[0]]=1\\n        dp[0]=0\\n        \\n        for j in range(num+1):\\n            for i in range(n):\\n                if j-cand[i]>=0:\\n                    dp[j]=min(dp[j], 1+dp[j-cand[i]])\\n        \\n        if dp[num]==500:\\n            return -1\\n        else:\\n            return dp[num]\\n                    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195312,
                "title": "o-1-python",
                "content": "```\\n\\tdef minimumNumbers(self, num: int, k: int) -> int:\\n        t = num%10\\n        if num==0:\\n            return 0\\n        if num<k:\\n            return -1\\n        for i in range(1,11):\\n            if (i*k)%10 == t:\\n                if i*k <= num:\\n                    return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\tdef minimumNumbers(self, num: int, k: int) -> int:\\n        t = num%10\\n        if num==0:\\n            return 0\\n        if num<k:\\n            return -1\\n        for i in range(1,11):\\n            if (i*k)%10 == t:\\n                if i*k <= num:\\n                    return i\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2191333,
                "title": "simple-observation-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n           if(num == 0)\\n            return 0;\\n        if(num%10 == k)\\n            return 1;\\n        if(k == 0)\\n            return -1;\\n        int temp = num;\\n        int cnt = 0;\\n      \\n        while(temp > 0){\\n            temp = temp - k;\\n            cnt++;\\n            if(temp%10 == k)\\n                return cnt + 1;\\n            \\n        }\\n        return -1;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n           if(num == 0)\\n            return 0;\\n        if(num%10 == k)\\n            return 1;\\n        if(k == 0)\\n            return -1;\\n        int temp = num;\\n        int cnt = 0;\\n      \\n        while(temp > 0){\\n            temp = temp - k;\\n            cnt++;\\n            if(temp%10 == k)\\n                return cnt + 1;\\n            \\n        }\\n        return -1;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183956,
                "title": "c-unique-approach-100-beats",
                "content": "![image](https://assets.leetcode.com/users/images/df5cab04-f907-42af-8a79-d928e7a562f1_1655926763.8887248.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        if(num==0) return 0;\\n            \\n        int last = num%10;\\n        int i=1;\\n        while(i<=num and i*k <= num)\\n        {\\n            int dig = k*i;\\n            int lastk = dig%10;\\n            \\n            if(lastk==last)\\n                return i;\\n            \\n            i++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        if(num==0) return 0;\\n            \\n        int last = num%10;\\n        int i=1;\\n        while(i<=num and i*k <= num)\\n        {\\n            int dig = k*i;\\n            int lastk = dig%10;\\n            \\n            if(lastk==last)\\n                return i;\\n            \\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2178430,
                "title": "c-easy-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums,int sum,int i,vector<vector<int>> &dp){\\n        if(sum==0)return 0;\\n        if(i==0){\\n            if(nums[0]!=0 && sum%nums[0]==0){\\n                return sum/nums[0];\\n            }\\n            return 1e9;\\n        }\\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        int left=INT_MAX,right=INT_MAX;\\n        left=f(nums,sum,i-1,dp);\\n        if(nums[i]<=sum)\\n            right = f(nums,sum-nums[i],i,dp)+1;\\n        return dp[i][sum] = min(left,right);\\n    }\\n    int minimumNumbers(int num, int k) {\\n        vector<int> v;\\n        \\n        if(num==0 && k==0)return 0;\\n        if(num==0){\\n            return 0;\\n        }\\n        if( num<k){\\n            return -1;\\n        }\\n        while(k<=num){\\n            v.push_back(k);\\n            k+=10;\\n        }\\n        int n = v.size();\\n        vector<vector<int>> dp(n+1,vector<int>(num+1,-1));\\n        int res=f(v,num,v.size()-1,dp);\\n        return res==1e9?-1:res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int f(vector<int>& nums,int sum,int i,vector<vector<int>> &dp){\\n        if(sum==0)return 0;\\n        if(i==0){\\n            if(nums[0]!=0 && sum%nums[0]==0){\\n                return sum/nums[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2176080,
                "title": "java",
                "content": "```\\npublic class Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        int i = num % 10;\\n        for (int j = 0; j <=10 j++) if ((j * k) % 10 == i && j * k <= num) return j;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        int i = num % 10;\\n        for (int j = 0; j <=10 j++) if ((j * k) % 10 == i && j * k <= num) return j;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173285,
                "title": "java-easy-math-and-dp-solution",
                "content": "**MATH :**\\n```\\n// example 11   3   -> i*k<=num\\n// eaxmple 124   3  -> (i*k) % 10 == num % 10 \\n    public int minimumNumbers(int num, int k) {\\n       if(num==0) return 0;\\n        \\n        for(int i=1;i<=10 && i*k<=num ;i++)\\n        {\\n            if( (i*k) % 10 == num % 10 ) return i;\\n        }\\n        return -1;\\n    }\\n```\\n**Dp :**\\n\\n```\\n public int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0; \\n        ArrayList<Integer> a = new ArrayList<>();\\n        for(int i=1;i<=num;i++)\\n        {\\n            if(i % 10 == k) a.add(i);\\n        }\\n        \\n        \\n    //     now onwards just - coin change question.\\n        \\n         int dp[]=new int[num+1];\\n         Arrays.fill(dp,Integer.MAX_VALUE-1);\\n        \\n        for(int i=0;i<a.size();i++)\\n        {   \\n            dp[0]=0; \\n            for(int j=1;j<=num;j++)\\n            {\\n                if(a.get(i)<=j) dp[j]=Math.min(dp[j],1+dp[j-a.get(i)]);\\n            }\\n        }\\n        \\n        return dp[num]==Integer.MAX_VALUE-1? -1:dp[num] ;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n// example 11   3   -> i*k<=num\\n// eaxmple 124   3  -> (i*k) % 10 == num % 10 \\n    public int minimumNumbers(int num, int k) {\\n       if(num==0) return 0;\\n        \\n        for(int i=1;i<=10 && i*k<=num ;i++)\\n        {\\n            if( (i*k) % 10 == num % 10 ) return i;\\n        }\\n        return -1;\\n    }\\n```\n```\\n public int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0; \\n        ArrayList<Integer> a = new ArrayList<>();\\n        for(int i=1;i<=num;i++)\\n        {\\n            if(i % 10 == k) a.add(i);\\n        }\\n        \\n        \\n    //     now onwards just - coin change question.\\n        \\n         int dp[]=new int[num+1];\\n         Arrays.fill(dp,Integer.MAX_VALUE-1);\\n        \\n        for(int i=0;i<a.size();i++)\\n        {   \\n            dp[0]=0; \\n            for(int j=1;j<=num;j++)\\n            {\\n                if(a.get(i)<=j) dp[j]=Math.min(dp[j],1+dp[j-a.get(i)]);\\n            }\\n        }\\n        \\n        return dp[num]==Integer.MAX_VALUE-1? -1:dp[num] ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2172335,
                "title": "memoization-striver-jaisa-code",
                "content": "```\\nclass Solution {\\n    void makeArr(int num, int k , vector<int> &v){ // to make vector\\n        while(k <= num){\\n            if(k != 0) v.push_back(k);\\n            k += 10;\\n        }\\n    }\\n\\n    int fn(int idx, int num, int cnt, vector<int> &v, vector<vector<int>> &dp){\\n        \\n        if(num == 0) return 0;\\n\\n        \\n        if(idx < 0 or num < 0) return 1e9;\\n        \\n        if(dp[idx][num] != -1) return dp[idx][num];\\n        \\n\\n        int notpick = fn(idx-1, num, cnt, v, dp);\\n        \\n        int pick = 1e9;\\n        if(v[idx] <= num and v[idx] != 0){\\n            pick = 1 + fn(idx, num-v[idx], cnt+1, v, dp);\\n        }\\n        \\n        return dp[idx][num] = min(pick, notpick);\\n    }\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        vector<int> v;\\n        makeArr(num, k, v);\\n        \\n        \\n        int n = v.size();\\n        \\n        vector<vector<int>> dp(n , vector<int>(num+1, -1));\\n        \\n        int ans = fn(n-1, num, 0, v, dp);\\n        return (ans == 1e9) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    void makeArr(int num, int k , vector<int> &v){ // to make vector\\n        while(k <= num){\\n            if(k != 0) v.push_back(k);\\n            k += 10;\\n        }\\n    }\\n\\n    int fn(int idx, int num, int cnt, vector<int> &v, vector<vector<int>> &dp){\\n        \\n        if(num == 0) return 0;\\n\\n        \\n        if(idx < 0 or num < 0) return 1e9;\\n        \\n        if(dp[idx][num] != -1) return dp[idx][num];\\n        \\n\\n        int notpick = fn(idx-1, num, cnt, v, dp);\\n        \\n        int pick = 1e9;\\n        if(v[idx] <= num and v[idx] != 0){\\n            pick = 1 + fn(idx, num-v[idx], cnt+1, v, dp);\\n        }\\n        \\n        return dp[idx][num] = min(pick, notpick);\\n    }\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        vector<int> v;\\n        makeArr(num, k, v);\\n        \\n        \\n        int n = v.size();\\n        \\n        vector<vector<int>> dp(n , vector<int>(num+1, -1));\\n        \\n        int ans = fn(n-1, num, 0, v, dp);\\n        return (ans == 1e9) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171954,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0:\\n            return 0\\n        c=1\\n        while c<=10:\\n            f=c*k\\n            if f%10==num%10 and num>=f:\\n                return c\\n            c+=1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0:\\n            return 0\\n        c=1\\n        while c<=10:\\n            f=c*k\\n            if f%10==num%10 and num>=f:\\n                return c\\n            c+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171718,
                "title": "unbounded-knapsack-coin-change-variation-python-dp",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        \\n        if num == 0:\\n            return 0\\n        \\n        a = []\\n        for i in range(k, num+1):\\n            if i % 10 == k:\\n                a.append(i)\\n        \\n        n = len(a)\\n        if n == 0:\\n            return -1\\n        s = num\\n        dp = [[0 for i in range(s+1)] for j in range(n+1)]\\n        for i in range(s+1):\\n            dp[0][i] = math.inf\\n        for i in range(1, s+1):\\n            if a[0] != 0 and i % a[0] == 0:\\n                dp[1][i] = i//a[0]\\n            else:\\n                dp[1][i] = math.inf\\n        for i in range(1, n+1):\\n            for j in range(1, s+1):\\n                if a[i-1] <= j:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-a[i-1]]+1)\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return dp[-1][-1] if dp[-1][-1] != math.inf else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        \\n        if num == 0:\\n            return 0\\n        \\n        a = []\\n        for i in range(k, num+1):\\n            if i % 10 == k:\\n                a.append(i)\\n        \\n        n = len(a)\\n        if n == 0:\\n            return -1\\n        s = num\\n        dp = [[0 for i in range(s+1)] for j in range(n+1)]\\n        for i in range(s+1):\\n            dp[0][i] = math.inf\\n        for i in range(1, s+1):\\n            if a[0] != 0 and i % a[0] == 0:\\n                dp[1][i] = i//a[0]\\n            else:\\n                dp[1][i] = math.inf\\n        for i in range(1, n+1):\\n            for j in range(1, s+1):\\n                if a[i-1] <= j:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-a[i-1]]+1)\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        return dp[-1][-1] if dp[-1][-1] != math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171386,
                "title": "javascript-solution-straightforward-super-understandable",
                "content": "**Loop from 1 to 10 and check the last numbers and if `k*i` is `<= num` or `> num`.**\\n```\\nvar minimumNumbers = function(num, k) {\\n    if (num === 0) return 0;\\n    for (let i = 1; i <= 10; i++) {\\n        if (k*i % 10 === num % 10 && k*i <= num) return i;\\n        if (k*i > num) return -1\\n    } return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumNumbers = function(num, k) {\\n    if (num === 0) return 0;\\n    for (let i = 1; i <= 10; i++) {\\n        if (k*i % 10 === num % 10 && k*i <= num) return i;\\n        if (k*i > num) return -1\\n    } return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2170965,
                "title": "java-solution-using-cyclicity-o-1-time-and-space",
                "content": "I don\\'t think this is the best solution but was the first thing that I could think of. This still is 100% fast.\\nThe intuition is you would never need more than 10 numbers to make *num*. For example, if k = 3 and *num* ends in 1 then we need exactly 7 numbers to make up *num* irrespective of what other digits of *num* are. This is because 3 * 7 ends in 1. \\n\\nFor this I created a cyclicity array - O(1) space. This has cyclicity of each number from 0 - 9. The cyclicity is based on the last digit of multiples. For example, 5 * 1 = 5, 5 * 2 = 10, 5 * 3 = 15, ... The last digits are 5, 0, 5, 0, ... so cyclicity of 5 is {5, 0}\\n\\n```\\nclass Solution {\\n    private final static int[][] cyclicity = new int[][]{\\n            {0},\\n            {1, 2, 3, 4, 5, 6, 7, 8, 9, 0},\\n            {2, 4, 6, 8, 0},\\n            {3, 6, 9, 2, 5, 8, 1, 4, 7, 0},\\n            {4, 8, 2, 6, 0},\\n            {5, 0},\\n            {6, 2, 8, 4, 0},\\n            {7, 4, 1, 8, 5, 2, 9, 6, 3, 0},\\n            {8, 6, 4, 2, 0},\\n            {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}\\n        };\\n    \\n    public int minimumNumbers(int num, int k) \\n    {\\n        if (num == 0) return 0;\\n        if (k > num) return -1;\\n        if (k == num) return 1;        \\n        \\n        int lastdigit = num % 10;\\n        \\n        for (int i = 0; i < cyclicity[k].length; i++)\\n        {\\n            if (cyclicity[k][i] == lastdigit && num >= k * (i + 1)) return i + 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private final static int[][] cyclicity = new int[][]{\\n            {0},\\n            {1, 2, 3, 4, 5, 6, 7, 8, 9, 0},\\n            {2, 4, 6, 8, 0},\\n            {3, 6, 9, 2, 5, 8, 1, 4, 7, 0},\\n            {4, 8, 2, 6, 0},\\n            {5, 0},\\n            {6, 2, 8, 4, 0},\\n            {7, 4, 1, 8, 5, 2, 9, 6, 3, 0},\\n            {8, 6, 4, 2, 0},\\n            {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}\\n        };\\n    \\n    public int minimumNumbers(int num, int k) \\n    {\\n        if (num == 0) return 0;\\n        if (k > num) return -1;\\n        if (k == num) return 1;        \\n        \\n        int lastdigit = num % 10;\\n        \\n        for (int i = 0; i < cyclicity[k].length; i++)\\n        {\\n            if (cyclicity[k][i] == lastdigit && num >= k * (i + 1)) return i + 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170807,
                "title": "java-math-easy-fast-solution",
                "content": "Lets use an example here.\\n\\n**num = 37 & k = 9**. If we take **three 9\\'s** in the answer set - > **[9,9,9]** then we get **7** in the unit place as 9 * 3 = 27. Then we can use whatever extra required in the on the left side of it to get the number.. In this case **[19,9,9**].\\n\\n\\nIf num was 147 -> **[59,59,49]** or **[69,49,69]**. It can be shown that we can\\'t use less than this as it won\\'t have 7 in its unit place. For eg -> 9 *2 will have 8 in its unit place. \\n\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        if(k == 0){\\n            if(num % 10 == 0) return 1;\\n            else return -1;\\n        }\\n        int mul = k;\\n        int  i = 1;\\n        while(mul <= num){\\n            if(mul % 10 == num % 10) return i;\\n            i++;\\n            mul = k * i;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThanks for reading. Happy Coding\\u263A",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        if(k == 0){\\n            if(num % 10 == 0) return 1;\\n            else return -1;\\n        }\\n        int mul = k;\\n        int  i = 1;\\n        while(mul <= num){\\n            if(mul % 10 == num % 10) return i;\\n            i++;\\n            mul = k * i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170645,
                "title": "c-simple-solution-100-faster-no-extra-space-super-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        int cnt = 0,sum = 0,temp = num%10;\\n        if(num == 0) return 0;\\n        else if(k == 0 && temp != 0) return -1;\\n        else if(k == 0) return 1;\\n        \\n        do{\\n            cnt++;\\n            sum += k;\\n        }while(sum%10 != temp && cnt <= 10);\\n\\n        return (sum > num || cnt > 10)? -1:cnt;\\n    }\\n};\\n```\\n## UPVOTE IF YOU LIKE\\n![image](https://assets.leetcode.com/users/images/da9c2c98-4214-4857-9d0e-47965d33f592_1655646174.8980079.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        int cnt = 0,sum = 0,temp = num%10;\\n        if(num == 0) return 0;\\n        else if(k == 0 && temp != 0) return -1;\\n        else if(k == 0) return 1;\\n        \\n        do{\\n            cnt++;\\n            sum += k;\\n        }while(sum%10 != temp && cnt <= 10);\\n\\n        return (sum > num || cnt > 10)? -1:cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170340,
                "title": "dp-knapsack",
                "content": "class Solution {\\npublic:\\n    int nap(vector<int>v,int num,int n,vector<int>&dp)\\n    {\\n        \\n         if(n==0||num<0)\\n        {\\n            return INT_MAX-1;\\n        }\\n        \\n        if(num==0)\\n        {\\n            return  dp[num]=0;\\n        }\\n        \\n        \\n        if(dp[num]!=-1)\\n        {\\n            return dp[num];\\n        }\\n        \\n        \\n    \\n        return dp[num]=(min(1+nap(v,num-v[n-1],n,dp),nap(v,num,n-1,dp)));\\n        \\n        \\n    }\\n    \\n    \\n    \\n    \\n    int minimumNumbers(int num, int k) {\\n     \\n        \\n        \\n        if(num==0)\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        \\n        vector<int>v;\\n        for(int i=1;i<=num;i++)\\n        {\\n            if(i%10==k)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        \\n        vector<int>dp(num+1,-1);\\n        \\n        \\n        \\n        int n=nap(v,num,v.size(),dp);\\n        \\n        \\n        if(n==INT_MAX-1)\\n        {\\n            return -1;\\n        }\\n        return n;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nap(vector<int>v,int num,int n,vector<int>&dp)\\n    {\\n        \\n         if(n==0||num<0)\\n        {\\n            return INT_MAX-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2170323,
                "title": "easy-solution-o-n-time-0ms-runtime-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)\\n            return 0;\\n        for(int i=1;i<=10;i++){\\n            if((i*k)%10==num%10 && i*k<=num)\\n                return i;\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)\\n            return 0;\\n        for(int i=1;i<=10;i++){\\n            if((i*k)%10==num%10 && i*k<=num)\\n                return i;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2169418,
                "title": "simple-dynamic-programming-memoization-approach",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.a1={}\\n    def dp(self,k,d,s):\\n        if s==k:\\n            self.a1[s]=0\\n            return\\n        elif s in self.a1:\\n            return\\n        else:\\n            h=float(\"inf\")\\n            for i in d:\\n                if i+s<=k and i!=0:\\n                    self.dp(k,d,s+i)\\n                    h=min(h,self.a1[s+i]+1)\\n            self.a1[s]=h\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        x=k\\n        d=[]\\n        while(x<=num):\\n            d.append(x)\\n            x+=10\\n        self.dp(num,d,0)\\n        if self.a1[0]==float(\"inf\"):\\n            return -1\\n        return self.a1[0]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def __init__(self):\\n        self.a1={}",
                "codeTag": "Java"
            },
            {
                "id": 2169412,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using Recursion && Memoization***\\n\\n* ***Time Complexity : O(N * Num) where N is the size of array***\\n\\n* ***Space Complexity : O(N * Num)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // just like subset sum problem\\n    \\n    vector<vector<int>> dp;\\n    \\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // if there is no element in array\\n        \\n        if(i == n)  \\n            return INT_MAX - 1;\\n        \\n        // 0 element needed to make sum == 0\\n        \\n        if(sum == 0)\\n            return 0;\\n        \\n        if(sum < 0)\\n            return INT_MAX - 1;\\n        \\n        if(dp[i][sum] != -1)\\n            return dp[i][sum];\\n        \\n        if(arr[i] <= sum)\\n        {\\n            return dp[i][sum] = min(1 + helper(arr, i, n, sum - arr[i]), helper(arr, i + 1, n, sum));\\n        }\\n        else\\n        {\\n            return dp[i][sum] = helper(arr, i + 1, n, sum);\\n        }\\n    }\\n    \\n    \\n    int minimumNumbers(int num, int k) {\\n        \\n        if(num == 0)\\n            return 0;\\n        \\n        vector<int> arr;\\n        \\n        // store all the numbers till num which has unit digit as k\\n        \\n        for(int i = 1; i <= num; i++)\\n        {\\n            if(i % 10 == k)\\n            {\\n                arr.push_back(i);\\n            }\\n        }\\n        \\n        // perform subset sum\\n        \\n        int n = arr.size();\\n        \\n        dp.resize(n + 1);\\n        \\n        dp.assign(n + 1, vector<int> (num + 1, -1));\\n    \\n        int ans = helper(arr, 0, n, num);\\n        \\n        return ans == INT_MAX - 1 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // just like subset sum problem\\n    \\n    vector<vector<int>> dp;\\n    \\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // if there is no element in array\\n        \\n        if(i == n)  \\n            return INT_MAX - 1;\\n        \\n        // 0 element needed to make sum == 0\\n        \\n        if(sum == 0)\\n            return 0;\\n        \\n        if(sum < 0)\\n            return INT_MAX - 1;\\n        \\n        if(dp[i][sum] != -1)\\n            return dp[i][sum];\\n        \\n        if(arr[i] <= sum)\\n        {\\n            return dp[i][sum] = min(1 + helper(arr, i, n, sum - arr[i]), helper(arr, i + 1, n, sum));\\n        }\\n        else\\n        {\\n            return dp[i][sum] = helper(arr, i + 1, n, sum);\\n        }\\n    }\\n    \\n    \\n    int minimumNumbers(int num, int k) {\\n        \\n        if(num == 0)\\n            return 0;\\n        \\n        vector<int> arr;\\n        \\n        // store all the numbers till num which has unit digit as k\\n        \\n        for(int i = 1; i <= num; i++)\\n        {\\n            if(i % 10 == k)\\n            {\\n                arr.push_back(i);\\n            }\\n        }\\n        \\n        // perform subset sum\\n        \\n        int n = arr.size();\\n        \\n        dp.resize(n + 1);\\n        \\n        dp.assign(n + 1, vector<int> (num + 1, -1));\\n    \\n        int ans = helper(arr, 0, n, num);\\n        \\n        return ans == INT_MAX - 1 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169274,
                "title": "c-dynamic-programming-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n  int dp[3005];\\n  int func(int sum, int k)\\n  {\\n    \\n    if(sum==0) return 0;\\n    if(sum<0) return INT_MAX;\\n    long long ans=INT_MAX;\\n    if(dp[sum]!=-1) return dp[sum];\\n    for(int i=max(k,1);i<=sum;i++)\\n    {\\n      if(i%10==k)\\n      {\\n        ans=min(ans,(long long)1+func(sum-i,k));\\n      }\\n    }\\n    return dp[sum]=ans;\\n  }\\n    int minimumNumbers(int num, int k) {\\n      memset(dp,-1,sizeof(dp));\\n      if(func(num,k)==INT_MAX) return -1;\\n     return func(num,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int dp[3005];\\n  int func(int sum, int k)\\n  {\\n    \\n    if(sum==0) return 0;\\n    if(sum<0) return INT_MAX;\\n    long long ans=INT_MAX;\\n    if(dp[sum]!=-1) return dp[sum];\\n    for(int i=max(k,1);i<=sum;i++)\\n    {\\n      if(i%10==k)\\n      {\\n        ans=min(ans,(long long)1+func(sum-i,k));\\n      }\\n    }\\n    return dp[sum]=ans;\\n  }\\n    int minimumNumbers(int num, int k) {\\n      memset(dp,-1,sizeof(dp));\\n      if(func(num,k)==INT_MAX) return -1;\\n     return func(num,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168986,
                "title": "simple-c-solution-using-coin-change-strategy",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>coins, int n, int amount){\\n        int dp[n+1][amount+1];\\n        for(int i=0; i<=amount; i++){\\n            dp[0][i] = INT_MAX - 1;\\n        }\\n        for(int i=0; i<=n; i++){\\n            dp[i][0] = 0;\\n        }\\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=amount; j++){\\n                if(coins[i-1] <= j){\\n                    dp[i][j] = min(dp[i-1][j],1+dp[i][j-coins[i-1]]);\\n                }\\n                else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        if(dp[n][amount] == INT_MAX-1){\\n            return -1;\\n        }\\n        return dp[n][amount];\\n    }\\n    int minimumNumbers(int num, int k) {\\n        vector<int>coins;\\n        for(int i=1; i<=num; i++){\\n            if(i%10 == k){\\n                coins.push_back(i);\\n            }\\n        }\\n        int x = solve(coins,coins.size(),num);\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>coins, int n, int amount){\\n        int dp[n+1][amount+1];\\n        for(int i=0; i<=amount; i++){\\n            dp[0][i] = INT_MAX - 1;\\n        }\\n        for(int i=0; i<=n; i++){\\n            dp[i][0] = 0;\\n        }\\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=amount; j++){\\n                if(coins[i-1] <= j){\\n                    dp[i][j] = min(dp[i-1][j],1+dp[i][j-coins[i-1]]);\\n                }\\n                else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        if(dp[n][amount] == INT_MAX-1){\\n            return -1;\\n        }\\n        return dp[n][amount];\\n    }\\n    int minimumNumbers(int num, int k) {\\n        vector<int>coins;\\n        for(int i=1; i<=num; i++){\\n            if(i%10 == k){\\n                coins.push_back(i);\\n            }\\n        }\\n        int x = solve(coins,coins.size(),num);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168944,
                "title": "easiest-java-solution-with-explanation",
                "content": "let num = 58 and k = 9 \\nI can write nums as (50 + 8)  or (40 + 18) or (30+28) + so on...\\ni know that if there exist x pairs such that =>     _ 9 + _ 9 +..... x time = 58\\n![image](https://assets.leetcode.com/users/images/ebe8776e-d23a-4e45-b82a-63aea1f28152_1655616810.711825.png)\\n so i can write that as 9 * x +  10 * alpha = 58 \\nnow my task is to find that x \\n1. anything multiplied by 10 will give result 0 that means the unit digit of 9 * x must be 8 then only I can get 58 so first condition is last digit of nums and k * x must be same => ``` (k * x) % 10 == nums % 10``` and ```(k * x) <= num ``` .\\n2. As there will be many cases then i must know where to stop. The value of alpha can be adjusted from 0 to max and when I increase alpha then x must decrease, x is max when alpha = 0. so when alpha becomes 0 then all the cases which satisfy  ```9 * x <= 58```, i have to consider.\\n\\n```9 * 2 + 10 * 40 = 58``` so 2 is my minimum answer.\\n\\n### Edge cases -\\n1. when input num = 0 then output must be 0 as there will be 1 case which is [0] itself.\\n2. when k = 0 then ( k * x) gives 0 at unit place always then to stop the loop i have to again take cases -\\n2.a when k = 0 and num  < 9 then there will be no possible answer but if num >= 10 there can be answer such that (10,0). thus the loop must run till 10 times to get the answer or else there will be no possible answer.\\n3. if num == k then there will be only 1 case so answer = 1.\\n\\nApproach - I will run a loop from x = 1  till  ```(k * x) <= num  AND x <= 10``` and i will check if  ``` (k * x) % 10 == nums % 10``` then the first x combinations of numbers that satisfy is my answer.\\n\\n>T.C. => O(n)\\n> S.C. => O(1)\\n\\n**Please upvote if you like this solution**\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num == 0 ) return 0;\\n        else if(k==num) return 1;\\n        int x = 1;\\n        while(k * x <= num && x <= 10){\\n            if((k * x)%10 == num % 10) return x;\\n            ++x;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` (k * x) % 10 == nums % 10```\n```(k * x) <= num ```\n```9 * x <= 58```\n```9 * 2 + 10 * 40 = 58```\n```(k * x) <= num  AND x <= 10```\n``` (k * x) % 10 == nums % 10```\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num == 0 ) return 0;\\n        else if(k==num) return 1;\\n        int x = 1;\\n        while(k * x <= num && x <= 10){\\n            if((k * x)%10 == num % 10) return x;\\n            ++x;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168931,
                "title": "100-faster-easy-solution-with-all-edge-cases-covered",
                "content": "class Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n       //edge cases\\n        if(num==0) return 0; \\n        if(num%10!=0 && k==0) return -1;\\n        if(num==0 && k==0) return 0;\\n        if(num%2!=0 && k%2==0) return -1;\\n        //......\\n       \\n        int count=0;\\n        while(num>0)\\n        {\\n            if(num%10==k)  //if got a number whose unit digit==k value, then count till that iteration +1 would definitely be the min size of set.\\n            {\\n               count++;\\n               return count;\\n            }\\n            num=num-k;\\n            count++;\\n            \\n         }\\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n       //edge cases\\n        if(num==0) return 0; \\n        if(num%10!=0 && k==0) return -1;\\n        if(num==0 && k==0) return 0;\\n        if(num%2!=0 && k%2==0) return -1;\\n        //......\\n       \\n        int count=0;\\n        while(num>0)\\n        {\\n            if(num%10==k)  //if got a number whose unit digit==k value, then count till that iteration +1 would definitely be the min size of set.\\n            {\\n               count++;\\n               return count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2168765,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        dp = [math.inf] * (num + 1)\\n        dp[0] = 0\\n        \\n        options = []\\n        t = k\\n        while t < num + 1:\\n            options.append(t)\\n            dp[t] = 1\\n            t += 10\\n        \\n        for i in range(1, num + 1):\\n            for option in options:\\n                if i - option > 0:\\n                    dp[i] = min(dp[i], 1 + dp[i - option])\\n        \\n        return dp[num] if dp[num] != math.inf else -1\\n```\\n\\nSimilar to coin change problem, but the coins in this case are the numbers less than our target number which end in k.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        dp = [math.inf] * (num + 1)\\n        dp[0] = 0\\n        \\n        options = []\\n        t = k\\n        while t < num + 1:\\n            options.append(t)\\n            dp[t] = 1\\n            t += 10\\n        \\n        for i in range(1, num + 1):\\n            for option in options:\\n                if i - option > 0:\\n                    dp[i] = min(dp[i], 1 + dp[i - option])\\n        \\n        return dp[num] if dp[num] != math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168546,
                "title": "python-easy-approach-beats-90-00-both-runtime-memory-remainder",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        \\n        if num == 0:\\n            return 0\\n        \\n        if num < k:\\n            return -1\\n        \\n        if num == k:\\n            return 1\\n        \\n        ans = -1\\n        i = 1\\n\\n        while i <= 10:\\n            if (num - i * k) % 10 == 0 and i * k <= num:\\n                return i\\n            i += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        \\n        if num == 0:\\n            return 0\\n        \\n        if num < k:\\n            return -1\\n        \\n        if num == k:\\n            return 1\\n        \\n        ans = -1\\n        i = 1\\n\\n        while i <= 10:\\n            if (num - i * k) % 10 == 0 and i * k <= num:\\n                return i\\n            i += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168531,
                "title": "c-easy-soln",
                "content": "Intuition \\nAs the last digit is fixed to k \\ntherefore to get the last digit equal to the given number in minimum elements is to consider the table of k\\nEg x=58 k=9\\nTable of 9  -> 9 18 27 36 45 54 63 72 81 90\\nSo we want the last digit equal to the given number x last digit \\nwhich is 8 so we can get 8 by 9\\\\*2 as last digit \\nSo we get answer if we consider 2 element minimum.\\n\\nthere will be some edge cases like if k>x handle these \\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)return 0;\\n        vector<int>multi;\\n        for(int i=0;i<10;i++)\\n        {\\n            multi.push_back(k*(i+1));\\n        }\\n        int ans=0;\\n        bool isTrue=false;\\n        for(int i=0;i<10;i++)\\n        {\\n            if((num-multi[i])>=0&&(num-multi[i])%10==0)\\n            {\\n                ans=i;\\n                isTrue=true;\\n                break;\\n            }\\n        }\\n        if(!isTrue)return -1;\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)return 0;\\n        vector<int>multi;\\n        for(int i=0;i<10;i++)\\n        {\\n            multi.push_back(k*(i+1));\\n        }\\n        int ans=0;\\n        bool isTrue=false;\\n        for(int i=0;i<10;i++)\\n        {\\n            if((num-multi[i])>=0&&(num-multi[i])%10==0)\\n            {\\n                ans=i;\\n                isTrue=true;\\n                break;\\n            }\\n        }\\n        if(!isTrue)return -1;\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168485,
                "title": "desperate-top-of-the-mind-solution",
                "content": "Sub-par solution from a person who sucks at math. Just went ahead to code with first thoughts in order to get AC ASAP. The heat of the constest backfired and turned out to be counterproductive. \\nThink Once get WA 13 times.\\n\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        if(num<k) return -1;\\n        if(k==0 && num%10!=0) return -1;\\n        if((num%10)%2!=0 && k%2==0) return -1;\\n        if(num==k || (k==0 && num%10==0)) return 1;\\n        if(num<=10 && num%k!=0) return -1;\\n        if(num<=10 && num%k==0) return num/k;\\n\\n        int cnt = 1;\\n        int i=1;\\n        while(num>(i*k) && num%10!=(i*k)%10) {\\n            // System.out.println(i*k);\\n            cnt++;\\n            i++;\\n        }\\n        // System.out.println(i*k);\\n        if(num%10==(i*k)%10) return cnt;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        if(num<k) return -1;\\n        if(k==0 && num%10!=0) return -1;\\n        if((num%10)%2!=0 && k%2==0) return -1;\\n        if(num==k || (k==0 && num%10==0)) return 1;\\n        if(num<=10 && num%k!=0) return -1;\\n        if(num<=10 && num%k==0) return num/k;\\n\\n        int cnt = 1;\\n        int i=1;\\n        while(num>(i*k) && num%10!=(i*k)%10) {\\n            // System.out.println(i*k);\\n            cnt++;\\n            i++;\\n        }\\n        // System.out.println(i*k);\\n        if(num%10==(i*k)%10) return cnt;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168438,
                "title": "simple-recursive-solution-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(int num, int k, vector<int> &dp){\\n        if(num == 0)    return 0;\\n        if(num < 0) return 1e9;\\n        if(dp[num] != -1)    return dp[num];\\n        int currAns = INT_MAX / 2;\\n        for(int i = num; i >= 1; --i){\\n            if(i % 10 == k)\\n                currAns = min(currAns, helper(num - i, k, dp));\\n        }\\n        return dp[num] = 1 + currAns;\\n    }\\n    int minimumNumbers(int num, int k) {\\n        vector<int> dp(num + 1,-1);\\n        int ans = helper(num, k, dp);\\n        return ans > 3500 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int num, int k, vector<int> &dp){\\n        if(num == 0)    return 0;\\n        if(num < 0) return 1e9;\\n        if(dp[num] != -1)    return dp[num];\\n        int currAns = INT_MAX / 2;\\n        for(int i = num; i >= 1; --i){\\n            if(i % 10 == k)\\n                currAns = min(currAns, helper(num - i, k, dp));\\n        }\\n        return dp[num] = 1 + currAns;\\n    }\\n    int minimumNumbers(int num, int k) {\\n        vector<int> dp(num + 1,-1);\\n        int ans = helper(num, k, dp);\\n        return ans > 3500 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168399,
                "title": "java-easy-math",
                "content": "```\\n    public int minimumNumbers(int num, int k) {\\n        if (num==0) return 0;\\n        if (num%2 == 1 && k %2==0) return -1;\\n\\n        if (num%10 ==k) return 1;\\n\\n\\n        for (int i = 1; i <= 10; i++) {\\n            int prod = k * i;\\n            if (num % 10 == prod % 10 && prod <= num) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minimumNumbers(int num, int k) {\\n        if (num==0) return 0;\\n        if (num%2 == 1 && k %2==0) return -1;\\n\\n        if (num%10 ==k) return 1;\\n\\n\\n        for (int i = 1; i <= 10; i++) {\\n            int prod = k * i;\\n            if (num % 10 == prod % 10 && prod <= num) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2168379,
                "title": "c-easy-answer-can-only-be-1-10",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        int ans;\\n        for(ans=1;ans<=10;ans++){\\n            int sum=k*ans;\\n            sum=num-sum;\\n            if(sum>=0&&sum%10==0) return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        int ans;\\n        for(ans=1;ans<=10;ans++){\\n            int sum=k*ans;\\n            sum=num-sum;\\n            if(sum>=0&&sum%10==0) return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168376,
                "title": "easiest-solution-my-c-solution",
                "content": "for better understanding you can check out GFG article on similar type question\\n\\n*Minimum count of numbers required with unit digit X that sums up to N*\\n\\n\\n\\'\\'\\'\\n\\n    int isSum(int dig, int k)\\n    {\\n        int occur, digit;\\n        for (int occur = 1; occur <= 10; occur++)\\n        {\\n            digit = (k * occur) % 10;\\n            if (digit == dig)\\n                return occur;\\n        }\\n        return -1;\\n    }\\n\\n    int minimumNumbers(int num, int k)\\n    {\\n        //         vector<unordered_set<int>> res;\\n        if (num == 0)\\n        {\\n            return 0;\\n        }\\n        int dig;\\n        dig = num % 10;\\n        int occur = isSum(dig, k);\\n        if (occur == -1)\\n            return occur;\\n        else\\n        {\\n            if (num >= (occur * k))\\n                return occur;\\n            else\\n                return -1;\\n        }\\n    }\\n\\t\\n\\'\\'\\'\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "for better understanding you can check out GFG article on similar type question\\n\\n*Minimum count of numbers required with unit digit X that sums up to N*\\n\\n\\n\\'\\'\\'\\n\\n    int isSum(int dig, int k)\\n    {\\n        int occur, digit;\\n        for (int occur = 1; occur <= 10; occur++)\\n        {\\n            digit = (k * occur) % 10;\\n            if (digit == dig)\\n                return occur;\\n        }\\n        return -1;\\n    }\\n\\n    int minimumNumbers(int num, int k)\\n    {\\n        //         vector<unordered_set<int>> res;\\n        if (num == 0)\\n        {\\n            return 0;\\n        }\\n        int dig;\\n        dig = num % 10;\\n        int occur = isSum(dig, k);\\n        if (occur == -1)\\n            return occur;\\n        else\\n        {\\n            if (num >= (occur * k))\\n                return occur;\\n            else\\n                return -1;\\n        }\\n    }\\n\\t\\n\\'\\'\\'\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2168360,
                "title": "c-fast-easy-and-efficient-code-with-o-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int sum, int k) {\\n        if (sum == 0) return 0;\\n        for (int i = 1; i <= sum; ++i)\\n\\t\\t// comparing the last digit ie. to be equal to \\'k\\' && comparing that if i*k has not exceeded the required sum\\n            if ((i * k) % 10 == sum % 10 && i * k <= sum) return i; \\n        return -1;\\n    }\\n};\\n\\n```\\n\\n**Liked it? DO UPVOTE IT !!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int sum, int k) {\\n        if (sum == 0) return 0;\\n        for (int i = 1; i <= sum; ++i)\\n\\t\\t// comparing the last digit ie. to be equal to \\'k\\' && comparing that if i*k has not exceeded the required sum\\n            if ((i * k) % 10 == sum % 10 && i * k <= sum) return i; \\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168308,
                "title": "c-dp-o-n-k",
                "content": "```\\nclass Solution {\\n    int mem[3001][10];\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        memset(mem,-1,sizeof mem);\\n        return( solve(num,k)>=1e8?-1: solve(num,k));\\n    }\\n    int solve(int num, int k) {\\n        if(num==0)return 0;\\n        int &ret=mem[num][k];\\n        if(~ret)return ret;\\n        ret=1e8;\\n        for(int i=1;i<=num;++i){\\n            if(i%10==k)ret=min(ret,solve(num-i,k)+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mem[3001][10];\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        memset(mem,-1,sizeof mem);\\n        return( solve(num,k)>=1e8?-1: solve(num,k));\\n    }\\n    int solve(int num, int k) {\\n        if(num==0)return 0;\\n        int &ret=mem[num][k];\\n        if(~ret)return ret;\\n        ret=1e8;\\n        for(int i=1;i<=num;++i){\\n            if(i%10==k)ret=min(ret,solve(num-i,k)+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168286,
                "title": "python-intuitive-solution-look-for-smallest-multiple-having-same-number-at-unit-place",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if k%2 == 0 and num%2 != 0:\\n            return -1\\n        if num == 0:\\n            return 0\\n        elif k == 0 and num%10 == 0:\\n            return 1\\n        elif k == 0:\\n            return -1\\n        i = 1\\n        while True:\\n            if i*k > num:\\n                return -1\\n            if (i*k)%10 == num%10:\\n                return i\\n            i += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if k%2 == 0 and num%2 != 0:\\n            return -1\\n        if num == 0:\\n            return 0\\n        elif k == 0 and num%10 == 0:\\n            return 1\\n        elif k == 0:\\n            return -1\\n        i = 1\\n        while True:\\n            if i*k > num:\\n                return -1\\n            if (i*k)%10 == num%10:\\n                return i\\n            i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168276,
                "title": "python-solution-constant-time-complexity-simple-solution-no-dp-nor-greedy",
                "content": "The Approach is quite simple, You\\'ve to understand that inorder to get the sum \"num\" from numbers ending with digit \"k\", you need to check the last digit of the multiple of the \"k\" upto 10 and these digits will repeat after 10 again. so if the ending digit exists in the dictionary of \"k\"s multiples that means the sum is possible otherwise its not. For example if the num ends with 6 and the \"k\" is 7 then the 6 is in the 8th position in 7th list and you need to have 8 numbers ending with 7 to get the number ending with 6 and other constraints is to separate the 0 of 10 and the 10th multiple of \"k\"\\n\\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0:\\n            return 0 \\n        if k==0:\\n            if num%10==0:\\n                return 1\\n            return -1\\n        if num<k:\\n            return -1 \\n        d = {\\n            1:[1,2,3,4,5,6,7,8,9,0],\\n            2:[2,4,6,8,0],\\n            3:[3,6,9,2,5,8,1,4,7,0],\\n            4:[4,8,2,6,0],\\n            5:[5,0],\\n            6:[6,2,8,4,0],\\n            7:[7,4,1,8,5,2,9,6,3,0],\\n            8:[8,6,4,2,0],\\n            9:[9,8,7,6,5,4,3,2,1,0]\\n        }\\n        if num%10 not in d[k]:\\n            return -1 \\n        else:\\n            i = d[k].index(num%10) + 1 \\n            if num<i*k:\\n                return -1 \\n            return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0:\\n            return 0 \\n        if k==0:\\n            if num%10==0:\\n                return 1\\n            return -1\\n        if num<k:\\n            return -1 \\n        d = {\\n            1:[1,2,3,4,5,6,7,8,9,0],\\n            2:[2,4,6,8,0],\\n            3:[3,6,9,2,5,8,1,4,7,0],\\n            4:[4,8,2,6,0],\\n            5:[5,0],\\n            6:[6,2,8,4,0],\\n            7:[7,4,1,8,5,2,9,6,3,0],\\n            8:[8,6,4,2,0],\\n            9:[9,8,7,6,5,4,3,2,1,0]\\n        }\\n        if num%10 not in d[k]:\\n            return -1 \\n        else:\\n            i = d[k].index(num%10) + 1 \\n            if num<i*k:\\n                return -1 \\n            return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168262,
                "title": "python-math-solution-only-looking-at-unit-digit-clean-concise",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        unit = num % 10\\n        for i in range(1, 11):\\n            if (i * k) % 10 == unit:\\n                if i * k <= num:\\n                    return i\\n                else:\\n                    break\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        unit = num % 10\\n        for i in range(1, 11):\\n            if (i * k) % 10 == unit:\\n                if i * k <= num:\\n                    return i\\n                else:\\n                    break\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168244,
                "title": "sum-of-numbers-with-units-digit-k-no-dp-simple-mathematics-logic",
                "content": "Only Mathematics logic is requires\\nif last digit of i*k is equal to last digit of num \\nthen i numbers will be required.\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)return 0;\\n        \\n        int i=1;\\n        while(i<=num){\\n            if(i*k>num)break;\\n            if((i*k)%10 == num%10){\\n                return i;\\n            }\\n            i++;\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)return 0;\\n        \\n        int i=1;\\n        while(i<=num){\\n            if(i*k>num)break;\\n            if((i*k)%10 == num%10){\\n                return i;\\n            }\\n            i++;\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168232,
                "title": "java-solution",
                "content": "```\\n    /* {num = 117 k = 9} -> 9 + 9 + 9 -> 27 % 10 -> 7\\n\\t\\t* Posible Solutions {19+29+69}, {29+39+59}\\n        * {num = 58 k= 9} -> 9 + 9 -> 18 % 10 -> 8 \\n\\t\\t* Possible Solutions {9+49}, {19, 39}, {29, 29}\\n\\t\\t*/\\n\\n\\npublic int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        if(num < k) return -1;\\n        \\n        int currK = k;\\n        int currentNum = num % 10;\\n         \\n        int i = 1;\\n        \\n        while(i <= 10){\\n\\n            if(currK % 10 == currentNum){\\n                return i;\\n            }\\n            currK+=k;\\n            if(currK > num){\\n\\n              return -1;\\n            }\\n            i++;\\n        }\\n        \\n        return -1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    /* {num = 117 k = 9} -> 9 + 9 + 9 -> 27 % 10 -> 7\\n\\t\\t* Posible Solutions {19+29+69}, {29+39+59}\\n        * {num = 58 k= 9} -> 9 + 9 -> 18 % 10 -> 8 \\n\\t\\t* Possible Solutions {9+49}, {19, 39}, {29, 29}\\n\\t\\t*/\\n\\n\\npublic int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        if(num < k) return -1;\\n        \\n        int currK = k;\\n        int currentNum = num % 10;\\n         \\n        int i = 1;\\n        \\n        while(i <= 10){\\n\\n            if(currK % 10 == currentNum){\\n                return i;\\n            }\\n            currK+=k;\\n            if(currK > num){\\n\\n              return -1;\\n            }\\n            i++;\\n        }\\n        \\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2168223,
                "title": "easy-to-understand-solution-explained",
                "content": "We need to find the smallest set which the units digit of each integer is k, and the sum of integers is num.\\nLet\\'s approach this systematically.\\n\\nLet\\'s start with a set of 2 (running_option), both numbers will start with k. So the initial `running_sum` will be 2*k (or running_option * k)\\nWe know we must keep the integrity of the numbers ending with k - so we can only increment them by 10.\\nWe will increment the running_sum by 10 until we hit our num or overpass it. If we hit num then we return running_option, otherwise try running_option + 1.\\nIf the `running_option * k > num` we know we exhausted all our possible options, so we will return -1.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0: return 0\\n        if k > num: return -1\\n        \\n        if (num % 10) == k: return 1\\n        if k == 0:\\n            if num % 10 == 0: return 0\\n            else: return -1\\n        \\n        running_option = 2\\n        \\n        while ((running_option * k) < num):\\n            running_sum = running_option * k\\n            \\n            while running_sum < num:\\n                running_sum += 10\\n            \\n            if running_sum == num:\\n                return running_option\\n                \\n            running_option += 1\\n            \\n        if running_option * k == num:\\n            return running_option\\n        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0: return 0\\n        if k > num: return -1\\n        \\n        if (num % 10) == k: return 1\\n        if k == 0:\\n            if num % 10 == 0: return 0\\n            else: return -1\\n        \\n        running_option = 2\\n        \\n        while ((running_option * k) < num):\\n            running_sum = running_option * k\\n            \\n            while running_sum < num:\\n                running_sum += 10\\n            \\n            if running_sum == num:\\n                return running_option\\n                \\n            running_option += 1\\n            \\n        if running_option * k == num:\\n            return running_option\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168202,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n\\t\\n\\t// Check if number is 0\\n        if(num == 0){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// For checking if number ends with 0.\\n        int pieces = num / 10;\\n        if(k != 0){\\n         pieces = num/k;\\n        } \\n\\t\\t\\n        int num1 =  k;\\n        int ans = -1;\\n        while(pieces >= 0){\\n            if(num1 + pieces*k == num){\\n               ans = pieces+1;\\n               pieces--;\\n               num1 += 10;\\n            }\\n            else if(num1 + pieces*k < num) {\\n                num1 += 10;\\n                pieces--;\\n            }else{\\n                pieces--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n\\t\\n\\t// Check if number is 0\\n        if(num == 0){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// For checking if number ends with 0.\\n        int pieces = num / 10;\\n        if(k != 0){\\n         pieces = num/k;\\n        } \\n\\t\\t\\n        int num1 =  k;\\n        int ans = -1;\\n        while(pieces >= 0){\\n            if(num1 + pieces*k == num){\\n               ans = pieces+1;\\n               pieces--;\\n               num1 += 10;\\n            }\\n            else if(num1 + pieces*k < num) {\\n                num1 += 10;\\n                pieces--;\\n            }else{\\n                pieces--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168201,
                "title": "python-with-explanation-beats-100",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        # only consider the last digit!!\\n        # use visited to exit the while loop\\n        \\n        if num == 0:\\n            return 0\\n        \\n        target_last_digit = num % 10\\n        cur_sum = k\\n        min_size = 1\\n        visited = set()\\n        \\n        while cur_sum <= num:\\n            cur_last_digit = cur_sum % 10\\n            if cur_last_digit == target_last_digit:\\n                return min_size\\n            \\n            else:\\n                if cur_last_digit in visited:\\n                    return -1\\n                \\n                visited.add(cur_last_digit)\\n            \\n            cur_sum += k\\n            min_size += 1\\n        \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        # only consider the last digit!!\\n        # use visited to exit the while loop\\n        \\n        if num == 0:\\n            return 0\\n        \\n        target_last_digit = num % 10\\n        cur_sum = k\\n        min_size = 1\\n        visited = set()\\n        \\n        while cur_sum <= num:\\n            cur_last_digit = cur_sum % 10\\n            if cur_last_digit == target_last_digit:\\n                return min_size\\n            \\n            else:\\n                if cur_last_digit in visited:\\n                    return -1\\n                \\n                visited.add(cur_last_digit)\\n            \\n            cur_sum += k\\n            min_size += 1\\n        \\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2168200,
                "title": "c-backtracking-memo",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        dp = vector<vector<int>> (3005, vector<int> (10, -1));\\n        int ans = dfs(num, k);\\n        return ans == 100000 ? -1 : ans;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> dp;\\n    int dfs(int num, int k){\\n        if(num <= 0)\\n            return 0;\\n        \\n        if(dp[num][k] != -1)\\n            return dp[num][k];\\n        \\n        int ans = 100000;\\n        for(int i = 0; i*10 + k <= num; i++){\\n            if(i == 0 && k == 0)\\n                continue;\\n            \\n            int cur = i * 10 + k;\\n            ans = min(ans, 1 + dfs(num - cur, k));\\n        }\\n        return dp[num][k] = ans;\\n    }\\n};\\n\\n/**\\n56 6\\n6 16 26 36 46 56\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        dp = vector<vector<int>> (3005, vector<int> (10, -1));\\n        int ans = dfs(num, k);\\n        return ans == 100000 ? -1 : ans;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> dp;\\n    int dfs(int num, int k){\\n        if(num <= 0)\\n            return 0;\\n        \\n        if(dp[num][k] != -1)\\n            return dp[num][k];\\n        \\n        int ans = 100000;\\n        for(int i = 0; i*10 + k <= num; i++){\\n            if(i == 0 && k == 0)\\n                continue;\\n            \\n            int cur = i * 10 + k;\\n            ans = min(ans, 1 + dfs(num - cur, k));\\n        }\\n        return dp[num][k] = ans;\\n    }\\n};\\n\\n/**\\n56 6\\n6 16 26 36 46 56\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168199,
                "title": "java-dp-dfs-with-memorization-two-solutions",
                "content": "DP\\n```\\n// DP\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0)\\n            return 0;\\n        \\n        ArrayList<Integer> nums = new ArrayList<>();\\n        while (k <= num) {\\n            nums.add(k);\\n            k += 10;\\n        }\\n        \\n        int minimum = helper(nums, num);\\n        return minimum == Integer.MAX_VALUE ? -1 : minimum;\\n    }\\n    \\n    private int helper(ArrayList<Integer> nums, int num) {\\n        // store the minimum possible size of a valid set to get the value(idx)\\n        int[] aux = new int[num + 1]; \\n        Arrays.fill(aux, Integer.MAX_VALUE);\\n        aux[0] = 0;\\n        \\n        for (int i = 1; i < num + 1; i++) {\\n            for (Integer number : nums) {\\n                if (number <= i && aux[i - number] != Integer.MAX_VALUE)\\n                    aux[i] = Math.min(aux[i], aux[i - number] + 1);\\n            }\\n        }\\n        \\n        return aux[num];\\n    }\\n    \\n}\\n```\\nDFS with memorization\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0)\\n            return 0;\\n        \\n        if (k == 0) {\\n            if (num % 10 != 0)\\n                return -1;\\n            \\n            return 1;\\n        }\\n        \\n        HashMap<Integer, Integer> cache = new HashMap<>();\\n        int res = helper(cache, num, k);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    \\n    // dfs\\n    private int helper(HashMap<Integer, Integer> cache, int num, int k) {\\n        if (num == 0) {\\n            return 0;\\n        }\\n        \\n        if (num < 10 && num < k) {\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        if (cache.containsKey(num))\\n            return cache.get(num);\\n        \\n        int minimum = Integer.MAX_VALUE;\\n        while (k <= num) {\\n            num -= k;\\n            int value = helper(cache, num, k);\\n            minimum = Math.min(value == Integer.MAX_VALUE ? value : value + 1, minimum);\\n            num += k; // backtrack\\n            k += 10; // try each integer has a units digit of k\\n        }\\n        cache.put(num, minimum); // memorization\\n        \\n        return minimum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n// DP\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0)\\n            return 0;\\n        \\n        ArrayList<Integer> nums = new ArrayList<>();\\n        while (k <= num) {\\n            nums.add(k);\\n            k += 10;\\n        }\\n        \\n        int minimum = helper(nums, num);\\n        return minimum == Integer.MAX_VALUE ? -1 : minimum;\\n    }\\n    \\n    private int helper(ArrayList<Integer> nums, int num) {\\n        // store the minimum possible size of a valid set to get the value(idx)\\n        int[] aux = new int[num + 1]; \\n        Arrays.fill(aux, Integer.MAX_VALUE);\\n        aux[0] = 0;\\n        \\n        for (int i = 1; i < num + 1; i++) {\\n            for (Integer number : nums) {\\n                if (number <= i && aux[i - number] != Integer.MAX_VALUE)\\n                    aux[i] = Math.min(aux[i], aux[i - number] + 1);\\n            }\\n        }\\n        \\n        return aux[num];\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0)\\n            return 0;\\n        \\n        if (k == 0) {\\n            if (num % 10 != 0)\\n                return -1;\\n            \\n            return 1;\\n        }\\n        \\n        HashMap<Integer, Integer> cache = new HashMap<>();\\n        int res = helper(cache, num, k);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    \\n    // dfs\\n    private int helper(HashMap<Integer, Integer> cache, int num, int k) {\\n        if (num == 0) {\\n            return 0;\\n        }\\n        \\n        if (num < 10 && num < k) {\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        if (cache.containsKey(num))\\n            return cache.get(num);\\n        \\n        int minimum = Integer.MAX_VALUE;\\n        while (k <= num) {\\n            num -= k;\\n            int value = helper(cache, num, k);\\n            minimum = Math.min(value == Integer.MAX_VALUE ? value : value + 1, minimum);\\n            num += k; // backtrack\\n            k += 10; // try each integer has a units digit of k\\n        }\\n        cache.put(num, minimum); // memorization\\n        \\n        return minimum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168194,
                "title": "easy-c-solution-with-explanation",
                "content": "I have used the fact that the unit element of the num should be something that also occur in at least one unit place of the table of the number of k. Since, only those unit numbers are obtainable by adding numbers with k as the last unit place. So I first find if it is possible to have the unit number of num same as unit number of one of the numbers in table of k. I also keep a count to know when it is reached.\\n\\nNow, say count =5, and k=9, irrespective of what num is, i will need at least 5 numbers ending with 9, so the num should at least be greater than equal to count*k. \\n\\nif the number is infact greater than minimum threshold, than we can simply add any multiple of 10 to it to achieve it, hence the minimum possible would be count itself.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        \\n        int unit=num%10;\\n        int a=k;\\n        \\n        bool possible=0;\\n        int count=0;\\n        for(int i=0; i<10; i++)\\n        {\\n            \\n            count++;\\n            if(a==unit) {\\n                possible=1;\\n                break;\\n            }\\n            a+=k;\\n            a%=10;\\n        }\\n       cout<<possible;\\n        \\n        if(!possible) return -1;\\n        if(num<count*k) return -1;\\n        else \\n            return count;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        \\n        int unit=num%10;\\n        int a=k;\\n        \\n        bool possible=0;\\n        int count=0;\\n        for(int i=0; i<10; i++)\\n        {\\n            \\n            count++;\\n            if(a==unit) {\\n                possible=1;\\n                break;\\n            }\\n            a+=k;\\n            a%=10;\\n        }\\n       cout<<possible;\\n        \\n        if(!possible) return -1;\\n        if(num<count*k) return -1;\\n        else \\n            return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2168180,
                "title": "easyy-c-solution-checking-the-unit-digits",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        if(num==0)\\n        {\\n            return 0;\\n        }\\n        int req,cnt,d,sum;\\n        req=num%10;\\n        vector <int> a(10);\\n\\t\\t// a[i] -> minimum number required to get a number with unit digit i\\n        cnt=1;\\n        d=k;\\n        while(a[d]==0)\\n        {\\n            a[d]=cnt;\\n            d+=k;\\n            d%=10;\\n            cnt++;\\n        }\\n\\t\\t//If we can not get the req unit digit\\n        if(a[req]==0)\\n        {\\n            return -1;\\n        }\\n        sum=a[req]*k;\\n        if(num<sum || ((num-sum)%10)!=0)\\n        {\\n            return -1;\\n        }\\n        return a[req];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        if(num==0)\\n        {\\n            return 0;\\n        }\\n        int req,cnt,d,sum;\\n        req=num%10;\\n        vector <int> a(10);\\n\\t\\t// a[i] -> minimum number required to get a number with unit digit i\\n        cnt=1;\\n        d=k;\\n        while(a[d]==0)\\n        {\\n            a[d]=cnt;\\n            d+=k;\\n            d%=10;\\n            cnt++;\\n        }\\n\\t\\t//If we can not get the req unit digit\\n        if(a[req]==0)\\n        {\\n            return -1;\\n        }\\n        sum=a[req]*k;\\n        if(num<sum || ((num-sum)%10)!=0)\\n        {\\n            return -1;\\n        }\\n        return a[req];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168175,
                "title": "c-simple-math-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0 )return 0;\\n        if(num < k ||(k == 0 && num % 10 != 0)||(k  % 2 == 0 && num % 2 == 1))return -1;\\n        \\n        int val = 1;\\n        while(num > 0)\\n        {\\n            if(num % 10 == k)\\n                return val;\\n            num -= k;\\n            val++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0 )return 0;\\n        if(num < k ||(k == 0 && num % 10 != 0)||(k  % 2 == 0 && num % 2 == 1))return -1;\\n        \\n        int val = 1;\\n        while(num > 0)\\n        {\\n            if(num % 10 == k)\\n                return val;\\n            num -= k;\\n            val++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168166,
                "title": "python-easy-simulate",
                "content": "Super simple, just handle edge cases and then simulate:\\n\\n```\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        \\n        if num == k:\\n            return 1\\n        \\n        if num % 10 == k:\\n            return 1\\n        \\n        if k == 0:\\n            return -1\\n        \\n        cur_num = num\\n        \\n        ret = 0\\n        while cur_num >= 0 and cur_num % 10 != k:\\n            cur_num -= k\\n            ret += 1\\n            \\n        if cur_num < 0:\\n            return -1\\n        else:\\n            return ret + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        \\n        if num == k:\\n            return 1\\n        \\n        if num % 10 == k:\\n            return 1\\n        \\n        if k == 0:\\n            return -1\\n        \\n        cur_num = num\\n        \\n        ret = 0\\n        while cur_num >= 0 and cur_num % 10 != k:\\n            cur_num -= k\\n            ret += 1\\n            \\n        if cur_num < 0:\\n            return -1\\n        else:\\n            return ret + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4081938,
                "title": "easy-java-solution-without-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n\\n        if(num==0){\\n            return 0;\\n        }\\n        int uni=num%10;\\n\\n        if(num<k){\\n            return -1;\\n        }\\n\\n        for(int i=1;i<=10;i++){\\n            if(k*i>num){\\n                return -1;\\n            }\\n            if((k*i)%10 == uni){\\n                return i;\\n            }\\n        \\n        }\\n\\n        return -1;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n\\n        if(num==0){\\n            return 0;\\n        }\\n        int uni=num%10;\\n\\n        if(num<k){\\n            return -1;\\n        }\\n\\n        for(int i=1;i<=10;i++){\\n            if(k*i>num){\\n                return -1;\\n            }\\n            if((k*i)%10 == uni){\\n                return i;\\n            }\\n        \\n        }\\n\\n        return -1;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983156,
                "title": "concept-of-3-line-code-minimum-numbers-by-given-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0){\\n            return num;\\n        }else if(num<k){\\n            return -1;\\n        }\\n\\n        int ud = num%10;\\n        for(int i=1; i<=10; i++){\\n            int res = (i*k)%10;\\n            if(res == ud){\\n                if(k*i>num){\\n                    return -1;\\n                }\\n                return i;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Greedy",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0){\\n            return num;\\n        }else if(num<k){\\n            return -1;\\n        }\\n\\n        int ud = num%10;\\n        for(int i=1; i<=10; i++){\\n            int res = (i*k)%10;\\n            if(res == ud){\\n                if(k*i>num){\\n                    return -1;\\n                }\\n                return i;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979719,
                "title": "0ms-100-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe last digit of a number repeats after their 10 multiples.\\nkx1, kx2, kx3, ..., kx10.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake care of some edge cases like num=0 or num<k or if the last digit of the num is equal to k. Else return -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        if(num%10 == k) return 1;\\n        if(k>num) return -1;\\n        for(int i=1; i<=10; i++){\\n            int t = k*i;\\n            if(t<=num && t%10==num%10) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n        if(num%10 == k) return 1;\\n        if(k>num) return -1;\\n        for(int i=1; i<=10; i++){\\n            int t = k*i;\\n            if(t<=num && t%10==num%10) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951777,
                "title": "easy-solution-o-1-4-lines",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        int i = 0;\\n        for (i = 1; i <= 10 && (k * i) % 10 != num % 10; i++);\\n        return i > 10 || k * i > num ? -1 : i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        int i = 0;\\n        for (i = 1; i <= 10 && (k * i) % 10 != num % 10; i++);\\n        return i > 10 || k * i > num ? -1 : i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950712,
                "title": "golang-0ms-100-solution",
                "content": "# Code\\n```go\\nfunc minimumNumbers(num int, k int) int {\\n\\tif num == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tif num % 10 == k {\\n\\t\\treturn 1\\n\\t}\\n\\tif k == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tcount := 1\\n\\tfor num > k {\\n\\t\\tcount++\\n\\t\\tnum -= k\\n\\t\\tif num % 10 == k {\\n\\t\\t\\treturn count\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimumNumbers(num int, k int) int {\\n\\tif num == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tif num % 10 == k {\\n\\t\\treturn 1\\n\\t}\\n\\tif k == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tcount := 1\\n\\tfor num > k {\\n\\t\\tcount++\\n\\t\\tnum -= k\\n\\t\\tif num % 10 == k {\\n\\t\\t\\treturn count\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946173,
                "title": "c-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        if (k == 0) return (num % 10) ? -1 : 1;\\n        for (int i = 1; i*k <= num; ++i)\\n            if (num%10 == (i*k)%10)\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n        if (k == 0) return (num % 10) ? -1 : 1;\\n        for (int i = 1; i*k <= num; ++i)\\n            if (num%10 == (i*k)%10)\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913599,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0)\\n        {\\n            return 0;\\n        }\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        if(num%10==k)\\n        {\\n            return 1;\\n        }\\n        while(k<=num)\\n        {\\n            l.add(k);\\n            k=k+10;\\n        }\\n        int arr[]=new int[num+1];\\n        int dp[]=new int[num+1];\\n        dp[0]=1;\\n        for(int i=0;i<l.size();i++)\\n        {\\n            for(int j=l.get(i);j<=num;j++)\\n            {\\n                if(dp[j-l.get(i)]>0)\\n                {\\n                    dp[j]+=dp[j-l.get(i)];\\n                    if(j-l.get(i)==0)\\n                    {\\n                         arr[j]=1;\\n                    }\\n                    else\\n                    {\\n                        if(arr[j]==0)\\n                        {\\n                            arr[j]=arr[j-l.get(i)]+1;\\n                        }\\n                        else if(arr[j-l.get(i)]+1<arr[j])\\n                        {\\n                            arr[j]=arr[j-l.get(i)]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(arr[num]==0)\\n        {\\n            return -1;\\n        }\\n\\n        return arr[num];\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0)\\n        {\\n            return 0;\\n        }\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        if(num%10==k)\\n        {\\n            return 1;\\n        }\\n        while(k<=num)\\n        {\\n            l.add(k);\\n            k=k+10;\\n        }\\n        int arr[]=new int[num+1];\\n        int dp[]=new int[num+1];\\n        dp[0]=1;\\n        for(int i=0;i<l.size();i++)\\n        {\\n            for(int j=l.get(i);j<=num;j++)\\n            {\\n                if(dp[j-l.get(i)]>0)\\n                {\\n                    dp[j]+=dp[j-l.get(i)];\\n                    if(j-l.get(i)==0)\\n                    {\\n                         arr[j]=1;\\n                    }\\n                    else\\n                    {\\n                        if(arr[j]==0)\\n                        {\\n                            arr[j]=arr[j-l.get(i)]+1;\\n                        }\\n                        else if(arr[j-l.get(i)]+1<arr[j])\\n                        {\\n                            arr[j]=arr[j-l.get(i)]+1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(arr[num]==0)\\n        {\\n            return -1;\\n        }\\n\\n        return arr[num];\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796665,
                "title": "beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0){\\n            return 0;\\n        }\\n        if(k > num){\\n            return -1;\\n        }\\n        string s_num = to_string(num), s_k = to_string(k);\\n        int len_num = s_num.length();\\n        if(s_num[len_num-1] == s_k[0])\\n        {\\n            return 1;\\n        }\\n        int ans = 1, k1 = k;\\n        bool flag = false;\\n        while(!flag)\\n        {\\n            k1+=k;\\n            ans++;\\n            string k_k1 = to_string(k1);\\n            int len_k1 = k_k1.length();\\n            if(k_k1[len_k1-1] == s_num[len_num-1])\\n            {\\n                flag = true;\\n            }\\n            if(ans > 10)\\n            {\\n                return -1;\\n            }\\n        }\\n        if(k*ans > num){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0){\\n            return 0;\\n        }\\n        if(k > num){\\n            return -1;\\n        }\\n        string s_num = to_string(num), s_k = to_string(k);\\n        int len_num = s_num.length();\\n        if(s_num[len_num-1] == s_k[0])\\n        {\\n            return 1;\\n        }\\n        int ans = 1, k1 = k;\\n        bool flag = false;\\n        while(!flag)\\n        {\\n            k1+=k;\\n            ans++;\\n            string k_k1 = to_string(k1);\\n            int len_k1 = k_k1.length();\\n            if(k_k1[len_k1-1] == s_num[len_num-1])\\n            {\\n                flag = true;\\n            }\\n            if(ans > 10)\\n            {\\n                return -1;\\n            }\\n        }\\n        if(k*ans > num){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766103,
                "title": "runtime-beats-100-00-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        int resp=0;\\n        boolean found= false;\\n        if(num==0){\\n            return 0;\\n        }\\n        if(num<k){\\n            return -1;\\n        }\\n        for(int i=1;i<=10;i++){\\n           resp++;\\n           int l= (k*i)%10;\\n           int h=num%10;\\n           if(l==h){\\n               found=true;\\n               break;\\n           } \\n           //System.out.println(\"l is \"+l+\" h is \"+h);    \\n        }\\n        if(!found){\\n            return -1;\\n        }\\n        if(num<k*resp){\\n            return -1;\\n        }\\n        return resp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        int resp=0;\\n        boolean found= false;\\n        if(num==0){\\n            return 0;\\n        }\\n        if(num<k){\\n            return -1;\\n        }\\n        for(int i=1;i<=10;i++){\\n           resp++;\\n           int l= (k*i)%10;\\n           int h=num%10;\\n           if(l==h){\\n               found=true;\\n               break;\\n           } \\n           //System.out.println(\"l is \"+l+\" h is \"+h);    \\n        }\\n        if(!found){\\n            return -1;\\n        }\\n        if(num<k*resp){\\n            return -1;\\n        }\\n        return resp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749057,
                "title": "very-intuitive-solution-gonna-love-dp-for-this",
                "content": "We simply stored minimum elements to get any element and returned final answer\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n      vector<int>dp(num+1,1e9);\\n        // dp[i] stores minimum no. of elements needed to get element i\\n       dp[0]=0;\\n        \\n        for(int i=1;i<=num;i++){\\n            for(int j=k;j<=num;j+=10){\\n                if(j<=i)\\n                    dp[i]=min(dp[i],1+dp[i-j]);\\n            }\\n            \\n        }\\n       \\n        if(dp[num]==1e9) return -1;\\n        return dp[num];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n      vector<int>dp(num+1,1e9);\\n        // dp[i] stores minimum no. of elements needed to get element i\\n       dp[0]=0;\\n        \\n        for(int i=1;i<=num;i++){\\n            for(int j=k;j<=num;j+=10){\\n                if(j<=i)\\n                    dp[i]=min(dp[i],1+dp[i-j]);\\n            }\\n            \\n        }\\n       \\n        if(dp[num]==1e9) return -1;\\n        return dp[num];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739610,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0){\\n                return 0;\\n        }\\n            \\n            for(int i=1; i<=10; i++){\\n                    if((i*k)%10==num%10 && (i*k)<=num){\\n\\t\\t\\t\\t\\t                  return i;\\n\\t\\t\\t\\t\\t}\\n                    \\n            }\\n            return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0){\\n                return 0;\\n        }\\n            \\n            for(int i=1; i<=10; i++){\\n                    if((i*k)%10==num%10 && (i*k)<=num){\\n\\t\\t\\t\\t\\t                  return i;\\n\\t\\t\\t\\t\\t}\\n                    \\n            }\\n            return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718619,
                "title": "simple-c-solution-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint hope(int index,vector<int>&available,int num,vector<vector<int>>&dp){\\n    if(num==0)return 0;\\n    if(index>=available.size()){\\n        return 1e9;\\n    }\\n    if(dp[index][num]!=-1)return dp[index][num];\\n    int pick=1e9;\\n    int not_pick=1e9;\\n    if(available[index]<=num)pick=1+hope(index,available,num-available[index],dp);\\n    not_pick=hope(index+1,available,num,dp);\\n    return dp[index][num]=min(pick,not_pick);\\n}\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)return 0;\\n        vector<int>available;\\n        int first=0;\\n        if(k!=0)first=k;\\n        else if(k==0)first=10;\\n        while(first<=num){\\n            available.push_back(first);\\n            first=first+10;\\n        }\\n        vector<vector<int>>dp(available.size(),vector<int>(num+1,-1));\\n        int answer=hope(0,available,num,dp);\\n        if(answer>=1e9)return -1;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint hope(int index,vector<int>&available,int num,vector<vector<int>>&dp){\\n    if(num==0)return 0;\\n    if(index>=available.size()){\\n        return 1e9;\\n    }\\n    if(dp[index][num]!=-1)return dp[index][num];\\n    int pick=1e9;\\n    int not_pick=1e9;\\n    if(available[index]<=num)pick=1+hope(index,available,num-available[index],dp);\\n    not_pick=hope(index+1,available,num,dp);\\n    return dp[index][num]=min(pick,not_pick);\\n}\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)return 0;\\n        vector<int>available;\\n        int first=0;\\n        if(k!=0)first=k;\\n        else if(k==0)first=10;\\n        while(first<=num){\\n            available.push_back(first);\\n            first=first+10;\\n        }\\n        vector<vector<int>>dp(available.size(),vector<int>(num+1,-1));\\n        int answer=hope(0,available,num,dp);\\n        if(answer>=1e9)return -1;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703934,
                "title": "python-3-easy-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0 :\\n            return 0\\n        if k==0:\\n            if num%10==0:\\n                return 1\\n            else:\\n                return -1\\n        c=1\\n        x=num%10\\n        n=k\\n        while k<=num:\\n            if k%10==x:\\n                return c\\n            c+=1\\n            k+=n\\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0 :\\n            return 0\\n        if k==0:\\n            if num%10==0:\\n                return 1\\n            else:\\n                return -1\\n        c=1\\n        x=num%10\\n        n=k\\n        while k<=num:\\n            if k%10==x:\\n                return c\\n            c+=1\\n            k+=n\\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698241,
                "title": "python-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially it looks like a backtracking problem. We need to try every possible combinations. If a combination does not meet the requirement, we backtrack and try a different combination.\\n\\nIt is easy to observe that we can cache the results of subproblems. There are multiple ways to achieve an intermediate result. We don\\'t need to re-calculate it. It leads to a DP approacch.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe ultimate problem: find minimum size of combinations where the sum of the combination equals `num`.\\n\\nThe subproblem: find the minimum size of combinations where the sum of the combination equals `curr_sum`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(num)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(num)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if not num: return num\\n        # if num%k ==0: return 1\\n        \\n        @cache\\n        def backtracking(curr_sum):\\n            if curr_sum > num: return float(\\'inf\\')\\n            if curr_sum == num: return 0\\n            res = float(\\'inf\\')\\n            for candidate in range(k, num-curr_sum+1, 10):\\n                # print(candidate)\\n                if candidate==0: continue\\n                res = min(res, 1+backtracking(curr_sum+candidate))\\n            return res\\n        \\n        ans = backtracking(0) \\n        if ans == float(\\'inf\\'): return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if not num: return num\\n        # if num%k ==0: return 1\\n        \\n        @cache\\n        def backtracking(curr_sum):\\n            if curr_sum > num: return float(\\'inf\\')\\n            if curr_sum == num: return 0\\n            res = float(\\'inf\\')\\n            for candidate in range(k, num-curr_sum+1, 10):\\n                # print(candidate)\\n                if candidate==0: continue\\n                res = min(res, 1+backtracking(curr_sum+candidate))\\n            return res\\n        \\n        ans = backtracking(0) \\n        if ans == float(\\'inf\\'): return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684641,
                "title": "easiest-math-based-intuitive-solution-beats-100",
                "content": "# Intuition\\nK lies between 0-9. Any set of numbers ending with specific k , will have a sum that would end with a specific set of numbers at its unit place.\\nexample if k == 2;\\n2, 4, 6, 8, 10, 12, 14, 16, 18, 20, so the unit place of sum of any set of number with k = 2 will have {0,2,4,6,8} at its unit place it can never have {1,3,5,7,9} at its unit place .\\n\\nNow for set of numbers with k = 2 to have sum ending with 4 we need minimum2 groups as 2*2 == 4.\\n\\nNow if this minRequirement * 2 is greater than the sum , then making any such set is impossible. \\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nwe iterate from 1 to 10 to see if (k*i)%10 == num%10\\nso O(10).\\n\\n- Space complexity:\\nNo storage required\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int minimumNumbers(int num, int k) {\\n        int last = num%10;\\n        int minReq = -1;\\n        for(int i=1;i<=10;i++){\\n            if((k*i)%10 == last){\\n                minReq = i;\\n                break;\\n            }\\n        }\\n        if(num == 0) return 0;\\n        if(minReq == -1 || minReq * k > num) return -1;\\n        return minReq;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minimumNumbers(int num, int k) {\\n        int last = num%10;\\n        int minReq = -1;\\n        for(int i=1;i<=10;i++){\\n            if((k*i)%10 == last){\\n                minReq = i;\\n                break;\\n            }\\n        }\\n        if(num == 0) return 0;\\n        if(minReq == -1 || minReq * k > num) return -1;\\n        return minReq;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662109,
                "title": "c-modulo-of-10",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if (num==0) return 0;\\n        if (k>num) return -1;\\n        \\n        //int multiplier =-1;\\n        for (int i=1;i<11;i++){\\n            if ((k*i)%10 == num%10 && k*i <=num) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if (num==0) return 0;\\n        if (k>num) return -1;\\n        \\n        //int multiplier =-1;\\n        for (int i=1;i<11;i++){\\n            if ((k*i)%10 == num%10 && k*i <=num) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641629,
                "title": "short-ruby-solution-using-modulo-with-explanation-100-100",
                "content": "# Intuition\\nMultiply the units digit by numbers 1-10 and see if any of them work.\\n\\n# Approach\\n1. Special case: return 0 if num is 0.\\n2. Multiply k by the numbers 1-10 and see if any of them have the same units digit as num.  If they do, and they don\\'t exceed num, that\\'s a valid solution.  (Note that it\\'s fine if it\\'s lower: instead of using 9 and 9, you could use 9 and 49 in the first testcase.)  Because this goes in order and returns early, it will pick the smallest set.\\n3. If none of these sets worked, return -1\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef minimum_numbers(num, k)\\n    return 0 if num == 0\\n    (1..10).each do |i|\\n        return i if k*i % 10 == num % 10 && k*i <= num\\n    end\\n    -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_numbers(num, k)\\n    return 0 if num == 0\\n    (1..10).each do |i|\\n        return i if k*i % 10 == num % 10 && k*i <= num\\n    end\\n    -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3637135,
                "title": "o-n-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(k == 0 && num==0) return 0;\\n        if(k==0)return num%10 == 0 ? 1 : -1;\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0) {\\n            n-=k;\\n            ans++;\\n            if(n<0) return -1;\\n            if(n%10 == 0) return ans;\\n        }\\n        if(n==0) return ans;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(k == 0 && num==0) return 0;\\n        if(k==0)return num%10 == 0 ? 1 : -1;\\n        int ans = 0;\\n        int n = num;\\n        while(n > 0) {\\n            n-=k;\\n            ans++;\\n            if(n<0) return -1;\\n            if(n%10 == 0) return ans;\\n        }\\n        if(n==0) return ans;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577432,
                "title": "beat-100-logic-and-observation-and-number-theory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- k belong to [0,9] so what is maximum carry we can generate by add k ===> 9  because 9*10=90;\\n- so means our primary concerd should be can i achieve num%10==(k*somevlaue)%10;\\n- someValue will be [1,10] because after that unit place will repeat\\n- if I get someValue then I know for sure that carry will be [0,9] and I can handle carry is num/10 or all the number except last digit is greater than carry .\\n- just Code this .Dry run with multiple testCase then reached to this conclusion so yaa use pen and paper.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        if (num==0)return 0;\\n\\n        int carry=0;\\n        bool flag=0;\\n        int count=0;\\n        for(int i=1;i<=10;i++)\\n        {\\n            carry+=k;\\n            count++;\\n            if(carry%10==num%10)\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if (!flag)return -1;\\n        if ((carry/10) >(num/10))\\n        {\\n            return -1;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) \\n    {\\n        if (num==0)return 0;\\n\\n        int carry=0;\\n        bool flag=0;\\n        int count=0;\\n        for(int i=1;i<=10;i++)\\n        {\\n            carry+=k;\\n            count++;\\n            if(carry%10==num%10)\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if (!flag)return -1;\\n        if ((carry/10) >(num/10))\\n        {\\n            return -1;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566925,
                "title": "c-easy-solution-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0) return num;\\n        for(int i = 1; i<= 10 && k * i <= num; ++i) if((k * i)%10 == num % 10) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0) return num;\\n        for(int i = 1; i<= 10 && k * i <= num; ++i) if((k * i)%10 == num % 10) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558281,
                "title": "no-sol-only-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int minimumNumbers(int num, int k)\\n    {\\n        if(num == 0)\\n            return 0;\\n        if(k == 0)\\n            if(num % 10 == 0) //E.g. 20,1590,3000\\n                return 1;\\n            else\\n                return -1;\\n        for(int i = 1; i <= num/k; i++) // Start with set size 1 and look for set having unit\\'s digit equal to that of num\\n            if(num % 10 == ((i*k)%10)) // Look for equal unit\\'s digit\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int minimumNumbers(int num, int k)\\n    {\\n        if(num == 0)\\n            return 0;\\n        if(k == 0)\\n            if(num % 10 == 0) //E.g. 20,1590,3000\\n                return 1;\\n            else\\n                return -1;\\n        for(int i = 1; i <= num/k; i++) // Start with set size 1 and look for set having unit\\'s digit equal to that of num\\n            if(num % 10 == ((i*k)%10)) // Look for equal unit\\'s digit\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544022,
                "title": "c-dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        long ans = 0;\\n        unordered_map<int, long> m;\\n        ans = dfs(num, k, m);\\n        return ans >= INT_MAX ? -1 : ans;\\n    }\\n    long dfs(int curVal, int k, unordered_map<int, long>& m){\\n        if (curVal == 0) return 0;\\n        if (curVal < 0) return INT_MAX;\\n        if (m.find(curVal) != m.end()) return m[curVal];\\n        long ans = INT_MAX;\\n        int cur = curVal - (curVal % 10) + k;\\n        while (cur > 0){\\n            ans = min(ans, 1 + dfs(curVal - cur, k, m));\\n            cur -= 10;\\n        }\\n        return m[curVal] = ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        long ans = 0;\\n        unordered_map<int, long> m;\\n        ans = dfs(num, k, m);\\n        return ans >= INT_MAX ? -1 : ans;\\n    }\\n    long dfs(int curVal, int k, unordered_map<int, long>& m){\\n        if (curVal == 0) return 0;\\n        if (curVal < 0) return INT_MAX;\\n        if (m.find(curVal) != m.end()) return m[curVal];\\n        long ans = INT_MAX;\\n        int cur = curVal - (curVal % 10) + k;\\n        while (cur > 0){\\n            ans = min(ans, 1 + dfs(curVal - cur, k, m));\\n            cur -= 10;\\n        }\\n        return m[curVal] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515234,
                "title": "o-1-z10-group-basics-of-graph-theory-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n0. Instead of finding the set of numbers, we only need to find a way to let the units digit to match with `k`.\\n1. To do so, first, note that all odd numbers rather than 5 could generate the units digit `0-9` by keep adding the number and doing `mod 10`.\\nFor example:\\n3:\\n3->6->9->2->5->8->1->4->7->0\\n2. 5 could only generate the units digit `0, 5`.\\n3. All even numbers could only generate the units digit `0, 2, 4, 6, 8`\\nFor example:\\n4:\\n4->8->2->6->0\\n4. And some base cases will be considered:\\n- num = 0 requires empty list\\n- k > num is impossible\\n- when k = num % 10 the units digit which means we\\'re good\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check all cases and preform early return if possible\\n2. Check if `num - k` can be constructed or not, if so return `1 + minimumNumbers(num - k, k)` otherwise return `-1`.\\n# Complexity\\n- Time complexity: O(1) \\n- the worst case happens when we need to substract `k` for 10 times, since the order of cycle for adding the number and doing `mod 10` is at most 10.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n- one recursive call requires one stack but at most 10 calls in total.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        elif k > num:\\n            return -1\\n        elif k % 2 == 0 and num % 10 % 2 == 1:\\n            return -1\\n        elif k == 5 and num % 10 not in [0, 5]:\\n            return -1\\n        elif num % 10 == k:\\n            return 1\\n        elif k == 0 and num != 0:\\n            return -1\\n        else:\\n            rest = self.minimumNumbers(num - k, k)\\n            return 1  + rest if rest != -1 else -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        elif k > num:\\n            return -1\\n        elif k % 2 == 0 and num % 10 % 2 == 1:\\n            return -1\\n        elif k == 5 and num % 10 not in [0, 5]:\\n            return -1\\n        elif num % 10 == k:\\n            return 1\\n        elif k == 0 and num != 0:\\n            return -1\\n        else:\\n            rest = self.minimumNumbers(num - k, k)\\n            return 1  + rest if rest != -1 else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495604,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar minimumNumbers = function(num, k) {\\n    if (num === 0) return 0;\\n    if (k === 0) {\\n        return num % 10 ? -1 : 1;\\n    }\\n\\n    const unitsNum = num % 10;\\n    const maxCount = num / k;\\n\\n    for (let count = 1; count <= maxCount; count++) {\\n        if (count * k % 10 !== unitsNum) continue;\\n        return count;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumNumbers = function(num, k) {\\n    if (num === 0) return 0;\\n    if (k === 0) {\\n        return num % 10 ? -1 : 1;\\n    }\\n\\n    const unitsNum = num % 10;\\n    const maxCount = num / k;\\n\\n    for (let count = 1; count <= maxCount; count++) {\\n        if (count * k % 10 !== unitsNum) continue;\\n        return count;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3457871,
                "title": "sum-of-numbers-with-units-digit-k",
                "content": "-------------- Easy C++ Solution --------------------\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n    if (num == 0)\\n      return 0;\\n    for (int i = 1; i <= 10 && i * k <= num; ++i)\\n      if (i * k % 10 == num % 10)\\n        return i;\\n\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n    if (num == 0)\\n      return 0;\\n    for (int i = 1; i <= 10 && i * k <= num; ++i)\\n      if (i * k % 10 == num % 10)\\n        return i;\\n\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401275,
                "title": "100-subtraction-concept-maths-c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSubtract k from num till num becomes 0\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(num.size())\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(!num) return 0;\\n        if(k==0 && num%10==0) return 1;\\n        if(k==0 && num%10!=0) return -1;\\n        int flag=0;\\n        int cnt=0;\\n        do{\\n            num-=k;\\n            flag=1;\\n            cnt++;\\n        }while(num%10!=0 && num>=0);\\n        if(flag==0 || num<0) return -1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(!num) return 0;\\n        if(k==0 && num%10==0) return 1;\\n        if(k==0 && num%10!=0) return -1;\\n        int flag=0;\\n        int cnt=0;\\n        do{\\n            num-=k;\\n            flag=1;\\n            cnt++;\\n        }while(num%10!=0 && num>=0);\\n        if(flag==0 || num<0) return -1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400961,
                "title": "c-easy-solution-dp-memoization-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    //TC=O(no*no)\\n    //sc=o(no)\\n    int dp[3001];\\n    int find(int no,int k){\\n        if(no==0){\\n            return 0;\\n        }\\n        if(no<0){\\n            return INT_MAX;\\n        }\\n        if(dp[no]!=-1){\\n            return dp[no];\\n        }\\n        int mini=INT_MAX;\\n        for(int i=1;i<=no;i++){\\n            int ans=INT_MAX;\\n            if(i%10==k){\\n                ans=find(no-i,k);\\n            }\\n            if(ans!=INT_MAX){\\n                mini=min(mini,1+ans);\\n            }\\n        }\\n        return dp[no]=mini;\\n    }\\n    int minimumNumbers(int num, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        if(num==0){\\n            return 0;\\n        }\\n        \\n        int ans= find(num,k);\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //TC=O(no*no)\\n    //sc=o(no)\\n    int dp[3001];\\n    int find(int no,int k){\\n        if(no==0){\\n            return 0;\\n        }\\n        if(no<0){\\n            return INT_MAX;\\n        }\\n        if(dp[no]!=-1){\\n            return dp[no];\\n        }\\n        int mini=INT_MAX;\\n        for(int i=1;i<=no;i++){\\n            int ans=INT_MAX;\\n            if(i%10==k){\\n                ans=find(no-i,k);\\n            }\\n            if(ans!=INT_MAX){\\n                mini=min(mini,1+ans);\\n            }\\n        }\\n        return dp[no]=mini;\\n    }\\n    int minimumNumbers(int num, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        if(num==0){\\n            return 0;\\n        }\\n        \\n        int ans= find(num,k);\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344547,
                "title": "memoization-dp-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int helper(List<Integer> list, int idx, int[][] dp, int sum) {\\n        if (idx == -1) {\\n            return sum == 0 ? 0 : 300000;\\n        }\\n        if (sum == 0) {\\n            return 0;\\n        }\\n        if (dp[idx][sum] != -1) {\\n            return dp[idx][sum];\\n        }\\n        int pick = 300000;\\n        if (list.get(idx) <= sum) {\\n            pick = 1 + helper(list, idx, dp, sum - list.get(idx));\\n        }\\n        int not_pick = helper(list, idx - 1, dp, sum);\\n        dp[idx][sum] = Math.min(pick, not_pick);\\n        return dp[idx][sum];\\n    }\\n\\n    public int minimumNumbers(int num, int k) {\\n        List<Integer>list = new ArrayList<>();\\n        int n = num;\\n        while(n > 0) {\\n            if (n % 10 == k) {\\n                list.add(n);\\n            }\\n            n--;\\n        }\\n        int[][] dp=new int[list.size()][num+1];\\n        for(int[]d:dp) Arrays.fill(d,-1);\\n        int size = helper(list,list.size()-1,dp,num);\\n        return size>=30000?-1:size;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Greedy",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public int helper(List<Integer> list, int idx, int[][] dp, int sum) {\\n        if (idx == -1) {\\n            return sum == 0 ? 0 : 300000;\\n        }\\n        if (sum == 0) {\\n            return 0;\\n        }\\n        if (dp[idx][sum] != -1) {\\n            return dp[idx][sum];\\n        }\\n        int pick = 300000;\\n        if (list.get(idx) <= sum) {\\n            pick = 1 + helper(list, idx, dp, sum - list.get(idx));\\n        }\\n        int not_pick = helper(list, idx - 1, dp, sum);\\n        dp[idx][sum] = Math.min(pick, not_pick);\\n        return dp[idx][sum];\\n    }\\n\\n    public int minimumNumbers(int num, int k) {\\n        List<Integer>list = new ArrayList<>();\\n        int n = num;\\n        while(n > 0) {\\n            if (n % 10 == k) {\\n                list.add(n);\\n            }\\n            n--;\\n        }\\n        int[][] dp=new int[list.size()][num+1];\\n        for(int[]d:dp) Arrays.fill(d,-1);\\n        int size = helper(list,list.size()-1,dp,num);\\n        return size>=30000?-1:size;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336227,
                "title": "java-100-simple-math-to-match-unit-digit-of-sum",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n\\n        int i=1;\\n\\n        while(i<=10 && k*i<=num){\\n            if(num%10==k*i%10) return i;\\n            i++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num==0) return 0;\\n\\n        int i=1;\\n\\n        while(i<=10 && k*i<=num){\\n            if(num%10==k*i%10) return i;\\n            i++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297578,
                "title": "c-easy-solution-with-explanation-using-unordered-map",
                "content": "# EXPLANATION\\nOn here we noticed that the only thing we need to check is the number of integres we need to match the conditions. So we just need to work on that.\\nAt first we store the one\\'s digit of multiple of **\"k\"** in **\"map\"** with the numbers.\\nThen we check the one\\'s digit of **\"num\"** and checked it\\'s presence.\\nIf **\"num\"** is greater than or equal to multiple of \"k\" then which means that the key\\'s value is the answer else **-1** is the answer.\\n**Dry run this code to have a better understanding.**\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)\\n            return 0;\\n        unordered_map<int,int> map;\\n        for(int i=1;i<=10;i++){\\n            int a=(k*i)%10;\\n            if(map.find(a)==map.end())\\n                map[a]=i;\\n            else\\n                break;\\n        }\\n        int b=num%10;\\n        if(map.find(b)!=map.end() && k*map[b]<=num)\\n            return map[b];\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)\\n            return 0;\\n        unordered_map<int,int> map;\\n        for(int i=1;i<=10;i++){\\n            int a=(k*i)%10;\\n            if(map.find(a)==map.end())\\n                map[a]=i;\\n            else\\n                break;\\n        }\\n        int b=num%10;\\n        if(map.find(b)!=map.end() && k*map[b]<=num)\\n            return map[b];\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296058,
                "title": "easy-c-math-4ms",
                "content": "# Intuition\\n**Think of eliminating all the cases for which the set is not possible.**\\n1. if num==0\\n2. if num%10!=0 && k==0\\n3. if num<k && num>0\\n4. if num%10==k \\n5. if num%10==0\\n# Approach\\n- elimate all non existing cases.\\n- then keep checking the possibility by subtracting k from num until num becomes zero or less than zero.\\n\\n# Complexity\\n- Time complexity:\\nO(num/k)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        int cnt=0;\\n        //eliminate all cases where there is no possibility of a set\\n        if(num==0) return 0;\\n        if(num<k && num>0) return -1;\\n        //if the num leaves remainder k when divided by 10 there won\\'t be any set existence\\n        if(num%10!=0 && k==0) return -1;\\n        //if num exits the loop with a value>0, then we will have a set.\\n        while(num%10!=k && num>0){\\n            num=num-k;\\n            cnt++;\\n        }\\n        if(num>0) return cnt+1;\\n        else return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        int cnt=0;\\n        //eliminate all cases where there is no possibility of a set\\n        if(num==0) return 0;\\n        if(num<k && num>0) return -1;\\n        //if the num leaves remainder k when divided by 10 there won\\'t be any set existence\\n        if(num%10!=0 && k==0) return -1;\\n        //if num exits the loop with a value>0, then we will have a set.\\n        while(num%10!=k && num>0){\\n            num=num-k;\\n            cnt++;\\n        }\\n        if(num>0) return cnt+1;\\n        else return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280469,
                "title": "java-count-i-easiest-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nuse formula (nums - (i*k))%10 = X+Y+Z+...)   \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num == 0)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n            return num%10==0 ? 1 : -1;\\n        }\\n\\n        for(int i=1; i*k<=num && i<=10; i++)\\n        {\\n            if((num- k*i)%10==0)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if(num == 0)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n            return num%10==0 ? 1 : -1;\\n        }\\n\\n        for(int i=1; i*k<=num && i<=10; i++)\\n        {\\n            if((num- k*i)%10==0)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223859,
                "title": "medium-is-fun-just-try",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nfocus on the first digit of both num and k.\\nif somehow you can make them equal you can win the game.\\nBy just adding the k many times you may be able to make first digit of num and k equal.\\n\\nAnd these many time = 10 times because after that number keeps on repeating previous values.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSo now make a loop of 10 times and track how many times you can add it to get the first digit same in both num and your current value.\\n\\nBut never let the current variable greater than the number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0:\\n            return 0\\n        l=k\\n        flag=True\\n        for i in range(1,11):\\n            if l>num:\\n                return -1\\n            else:\\n                l=k*i\\n                if str(l)[-1]==str(num)[-1]:\\n                    flag=False\\n                    break\\n        if flag:\\n            return -1\\n        return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0:\\n            return 0\\n        l=k\\n        flag=True\\n        for i in range(1,11):\\n            if l>num:\\n                return -1\\n            else:\\n                l=k*i\\n                if str(l)[-1]==str(num)[-1]:\\n                    flag=False\\n                    break\\n        if flag:\\n            return -1\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200564,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        if(k == 0 && num % 10 != 0) return -1;\\n        for(int i = 1; i * k <= num; i++) {\\n            if((num - i * k) % 10 == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n\\n// Golang\\nfunc minimumNumbers(num int, k int) int {\\n    if num == 0 {return 0}\\n    if k == 0 && num % 10 != 0 {return -1}\\n    for i := 1; i * k <= num; i++ {\\n        if (num - i * k) % 10 == 0 {return i}\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num == 0) return 0;\\n        if(k == 0 && num % 10 != 0) return -1;\\n        for(int i = 1; i * k <= num; i++) {\\n            if((num - i * k) % 10 == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n\\n// Golang\\nfunc minimumNumbers(num int, k int) int {\\n    if num == 0 {return 0}\\n    if k == 0 && num % 10 != 0 {return -1}\\n    for i := 1; i * k <= num; i++ {\\n        if (num - i * k) % 10 == 0 {return i}\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200493,
                "title": "c-golang-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        vector<int> DP(num + 1, 1e9);\\n        DP[0] = 0;\\n        for(int i = k; i <= num; i += 10) {\\n            for(int j = i; j <= num; j++) {\\n                DP[j] = min(DP[j], DP[j - i] + 1);\\n            }\\n        }\\n        return DP[num] == 1e9? -1: DP[num];\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumNumbers(num int, k int) int {\\n    DP := make([]int, num + 1) \\n    for i := 0; i <= num; i++ {DP[i] = 1e9}\\n    DP[0] = 0\\n    for i := k; i <= num; i += 10 {\\n        for j := i; j <= num; j++ {\\n            if DP[j - i] + 1 < DP[j] {\\n                DP[j] = DP[j - i] + 1\\n            }\\n        }\\n    }\\n    if DP[num] == 1e9 {return -1}\\n    return DP[num]\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        vector<int> DP(num + 1, 1e9);\\n        DP[0] = 0;\\n        for(int i = k; i <= num; i += 10) {\\n            for(int j = i; j <= num; j++) {\\n                DP[j] = min(DP[j], DP[j - i] + 1);\\n            }\\n        }\\n        return DP[num] == 1e9? -1: DP[num];\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumNumbers(num int, k int) int {\\n    DP := make([]int, num + 1) \\n    for i := 0; i <= num; i++ {DP[i] = 1e9}\\n    DP[0] = 0\\n    for i := k; i <= num; i += 10 {\\n        for j := i; j <= num; j++ {\\n            if DP[j - i] + 1 < DP[j] {\\n                DP[j] = DP[j - i] + 1\\n            }\\n        }\\n    }\\n    if DP[num] == 1e9 {return -1}\\n    return DP[num]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197147,
                "title": "c-solution-using-recursion",
                "content": "# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int num,int k,int size,int sum,vector<vector<int>>&dp){\\n        if(sum>num || k>num) return 1e9;\\n        if(num==sum){\\n            return size;\\n        }\\n        if(dp[k][sum]!=-1) return dp[k][sum];\\n        int t=1e9,nt=1e9; \\n           t=f(num,k+10,size,sum,dp);\\n        \\n        if(k <=num && k!=0 && sum+k<=num){\\n           nt=f(num,k,size+1,sum+k,dp);\\n        }   \\n        return dp[k][sum]=min(t,nt);\\n    }\\n    int minimumNumbers(int num, int k){\\n        if(num==k && num!=0) return 1;\\n        if(num==k || num==0) return 0;\\n        vector<vector<int>>dp(num+1,vector<int>(num+1,-1));\\n        int temp=f(num,k,0,0,dp);\\n        if(temp>=1e9) return -1;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int num,int k,int size,int sum,vector<vector<int>>&dp){\\n        if(sum>num || k>num) return 1e9;\\n        if(num==sum){\\n            return size;\\n        }\\n        if(dp[k][sum]!=-1) return dp[k][sum];\\n        int t=1e9,nt=1e9; \\n           t=f(num,k+10,size,sum,dp);\\n        \\n        if(k <=num && k!=0 && sum+k<=num){\\n           nt=f(num,k,size+1,sum+k,dp);\\n        }   \\n        return dp[k][sum]=min(t,nt);\\n    }\\n    int minimumNumbers(int num, int k){\\n        if(num==k && num!=0) return 1;\\n        if(num==k || num==0) return 0;\\n        vector<vector<int>>dp(num+1,vector<int>(num+1,-1));\\n        int temp=f(num,k,0,0,dp);\\n        if(temp>=1e9) return -1;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188129,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int rec(int num,int k,int dig, vector<vector<int>>&dp,int t)\\n   {\\n       if (num==0) return 0;\\n       if ((num%10)==t) return 1;\\n       if (dp[num][dig]!=-1) return dp[num][dig];\\n       int t2=1e7;\\n       if (num-k>=0)\\n       {\\n         t2=1+rec(num-k,k,dig,dp,t);\\n       }\\n        int cur=pow(10,dig);\\n       for (int i=1;i<=9;i++)\\n       {\\n           int temp=i*cur+k;\\n           if(num-temp>=0)\\n           t2=min(t2,1+rec(num-temp,temp,dig+1,dp,t));\\n       }\\n       return dp[num][dig]=t2;\\n   }\\n    int minimumNumbers(int num, int k) \\n    {\\n        if (k==0 && num==0) return 0;\\n        if (k==0 && num%10==0)\\n        {\\n            return 1;\\n        }\\n        if(k==0) return -1;\\n        if ((num%10)==k) return 1;\\n        vector<vector<int>>dp(num+1,vector<int>(1000,-1));\\n        int temp=rec(num,k,1,dp,k);\\n        if (temp>=1e7) return -1;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int rec(int num,int k,int dig, vector<vector<int>>&dp,int t)\\n   {\\n       if (num==0) return 0;\\n       if ((num%10)==t) return 1;\\n       if (dp[num][dig]!=-1) return dp[num][dig];\\n       int t2=1e7;\\n       if (num-k>=0)\\n       {\\n         t2=1+rec(num-k,k,dig,dp,t);\\n       }\\n        int cur=pow(10,dig);\\n       for (int i=1;i<=9;i++)\\n       {\\n           int temp=i*cur+k;\\n           if(num-temp>=0)\\n           t2=min(t2,1+rec(num-temp,temp,dig+1,dp,t));\\n       }\\n       return dp[num][dig]=t2;\\n   }\\n    int minimumNumbers(int num, int k) \\n    {\\n        if (k==0 && num==0) return 0;\\n        if (k==0 && num%10==0)\\n        {\\n            return 1;\\n        }\\n        if(k==0) return -1;\\n        if ((num%10)==k) return 1;\\n        vector<vector<int>>dp(num+1,vector<int>(1000,-1));\\n        int temp=rec(num,k,1,dp,k);\\n        if (temp>=1e7) return -1;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177797,
                "title": "c",
                "content": "```\\nint minimumNumbers(int num, int k){\\n    if(num == 0)\\n        return 0 ;\\n    int data[11] ;\\n    for(int i = 1; i <= 10; i++){\\n        data[i] = (k*i)%10 ;\\n    }\\n    int m = num % 10 ;\\n    for(int i = 1; i <= 10; i++){\\n        if(m == data[i] && num >= k*i)\\n            return i ;\\n    }\\n    return -1 ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumNumbers(int num, int k){\\n    if(num == 0)\\n        return 0 ;\\n    int data[11] ;\\n    for(int i = 1; i <= 10; i++){\\n        data[i] = (k*i)%10 ;\\n    }\\n    int m = num % 10 ;\\n    for(int i = 1; i <= 10; i++){\\n        if(m == data[i] && num >= k*i)\\n            return i ;\\n    }\\n    return -1 ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3138580,
                "title": "c-easy-fast-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(num*num)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(num*num)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int num,int curr,int k,int n,vector<vector<int>> &dp)\\n    {\\n        if(num%10==k and curr%10==k and num!=n)\\n        return 2;\\n\\n        if(num<=0)\\n        return 1e9;\\n\\n        if(curr>=num)\\n        return 1e9;\\n        \\n        if(dp[num][curr]!=-1)\\n        return dp[num][curr];\\n\\n        int take=1+solve(num-k,k,k,n,dp);\\n        int nottake=solve(num-10,curr+10,k,n,dp);\\n\\n        return dp[num][curr]=min(take,nottake);\\n    }\\n    int minimumNumbers(int num, int k) {\\n        if(k%2==0 and num%2!=0)\\n        return -1;\\n\\n        if(num%10==k and num!=0)\\n        return 1;\\n\\n        if(num!=0 and k==0)\\n        return -1;\\n\\n        if(num==0 || k==0)\\n        return 0;\\n\\n\\n        vector<vector<int>> dp(num+1,vector<int>(num+1,-1));\\n        int ans=solve(num-k,k,k,num,dp);\\n\\n        if(ans!=1e9)\\n        return ans;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int num,int curr,int k,int n,vector<vector<int>> &dp)\\n    {\\n        if(num%10==k and curr%10==k and num!=n)\\n        return 2;\\n\\n        if(num<=0)\\n        return 1e9;\\n\\n        if(curr>=num)\\n        return 1e9;\\n        \\n        if(dp[num][curr]!=-1)\\n        return dp[num][curr];\\n\\n        int take=1+solve(num-k,k,k,n,dp);\\n        int nottake=solve(num-10,curr+10,k,n,dp);\\n\\n        return dp[num][curr]=min(take,nottake);\\n    }\\n    int minimumNumbers(int num, int k) {\\n        if(k%2==0 and num%2!=0)\\n        return -1;\\n\\n        if(num%10==k and num!=0)\\n        return 1;\\n\\n        if(num!=0 and k==0)\\n        return -1;\\n\\n        if(num==0 || k==0)\\n        return 0;\\n\\n\\n        vector<vector<int>> dp(num+1,vector<int>(num+1,-1));\\n        int ans=solve(num-k,k,k,num,dp);\\n\\n        if(ans!=1e9)\\n        return ans;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133032,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int minimumNumbers(int num, int k) {\\n    if (num == 0)\\n      return 0;\\n\\n    for (int i = 1; i <= 10 && i * k <= num; ++i)\\n      if (i * k % 10 == num % 10)\\n        return i;\\n\\n    return -1;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n\\n        if num==0:\\n            return 0\\n\\n        possible_end_digits=set([i*k%10 for i in range(10)])\\n        \\n        if num%10 not in possible_end_digits:\\n            return -1\\n\\n        possible_outputs=list(set([i for i in range(1,11) if i*k%10 == num%10 and i*k<=num]))\\n        if len(possible_outputs)==0:\\n            return -1\\n        else:\\n            return min(possible_outputs)\\n```\\n\\n```Java []\\nclass Solution\\n{\\n    public int minimumNumbers(int num, int k)\\n    {\\n        if(num == 0)\\n            return 0;\\n        if(k == 0)\\n            if(num % 10 == 0) //E.g. 20,1590,3000\\n                return 1;\\n            else\\n                return -1;\\n        for(int i = 1; i <= num/k; i++)\\n            if(num % 10 == ((i*k)%10))\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int minimumNumbers(int num, int k) {\\n    if (num == 0)\\n      return 0;\\n\\n    for (int i = 1; i <= 10 && i * k <= num; ++i)\\n      if (i * k % 10 == num % 10)\\n        return i;\\n\\n    return -1;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n\\n        if num==0:\\n            return 0\\n\\n        possible_end_digits=set([i*k%10 for i in range(10)])\\n        \\n        if num%10 not in possible_end_digits:\\n            return -1\\n\\n        possible_outputs=list(set([i for i in range(1,11) if i*k%10 == num%10 and i*k<=num]))\\n        if len(possible_outputs)==0:\\n            return -1\\n        else:\\n            return min(possible_outputs)\\n```\n```Java []\\nclass Solution\\n{\\n    public int minimumNumbers(int num, int k)\\n    {\\n        if(num == 0)\\n            return 0;\\n        if(k == 0)\\n            if(num % 10 == 0) //E.g. 20,1590,3000\\n                return 1;\\n            else\\n                return -1;\\n        for(int i = 1; i <= num/k; i++)\\n            if(num % 10 == ((i*k)%10))\\n                return i;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131078,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn minimum_numbers(num: i32, k: i32) -> i32 {\\n    if num == 0 {\\n      return 0\\n    }\\n    if k == 0 {\\n      return if num % 10 == 0 {\\n        1\\n      } else {\\n        -1\\n      }\\n    }\\n\\n    let one = num % 10;\\n    for i in 1..=3000 {\\n      if one == i * k % 10 && num >= i*k {\\n        return i\\n      }\\n    }\\n    -1\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn minimum_numbers(num: i32, k: i32) -> i32 {\\n    if num == 0 {\\n      return 0\\n    }\\n    if k == 0 {\\n      return if num % 10 == 0 {\\n        1\\n      } else {\\n        -1\\n      }\\n    }\\n\\n    let one = num % 10;\\n    for i in 1..=3000 {\\n      if one == i * k % 10 && num >= i*k {\\n        return i\\n      }\\n    }\\n    -1\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099472,
                "title": "easy-c-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach greedy approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)\\n        return 0;\\n        int c=0,p,i;\\n        for(i=0;i<=9;i++){\\n             c=c+k;\\n            \\n            if(num%10==c%10){\\n                num=num-c;\\n                break;\\n            }\\n            else if(num<c){\\n                return -1;\\n            }\\n        }\\n        if(i==10)\\n        return -1;\\n        else\\n        return i+1;\\n        \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0)\\n        return 0;\\n        int c=0,p,i;\\n        for(i=0;i<=9;i++){\\n             c=c+k;\\n            \\n            if(num%10==c%10){\\n                num=num-c;\\n                break;\\n            }\\n            else if(num<c){\\n                return -1;\\n            }\\n        }\\n        if(i==10)\\n        return -1;\\n        else\\n        return i+1;\\n        \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068781,
                "title": "c-beats-100-o-1",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n\\n        if(num==0){\\n            return 0;\\n        }\\n        if(num<k)\\n            return -1;\\n\\n        for(int i=1;i<=10;++i){\\n            if((k*i)%10 == num%10){\\n                if(num<k*i){\\n                    continue;\\n                }\\n                return i;\\n            }\\n        }\\n\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n\\n        if(num==0){\\n            return 0;\\n        }\\n        if(num<k)\\n            return -1;\\n\\n        for(int i=1;i<=10;++i){\\n            if((k*i)%10 == num%10){\\n                if(num<k*i){\\n                    continue;\\n                }\\n                return i;\\n            }\\n        }\\n\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063162,
                "title": "java-dp-memoization",
                "content": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        if(num == 0){\\n            return 0;\\n        }\\n        \\n        //create the list of all possiblities\\n        while(k<=num){\\n            if(k!=0)list.add(k);\\n            k+=10;\\n        }\\n        \\n        //dp\\n        int[][] dp = new int[num+1][list.size()];\\n        \\n        for(int[] arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        return getMin(num,list,0,0,dp) == Integer.MAX_VALUE ? -1 : getMin(num,list,0,0,dp);\\n        \\n    }\\n    \\n    \\n    public int getMin(int num,List<Integer> list,int ind,int step,int dp[][]){\\n        if(num == 0){\\n            return step;\\n        }\\n        \\n        if(num < 0 || ind > list.size() - 1){\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        if(dp[num][ind] != -1){\\n            return dp[num][ind];\\n        }\\n        \\n        //if index taken then step+=1 and index will be the same\\n        int take = getMin(num-list.get(ind),list,ind,step+1,dp);\\n        //if index not taken ind+=1 but step remains same\\n        int notTake = getMin(num,list,ind+1,step,dp);\\n        \\n        return dp[num][ind] = Math.min(take,notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        if(num == 0){\\n            return 0;\\n        }\\n        \\n        //create the list of all possiblities\\n        while(k<=num){\\n            if(k!=0)list.add(k);\\n            k+=10;\\n        }\\n        \\n        //dp\\n        int[][] dp = new int[num+1][list.size()];\\n        \\n        for(int[] arr:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        return getMin(num,list,0,0,dp) == Integer.MAX_VALUE ? -1 : getMin(num,list,0,0,dp);\\n        \\n    }\\n    \\n    \\n    public int getMin(int num,List<Integer> list,int ind,int step,int dp[][]){\\n        if(num == 0){\\n            return step;\\n        }\\n        \\n        if(num < 0 || ind > list.size() - 1){\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        if(dp[num][ind] != -1){\\n            return dp[num][ind];\\n        }\\n        \\n        //if index taken then step+=1 and index will be the same\\n        int take = getMin(num-list.get(ind),list,ind,step+1,dp);\\n        //if index not taken ind+=1 but step remains same\\n        int notTake = getMin(num,list,ind+1,step,dp);\\n        \\n        return dp[num][ind] = Math.min(take,notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019777,
                "title": "a-math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOriginally, I try to enumerate every combination of a series. However, time exceeded. Then I start to think any possible method to reduce those numbers of possible combination. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFinally, I found this is a math problem. num = a * 10 + b * k\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nint minimumNumbers(int num, int k){\\n\\tif(num == 0){return 0;}\\n    int iCon;\\n    int iResult = 4000;\\n    for(iCon = 0 ; iCon <= num / 10 ; iCon++){\\n        int iTemp = num - iCon * 10;\\n        int iRequire = 4000;\\n        if(k){\\n            if(!iTemp || iTemp % k){\\n                continue;\\n            }else{\\n                iRequire = iTemp / k;\\n            }\\n        }else{\\n            if(iTemp % 10){\\n                continue;\\n            }else{\\n                iRequire = 1;\\n            }\\n        }       \\n        if(iRequire < iResult){\\n            iResult = iRequire;\\n        }        \\n    }\\n    if(iResult == 4000){return -1;}\\n    return iResult;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumNumbers(int num, int k){\\n\\tif(num == 0){return 0;}\\n    int iCon;\\n    int iResult = 4000;\\n    for(iCon = 0 ; iCon <= num / 10 ; iCon++){\\n        int iTemp = num - iCon * 10;\\n        int iRequire = 4000;\\n        if(k){\\n            if(!iTemp || iTemp % k){\\n                continue;\\n            }else{\\n                iRequire = iTemp / k;\\n            }\\n        }else{\\n            if(iTemp % 10){\\n                continue;\\n            }else{\\n                iRequire = 1;\\n            }\\n        }       \\n        if(iRequire < iResult){\\n            iResult = iRequire;\\n        }        \\n    }\\n    if(iResult == 4000){return -1;}\\n    return iResult;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3004906,
                "title": "c-dp-memoization-o-n-target",
                "content": "```\\nclass Solution {\\npublic:\\n    long long helper(int i,vector<int>&arr,int target,int n,vector<vector<int>>&dp){\\n        \\n        if(target==0){\\n            return 0;\\n        }\\n        if(i>=n){\\n            return 1e9;\\n        }\\n        if(i==n-1){\\n           if(arr[i]!=0 && target%arr[i]==0){\\n               return (target/arr[i]);\\n           }\\n            return 1e9;\\n        }\\n        if(dp[i][target]!=-1){\\n            return dp[i][target];\\n        }\\n        long long nottake=helper(i+1,arr,target,n,dp);\\n        long long take=1e9;\\n        if(arr[i]<=target){\\n            \\n            take=1+helper(i,arr,target-arr[i],n,dp);\\n        }\\n        long long ans=min(take,nottake);\\n        return dp[i][target]=ans;\\n    }\\n    int minimumNumbers(int num, int k) {\\n        \\n        vector<int> arr;\\n        for(int i=k;i<=num;i=i+10){\\n            \\n            if(i!=0){\\n              arr.push_back(i);\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            cout<<arr[i]<<\" \";\\n        }\\n        int n=arr.size();\\n        int target=num;\\n        vector<vector<int>> dp(n,vector<int>(target+1,-1));\\n        long long ans=helper(0,arr,target,n,dp);\\n        if(ans>=1e9){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    long long helper(int i,vector<int>&arr,int target,int n,vector<vector<int>>&dp){\\n        \\n        if(target==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3000574,
                "title": "python3-solution-using-math",
                "content": "\\n```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0:\\n            return 0\\n        for i in range(1,11):\\n            if(k*i)%10==num%10 and (k*i)<=num:\\n                return i\\n        return -1    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num==0:\\n            return 0\\n        for i in range(1,11):\\n            if(k*i)%10==num%10 and (k*i)<=num:\\n                return i\\n        return -1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987407,
                "title": "13-line-easy-and-greedy-approach-c-o-k-time-faster-than-100",
                "content": "# Approach\\n- The Naive approach would be to first eliminate the cases where either or both *num* and *k* are equal to 0 then we observe the cases where we actually get an output. If the unit digit of *num*=k then there\\'s no need to proceed any further and we push its value to our *ans* vector else we subtract *k* from *num* and continue this process *while num>0* and after this process if *num!=0* then there\\'s no valid set of such numbers else we return the size of the *ans* vector.\\n# Complexity\\n- Time complexity:\\nO(k) Time complexity, since we iterate from num to 0, k number of times \\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumNumbers(int num, int k) {\\n        vector<int> ans;\\n        if(num==0) return 0;\\n        if(k==0)\\n            if(num%10==0) return 1;\\n            else return -1;\\n        while(num>0){\\n            if(num%10==k){\\n                ans.push_back(num);\\n                return ans.size();\\n            }\\n            else\\n                ans.push_back(k);\\n                num-=k;\\n        }\\n        if(num==0) return ans.size();\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int minimumNumbers(int num, int k) {\\n        vector<int> ans;\\n        if(num==0) return 0;\\n        if(k==0)\\n            if(num%10==0) return 1;\\n            else return -1;\\n        while(num>0){\\n            if(num%10==k){\\n                ans.push_back(num);\\n                return ans.size();\\n            }\\n            else\\n                ans.push_back(k);\\n                num-=k;\\n        }\\n        if(num==0) return ans.size();\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917325,
                "title": "cpp-must-see-easy-to-understand-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int val = 5000;\\n    vector<int>dp;\\n    int minimumNumbers(int num, int k) \\n\\t{\\n        dp.resize(num+1,-1);\\n        //simulation with dynamic programming \\n\\t\\t//trying all the possible path to make the smallest possible set\\n\\t\\tint x =fun(num,k);          \\n        \\n        if(x>=val)\\n        return -1;\\n\\n        return x;\\n    }\\n    int fun(int num,int &k)\\n    {\\n  \\t    if(num==0 and k==0)\\n  \\t    {\\n  \\t       //{0} set_size == 1\\n  \\t       //positive integet \\n  \\t       //0 is considered not as positvie and negative\\n  \\t       \\n  \\t       //only sol is {}\\n  \\t       return 0;\\n        }\\n        else if(num==0 and k > 0)  //*\\n        {\\n        \\treturn 0;\\n\\t\\t}\\n        if(dp[num]!=-1) return dp[num];\\n    \\tint set_size = val;\\n   \\t    for(int i=num;i>=1;i--)\\n   \\t    {\\n  \\t        //if the curr num has the unit digit k then we can try it\\n\\t\\t\\tif((i%10)==k and (num-i)>=0)\\n\\t\\t\\t{\\n                int size = 1 + fun(num-i,k);\\n\\n                if(size < set_size)\\n                {\\n                \\tset_size = size;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\n\\t    }\\n\\t    return dp[num] = set_size;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int val = 5000;\\n    vector<int>dp;\\n    int minimumNumbers(int num, int k) \\n\\t{\\n        dp.resize(num+1,-1);\\n        //simulation with dynamic programming \\n\\t\\t//trying all the possible path to make the smallest possible set\\n\\t\\tint x =fun(num,k);          \\n        \\n        if(x>=val)\\n        return -1;\\n\\n        return x;\\n    }\\n    int fun(int num,int &k)\\n    {\\n  \\t    if(num==0 and k==0)\\n  \\t    {\\n  \\t       //{0} set_size == 1\\n  \\t       //positive integet \\n  \\t       //0 is considered not as positvie and negative\\n  \\t       \\n  \\t       //only sol is {}\\n  \\t       return 0;\\n        }\\n        else if(num==0 and k > 0)  //*\\n        {\\n        \\treturn 0;\\n\\t\\t}\\n        if(dp[num]!=-1) return dp[num];\\n    \\tint set_size = val;\\n   \\t    for(int i=num;i>=1;i--)\\n   \\t    {\\n  \\t        //if the curr num has the unit digit k then we can try it\\n\\t\\t\\tif((i%10)==k and (num-i)>=0)\\n\\t\\t\\t{\\n                int size = 1 + fun(num-i,k);\\n\\n                if(size < set_size)\\n                {\\n                \\tset_size = size;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\n\\t    }\\n\\t    return dp[num] = set_size;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916850,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumNumbers(int num, int k) {\\n        if(k==0 and num%10!=0)\\n        {\\n            return -1;\\n        }\\n        if(k==0 and num>0 and num%10==0)\\n        {\\n            return 1;\\n        }\\n        vector<int>arr;\\n        for(int i=0;i<=num;i++)\\n        {\\n            if(i%10==k)\\n            {\\n                arr.push_back(i);\\n            }\\n        }\\n        dp.resize(arr.size()+1,vector<int>(num+10,-1));\\n        int ans=fun(arr,0,num,0);\\n        if(ans>=3004)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    int fun(vector<int>&arr,int i,int &sum,int s)\\n    {\\n        if(i>=arr.size() and sum==s)\\n        {\\n            return 0;\\n        }\\n        if(i>=arr.size() and sum>s)\\n        {\\n            return 3004;\\n        }\\n        if(sum<s)\\n        {\\n            return 3004;\\n        }\\n        if(s==sum)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][s]!=-1) return dp[i][s];\\n        return dp[i][s]=min(1+fun(arr,i,sum,s+arr[i]),fun(arr,i+1,sum,s));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumNumbers(int num, int k) {\\n        if(k==0 and num%10!=0)\\n        {\\n            return -1;\\n        }\\n        if(k==0 and num>0 and num%10==0)\\n        {\\n            return 1;\\n        }\\n        vector<int>arr;\\n        for(int i=0;i<=num;i++)\\n        {\\n            if(i%10==k)\\n            {\\n                arr.push_back(i);\\n            }\\n        }\\n        dp.resize(arr.size()+1,vector<int>(num+10,-1));\\n        int ans=fun(arr,0,num,0);\\n        if(ans>=3004)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    int fun(vector<int>&arr,int i,int &sum,int s)\\n    {\\n        if(i>=arr.size() and sum==s)\\n        {\\n            return 0;\\n        }\\n        if(i>=arr.size() and sum>s)\\n        {\\n            return 3004;\\n        }\\n        if(sum<s)\\n        {\\n            return 3004;\\n        }\\n        if(s==sum)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][s]!=-1) return dp[i][s];\\n        return dp[i][s]=min(1+fun(arr,i,sum,s+arr[i]),fun(arr,i+1,sum,s));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911651,
                "title": "explained-using-simple-math-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        \\n        // Edge Cases\\n        // if num is 0 then we don\\'t need any number hence size is 0\\n        // if k == 0 means unit digit should be 0 hence if num has unit digit 0 then num itself will be the answer hence size 1 else we can not make num hence answer will be -1\\n        \\n        // If we take size n then unit digits will be k of all the elements. \\n\\t\\t// If we sum of the elements then unit digit of sum will (k * size) % 10. \\n\\t\\t// Hence if we have unit digit == k then size will be the answer. \\n\\t\\t// We will try by taking minimum size as 1,2,3 and so on so that we could find the minimum possible size.\\n        \\n        if(num == 0) return 0;\\n        \\n        if(k == 0) {\\n            return num % 10 == 0 ? 1 : -1;\\n        }\\n        \\n        for(int i = 1; i * k <= num; i++) {\\n            if((i * k) % 10 == num % 10) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        \\n        // Edge Cases\\n        // if num is 0 then we don\\'t need any number hence size is 0\\n        // if k == 0 means unit digit should be 0 hence if num has unit digit 0 then num itself will be the answer hence size 1 else we can not make num hence answer will be -1\\n        \\n        // If we take size n then unit digits will be k of all the elements. \\n\\t\\t// If we sum of the elements then unit digit of sum will (k * size) % 10. \\n\\t\\t// Hence if we have unit digit == k then size will be the answer. \\n\\t\\t// We will try by taking minimum size as 1,2,3 and so on so that we could find the minimum possible size.\\n        \\n        if(num == 0) return 0;\\n        \\n        if(k == 0) {\\n            return num % 10 == 0 ? 1 : -1;\\n        }\\n        \\n        for(int i = 1; i * k <= num; i++) {\\n            if((i * k) % 10 == num % 10) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839325,
                "title": "coin-change-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        vector<int> res;\\n        for(int i=0; i<=num; i++)\\n            if(i%10 == k) res.push_back(i);\\n        \\n        int n = res.size();\\n        vector<int> dp(num+1, INT_MAX-1);\\n        dp[0] = 0;\\n        for(int i=0; i<=num; i++){\\n            for(int j=0; j<n; j++){\\n                if(res[j] <= i){\\n                    dp[i] = min(dp[i], 1+dp[i-res[j]]);\\n                }\\n            }\\n        }\\n        \\n        return dp[num]==INT_MAX-1? -1: dp[num];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        vector<int> res;\\n        for(int i=0; i<=num; i++)\\n            if(i%10 == k) res.push_back(i);\\n        \\n        int n = res.size();\\n        vector<int> dp(num+1, INT_MAX-1);\\n        dp[0] = 0;\\n        for(int i=0; i<=num; i++){\\n            for(int j=0; j<n; j++){\\n                if(res[j] <= i){\\n                    dp[i] = min(dp[i], 1+dp[i-res[j]]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2816120,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumNumbers(self, num, k):\\n        if num == 0:\\n            return 0\\n\\n        if num < k:\\n            return -1\\n\\n        for i in range(1,11):\\n            if (i*k)%10 == num%10 and i*k <= num:\\n                return i \\n\\n        return -1\\n\\n        \\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num, k):\\n        if num == 0:\\n            return 0\\n\\n        if num < k:\\n            return -1\\n\\n        for i in range(1,11):\\n            if (i*k)%10 == num%10 and i*k <= num:\\n                return i \\n\\n        return -1\\n\\n        \\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767259,
                "title": "python-wacky-o-1-maths-solution-no-loops",
                "content": "# Approach\\nSuppose the number we are trying to create is $$b$$. We are essentially looking for solutions to the congruence $$kn \\\\equiv b\\\\mod 10$$. If anyone is interested in a further explanation and proof, I\\'d be glad to write one up. Let me know. \\n\\n# Complexity\\n- Time complexity:\\nO(1)\\nThe function gcd(k,10) runs in O(log 10) time.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__ (self):\\n        self.params = [None, (1,10), (3,5), (7,10), (4,5), None, (1,5), (3,10), (2,5), (9,10)]\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n\\n        if num == 0:\\n            return 0\\n\\n        # Is there a solution?\\n        d = gcd(k,10)\\n        if num % d:\\n            return -1\\n\\n        if k == 0:\\n            return 1\\n        if k == 5:\\n            if num % 10 == 0:\\n                return 2\\n            else:\\n                return 1\\n\\n        min_needed = (num * self.params[k][0]) % self.params[k][1]\\n        if min_needed == 0:\\n            min_needed = self.params[k][1]\\n            \\n        return min_needed if min_needed * k <= num else -1\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__ (self):\\n        self.params = [None, (1,10), (3,5), (7,10), (4,5), None, (1,5), (3,10), (2,5), (9,10)]\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n\\n        if num == 0:\\n            return 0\\n\\n        # Is there a solution?\\n        d = gcd(k,10)\\n        if num % d:\\n            return -1\\n\\n        if k == 0:\\n            return 1\\n        if k == 5:\\n            if num % 10 == 0:\\n                return 2\\n            else:\\n                return 1\\n\\n        min_needed = (num * self.params[k][0]) % self.params[k][1]\\n        if min_needed == 0:\\n            min_needed = self.params[k][1]\\n            \\n        return min_needed if min_needed * k <= num else -1\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761811,
                "title": "c-greedy-easy-understand-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0){\\n            return 0;\\n        }\\n        unordered_map<int,int> mp;\\n        int d=k,i=1;\\n\\t\\t// store unit place digit of multiple of k until it getting repeated\\n        while(mp.find(d)==mp.end()){\\n            mp[d]=i;\\n            d+=k;\\n            d=d%10;\\n            i++;\\n        }\\n\\t\\t// if num doesn\\'t appear in map then sum is not possible\\n        if(mp.find(num%10)==mp.end()){\\n            return -1;\\n        }\\n\\t\\t// if sum is less than minimun val required to make that unit value of num then it is not possible\\n        if(num<mp[num%10]*k){\\n            return -1;\\n        }\\n\\t\\t// minimum val required to make that unit place\\n        return mp[num%10];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        if(num==0){\\n            return 0;\\n        }\\n        unordered_map<int,int> mp;\\n        int d=k,i=1;\\n\\t\\t// store unit place digit of multiple of k until it getting repeated\\n        while(mp.find(d)==mp.end()){\\n            mp[d]=i;\\n            d+=k;\\n            d=d%10;\\n            i++;\\n        }\\n\\t\\t// if num doesn\\'t appear in map then sum is not possible\\n        if(mp.find(num%10)==mp.end()){\\n            return -1;\\n        }\\n\\t\\t// if sum is less than minimun val required to make that unit value of num then it is not possible\\n        if(num<mp[num%10]*k){\\n            return -1;\\n        }\\n\\t\\t// minimum val required to make that unit place\\n        return mp[num%10];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752702,
                "title": "python-simple-math-based-solution",
                "content": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        for i in range(1, 11):\\n            if (i * k) % 10 == num % 10 and i * k <= num: \\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimumNumbers(self, num: int, k: int) -> int:\\n        if num == 0:\\n            return 0\\n        for i in range(1, 11):\\n            if (i * k) % 10 == num % 10 and i * k <= num: \\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748107,
                "title": "java-o-1-modular-arithmetic",
                "content": "\\nAny number n can be written as `n = last digit + sum of multiples of 10`. For instance, `1234 = 1000 + 100 + 100 + 10 + 10 + 10 + 4`\\n we just need to check whether multiples of k can resolve for the last digit of n.\\n```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n                \\n        int lastDigit = num % 10;\\n        \\n        for (int i = 1; i <= 10; i++) {\\n            if (k * i <= num && (k * i)  % 10 == lastDigit) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumNumbers(int num, int k) {\\n        if (num == 0) return 0;\\n                \\n        int lastDigit = num % 10;\\n        \\n        for (int i = 1; i <= 10; i++) {\\n            if (k * i <= num && (k * i)  % 10 == lastDigit) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729063,
                "title": "c-java-math-logical-solution",
                "content": "# Please Upvote if Understandable.\\n\\n**Note 1 :- This Question Can Also be Done Using DP ( Application of Minimum coin Change Problem)**\\n\\n**Note 2:- Please Use Pen and Paper.**\\n\\n\\n**Intution**\\n* Think of this Probelm as that if Last Digit is multiple of k\\n\\t* That is let say , 54676767X     and k= y\\n\\t* if u Use Pen and Paper U Will find that if Last digit is Same as Last Digit of all possible value for Table k\\n\\n\\t * if X=6  and k=9\\n\\t\\t * we know that in Table of 9 ,  ---{ 9, 18 , 27 , 36 , 45, 54, 63 , 72 , 81 , 90 }\\n\\n\\t\\t *  if Last Digit of Answer Matches Last digit of Table of 9 then  ans will be the Position where \\n\\n\\t\\t\\t  *    **(K * i )%10    is lst Digit of kth Table === lst digit of Num**\\n\\t\\t\\t  *    **then ans=i     else -1 if no digit matches**\\n\\n* U can Come up With This Observation Also  :-\\n\\t* **Use Pen and Paper and Try to  subtract number Num by k   i times  [Where i= position where\\n\\tAbove Condition satisfied** \\n* for corner Case i Dont think i  Need to Explain\\n\\t* if num==0  then 0;\\n\\t* if   num < k   then -1;\\n\\t* if  k==0 , then if last digit  of num Must be 0  i.e , **num%10==0** otherwise -1;  \\n```\\nclass Solution {\\npublic:\\n\\n    int minimumNumbers(int num, int k) {\\n \\n        if(num == 0) return 0;\\n        \\n        if (k == 0) return num % 10 == 0 ? 1 : -1;\\n        \\n        if (num % 10 == k) return 1;\\n       \\n        for (int i = 1; i <= num / k && i<=10; i++){\\n            \\n            if (num % 10 == ((i * k) % 10)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumNumbers(int num, int k) {\\n \\n        if(num == 0) return 0;\\n        \\n        if (k == 0) return num % 10 == 0 ? 1 : -1;\\n        \\n        if (num % 10 == k) return 1;\\n       \\n        for (int i = 1; i <= num / k && i<=10; i++){\\n            \\n            if (num % 10 == ((i * k) % 10)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727969,
                "title": "no-dp-simple-math-just-check-for-divisiblity-100-faster-upvote-if-you-llike-my-solution",
                "content": "\\'\\'\\'\\'\\n\\n\\n\\nint minimumNumbers(int num, int k) {\\n        \\n        if( num == 0 ) return 0  ;\\n        if( num < k  ) return -1 ;\\n        int r = num%10 ;\\n        \\n        bool ans = false ;\\n        \\n        for( int i = 1 ; i <= 10 ; i++ )\\n        {\\n             if( ( k*i )%10 == r && (k*i) <= num )\\n             {\\n                 ans = true ;\\n                 return i ;\\n             }\\n        }\\n        \\n        return -1 ;\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\'\\n\\n\\n\\nint minimumNumbers(int num, int k) {\\n        \\n        if( num == 0 ) return 0  ;\\n        if( num < k  ) return -1 ;\\n        int r = num%10 ;\\n        \\n        bool ans = false ;\\n        \\n        for( int i = 1 ; i <= 10 ; i++ )\\n        {\\n             if( ( k*i )%10 == r && (k*i) <= num )\\n             {\\n                 ans = true ;\\n                 return i ;\\n             }\\n        }\\n        \\n        return -1 ;\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2716799,
                "title": "c-solution-recursive-approach-dp-dfs",
                "content": "```\\npublic class Solution {\\n    public int MinimumNumbers(int num, int k) {\\n        int[] dp = new int[num+1];\\n        \\n        Array.Fill(dp, -1);\\n        \\n        int res = MinimumNumbers(num, k, 0, dp);\\n        return res == int.MaxValue ? -1 : res;\\n    }\\n    \\n    private int MinimumNumbers(int num, int k, int size, int[] dp){\\n        if(num < 0){\\n            return int.MaxValue;            \\n        }\\n        \\n        if(num == 0)\\n            return size;\\n        \\n        if(dp[num] != -1)\\n            return dp[num];\\n        \\n        int num1 = k != 0 ? k : 10;\\n        int counter = 1;\\n        int res = int.MaxValue;\\n        \\n        while(num1 <= num){\\n            res = Math.Min(res, MinimumNumbers(num-num1, k, size+1, dp));\\n            num1 = (10*counter) + k;\\n            counter++;\\n        }\\n        \\n        dp[num] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumNumbers(int num, int k) {\\n        int[] dp = new int[num+1];\\n        \\n        Array.Fill(dp, -1);\\n        \\n        int res = MinimumNumbers(num, k, 0, dp);\\n        return res == int.MaxValue ? -1 : res;\\n    }\\n    \\n    private int MinimumNumbers(int num, int k, int size, int[] dp){\\n        if(num < 0){\\n            return int.MaxValue;            \\n        }\\n        \\n        if(num == 0)\\n            return size;\\n        \\n        if(dp[num] != -1)\\n            return dp[num];\\n        \\n        int num1 = k != 0 ? k : 10;\\n        int counter = 1;\\n        int res = int.MaxValue;\\n        \\n        while(num1 <= num){\\n            res = Math.Min(res, MinimumNumbers(num-num1, k, size+1, dp));\\n            num1 = (10*counter) + k;\\n            counter++;\\n        }\\n        \\n        dp[num] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712092,
                "title": "depth-first-search-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    int minVal = (int) 1e9;\\n    public int MinimumNumbers(int num, int k) {\\n        //first find all unit digits and add it to the list ds\\n        List<int> ds = new List<int>();\\n        int l = 0;\\n        while(l <=num)\\n        {\\n            if(l%10 == k)\\n                ds.Add(l);\\n            l++;\\n        }\\n        if(num == 0) return 0;\\n        else if(k == 0 && num%10==0) return 1;\\n        else if(k==0 && num%10 != 0) return -1;\\n        List<int> ls = new List<int>();\\n        bool[] visited = new bool[num+1];\\n        dfs(ds,num,ls,visited);\\n        if(minVal == (int)1e9) return -1;\\n        return minVal;\\n    }\\n    private void dfs(List<int> nums, int target,List<int> ls,bool[] visited)\\n    {\\n       if(target < 0) return;\\n       else if(target == 0) \\n       {\\n           minVal = Math.Min(minVal,ls.Count);\\n           return;\\n       }\\n       else if(ls.Count > minVal) return;\\n       else if(visited[target]) return;\\n       for(int i = 0 ;i<nums.Count;i++)\\n       {\\n           ls.Add(nums[i]);\\n           dfs(nums,target - nums[i],ls,visited);\\n           visited[target] = true;\\n           ls.Remove(nums[i]);\\n       }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int minVal = (int) 1e9;\\n    public int MinimumNumbers(int num, int k) {\\n        //first find all unit digits and add it to the list ds\\n        List<int> ds = new List<int>();\\n        int l = 0;\\n        while(l <=num)\\n        {\\n            if(l%10 == k)\\n                ds.Add(l);\\n            l++;\\n        }\\n        if(num == 0) return 0;\\n        else if(k == 0 && num%10==0) return 1;\\n        else if(k==0 && num%10 != 0) return -1;\\n        List<int> ls = new List<int>();\\n        bool[] visited = new bool[num+1];\\n        dfs(ds,num,ls,visited);\\n        if(minVal == (int)1e9) return -1;\\n        return minVal;\\n    }\\n    private void dfs(List<int> nums, int target,List<int> ls,bool[] visited)\\n    {\\n       if(target < 0) return;\\n       else if(target == 0) \\n       {\\n           minVal = Math.Min(minVal,ls.Count);\\n           return;\\n       }\\n       else if(ls.Count > minVal) return;\\n       else if(visited[target]) return;\\n       for(int i = 0 ;i<nums.Count;i++)\\n       {\\n           ls.Add(nums[i]);\\n           dfs(nums,target - nums[i],ls,visited);\\n           visited[target] = true;\\n           ls.Remove(nums[i]);\\n       }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710262,
                "title": "c-fastest-submission-sc-o-n-tabulation",
                "content": "TC :O(N * N)\\nSC: O(N)\\n```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        vector<int>curr(num+5,1e5);\\n        curr[0]=0;\\n        for(int idx=1;idx<=num;idx++){\\n            for(int target=1;target<=num;target++){\\n                // take or not take\\n                int take = 1e5,notatke=1e5;\\n                int nottake = curr[target];\\n                if(idx<=target && idx%10==k)\\n                    take = 1 + curr[target-idx];\\n                curr[target] = min(take,nottake);\\n            }\\n        }\\n        int sz= curr[num];\\n        return sz>=1e5?-1:sz;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        vector<int>curr(num+5,1e5);\\n        curr[0]=0;\\n        for(int idx=1;idx<=num;idx++){\\n            for(int target=1;target<=num;target++){\\n                // take or not take\\n                int take = 1e5,notatke=1e5;\\n                int nottake = curr[target];\\n                if(idx<=target && idx%10==k)\\n                    take = 1 + curr[target-idx];\\n                curr[target] = min(take,nottake);\\n            }\\n        }\\n        int sz= curr[num];\\n        return sz>=1e5?-1:sz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710218,
                "title": "c-unbounded-knapsack-approach-tabulation-dp",
                "content": "TC: O(Num* Num)\\nSC: O(Num)\\n```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n        vector<int>prev(num+10,1e5);\\n        vector<int>curr(num+10,1e5);\\n        prev[0]=0;\\n        for(int idx=1;idx<=num;idx++){\\n            curr[0]=0;\\n            for(int target=1;target<=num;target++){\\n                // take or not take\\n                int take = 1e5,notatke=1e5;\\n                int nottake = prev[target];\\n                if(idx<=target && idx%10==k)\\n                    take = 1 + curr[target-idx];\\n                curr[target] = min(take,nottake);\\n            }\\n            prev=curr;\\n        }\\n        int sz= prev[num];\\n        return sz>=1e5?-1:sz;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    int minimumNumbers(int num, int k) {\\n        \\n        vector<int>prev(num+10,1e5);\\n        vector<int>curr(num+10,1e5);\\n        prev[0]=0;\\n        for(int idx=1;idx<=num;idx++){\\n            curr[0]=0;\\n            for(int target=1;target<=num;target++){\\n                // take or not take\\n                int take = 1e5,notatke=1e5;\\n                int nottake = prev[target];\\n                if(idx<=target && idx%10==k)\\n                    take = 1 + curr[target-idx];\\n                curr[target] = min(take,nottake);\\n            }\\n            prev=curr;\\n        }\\n        int sz= prev[num];\\n        return sz>=1e5?-1:sz;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710135,
                "title": "c-knapsack-approach-memoization-dp",
                "content": "TC: O( Num * Num)\\nSC: O(Num * Num)\\n\\n```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    int solve(int idx,int num,int &k ,vvi &dp){\\n        //base case\\n        if(num==0)  return 0;\\n        if(idx<=0)  return 1e5;\\n        \\n        //check the cache\\n        if(dp[idx][num]!=-1)\\n            return dp[idx][num];\\n        \\n        // take or not take\\n        int take= 1e5,notatke=1e5;\\n        int nottake = 0 + solve(idx-1,num,k,dp);\\n        \\n        // take\\n        if(idx<=num && idx%10==k)\\n            take = 1 + solve(idx,num-idx,k,dp);\\n        \\n        return  dp[idx][num] = min(take,nottake);\\n        \\n    }\\n    int minimumNumbers(int num, int k) {\\n        \\n        vector<vector<int>>dp(num+10,vector<int>(num+10,-1));\\n        int sz= solve(num,num,k,dp);\\n        if(sz>=1e5) return -1;\\n        return sz;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    int solve(int idx,int num,int &k ,vvi &dp){\\n        //base case\\n        if(num==0)  return 0;\\n        if(idx<=0)  return 1e5;\\n        \\n        //check the cache\\n        if(dp[idx][num]!=-1)\\n            return dp[idx][num];\\n        \\n        // take or not take\\n        int take= 1e5,notatke=1e5;\\n        int nottake = 0 + solve(idx-1,num,k,dp);\\n        \\n        // take\\n        if(idx<=num && idx%10==k)\\n            take = 1 + solve(idx,num-idx,k,dp);\\n        \\n        return  dp[idx][num] = min(take,nottake);\\n        \\n    }\\n    int minimumNumbers(int num, int k) {\\n        \\n        vector<vector<int>>dp(num+10,vector<int>(num+10,-1));\\n        int sz= solve(num,num,k,dp);\\n        if(sz>=1e5) return -1;\\n        return sz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707739,
                "title": "python-memoization-solution",
                "content": "```\\ndef minimumNumbers(self, num: int, k: int) -> int:\\n\\tif num == 0: return 0\\n\\tif num < k: return -1\\n\\tif k == num: return 1\\n\\tif num % 2 == 1 and k % 2 == 0: return -1\\n\\n\\n\\tdp = {}\\n\\tdef dfs(sum):\\n\\t\\tif sum > num: return 0\\n\\t\\tif sum == 0: return 0\\n\\t\\tif dp.__contains__(sum): return dp[sum]\\n\\t\\tresult = float(\"inf\")\\n\\t\\tfor i in range(k if k > 0 else 10, num+1, 10):\\n\\t\\t\\tif sum - i >= 0:\\n\\t\\t\\t\\tresult = min(result, 1+dfs(sum-i))\\n\\t\\t\\t\\tdp[sum] = result\\n\\t\\treturn result\\n\\n\\n\\tresult = dfs(num)\\n\\tif result == inf: return -1\\n\\treturn result",
                "solutionTags": [],
                "code": "```\\ndef minimumNumbers(self, num: int, k: int) -> int:\\n\\tif num == 0: return 0\\n\\tif num < k: return -1\\n\\tif k == num: return 1\\n\\tif num % 2 == 1 and k % 2 == 0: return -1\\n\\n\\n\\tdp = {}\\n\\tdef dfs(sum):\\n\\t\\tif sum > num: return 0\\n\\t\\tif sum == 0: return 0\\n\\t\\tif dp.__contains__(sum): return dp[sum]\\n\\t\\tresult = float(\"inf\")\\n\\t\\tfor i in range(k if k > 0 else 10, num+1, 10):\\n\\t\\t\\tif sum - i >= 0:\\n\\t\\t\\t\\tresult = min(result, 1+dfs(sum-i))\\n\\t\\t\\t\\tdp[sum] = result\\n\\t\\treturn result\\n\\n\\n\\tresult = dfs(num)\\n\\tif result == inf: return -1\\n\\treturn result",
                "codeTag": "Python3"
            },
            {
                "id": 2647176,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumNumbers(self, num, k):\\n\\t\\t\\tif num == 0: return 0\\n\\t\\t\\tfor i in range(1, 11):\\n\\t\\t\\t\\tif k * i % 10 == num % 10 and i * k <= num:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\treturn -1",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumNumbers(self, num, k):\\n\\t\\t\\tif num == 0: return 0\\n\\t\\t\\tfor i in range(1, 11):\\n\\t\\t\\t\\tif k * i % 10 == num % 10 and i * k <= num:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\treturn -1",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1912092,
                "content": [
                    {
                        "username": "BlueNihilist",
                        "content": " `The set can contain multiple instances of the same integer`\\nThen it\\'s not a set, is it?"
                    },
                    {
                        "username": "ixphoria",
                        "content": "It is similar to coin change problem. just put all the numbers (greater than zero) ending in k less than or equal to num in a list and now its the same problem as the coin change."
                    },
                    {
                        "username": "WatocMasc",
                        "content": "Leetcode tells me that \"num\" 10 and k \"0\" has 1 combination, how does adding, even a set of 0\\'s - can you get 10?\\n\\nJust unthinkable, but if I\\'m missing something, correct me."
                    },
                    {
                        "username": "ENViN",
                        "content": "Numbers with unit digit 0 (k=0) are 0, 10, 20, 30, ........\\n\\nI hope that helps you understand how a combination is possible :)"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one month back I submitted my solution then I got tle now I submitted same solution it got submitted . just  leetcode things"
                    },
                    {
                        "username": "c4tdog",
                        "content": "do a simple check whether is it possible at all before your recursion (like in example #2), otherwise you\\'ll get a TLE :)\\nanother example when it\\'s not possible:\\n963\\n5"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "It\\'s good of number Theory . "
                    }
                ]
            },
            {
                "id": 2072936,
                "content": [
                    {
                        "username": "BlueNihilist",
                        "content": " `The set can contain multiple instances of the same integer`\\nThen it\\'s not a set, is it?"
                    },
                    {
                        "username": "ixphoria",
                        "content": "It is similar to coin change problem. just put all the numbers (greater than zero) ending in k less than or equal to num in a list and now its the same problem as the coin change."
                    },
                    {
                        "username": "WatocMasc",
                        "content": "Leetcode tells me that \"num\" 10 and k \"0\" has 1 combination, how does adding, even a set of 0\\'s - can you get 10?\\n\\nJust unthinkable, but if I\\'m missing something, correct me."
                    },
                    {
                        "username": "ENViN",
                        "content": "Numbers with unit digit 0 (k=0) are 0, 10, 20, 30, ........\\n\\nI hope that helps you understand how a combination is possible :)"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one month back I submitted my solution then I got tle now I submitted same solution it got submitted . just  leetcode things"
                    },
                    {
                        "username": "c4tdog",
                        "content": "do a simple check whether is it possible at all before your recursion (like in example #2), otherwise you\\'ll get a TLE :)\\nanother example when it\\'s not possible:\\n963\\n5"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "It\\'s good of number Theory . "
                    }
                ]
            },
            {
                "id": 1964710,
                "content": [
                    {
                        "username": "BlueNihilist",
                        "content": " `The set can contain multiple instances of the same integer`\\nThen it\\'s not a set, is it?"
                    },
                    {
                        "username": "ixphoria",
                        "content": "It is similar to coin change problem. just put all the numbers (greater than zero) ending in k less than or equal to num in a list and now its the same problem as the coin change."
                    },
                    {
                        "username": "WatocMasc",
                        "content": "Leetcode tells me that \"num\" 10 and k \"0\" has 1 combination, how does adding, even a set of 0\\'s - can you get 10?\\n\\nJust unthinkable, but if I\\'m missing something, correct me."
                    },
                    {
                        "username": "ENViN",
                        "content": "Numbers with unit digit 0 (k=0) are 0, 10, 20, 30, ........\\n\\nI hope that helps you understand how a combination is possible :)"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one month back I submitted my solution then I got tle now I submitted same solution it got submitted . just  leetcode things"
                    },
                    {
                        "username": "c4tdog",
                        "content": "do a simple check whether is it possible at all before your recursion (like in example #2), otherwise you\\'ll get a TLE :)\\nanother example when it\\'s not possible:\\n963\\n5"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "It\\'s good of number Theory . "
                    }
                ]
            },
            {
                "id": 1964202,
                "content": [
                    {
                        "username": "BlueNihilist",
                        "content": " `The set can contain multiple instances of the same integer`\\nThen it\\'s not a set, is it?"
                    },
                    {
                        "username": "ixphoria",
                        "content": "It is similar to coin change problem. just put all the numbers (greater than zero) ending in k less than or equal to num in a list and now its the same problem as the coin change."
                    },
                    {
                        "username": "WatocMasc",
                        "content": "Leetcode tells me that \"num\" 10 and k \"0\" has 1 combination, how does adding, even a set of 0\\'s - can you get 10?\\n\\nJust unthinkable, but if I\\'m missing something, correct me."
                    },
                    {
                        "username": "ENViN",
                        "content": "Numbers with unit digit 0 (k=0) are 0, 10, 20, 30, ........\\n\\nI hope that helps you understand how a combination is possible :)"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one month back I submitted my solution then I got tle now I submitted same solution it got submitted . just  leetcode things"
                    },
                    {
                        "username": "c4tdog",
                        "content": "do a simple check whether is it possible at all before your recursion (like in example #2), otherwise you\\'ll get a TLE :)\\nanother example when it\\'s not possible:\\n963\\n5"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "It\\'s good of number Theory . "
                    }
                ]
            },
            {
                "id": 1960430,
                "content": [
                    {
                        "username": "BlueNihilist",
                        "content": " `The set can contain multiple instances of the same integer`\\nThen it\\'s not a set, is it?"
                    },
                    {
                        "username": "ixphoria",
                        "content": "It is similar to coin change problem. just put all the numbers (greater than zero) ending in k less than or equal to num in a list and now its the same problem as the coin change."
                    },
                    {
                        "username": "WatocMasc",
                        "content": "Leetcode tells me that \"num\" 10 and k \"0\" has 1 combination, how does adding, even a set of 0\\'s - can you get 10?\\n\\nJust unthinkable, but if I\\'m missing something, correct me."
                    },
                    {
                        "username": "ENViN",
                        "content": "Numbers with unit digit 0 (k=0) are 0, 10, 20, 30, ........\\n\\nI hope that helps you understand how a combination is possible :)"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one month back I submitted my solution then I got tle now I submitted same solution it got submitted . just  leetcode things"
                    },
                    {
                        "username": "c4tdog",
                        "content": "do a simple check whether is it possible at all before your recursion (like in example #2), otherwise you\\'ll get a TLE :)\\nanother example when it\\'s not possible:\\n963\\n5"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "It\\'s good of number Theory . "
                    }
                ]
            },
            {
                "id": 1910575,
                "content": [
                    {
                        "username": "BlueNihilist",
                        "content": " `The set can contain multiple instances of the same integer`\\nThen it\\'s not a set, is it?"
                    },
                    {
                        "username": "ixphoria",
                        "content": "It is similar to coin change problem. just put all the numbers (greater than zero) ending in k less than or equal to num in a list and now its the same problem as the coin change."
                    },
                    {
                        "username": "WatocMasc",
                        "content": "Leetcode tells me that \"num\" 10 and k \"0\" has 1 combination, how does adding, even a set of 0\\'s - can you get 10?\\n\\nJust unthinkable, but if I\\'m missing something, correct me."
                    },
                    {
                        "username": "ENViN",
                        "content": "Numbers with unit digit 0 (k=0) are 0, 10, 20, 30, ........\\n\\nI hope that helps you understand how a combination is possible :)"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one month back I submitted my solution then I got tle now I submitted same solution it got submitted . just  leetcode things"
                    },
                    {
                        "username": "c4tdog",
                        "content": "do a simple check whether is it possible at all before your recursion (like in example #2), otherwise you\\'ll get a TLE :)\\nanother example when it\\'s not possible:\\n963\\n5"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "It\\'s good of number Theory . "
                    }
                ]
            }
        ]
    }
]