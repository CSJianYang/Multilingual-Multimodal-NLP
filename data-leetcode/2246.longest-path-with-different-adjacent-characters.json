[
    {
        "title": "Longest Path With Different Adjacent Characters",
        "question_content": "You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1.\nYou are also given a string s of length n, where s[i] is the character assigned to node i.\nReturn the length of the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them.\n&nbsp;\nExample 1:\n\nInput: parent = [-1,0,0,1,1,2], s = \"abacbe\"\nOutput: 3\nExplanation: The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\nIt can be proven that there is no longer path that satisfies the conditions. \n\nExample 2:\n\nInput: parent = [-1,0,0,0], s = \"aabc\"\nOutput: 3\nExplanation: The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.\n\n&nbsp;\nConstraints:\n\n\tn == parent.length == s.length\n\t1 <= n <= 105\n\t0 <= parent[i] <= n - 1 for all i >= 1\n\tparent[0] == -1\n\tparent represents a valid tree.\n\ts consists of only lowercase English letters.",
        "solutions": [
            {
                "id": 3043055,
                "title": "c-easy-solution-with-explanation-dfs",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\n**This problem is similar to Diameter of tree problem**\\n# Approach\\n1. In every recursion cycle we find 2 largest branches of node(mx1 and mx2). Sum of these branches and node can be longest path. We return maximum path from current node so previous node can append with this path.\\n2. **Steps for solve this problem**\\n   - Start from the source node\\n   - Iterate over all it\\'s children\\n   - If the character value of the child and parent is same leave it\\n   - If the character value of the child and parent is different update the best(mx1) and second_best(mx2) possible values\\n   - update the answer with the best from the \\n      ans=max(1+mx1+mx2,ans)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> child[100001];\\n    int ans;\\n    int dfs(string &s, int curr_node)\\n    {\\n        if(child[curr_node].empty())return 1;\\n        int mx1 = 0, mx2 =0;\\n    // traversing over all the child nodes of the curr_node\\n        for(auto &child_node : child[curr_node])\\n        {\\n        // recursively trying for child nodes\\n            int len = dfs(s, child_node);\\n            ans = max(ans , len);\\n     // rejecting the current node if it\\'s of same character\\n            if(s[curr_node] == s[child_node])continue;\\n     // updating the mx1 and mx2 paths that we can take from all the children of the given node\\n            if(len > mx1)\\n            {\\n                mx2 = mx1;\\n                mx1 = len;\\n            }\\n    //seecond max will be updated\\n            else mx2 = max(mx2 , len);\\n        }\\n    // Update the result.\\n    //Again, max1+mx2+1 means the length of the longest valid path \\n    //going through this node in the sub-tree rooted at this node\\n        ans = max(ans, 1 + mx1 + mx2);\\n    //Adding 1 for the current node\\n        return 1 + mx1;\\n    }\\n    int longestPath(vector<int>& parent, string s){\\n        int n = parent.size();\\n        for(int i=1;i<n;i++)child[parent[i]].push_back(i);\\n        ans = 1;\\n        dfs(s,0);\\n        return ans;\\n    }\\n};\\n```\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on **[LINKDIN](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)**\\n![upvote.jfif](https://assets.leetcode.com/users/images/2ddedd60-39d6-4167-9b77-88e10400f044_1673586388.8794823.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> child[100001];\\n    int ans;\\n    int dfs(string &s, int curr_node)\\n    {\\n        if(child[curr_node].empty())return 1;\\n        int mx1 = 0, mx2 =0;\\n    // traversing over all the child nodes of the curr_node\\n        for(auto &child_node : child[curr_node])\\n        {\\n        // recursively trying for child nodes\\n            int len = dfs(s, child_node);\\n            ans = max(ans , len);\\n     // rejecting the current node if it\\'s of same character\\n            if(s[curr_node] == s[child_node])continue;\\n     // updating the mx1 and mx2 paths that we can take from all the children of the given node\\n            if(len > mx1)\\n            {\\n                mx2 = mx1;\\n                mx1 = len;\\n            }\\n    //seecond max will be updated\\n            else mx2 = max(mx2 , len);\\n        }\\n    // Update the result.\\n    //Again, max1+mx2+1 means the length of the longest valid path \\n    //going through this node in the sub-tree rooted at this node\\n        ans = max(ans, 1 + mx1 + mx2);\\n    //Adding 1 for the current node\\n        return 1 + mx1;\\n    }\\n    int longestPath(vector<int>& parent, string s){\\n        int n = parent.size();\\n        for(int i=1;i<n;i++)child[parent[i]].push_back(i);\\n        ans = 1;\\n        dfs(s,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955433,
                "title": "java-c-python-dfs-on-tree",
                "content": "# **Intuition**\\nClassic dfs problem on the tree.\\n<br>\\n\\n# **Explanation**\\n`dfs(i)` return the the longest path starting at the node `i`.\\n\\n`dfs` on each node `i`, and for each node `i`,\\nwe iterate on all its children, \\nand find all the path startint at the node `i`.\\nThe 2 longest path can make up the longest path in subtree of node `i`,\\nwe update the global result `res`,\\nand return the longest path length as result for `dfs`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    int res;\\n    public int longestPath(int[] parent, String s) {\\n        res = 0;\\n        ArrayList<Integer>[] children = new ArrayList[parent.length];\\n        for (int i = 0; i < parent.length; i++)\\n            children[i] = new ArrayList<>();\\n        for (int i = 1; i < parent.length; i++)\\n            children[parent[i]].add(i);\\n        dfs(children, s, 0);\\n        return res;\\n    }\\n\\n    private int dfs(ArrayList<Integer>[] children, String s, int i) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for (int j : children[i]) {\\n            int cur = dfs(children, s, j);\\n            if (s.charAt(j) != s.charAt(i))\\n                queue.offer(-cur);\\n        }\\n        int big1 = queue.isEmpty() ? 0 : -queue.poll();\\n        int big2 = queue.isEmpty() ? 0 : -queue.poll();\\n        res = Math.max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n```\\n**C++**\\n```cpp\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size(), res = 0;\\n        vector<vector<int>> children(n, vector<int>());\\n        for (int i = 1; i < n; ++i)\\n            children[parent[i]].push_back(i);\\n        dfs(children, s, res, 0);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& children, string& s, int& res, int i) {\\n        int big1 = 0, big2 = 0;\\n        for (int& j : children[i]) {\\n            int cur = dfs(children, s, res, j);\\n            if (s[i] == s[j]) continue;\\n            if (cur > big2) big2 = cur;\\n            if (big2 > big1) swap(big1, big2);\\n        }\\n        res = max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n```\\n**Python3**\\n```py\\n    def longestPath(self, parent, s):\\n        children = [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                children[j].append(i)\\n        \\n        res = [0]\\n        def dfs(i):\\n            candi = [0]\\n            for j in children[i]:\\n                cur = dfs(j)\\n                if s[i] != s[j]:\\n                    candi.append(cur)\\n                    \\n            candi = nlargest(2, candi)\\n            res[0] = max(res[0], sum(candi) + 1)\\n            return max(candi) + 1\\n        \\n        dfs(0)\\n        return res[0]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    int res;\\n    public int longestPath(int[] parent, String s) {\\n        res = 0;\\n        ArrayList<Integer>[] children = new ArrayList[parent.length];\\n        for (int i = 0; i < parent.length; i++)\\n            children[i] = new ArrayList<>();\\n        for (int i = 1; i < parent.length; i++)\\n            children[parent[i]].add(i);\\n        dfs(children, s, 0);\\n        return res;\\n    }\\n\\n    private int dfs(ArrayList<Integer>[] children, String s, int i) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for (int j : children[i]) {\\n            int cur = dfs(children, s, j);\\n            if (s.charAt(j) != s.charAt(i))\\n                queue.offer(-cur);\\n        }\\n        int big1 = queue.isEmpty() ? 0 : -queue.poll();\\n        int big2 = queue.isEmpty() ? 0 : -queue.poll();\\n        res = Math.max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n```\n```cpp\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size(), res = 0;\\n        vector<vector<int>> children(n, vector<int>());\\n        for (int i = 1; i < n; ++i)\\n            children[parent[i]].push_back(i);\\n        dfs(children, s, res, 0);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& children, string& s, int& res, int i) {\\n        int big1 = 0, big2 = 0;\\n        for (int& j : children[i]) {\\n            int cur = dfs(children, s, res, j);\\n            if (s[i] == s[j]) continue;\\n            if (cur > big2) big2 = cur;\\n            if (big2 > big1) swap(big1, big2);\\n        }\\n        res = max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n```\n```py\\n    def longestPath(self, parent, s):\\n        children = [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                children[j].append(i)\\n        \\n        res = [0]\\n        def dfs(i):\\n            candi = [0]\\n            for j in children[i]:\\n                cur = dfs(j)\\n                if s[i] != s[j]:\\n                    candi.append(cur)\\n                    \\n            candi = nlargest(2, candi)\\n            res[0] = max(res[0], sum(candi) + 1)\\n            return max(candi) + 1\\n        \\n        dfs(0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3043377,
                "title": "java-solution-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. This code is solving a problem where given an array \"parent\" representing a tree where the ith element of the array is the parent of the ith node and a string \"s\", the task is to find the longest path in the tree such that no two nodes in the path have the same character in the string s.\\n\\n2. The approach used here is to first create an adjacency list representation of the tree using the given parent array. This is done in the first line of the longestPath method where a map is created with key as the parent node and value as a list of its child nodes.\\n\\n3. Next, the code uses a depth-first search (dfs) traversal to find the longest path in the tree. The dfs method takes in the current node, the adjacency list representation of the tree and the string s as its inputs.\\n\\n4. The base case for the dfs method is when the current node has no children i.e, it is a leaf node. In this case, the method returns 1 as the longest path from a leaf node is of length 1.\\n\\n5. Otherwise, the method iterates through all the children of the current node. For each child, it finds the longest path from that child using the dfs method recursively. Then, if the character at the current node and the child node are different, the method compares the length of the longest path from the child with the current maximum and second maximum length found so far. If it is greater than the maximum, it becomes the new maximum and the previous maximum becomes the second maximum. If it is greater than the second maximum, it becomes the new second maximum.\\n\\n6. Finally, the method updates the longestPathValue variable with the maximum of the current longestPathValue and the sum of the maximum and second maximum length of the path found so far plus 1 (to account for the current node). The method then returns the maximum length of the path found so far plus 1 (to account for the current node)\\n\\n7. The longestPath method returns the final value of the longestPathValue variable which is the longest path in the tree such that no two nodes in the path have the same character in the string s\\n\\n# Code\\n```\\nclass Solution {\\n    int longestPathValue = 1; // variable to store the length of the longest path\\n\\n    public int longestPath(int[] parent, String s) {\\n        // create an adjacency list representation of the tree\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for(int i = 1; i < parent.length; i++){\\n            int j = parent[i];\\n            adj.putIfAbsent(j, new LinkedList<>());\\n            adj.get(j).add(i);\\n        }\\n        // call dfs on the root of the tree\\n        dfs(0, adj, s);\\n        return longestPathValue;\\n    }\\n\\n    public int dfs(int node, Map<Integer, List<Integer>> adj, String s){\\n        // if the node is a leaf node, return 1\\n        if(!adj.containsKey(node)) return 1;\\n        int max = 0, secondMax = 0;\\n        // for each neighbor of the node\\n        for(int nbrNode : adj.get(node)){\\n            int longestPathFromNbrNode = dfs(nbrNode , adj, s);\\n            // if the characters at the current node and its neighbor are the same, ignore the neighbor\\n            if(s.charAt(node) == s.charAt(nbrNode)) continue;\\n            // update max and secondMax with the longest path from the neighbor node\\n            if(longestPathFromNbrNode > max){\\n                secondMax = max;\\n                max = longestPathFromNbrNode;\\n            }else if(longestPathFromNbrNode > secondMax){\\n                secondMax = longestPathFromNbrNode;\\n            }\\n        }\\n        // update longestPathValue with the longest path that includes the current node\\n        longestPathValue = Math.max(longestPathValue, max+secondMax+1);\\n        return max+1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int longestPathValue = 1; // variable to store the length of the longest path\\n\\n    public int longestPath(int[] parent, String s) {\\n        // create an adjacency list representation of the tree\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for(int i = 1; i < parent.length; i++){\\n            int j = parent[i];\\n            adj.putIfAbsent(j, new LinkedList<>());\\n            adj.get(j).add(i);\\n        }\\n        // call dfs on the root of the tree\\n        dfs(0, adj, s);\\n        return longestPathValue;\\n    }\\n\\n    public int dfs(int node, Map<Integer, List<Integer>> adj, String s){\\n        // if the node is a leaf node, return 1\\n        if(!adj.containsKey(node)) return 1;\\n        int max = 0, secondMax = 0;\\n        // for each neighbor of the node\\n        for(int nbrNode : adj.get(node)){\\n            int longestPathFromNbrNode = dfs(nbrNode , adj, s);\\n            // if the characters at the current node and its neighbor are the same, ignore the neighbor\\n            if(s.charAt(node) == s.charAt(nbrNode)) continue;\\n            // update max and secondMax with the longest path from the neighbor node\\n            if(longestPathFromNbrNode > max){\\n                secondMax = max;\\n                max = longestPathFromNbrNode;\\n            }else if(longestPathFromNbrNode > secondMax){\\n                secondMax = longestPathFromNbrNode;\\n            }\\n        }\\n        // update longestPathValue with the longest path that includes the current node\\n        longestPathValue = Math.max(longestPathValue, max+secondMax+1);\\n        return max+1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042992,
                "title": "python3-dfs-explained",
                "content": "The main thing we are looking for at each node is the longest **valid** path **going through this node** in the **sub-tree rooted at this node**. And the maximum such path length is our solution.\\n\\n - **Valid**: Just as what problem stated \"no pair of adjacent nodes on the path have the same character assigned to them.\" So at each node, we only need to make sure its children doesnot have the same character as itself.\\n - Path **going through this node** in the **sub-tree rooted at this node**: We only care about the sub-tree rooted at this node when visiting this node, because if a valid path going though this node and moving up to its parent node, it will be taking cared of when we are visiting its parent node.\\n\\n```python\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        # Construct the tree using the parent list.\\n        tree = defaultdict(list)\\n        for end,start in enumerate(parent):\\n            tree[start].append(end)\\n        \\n        # Store the longest path\\n        # It is updated in dfs\\n        res = 1\\n        \\n        # dfs will return the longest valid path starting from this node in the sub-tree rooted at this node.\\n        def dfs(node):\\n            nonlocal res\\n            \\n            # While examing the children, \\n            # We want to keep track of the 2 longest paths starting from this node,\\n            # So that we can compute the longest path going through this node \\n            # in the sub-tree rooted at this node.\\n            max1 = max2 = 0\\n\\n            for nei in tree[node]:\\n                neiL = dfs(nei)\\n                # This condition makes sure the path is valid.\\n                if s[nei] != s[node]:\\n                    # Update the length of the top two longest paths.\\n                    if neiL > max1:\\n                        max2 = max1\\n                        max1 = neiL\\n                    elif neiL > max2:\\n                        max2 = neiL\\n            \\n            # Update the result.\\n            # Again, max1+max2+1 means the length of the longest valid path \\n            # going through this node in the sub-tree rooted at this node.\\n            res = max(res, max1+max2+1)\\n            \\n            # Adding 1 for the current node\\n            return max1+1\\n        \\n        dfs(0)\\n        return res\\n```\\nThis **[post](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/discuss/1955340/Python-Explanation-with-pictures-BFS)** has the best figure illustration, if I didn\\'t do a good job explaining it and you are still confused about the problem.\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        # Construct the tree using the parent list.\\n        tree = defaultdict(list)\\n        for end,start in enumerate(parent):\\n            tree[start].append(end)\\n        \\n        # Store the longest path\\n        # It is updated in dfs\\n        res = 1\\n        \\n        # dfs will return the longest valid path starting from this node in the sub-tree rooted at this node.\\n        def dfs(node):\\n            nonlocal res\\n            \\n            # While examing the children, \\n            # We want to keep track of the 2 longest paths starting from this node,\\n            # So that we can compute the longest path going through this node \\n            # in the sub-tree rooted at this node.\\n            max1 = max2 = 0\\n\\n            for nei in tree[node]:\\n                neiL = dfs(nei)\\n                # This condition makes sure the path is valid.\\n                if s[nei] != s[node]:\\n                    # Update the length of the top two longest paths.\\n                    if neiL > max1:\\n                        max2 = max1\\n                        max1 = neiL\\n                    elif neiL > max2:\\n                        max2 = neiL\\n            \\n            # Update the result.\\n            # Again, max1+max2+1 means the length of the longest valid path \\n            # going through this node in the sub-tree rooted at this node.\\n            res = max(res, max1+max2+1)\\n            \\n            # Adding 1 for the current node\\n            return max1+1\\n        \\n        dfs(0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955340,
                "title": "python-explanation-with-pictures-bfs",
                "content": "Each chain consists of one parent node and at most two longest chains from its child nodes.\\n\\n![image](https://assets.leetcode.com/users/images/a06b90b8-e849-496c-97c1-2c874d67dd59_1650168100.1094086.png)\\n\\nThus for node a, we save the longest 2 chains from a\\'s child nodes. \\n\\n![image](https://assets.leetcode.com/users/images/2812bedc-7f4b-48d8-a534-44c90b27ac35_1650168109.0435398.png)\\n\\nThe longest chain \"centered on \" `a` can be calculated as 1 + the longest two chain of `a`\\'s child nodes.\\n\\n\\n![image](https://assets.leetcode.com/users/images/33d02d43-4198-41fa-85f8-4386839e9914_1650168120.6134412.png)\\n\\n\\n\\n\\nNow we move on to `a`\\'s parent node, the longest chain \"end by\" `a` equals 1 + the longest chain of `a`\\'s child node.\\n\\n![image](https://assets.leetcode.com/users/images/5256942d-3a4e-4a78-aec2-6ca1dbb90b7c_1650168120.0273561.png)\\n\\n\\n\\n\\n\\n\\n\\nThe example given by the problem:\\n\\n![image](https://assets.leetcode.com/users/images/f8b273dc-439f-4ad5-857b-dc2a302348b6_1650168126.7276144.png)\\n\\n**complexity**\\nTime: O(n)\\nSpace: O(n)\\n\\n\\n**code**\\n```\\nclass Solution:\\n    def longestPath(self, A: List[int], s: str) -> int:\\n        n = len(A)\\n        child_num = [0] * n\\n        \\n        # count the number of children for each node\\n        for a in A[1:]:\\n            child_num[a] += 1\\n        \\n        # The longest valid chain with node i as parent.\\n        longest = [[0] for _ in range(n)]\\n        \\n        # Add all leaf nodes to deque\\n\\t\\t# [current node, the maximum length end by this node]\\n        dq = collections.deque()\\n        for i in range(n):\\n            if child_num[i] == 0:\\n                dq.append([i, 1])\\n        \\n        ans = 1\\n        while dq:\\n            cur_i, cur_l = dq.popleft()\\n            cur_p = A[cur_i]\\n            \\n            # Minus the number of unvisited child node by 1\\n            child_num[cur_p] -= 1\\n            \\n            # If the child has different char with parent\\n            if s[cur_p] != s[cur_i]:\\n                bisect.insort_right(longest[cur_p], cur_l)\\n                if len(longest[cur_p]) > 2:\\n                    longest[cur_p].pop(0)\\n                    \\n            # If the parent has 0 univisited child, meaning it also\\n            # become a child node, add it to deque.\\n            if child_num[cur_p] == 0:\\n                ans = max(ans, 1 + sum(longest[cur_p][-2:]))\\n                dq.append([cur_p, 1 + longest[cur_p][-1]])\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPath(self, A: List[int], s: str) -> int:\\n        n = len(A)\\n        child_num = [0] * n\\n        \\n        # count the number of children for each node\\n        for a in A[1:]:\\n            child_num[a] += 1\\n        \\n        # The longest valid chain with node i as parent.\\n        longest = [[0] for _ in range(n)]\\n        \\n        # Add all leaf nodes to deque\\n\\t\\t# [current node, the maximum length end by this node]\\n        dq = collections.deque()\\n        for i in range(n):\\n            if child_num[i] == 0:\\n                dq.append([i, 1])\\n        \\n        ans = 1\\n        while dq:\\n            cur_i, cur_l = dq.popleft()\\n            cur_p = A[cur_i]\\n            \\n            # Minus the number of unvisited child node by 1\\n            child_num[cur_p] -= 1\\n            \\n            # If the child has different char with parent\\n            if s[cur_p] != s[cur_i]:\\n                bisect.insort_right(longest[cur_p], cur_l)\\n                if len(longest[cur_p]) > 2:\\n                    longest[cur_p].pop(0)\\n                    \\n            # If the parent has 0 univisited child, meaning it also\\n            # become a child node, add it to deque.\\n            if child_num[cur_p] == 0:\\n                ans = max(ans, 1 + sum(longest[cur_p][-2:]))\\n                dq.append([cur_p, 1 + longest[cur_p][-1]])\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955967,
                "title": "explanation-with-c-code",
                "content": "This questions is very similary to finding the diameter of the tree with additional constraint  of not choosing the node with same character value of it\\'s parent \\nNow to find the diameter we see for any node present in a tree there are 3 ways of choosing a path as shown in the figure\\n![image](https://assets.leetcode.com/users/images/6a31c543-c2ad-46bb-ad3e-97e0a1167455_1650174432.0409.png)\\n\\nSo in this questions we do the same  but extending this concept to a generic tree\\nSo in a generic tree there are more than 2 nodes however the longest path can only be found from 2 of the longest nodes \\nHence for every node, we will consider only the 2 longest child nodes.\\n![image](https://assets.leetcode.com/users/images/3f5fdce9-19eb-471f-884e-e9e882de96ce_1650173969.9700348.png)\\n\\n\\nAlgo Steps:\\n 1. Start from the source node\\n 2. Iterate over all it\\'s children\\n 3. If the character value of the child and parent is same leave it\\n 4. If the character value of the child and parent is different update the best and second_best possible values\\n 5. finally try all the three cases shown in the first figure\\n 6. update the answer with the best from the three cases\\n```\\n \\n Code:\\n \\nclass Solution {\\npublic:\\n    vector<int>tree[100005];\\n    int ans;\\n    int FindLongestLength(int curr_node,string&s){\\n        \\n        int best=0,second_best=0;\\n        \\n        \\n        // traversing over all the child nodes of the curr_node\\n        for(auto child_node:tree[curr_node]){\\n\\t\\t    // recursively trying for child nodes\\n            int len=FindLongestLength(child_node,s);\\n            \\n            // rejecting the current node if it\\'s of same character\\n            if(s[child_node]==s[curr_node])\\n                continue;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// updating the best and second_best paths that we can take from all the children of the given node\\n            if(len>best){\\n                second_best=best;\\n                best=len;\\n            }\\n            else if(len>second_best) {\\n                second_best=len;\\n            }\\n        }\\n        \\n\\t\\t\\n\\t\\n        // now there are 3 possibilies  as discussed\\n\\t\\t\\n\\t\\t// however here we have reject one of the possibility as we have already selcted the\\n\\t\\t// max from both the values\\n        \\n        // case 1 :  selecting the max of the two possible paths \\n        int case1=1+best;\\n\\t\\t\\n\\t\\t// case 2:  \\n        int case2=1+best+second_best;\\n        \\n        // updating the answer\\n        ans=max({ans,case1,case2});\\n\\t\\t\\n\\t\\t\\n        return case1;\\n        \\n        \\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        for(int i=1;i<parent.size();i++)\\n            tree[parent[i]].push_back(i);\\n        \\n        ans=0;\\n        FindLongestLength(0,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n \\n Code:\\n \\nclass Solution {\\npublic:\\n    vector<int>tree[100005];\\n    int ans;\\n    int FindLongestLength(int curr_node,string&s){\\n        \\n        int best=0,second_best=0;\\n        \\n        \\n        // traversing over all the child nodes of the curr_node\\n        for(auto child_node:tree[curr_node]){\\n\\t\\t    // recursively trying for child nodes\\n            int len=FindLongestLength(child_node,s);\\n            \\n            // rejecting the current node if it\\'s of same character\\n            if(s[child_node]==s[curr_node])\\n                continue;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// updating the best and second_best paths that we can take from all the children of the given node\\n            if(len>best){\\n                second_best=best;\\n                best=len;\\n            }\\n            else if(len>second_best) {\\n                second_best=len;\\n            }\\n        }\\n        \\n\\t\\t\\n\\t\\n        // now there are 3 possibilies  as discussed\\n\\t\\t\\n\\t\\t// however here we have reject one of the possibility as we have already selcted the\\n\\t\\t// max from both the values\\n        \\n        // case 1 :  selecting the max of the two possible paths \\n        int case1=1+best;\\n\\t\\t\\n\\t\\t// case 2:  \\n        int case2=1+best+second_best;\\n        \\n        // updating the answer\\n        ans=max({ans,case1,case2});\\n\\t\\t\\n\\t\\t\\n        return case1;\\n        \\n        \\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        for(int i=1;i<parent.size();i++)\\n            tree[parent[i]].push_back(i);\\n        \\n        ans=0;\\n        FindLongestLength(0,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955374,
                "title": "climb-up",
                "content": "We \"climb up\" the tree, waiting for all branches to reach a parent, and then continue upward. We count (`cnt`) children for each node, and start from leaves (zero children). \\n\\n> Well, the tree is upside-down, so we climb from leaves up to the root? Need to do a better job on my analogies...\\n\\nFor a parent, we track lengths for two longest branches.  If the parent has a different letter, the branch size is the longest branch for the child (`top1[i]`) plus one.\\n\\nOnce all branches are converged for a parent, this parent becomes a leaf and we continue climbing up.\\n\\nWe track and return the maximum sum of two longest branches among all nodes. \\n\\n**C++**\\n```cpp\\nint longestPath(vector<int>& parent, string s) {\\n    int n = parent.size(), res = 1;\\n    vector<int> cnt(n), top1(n, 1), top2(n, 1);\\n    for (int i = 1; i < n; ++i)\\n        ++cnt[parent[i]];\\n    queue<int> q;\\n    for (int i = 1; i < n; ++i)\\n        if (cnt[i] == 0)\\n            q.push(i);\\n    while (!q.empty() && q.front() != 0) {\\n        int i = q.front(), p = parent[i]; \\n        q.pop();\\n        if (int length = 1 + (s[i] != s[p] ? top1[i] : 0); top1[p] <= length) {\\n            top2[p] = top1[p];\\n            top1[p] = length;\\n        }\\n        else\\n            top2[p] = max(top2[p], length);\\n        if (--cnt[p] == 0) {\\n            q.push(p);\\n            res = max(res, top1[p] + top2[p] - 1);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint longestPath(vector<int>& parent, string s) {\\n    int n = parent.size(), res = 1;\\n    vector<int> cnt(n), top1(n, 1), top2(n, 1);\\n    for (int i = 1; i < n; ++i)\\n        ++cnt[parent[i]];\\n    queue<int> q;\\n    for (int i = 1; i < n; ++i)\\n        if (cnt[i] == 0)\\n            q.push(i);\\n    while (!q.empty() && q.front() != 0) {\\n        int i = q.front(), p = parent[i]; \\n        q.pop();\\n        if (int length = 1 + (s[i] != s[p] ? top1[i] : 0); top1[p] <= length) {\\n            top2[p] = top1[p];\\n            top1[p] = length;\\n        }\\n        else\\n            top2[p] = max(top2[p], length);\\n        if (--cnt[p] == 0) {\\n            q.push(p);\\n            res = max(res, top1[p] + top2[p] - 1);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043288,
                "title": "super-easy-explanation-dfs-o-n-java",
                "content": "\\n# Request \\uD83D\\uDE0A :\\n```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n# Complexity :\\n- Time complexity :O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity :O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code (Explained in Comments) :\\n```\\nclass Solution {\\n  public int longestPath(int[] parent, String s) {\\n    final int n = parent.length;\\n    List<Integer>[] graph = new List[n];\\n\\n    for (int i = 0; i < n; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int i = 1; i < n; ++i)\\n      graph[parent[i]].add(i);//adding every vertex\\n\\n    longestPathDownFrom(graph, 0, s);//calling the function for max path\\n    return ans;\\n  }\\n\\n  private int ans = 0;\\n\\n  private int longestPathDownFrom(List<Integer>[] graph, int u, final String s) {\\n    int max1 = 0;\\n    int max2 = 0;\\n\\n    for (final int v : graph[u]) {\\n      final int res = longestPathDownFrom(graph, v, s);\\n      if (s.charAt(u) == s.charAt(v))//equal charcters skipped\\n        continue;\\n      if (res > max1) //finding path with different charcters\\n      {\\n        max2 = max1;\\n        max1 = res;\\n      } else if (res > max2) {\\n        max2 = res;\\n      }\\n    }\\n\\n    ans = Math.max(ans, 1 + max1 + max2);//finding max from every path\\n    return 1 + max1;//return the maximum length of path\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution {\\n  public int longestPath(int[] parent, String s) {\\n    final int n = parent.length;\\n    List<Integer>[] graph = new List[n];\\n\\n    for (int i = 0; i < n; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int i = 1; i < n; ++i)\\n      graph[parent[i]].add(i);//adding every vertex\\n\\n    longestPathDownFrom(graph, 0, s);//calling the function for max path\\n    return ans;\\n  }\\n\\n  private int ans = 0;\\n\\n  private int longestPathDownFrom(List<Integer>[] graph, int u, final String s) {\\n    int max1 = 0;\\n    int max2 = 0;\\n\\n    for (final int v : graph[u]) {\\n      final int res = longestPathDownFrom(graph, v, s);\\n      if (s.charAt(u) == s.charAt(v))//equal charcters skipped\\n        continue;\\n      if (res > max1) //finding path with different charcters\\n      {\\n        max2 = max1;\\n        max1 = res;\\n      } else if (res > max2) {\\n        max2 = res;\\n      }\\n    }\\n\\n    ans = Math.max(ans, 1 + max1 + max2);//finding max from every path\\n    return 1 + max1;//return the maximum length of path\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956666,
                "title": "standard-diameter-problem-trees-variation-c",
                "content": "**Lets see what our solve function is doing**\\n1) It returns a pair which contains the charecter of node we just came from , total lenght of ans starting from that node.\\n2) answer variable stores max answer of the tree\\n3)  we loop through all adjacent nodes of the parent , if our recursive function says that the adjacent node returns different charecter value then , we can include it in our answer. Moreover , we can include atmost 2 such nodes in our answer.\\n  Just try to recall diameter problem of trees , we do very similar thing here too .\\n  I am using priority queue to get atmost top 2 elements having longest answer if they exist\\n\\n4) Now we update our answer by taking max of ans , addition of answers from our adjacent nodes + 1\\n5) And we return best lenght we can extend form this node to our parent node . Very similar to diameter problem.\\n6) Thus is the end ans contains max answer of the tree\\n\\n```\\nclass Solution {\\n    \\n    pair<int , int> solve(vector<int> adj[] , string &s , int par , int &ans , vector<bool> &vis)\\n    {\\n        priority_queue<int> pq ;\\n        \\n        vis[par] = 1 ;\\n        \\n        for(auto &x: adj[par])\\n        {\\n            if(!vis[x])\\n            {\\n                 pair<int , int> p1 = solve(adj , s , x , ans , vis) ;\\n                 if(p1.first != s[par])\\n                 {\\n                     pq.push(-p1.second) ;\\n                     if(pq.size() > 2) pq.pop() ;\\n                 }\\n            }\\n        }\\n        \\n        int mxnum = 0;\\n        int curmx = 0 ;\\n        \\n        if(pq.size() > 0)\\n        {\\n            int f = -pq.top() ;\\n            pq.pop() ;\\n            curmx+= f ;\\n            \\n            mxnum = max(mxnum , f) ;\\n        }\\n            \\n          if(pq.size() > 0)\\n        {\\n            int f = -pq.top() ;\\n            pq.pop() ;\\n            curmx+= f ;\\n              \\n             mxnum = max(mxnum , f) ;\\n        }\\n        \\n        curmx++ ;\\n        ans = max(ans,  curmx) ;\\n        \\n        return {s[par] , mxnum + 1 } ;\\n            \\n    }\\n    \\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        \\n        int n = parent.size() ;\\n        vector<int> adj[n] ;\\n        \\n        for(int i=1; i<n ; i++)\\n        {\\n            adj[i].push_back(parent[i]) ;\\n            adj[parent[i]].push_back(i) ;\\n\\n        }\\n\\n        vector<bool > vis(n , 0) ;\\n        \\n        int ans = 0;\\n        \\n        solve(adj , s , 0 , ans, vis) ;\\n        return ans ;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    pair<int , int> solve(vector<int> adj[] , string &s , int par , int &ans , vector<bool> &vis)\\n    {\\n        priority_queue<int> pq ;\\n        \\n        vis[par] = 1 ;\\n        \\n        for(auto &x: adj[par])\\n        {\\n            if(!vis[x])\\n            {\\n                 pair<int , int> p1 = solve(adj , s , x , ans , vis) ;\\n                 if(p1.first != s[par])\\n                 {\\n                     pq.push(-p1.second) ;\\n                     if(pq.size() > 2) pq.pop() ;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 3045238,
                "title": "dfs-solution-c-with-explanation",
                "content": "# Intuition\\nTrying to get best answer for each node\\n\\n# Approach\\nWe have two options for each node:\\n- the first one is to take one branch and add the node\\n- the second one is to take two sub branches from the node and merge them and add the current node\\n\\n***Note:the second approache if the letter for the child and current node are different***\\n\\n# Complexity\\n- Time complexity:\\n$O(V + E)$ - where $V$ is the number of vertices and $E$ is the number of edges\\n\\n- Space complexity:\\n$O(V + 2 \\\\times E)$ - where $V$ is the number of vertices and $E$ is the number of edges\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // global variables to use\\n    vector < vector < int > > adj;\\n    string letters;\\n\\n    int dfs(int u, int p, int& best_path){\\n        // visit the current node\\n        int best_path_1 = 0, best_path_2 = 0;\\n        \\n        auto update_max = [&](int x){\\n            if(x >= best_path_1)\\n                best_path_2 = best_path_1, best_path_1 = x;\\n            else if(x >= best_path_2)\\n                best_path_2 = x; \\n        };\\n\\n        for(auto& v : adj[u]){\\n            // if the adjacent node not visited and not the same letter let\\'s calc it\\n            if(v == p) continue;\\n            int v_ans = dfs(v, u, best_path);\\n            if(letters[u] != letters[v])\\n                update_max(v_ans);\\n        }\\n\\n        // take two branches\\n        best_path = max({best_path, best_path_1 + best_path_2 + 1});\\n\\n        // the maximum path from the current node\\n        return 1 + best_path_1;\\n    }\\n\\n    void add_edge(int u, int v){\\n        adj[u].push_back(v), adj[v].push_back(u);\\n    }\\n\\n    int longestPath(vector<int>& parent, string& s) {\\n        // global variable initialization\\n        int n = parent.size();\\n        adj = vector < vector < int > > (n);\\n        letters = s;\\n\\n        // add edges between i and parent of i\\n        for(int i = 1; i < n; i++)\\n            add_edge(i, parent[i]);\\n        \\n        int best_path = 0;\\n        dfs(0, -1, best_path);\\n\\n        // the length of the longest path with the required conditions.\\n        return best_path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // global variables to use\\n    vector < vector < int > > adj;\\n    string letters;\\n\\n    int dfs(int u, int p, int& best_path){\\n        // visit the current node\\n        int best_path_1 = 0, best_path_2 = 0;\\n        \\n        auto update_max = [&](int x){\\n            if(x >= best_path_1)\\n                best_path_2 = best_path_1, best_path_1 = x;\\n            else if(x >= best_path_2)\\n                best_path_2 = x; \\n        };\\n\\n        for(auto& v : adj[u]){\\n            // if the adjacent node not visited and not the same letter let\\'s calc it\\n            if(v == p) continue;\\n            int v_ans = dfs(v, u, best_path);\\n            if(letters[u] != letters[v])\\n                update_max(v_ans);\\n        }\\n\\n        // take two branches\\n        best_path = max({best_path, best_path_1 + best_path_2 + 1});\\n\\n        // the maximum path from the current node\\n        return 1 + best_path_1;\\n    }\\n\\n    void add_edge(int u, int v){\\n        adj[u].push_back(v), adj[v].push_back(u);\\n    }\\n\\n    int longestPath(vector<int>& parent, string& s) {\\n        // global variable initialization\\n        int n = parent.size();\\n        adj = vector < vector < int > > (n);\\n        letters = s;\\n\\n        // add edges between i and parent of i\\n        for(int i = 1; i < n; i++)\\n            add_edge(i, parent[i]);\\n        \\n        int best_path = 0;\\n        dfs(0, -1, best_path);\\n\\n        // the length of the longest path with the required conditions.\\n        return best_path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494179,
                "title": "python-faster-than-100-simple-dfs-easy-explanation",
                "content": "**similar approach like longest path in Tree**\\n#### **If you like the Solution,\\n#### please  Upvote  :) **\\n```\\nclass Solution:\\n    def longestPath(self, par: List[int], s: str) -> int:\\n        dit = {}\\n        # store tree in dictionary\\n        for i in range(len(par)):\\n            if par[i] in dit:\\n                dit[par[i]].append(i)\\n            else:\\n                dit[par[i]] = [i]\\n                \\n        ans = 1        \\n        def dfs(n):\\n            nonlocal ans\\n            if n not in dit:\\n                return 1\\n            \\n            largest=0 # largest path lenght among all children\\n            second_largest=0 # second largest path lenght among all children\\n            for u in dit[n]:\\n                curr = dfs(u)\\n                if s[u]!=s[n]: # pick child path if child and parent both have different value\\n                    if curr>largest:\\n                        second_largest = largest\\n                        largest = curr\\n                    elif curr>second_largest:\\n                        second_largest = curr\\n                        \\n            ans = max(ans,largest+second_largest+1) # largest path including parent with at most two children \\n            \\n            return largest+1  # return largest path end at parent\\n        \\n        dfs(0)\\n        return ans\\n        ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, par: List[int], s: str) -> int:\\n        dit = {}\\n        # store tree in dictionary\\n        for i in range(len(par)):\\n            if par[i] in dit:\\n                dit[par[i]].append(i)\\n            else:\\n                dit[par[i]] = [i]\\n                \\n        ans = 1        \\n        def dfs(n):\\n            nonlocal ans\\n            if n not in dit:\\n                return 1\\n            \\n            largest=0 # largest path lenght among all children\\n            second_largest=0 # second largest path lenght among all children\\n            for u in dit[n]:\\n                curr = dfs(u)\\n                if s[u]!=s[n]: # pick child path if child and parent both have different value\\n                    if curr>largest:\\n                        second_largest = largest\\n                        largest = curr\\n                    elif curr>second_largest:\\n                        second_largest = curr\\n                        \\n            ans = max(ans,largest+second_largest+1) # largest path including parent with at most two children \\n            \\n            return largest+1  # return largest path end at parent\\n        \\n        dfs(0)\\n        return ans\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 3043041,
                "title": "python-easysolution-beats-95",
                "content": "Easy Approach \\uD83D\\uDCAF. Enjoy the day.\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        t={}\\n        for i in range(1,len(parent)):\\n            if parent[i] not in t:\\n                t[parent[i]]=[i]\\n            else:\\n                t[parent[i]].append(i)\\n            \\n        self.ans=1\\n        def fun(i):\\n            if i not in t:\\n                return 1\\n            res = 1\\n            for j in t[i]:\\n                length=fun(j)\\n                if s[i] != s[j]:\\n                    self.ans = max(self.ans,length+res)\\n                    res = max(res,length+1)\\n            return res\\n        \\n        fun(0)\\n        return self.ans\\n```\\n**If you like my Content please \\uD83D\\uDC4D REPUTATE ME \\uD83D\\uDC4D \\u2705**\\nFROM TOMORROW I WILL EXPLAIN THE CODE CLEARLY..SORYY FOR TODAY WHAT I HAVE DONE..\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        t={}\\n        for i in range(1,len(parent)):\\n            if parent[i] not in t:\\n                t[parent[i]]=[i]\\n            else:\\n                t[parent[i]].append(i)\\n            \\n        self.ans=1\\n        def fun(i):\\n            if i not in t:\\n                return 1\\n            res = 1\\n            for j in t[i]:\\n                length=fun(j)\\n                if s[i] != s[j]:\\n                    self.ans = max(self.ans,length+res)\\n                    res = max(res,length+1)\\n            return res\\n        \\n        fun(0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508404,
                "title": "java-15ms-beats-100-01-time-100-mem-topological-sort",
                "content": "100.01% was a joke, \\'cause Leetcode says the fastest time was 16ms...\\n\\n[15ms 51 MB submission](https://leetcode.com/submissions/detail/787833489/)\\n\\nInitially (based on the two examples) I thought the input arrays are in exact level order, in which case we could just go scan backwards node by node and finish this in one pass. That turns out to be naive, the input could be in somewhat random order, had to resort to Topological Sort, as @votrubac put it, this is a \\'Climb Up\\' process.\\n\\nCredit of this solution partially goes to anonymous java submmision and @votrubac..\\n```java\\nclass Solution {\\n    public int longestPath(int[] parents, String s) {\\n        char[] a = s.toCharArray();\\n        int n = a.length, res = 1; // res is what we return\\n        \\n        // topo sort, count in-degree first (in=degree here means child -> parent)\\n        int[] degree = new int[n];\\n        for (int i = 1; i < n; i++) degree[parents[i]]++; // skip root\\n        \\n        // q: seed queue for topo sort, start with leaf nodes(in-degree = 0)\\n        int[] q = new int[n];\\n        int qIdx = -1; // index for q (Actually a stack?)\\n        for (int i = 1; i < n; i++) // skip root\\n            if (degree[i] == 0) q[++qIdx] = i;\\n        \\n        int[] path = new int[n]; // max length of path for each node\\n        Arrays.fill(path, 1); // every node is a path of length 1\\n        \\n        while (qIdx >= 0) { // topo sort till the end\\n            int c = q[qIdx--]; // c: child index\\n            int p = parents[c]; // p: parent index\\n            if (--degree[p] == 0 && p != 0) q[++qIdx] = p; // do not process root\\n            \\n            if (a[p] == a[c]) continue; // nothing to update\\n            \\n            // we must update res first, otherwise we may double count the same path\\n            res = Math.max(res, path[p] + path[c]);\\n            path[p] = Math.max(path[p], path[c] + 1);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Topological Sort"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestPath(int[] parents, String s) {\\n        char[] a = s.toCharArray();\\n        int n = a.length, res = 1; // res is what we return\\n        \\n        // topo sort, count in-degree first (in=degree here means child -> parent)\\n        int[] degree = new int[n];\\n        for (int i = 1; i < n; i++) degree[parents[i]]++; // skip root\\n        \\n        // q: seed queue for topo sort, start with leaf nodes(in-degree = 0)\\n        int[] q = new int[n];\\n        int qIdx = -1; // index for q (Actually a stack?)\\n        for (int i = 1; i < n; i++) // skip root\\n            if (degree[i] == 0) q[++qIdx] = i;\\n        \\n        int[] path = new int[n]; // max length of path for each node\\n        Arrays.fill(path, 1); // every node is a path of length 1\\n        \\n        while (qIdx >= 0) { // topo sort till the end\\n            int c = q[qIdx--]; // c: child index\\n            int p = parents[c]; // p: parent index\\n            if (--degree[p] == 0 && p != 0) q[++qIdx] = p; // do not process root\\n            \\n            if (a[p] == a[c]) continue; // nothing to update\\n            \\n            // we must update res first, otherwise we may double count the same path\\n            res = Math.max(res, path[p] + path[c]);\\n            path[p] = Math.max(path[p], path[c] + 1);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045253,
                "title": "bfs-solution-c-with-explanation-beats-99",
                "content": "# Intuition\\nTrying to get best answer for each node\\n\\n\\n# Approach\\nWe have two options for each node:\\n\\n- the first one is to take one branch and add the node\\n- the second one is to take two sub branches from the node and merge them and add the current node\\n\\n# Complexity\\n- Time complexity:\\n$O(V+E)$ - where $V$ is the number of vertices and $E$ is the number of edges\\n\\n\\n- Space complexity:\\n$O(V)$ - where $V$ is the number of vertices\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        // decalration variables to use\\n        int n = parent.size();\\n        vector < int > top_1(n, 1), top_2(n, 1), deg(n);\\n        \\n        // add edges between i and parent of i\\n        for(int i = 1; i < n; i++)\\n            deg[parent[i]]++;\\n        \\n        // queue for topology sort\\n        queue < int > topo;\\n\\n        // let\\'s calc the max_path\\n        int max_path = 1;\\n\\n        // add the endpoints in queue\\n        for(int i = 1; i < n; i++)\\n            if(deg[i] == 0)\\n                topo.push(i), deg[i]--;\\n        \\n        auto update_max = [&](int u, int x){\\n            // update the maximum to paths for each node\\n            if(x >= top_1[u])\\n                top_2[u] = top_1[u], top_1[u] = x;\\n            else if(x >= top_2[u])\\n                top_2[u] = x;\\n        };\\n\\n        while(!topo.empty() && topo.front()){\\n            // the current node\\n            int u = topo.front(), p = parent[u];\\n            topo.pop();\\n\\n            // path_length\\n            int len = 1 + (s[u] != s[p] ? top_1[u] : 0);\\n            \\n            // update max paths for current node\\n            update_max(p, len);\\n\\n            // if the parent degree becomes 0 so, let\\'s add it\\n            if(!--deg[p])\\n                topo.push(p);\\n\\n            // update the answer wit max between it and the best two paths in it\\'s children\\n            max_path = max(max_path, top_1[p] + top_2[p] - 1);\\n        }\\n\\n        // the length of the longest path with the required conditions.\\n        return max_path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        // decalration variables to use\\n        int n = parent.size();\\n        vector < int > top_1(n, 1), top_2(n, 1), deg(n);\\n        \\n        // add edges between i and parent of i\\n        for(int i = 1; i < n; i++)\\n            deg[parent[i]]++;\\n        \\n        // queue for topology sort\\n        queue < int > topo;\\n\\n        // let\\'s calc the max_path\\n        int max_path = 1;\\n\\n        // add the endpoints in queue\\n        for(int i = 1; i < n; i++)\\n            if(deg[i] == 0)\\n                topo.push(i), deg[i]--;\\n        \\n        auto update_max = [&](int u, int x){\\n            // update the maximum to paths for each node\\n            if(x >= top_1[u])\\n                top_2[u] = top_1[u], top_1[u] = x;\\n            else if(x >= top_2[u])\\n                top_2[u] = x;\\n        };\\n\\n        while(!topo.empty() && topo.front()){\\n            // the current node\\n            int u = topo.front(), p = parent[u];\\n            topo.pop();\\n\\n            // path_length\\n            int len = 1 + (s[u] != s[p] ? top_1[u] : 0);\\n            \\n            // update max paths for current node\\n            update_max(p, len);\\n\\n            // if the parent degree becomes 0 so, let\\'s add it\\n            if(!--deg[p])\\n                topo.push(p);\\n\\n            // update the answer wit max between it and the best two paths in it\\'s children\\n            max_path = max(max_path, top_1[p] + top_2[p] - 1);\\n        }\\n\\n        // the length of the longest path with the required conditions.\\n        return max_path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044987,
                "title": "java-dfs-commented-explanation",
                "content": "# Please Upvote :D\\n---\\nRead the comments carefully, comment if any doubt. Would be happy to help. \\uD83D\\uDE07\\n``` java []\\nclass Solution {\\n    // globally declaring answer and adjacency list\\n    private int longestPath = 1;    // path is atleast going to be 1 unit long (a node itself)\\n    private List<Integer>[] adj;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        adj = new List[n];      // initialising the adjacency list\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int i = 1; i < n; i++) {   // populating the adjacency list\\n            int u = i, v = parent[i];\\n            adj[u].add(v);\\n            adj[v].add(u);\\n        }\\n\\n        dfs(0, -1, s);          // calling the dfs\\n        return longestPath;     // returning the longest path length found\\n    }\\n\\n    private int dfs(int currentNode, int parent, String s) {\\n        // there can be multiple children paths\\n        // but only the longest two of them can combine along with the current node to form a single longest path\\n        // so we take two variables which will store the longest and second longest path lengths\\n        int maxLen = 0, secondMaxLen = 0;\\n        for (int child : adj[currentNode]) {    // look at all all the child nodes of the current node\\n            // we don\\'t want to go back to the parent node so continue if condition is true\\n            if (child == parent) {\\n                continue;\\n            }\\n\\n            // Now we call the dfs for our child node\\n            // child becomes the current node, current node becomes the parent of the child\\n            int maxLenFromChild = dfs(child, currentNode, s);\\n\\n            // we want adjacent node characters to be different\\n            // in case they are equal, continue the loop\\n            // the reason we have called the dfs before is because\\n            // there still can be potential answers down below so we call the dfs anyway and it\\'ll look for it\\n            // and if this next condition is true, we just discard the further comparisons of lengths\\n            // because the current node is not going to be a part of it\\n            if (s.charAt(child) == s.charAt(currentNode)) {\\n                continue;\\n            }\\n\\n            // if the longest length we got from our child is greater than our max length\\n            // the child\\'s max length becomes the so far discovered max length\\n            // and the previous max length becomes the second max\\n            if (maxLenFromChild > maxLen) {\\n                secondMaxLen = maxLen;\\n                maxLen = maxLenFromChild;\\n            }\\n            // else if the length obtained from child is smaller than max length\\n            // but greater than second max length, we update second max length\\n            else if (maxLenFromChild > secondMaxLen) {\\n                secondMaxLen = maxLenFromChild;\\n            }\\n        }\\n\\n        // as previously discussed, two longest lengths under a node will combine along with the node itself\\n        // to form a subtree like path (a subtree with two branches/paths)\\n        // so maxLen + secondMaxLen + 1 (the current node itself)\\n        longestPath = Math.max(longestPath, maxLen + secondMaxLen + 1);     // we update the so far discovered longest path length\\n        // we return the max length of path + 1 (the current node itself) for utilisation upon backtracking\\n        // this max length is length of the path we are in right now\\n        return maxLen + 1;\\n    }\\n}\\n\\n// TC: O(e + v), SC: O(e + v)\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "``` java []\\nclass Solution {\\n    // globally declaring answer and adjacency list\\n    private int longestPath = 1;    // path is atleast going to be 1 unit long (a node itself)\\n    private List<Integer>[] adj;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        adj = new List[n];      // initialising the adjacency list\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int i = 1; i < n; i++) {   // populating the adjacency list\\n            int u = i, v = parent[i];\\n            adj[u].add(v);\\n            adj[v].add(u);\\n        }\\n\\n        dfs(0, -1, s);          // calling the dfs\\n        return longestPath;     // returning the longest path length found\\n    }\\n\\n    private int dfs(int currentNode, int parent, String s) {\\n        // there can be multiple children paths\\n        // but only the longest two of them can combine along with the current node to form a single longest path\\n        // so we take two variables which will store the longest and second longest path lengths\\n        int maxLen = 0, secondMaxLen = 0;\\n        for (int child : adj[currentNode]) {    // look at all all the child nodes of the current node\\n            // we don\\'t want to go back to the parent node so continue if condition is true\\n            if (child == parent) {\\n                continue;\\n            }\\n\\n            // Now we call the dfs for our child node\\n            // child becomes the current node, current node becomes the parent of the child\\n            int maxLenFromChild = dfs(child, currentNode, s);\\n\\n            // we want adjacent node characters to be different\\n            // in case they are equal, continue the loop\\n            // the reason we have called the dfs before is because\\n            // there still can be potential answers down below so we call the dfs anyway and it\\'ll look for it\\n            // and if this next condition is true, we just discard the further comparisons of lengths\\n            // because the current node is not going to be a part of it\\n            if (s.charAt(child) == s.charAt(currentNode)) {\\n                continue;\\n            }\\n\\n            // if the longest length we got from our child is greater than our max length\\n            // the child\\'s max length becomes the so far discovered max length\\n            // and the previous max length becomes the second max\\n            if (maxLenFromChild > maxLen) {\\n                secondMaxLen = maxLen;\\n                maxLen = maxLenFromChild;\\n            }\\n            // else if the length obtained from child is smaller than max length\\n            // but greater than second max length, we update second max length\\n            else if (maxLenFromChild > secondMaxLen) {\\n                secondMaxLen = maxLenFromChild;\\n            }\\n        }\\n\\n        // as previously discussed, two longest lengths under a node will combine along with the node itself\\n        // to form a subtree like path (a subtree with two branches/paths)\\n        // so maxLen + secondMaxLen + 1 (the current node itself)\\n        longestPath = Math.max(longestPath, maxLen + secondMaxLen + 1);     // we update the so far discovered longest path length\\n        // we return the max length of path + 1 (the current node itself) for utilisation upon backtracking\\n        // this max length is length of the path we are in right now\\n        return maxLen + 1;\\n    }\\n}\\n\\n// TC: O(e + v), SC: O(e + v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043124,
                "title": "c-easiest-solution-dfs-o-n-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS and child parent comparison with count return.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreated Adjacency List for given Par for Tree , then Performed DFS over it which return max path without same adjacent values and for finding max it also seeks max of 2 paths and sum up and compare with maximum value. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& x,int& mx,int i,string& s){\\n        if(x[i].size()==0) return 1;\\n        vector<int> e;\\n        int mx1=0,mx2=0;\\n        for(int j=0;j<x[i].size();j++){\\n            int a = dfs(x,mx,x[i][j],s);\\n            if(s[x[i][j]]==s[i]) a=0;\\n            if(a>mx1){\\n                mx2=mx1;\\n                mx1=a;\\n            }\\n            else if(a>mx2) mx2=a;\\n        }\\n        mx=max(mx,mx1+mx2+1);\\n        return mx1+1;\\n    }\\n\\n    int longestPath(vector<int>& par, string s) {\\n        int n=par.size(),mx=1;\\n        vector<vector<int>> x(n,vector<int>());\\n        for(int i=0;i<n;i++){\\n            if(par[i]!=-1) x[par[i]].push_back(i);\\n        }\\n        dfs(x,mx,0,s);\\n        return mx;\\n    }\\n};\\n```\\n\\n$Don\\'t$ $Forget$ $to$ $upvote$ \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& x,int& mx,int i,string& s){\\n        if(x[i].size()==0) return 1;\\n        vector<int> e;\\n        int mx1=0,mx2=0;\\n        for(int j=0;j<x[i].size();j++){\\n            int a = dfs(x,mx,x[i][j],s);\\n            if(s[x[i][j]]==s[i]) a=0;\\n            if(a>mx1){\\n                mx2=mx1;\\n                mx1=a;\\n            }\\n            else if(a>mx2) mx2=a;\\n        }\\n        mx=max(mx,mx1+mx2+1);\\n        return mx1+1;\\n    }\\n\\n    int longestPath(vector<int>& par, string s) {\\n        int n=par.size(),mx=1;\\n        vector<vector<int>> x(n,vector<int>());\\n        for(int i=0;i<n;i++){\\n            if(par[i]!=-1) x[par[i]].push_back(i);\\n        }\\n        dfs(x,mx,0,s);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042987,
                "title": "python-dfs-with-no-topological-sort-and-no-memoization-o-n-simple-and-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        G = defaultdict(list)\\n        for i in range(1,len(parent)):\\n            G[parent[i]].append(i)\\n        self.ans = 1\\n        #it returns the length of the longest path that starts from v to the bottom\\n        def dfs(v):\\n            if not G[v]: return 1\\n            res = 1\\n            for w in G[v]:\\n                length_of_child = dfs(w)\\n                if s[v] != s[w]:\\n                    self.ans = max(self.ans, length_of_child+res)\\n                    res = max(res, length_of_child+1)\\n            return res\\n        dfs(0)\\n        return self.ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        G = defaultdict(list)\\n        for i in range(1,len(parent)):\\n            G[parent[i]].append(i)\\n        self.ans = 1\\n        #it returns the length of the longest path that starts from v to the bottom\\n        def dfs(v):\\n            if not G[v]: return 1\\n            res = 1\\n            for w in G[v]:\\n                length_of_child = dfs(w)\\n                if s[v] != s[w]:\\n                    self.ans = max(self.ans, length_of_child+res)\\n                    res = max(res, length_of_child+1)\\n            return res\\n        dfs(0)\\n        return self.ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955300,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    int ans=0;\\n    int dfs(int i,string& s){\\n        vector<int> a;\\n        for(auto nbr:g[i]){\\n            if(s[nbr]!=s[i]) a.push_back(1+dfs(nbr,s));\\n            else ans=max(ans,dfs(nbr,s));\\n        }\\n        sort(a.begin(),a.end(),greater<int>());\\n        if(a.size()>=2) ans=max(ans,a[0]+a[1]);\\n        if(a.size()==0) return 0;\\n        return a[0];\\n    }\\n    int longestPath(vector<int>& p, string s) {\\n        g=vector<vector<int>> (s.size());\\n        \\n        for(int i=1;i<p.size();i++){\\n             g[p[i]].push_back(i);\\n        }\\n        \\n        int val=dfs(0,s);\\n        ans=max(ans,val);\\n        return ans+1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> g;\\n    int ans=0;\\n    int dfs(int i,string& s){\\n        vector<int> a;\\n        for(auto nbr:g[i]){\\n            if(s[nbr]!=s[i]) a.push_back(1+dfs(nbr,s));\\n            else ans=max(ans,dfs(nbr,s));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3043261,
                "title": "j-dfs-bottomup-detail-explanation",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/p8dYf3_00C0\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar longestPath = function(parent, s) {\\n    let n = parent.length\\n\\n    let children = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        children[i] = new Array()\\n    }\\n    for (let i = 1; i < n; i++) {\\n        children[parent[i]].push(i)\\n    }\\n\\n    s = s.split(\"\")\\n    let longestPath = 0\\n    let dfs = function(node) {\\n        let longestLength = 0, longestLength2 = 0\\n        for (let child of children[node]) {\\n            let lengthChild = dfs(child)\\n            if (s[node] == s[child]) continue\\n            if (longestLength < lengthChild) {\\n                longestLength2 = longestLength\\n                longestLength = lengthChild\\n            }\\n            else if (longestLength2 < lengthChild) {\\n                longestLength2 = lengthChild\\n            }\\n        }\\n        longestPath = Math.max(longestPath, longestLength + longestLength2 + 1)\\n        return longestLength + 1\\n    }\\n    dfs(0)\\n    return longestPath\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar longestPath = function(parent, s) {\\n    let n = parent.length\\n\\n    let children = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        children[i] = new Array()\\n    }\\n    for (let i = 1; i < n; i++) {\\n        children[parent[i]].push(i)\\n    }\\n\\n    s = s.split(\"\")\\n    let longestPath = 0\\n    let dfs = function(node) {\\n        let longestLength = 0, longestLength2 = 0\\n        for (let child of children[node]) {\\n            let lengthChild = dfs(child)\\n            if (s[node] == s[child]) continue\\n            if (longestLength < lengthChild) {\\n                longestLength2 = longestLength\\n                longestLength = lengthChild\\n            }\\n            else if (longestLength2 < lengthChild) {\\n                longestLength2 = lengthChild\\n            }\\n        }\\n        longestPath = Math.max(longestPath, longestLength + longestLength2 + 1)\\n        return longestLength + 1\\n    }\\n    dfs(0)\\n    return longestPath\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043068,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=T6GAJXCsfnQ&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=13) if you are interested.\\n\\n```cpp\\n// observation:\\n// a node can have at most two longest chains from child nodes\\n// if a node have more than two chains, take the longest two\\n// i.e. one parent node + longest + second longest\\n\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int ans = 0, n = parent.size();\\n        vector<vector<int>> g(n);\\n        // build the graph\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] ^ -1) {\\n                g[parent[i]].push_back(i);\\n            }\\n        }\\n        function<int(int)> dfs = [&](int u) {\\n            // store the longest one and the second longest\\n            int longest = 0, secondLongest = 0;\\n            for (auto v : g[u]) {\\n                // calculate the value first\\n                int val = dfs(v);\\n                // if their charachters are not same\\n                if (s[u] ^ s[v]) {\\n                    // then find out longest & secondLongest\\n                    if (val > secondLongest) secondLongest = val;\\n                    if (secondLongest > longest) swap(longest, secondLongest);\\n                }\\n            }\\n            // update ans \\n            // the value would be longest + secondLongest + 1, i.e.\\n            // the length of both chain (longest & secondLongest) + itself\\n            ans = max(ans, longest + secondLongest + 1);\\n            // take the longest one plus itself\\n            return longest + 1;\\n        };\\n        // 0 must be the root\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        ans = 0\\n        n = len(parent)\\n        g = [[] for _ in range(n)]\\n        # build the graph\\n        for i in range(n):\\n            if parent[i] != -1:\\n                g[parent[i]].append(i)\\n                \\n        def dfs(u):\\n            nonlocal ans\\n            # store the longest one and the second longest\\n            longest = 0\\n            secondLongest = 0\\n            for v in g[u]:\\n                # calculate the value first\\n                val = dfs(v)\\n                # if their charachters are not same\\n                if s[u] != s[v]:\\n                    # then find out longest & secondLongest\\n                    if val > secondLongest:\\n                        secondLongest = val\\n                    if secondLongest > longest:\\n                        longest, secondLongest = secondLongest, longest\\n                        \\n            # update ans \\n            # the value would be longest + secondLongest + 1, i.e.\\n            # the length of both chain (longest & secondLongest) + itself\\n            ans = max(ans, longest + secondLongest + 1)\\n            # take the longest one plus itself\\n            return longest + 1\\n        \\n        # 0 must be the root\\n        dfs(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\n// observation:\\n// a node can have at most two longest chains from child nodes\\n// if a node have more than two chains, take the longest two\\n// i.e. one parent node + longest + second longest\\n\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int ans = 0, n = parent.size();\\n        vector<vector<int>> g(n);\\n        // build the graph\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] ^ -1) {\\n                g[parent[i]].push_back(i);\\n            }\\n        }\\n        function<int(int)> dfs = [&](int u) {\\n            // store the longest one and the second longest\\n            int longest = 0, secondLongest = 0;\\n            for (auto v : g[u]) {\\n                // calculate the value first\\n                int val = dfs(v);\\n                // if their charachters are not same\\n                if (s[u] ^ s[v]) {\\n                    // then find out longest & secondLongest\\n                    if (val > secondLongest) secondLongest = val;\\n                    if (secondLongest > longest) swap(longest, secondLongest);\\n                }\\n            }\\n            // update ans \\n            // the value would be longest + secondLongest + 1, i.e.\\n            // the length of both chain (longest & secondLongest) + itself\\n            ans = max(ans, longest + secondLongest + 1);\\n            // take the longest one plus itself\\n            return longest + 1;\\n        };\\n        // 0 must be the root\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        ans = 0\\n        n = len(parent)\\n        g = [[] for _ in range(n)]\\n        # build the graph\\n        for i in range(n):\\n            if parent[i] != -1:\\n                g[parent[i]].append(i)\\n                \\n        def dfs(u):\\n            nonlocal ans\\n            # store the longest one and the second longest\\n            longest = 0\\n            secondLongest = 0\\n            for v in g[u]:\\n                # calculate the value first\\n                val = dfs(v)\\n                # if their charachters are not same\\n                if s[u] != s[v]:\\n                    # then find out longest & secondLongest\\n                    if val > secondLongest:\\n                        secondLongest = val\\n                    if secondLongest > longest:\\n                        longest, secondLongest = secondLongest, longest\\n                        \\n            # update ans \\n            # the value would be longest + secondLongest + 1, i.e.\\n            # the length of both chain (longest & secondLongest) + itself\\n            ans = max(ans, longest + secondLongest + 1)\\n            # take the longest one plus itself\\n            return longest + 1\\n        \\n        # 0 must be the root\\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979509,
                "title": "java-dfs-solution-easy-to-read-and-understand-short-code",
                "content": "```\\nclass Solution {\\n    int ans = 1;\\n    int dist[] = new int[100005];\\n    \\n    public int longestPath(int[] parent, String s) {\\n        \\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        \\n        for(int i=0; i<s.length(); i++) list.add(new ArrayList<>());\\n        \\n        for(int i=1; i<s.length(); i++){\\n            list.get(parent[i]).add(i);\\n        }\\n\\n        dfs(0, s, list);\\n        \\n        return ans;        \\n    }\\n    \\n    public void dfs(int src, String s, ArrayList<ArrayList<Integer>> list){\\n        \\n        dist[src] = 1; \\n        // cuz at first \\'0\\'(root) has 1 distance only and same goes for \\'leaf\\' and other nodes \\n        \\n        for(int child : list.get(src)){\\n            \\n            dfs(child, s, list);\\n            \\n            if(s.charAt(child) != s.charAt(src)){\\n                \\n                ans = Math.max(ans, dist[src] + dist[child]);\\n                // total distance as a span\\n                \\n                dist[src] = Math.max(dist[src], dist[child] +1); \\n                // max child distance of root is maintained as dist[src] for future answers, if any               \\n            }            \\n            \\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 1;\\n    int dist[] = new int[100005];\\n    \\n    public int longestPath(int[] parent, String s) {\\n        \\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        \\n        for(int i=0; i<s.length(); i++) list.add(new ArrayList<>());\\n        \\n        for(int i=1; i<s.length(); i++){\\n            list.get(parent[i]).add(i);\\n        }\\n\\n        dfs(0, s, list);\\n        \\n        return ans;        \\n    }\\n    \\n    public void dfs(int src, String s, ArrayList<ArrayList<Integer>> list){\\n        \\n        dist[src] = 1; \\n        // cuz at first \\'0\\'(root) has 1 distance only and same goes for \\'leaf\\' and other nodes \\n        \\n        for(int child : list.get(src)){\\n            \\n            dfs(child, s, list);\\n            \\n            if(s.charAt(child) != s.charAt(src)){\\n                \\n                ans = Math.max(ans, dist[src] + dist[child]);\\n                // total distance as a span\\n                \\n                dist[src] = Math.max(dist[src], dist[child] +1); \\n                // max child distance of root is maintained as dist[src] for future answers, if any               \\n            }            \\n            \\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042998,
                "title": "java-c-dfs-explained-beats-85",
                "content": "## Intuition\\n\\nTwo longest paths in a subtree of node x can make up the max longest path.\\n\\n## Approach\\n\\nStep 1. Find two longest path out of k children for each node.\\nStep 2. Update global maxPath value if maxPath1+maxPath2> maxPath\\nStep 3. Return longest path for each child node to parent node using dfs.\\n\\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\\n* If adjacent node letters are equal set pathlength for children = 0.\\n\\n\\n## Code\\n``` java []\\nclass Solution {\\n    int maxPath=0;\\n    public int longestPath(int[] parent, String s){\\n\\n        //Creating adjacency list\\n\\n        ArrayList<Integer>[] a = new ArrayList[parent.length];\\n        \\n        for(int i=0;i<parent.length;i++)\\n            a[i] = new ArrayList<Integer>();\\n\\n        for(int i=1;i<parent.length;i++)\\n            a[parent[i]].add(i);\\n\\n        // dfs from root node\\n        dfs(0,a,s);\\n        \\n        return maxPath+1;  //since we have to return no. of vertices in path length, so adding +1\\n    }\\n\\n    private int dfs(int root,ArrayList<Integer>[] a,String s)\\n    {\\n        int maxPath1=0;//first longest Path\\n        int maxPath2=0;//second longest Path\\n        for(int child:a[root]){\\n            int pathlength=dfs(child,a,s); //longest path for children node\\n            pathlength=s.charAt(child)==s.charAt(root)?0:pathlength+1;\\n                \\n            if(pathlength>=maxPath1){\\n                maxPath2=maxPath1;\\n                maxPath1=pathlength;\\n            }\\n            else if(pathlength>=maxPath2)\\n                maxPath2=pathlength;\\n        }\\n        maxPath = Math.max(maxPath,maxPath1+maxPath2); //updating global maxPath\\n         \\n        return maxPath1; //return longest path for children node\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\n    int maxPath=0;\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n\\n        // Creating adjacency list\\n        vector<vector<int>> a(parent.size());\\n    \\n        for (int i = 1; i < parent.size(); i++) {\\n            a[parent[i]].push_back(i);\\n        }\\n\\n        // dfs from root node\\n        dfs(0, a, s);\\n\\n        return maxPath + 1;  // since we have to return no. of vertices in path length, so adding +1\\n    }\\n\\n        int dfs(int root, vector<vector<int>>& a, string& s) {\\n        int maxPath1=0;//first longest Path\\n        int maxPath2=0;//second longest Path\\n        for(int child:a[root]){\\n            int pathlength=dfs(child,a,s); //longest path for children node\\n            pathlength=s[child]==s[root]?0:pathlength+1;\\n                \\n            if(pathlength>=maxPath1){\\n                maxPath2=maxPath1;\\n                maxPath1=pathlength;\\n            }\\n            else if(pathlength>=maxPath2)\\n                maxPath2=pathlength;\\n        }\\n        maxPath = max(maxPath,maxPath1+maxPath2); //updating global maxPath\\n\\n        return maxPath1; //return longest path for children node\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    int maxPath=0;\\n    public int longestPath(int[] parent, String s){\\n\\n        //Creating adjacency list\\n\\n        ArrayList<Integer>[] a = new ArrayList[parent.length];\\n        \\n        for(int i=0;i<parent.length;i++)\\n            a[i] = new ArrayList<Integer>();\\n\\n        for(int i=1;i<parent.length;i++)\\n            a[parent[i]].add(i);\\n\\n        // dfs from root node\\n        dfs(0,a,s);\\n        \\n        return maxPath+1;  //since we have to return no. of vertices in path length, so adding +1\\n    }\\n\\n    private int dfs(int root,ArrayList<Integer>[] a,String s)\\n    {\\n        int maxPath1=0;//first longest Path\\n        int maxPath2=0;//second longest Path\\n        for(int child:a[root]){\\n            int pathlength=dfs(child,a,s); //longest path for children node\\n            pathlength=s.charAt(child)==s.charAt(root)?0:pathlength+1;\\n                \\n            if(pathlength>=maxPath1){\\n                maxPath2=maxPath1;\\n                maxPath1=pathlength;\\n            }\\n            else if(pathlength>=maxPath2)\\n                maxPath2=pathlength;\\n        }\\n        maxPath = Math.max(maxPath,maxPath1+maxPath2); //updating global maxPath\\n         \\n        return maxPath1; //return longest path for children node\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\n    int maxPath=0;\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n\\n        // Creating adjacency list\\n        vector<vector<int>> a(parent.size());\\n    \\n        for (int i = 1; i < parent.size(); i++) {\\n            a[parent[i]].push_back(i);\\n        }\\n\\n        // dfs from root node\\n        dfs(0, a, s);\\n\\n        return maxPath + 1;  // since we have to return no. of vertices in path length, so adding +1\\n    }\\n\\n        int dfs(int root, vector<vector<int>>& a, string& s) {\\n        int maxPath1=0;//first longest Path\\n        int maxPath2=0;//second longest Path\\n        for(int child:a[root]){\\n            int pathlength=dfs(child,a,s); //longest path for children node\\n            pathlength=s[child]==s[root]?0:pathlength+1;\\n                \\n            if(pathlength>=maxPath1){\\n                maxPath2=maxPath1;\\n                maxPath1=pathlength;\\n            }\\n            else if(pathlength>=maxPath2)\\n                maxPath2=pathlength;\\n        }\\n        maxPath = max(maxPath,maxPath1+maxPath2); //updating global maxPath\\n\\n        return maxPath1; //return longest path for children node\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360488,
                "title": "dfs-on-tree",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int dfs(int i, int par, vector<int> adj[], string &s) {\\n        int ans = 1;\\n        vector<int>curs;\\n        for(auto &j : adj[i]) {\\n            if(j != par){\\n                int cur = dfs(j, i, adj, s);\\n                if(s[i] != s[j])cur++;\\n                else cur = 0;\\n                ans = max(ans, cur);\\n                curs.push_back(cur);\\n            }\\n        }\\n        int sz = curs.size();\\n        sort(begin(curs), end(curs));\\n        if(sz > 1) maxi = max(maxi, curs[sz-1] + curs[sz-2] - 1);\\n        maxi = max(maxi, ans);\\n        return ans;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        for(int i = 1; i < parent.size(); i++) {\\n            adj[parent[i]].push_back(i);\\n            adj[i].push_back(parent[i]);\\n        } \\n        dfs(0, -1,  adj, s);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int dfs(int i, int par, vector<int> adj[], string &s) {\\n        int ans = 1;\\n        vector<int>curs;\\n        for(auto &j : adj[i]) {\\n            if(j != par){\\n                int cur = dfs(j, i, adj, s);\\n                if(s[i] != s[j])cur++;\\n                else cur = 0;\\n                ans = max(ans, cur);\\n                curs.push_back(cur);\\n            }\\n        }\\n        int sz = curs.size();\\n        sort(begin(curs), end(curs));\\n        if(sz > 1) maxi = max(maxi, curs[sz-1] + curs[sz-2] - 1);\\n        maxi = max(maxi, ans);\\n        return ans;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        for(int i = 1; i < parent.size(); i++) {\\n            adj[parent[i]].push_back(i);\\n            adj[i].push_back(parent[i]);\\n        } \\n        dfs(0, -1,  adj, s);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043875,
                "title": "c-java-easy-dfs-approach-o-n",
                "content": "**Upvote the post if you like it <3** \\n\\n**Intuition:**\\n\\nThe problem is looking for the **longest** path in a tree such that no **pair** of **adjacent** nodes on the path have the same character assigned to them. One way to find this path is to **start** at the **root** of the tree and explore all **possible** paths through the tree while keeping track of the **longest** path that satisfies the condition. \\nThis is exactly what **DFS** does, it starts at the root and explores all possible paths by **visiting** each **node** and its **children**.\\n\\n**Approach:**\\n\\nThe approach that we are using is the **Depth First Search (DFS)** algorithm as said earlier to traverse the tree and find the **longest** path such that no pair of adjacent nodes on the path have the same character assigned to them.\\n\\n**Here are the steps of this approach:**\\n\\n1. Initialize the variable **n** to the size of the parent vector, and the variable **ans** to 1. This is because the **minimum** longest path that can be guaranteed is the node itself, which has a **length** of 1.\\n2. Create an **adjacency** list **adj** of size n to represent the tree. For each node, i starting from 1 to n-1, add i as a child of the parent node **parent**[i] in the adjacency list.\\n3. Call the **longestPathDfs** function, passing in the parameters 0, adj, s, and ans. This function will use **DFS** to traverse the tree, starting from the root node, and find the **longest** path that satisfies the condition.\\n4. Inside the **longestPathDfs** function, initialize two variables **currentMax** and **secondMax** to 0. These variables will be used to store the maximum and second maximum lengths of the path found so far.\\n5. Iterate through the children of the current node, **nextNode**, in the adjacency list.\\n6. For each child, recursively call the **longestPathDfs** function with the current child node, **nextNode**, as the new current node, and update the result variable with the returned value.\\n7. If the character assigned to the current node is the same as the character assigned to the child node, skip to the next child node.\\n8. If the result is greater than **currentMax**, update **secondMax** to **currentMax**, and update **currentMax** to the result.\\n9. Else, if the result is greater than **secondMax**, update **secondMax** to be result.\\n10. After iterating through all children, update the **maxLength** variable to be the maximum of its current value and the value of 1 + **currentMax** + **secondMax**. This is because the path we are looking for can be the concatenation of two paths we found while traversing the tree.\\n11. Finally, return the value of 1 + **currentMax**.\\n\\n----\\n\\nHere is the **implementation** of the approach in **C++**:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans=1; \\n//at any way the minimum longest path that we can definitely get will be that particular node i.e 1\\n        vector<vector<int>>adj(n);\\n        for(int i=1;i<n;i++) adj[parent[i]].push_back(i);\\n        longestPathDfs(0,adj,s,ans);\\n        return ans;\\n    }\\nprivate:\\n    int longestPathDfs(int currentNode,vector<vector<int>>&adjacentNodes,string &stringInput,int &maxLength){\\n        int currentMax=0;\\n        int secondMax=0;\\n        for(auto nextNode:adjacentNodes[currentNode]){\\n            int result = longestPathDfs(nextNode,adjacentNodes,stringInput,maxLength);\\n            if(stringInput[currentNode] == stringInput[nextNode]){ // adjacent are same character\\n                continue;\\n            }\\n            if(result > currentMax){\\n                secondMax = currentMax;\\n                currentMax = result;\\n            }\\n            else if(result > secondMax){\\n                secondMax = result;\\n            }\\n        }\\n        maxLength = max(maxLength, 1 + currentMax + secondMax);\\n        return 1 + currentMax;\\n    }\\n};\\n```\\n\\nHere is the **implementation** of the solution in **Java**:\\n```\\nclass Solution {\\n    int ans = 1;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\\n        for (int i = 1; i < n; i++) adj.get(parent[i]).add(i);\\n        longestPathDfs(0, adj, s);\\n        return ans;\\n    }\\n    private int longestPathDfs(int currentNode, List<List<Integer>> adjacentNodes, String stringInput) {\\n        int currentMax = 0;\\n        int secondMax = 0;\\n        for (int nextNode : adjacentNodes.get(currentNode)) {\\n            int result = longestPathDfs(nextNode, adjacentNodes, stringInput);\\n            if (stringInput.charAt(currentNode) == stringInput.charAt(nextNode)) continue;\\n            if (result > currentMax) {\\n                secondMax = currentMax;\\n                currentMax = result;\\n            } else if (result > secondMax) {\\n                secondMax = result;\\n            }\\n        }\\n        ans = Math.max(ans, 1 + currentMax + secondMax);\\n        return 1 + currentMax;\\n    }\\n}\\n```\\n\\n\\n----\\n\\nThe **Time Complexity** of this approach is **O(n)**, as each node is visited once. \\nThe **Space Complexity** is also **O(n)** due to the use of an adjacency list to represent the tree.\\n\\n----\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans=1; \\n//at any way the minimum longest path that we can definitely get will be that particular node i.e 1\\n        vector<vector<int>>adj(n);\\n        for(int i=1;i<n;i++) adj[parent[i]].push_back(i);\\n        longestPathDfs(0,adj,s,ans);\\n        return ans;\\n    }\\nprivate:\\n    int longestPathDfs(int currentNode,vector<vector<int>>&adjacentNodes,string &stringInput,int &maxLength){\\n        int currentMax=0;\\n        int secondMax=0;\\n        for(auto nextNode:adjacentNodes[currentNode]){\\n            int result = longestPathDfs(nextNode,adjacentNodes,stringInput,maxLength);\\n            if(stringInput[currentNode] == stringInput[nextNode]){ // adjacent are same character\\n                continue;\\n            }\\n            if(result > currentMax){\\n                secondMax = currentMax;\\n                currentMax = result;\\n            }\\n            else if(result > secondMax){\\n                secondMax = result;\\n            }\\n        }\\n        maxLength = max(maxLength, 1 + currentMax + secondMax);\\n        return 1 + currentMax;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int ans = 1;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\\n        for (int i = 1; i < n; i++) adj.get(parent[i]).add(i);\\n        longestPathDfs(0, adj, s);\\n        return ans;\\n    }\\n    private int longestPathDfs(int currentNode, List<List<Integer>> adjacentNodes, String stringInput) {\\n        int currentMax = 0;\\n        int secondMax = 0;\\n        for (int nextNode : adjacentNodes.get(currentNode)) {\\n            int result = longestPathDfs(nextNode, adjacentNodes, stringInput);\\n            if (stringInput.charAt(currentNode) == stringInput.charAt(nextNode)) continue;\\n            if (result > currentMax) {\\n                secondMax = currentMax;\\n                currentMax = result;\\n            } else if (result > secondMax) {\\n                secondMax = result;\\n            }\\n        }\\n        ans = Math.max(ans, 1 + currentMax + secondMax);\\n        return 1 + currentMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044016,
                "title": "simple-solution-detailed-explanation-beats-98",
                "content": "# Intuition\\n A  simple  tree is given, we just need to find the longest path in the tree, that\\'s all!!! Just one more condition is given that if two adjacent nodes have same label value (in alphabet), then we don\\'t have to consider that path.\\n\\n# Approach\\n- Just do a DFS of tree, single pass, do some work(more about this below) and return.\\n- BUT BEFORE we can do DFS, we need to have proper structure of input, nobody ever did a DFS with a parent array!!. We need a node\\'s children to do traversal, not parent. So let\\'s first convert parent array to children array\\n- Declare an array of vectors. Each vector in array will hold node\\'s children. Then traverse via parent array and put the current node in children of parent.\\n- Now we are ready to do dfs, just make a recursive call on root and begin. Get Set Go!!!\\n- But wait, before we begin - declare a global/ class level MAX variable. This var will maintain global max which is what we need to return as final answer\\n- In recursive function, each node will make call to it\\'s children. NO need to check the label, even thought the label might be same, but who knows there might be global maxima hidden somewhere deep down, so make call for every child.\\n- Now the children are done processing and it\\'s time to do work for the current node.\\n- We need to see if the current node is forming the joining point of two paths in subtree and making a global maxima. How long would that path be?? It would be First longest Subpath + Second longest Subpath + 1 (for the current node) - See image below.\\n![LC.png](https://assets.leetcode.com/users/images/f582a02c-758f-4abd-9178-b8591827d0b0_1673591688.67146.png)\\n- So for global answer purpose we calculate `first_max_longest_path + 1 + second_max_longest_path`, but for returning to parent so that it too has ability to do such calculation , we return the longest staright path (without bend) i.e `first_max_longest_path_from_subtree + 1`\\n- All of this is fine and this helps to find the longest path in tree (which is precursor for this problem), so for satisying the condition that no two adjacent nodes on such path should have same label, we ignore answer from those child nodes that have same label as current node. \\n>Remember we call for for all child nodes, so that global maxima is found, but upon returning we discard some answers for calculation of current node if the label is same\\n\\n# Peculiarity\\n- We need to find first max and second max. The comparison here is not one int to one, where we can use max function. Here we need to compare new candidate integer to two existing integers , first_max and second_max and see whether the new int lies above `first_max`, or below `second max`, or in between these two and update `first_max` & `second_max` accordingly\\n- Initial values of `first_max` and `second_max` can be set to zero because if no good path is found we need to calculate `first_max` + 1 + `second_max` i.e  (0 + 1 + 0) for global path and return `first_max` + 1  i.e (0 + 1) for parent\\n\\n# Getting good time complexity and \\'Beats x % of submissions\\' \\u2764\\uFE0F\\u2764\\uFE0F\\n- Dont pass unnecessary values in recursive function.\\n> One of my initial (and best) obsevation right from the early recursion days was that we don\\'t need to pass anything in recursive functions that will stay constant for all function instances. Pass only those values that will change with calls and keep the values such as label string/ children array as global. This prevents unnecessary copying (for both by value and by reference) and hence makes each function call lighter.\\n- Dont compare/ do any operation if child label is same as current node label. Also the comparision function with two integers is written in the recursive function itself to avoid extra calls to a helper function and use of little more expensive max function. Delegating this responsibility to a helper function `update_max(int& first_max, int& second_max, int new_candidate)` would have made the code a lot neater, but a little slower too!! \\uD83D\\uDE12\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ Since only one pass of nodes is done in recursive calls\\n\\n- Space complexity:\\n$$O(n)$$, $\\\\theta(log(n))$ Since max $$log(n)$$ function calls might be waiting on recursive function call stack in a balanced tree and $$n$$ calls in a fully skewed linked list type tree. \\n\\n## Please upvote if you like the explaination, Spread some Love!! \\u2728\\u2728\\u2728\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // declared here, no need to pass in recursive functions\\n    vector<int>* children; \\n    string s;\\n    int maxSoFar = 1;\\n\\n    int recur(int node)\\n    {\\n        int n = children[node].size();\\n\\n        int first = 0;      // first highest path in my subtree\\n        int second = 0;     // second hihghest path in my subtree\\n\\n        for(int i = 0; i<n; i++)\\n        { \\n            int ele = children[node][i];\\n            int smallAns = recur(ele);\\n            \\n            if(s[ele] == s[node])   // no need to consider if child has same aplphabet\\n                continue;\\n            \\n            // compete candidate soln with first and second highest\\n            if(smallAns < second)\\n                continue;\\n            \\n            // now candt >= second\\n            if(smallAns < first)\\n            {\\n                second = smallAns;\\n                continue;\\n            }\\n            \\n            // now candt >= first\\n            second = first;\\n            first = smallAns;\\n        }\\n\\n        int myGlobAns = first + second + 1;\\n        if(myGlobAns > maxSoFar)\\n            maxSoFar = myGlobAns;\\n        \\n        return first + 1;   // retuned answer is diff from myGlobAns\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n\\n        // these are global/ class level, no need to pass in functions\\n        this->s = s;\\n        children = new vector<int>[n];\\n        \\n        // converting parent array to children array\\n        for(int i = 1; i<n; i++)\\n            children[parent[i]].push_back(i);\\n\\n        // just call the function with starting node\\n        recur(0);\\n        return maxSoFar;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // declared here, no need to pass in recursive functions\\n    vector<int>* children; \\n    string s;\\n    int maxSoFar = 1;\\n\\n    int recur(int node)\\n    {\\n        int n = children[node].size();\\n\\n        int first = 0;      // first highest path in my subtree\\n        int second = 0;     // second hihghest path in my subtree\\n\\n        for(int i = 0; i<n; i++)\\n        { \\n            int ele = children[node][i];\\n            int smallAns = recur(ele);\\n            \\n            if(s[ele] == s[node])   // no need to consider if child has same aplphabet\\n                continue;\\n            \\n            // compete candidate soln with first and second highest\\n            if(smallAns < second)\\n                continue;\\n            \\n            // now candt >= second\\n            if(smallAns < first)\\n            {\\n                second = smallAns;\\n                continue;\\n            }\\n            \\n            // now candt >= first\\n            second = first;\\n            first = smallAns;\\n        }\\n\\n        int myGlobAns = first + second + 1;\\n        if(myGlobAns > maxSoFar)\\n            maxSoFar = myGlobAns;\\n        \\n        return first + 1;   // retuned answer is diff from myGlobAns\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n\\n        // these are global/ class level, no need to pass in functions\\n        this->s = s;\\n        children = new vector<int>[n];\\n        \\n        // converting parent array to children array\\n        for(int i = 1; i<n; i++)\\n            children[parent[i]].push_back(i);\\n\\n        // just call the function with starting node\\n        recur(0);\\n        return maxSoFar;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962794,
                "title": "cpp-simple-solution-dfs-diameter-of-a-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> d;\\n    unordered_map<int, int> vis;\\n    int fans = 0;\\n    \\n    int dfs(int root){\\n        \\n        if(vis[root] == 1) return 0;\\n        vis[root] = 1;\\n        \\n        vector<int> ansx = {0, 0};\\n        \\n        for(int i: d[root]){\\n            if(vis[i] == 0)\\n            ansx.push_back(dfs(i));\\n        }\\n        \\n        sort(ansx.begin(), ansx.end());\\n        int ans = 1 + ansx.back() + ansx[ansx.size()-2];\\n        fans = max(fans, ans);\\n        return 1 + ansx.back();\\n        \\n    }\\n    \\n    int longestPath(vector<int>& parent, string s) {\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i] != -1 && s[i] != s[parent[i]]){\\n                d[i].push_back(parent[i]);\\n                d[parent[i]].push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0;i<parent.size();i++){\\n            dfs(i);\\n        }\\n        \\n        return fans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> d;\\n    unordered_map<int, int> vis;\\n    int fans = 0;\\n    \\n    int dfs(int root){\\n        \\n        if(vis[root] == 1) return 0;\\n        vis[root] = 1;\\n        \\n        vector<int> ansx = {0, 0};\\n        \\n        for(int i: d[root]){\\n            if(vis[i] == 0)\\n            ansx.push_back(dfs(i));\\n        }\\n        \\n        sort(ansx.begin(), ansx.end());\\n        int ans = 1 + ansx.back() + ansx[ansx.size()-2];\\n        fans = max(fans, ans);\\n        return 1 + ansx.back();\\n        \\n    }\\n    \\n    int longestPath(vector<int>& parent, string s) {\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i] != -1 && s[i] != s[parent[i]]){\\n                d[i].push_back(parent[i]);\\n                d[parent[i]].push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0;i<parent.size();i++){\\n            dfs(i);\\n        }\\n        \\n        return fans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958690,
                "title": "8-lines-python-using-graphlib-topologicalsorter",
                "content": "I use a topological sorter to visit the nodes from leaves to root. And `downs[i]` stores a list of lengths of paths going down from node `i`.\\n```\\nfrom graphlib import TopologicalSorter\\n\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        def lengths():\\n            downs = [[0] for _ in s]\\n            ts = TopologicalSorter(dict(enumerate(zip(parent))))\\n            for node in [*ts.static_order()][:0:-1]:\\n                yield 1 + sum(nlargest(2, downs[node]))\\n                if s[node] != s[parent[node]]:\\n                    downs[parent[node]].append(1 + max(downs[node]))\\n        return max(lengths())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom graphlib import TopologicalSorter\\n\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        def lengths():\\n            downs = [[0] for _ in s]\\n            ts = TopologicalSorter(dict(enumerate(zip(parent))))\\n            for node in [*ts.static_order()][:0:-1]:\\n                yield 1 + sum(nlargest(2, downs[node]))\\n                if s[node] != s[parent[node]]:\\n                    downs[parent[node]].append(1 + max(downs[node]))\\n        return max(lengths())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955404,
                "title": "java-dfs",
                "content": "\\n```\\nclass Solution {\\n    public int longestPath(int[] parent, String s) {\\n        ArrayList<ArrayList<Integer>> a=new ArrayList<>();\\n        for(int i=0;i<parent.length;i++)a.add(new ArrayList<Integer>());\\n        for(int i=1;i<parent.length;i++){\\n            a.get(parent[i]).add(i);\\n        }\\n        Pair p=dfs(0,a,s);\\n        return p.maxCount;\\n    }\\n    public Pair dfs(int root,ArrayList<ArrayList<Integer>> a,String s){\\n        if(a.get(root).size()==0)return new Pair(1,1);\\n        int maxCount=0,count1=0,count2=0;\\n        for(int child:a.get(root)){\\n            Pair pair=dfs(child,a,s);\\n            maxCount=Math.max(maxCount,pair.maxCount);\\n            if(s.charAt(root)!=s.charAt(child)){\\n                if(count1<pair.count){\\n                    count2=count1;\\n                    count1=pair.count;\\n                }else if(pair.count>count2){\\n                    count2=pair.count;\\n                }\\n            }\\n        }\\n        maxCount=Math.max(maxCount,count1+count2+1);\\n        return new Pair(count1+1,maxCount);\\n    }\\n    class Pair{\\n        int count,maxCount;\\n        Pair(int count,int maxCount){\\n            this.count=count;\\n            this.maxCount=maxCount;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPath(int[] parent, String s) {\\n        ArrayList<ArrayList<Integer>> a=new ArrayList<>();\\n        for(int i=0;i<parent.length;i++)a.add(new ArrayList<Integer>());\\n        for(int i=1;i<parent.length;i++){\\n            a.get(parent[i]).add(i);\\n        }\\n        Pair p=dfs(0,a,s);\\n        return p.maxCount;\\n    }\\n    public Pair dfs(int root,ArrayList<ArrayList<Integer>> a,String s){\\n        if(a.get(root).size()==0)return new Pair(1,1);\\n        int maxCount=0,count1=0,count2=0;\\n        for(int child:a.get(root)){\\n            Pair pair=dfs(child,a,s);\\n            maxCount=Math.max(maxCount,pair.maxCount);\\n            if(s.charAt(root)!=s.charAt(child)){\\n                if(count1<pair.count){\\n                    count2=count1;\\n                    count1=pair.count;\\n                }else if(pair.count>count2){\\n                    count2=pair.count;\\n                }\\n            }\\n        }\\n        maxCount=Math.max(maxCount,count1+count2+1);\\n        return new Pair(count1+1,maxCount);\\n    }\\n    class Pair{\\n        int count,maxCount;\\n        Pair(int count,int maxCount){\\n            this.count=count;\\n            this.maxCount=maxCount;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044213,
                "title": "simple-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do simple dfs and  check at each  node max length of subtree such that no two adjacent are same and then increment the count and also check with answer count if its maximum or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n) : `Traverse each node max n nodes of tree`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) : `Recursive stack` \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    int ans=1;\\n    int dfs(int node,int par,string&s){\\n     \\n      int parC=1;  \\n      for(auto x:adj[node]){\\n          if(x!=par){\\n             int childC=dfs(x,node,s);\\n          \\n          if(s[x]!=s[node]){\\n             ans=max(childC+parC,ans);\\n             parC= max(parC,childC+1);\\n          }\\n          }\\n      }\\n      \\n      return parC;\\n    }\\n    int longestPath(vector<int>& p, string s) {\\n        int n=p.size();\\n        adj.resize(n);\\n        for(int i=0;i<n;i++){\\n            if(i!=0){\\n            adj[p[i]].push_back(i);\\n            adj[i].push_back(p[i]);\\n            }\\n        }\\n      dfs(0,-1,s);\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    int ans=1;\\n    int dfs(int node,int par,string&s){\\n     \\n      int parC=1;  \\n      for(auto x:adj[node]){\\n          if(x!=par){\\n             int childC=dfs(x,node,s);\\n          \\n          if(s[x]!=s[node]){\\n             ans=max(childC+parC,ans);\\n             parC= max(parC,childC+1);\\n          }\\n          }\\n      }\\n      \\n      return parC;\\n    }\\n    int longestPath(vector<int>& p, string s) {\\n        int n=p.size();\\n        adj.resize(n);\\n        for(int i=0;i<n;i++){\\n            if(i!=0){\\n            adj[p[i]].push_back(i);\\n            adj[i].push_back(p[i]);\\n            }\\n        }\\n      dfs(0,-1,s);\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043728,
                "title": "c-begineer-friendly-easy-understanding-dfs-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=L1ThfzJQfQY/\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\n // to store the ans.\\n    int ans=1;\\n    vector<vector<int>>adjlist;\\n\\n    int dfs(int node,int parent,string& s){\\n        // to store the max length upto that node including it , so initialize with 1.\\n        int maxpath=1;\\n\\n\\n        for(auto x : adjlist[node]){\\n        //   check only for children\\n            if(x != parent){\\n            int temp=dfs(x,node,s);\\n\\n            //if node character and its child character is not equal\\n            if(s[node]!=s[x]){\\n                // update the ans with maximum value.\\n                // update the maxpath length to return to its parent.\\n                ans=max(ans,maxpath+temp);\\n                maxpath=max(maxpath,1+temp);\\n            }\\n            }\\n\\n        }\\n        // return the maxpath for current node.\\n        return maxpath;\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        adjlist.resize(n);\\n\\n        //create adjacency list\\n        for(int i=1;i<n;i++){\\n            adjlist[parent[i]].push_back(i);\\n            adjlist[i].push_back(parent[i]);\\n        }\\n        //call dfs.\\n        dfs(0,-1,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n // to store the ans.\\n    int ans=1;\\n    vector<vector<int>>adjlist;\\n\\n    int dfs(int node,int parent,string& s){\\n        // to store the max length upto that node including it , so initialize with 1.\\n        int maxpath=1;\\n\\n\\n        for(auto x : adjlist[node]){\\n        //   check only for children\\n            if(x != parent){\\n            int temp=dfs(x,node,s);\\n\\n            //if node character and its child character is not equal\\n            if(s[node]!=s[x]){\\n                // update the ans with maximum value.\\n                // update the maxpath length to return to its parent.\\n                ans=max(ans,maxpath+temp);\\n                maxpath=max(maxpath,1+temp);\\n            }\\n            }\\n\\n        }\\n        // return the maxpath for current node.\\n        return maxpath;\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        adjlist.resize(n);\\n\\n        //create adjacency list\\n        for(int i=1;i<n;i++){\\n            adjlist[parent[i]].push_back(i);\\n            adjlist[i].push_back(parent[i]);\\n        }\\n        //call dfs.\\n        dfs(0,-1,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043457,
                "title": "easy-c-solution-short-simple-best-method-easy-to-understand",
                "content": "# Intuition\\n**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n         const int n = parent.size();\\n    int ans = 1;\\n    vector<vector<int>> graph(n);\\n\\n    for (int i = 1; i < n; ++i)\\n      graph[parent[i]].push_back(i);\\n\\n    longestPathDownFrom(graph, 0, s, ans);\\n    return ans;\\n  }\\n\\n private:\\n  int longestPathDownFrom(const vector<vector<int>>& graph, int u,\\n                          const string& s, int& ans) {\\n    int max1 = 0;\\n    int max2 = 0;\\n\\n    for (const int v : graph[u]) {\\n      const int res = longestPathDownFrom(graph, v, s, ans);\\n      if (s[u] == s[v])\\n        continue;\\n      if (res > max1) {\\n        max2 = max1;\\n        max1 = res;\\n      } else if (res > max2) {\\n        max2 = res;\\n      }\\n    }\\n\\n    ans = max(ans, 1 + max1 + max2);\\n    return 1 + max1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n         const int n = parent.size();\\n    int ans = 1;\\n    vector<vector<int>> graph(n);\\n\\n    for (int i = 1; i < n; ++i)\\n      graph[parent[i]].push_back(i);\\n\\n    longestPathDownFrom(graph, 0, s, ans);\\n    return ans;\\n  }\\n\\n private:\\n  int longestPathDownFrom(const vector<vector<int>>& graph, int u,\\n                          const string& s, int& ans) {\\n    int max1 = 0;\\n    int max2 = 0;\\n\\n    for (const int v : graph[u]) {\\n      const int res = longestPathDownFrom(graph, v, s, ans);\\n      if (s[u] == s[v])\\n        continue;\\n      if (res > max1) {\\n        max2 = max1;\\n        max1 = res;\\n      } else if (res > max2) {\\n        max2 = res;\\n      }\\n    }\\n\\n    ans = max(ans, 1 + max1 + max2);\\n    return 1 + max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099836,
                "title": "c-simple-dfs-solution-easy-to-understand",
                "content": "Simple DFS Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    int ans=0;\\n   int dfs(int node,int par, string &s){\\n       // vector to store max length & second max length that we get from children of node at v[1] & v[0] respectively\\n        vector<int>v(2,0);\\n       for(auto child:g[node]){\\n           if(child != par){\\n               int x = dfs(child,node,s);\\n\\t\\t\\t   // if char at node != char at child then node can be included in our ans\\n               if(s[node] != s[child]){\\n                   if(v[1]<x){\\n                       v[0]=v[1];\\n                       v[1]=x;\\n                       \\n                   }else{\\n                       v[0]=max(v[0],x);\\n                   }\\n               }\\n               \\n           }\\n       }\\n       // update our ans every time we return to node\\n       ans = max(ans, v[0]+v[1]+1);\\n\\t   //return the max length up till here including node\\n       return max(v[0],v[1])+1;\\n        \\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        \\n        ans =0;\\n        g.assign(n+1,{});\\n        for(int i=1;i<parent.size();i++){\\n           g[parent[i]].push_back(i);\\n           g[i].push_back(parent[i]);\\n        }\\n\\t\\t// run dfs and calculate max \\n        ans = max(ans, dfs(0,-1,s));\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    int ans=0;\\n   int dfs(int node,int par, string &s){\\n       // vector to store max length & second max length that we get from children of node at v[1] & v[0] respectively\\n        vector<int>v(2,0);\\n       for(auto child:g[node]){\\n           if(child != par){\\n               int x = dfs(child,node,s);\\n\\t\\t\\t   // if char at node != char at child then node can be included in our ans\\n               if(s[node] != s[child]){\\n                   if(v[1]<x){\\n                       v[0]=v[1];\\n                       v[1]=x;\\n                       \\n                   }else{\\n                       v[0]=max(v[0],x);\\n                   }\\n               }\\n               \\n           }\\n       }\\n       // update our ans every time we return to node\\n       ans = max(ans, v[0]+v[1]+1);\\n\\t   //return the max length up till here including node\\n       return max(v[0],v[1])+1;\\n        \\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        \\n        ans =0;\\n        g.assign(n+1,{});\\n        for(int i=1;i<parent.size();i++){\\n           g[parent[i]].push_back(i);\\n           g[i].push_back(parent[i]);\\n        }\\n\\t\\t// run dfs and calculate max \\n        ans = max(ans, dfs(0,-1,s));\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965318,
                "title": "javascript-dfs",
                "content": "This is basically the same as https://leetcode.com/problems/binary-tree-maximum-path-sum/, with a couple differences:\\n1. It\\'s an N-Ary tree instead of Binary\\n2. Nodes can\\'t have the same value\\n\\nThere are only two types of \"paths\" we can make in a tree (N-Ary other otherwise):\\n1. a straight line some distance up the height of the tree (potentially from the root to a leaf node)\\n2. a loop from some left child, to the current node, to a right child\\n\\nNo idea if a visual is helpful but:\\n```\\n      a\\n   a    d\\n b  e     f\\nd\\n```\\nOur possible longest paths are\\n```d -> b -> a -> e``` (starting from the bottom left, looping around the lower \\'a\\' and ending\\n```f -> d -> a``` (from bottom right to the root)\\n\\n**Strategy**\\n- Let\\'s DFS from the root, post-order traversal\\n- At each node we\\'re doing two things:\\n  - Finding the longest \"loop\" from child to node to some other child, so we\\'ll find the two longest child paths where the children don\\'t match our current letter\\n  - Finding the longest path \"up the tree\", so taking the longest child path where the child doesn\\'t match our current letter, and returning that + 1. This feeds into finding the longest \"loop\" for our parent node.\\n- Our longest \"loop\" will always be at least as long as our longest path \"up the tree\", because even if we don\\'t find more than one child who doesn\\'t match our letter, our loop will still be 1 + the longest path.\\n\\n\\n```\\nvar longestPath = function(parent, s) {\\n  const adjList = parent.reduce((adjList, parent, node) => {\\n    if (parent < 0) return adjList;\\n    adjList[parent].push(node);\\n    return adjList;\\n  }, new Array(parent.length).fill(0).map(() => []));\\n  \\n  let longest = 1;\\n  \\n  const getLongest = (node) => {\\n    let maxChild1 = 0;\\n    let maxChild2 = 0;\\n    \\n    adjList[node].forEach((child) => {\\n      const childLength = getLongest(child);\\n    \\n\\t  // child letter matches our node, so we can\\'t use it\\n      if (s[child] === s[node]) return;\\n      \\n\\t  // compare and update the longest two child paths\\n      if (childLength > maxChild1) {\\n        maxChild2 = maxChild1;\\n        maxChild1 = childLength;\\n      } else if (childLength > maxChild2) {\\n        maxChild2 = childLength;\\n      }\\n    });\\n    \\n\\t// longest loop\\n    longest = Math.max(longest, maxChild1 + maxChild2 + 1);\\n    \\n\\t// return longest path up the tree\\n    return 1 + maxChild1;\\n  }\\n  \\n  getLongest(0);\\n  \\n  return longest;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n      a\\n   a    d\\n b  e     f\\nd\\n```\n```d -> b -> a -> e```\n```f -> d -> a```\n```\\nvar longestPath = function(parent, s) {\\n  const adjList = parent.reduce((adjList, parent, node) => {\\n    if (parent < 0) return adjList;\\n    adjList[parent].push(node);\\n    return adjList;\\n  }, new Array(parent.length).fill(0).map(() => []));\\n  \\n  let longest = 1;\\n  \\n  const getLongest = (node) => {\\n    let maxChild1 = 0;\\n    let maxChild2 = 0;\\n    \\n    adjList[node].forEach((child) => {\\n      const childLength = getLongest(child);\\n    \\n\\t  // child letter matches our node, so we can\\'t use it\\n      if (s[child] === s[node]) return;\\n      \\n\\t  // compare and update the longest two child paths\\n      if (childLength > maxChild1) {\\n        maxChild2 = maxChild1;\\n        maxChild1 = childLength;\\n      } else if (childLength > maxChild2) {\\n        maxChild2 = childLength;\\n      }\\n    });\\n    \\n\\t// longest loop\\n    longest = Math.max(longest, maxChild1 + maxChild2 + 1);\\n    \\n\\t// return longest path up the tree\\n    return 1 + maxChild1;\\n  }\\n  \\n  getLongest(0);\\n  \\n  return longest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957051,
                "title": "simple-c-recursive",
                "content": "Very simple actually. Code is probably simpler than explanation. \\n\\nFor every node check if the best answer that includes the node is better than the global answer. The local best answer includes the longest and the second longest child subsequence. The return integer for the recursive call is the max sequence length for the given node.\\n\\n\\n\\'\\'\\'\\n\\n    class Solution {\\n    public:\\n        struct Node {\\n            vector<Node*> children;\\n            char c;\\n        };\\n        \\n        int longestPath(vector<int>& parent, string s) {\\n            // just create the nodes\\n            nodes_.resize(parent.size());\\n            for(int i = 0; i < nodes_.size(); ++i) {\\n                nodes_[i] = new Node;\\n                nodes_[i]->c = s[i];\\n            }\\n            \\n            // add child pointers\\n            for(int i = 1; i < nodes_.size(); ++i) {\\n                nodes_[parent[i]]->children.push_back(nodes_[i]);\\n            }\\n            \\n            ans_ = 0;\\n            Calc(nodes_[0]);\\n            return ans_;\\n        }\\n        \\n        int Calc(Node* root) {        \\n            int longest_child = 0;\\n            int second_longest_child = 0;\\n            \\n            for(Node* child : root->children) {\\n                int child_len = Calc(child);\\n                if(child->c != root->c) {\\n                    if(child_len > longest_child) {\\n                        second_longest_child = longest_child;\\n                        longest_child = child_len;\\n                    } else if(child_len > second_longest_child) {\\n                        second_longest_child = child_len;\\n                    }\\n                }\\n            }\\n                    \\n            ans_ = std::max(ans_, 1 + longest_child + second_longest_child);\\n            return longest_child + 1;\\n        }\\n        \\n        int ans_;\\n        vector<Node*> nodes_;\\n    };\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        struct Node {\\n            vector<Node*> children;\\n            char c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1955335,
                "title": "python3-simple-solution-using-recursion",
                "content": "1. for each node, find the longest sequence and the second longest sequence(if exist) starting from it.\\n2. if there are at least two possible sequences starting from node `i`, they can form a sequence using node `i` as a connector.\\n3. return the longest sequence\\'s length of each node\\n```\\ndef longestPath(self, parent: List[int], s: str) -> int:\\n    tree = collections.defaultdict(list)\\n    for c, p in enumerate(parent):\\n        tree[p].append(c)\\n\\n    self.ret = 1\\n    @cache\\n    def calc(node):\\n        temp = []\\n        for c in tree[node]:\\n            sub = calc(c)\\n            if s[node] != s[c]:\\n                temp.append(sub)\\n        temp.sort()\\n        if len(temp) >= 2: \\n            self.ret = max(self.ret, 1 + temp[-1] + temp[-2])\\n        elif temp: \\n            self.ret = max(self.ret, 1 + temp[-1])\\n        return 1 if not temp else (1 + temp[-1])\\n    calc(0)\\n    return self.ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef longestPath(self, parent: List[int], s: str) -> int:\\n    tree = collections.defaultdict(list)\\n    for c, p in enumerate(parent):\\n        tree[p].append(c)\\n\\n    self.ret = 1\\n    @cache\\n    def calc(node):\\n        temp = []\\n        for c in tree[node]:\\n            sub = calc(c)\\n            if s[node] != s[c]:\\n                temp.append(sub)\\n        temp.sort()\\n        if len(temp) >= 2: \\n            self.ret = max(self.ret, 1 + temp[-1] + temp[-2])\\n        elif temp: \\n            self.ret = max(self.ret, 1 + temp[-1])\\n        return 1 if not temp else (1 + temp[-1])\\n    calc(0)\\n    return self.ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3047162,
                "title": "c-intuitive-and-crisp-approach-take-or-nottake-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the maximum length path for every children of each node and update ```res``` accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Step 1: -** Standing on a node, we will ask ```helper``` function to bring us the length of the maximum path for each children.\\n**Step 2: -** Store the atmost 2 maximum values obtained in min heap ```pq```.\\n**Step 3: -** Store the 2 elements of min heap ```pq``` in ```len1``` and ```len2```.\\n**Step 4: -** Update ```res``` as \\n1. By considering maximum of two longest paths obtained i.e. ```res = max (res, 1+max (len1, len2))```.\\n2. By considering sum of two longest paths obtained i.e. ```res = max (res, 1+len1+len2)```.\\n\\n**Step 5: -** Return ```0``` if ```prev == s[node]-\\'a\\'``` is ```true``` else return ```1 + max(len1, len2)```(*since responsibility of ```helper``` is to provide the longest path containing current node*).\\n# Complexity\\n- Time complexity: ```O(N*log 2)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(height of the tree + 2*n(adjacency list))```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper (vector<int>* adj, string &s, int vertex, int&res, int prev, int parent){\\n// Base case\\n        if ((adj[vertex].size () == 1 && adj[vertex][0] == parent) || adj[0].size () == 0){\\n            res = max (res, 1);\\n\\n            return (prev != -1 && prev == s[vertex]-\\'a\\') ? 0 : 1;\\n        }\\n\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        for (auto x: adj[vertex]){\\n            if (x != parent){\\n                int ans = helper (adj, s, x, res, s[vertex]-\\'a\\', vertex);\\n\\n                if (pq.size () < 2) pq.push (ans);\\n                else{\\n                    if (pq.top () < ans){\\n                        pq.pop ();\\n\\n                        pq.push (ans);\\n                    }\\n                }\\n            }\\n        }\\n\\n        auto len1 = pq.top ();\\n        pq.pop ();\\n\\n        int len2 = 0;\\n        if (pq.empty () == 0) {\\n            len2 = pq.top ();\\n            pq.pop ();\\n        }\\n\\n        res = max (res, 1+max (len1, len2));\\n        res = max (res, 1+len1+len2);\\n\\n        return (prev != -1 && prev == s[vertex]-\\'a\\') ? 0 : 1 + max (len1,len2);\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size ();\\n        vector<int> adj[n];\\n\\n        for (int i = 1; i < n; i++){\\n            adj[i].push_back (parent[i]);\\n            adj[parent[i]].push_back (i);\\n        }\\n\\n        int res = 0;\\n        helper (adj, s, 0, res, -1, -1);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```res```\n```helper```\n```pq```\n```pq```\n```len1```\n```len2```\n```res```\n```res = max (res, 1+max (len1, len2))```\n```res = max (res, 1+len1+len2)```\n```0```\n```prev == s[node]-\\'a\\'```\n```true```\n```1 + max(len1, len2)```\n```helper```\n```O(N*log 2)```\n```O(height of the tree + 2*n(adjacency list))```\n```\\nclass Solution {\\npublic:\\n    int helper (vector<int>* adj, string &s, int vertex, int&res, int prev, int parent){\\n// Base case\\n        if ((adj[vertex].size () == 1 && adj[vertex][0] == parent) || adj[0].size () == 0){\\n            res = max (res, 1);\\n\\n            return (prev != -1 && prev == s[vertex]-\\'a\\') ? 0 : 1;\\n        }\\n\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        for (auto x: adj[vertex]){\\n            if (x != parent){\\n                int ans = helper (adj, s, x, res, s[vertex]-\\'a\\', vertex);\\n\\n                if (pq.size () < 2) pq.push (ans);\\n                else{\\n                    if (pq.top () < ans){\\n                        pq.pop ();\\n\\n                        pq.push (ans);\\n                    }\\n                }\\n            }\\n        }\\n\\n        auto len1 = pq.top ();\\n        pq.pop ();\\n\\n        int len2 = 0;\\n        if (pq.empty () == 0) {\\n            len2 = pq.top ();\\n            pq.pop ();\\n        }\\n\\n        res = max (res, 1+max (len1, len2));\\n        res = max (res, 1+len1+len2);\\n\\n        return (prev != -1 && prev == s[vertex]-\\'a\\') ? 0 : 1 + max (len1,len2);\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size ();\\n        vector<int> adj[n];\\n\\n        for (int i = 1; i < n; i++){\\n            adj[i].push_back (parent[i]);\\n            adj[parent[i]].push_back (i);\\n        }\\n\\n        int res = 0;\\n        helper (adj, s, 0, res, -1, -1);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043683,
                "title": "simple-rust-recursive-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Create an adjacency list to easily travel the graph\\n\\n**DFS** starting at node `0`.\\n\\nFor the DFS, we want to keep track of the maximum length of a branch, if we take the node, and the maximum length of a path, regardelss of if we use the node or note.\\n\\nFor a given node it\\'s longest branch will be `1` if all it\\'s children have the same label, or `1 + longest_child_branch`.\\n\\nThe longest path will be the longest_path from all child nodes or `1 + longest_child_branch + second_longest_child_branch`.\\n\\n# Complexity\\n\\n- Time complexity:\\n$$O(n)$$ since we visit each node once.\\n\\n- Space complexity:\\n$$O(n)$$ for the `adjacency_list`\\n$$O(\\\\log_n)$$ for the **DFS** reecursive stack.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {\\n        let tree = Solution::get_adjacency_list(parent);\\n        let (_, longest_path) = Solution::dfs(&tree, &s.chars().collect(), 0);\\n        longest_path\\n    }\\n    fn dfs(tree: &Vec<Vec<usize>>, labels: &Vec<char>, node: usize) -> (i32, i32) {\\n        let mut longest_branch = 1;\\n        let mut longest_path = 1;\\n        \\n        for child in &tree[node] {\\n            let (longest_child_branch, longest_child_path) = Solution::dfs(tree, labels, *child);\\n            longest_path = longest_path.max(longest_child_path);\\n            if labels[*child] == labels[node] { continue }\\n            longest_path = longest_path.max(longest_branch + longest_child_branch);\\n            longest_branch = longest_branch.max(longest_child_branch + 1);\\n        }\\n\\n        (longest_branch, longest_path)\\n    }\\n    fn get_adjacency_list(parent: Vec<i32>) -> Vec<Vec<usize>> {\\n        let mut graph = vec![Vec::new(); parent.len()];\\n        for i in 1..parent.len() {\\n            graph[parent[i] as usize].push(i);\\n        }\\n        graph\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {\\n        let tree = Solution::get_adjacency_list(parent);\\n        let (_, longest_path) = Solution::dfs(&tree, &s.chars().collect(), 0);\\n        longest_path\\n    }\\n    fn dfs(tree: &Vec<Vec<usize>>, labels: &Vec<char>, node: usize) -> (i32, i32) {\\n        let mut longest_branch = 1;\\n        let mut longest_path = 1;\\n        \\n        for child in &tree[node] {\\n            let (longest_child_branch, longest_child_path) = Solution::dfs(tree, labels, *child);\\n            longest_path = longest_path.max(longest_child_path);\\n            if labels[*child] == labels[node] { continue }\\n            longest_path = longest_path.max(longest_branch + longest_child_branch);\\n            longest_branch = longest_branch.max(longest_child_branch + 1);\\n        }\\n\\n        (longest_branch, longest_path)\\n    }\\n    fn get_adjacency_list(parent: Vec<i32>) -> Vec<Vec<usize>> {\\n        let mut graph = vec![Vec::new(); parent.len()];\\n        for i in 1..parent.len() {\\n            graph[parent[i] as usize].push(i);\\n        }\\n        graph\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043600,
                "title": "easy-to-grok-stateless-c-solution-with-comments",
                "content": "# Intuition\\n\\nThis is a similar pattern to other tree questions such as the house robber one inside a tree.\\n\\n# Approach\\n\\n- First, turn the parent array representation into something a tree which allows for efficient traversals (like an adjacency matrix)\\n- Do a DFS and for each node, compute and return two values: max length for the whole subtree of that node and max length for a path starting from that node.\\n- Then, for that node, check child nodes which don\\'t match character-wise take the 2 highest values, sum them and add one - that is the max path which contains that node as an intermediary node.\\n- Read the comments\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$ - it\\'s basically traversing an n-ary tree\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestPath(int[] parent, string s) {\\n        var n = parent.Length;\\n        // Build an adjacency \\'matrix\\'\\n        var adj = Enumerable.Range(0, n)\\n            .ToDictionary(x => x, x => new HashSet<int>());\\n        for (var i = 0; i < n; i++) {\\n            if (parent[i] != -1) {\\n                adj[parent[i]].Add(i);\\n            }\\n        }\\n\\n        return LongestPath(0, adj, s).Item1;\\n    }\\n\\n    // Returning a tuple, to make this stateless\\n    private (int maxTreePath, int maxBranchPath, char mapping) LongestPath(\\n        int i, \\n        Dictionary<int, HashSet<int>> adj,\\n        string s\\n    ) {\\n        int i, \\n        Dictionary<int, HashSet<int>> adj,\\n        string s\\n    ) {\\n        // This is a leaf node. All paths are length 1\\n        if (!adj[i].Any()) {\\n            return (1, 1, s[i]);\\n        }\\n\\n        var next = adj[i]\\n            .Select(x => LongestPath(x, adj, s))\\n            .ToArray();\\n        var different = next\\n            .Where(x => x.mapping != s[i])\\n            .OrderByDescending(x => x.maxBranchPath)\\n            .Select(x => x.maxBranchPath)\\n            .Take(2)\\n            .ToArray();\\n        \\n        return (\\n            // The longest path for this subtree is the max of (all \\n            // longest paths from child subtrees) and (the two longest\\n            // paths starting at the children whith different \\n            // mappings + 1 to account for the current node\\n            Math.Max(\\n                next.Max(x => x.maxTreePath),\\n                1 + different.Sum()),\\n            // 1 + max path starting at children with different \\n            // mappings\\n            (different.Any() ? different.Max() : 0) + 1,\\n            s[i]\\n        );\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestPath(int[] parent, string s) {\\n        var n = parent.Length;\\n        // Build an adjacency \\'matrix\\'\\n        var adj = Enumerable.Range(0, n)\\n            .ToDictionary(x => x, x => new HashSet<int>());\\n        for (var i = 0; i < n; i++) {\\n            if (parent[i] != -1) {\\n                adj[parent[i]].Add(i);\\n            }\\n        }\\n\\n        return LongestPath(0, adj, s).Item1;\\n    }\\n\\n    // Returning a tuple, to make this stateless\\n    private (int maxTreePath, int maxBranchPath, char mapping) LongestPath(\\n        int i, \\n        Dictionary<int, HashSet<int>> adj,\\n        string s\\n    ) {\\n        int i, \\n        Dictionary<int, HashSet<int>> adj,\\n        string s\\n    ) {\\n        // This is a leaf node. All paths are length 1\\n        if (!adj[i].Any()) {\\n            return (1, 1, s[i]);\\n        }\\n\\n        var next = adj[i]\\n            .Select(x => LongestPath(x, adj, s))\\n            .ToArray();\\n        var different = next\\n            .Where(x => x.mapping != s[i])\\n            .OrderByDescending(x => x.maxBranchPath)\\n            .Select(x => x.maxBranchPath)\\n            .Take(2)\\n            .ToArray();\\n        \\n        return (\\n            // The longest path for this subtree is the max of (all \\n            // longest paths from child subtrees) and (the two longest\\n            // paths starting at the children whith different \\n            // mappings + 1 to account for the current node\\n            Math.Max(\\n                next.Max(x => x.maxTreePath),\\n                1 + different.Sum()),\\n            // 1 + max path starting at children with different \\n            // mappings\\n            (different.Any() ? different.Max() : 0) + 1,\\n            s[i]\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043024,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int node,int parent,vector<int> adj[],string &s,int& maxi){\\n        priority_queue<int> pq;\\n        pq.push(0);//just to avoid underflow\\n        pq.push(0);//just to avoid underflow\\n        for(auto &i:adj[node]){\\n            if(i!=parent){\\n                pq.push(solve(i,node,adj,s,maxi));//push all the length of the longest valid paths\\n            }\\n        }\\n        int max1=pq.top();//choose the maximum length out of all maximum path\\n        pq.pop();\\n        int max2=pq.top();//once again choose the maximum length out of all longest valid paths\\n        pq.pop();\\n        maxi=max(maxi,max1+max2+1);/*for curved path at current nodes choose the top 2 length and \\n\\t\\tadd them together and store the maximum length in variable maxi*/\\n        return ((parent==-1)||(s[parent]!=s[node]))? max(max1,max2)+1:0;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<int> adj[n];//prepare a adjacency list\\n        for(int i=1;i<n;i++){\\n            int u=parent[i],v=i;\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int maxi=0;\\n        int res=solve(0,-1,adj,s,maxi);\\n        return max(res,maxi);//return the answer\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/463e2481-1ef9-4aba-9b99-399204aa6600_1673573312.3330724.png)\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int node,int parent,vector<int> adj[],string &s,int& maxi){\\n        priority_queue<int> pq;\\n        pq.push(0);//just to avoid underflow\\n        pq.push(0);//just to avoid underflow\\n        for(auto &i:adj[node]){\\n            if(i!=parent){\\n                pq.push(solve(i,node,adj,s,maxi));//push all the length of the longest valid paths\\n            }\\n        }\\n        int max1=pq.top();//choose the maximum length out of all maximum path\\n        pq.pop();\\n        int max2=pq.top();//once again choose the maximum length out of all longest valid paths\\n        pq.pop();\\n        maxi=max(maxi,max1+max2+1);/*for curved path at current nodes choose the top 2 length and \\n\\t\\tadd them together and store the maximum length in variable maxi*/\\n        return ((parent==-1)||(s[parent]!=s[node]))? max(max1,max2)+1:0;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<int> adj[n];//prepare a adjacency list\\n        for(int i=1;i<n;i++){\\n            int u=parent[i],v=i;\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int maxi=0;\\n        int res=solve(0,-1,adj,s,maxi);\\n        return max(res,maxi);//return the answer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956872,
                "title": "dfs-and-multiset",
                "content": "```\\nvector<vector<pair<int,char>>>graph;\\n    int ans;\\n    \\n    int dfs(int node , int par,char c){\\n        multiset<int>v;\\n        for(auto child :graph[node]){\\n            if(child.first==par)continue;\\n            \\n            if(c==child.second){\\n                dfs(child.first,node, child.second);\\n                continue;\\n            }\\n            int cur = dfs(child.first,node, child.second);\\n            v.insert(cur+1);\\n            if(v.size()>2)v.erase(v.begin());\\n        }\\n        int su=0,maxi=0;\\n        for(auto it :v){\\n            su+=it;\\n            maxi=max(maxi,it);\\n        }\\n        ans=max(ans,su);\\n        return maxi;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        dis.assign(n+10,0);\\n        graph.resize(n+1,{});\\n        for(int i=1;i<parent.size();i++){\\n            graph[parent[i]].push_back({i,s[i]});\\n            graph[i].push_back({parent[i],s[i]});\\n        }\\n        dfs(0,-1,s[0]);\\n        return ans+1;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nvector<vector<pair<int,char>>>graph;\\n    int ans;\\n    \\n    int dfs(int node , int par,char c){\\n        multiset<int>v;\\n        for(auto child :graph[node]){\\n            if(child.first==par)continue;\\n            \\n            if(c==child.second){\\n                dfs(child.first,node, child.second);\\n                continue;\\n            }\\n            int cur = dfs(child.first,node, child.second);\\n            v.insert(cur+1);\\n            if(v.size()>2)v.erase(v.begin());\\n        }\\n        int su=0,maxi=0;\\n        for(auto it :v){\\n            su+=it;\\n            maxi=max(maxi,it);\\n        }\\n        ans=max(ans,su);\\n        return maxi;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        dis.assign(n+10,0);\\n        graph.resize(n+1,{});\\n        for(int i=1;i<parent.size();i++){\\n            graph[parent[i]].push_back({i,s[i]});\\n            graph[i].push_back({parent[i],s[i]});\\n        }\\n        dfs(0,-1,s[0]);\\n        return ans+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1955371,
                "title": "c-find-recursively-longest-path-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxval;\\n    vector<vector<int>> vec;\\n    int cost(string& s,char x,int node)\\n    {\\n        int m1 = INT_MIN;\\n        int m2=INT_MIN;\\n        // looking for all adjacent paths and finding two longest paths\\n        for(auto adj:vec[node])\\n        {\\n            int temp=cost(s,s[node],adj);\\n            if(temp>m1)\\n            {\\n                m2=m1;\\n                m1=temp;\\n            }\\n            else if(temp>m2)\\n                m2= temp;\\n        }\\n\\n        // No node exist after this node\\n        if(m1==INT_MIN)\\n            return 1-(x==s[node]);\\n        // only path is there\\n        else if(m2==INT_MIN)\\n            maxval= max(maxval,m1+1);\\n        // both paths + 1  ->                                 //     a           1(left) + 1(right) +1\\n        else                                                 //    /   |\\n            maxval=max(maxval,m2+m1+1);                     //    b     c\\n        if(x == s[node])                                 // if both same 0\\n            return 0;\\n        return m1+1;                                   // return max path+1\\n    }\\n    \\n    int longestPath(vector<int>& par, string s) {\\n        int n=s.length();\\n\\t\\tvec.resize(n);\\n        maxval =INT_MIN;\\n        for(int node=1;node<n;node++)\\n            vec[par[node]].push_back(node);\\n        maxval  = max(maxval,cost(s,\\']\\',0));\\n        return maxval;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxval;\\n    vector<vector<int>> vec;\\n    int cost(string& s,char x,int node)\\n    {\\n        int m1 = INT_MIN;\\n        int m2=INT_MIN;\\n        // looking for all adjacent paths and finding two longest paths\\n        for(auto adj:vec[node])\\n        {\\n            int temp=cost(s,s[node],adj);\\n            if(temp>m1)\\n            {\\n                m2=m1;\\n                m1=temp;\\n            }\\n            else if(temp>m2)\\n                m2= temp;\\n        }\\n\\n        // No node exist after this node\\n        if(m1==INT_MIN)\\n            return 1-(x==s[node]);\\n        // only path is there\\n        else if(m2==INT_MIN)\\n            maxval= max(maxval,m1+1);\\n        // both paths + 1  ->                                 //     a           1(left) + 1(right) +1\\n        else                                                 //    /   |\\n            maxval=max(maxval,m2+m1+1);                     //    b     c\\n        if(x == s[node])                                 // if both same 0\\n            return 0;\\n        return m1+1;                                   // return max path+1\\n    }\\n    \\n    int longestPath(vector<int>& par, string s) {\\n        int n=s.length();\\n\\t\\tvec.resize(n);\\n        maxval =INT_MIN;\\n        for(int node=1;node<n;node++)\\n            vec[par[node]].push_back(node);\\n        maxval  = max(maxval,cost(s,\\']\\',0));\\n        return maxval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560767,
                "title": "c-dfs-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int s,vector<vector<int>> &g,string &s1,int &ans,char c){\\n    int mx1 = 0, mx2 = 0,x;\\n    for(auto &i: g[s]){\\n        x = solve(i,g,s1,ans,s1[s]);\\n        if(x>mx1){\\n            mx2 = mx1;\\n            mx1 = x;\\n        }else if(x>mx2){\\n            mx2 = x;\\n        }\\n    }\\n    ans = max(ans,mx1+mx2+1);\\n    if(c==s1[s])return 0;\\n    return mx1+1;\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.length();\\n        vector<vector<int>> v(n);\\n        for(int i = 1; i < n; i++){\\n            v[parent[i]].push_back(i);\\n        }\\n        // for(int i = 0; i < n; i++){\\n        //     cout<<i<<\" -> \";\\n        //     for(auto &j: v[i])cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        int ans = 0;\\n        solve(0,v,s,ans,\\'#\\');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int s,vector<vector<int>> &g,string &s1,int &ans,char c){\\n    int mx1 = 0, mx2 = 0,x;\\n    for(auto &i: g[s]){\\n        x = solve(i,g,s1,ans,s1[s]);\\n        if(x>mx1){\\n            mx2 = mx1;\\n            mx1 = x;\\n        }else if(x>mx2){\\n            mx2 = x;\\n        }\\n    }\\n    ans = max(ans,mx1+mx2+1);\\n    if(c==s1[s])return 0;\\n    return mx1+1;\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.length();\\n        vector<vector<int>> v(n);\\n        for(int i = 1; i < n; i++){\\n            v[parent[i]].push_back(i);\\n        }\\n        // for(int i = 0; i < n; i++){\\n        //     cout<<i<<\" -> \";\\n        //     for(auto &j: v[i])cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        int ans = 0;\\n        solve(0,v,s,ans,\\'#\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3045037,
                "title": "ruby-dfs-without-time-limit-exceeded-714-ms-274-mb-beats-100",
                "content": "This solution use approach from Official Solution with little trick for Ruby. We should converte `s` string to Array:\\n\\nThis solution use approach from the Official Solution with a little trick for Ruby. We should convert the \"s\" string to an array:\\n\\n```\\ns = s.split(\"\")\\n```\\n\\nThis unexpected trick helped me submit a solution without getting \"Time Limit Exceeded.\"\\n\\n# Benchmarks\\n\\nSource code for benchmarks:\\n```\\nchars_array = Array.new(10_000) { (97 + rand(25)).chr }\\nnumber_array = Array.new(10_000) { rand(25) }\\nchars_string = chars_array.join(\\'\\')\\n\\nrequire \\'benchmark\\'\\n\\nn = 10_000\\nBenchmark.bmbm(10) do |x|\\n  x.report(\"array\") { n.times { |i| chars_array[i] } }\\n  x.report(\"string\")  { n.times { |i| chars_string[i] } }\\nend\\n```\\nResult:\\n```\\nRehearsal ----------------------------------------------\\narray        0.000604   0.000003   0.000607 (  0.000602)\\nstring       0.001681   0.000015   0.001696 (  0.001698)\\n------------------------------------- total: 0.002303sec\\n\\n                 user     system      total        real\\narray        0.000589   0.000004   0.000593 (  0.000588)\\nstring       0.001581   0.000145   0.001726 (  0.001823\\n```\\n\\n\\n# Code\\n```\\n# @param {Integer[]} parent\\n# @param {String} s\\n# @return {Integer}\\ndef longest_path(parent, s)\\n    results = [1]\\n    n = parent.size\\n    childrens = Array.new(n) { Array.new() }\\n    (1...n).each_with_index do |index|\\n      childrens[parent[index]] << index\\n    end\\n    s = s.split(\"\")\\n\\n    dfs(0, childrens, s, results)\\n\\n    results[0]\\nend\\n\\ndef dfs(node, childrens, s, results)\\n  first_longest_path = 0\\n  second_longest_path = 0\\n\\n  childrens[node].each do |child|\\n\\n    long_path_from_child = dfs(child, childrens, s, results)\\n\\n    next if s[child] == s[node]\\n\\n    if long_path_from_child > first_longest_path\\n      second_longest_path = first_longest_path\\n      first_longest_path = long_path_from_child\\n    elsif long_path_from_child > second_longest_path\\n      second_longest_path = long_path_from_child\\n    end\\n  end\\n\\n  results[0] = [results[0], first_longest_path + second_longest_path + 1].max\\n  return first_longest_path + 1;\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ns = s.split(\"\")\\n```\n```\\nchars_array = Array.new(10_000) { (97 + rand(25)).chr }\\nnumber_array = Array.new(10_000) { rand(25) }\\nchars_string = chars_array.join(\\'\\')\\n\\nrequire \\'benchmark\\'\\n\\nn = 10_000\\nBenchmark.bmbm(10) do |x|\\n  x.report(\"array\") { n.times { |i| chars_array[i] } }\\n  x.report(\"string\")  { n.times { |i| chars_string[i] } }\\nend\\n```\n```\\nRehearsal ----------------------------------------------\\narray        0.000604   0.000003   0.000607 (  0.000602)\\nstring       0.001681   0.000015   0.001696 (  0.001698)\\n------------------------------------- total: 0.002303sec\\n\\n                 user     system      total        real\\narray        0.000589   0.000004   0.000593 (  0.000588)\\nstring       0.001581   0.000145   0.001726 (  0.001823\\n```\n```\\n# @param {Integer[]} parent\\n# @param {String} s\\n# @return {Integer}\\ndef longest_path(parent, s)\\n    results = [1]\\n    n = parent.size\\n    childrens = Array.new(n) { Array.new() }\\n    (1...n).each_with_index do |index|\\n      childrens[parent[index]] << index\\n    end\\n    s = s.split(\"\")\\n\\n    dfs(0, childrens, s, results)\\n\\n    results[0]\\nend\\n\\ndef dfs(node, childrens, s, results)\\n  first_longest_path = 0\\n  second_longest_path = 0\\n\\n  childrens[node].each do |child|\\n\\n    long_path_from_child = dfs(child, childrens, s, results)\\n\\n    next if s[child] == s[node]\\n\\n    if long_path_from_child > first_longest_path\\n      second_longest_path = first_longest_path\\n      first_longest_path = long_path_from_child\\n    elsif long_path_from_child > second_longest_path\\n      second_longest_path = long_path_from_child\\n    end\\n  end\\n\\n  results[0] = [results[0], first_longest_path + second_longest_path + 1].max\\n  return first_longest_path + 1;\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3044901,
                "title": "c-depth-first-search-concise-explanation",
                "content": "# Intuition\\n- We need two of largest lengths from subtrees to combine them with current node to get the answer\\n\\n- But we also need to maintain desired answer so that we cannot lose maximum answer value in case of two adjacent nodes have same character.  \\n# Approach\\n- Use classic depth first search to get two maximum lengths (l1 , l2) from all subtrees and return value will be maximum length in the subtree possible from current node (l1+1)\\n- We will maintain our answer as a parameter to not lose it \\n-  ans=l1+l2+1(including current root node)  \\n# Complexity\\n- Time complexity : $$O(N)$$\\n- Space complexity : $$O(N)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int root,vector<vector<int>>& graph,string& s,int& ans)\\n    {\\n        int l1=0 , l2=0;\\n        for(int node:graph[root])\\n        {\\n            int l3=solve(node,graph,s,ans);\\n            if(s[node]!=s[root])\\n            {\\n                if(l3>l1) l2=l1 , l1=l3;\\n                else if(l3>l2) l2=l3;\\n            }\\n        }\\n        ans=max(ans,l1+l2+1);\\n        return l1+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) \\n    {\\n        int n=s.length();\\n\\n        vector<vector<int>>graph(n,vector<int>());\\n\\n        for(int i=1;i<n;i++) graph[parent[i]].push_back(i);\\n        \\n        int ans=0 , ret=solve(0,graph,s,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int root,vector<vector<int>>& graph,string& s,int& ans)\\n    {\\n        int l1=0 , l2=0;\\n        for(int node:graph[root])\\n        {\\n            int l3=solve(node,graph,s,ans);\\n            if(s[node]!=s[root])\\n            {\\n                if(l3>l1) l2=l1 , l1=l3;\\n                else if(l3>l2) l2=l3;\\n            }\\n        }\\n        ans=max(ans,l1+l2+1);\\n        return l1+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) \\n    {\\n        int n=s.length();\\n\\n        vector<vector<int>>graph(n,vector<int>());\\n\\n        for(int i=1;i<n;i++) graph[parent[i]].push_back(i);\\n        \\n        int ans=0 , ret=solve(0,graph,s,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044614,
                "title": "c-easy-solution-dfs-approach-heavily-commented",
                "content": "# **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFDFS Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<vector<int>>&g,string&s,vector<int>&vis,int& ans){\\n\\t    //Making the visited node true or marking it visited\\n        vis[val]=1;\\n\\t\\t//We are creating a temp vector which would contain the length of \\n\\t\\t//Subtree with different char at subTree Node\\n\\t\\tvector<int>temp;\\n\\t\\t\\n\\t\\t//Now we start Traversing the neighboring nodes of the val node.\\n        for(int child:g[node]){\\n            if(!vis[child]){\\n                int val=dfs(child,g,s,vis,ans);\\n\\t\\t\\t\\t//if the char at child not equal to char at node then we will store the length of subtree\\n                if(s[child]!=s[node]){\\n                    temp.push_back(val);\\n                }\\n            }\\n        }\\n        int maximum=0,val=0;\\n        sort(temp.begin(),temp.end(),greater<int>());\\n        for(int i=0;i<2&&i<temp.size();i++){\\n            maximum+=temp[i];\\n            val=max(val,temp[i]);\\n        }\\n\\t\\t\\n        ans=max(ans,maximum+1);\\n\\t\\t//Returning the maximum length of single branch\\n        return val+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>g(n);\\n\\t\\t//First step is to convert the edges into the graph\\n\\t\\t//so as given undirected graph so we have made 2d vector for graph\\n        for(int i=1;i<n;i++){\\n            g[i].push_back(parent[i]);\\n            g[parent[i]].push_back(i);\\n        }\\n\\t\\t//Second step is to make the visited vector \\n\\t\\t//inorder to keep the count of the node that has been visited.\\n\\t\\t\\n        vector<int>vis(n);\\n        int res=0;\\n        int ans=dfs(0,g,s,vis,res);\\n        \\n        return max(res,ans);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<vector<int>>&g,string&s,vector<int>&vis,int& ans){\\n\\t    //Making the visited node true or marking it visited\\n        vis[val]=1;\\n\\t\\t//We are creating a temp vector which would contain the length of \\n\\t\\t//Subtree with different char at subTree Node\\n\\t\\tvector<int>temp;\\n\\t\\t\\n\\t\\t//Now we start Traversing the neighboring nodes of the val node.\\n        for(int child:g[node]){\\n            if(!vis[child]){\\n                int val=dfs(child,g,s,vis,ans);\\n\\t\\t\\t\\t//if the char at child not equal to char at node then we will store the length of subtree\\n                if(s[child]!=s[node]){\\n                    temp.push_back(val);\\n                }\\n            }\\n        }\\n        int maximum=0,val=0;\\n        sort(temp.begin(),temp.end(),greater<int>());\\n        for(int i=0;i<2&&i<temp.size();i++){\\n            maximum+=temp[i];\\n            val=max(val,temp[i]);\\n        }\\n\\t\\t\\n        ans=max(ans,maximum+1);\\n\\t\\t//Returning the maximum length of single branch\\n        return val+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>g(n);\\n\\t\\t//First step is to convert the edges into the graph\\n\\t\\t//so as given undirected graph so we have made 2d vector for graph\\n        for(int i=1;i<n;i++){\\n            g[i].push_back(parent[i]);\\n            g[parent[i]].push_back(i);\\n        }\\n\\t\\t//Second step is to make the visited vector \\n\\t\\t//inorder to keep the count of the node that has been visited.\\n\\t\\t\\n        vector<int>vis(n);\\n        int res=0;\\n        int ans=dfs(0,g,s,vis,res);\\n        \\n        return max(res,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044325,
                "title": "diameter-of-separate-components-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe don\\'t want repeated adjacent characters in the path, so it makes sense to avoid making a edge when the parent and child have same character. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we are not making a edge when parent and have child have same character, we will have some number of components. Now we just have to find the maximum diameter of each component and then print the maximum of them.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2*(V+E))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(V^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int v, int len, vector<vector<int>> &adj,\\n         vector<int> &vis, int &maxlen, int &node) {\\n        len++;\\n        vis[v] = 1;\\n        if (maxlen < len) {\\n            maxlen = len;\\n            node = v;\\n        }\\n        for (auto u : adj[v]) {\\n            if (!vis[u]) {\\n                dfs(u, len, adj, vis, maxlen, node);\\n            }\\n        }\\n    }\\n\\n    void dfs(int v, vector<vector<int>> &adj, vector<int> &par,\\n            int len, int &maxlen) {\\n        len++;\\n        maxlen = max(maxlen, len);\\n        for (auto u : adj[v]) {\\n            if (u != par[v]) {\\n                par[u] = v;\\n                dfs(u, adj, par, len, maxlen);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> adj(n + 1);\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] == s[parent[i]]) {\\n                continue;\\n            }\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<int> par(n);\\n        for (int i = 0; i < n; i++) {\\n            if (vis[i] == 0) {\\n                int len = 0, maxlen = 0, node = -1;\\n                dfs(i, len, adj, vis, maxlen, node);\\n                len = 0, maxlen = 0;\\n                par[node] = -1;\\n                dfs(node, adj, par, len, maxlen);\\n                ans = max(ans, maxlen);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int v, int len, vector<vector<int>> &adj,\\n         vector<int> &vis, int &maxlen, int &node) {\\n        len++;\\n        vis[v] = 1;\\n        if (maxlen < len) {\\n            maxlen = len;\\n            node = v;\\n        }\\n        for (auto u : adj[v]) {\\n            if (!vis[u]) {\\n                dfs(u, len, adj, vis, maxlen, node);\\n            }\\n        }\\n    }\\n\\n    void dfs(int v, vector<vector<int>> &adj, vector<int> &par,\\n            int len, int &maxlen) {\\n        len++;\\n        maxlen = max(maxlen, len);\\n        for (auto u : adj[v]) {\\n            if (u != par[v]) {\\n                par[u] = v;\\n                dfs(u, adj, par, len, maxlen);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> adj(n + 1);\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] == s[parent[i]]) {\\n                continue;\\n            }\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<int> par(n);\\n        for (int i = 0; i < n; i++) {\\n            if (vis[i] == 0) {\\n                int len = 0, maxlen = 0, node = -1;\\n                dfs(i, len, adj, vis, maxlen, node);\\n                len = 0, maxlen = 0;\\n                par[node] = -1;\\n                dfs(node, adj, par, len, maxlen);\\n                ans = max(ans, maxlen);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043668,
                "title": "python-3-dfs-post-order-beats-95-locally-explained",
                "content": "**Intuition and Logic-**\\nThe intuition behind this problem is that, to find the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them, we have to look at the longest path from each node as a starting point and check if adding the parent node to it won\\'t violate the condition.\\n\\nThe post-order DFS traversal, allows us to first calculate the longest path ending at each child node before calculating the longest path ending at its parent node. This way, when we reach a parent node, we already know the longest path ending at all its children, so we can use that information to calculate the longest path ending at the parent node.\\n\\n**Code for the same-**\\n```\\nclass Solution:\\n    def longestPath(self, par: List[int], label: str) -> int:\\n        n = len(par)\\n        adj = [[] for i in range(n)]\\n        \\n        for i in range(1, n):\\n            adj[par[i]].append(i)\\n            \\n        vis = [0]*n \\n        vis[0] = 1 \\n        \\n        queue = [0]\\n        q = 1 \\n        \\n        ans = 1 \\n        \\n        arr = [1]*n \\n        \\n        while q > 0:\\n            s = queue[-1]\\n            \\n            leaf = True\\n            flag = True\\n            \\n            for z in adj[s]:\\n                leaf = False\\n                if not vis[z]:\\n                    flag = False\\n                    vis[z] = 1 \\n                    queue.append(z)\\n                    q += 1\\n                    \\n            if leaf:\\n                queue.pop()\\n                q -= 1\\n                continue \\n                \\n            if flag:\\n                curr = []\\n                c = 0\\n                \\n                for z in adj[s]:\\n                    if label[z] != label[s]:\\n                        c += 1 \\n                        curr.append(arr[z])\\n                        \\n                if c > 1:\\n                    curr.sort()\\n                    a, b = curr[-1], curr[-2]\\n                    \\n                    ans = max(ans, a+b+1)\\n\\n                    mx = a \\n                elif c == 1:\\n                    mx = curr[0] \\n                else:\\n                    mx = 0 \\n                    \\n                arr[s] = mx+1 \\n                \\n                ans = max(ans, arr[s])\\n                \\n                queue.pop()\\n                q -= 1\\n                \\n        return ans\\n                \\n            \\n                    \\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "**Intuition and Logic-**\\nThe intuition behind this problem is that, to find the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them, we have to look at the longest path from each node as a starting point and check if adding the parent node to it won\\'t violate the condition.\\n\\nThe post-order DFS traversal, allows us to first calculate the longest path ending at each child node before calculating the longest path ending at its parent node. This way, when we reach a parent node, we already know the longest path ending at all its children, so we can use that information to calculate the longest path ending at the parent node.\\n\\n**Code for the same-**\\n```\\nclass Solution:\\n    def longestPath(self, par: List[int], label: str) -> int:\\n        n = len(par)\\n        adj = [[] for i in range(n)]\\n        \\n        for i in range(1, n):\\n            adj[par[i]].append(i)\\n            \\n        vis = [0]*n \\n        vis[0] = 1 \\n        \\n        queue = [0]\\n        q = 1 \\n        \\n        ans = 1 \\n        \\n        arr = [1]*n \\n        \\n        while q > 0:\\n            s = queue[-1]\\n            \\n            leaf = True\\n            flag = True\\n            \\n            for z in adj[s]:\\n                leaf = False\\n                if not vis[z]:\\n                    flag = False\\n                    vis[z] = 1 \\n                    queue.append(z)\\n                    q += 1\\n                    \\n            if leaf:\\n                queue.pop()\\n                q -= 1\\n                continue \\n                \\n            if flag:\\n                curr = []\\n                c = 0\\n                \\n                for z in adj[s]:\\n                    if label[z] != label[s]:\\n                        c += 1 \\n                        curr.append(arr[z])\\n                        \\n                if c > 1:\\n                    curr.sort()\\n                    a, b = curr[-1], curr[-2]\\n                    \\n                    ans = max(ans, a+b+1)\\n\\n                    mx = a \\n                elif c == 1:\\n                    mx = curr[0] \\n                else:\\n                    mx = 0 \\n                    \\n                arr[s] = mx+1 \\n                \\n                ans = max(ans, arr[s])\\n                \\n                queue.pop()\\n                q -= 1\\n                \\n        return ans\\n                \\n            \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 3043033,
                "title": "python3-dfs-solution-for-reference",
                "content": "At every node, there are three strings to consider.\\n- Longest child string whose last char == parent_char\\n- Longest child string  whose last char != parent_char\\n- Two longest child strings whose last char != parent_char - joined by parent char in the middle.\\n\\nThe code below uses a dfs traversal in the graph, that will - at everynode checks and keep track of the longest string.\\n\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        g = defaultdict(list)\\n        \\n        for i in range(1, len(parent)):\\n            g[parent[i]].append(i)\\n        \\n        ans = 0 \\n        \\n        def dfs(node, parent):\\n            nonlocal ans\\n            \\n\\t\\t\\t## required for keeping track of two longest child paths that dont match \\n\\t\\t\\t## the label in case there is a case (iii) from the list above.\\n\\t\\t\\t\\n            fir,sec = 0,0  \\n            \\n            for nei in g[node]:\\n                st = dfs(nei, node)\\n                if s[nei] != s[node]:\\n                    if st > fir: \\n                        sec = fir\\n                        fir = st\\n                    elif st == fir or st > sec: \\n                        sec = st\\n                            \\n            ans = max(ans, fir+sec+1)\\n            return fir+1\\n        \\n        dfs(0, -1)\\n        \\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "At every node, there are three strings to consider.\\n- Longest child string whose last char == parent_char\\n- Longest child string  whose last char != parent_char\\n- Two longest child strings whose last char != parent_char - joined by parent char in the middle.\\n\\nThe code below uses a dfs traversal in the graph, that will - at everynode checks and keep track of the longest string.\\n\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        g = defaultdict(list)\\n        \\n        for i in range(1, len(parent)):\\n            g[parent[i]].append(i)\\n        \\n        ans = 0 \\n        \\n        def dfs(node, parent):\\n            nonlocal ans\\n            \\n\\t\\t\\t## required for keeping track of two longest child paths that dont match \\n\\t\\t\\t## the label in case there is a case (iii) from the list above.\\n\\t\\t\\t\\n            fir,sec = 0,0  \\n            \\n            for nei in g[node]:\\n                st = dfs(nei, node)\\n                if s[nei] != s[node]:\\n                    if st > fir: \\n                        sec = fir\\n                        fir = st\\n                    elif st == fir or st > sec: \\n                        sec = st\\n                            \\n            ans = max(ans, fir+sec+1)\\n            return fir+1\\n        \\n        dfs(0, -1)\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3042914,
                "title": "daily-leetcoding-challenge-january-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2974004,
                "title": "c-bfs-indegrees-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse topological sort for to optain leaf node. Iterate from leaf node to root and accordingly store the and maxpath of node\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:100% TC\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 90% SC\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<int> indegree(n,0);\\n        for(int i=0;i<n;i++){\\n            if(parent[i]!=-1){\\n                // store number of child node in a node\\n                indegree[parent[i]]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            // push the leaf node in a queue\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        // maxpath: stores the max path of from that node \\n        vector<int> maxpath(n,1);\\n        int ans=1;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            \\n            int v=parent[u];\\n            if(v==-1){\\n                continue;\\n            }\\n            indegree[v]--;\\n            if(s[u]!=s[v]){\\n                // store the max path in ans variable\\n                ans=max(ans,maxpath[v]+maxpath[u]);\\n                maxpath[v]=max(maxpath[v],1+maxpath[u]);\\n            }\\n            if(indegree[v]==0){\\n                q.push(v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<int> indegree(n,0);\\n        for(int i=0;i<n;i++){\\n            if(parent[i]!=-1){\\n                // store number of child node in a node\\n                indegree[parent[i]]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            // push the leaf node in a queue\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        // maxpath: stores the max path of from that node \\n        vector<int> maxpath(n,1);\\n        int ans=1;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            \\n            int v=parent[u];\\n            if(v==-1){\\n                continue;\\n            }\\n            indegree[v]--;\\n            if(s[u]!=s[v]){\\n                // store the max path in ans variable\\n                ans=max(ans,maxpath[v]+maxpath[u]);\\n                maxpath[v]=max(maxpath[v],1+maxpath[u]);\\n            }\\n            if(indegree[v]==0){\\n                q.push(v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735152,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int longestPath(vector<int>& parent, string s) {\\n        int n = s.size(), res = 0;\\n        vector<vector<int>> children(n, vector<int>());\\n        for (int i = 1; i < n; ++i)\\n            children[parent[i]].push_back(i);\\n        dfs(children, s, res, 0);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& children, string& s, int& res, int i) {\\n        int big1 = 0, big2 = 0;\\n        for (int& j : children[i]) {\\n            int cur = dfs(children, s, res, j);\\n            if (s[i] == s[j]) continue;\\n            if (cur > big2) big2 = cur;\\n            if (big2 > big1) swap(big1, big2);\\n        }\\n        res = max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n    };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int longestPath(vector<int>& parent, string s) {\\n        int n = s.size(), res = 0;\\n        vector<vector<int>> children(n, vector<int>());\\n        for (int i = 1; i < n; ++i)\\n            children[parent[i]].push_back(i);\\n        dfs(children, s, res, 0);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& children, string& s, int& res, int i) {\\n        int big1 = 0, big2 = 0;\\n        for (int& j : children[i]) {\\n            int cur = dfs(children, s, res, j);\\n            if (s[i] == s[j]) continue;\\n            if (cur > big2) big2 = cur;\\n            if (big2 > big1) swap(big1, big2);\\n        }\\n        res = max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014640,
                "title": "python-longest-path-in-tree-diameter-of-a-tree",
                "content": "This problem is the same as finding the diameter of a tree. However, we have many disconnected tree because we can not travel using the same letter in adjacent nodes. So, we will run the following algorithm for each tree in our graph:\\n* Using two BFSs, we can find the longest path.\\n* The concept is based on the fact that if we start BFS from any node x and find a node that is the furthest away from x, it must be the endpoint of the longest path.\\n* As a result, our algorithm is reduced to just two BFSs.\\n* First, BFS to find the longest path\\'s endpoint, then BFS from there to find the actual longest path.\\n\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int: \\n        \\n        adj_list = defaultdict(list)\\n        roots = set([0])\\n        \\n        for i, x in enumerate(parent[1:], start = 1):\\n            if s[i] != s[x]:\\n                adj_list[x].append(i)\\n                adj_list[i].append(x)\\n            else:\\n                roots.add(i)\\n        \\n        # returns the farthest node and distance from node u\\n        def BFS(u):\\n            # visited nodes and length of path from u\\n            visit_dis = dict()\\n            \\n            queue = deque([u])\\n            visit_dis[u] = 1\\n            maxDist = 1\\n            nodeid = u\\n            \\n            while queue:\\n                cur_node = queue.pop()\\n                \\n                for i in adj_list[cur_node]:\\n                    if i not in visit_dis:\\n                        visit_dis[i] = visit_dis[cur_node] + 1\\n                        queue.appendleft(i)\\n                        \\n                        maxDist = visit_dis[i]\\n                        nodeid = i\\n                        \\n            return nodeid, maxDist\\n        \\n        #  returns longest path of given tree root\\n        def LongestPathLength(root):\\n            # first BFS to find one end point of longest path\\n            node_1, dis_1 = BFS(root)\\n            # second BFS to find the longest path\\n            node_2, dis_2 = BFS(node_1)\\n            \\n            return dis_2\\n        \\n        return max(LongestPathLength(root) for root in roots)\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int: \\n        \\n        adj_list = defaultdict(list)\\n        roots = set([0])\\n        \\n        for i, x in enumerate(parent[1:], start = 1):\\n            if s[i] != s[x]:\\n                adj_list[x].append(i)\\n                adj_list[i].append(x)\\n            else:\\n                roots.add(i)\\n        \\n        # returns the farthest node and distance from node u\\n        def BFS(u):\\n            # visited nodes and length of path from u\\n            visit_dis = dict()\\n            \\n            queue = deque([u])\\n            visit_dis[u] = 1\\n            maxDist = 1\\n            nodeid = u\\n            \\n            while queue:\\n                cur_node = queue.pop()\\n                \\n                for i in adj_list[cur_node]:\\n                    if i not in visit_dis:\\n                        visit_dis[i] = visit_dis[cur_node] + 1\\n                        queue.appendleft(i)\\n                        \\n                        maxDist = visit_dis[i]\\n                        nodeid = i\\n                        \\n            return nodeid, maxDist\\n        \\n        #  returns longest path of given tree root\\n        def LongestPathLength(root):\\n            # first BFS to find one end point of longest path\\n            node_1, dis_1 = BFS(root)\\n            # second BFS to find the longest path\\n            node_2, dis_2 = BFS(node_1)\\n            \\n            return dis_2\\n        \\n        return max(LongestPathLength(root) for root in roots)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966325,
                "title": "java-diameter-problem-dfs-commented",
                "content": "```\\nclass Solution {\\n    int ans;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        List<List<Integer>> store = new ArrayList<>();\\n\\t\\t//creating a graph\\n        for(int i = 0; i < n; i++) {\\n            store.add(new ArrayList<Integer>());\\n        }\\n\\t\\t//adding values to graph\\n        for(int i = 1; i < n; i++) {\\n            store.get(parent[i]).add(i);\\n        }\\n\\t\\t//storing minimum value to ans\\n        ans = Integer.MIN_VALUE;\\n        dfs(store, 0, s);\\n        return ans;\\n    }\\n    \\n    public int dfs(List<List<Integer>> graph, int curr, String s) {\\n        int max1 = 0, max2 = 0; // storing maximum and 2nd maximum value\\n\\t\\t\\n\\t\\t//traversing throuogh all childs of \\'curr\\'\\n        for(int i : graph.get(curr)) {\\n            int st = dfs(graph, i, s);\\n            if(s.charAt(curr) != s.charAt(i))\\n\\t\\t\\t//storing maximum and 2nd maximum value\\n\\t\\t\\t\\tif(st>max1) {\\n\\t\\t\\t\\t\\tmax2 = max1;\\n\\t\\t\\t\\t\\tmax1 = st;\\n\\t\\t\\t\\t} else if(st > max2) {\\n\\t\\t\\t\\t\\tmax2 = st;\\n\\t\\t\\t\\t}\\n        }\\n\\t\\t//adding 1 -> to count the contribution of node also\\n        ans = Math.max(max1+max2+1, ans);\\n\\t\\t//returning the maximum path (to reach a leaf node)\\n        return max1+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        List<List<Integer>> store = new ArrayList<>();\\n\\t\\t//creating a graph\\n        for(int i = 0; i < n; i++) {\\n            store.add(new ArrayList<Integer>());\\n        }\\n\\t\\t//adding values to graph\\n        for(int i = 1; i < n; i++) {\\n            store.get(parent[i]).add(i);\\n        }\\n\\t\\t//storing minimum value to ans\\n        ans = Integer.MIN_VALUE;\\n        dfs(store, 0, s);\\n        return ans;\\n    }\\n    \\n    public int dfs(List<List<Integer>> graph, int curr, String s) {\\n        int max1 = 0, max2 = 0; // storing maximum and 2nd maximum value\\n\\t\\t\\n\\t\\t//traversing throuogh all childs of \\'curr\\'\\n        for(int i : graph.get(curr)) {\\n            int st = dfs(graph, i, s);\\n            if(s.charAt(curr) != s.charAt(i))\\n\\t\\t\\t//storing maximum and 2nd maximum value\\n\\t\\t\\t\\tif(st>max1) {\\n\\t\\t\\t\\t\\tmax2 = max1;\\n\\t\\t\\t\\t\\tmax1 = st;\\n\\t\\t\\t\\t} else if(st > max2) {\\n\\t\\t\\t\\t\\tmax2 = st;\\n\\t\\t\\t\\t}\\n        }\\n\\t\\t//adding 1 -> to count the contribution of node also\\n        ans = Math.max(max1+max2+1, ans);\\n\\t\\t//returning the maximum path (to reach a leaf node)\\n        return max1+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955349,
                "title": "c-o-n-top-down-dp-on-tree",
                "content": "Build `graph`. Build `memo` which is the longest path starting at `node` and not going back to `from`.\\nComplexity: O(V + E) = O(n)\\n```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    vector<unordered_map<int, int>> memo;\\n    int find(int node, int from, char ch, const string &s) {\\n        if (s[node] == ch) {\\n            return 0;\\n        }\\n        if (memo[node].find(from) != memo[node].end()) {\\n            return memo[node][from];\\n        }\\n        int result = 0;\\n        for (int next : graph[node]) {\\n            if (next == from) {\\n                continue;\\n            }\\n            result = max(result, find(next, node, s[node], s));\\n        }\\n        result++;\\n        memo[node][from] = result;\\n        return result;\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        graph = vector<vector<int>>(n);\\n        memo = vector<unordered_map<int, int>>(n);\\n        for (int i = 1; i < n; i++) {\\n            graph[parent[i]].push_back(i);\\n            graph[i].push_back(parent[i]);\\n        }\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            result = max(result, find(i, -1, \\'0\\', s));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    vector<unordered_map<int, int>> memo;\\n    int find(int node, int from, char ch, const string &s) {\\n        if (s[node] == ch) {\\n            return 0;\\n        }\\n        if (memo[node].find(from) != memo[node].end()) {\\n            return memo[node][from];\\n        }\\n        int result = 0;\\n        for (int next : graph[node]) {\\n            if (next == from) {\\n                continue;\\n            }\\n            result = max(result, find(next, node, s[node], s));\\n        }\\n        result++;\\n        memo[node][from] = result;\\n        return result;\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        graph = vector<vector<int>>(n);\\n        memo = vector<unordered_map<int, int>>(n);\\n        for (int i = 1; i < n; i++) {\\n            graph[parent[i]].push_back(i);\\n            graph[i].push_back(parent[i]);\\n        }\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            result = max(result, find(i, -1, \\'0\\', s));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047144,
                "title": "simple-python-solution-with-explanation",
                "content": "# Approach\\n\\n* Create adjacency list since its easier to traverse with adjacency list\\n\\n* Lets solve this recursively using Depth First Search (DFS)\\n\\n    ![Untitled-2023-01-11-1852(3).png](https://assets.leetcode.com/users/images/e66c971e-d2ec-4afa-9bc0-1096286bba7d_1673640950.1146278.png)\\n    \\n\\n    * Lets assume, there is no condition on adjacent nodes, they can have the same value.\\n    Now, for node-1, max_value will be maximum of \\n        1) max value of node-2 (child sub tree can have the max value, in this case 4)\\n        2) max value of node-3 (in this case also 4)\\n        3) max leg of node-2 + max leg of node-3 + 1 (in this case 8)\\n\\n    * Lets bring back the condition on adjacent nodes, in the image, lets say, node-1 and node-2 have same value,\\n    Now, for node-1, max_value will be maximum of \\n        1) max value of node-2 (in this case 4)\\n        2) max value of node-3 (in this case 4)\\n        3) ~~max leg of node-2 +~~ max leg of node-3 + 1  (in this case 4)\\n\\n        So, for any node, if the child and the node has same value, we won\\'t consider its max leg, the max leg value becomes zero\\n\\n    * So our resursive function will return max value of the leg from the root node of the sub tree and the max_value for the sub-tree \\n\\n    * Since this is not a binary tree, the root node can have multiple children, hence we keep track of max_leg1 and max_leg2 to make a path between two children \\n\\n\\n    \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ -> function stack, adj_list\\n\\n# Code (with comments)\\n```python []\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        n = len(parent)\\n\\n        # constructing adjacency list\\n        adj_list = {i: [] for i in range(n)}\\n        for i in range(1, n):\\n            adj_list[parent[i]].append(i)\\n\\n        # depth first search\\n        def dfs(node):\\n            max_value = max_leg1 = max_leg2 = 0\\n            for child in adj_list[node]:\\n                # get max leg and max value of the child tree\\n                (leg, value) = dfs(child)\\n                if s[child] == s[node]:\\n                    leg = 0\\n\\n                # max_leg1 is the max leg length \\n                # max_leg2 is the second max leg length\\n                if leg > max_leg1:\\n                    max_leg2, max_leg1 = max_leg1, leg\\n                elif leg > max_leg2:\\n                    max_leg2 = leg\\n\\n                # max value of child trees\\n                max_value = max(value, max_value)\\n\\n            # value which includes max_leg1, max_leg2 and the root of this subtree\\n            max_value = max(max_value, (max_leg1 + max_leg2 + 1))\\n            return (max_leg1 + 1, max_value)\\n\\n        _, max_value = dfs(0)\\n        return max_value\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```python []\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        n = len(parent)\\n\\n        # constructing adjacency list\\n        adj_list = {i: [] for i in range(n)}\\n        for i in range(1, n):\\n            adj_list[parent[i]].append(i)\\n\\n        # depth first search\\n        def dfs(node):\\n            max_value = max_leg1 = max_leg2 = 0\\n            for child in adj_list[node]:\\n                # get max leg and max value of the child tree\\n                (leg, value) = dfs(child)\\n                if s[child] == s[node]:\\n                    leg = 0\\n\\n                # max_leg1 is the max leg length \\n                # max_leg2 is the second max leg length\\n                if leg > max_leg1:\\n                    max_leg2, max_leg1 = max_leg1, leg\\n                elif leg > max_leg2:\\n                    max_leg2 = leg\\n\\n                # max value of child trees\\n                max_value = max(value, max_value)\\n\\n            # value which includes max_leg1, max_leg2 and the root of this subtree\\n            max_value = max(max_value, (max_leg1 + max_leg2 + 1))\\n            return (max_leg1 + 1, max_value)\\n\\n        _, max_value = dfs(0)\\n        return max_value\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046839,
                "title": "java-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int longestPathValue = 1; // variable to store the length of the longest path\\n\\n    public int longestPath(int[] parent, String s) {\\n        // create an adjacency list representation of the tree\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for(int i = 1; i < parent.length; i++){\\n            int j = parent[i];\\n            adj.putIfAbsent(j, new LinkedList<>());\\n            adj.get(j).add(i);\\n        }\\n        // call dfs on the root of the tree\\n        dfs(0, adj, s);\\n        return longestPathValue;\\n    }\\n\\n    public int dfs(int node, Map<Integer, List<Integer>> adj, String s){\\n        // if the node is a leaf node, return 1\\n        if(!adj.containsKey(node)) return 1;\\n        int max = 0, secondMax = 0;\\n        // for each neighbor of the node\\n        for(int nbrNode : adj.get(node)){\\n            int longestPathFromNbrNode = dfs(nbrNode , adj, s);\\n            // if the characters at the current node and its neighbor are the same, ignore the neighbor\\n            if(s.charAt(node) == s.charAt(nbrNode)) continue;\\n            // update max and secondMax with the longest path from the neighbor node\\n            if(longestPathFromNbrNode > max){\\n                secondMax = max;\\n                max = longestPathFromNbrNode;\\n            }else if(longestPathFromNbrNode > secondMax){\\n                secondMax = longestPathFromNbrNode;\\n            }\\n        }\\n        // update longestPathValue with the longest path that includes the current node\\n        longestPathValue = Math.max(longestPathValue, max+secondMax+1);\\n        return max+1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int longestPathValue = 1; // variable to store the length of the longest path\\n\\n    public int longestPath(int[] parent, String s) {\\n        // create an adjacency list representation of the tree\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for(int i = 1; i < parent.length; i++){\\n            int j = parent[i];\\n            adj.putIfAbsent(j, new LinkedList<>());\\n            adj.get(j).add(i);\\n        }\\n        // call dfs on the root of the tree\\n        dfs(0, adj, s);\\n        return longestPathValue;\\n    }\\n\\n    public int dfs(int node, Map<Integer, List<Integer>> adj, String s){\\n        // if the node is a leaf node, return 1\\n        if(!adj.containsKey(node)) return 1;\\n        int max = 0, secondMax = 0;\\n        // for each neighbor of the node\\n        for(int nbrNode : adj.get(node)){\\n            int longestPathFromNbrNode = dfs(nbrNode , adj, s);\\n            // if the characters at the current node and its neighbor are the same, ignore the neighbor\\n            if(s.charAt(node) == s.charAt(nbrNode)) continue;\\n            // update max and secondMax with the longest path from the neighbor node\\n            if(longestPathFromNbrNode > max){\\n                secondMax = max;\\n                max = longestPathFromNbrNode;\\n            }else if(longestPathFromNbrNode > secondMax){\\n                secondMax = longestPathFromNbrNode;\\n            }\\n        }\\n        // update longestPathValue with the longest path that includes the current node\\n        longestPathValue = Math.max(longestPathValue, max+secondMax+1);\\n        return max+1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046427,
                "title": "most-detailed-solution-c-dfs",
                "content": "# Intuition\\n\\n--> So this problem is very similar to `Finding diameter of tree` problem where we find the `longest path from any leaf node to any other leaf node.` So let\\'s first discuss the diameter of tree and then we will see how its useful for this problem.\\n\\n### Diameter of Tree (Initial idea)\\n\\n--> To find diameter of tree, we will start from `root` node and recursively we will goto any leaf node in its left or right subtree. \\n\\nConsider one tree here:\\n\\n![image.png](https://assets.leetcode.com/users/images/579cb90e-837c-4ee3-811f-e608b277923d_1673630590.0103319.png)\\n\\n--> Now for each node we will have 2 possibilities:\\n\\n1. If that node is the turning point for the path means diameter of tree will pass through this node.\\n\\nFor example in diagram node `A` is passing the first possibility:\\n\\n![image.png](https://assets.leetcode.com/users/images/c3572ce8-c34c-4ef4-a7ab-b054e393333a_1673630634.4305274.png)\\n\\nthen we will find the diameter of left subtree and right subtree and add current node into it and we will get our final diamter.\\n\\n2. If that node is just contributing to the path which is diameter of tree.\\nFor example in diagram node `A` is passing the second possilibity:\\n\\n![image.png](https://assets.leetcode.com/users/images/482bb7ad-d301-4357-9d78-efc45ff38c4b_1673630677.618005.png)\\n\\nSo here we will just find the longest diameter of both of its subtrees and add `1` into it and pass to its parent.\\n\\n---\\n\\n# Approach\\n\\n--> Now in this problem also we can see that we need the `longest path` so here we can apply the same logic which we used above but with some changes!\\n\\nFirst of all this is not a binary tree, it will be generic tree so it will be easy for us to think it as a graph and to traverse a graph we will need `adjacency list` which we can make from `parent` array.\\n\\nMaking adjacency list:\\n\\n```cpp\\nint n = parent.size();\\nunordered_map<int,vector<int>>adj;\\n// we are starting from 1st index because parent of root will be -1 and we have already visited this node as we are starting from this node only\\nfor(int i=1;i<n;i++){\\n\\tadj[parent[i]].push_back(i);\\n}\\n```\\n\\nNow we will use `dfs` to traverse this graph and during traversing the graph we will follow the same logic which we followed in finding diameter of tree but there will be some edge cases.\\n\\n### Edge cases:\\n\\n--> We know that for finding diameter of tree our path will begin and end at any `leaf node` but in this problem, that\\'s not the case so we have to take care of one more case which will be like this:\\n\\n![image.png](https://assets.leetcode.com/users/images/2d915342-1c85-4923-a5fb-245c882724f8_1673630738.3328218.png)\\n\\nSo to handle this case we will put one condition `If labels of parent and child are same then we will just skip that node and we will traverse current parent\\'s other childs.`\\n\\n### Approach (Continue...)\\n\\n--> Now in trees we now that there will be at max only 2 children to any node but here its not the case so we will maintain 2 variables called `bestLength` and `secondBest` which will be the top 2 max answers from all of parent\\'s childs. \\n\\nAlso for each node we will implement those 2 cases from `diameter of tree` problem.\\n\\n```\\nCase 1: Use current node as a turning point for path\\nCase 2: Use current node as a contributor to final path\\n```\\n\\n--> And at last take `maximum` of these 2 cases and store it in global `ans` variable.\\n\\n`\\nRemember that we have to return the answer of case 2 because in case 2 we are returning answer to current node\\'s parent.\\n`\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int dfs(int parent,unordered_map<int,vector<int>>&adj,string &s){\\n        int bestLength = 0;\\n        int secondBest = 0;\\n        for(auto &child:adj[parent]){\\n            int currBest = dfs(child,adj,s);\\n            // Different adjacent character case\\n            if(s[parent] == s[child]){\\n                continue;\\n            }\\n            if(currBest > bestLength){\\n                secondBest = bestLength;\\n                bestLength = currBest;\\n            }\\n            else if(currBest > secondBest){\\n                secondBest = currBest;\\n            }\\n        }\\n        // Diameter of tree cases\\n        // Case 1: Pass through\\n        int passThrough = 1 + bestLength + secondBest;\\n        // case 2: Contribute to path\\n        int contriPath = 1 + bestLength;\\n        // Take maximum of both cases and store in ans\\n        ans = max({ans,passThrough,contriPath});\\n        // Returning answer of case 2\\n        return contriPath;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        ans = 0;\\n        int n = parent.size();\\n        unordered_map<int,vector<int>>adj;\\n        for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0,adj,s);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nIf you want to see more solutions like this then find it [here](https://github.com/shivam1317/DSA-Notes)\\n\\nThanks for reading.",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nint n = parent.size();\\nunordered_map<int,vector<int>>adj;\\n// we are starting from 1st index because parent of root will be -1 and we have already visited this node as we are starting from this node only\\nfor(int i=1;i<n;i++){\\n\\tadj[parent[i]].push_back(i);\\n}\\n```\n```\\nCase 1: Use current node as a turning point for path\\nCase 2: Use current node as a contributor to final path\\n```\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int dfs(int parent,unordered_map<int,vector<int>>&adj,string &s){\\n        int bestLength = 0;\\n        int secondBest = 0;\\n        for(auto &child:adj[parent]){\\n            int currBest = dfs(child,adj,s);\\n            // Different adjacent character case\\n            if(s[parent] == s[child]){\\n                continue;\\n            }\\n            if(currBest > bestLength){\\n                secondBest = bestLength;\\n                bestLength = currBest;\\n            }\\n            else if(currBest > secondBest){\\n                secondBest = currBest;\\n            }\\n        }\\n        // Diameter of tree cases\\n        // Case 1: Pass through\\n        int passThrough = 1 + bestLength + secondBest;\\n        // case 2: Contribute to path\\n        int contriPath = 1 + bestLength;\\n        // Take maximum of both cases and store in ans\\n        ans = max({ans,passThrough,contriPath});\\n        // Returning answer of case 2\\n        return contriPath;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        ans = 0;\\n        int n = parent.size();\\n        unordered_map<int,vector<int>>adj;\\n        for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0,adj,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046329,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int result;\\n    int dfs(int root,int parent,unordered_map<int,vector<int>> &adj,string &s){\\n        int largest=0;\\n        int secondLargest=0;\\n\\n        for(auto &child:adj[root]){\\n            if(child==parent){\\n                continue;\\n            }\\n            \\n            int child_longest_path=dfs(child,root,adj,s);\\n\\n            if(s[child]==s[root]){\\n                continue;\\n            }\\n            if(child_longest_path>secondLargest){\\n                secondLargest=child_longest_path;\\n            }\\n            if(secondLargest>largest){\\n                swap(largest,secondLargest);\\n            }\\n        }\\n            int ansIsRoot=1;\\n            int ansLeftOrRight=max(largest,secondLargest)+1;\\n            int ansIsDownTheCurr=largest+secondLargest+1;\\n\\n            result=max({result,ansIsRoot,ansLeftOrRight,ansIsDownTheCurr});\\n\\n            return max(ansIsRoot,ansLeftOrRight);\\n\\n            //logic is same as binaryTree 124 question\\n\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        \\n        unordered_map<int,vector<int>> adj;\\n        for(int i=1;i<parent.size();i++){\\n            int u=i;\\n            int v=parent[i];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        result=0;\\n        dfs(0,-1,adj,s);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int result;\\n    int dfs(int root,int parent,unordered_map<int,vector<int>> &adj,string &s){\\n        int largest=0;\\n        int secondLargest=0;\\n\\n        for(auto &child:adj[root]){\\n            if(child==parent){\\n                continue;\\n            }\\n            \\n            int child_longest_path=dfs(child,root,adj,s);\\n\\n            if(s[child]==s[root]){\\n                continue;\\n            }\\n            if(child_longest_path>secondLargest){\\n                secondLargest=child_longest_path;\\n            }\\n            if(secondLargest>largest){\\n                swap(largest,secondLargest);\\n            }\\n        }\\n            int ansIsRoot=1;\\n            int ansLeftOrRight=max(largest,secondLargest)+1;\\n            int ansIsDownTheCurr=largest+secondLargest+1;\\n\\n            result=max({result,ansIsRoot,ansLeftOrRight,ansIsDownTheCurr});\\n\\n            return max(ansIsRoot,ansLeftOrRight);\\n\\n            //logic is same as binaryTree 124 question\\n\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        \\n        unordered_map<int,vector<int>> adj;\\n        for(int i=1;i<parent.size();i++){\\n            int u=i;\\n            int v=parent[i];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        result=0;\\n        dfs(0,-1,adj,s);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046297,
                "title": "dfs-solution-with-explanations-what-two-options-are-for-each-recursive-call",
                "content": "# Intuition\\n1. The path here is counting the number of nodes on a path instead of edges.\\n2. Similar to 543. Diameter of Binary Tree, the longest path may or may not pass through the root.\\n3. This leaves us with two options: \\n    a .  The longest path passes the current node, and in the subtree which is rooted by the current node, so that we find top two of the longest paths plus the current node. \\n    b. The longest path does may or may not pass the current root, but it is not in the subtree which is rooted by the current node, then we pass the longest path that passes the root back to upper level for further use. \\n\\n# Approach\\nDFS\\n\\n# Complexity\\n- Time complexity:\\nO(m+n)\\n\\n- Space complexity:\\nO(m+n)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        graph = collections.defaultdict(list)\\n        for i in range(1, len(parent)):\\n            graph[i].append(parent[i])\\n            graph[parent[i]].append(i)\\n        ans=0\\n        def dfs(root,parent):\\n            nonlocal ans\\n            res = 0\\n            first_path=0\\n            second_path=0\\n            for v in graph[root]:\\n                if v != parent :\\n                    cur_path = dfs(v,root)\\n                    #####################################\\n                    #option1 : The longest path is under this subtree\\n                    #Then we find the top 2 longest path under this subtree\\n                    #and add them with the subtree root(current node)\\n                    if cur_path > first_path:\\n                        second_path = first_path\\n                        first_path=cur_path\\n                        \\n                    elif cur_path > second_path:\\n                        second_path = cur_path\\n                    #####################################\\n                    #Option 2: The longest path is not under this subtree\\n                    #But since one of the branchs of the subtree may be part of the longest path,\\n                    # We pass the best among all branches back to upper level for future use.\\n                    res=max(res,cur_path)\\n            #compare two options for the best, ans is a global var\\n            ans = max(ans,first_path+second_path+1)\\n            if s[root]!=s[parent]:\\n                return res +1\\n            else:\\n                return 0\\n        \\n\\n        dfs(0,0)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        graph = collections.defaultdict(list)\\n        for i in range(1, len(parent)):\\n            graph[i].append(parent[i])\\n            graph[parent[i]].append(i)\\n        ans=0\\n        def dfs(root,parent):\\n            nonlocal ans\\n            res = 0\\n            first_path=0\\n            second_path=0\\n            for v in graph[root]:\\n                if v != parent :\\n                    cur_path = dfs(v,root)\\n                    #####################################\\n                    #option1 : The longest path is under this subtree\\n                    #Then we find the top 2 longest path under this subtree\\n                    #and add them with the subtree root(current node)\\n                    if cur_path > first_path:\\n                        second_path = first_path\\n                        first_path=cur_path\\n                        \\n                    elif cur_path > second_path:\\n                        second_path = cur_path\\n                    #####################################\\n                    #Option 2: The longest path is not under this subtree\\n                    #But since one of the branchs of the subtree may be part of the longest path,\\n                    # We pass the best among all branches back to upper level for future use.\\n                    res=max(res,cur_path)\\n            #compare two options for the best, ans is a global var\\n            ans = max(ans,first_path+second_path+1)\\n            if s[root]!=s[parent]:\\n                return res +1\\n            else:\\n                return 0\\n        \\n\\n        dfs(0,0)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045519,
                "title": "c-solution-dfs-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int dfs(int node, vector<vector<int>>& graph, string& s) {\\n        int max1 = 0;\\n        int max2 = 0;\\n        for(int& i : graph[node]) {\\n            int val = dfs(i, graph, s);\\n            if(s[i] == s[node]) continue;\\n            if(val > max1) {max2 = max1; max1 = val;}\\n            else if(val > max2) {max2 = val;}\\n        }\\n        ans = max(ans, max1 + max2 + 1);\\n        return max1 + 1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> graph(n, vector<int>());\\n        for(int i = 1; i < n; i++) graph[parent[i]].push_back(i);\\n        ans = 1;\\n        dfs(0, graph, s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    int dfs(int node, vector<vector<int>>& graph, string& s) {\\n        int max1 = 0;\\n        int max2 = 0;\\n        for(int& i : graph[node]) {\\n            int val = dfs(i, graph, s);\\n            if(s[i] == s[node]) continue;\\n            if(val > max1) {max2 = max1; max1 = val;}\\n            else if(val > max2) {max2 = val;}\\n        }\\n        ans = max(ans, max1 + max2 + 1);\\n        return max1 + 1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> graph(n, vector<int>());\\n        for(int i = 1; i < n; i++) graph[parent[i]].push_back(i);\\n        ans = 1;\\n        dfs(0, graph, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045377,
                "title": "c-2023-must-watch-intuitive-dfs-sol-explanation",
                "content": "* Please upvode if you like my sol. That would we highly appreciable.\\n\\n* DFS\\n\\n\\n```\\nclass Solution {\\n    int n,ans; vector<vector<int>> graph;\\n    int dfs(int root, string &s,int par){\\n        priority_queue<int, vector<int>, greater<int>> pq;  // this pq will store top 2 longest path from all the child\\n        for(int child:graph[root]){\\n            pq.push(dfs(child,s,root));\\n            if(pq.size()>2) pq.pop();\\n        }\\n        if(!(pq.size()))  return s[root]==s[par] ? 0 : 1;  // this is the base case for leaf node\\n        int mx=0, temp = 1;  // now we will take temp max ans ans we will take max = mx from all the result stored in pq to get the max from all the children node \\n        while(pq.size()) {\\n            mx = max(mx,pq.top()), \\n            temp +=pq.top(); // this will get max from top 2 element in pq and give the current max at the current node\\n            pq.pop();\\n        }\\n        ans = max(temp,ans); // store the max \\n        return s[root]==s[par] ? 0 : mx+1; //  if root amd par have different dtring value then we will return max from all the child node + 1 = max + 1\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string &s) {\\n        n = parent.size(); graph.resize(n); s.push_back(s[0]+1);\\n        for(int i=1;i<n;i++) graph[parent[i]].push_back(i);\\n        return max(dfs(0,s,n),ans); // i think we can simply return ans.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int n,ans; vector<vector<int>> graph;\\n    int dfs(int root, string &s,int par){\\n        priority_queue<int, vector<int>, greater<int>> pq;  // this pq will store top 2 longest path from all the child\\n        for(int child:graph[root]){\\n            pq.push(dfs(child,s,root));\\n            if(pq.size()>2) pq.pop();\\n        }\\n        if(!(pq.size()))  return s[root]==s[par] ? 0 : 1;  // this is the base case for leaf node\\n        int mx=0, temp = 1;  // now we will take temp max ans ans we will take max = mx from all the result stored in pq to get the max from all the children node \\n        while(pq.size()) {\\n            mx = max(mx,pq.top()), \\n            temp +=pq.top(); // this will get max from top 2 element in pq and give the current max at the current node\\n            pq.pop();\\n        }\\n        ans = max(temp,ans); // store the max \\n        return s[root]==s[par] ? 0 : mx+1; //  if root amd par have different dtring value then we will return max from all the child node + 1 = max + 1\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string &s) {\\n        n = parent.size(); graph.resize(n); s.push_back(s[0]+1);\\n        for(int i=1;i<n;i++) graph[parent[i]].push_back(i);\\n        return max(dfs(0,s,n),ans); // i think we can simply return ans.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045164,
                "title": "longest-path-with-different-adjacent-characters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a graph and use DFS approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse dfs and calculate two cases on each and every node.\\n1. Case 1: when current node is our ans node then find two max childLen and store that into global ans.\\n2. Case 2: when current node is not our answer then return max childLen.\\n\\n# Code\\n```\\n//Please let me know If it is difficult to understand, I will add the more explanation.\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    int dfs(vector<int> adj[],int parent,int node,string &s)\\n    {\\n        // Create two max length variable\\n        int maxLen = 0;\\n        int maxLen2 = 0;\\n\\n        for(int i=0;i<adj[node].size();i++)\\n        {\\n            int child = adj[node][i];\\n\\n            //No self loop\\n            if(parent==child)\\n            continue;\\n\\n            int childMaxLen = dfs(adj,node,child,s);\\n            // Calculate maxLen or maxLen2 only when adjacent char are differents\\n            if(s[node]!=s[child])\\n            {\\n                //case 1: when childMaxLen is greater or than maxLen\\n                if(maxLen<=childMaxLen)\\n                {\\n                    maxLen2 = maxLen;\\n                    maxLen = childMaxLen;\\n                }\\n                // Case 2: when childMaxLen is greater or equal than maxLen2\\n                // but less than the maxLen\\n                else if(maxLen2<=childMaxLen)\\n                {\\n                    maxLen2 = childMaxLen;\\n                }\\n            }\\n        }\\n\\n        //Global ans will track and store max value at each tree node.\\n        ans = max(1+maxLen+maxLen2,ans);\\n\\n        // return maxLen\\n        return 1 + maxLen;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n\\n        int n = parent.size();\\n        vector<int> adj[n];\\n\\n        //Create a graph\\n        for(int i = 1;i<n;i++)\\n        {\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n\\n        //Run dfs algorith\\n        dfs(adj,-1,0,s);\\n\\n        //Return global ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n//Please let me know If it is difficult to understand, I will add the more explanation.\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    int dfs(vector<int> adj[],int parent,int node,string &s)\\n    {\\n        // Create two max length variable\\n        int maxLen = 0;\\n        int maxLen2 = 0;\\n\\n        for(int i=0;i<adj[node].size();i++)\\n        {\\n            int child = adj[node][i];\\n\\n            //No self loop\\n            if(parent==child)\\n            continue;\\n\\n            int childMaxLen = dfs(adj,node,child,s);\\n            // Calculate maxLen or maxLen2 only when adjacent char are differents\\n            if(s[node]!=s[child])\\n            {\\n                //case 1: when childMaxLen is greater or than maxLen\\n                if(maxLen<=childMaxLen)\\n                {\\n                    maxLen2 = maxLen;\\n                    maxLen = childMaxLen;\\n                }\\n                // Case 2: when childMaxLen is greater or equal than maxLen2\\n                // but less than the maxLen\\n                else if(maxLen2<=childMaxLen)\\n                {\\n                    maxLen2 = childMaxLen;\\n                }\\n            }\\n        }\\n\\n        //Global ans will track and store max value at each tree node.\\n        ans = max(1+maxLen+maxLen2,ans);\\n\\n        // return maxLen\\n        return 1 + maxLen;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n\\n        int n = parent.size();\\n        vector<int> adj[n];\\n\\n        //Create a graph\\n        for(int i = 1;i<n;i++)\\n        {\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n\\n        //Run dfs algorith\\n        dfs(adj,-1,0,s);\\n\\n        //Return global ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045007,
                "title": "c-intuitive-solution-time-o-n-space-o-n",
                "content": "# Intuition and  Approach \\n(DFS) Bottom-Up Approach \\nReturn the `first` character(to check duplicates) and `length` of the maximum streak to the parent node then parent node pick the maximum length streak from its children and then parent node become the first character, add `1` to the length and return so on....\\nWe maintain a global variable `ans` which is calculated by adding the `two` maximum length from all children.\\n\\n# Complexity\\n- `Time` complexity: $$O(n)$$\\n- `Space` complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = 1;\\n    pair<int,char> solve(vector<vector<int>>& adj, string& s, int x, int p){\\n\\n        char c = s[x];\\n        int len = 1;     //length of current node i.e. 1\\n        int len1 = 0;   //first maximum len\\n        int len2 = 0;  //second maximum len\\n\\n        for(int i=0; i<adj[x].size(); i++){\\n            if(adj[x][i] != p){  \\n                pair<int,char> res = solve(adj,s,adj[x][i],x);\\n                //pair<int,char> means first char and length\\n                if(res.second != s[x]){\\n                    if(len2 < res.first){\\n                        if(len1 < res.first){\\n                            len2 = len1;\\n                            len1 = res.first;\\n                        }else{\\n                            len2 = res.first;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ans = max(ans,len1+len+len2);  //Updating ans by adding two maximum lengths from the all children\\n        return {len+len1,c}; // as len1 >= len2 always so only add len1\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        vector<vector<int>> adj(parent.size());\\n        for(int i=1; i<parent.size(); i++){ //creating Adjacency List\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        solve(adj,s,0,-1);\\n        return ans;\\n    }\\n};\\n```\\n\\u2764 Please Upvote if you find helpful :) \\u2764\\n\\n![55ttuz.jpg](https://assets.leetcode.com/users/images/60b239cb-1e97-494c-b3da-e833816573c8_1673609436.4359465.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = 1;\\n    pair<int,char> solve(vector<vector<int>>& adj, string& s, int x, int p){\\n\\n        char c = s[x];\\n        int len = 1;     //length of current node i.e. 1\\n        int len1 = 0;   //first maximum len\\n        int len2 = 0;  //second maximum len\\n\\n        for(int i=0; i<adj[x].size(); i++){\\n            if(adj[x][i] != p){  \\n                pair<int,char> res = solve(adj,s,adj[x][i],x);\\n                //pair<int,char> means first char and length\\n                if(res.second != s[x]){\\n                    if(len2 < res.first){\\n                        if(len1 < res.first){\\n                            len2 = len1;\\n                            len1 = res.first;\\n                        }else{\\n                            len2 = res.first;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ans = max(ans,len1+len+len2);  //Updating ans by adding two maximum lengths from the all children\\n        return {len+len1,c}; // as len1 >= len2 always so only add len1\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        vector<vector<int>> adj(parent.size());\\n        for(int i=1; i<parent.size(); i++){ //creating Adjacency List\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        solve(adj,s,0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044884,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    int dfs(int u, string& s, int& longestPath) {\\n        int lc = 0, slc = 0;\\n        for (int v: g[u]) {\\n            int lcc = dfs(v, s, longestPath);\\n            if(s[u] == s[v]) {\\n                continue;\\n            }\\n            if(lcc > lc) {\\n                slc = lc;\\n                lc = lcc;\\n            }\\n            else if(lcc > slc) {\\n                slc = lcc;\\n            }\\n        }\\n        longestPath = max(longestPath, lc + slc + 1);\\n        return lc + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        for(int i=1; i<parent.size(); i++) {\\n            g[parent[i]].push_back(i);\\n        }\\n        int longestPath = 1;\\n        dfs(0, s, longestPath);\\n        return longestPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    int dfs(int u, string& s, int& longestPath) {\\n        int lc = 0, slc = 0;\\n        for (int v: g[u]) {\\n            int lcc = dfs(v, s, longestPath);\\n            if(s[u] == s[v]) {\\n                continue;\\n            }\\n            if(lcc > lc) {\\n                slc = lc;\\n                lc = lcc;\\n            }\\n            else if(lcc > slc) {\\n                slc = lcc;\\n            }\\n        }\\n        longestPath = max(longestPath, lc + slc + 1);\\n        return lc + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        for(int i=1; i<parent.size(); i++) {\\n            g[parent[i]].push_back(i);\\n        }\\n        int longestPath = 1;\\n        dfs(0, s, longestPath);\\n        return longestPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044814,
                "title": "c-easy-and-clean-code-with-explanation",
                "content": "# Intuition\\nAt every level, check if current path is longest or not\\n\\n# Approach\\nKeep track of largest 2 paths at all levels.\\nHere \\'a\\' and \\'b\\' are used to achieve this.\\nIf the child has same character as parent, then path length with be 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void makeList(unordered_map<int, list<int>> &adj, vector<int>& parent){\\n        for(int i=1; i<parent.size(); i++){\\n            int num = parent[i];\\n            adj[num].push_back(i);\\n        }\\n    }\\n\\n    pair<int, char> solve(unordered_map<int, list<int>> &adj, string &s, int &ans, int node){\\n        int a = 0, b = 0;\\n        \\n        for(auto i : adj[node]){\\n            pair<int, char> num = solve(adj, s, ans, i);\\n            int temp = num.second != s[node] ? num.first : 0;\\n\\n            if(a > b){\\n                b = max(b, temp);\\n            }\\n            else{\\n                a = max(a, temp);\\n            }\\n        }\\n\\n        ans = max(ans, a+b+1);\\n\\n        int res = 1 + max(a,b);\\n        return {res, s[node]};\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        unordered_map<int, list<int>> adj;\\n        makeList(adj, parent);\\n\\n        int ans = -1;\\n        solve(adj, s, ans, 0);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeList(unordered_map<int, list<int>> &adj, vector<int>& parent){\\n        for(int i=1; i<parent.size(); i++){\\n            int num = parent[i];\\n            adj[num].push_back(i);\\n        }\\n    }\\n\\n    pair<int, char> solve(unordered_map<int, list<int>> &adj, string &s, int &ans, int node){\\n        int a = 0, b = 0;\\n        \\n        for(auto i : adj[node]){\\n            pair<int, char> num = solve(adj, s, ans, i);\\n            int temp = num.second != s[node] ? num.first : 0;\\n\\n            if(a > b){\\n                b = max(b, temp);\\n            }\\n            else{\\n                a = max(a, temp);\\n            }\\n        }\\n\\n        ans = max(ans, a+b+1);\\n\\n        int res = 1 + max(a,b);\\n        return {res, s[node]};\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        unordered_map<int, list<int>> adj;\\n        makeList(adj, parent);\\n\\n        int ans = -1;\\n        solve(adj, s, ans, 0);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044797,
                "title": "easy-to-understand-dfs-postorder-with-testcases",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/hard/math/LongestPathDifferentAdjacentCharacters.kt",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3044386,
                "title": "c-picture-commented-solution-dfs-on-adj-list",
                "content": "We are climbing up the tree/Graph from the leaf node, and taking the `path`, and from that updating `maxPath` and `ans`.\\n\\n![image](https://assets.leetcode.com/users/images/dfdbeb3d-44f4-4040-9f3e-6701eb3a26ee_1673598716.5030055.png)\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> adj;\\n    int ans = 1;\\n\\n    int dfs(int currNode, int parent, string &labels) {\\n        int maxPath = 1;\\n        \\n        for(int &node : adj[currNode]) {\\n            if(node != parent) { // as adj list contains a edge to parent node as well, so to avoid an infinite loop\\n                \\n                int path = dfs(node, currNode, labels);\\n                \\n                if(labels[node] != labels[currNode]) { // adjacent chars are not equal\\n                    ans = max(ans, maxPath + path);\\n                    maxPath = max(maxPath, path + 1);\\n                }\\n            }\\n        }\\n        \\n        return maxPath;\\n    }\\n\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        // creating adjacency list\\n        int n = parent.size();\\n        adj.resize(n);\\n        \\n        for(int i = 1; i < n; ++i) {\\n            adj[parent[i]].push_back(i); // i is bonded with its parent\\n            adj[i].push_back(parent[i]); // undirected, that\\'s why 2 way binding\\n        }\\n        \\n        /*\\n            for ex1 - adj list =>\\n            0 -> 1, 2\\n            1 -> 0, 3, 4\\n            2 -> 5\\n            3 -> 1\\n            4 -> 1\\n        */\\n        \\n        dfs(0, -1, s);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> adj;\\n    int ans = 1;\\n\\n    int dfs(int currNode, int parent, string &labels) {\\n        int maxPath = 1;\\n        \\n        for(int &node : adj[currNode]) {\\n            if(node != parent) { // as adj list contains a edge to parent node as well, so to avoid an infinite loop\\n                \\n                int path = dfs(node, currNode, labels);\\n                \\n                if(labels[node] != labels[currNode]) { // adjacent chars are not equal\\n                    ans = max(ans, maxPath + path);\\n                    maxPath = max(maxPath, path + 1);\\n                }\\n            }\\n        }\\n        \\n        return maxPath;\\n    }\\n\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        // creating adjacency list\\n        int n = parent.size();\\n        adj.resize(n);\\n        \\n        for(int i = 1; i < n; ++i) {\\n            adj[parent[i]].push_back(i); // i is bonded with its parent\\n            adj[i].push_back(parent[i]); // undirected, that\\'s why 2 way binding\\n        }\\n        \\n        /*\\n            for ex1 - adj list =>\\n            0 -> 1, 2\\n            1 -> 0, 3, 4\\n            2 -> 5\\n            3 -> 1\\n            4 -> 1\\n        */\\n        \\n        dfs(0, -1, s);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044226,
                "title": "day-13-c-java-python-detailed-explanation-solution",
                "content": "![WhatsApp Image 2023-01-13 at 10.41.19 AM.jpeg](https://assets.leetcode.com/users/images/678d0941-035c-4408-8231-cbcce329dab6_1673596025.9026396.jpeg)\\n# Approach\\nThe above code is a solution in C++ to find the longest path of consecutive characters in a string where the end character of one node is the start character of the next node. The path is defined by a parent array where parent[i] is the parent of node i. The root node is assumed to be node 0 and its parent is -1.\\n\\nThe solution uses a depth-first search (DFS) algorithm to traverse the nodes and find the longest path. It creates an adjacency list representation of the tree using the parent array, then calls the longestPath function with the root node, the string, and the adjacency list as inputs.\\n\\nThe longestPath function takes in the current node, the string, and the adjacency list as inputs. It starts by initializing the distance of the current node to 1. It then iterates through all the nodes in the adjacency list of the current node, and for each node, it calls itself recursively to find the longest path from that node. If the end character of the current node is the same as the start character of the next node, it continues without updating the output or the distance. Else, it updates the output with the maximum of the current output and the sum of the distance of the current node and the next node. Finally, it updates the distance of the current node with the maximum of the current distance and the distance of the next node plus 1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime complexity: **O(n)** Here, n is the number of nodes.\\n\\nEach node is visited by the dfs function once, which takes O(n) time in total. We also iterate over the edges of every node once (since we don\\'t visit a node more than once, we don\\'t iterate its edges more than once), which adds O(n) time since we have n\\u22121 edges.\\nWe also need O(n) time to initialize the children array.\\n\\nSpace complexity: **O(n)** Here, n is the number of nodes.\\n\\nThe recursion call stack used by dfs can have no more than nnn elements in the worst-case scenario. So, we would take up O(n) space in the worst case.\\nWe also need O(n) space for the the children array.\\n```C++ []\\nclass Solution {\\npublic:\\n    int distance[100005];\\n    int output = 1;\\n    void longestPath(int currNode, string& s, vector<vector<int>>& adj){\\n        distance[currNode] = 1;\\n        for(int node : adj[currNode]){\\n            longestPath(node, s, adj);\\n            if(s[node] == s[currNode])\\n                continue;\\n            output = max(output, distance[currNode] + distance[node]);\\n            distance[currNode] = max(distance[currNode], distance[node] + 1);\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        //creating adjacency list\\n        vector<vector<int>> adj;\\n        adj.resize(parent.size());\\n        //adjacency list is making on the basis of this statement = parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1\\n        for(int i = 1; i < parent.size(); i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        //calling for dfs\\n        longestPath(0, s, adj);\\n        return output;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    distance = [0] * 100005\\n    output = 1\\n\\n    def longestPath(self, currNode, s, adj):\\n        self.distance[currNode] = 1\\n        for node in adj[currNode]:\\n            self.longestPath(node, s, adj)\\n            if s[node] == s[currNode]:\\n                continue\\n            self.output = max(self.output, self.distance[currNode] + self.distance[node])\\n            self.distance[currNode] = max(self.distance[currNode], self.distance[node] + 1)\\n\\n    def longestPath(self, parent, s):\\n        adj = [[] for _ in range(len(parent))]\\n        for i in range(1, len(parent)):\\n            adj[parent[i]].append(i)\\n        self.longestPath(0, s, adj)\\n        return self.output\\n\\n```\\n```java []\\nclass Solution {\\n    int distance[] = new int[100005];\\n    int output = 1;\\n\\n    void longestPath(int currNode, String s, ArrayList<ArrayList<Integer>> adj) {\\n        distance[currNode] = 1;\\n        for (int node : adj.get(currNode)) {\\n            longestPath(node, s, adj);\\n            if (s.charAt(node) == s.charAt(currNode))\\n                continue;\\n            output = Math.max(output, distance[currNode] + distance[node]);\\n            distance[currNode] = Math.max(distance[currNode], distance[node] + 1);\\n        }\\n    }\\n\\n    int longestPath(int[] parent, String s) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\\n        for (int i = 0; i < parent.length; i++)\\n            adj.add(new ArrayList<Integer>());\\n        for (int i = 1; i < parent.length; i++)\\n            adj.get(parent[i]).add(i);\\n        longestPath(0, s, adj);\\n        return output;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int distance[100005];\\n    int output = 1;\\n    void longestPath(int currNode, string& s, vector<vector<int>>& adj){\\n        distance[currNode] = 1;\\n        for(int node : adj[currNode]){\\n            longestPath(node, s, adj);\\n            if(s[node] == s[currNode])\\n                continue;\\n            output = max(output, distance[currNode] + distance[node]);\\n            distance[currNode] = max(distance[currNode], distance[node] + 1);\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        //creating adjacency list\\n        vector<vector<int>> adj;\\n        adj.resize(parent.size());\\n        //adjacency list is making on the basis of this statement = parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1\\n        for(int i = 1; i < parent.size(); i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        //calling for dfs\\n        longestPath(0, s, adj);\\n        return output;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    distance = [0] * 100005\\n    output = 1\\n\\n    def longestPath(self, currNode, s, adj):\\n        self.distance[currNode] = 1\\n        for node in adj[currNode]:\\n            self.longestPath(node, s, adj)\\n            if s[node] == s[currNode]:\\n                continue\\n            self.output = max(self.output, self.distance[currNode] + self.distance[node])\\n            self.distance[currNode] = max(self.distance[currNode], self.distance[node] + 1)\\n\\n    def longestPath(self, parent, s):\\n        adj = [[] for _ in range(len(parent))]\\n        for i in range(1, len(parent)):\\n            adj[parent[i]].append(i)\\n        self.longestPath(0, s, adj)\\n        return self.output\\n\\n```\n```java []\\nclass Solution {\\n    int distance[] = new int[100005];\\n    int output = 1;\\n\\n    void longestPath(int currNode, String s, ArrayList<ArrayList<Integer>> adj) {\\n        distance[currNode] = 1;\\n        for (int node : adj.get(currNode)) {\\n            longestPath(node, s, adj);\\n            if (s.charAt(node) == s.charAt(currNode))\\n                continue;\\n            output = Math.max(output, distance[currNode] + distance[node]);\\n            distance[currNode] = Math.max(distance[currNode], distance[node] + 1);\\n        }\\n    }\\n\\n    int longestPath(int[] parent, String s) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\\n        for (int i = 0; i < parent.length; i++)\\n            adj.add(new ArrayList<Integer>());\\n        for (int i = 1; i < parent.length; i++)\\n            adj.get(parent[i]).add(i);\\n        longestPath(0, s, adj);\\n        return output;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044215,
                "title": "at-each-node-the-longest-possible-path-deepest-traversal-second-deepest-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nat each node, the longest path is formed by traversing from the deppest valid traversal (from that node) to the node and then to the second deepest valid traversal.\\n\\nA little optimization would be needed, if we start a new traversal at each node, the time complexity will be $$O(n^2)$$. So Here, we try to do that in a single DFT.\\n\\n![A.png](https://assets.leetcode.com/users/images/03bd2cf4-4e45-472e-bcdd-6f5788cd7082_1673595940.1588051.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Make the Adjacency List (here, I have changed the structure to an out tree rooted at $$0$$)\\n2. Perform DFT. The function `longetsPathAt(int n, List<List<Integer>> adj, String s)`\\n    - returns the deepest path from node n, such that the path has no 2 adjacent nodes assigned the same character. \\n    - Updates the global variable `res` as `res = Math.max(res, max1 + max2 - 1)`\\n    - Trverses nodes that violates the forth-mentioned conditions separately, for the longest path may go through them alike.\\n3. return `res`\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    int longetsPathAt(int n, List<List<Integer>> adj, String s)\\n    {\\n        int max1 = 1, max2 = 1;\\n        for(int child : adj.get(n))\\n        {\\n            if(s.charAt(child) != s.charAt(n))\\n            {\\n                int path = longetsPathAt(child, adj, s) + 1;\\n                if(path > max1)\\n                {\\n                    max2 = max1;\\n                    max1 = path;\\n                }\\n                else if(path > max2) max2 = path;\\n            }\\n            else longetsPathAt(child, adj, s);\\n        }\\n        res = Math.max(res, max1 + max2 - 1);\\n        return max1;\\n    }\\n    public int longestPath(int[] parent, String s) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < parent.length; i++) adj.add(new ArrayList<>());\\n        for(int i = 0 ; i < parent.length; i++) if(parent[i] != -1) adj.get(parent[i]).add(i);\\n        longetsPathAt(0, adj, s);\\n        return res;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    int longetsPathAt(int n, List<List<Integer>> adj, String s)\\n    {\\n        int max1 = 1, max2 = 1;\\n        for(int child : adj.get(n))\\n        {\\n            if(s.charAt(child) != s.charAt(n))\\n            {\\n                int path = longetsPathAt(child, adj, s) + 1;\\n                if(path > max1)\\n                {\\n                    max2 = max1;\\n                    max1 = path;\\n                }\\n                else if(path > max2) max2 = path;\\n            }\\n            else longetsPathAt(child, adj, s);\\n        }\\n        res = Math.max(res, max1 + max2 - 1);\\n        return max1;\\n    }\\n    public int longestPath(int[] parent, String s) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < parent.length; i++) adj.add(new ArrayList<>());\\n        for(int i = 0 ; i < parent.length; i++) if(parent[i] != -1) adj.get(parent[i]).add(i);\\n        longetsPathAt(0, adj, s);\\n        return res;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044173,
                "title": "java-2-solutions-topological-sort-dfs",
                "content": "2.DFS\\n```\\n    //2.DFS\\n    //Runtime: 88 ms 92%; Memory: 84.1MB 93%\\n    //Time: O(N); Space: O(N)\\n    public int longestPath(int[] parent, String s) {\\n        List<Integer>[] graph = new List[parent.length];\\n        for(int i = 0; i < parent.length; i++)\\n            graph[i] = new ArrayList<>();\\n\\n        for(int i = 1; i < parent.length; i++)\\n            graph[parent[i]].add(i);\\n\\n        helper_DFS(graph, 0, -1, s.toCharArray());\\n        return longestPath;\\n    }\\n    private int longestPath = 1;\\n    private int helper_DFS(List<Integer>[] graph, int node, int parent, char[] s){\\n        int currMax = 0;\\n        for (int neighbour : graph[node]) {\\n            if (neighbour == parent) continue;\\n\\n            int subChain = helper_DFS(graph, neighbour, node, s) + 1;\\n            if (s[node] == s[neighbour]) continue;\\n\\n            longestPath = Math.max(longestPath, 1 + currMax + subChain);\\n            currMax = Math.max(currMax, subChain);\\n            longestPath = Math.max(longestPath, currMax);\\n        }\\n        return currMax;\\n    }\\n```\\n\\n\\n1.topological sort\\n```\\n    //1.topological sort\\n    //Runtime: 35ms 98%; Memory: 54.6MB 99%\\n    //Time: O(N); Space: O(N)\\n    public int longestPath(int[] parent, String s) {\\n        int[] indegree = new int[parent.length];\\n        for (int i = 1; i < parent.length; i++)\\n            indegree[parent[i]]++;\\n\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; i < indegree.length ; i++) {\\n            if (indegree[i] != 0) continue;\\n            //leaf node\\n            queue.add(i);\\n        }\\n\\n        int res = 1;\\n        //node\\'s the longest chain in one sub-tree\\n        int [] counter = new int[parent.length];\\n\\n        while (!queue.isEmpty()){\\n            int i = queue.poll();\\n            int p = parent[i];\\n\\n            if (p != -1 && (--indegree[p]) == 0)\\n                queue.add(p);//leaf node\\n\\n            if (p == -1 || s.charAt(p) == s.charAt(i)) continue;\\n\\n            int currCount = 1 + counter[i];\\n            int pathLen = 1 + counter[p] + currCount;//path : include two chains\\n            res = Math.max(res, pathLen);\\n\\n            counter[p] = Math.max(counter[p], currCount);\\n            res = Math.max(res, counter[p]);\\n        }\\n        return res;\\n    }   \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n    //2.DFS\\n    //Runtime: 88 ms 92%; Memory: 84.1MB 93%\\n    //Time: O(N); Space: O(N)\\n    public int longestPath(int[] parent, String s) {\\n        List<Integer>[] graph = new List[parent.length];\\n        for(int i = 0; i < parent.length; i++)\\n            graph[i] = new ArrayList<>();\\n\\n        for(int i = 1; i < parent.length; i++)\\n            graph[parent[i]].add(i);\\n\\n        helper_DFS(graph, 0, -1, s.toCharArray());\\n        return longestPath;\\n    }\\n    private int longestPath = 1;\\n    private int helper_DFS(List<Integer>[] graph, int node, int parent, char[] s){\\n        int currMax = 0;\\n        for (int neighbour : graph[node]) {\\n            if (neighbour == parent) continue;\\n\\n            int subChain = helper_DFS(graph, neighbour, node, s) + 1;\\n            if (s[node] == s[neighbour]) continue;\\n\\n            longestPath = Math.max(longestPath, 1 + currMax + subChain);\\n            currMax = Math.max(currMax, subChain);\\n            longestPath = Math.max(longestPath, currMax);\\n        }\\n        return currMax;\\n    }\\n```\n```\\n    //1.topological sort\\n    //Runtime: 35ms 98%; Memory: 54.6MB 99%\\n    //Time: O(N); Space: O(N)\\n    public int longestPath(int[] parent, String s) {\\n        int[] indegree = new int[parent.length];\\n        for (int i = 1; i < parent.length; i++)\\n            indegree[parent[i]]++;\\n\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; i < indegree.length ; i++) {\\n            if (indegree[i] != 0) continue;\\n            //leaf node\\n            queue.add(i);\\n        }\\n\\n        int res = 1;\\n        //node\\'s the longest chain in one sub-tree\\n        int [] counter = new int[parent.length];\\n\\n        while (!queue.isEmpty()){\\n            int i = queue.poll();\\n            int p = parent[i];\\n\\n            if (p != -1 && (--indegree[p]) == 0)\\n                queue.add(p);//leaf node\\n\\n            if (p == -1 || s.charAt(p) == s.charAt(i)) continue;\\n\\n            int currCount = 1 + counter[i];\\n            int pathLen = 1 + counter[p] + currCount;//path : include two chains\\n            res = Math.max(res, pathLen);\\n\\n            counter[p] = Math.max(counter[p], currCount);\\n            res = Math.max(res, counter[p]);\\n        }\\n        return res;\\n    }   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043955,
                "title": "c-dfs-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS will be required to get the Max path but we need to figure out a way to check which path is the longest.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe longest path can be 1 of two types as can be seen in the provided examples:\\n1. A node along with path along one of its subtrees\\n    \\n![image.png](https://assets.leetcode.com/users/images/a927aa6e-1a9b-4264-a835-a4f0bff0b73f_1673591686.1253104.png)\\n\\n2. A node and path along two of its subtrees\\n    \\n![image.png](https://assets.leetcode.com/users/images/4148bf9c-2f9e-4e33-ab37-2b408fd49c58_1673591840.1773436.png)\\n\\nSo during DFS we can only consider path along two subtrees at max for a certain node. And the path that can be returned to the parent of a node should be the maxpath along one of the subtrees of the node.\\nTo achieve this we will maintain two path lengths maximum path & second maximum path for each call to the recursive dfs function. And the path lengths from subtrees will only be considered if the subtree root does not have the same label as parent.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxval;\\n    int dfs(vector<vector<int>>& tree, int node, string& s, int p) {\\n        int smaxpath = 0, maxpath = 0;\\n        for(int val : tree[node]) {\\n            //to avoid call to parent\\n            if(val != p) {\\n                //dfs call to a child node\\n                int clen = dfs(tree, val, s, node);\\n                //checking if parent - child labels are different\\n                if(s[node] != s[val]) {\\n                    //updating maximum path & second maximum path\\n                    if(clen > maxpath) {\\n                        smaxpath = maxpath;\\n                        maxpath = clen;\\n                    } else if(clen > smaxpath) {\\n                        smaxpath = clen;\\n                    }\\n                }\\n            }\\n        }\\n        //to consider the current node\\n        maxpath += 1;\\n        //updating the maximum path length so far\\n        maxval = max(maxval, maxpath + smaxpath);\\n        //returning only the maximum path from subtrees\\n        return maxpath;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        vector<vector<int>> tree(parent.size());\\n        //adjacency list for tree\\n        for(int i = 1; i < parent.size(); i++) {\\n            tree[i].push_back(parent[i]);\\n            tree[parent[i]].push_back(i);\\n        }\\n        maxval = 0;\\n        dfs(tree, 0, s, -1);\\n        return maxval;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxval;\\n    int dfs(vector<vector<int>>& tree, int node, string& s, int p) {\\n        int smaxpath = 0, maxpath = 0;\\n        for(int val : tree[node]) {\\n            //to avoid call to parent\\n            if(val != p) {\\n                //dfs call to a child node\\n                int clen = dfs(tree, val, s, node);\\n                //checking if parent - child labels are different\\n                if(s[node] != s[val]) {\\n                    //updating maximum path & second maximum path\\n                    if(clen > maxpath) {\\n                        smaxpath = maxpath;\\n                        maxpath = clen;\\n                    } else if(clen > smaxpath) {\\n                        smaxpath = clen;\\n                    }\\n                }\\n            }\\n        }\\n        //to consider the current node\\n        maxpath += 1;\\n        //updating the maximum path length so far\\n        maxval = max(maxval, maxpath + smaxpath);\\n        //returning only the maximum path from subtrees\\n        return maxpath;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        vector<vector<int>> tree(parent.size());\\n        //adjacency list for tree\\n        for(int i = 1; i < parent.size(); i++) {\\n            tree[i].push_back(parent[i]);\\n            tree[parent[i]].push_back(i);\\n        }\\n        maxval = 0;\\n        dfs(tree, 0, s, -1);\\n        return maxval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043767,
                "title": "approach-explained-briefly-clean-readable",
                "content": "# Approach\\nWhat does dfs function return? It returns longest chain of letters below it including itself such that no two adjacent are same letters. \\nStarting from root node, we call for dfs for every child, and if child and node are different then we exten the chain by one, and keep selecting maximum one.\\nWe do this for each and every node recursively.\\n\\nPriority queue is used to store two longest chain of below node, then combine them with node\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> adj;\\n    string s;\\n    int ans = 0;\\n    int dfs(int node, int parent = -1){\\n        int ret = 1;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(auto child : adj[node]){\\n            if(child == parent) continue;\\n            int res = dfs(child, node);\\n            if(s[child] != s[node]) {\\n                ret = max(ret, res + 1);\\n                pq.push(res);\\n                if(pq.size() > 2) pq.pop();\\n            }\\n            ans = max(ans, ret);\\n        }\\n        int temp = 0;\\n        while(!pq.empty()) temp += pq.top(), pq.pop();\\n        ans = max(ans, temp + 1);\\n        return ret;\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string S) {\\n        int n = parent.size();\\n        s = S;\\n        adj.resize(n);\\n        for(int i=0;i<n;i++){\\n            if(parent[i] == -1) continue;\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\n<img src=\"https://i.imgflip.com/5kej8w.jpg\" width=350 />\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> adj;\\n    string s;\\n    int ans = 0;\\n    int dfs(int node, int parent = -1){\\n        int ret = 1;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(auto child : adj[node]){\\n            if(child == parent) continue;\\n            int res = dfs(child, node);\\n            if(s[child] != s[node]) {\\n                ret = max(ret, res + 1);\\n                pq.push(res);\\n                if(pq.size() > 2) pq.pop();\\n            }\\n            ans = max(ans, ret);\\n        }\\n        int temp = 0;\\n        while(!pq.empty()) temp += pq.top(), pq.pop();\\n        ans = max(ans, temp + 1);\\n        return ret;\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string S) {\\n        int n = parent.size();\\n        s = S;\\n        adj.resize(n);\\n        for(int i=0;i<n;i++){\\n            if(parent[i] == -1) continue;\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043651,
                "title": "java-c-100-solution-using-depth-first-search-longest-path-with-different-adjacent-characters",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Java Code\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> children = new HashMap<>();\\n    int ans=1;\\n    public int genratePathDFS(int currNode, String str){\\n        if(!children.containsKey(currNode))\\n            return 1;\\n\\n        int maxPath1 = 0, maxPath2 = 0;\\n\\n        for(int nextNode : children.get(currNode)){\\n            int currPath = genratePathDFS(nextNode,str);\\n            ans = Math.max(ans,currPath);\\n\\n            if(str.charAt(currNode) == str.charAt(nextNode))\\n                continue;\\n\\n            if(currPath>maxPath1)\\n            {\\n                maxPath2 = maxPath1;\\n                maxPath1 = currPath;\\n            }\\n            else\\n                maxPath2 = Math.max(maxPath2,currPath);\\n        }\\n\\n        ans = Math.max(ans,maxPath1+maxPath2+1);\\n\\n        return maxPath1+1;\\n        \\n    }\\n    public int longestPath(int[] parent, String s) {        \\n        for(int i = 1; i < parent.length; i++){\\n            int j = parent[i];\\n            children.putIfAbsent(j, new LinkedList<>());\\n            children.get(j).add(i);\\n        }\\n        genratePathDFS(0,s);\\n        return ans;\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> children[100001];\\n    int ans=1;\\n    int genratePathDFS(int currNode, string& str){\\n        if(children[currNode].empty())\\n            return 1;\\n\\n        int maxPath1 = 0, maxPath2 = 0;\\n\\n        for(auto &nextNode : children[currNode]){\\n            int currPath = genratePathDFS(nextNode,str);\\n            ans = max(ans,currPath);\\n\\n            if(str[currNode] == str[nextNode])\\n                continue;\\n\\n            if(currPath>maxPath1)\\n            {\\n                maxPath2 = maxPath1;\\n                maxPath1 = currPath;\\n            }\\n            else\\n                maxPath2 = max(maxPath2,currPath);\\n        }\\n\\n        ans = max(ans,maxPath1+maxPath2+1);\\n\\n        return maxPath1+1;\\n        \\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        for(int i=1;i<n;i++)\\n            children[parent[i]].push_back(i);\\n        genratePathDFS(0,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> children = new HashMap<>();\\n    int ans=1;\\n    public int genratePathDFS(int currNode, String str){\\n        if(!children.containsKey(currNode))\\n            return 1;\\n\\n        int maxPath1 = 0, maxPath2 = 0;\\n\\n        for(int nextNode : children.get(currNode)){\\n            int currPath = genratePathDFS(nextNode,str);\\n            ans = Math.max(ans,currPath);\\n\\n            if(str.charAt(currNode) == str.charAt(nextNode))\\n                continue;\\n\\n            if(currPath>maxPath1)\\n            {\\n                maxPath2 = maxPath1;\\n                maxPath1 = currPath;\\n            }\\n            else\\n                maxPath2 = Math.max(maxPath2,currPath);\\n        }\\n\\n        ans = Math.max(ans,maxPath1+maxPath2+1);\\n\\n        return maxPath1+1;\\n        \\n    }\\n    public int longestPath(int[] parent, String s) {        \\n        for(int i = 1; i < parent.length; i++){\\n            int j = parent[i];\\n            children.putIfAbsent(j, new LinkedList<>());\\n            children.get(j).add(i);\\n        }\\n        genratePathDFS(0,s);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> children[100001];\\n    int ans=1;\\n    int genratePathDFS(int currNode, string& str){\\n        if(children[currNode].empty())\\n            return 1;\\n\\n        int maxPath1 = 0, maxPath2 = 0;\\n\\n        for(auto &nextNode : children[currNode]){\\n            int currPath = genratePathDFS(nextNode,str);\\n            ans = max(ans,currPath);\\n\\n            if(str[currNode] == str[nextNode])\\n                continue;\\n\\n            if(currPath>maxPath1)\\n            {\\n                maxPath2 = maxPath1;\\n                maxPath1 = currPath;\\n            }\\n            else\\n                maxPath2 = max(maxPath2,currPath);\\n        }\\n\\n        ans = max(ans,maxPath1+maxPath2+1);\\n\\n        return maxPath1+1;\\n        \\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        for(int i=1;i<n;i++)\\n            children[parent[i]].push_back(i);\\n        genratePathDFS(0,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043547,
                "title": "golang-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc longestPath(parent []int, s string) int {\\n    maxLength := 0\\n    n := len(parent)\\n\\n    children := make([][]int, n)\\n    for i, pi := range parent {\\n        if pi == -1 {\\n            continue\\n        }\\n        children[pi] = append(children[pi], i)\\n    }\\n\\n    dfs(0, children, s, &maxLength)\\n    return maxLength\\n}\\n\\nfunc dfs(curNode int, children [][]int, s string, maxLength *int) int {\\n    maxPath1, maxPath2 := 0, 0\\n    for _, child := range children[curNode] {\\n        l := dfs(child, children, s, maxLength)\\n        if s[curNode] != s[child] {\\n            if l >= maxPath1 {\\n                maxPath2 = maxPath1\\n                maxPath1 = l\\n            } else if l > maxPath2 {\\n                maxPath2 = l\\n            }\\n        }\\n    }\\n    *maxLength = max(*maxLength, maxPath1+maxPath2+1)\\n    return maxPath1+1\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestPath(parent []int, s string) int {\\n    maxLength := 0\\n    n := len(parent)\\n\\n    children := make([][]int, n)\\n    for i, pi := range parent {\\n        if pi == -1 {\\n            continue\\n        }\\n        children[pi] = append(children[pi], i)\\n    }\\n\\n    dfs(0, children, s, &maxLength)\\n    return maxLength\\n}\\n\\nfunc dfs(curNode int, children [][]int, s string, maxLength *int) int {\\n    maxPath1, maxPath2 := 0, 0\\n    for _, child := range children[curNode] {\\n        l := dfs(child, children, s, maxLength)\\n        if s[curNode] != s[child] {\\n            if l >= maxPath1 {\\n                maxPath2 = maxPath1\\n                maxPath1 = l\\n            } else if l > maxPath2 {\\n                maxPath2 = l\\n            }\\n        }\\n    }\\n    *maxLength = max(*maxLength, maxPath1+maxPath2+1)\\n    return maxPath1+1\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043507,
                "title": "c-graph-easy-and-shortest-code-new-approach-fast",
                "content": "# Approach\\nFirstly, instead of parent graph build child graph for easy traversal.\\nThen traverse the tree and for each node calculate the maximum path length in its subtree.\\nmaxStraightPath is the path in the branch of that node.\\nmaxTreePath is the path joing two straight path with the node.\\n\\nIf the child node that we are checking has same label as parent node i then straight path length for that branch for that node i will be 0.\\n\\nAfter we will store maxTreePath and return maxStraightPath for further computation.\\n\\n# Code\\n```\\nclass Solution {\\n    int maxLength = 1;\\n    int dfs(int i, vector<vector<int>> &child, string &s){\\n        int maxTreePath = 0, maxStraightPath = 0;\\n\\n        for(auto j : child[i]){\\n            int x = dfs(j, child, s);\\n            if(s[i] == s[j])\\n                x = 0;\\n\\n            maxTreePath = max(maxTreePath, maxStraightPath + x);\\n            maxStraightPath = max(maxStraightPath, x);\\n        }\\n\\n        maxLength = max(maxLength, maxTreePath + 1);\\n        return maxStraightPath + 1;\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> child(n);\\n\\n        for(int i = 1; i<n; i++)\\n            child[parent[i]].push_back(i);\\n        \\n        dfs(0, child, s);\\n        return maxLength;\\n    }\\n};\\n```\\n\\n---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int maxLength = 1;\\n    int dfs(int i, vector<vector<int>> &child, string &s){\\n        int maxTreePath = 0, maxStraightPath = 0;\\n\\n        for(auto j : child[i]){\\n            int x = dfs(j, child, s);\\n            if(s[i] == s[j])\\n                x = 0;\\n\\n            maxTreePath = max(maxTreePath, maxStraightPath + x);\\n            maxStraightPath = max(maxStraightPath, x);\\n        }\\n\\n        maxLength = max(maxLength, maxTreePath + 1);\\n        return maxStraightPath + 1;\\n    }\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> child(n);\\n\\n        for(int i = 1; i<n; i++)\\n            child[parent[i]].push_back(i);\\n        \\n        dfs(0, child, s);\\n        return maxLength;\\n    }\\n};\\n```\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043435,
                "title": "simple-dfs-solution-c",
                "content": "# Intuition\\nSimple dfs Algo\\n\\n# Approach\\n Similar to diameter of binary tree question\\n     just a little change here we have take top 2 maximaum path at each node\\n\\n# Complexity\\n- Time complexity: O(N + E*LOG(2)) \\n\\n- Space complexity:\\n O(N+2E) + O(N) + O(N) + O(2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i,vector<int>& vis,string& s,vector<int> adj[],vector<int>& parent,int& ans){\\n        vis[i]=1;\\n        int maxi=0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto it:adj[i]){\\n            if(!vis[it]){\\n                int p = dfs(it,vis,s,adj,parent,ans);\\n                pq.push(p);\\n                maxi = max(maxi,p);\\n                if(pq.size()>2){\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        int a=0,b=0;\\n        if(!pq.empty()){\\n           a=pq.top();\\n           pq.pop();\\n        }\\n        if(!pq.empty()){\\n           b=pq.top();\\n           pq.pop();\\n        }\\n        ans = max(ans,a+b+1);\\n        if(i!=0 && s[parent[i]]==s[i]){\\n            return 0;\\n        }\\n        return maxi+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        for(int i=1;i<n;i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        vector<int> vis(n,0);\\n        int ans=0;\\n        int k = dfs(0,vis,s,adj,parent,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,vector<int>& vis,string& s,vector<int> adj[],vector<int>& parent,int& ans){\\n        vis[i]=1;\\n        int maxi=0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto it:adj[i]){\\n            if(!vis[it]){\\n                int p = dfs(it,vis,s,adj,parent,ans);\\n                pq.push(p);\\n                maxi = max(maxi,p);\\n                if(pq.size()>2){\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        int a=0,b=0;\\n        if(!pq.empty()){\\n           a=pq.top();\\n           pq.pop();\\n        }\\n        if(!pq.empty()){\\n           b=pq.top();\\n           pq.pop();\\n        }\\n        ans = max(ans,a+b+1);\\n        if(i!=0 && s[parent[i]]==s[i]){\\n            return 0;\\n        }\\n        return maxi+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        for(int i=1;i<n;i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        vector<int> vis(n,0);\\n        int ans=0;\\n        int k = dfs(0,vis,s,adj,parent,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043249,
                "title": "c-beats-95-tc-o-n-sc-o-n-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe longest path of a node must be constructed by the node itself and two children node path.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse recursion to travel through the tree while updating the longest path as output;\\n# Complexity\\n- Time complexity: O(N)\\n    use recursion to travel through the tree exactly once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n    use a list to save children node of each parent.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![\\u87A2\\u5E55\\u64F7\\u53D6\\u756B\\u9762 2023-01-13 111354.png](https://assets.leetcode.com/users/images/8208b80e-0a79-488d-a35b-720d472eac0d_1673579648.8988152.png)\\n\\n# Code\\n```\\npublic class Solution {\\n    //output\\n    private int output = 0;\\n    //a list to save children for later traversal\\n    private List<List<int>> graph = new List<List<int>>();\\n    private string s;\\n\\n    public int LongestPath(int[] parent, string s) {\\n        //initialization\\n        this.s = s;\\n        for(int i = 0; i < parent.Length; i++) {\\n            graph.Add(new List<int>());\\n        }\\n        for(int i = 0; i < parent.Length; i++) {\\n            if(parent[i] == -1) continue;\\n            graph[parent[i]].Add(i);\\n        }\\n\\n        Traversal(0);\\n        return output;\\n    }\\n\\n    private int Traversal(int cur) {\\n        //a path can be constructed by two or less children path and the current node\\n        int largest = 0;\\n        int second = 0;\\n        //iterate through the children and find largest and second largest children path\\n        for(int i = 0; i < graph[cur].Count(); i++) {\\n            int path = Traversal(graph[cur][i]);\\n            if(s[graph[cur][i]] == s[cur]) continue;\\n\\n            if(path > largest) {\\n                second = largest;\\n                largest = path;\\n            }\\n            else if(path > second) {\\n                second = path;\\n            }\\n        }\\n        //update the longest path to output (+1 is for the current node)\\n        if(largest + second + 1 > output) {\\n            output = largest + second + 1;\\n        }\\n        \\n        //return the largest path + current node for last recusrion call\\n        return largest + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    //output\\n    private int output = 0;\\n    //a list to save children for later traversal\\n    private List<List<int>> graph = new List<List<int>>();\\n    private string s;\\n\\n    public int LongestPath(int[] parent, string s) {\\n        //initialization\\n        this.s = s;\\n        for(int i = 0; i < parent.Length; i++) {\\n            graph.Add(new List<int>());\\n        }\\n        for(int i = 0; i < parent.Length; i++) {\\n            if(parent[i] == -1) continue;\\n            graph[parent[i]].Add(i);\\n        }\\n\\n        Traversal(0);\\n        return output;\\n    }\\n\\n    private int Traversal(int cur) {\\n        //a path can be constructed by two or less children path and the current node\\n        int largest = 0;\\n        int second = 0;\\n        //iterate through the children and find largest and second largest children path\\n        for(int i = 0; i < graph[cur].Count(); i++) {\\n            int path = Traversal(graph[cur][i]);\\n            if(s[graph[cur][i]] == s[cur]) continue;\\n\\n            if(path > largest) {\\n                second = largest;\\n                largest = path;\\n            }\\n            else if(path > second) {\\n                second = path;\\n            }\\n        }\\n        //update the longest path to output (+1 is for the current node)\\n        if(largest + second + 1 > output) {\\n            output = largest + second + 1;\\n        }\\n        \\n        //return the largest path + current node for last recusrion call\\n        return largest + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043241,
                "title": "java-dfs-o-n-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVisit each node beginning the root using DFS. At each node compute the length of longest path with different adjacent characters for all its children. The longest path possible for the current subtree would be 1 + the lengths of the 2 longest paths amongst all its children that don\\'t have the same character value as the current node. Solve this for every node and keep track of the maximum value computed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Compute an adjacency list for all nodes using the `int[] parent` input.\\n2. Initiate a DFS traversal beginning with the root node.\\n3. The DFS recursive function should return to its caller the maximum length of a valid sequence that the parent can potentially append to.\\n4. This value is 1 for all leaf nodes.\\n5. For all other nodes this value is 1 + the maximum value amongst all its children.\\n6. The final answer for each subtree can be computed as 1 + 2 maximum values amongst all its children.\\n7. Keep track of the max value of the final answer for each subtree.\\n8. Once the traversal is complete, the answer should be available.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int maxLength = 0;\\n  int n;\\n  List<Integer>[] adj;\\n\\n  private int dfs(int node, char[] s) {\\n    int length = 1;\\n    int max1 = 0;\\n    int max2 = 0;\\n\\n    for (int child : adj[node]) {\\n      int l = dfs(child, s);\\n      \\n      if (s[child] != s[node]) {\\n        length = Math.max(length, l + 1);\\n\\n        if (l > max2) {\\n          if (l > max1) {\\n            max2 = max1;\\n            max1 = l;\\n          } else\\n            max2 = l;\\n        }\\n      }\\n    }\\n    maxLength = Math.max(maxLength, max1 + max2 + 1);\\n    return length;\\n  }\\n\\n  public int longestPath(int[] parent, String s) {\\n    n = parent.length;\\n    adj = new ArrayList[n];\\n\\n    for (int i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (int i=1; i<n; i++)\\n      adj[parent[i]].add(i);\\n\\n    dfs(0, s.toCharArray());\\n    return maxLength;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  int maxLength = 0;\\n  int n;\\n  List<Integer>[] adj;\\n\\n  private int dfs(int node, char[] s) {\\n    int length = 1;\\n    int max1 = 0;\\n    int max2 = 0;\\n\\n    for (int child : adj[node]) {\\n      int l = dfs(child, s);\\n      \\n      if (s[child] != s[node]) {\\n        length = Math.max(length, l + 1);\\n\\n        if (l > max2) {\\n          if (l > max1) {\\n            max2 = max1;\\n            max1 = l;\\n          } else\\n            max2 = l;\\n        }\\n      }\\n    }\\n    maxLength = Math.max(maxLength, max1 + max2 + 1);\\n    return length;\\n  }\\n\\n  public int longestPath(int[] parent, String s) {\\n    n = parent.length;\\n    adj = new ArrayList[n];\\n\\n    for (int i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (int i=1; i<n; i++)\\n      adj[parent[i]].add(i);\\n\\n    dfs(0, s.toCharArray());\\n    return maxLength;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043230,
                "title": "c-beats-97-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans =INT_MIN;\\n    int solve(vector<vector<int>>&adj,int start, int parent, string &s)\\n    {\\n        int mx1=0, mx2=0, temp; // mx1 and mx2 would store two \\n        //largest path from the current node ( if exist)\\n        for(auto x:adj[start])\\n        {\\n            temp= solve(adj, x, start, s);\\n            if(temp!=-1) // if them isn\\'t -1 then we found a path\\n            // from the current node where we can go down\\n            {\\n                if(temp>=mx1) //update mx1 and mx2\\n                {\\n                   mx2=mx1;\\n                   mx1=temp;\\n                }\\n                else if(temp<mx1 && temp>mx2)\\n                {\\n                   mx2=temp;\\n                }\\n            }\\n        }\\n        ans=max(ans, mx1+mx2+1); //update ans as mx1+mx2+1 ( 1 for \\n                                   //current node)\\n        if(parent==-1)\\n        return mx1+1;\\n        if(s[start]==s[parent]) // if(child has the same character\\n    // as parent return -1 because parent cannot proceed in this direction)\\n        return -1;\\n        else\\n        return mx1+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=1;i<n;i++) // create adjacency list \\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n        solve(adj, 0 ,-1,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans =INT_MIN;\\n    int solve(vector<vector<int>>&adj,int start, int parent, string &s)\\n    {\\n        int mx1=0, mx2=0, temp; // mx1 and mx2 would store two \\n        //largest path from the current node ( if exist)\\n        for(auto x:adj[start])\\n        {\\n            temp= solve(adj, x, start, s);\\n            if(temp!=-1) // if them isn\\'t -1 then we found a path\\n            // from the current node where we can go down\\n            {\\n                if(temp>=mx1) //update mx1 and mx2\\n                {\\n                   mx2=mx1;\\n                   mx1=temp;\\n                }\\n                else if(temp<mx1 && temp>mx2)\\n                {\\n                   mx2=temp;\\n                }\\n            }\\n        }\\n        ans=max(ans, mx1+mx2+1); //update ans as mx1+mx2+1 ( 1 for \\n                                   //current node)\\n        if(parent==-1)\\n        return mx1+1;\\n        if(s[start]==s[parent]) // if(child has the same character\\n    // as parent return -1 because parent cannot proceed in this direction)\\n        return -1;\\n        else\\n        return mx1+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=1;i<n;i++) // create adjacency list \\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n        solve(adj, 0 ,-1,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043142,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        def dfs(node):\\n            node_char = s[node]            \\n            longest = second_longest = 0\\n            for child in children[node]:\\n                child_path = dfs(child)\\n                if s[child] != node_char:                    \\n                    if child_path >= longest:\\n                        second_longest = longest\\n                        longest = child_path \\n                    elif child_path > second_longest:\\n                        second_longest = child_path\\n                        \\n            self.result = max(self.result, 1 + longest + second_longest)        \\n            return 1 + longest\\n        \\n        children = defaultdict(list)\\n        for n in range(1, len(parent)):\\n            children[parent[n]].append(n)\\n            \\n        self.result = 0\\n        dfs(0)\\n        \\n        return self.result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        def dfs(node):\\n            node_char = s[node]            \\n            longest = second_longest = 0\\n            for child in children[node]:\\n                child_path = dfs(child)\\n                if s[child] != node_char:                    \\n                    if child_path >= longest:\\n                        second_longest = longest\\n                        longest = child_path \\n                    elif child_path > second_longest:\\n                        second_longest = child_path\\n                        \\n            self.result = max(self.result, 1 + longest + second_longest)        \\n            return 1 + longest\\n        \\n        children = defaultdict(list)\\n        for n in range(1, len(parent)):\\n            children[parent[n]].append(n)\\n            \\n        self.result = 0\\n        dfs(0)\\n        \\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043120,
                "title": "explained-java-in-out-dp-solution",
                "content": "We solve this using two arrays \"in\" and \"out\" array.\\n1. The \"in\" array stores the longest path **starting** at a given node where all nodes have different adjacent labels.\\n2. The \"out\" array stores the longest path **ending** at a given node where all nodes have different adjacent labels.\\n\\nThe \"in\" is used to count the path below the current node considering the current node as well whereas the  \"out\" array calculates the upper path from the current node.\\nThe \"out\" array is calculated using the approach that the lower node can go either in the direction ***( child -> parent -> parent of parent )*** or ***( child -> parent -> other child with the max length)*** . Hence if the current node chain has the max length then consider the second max chain.\\n```\\nclass Solution {\\n    //canVisit[i] contains the nodes that can be visited from node i\\n    private List<Integer>[] canVisit;\\n    //in[i] stores the longest path starting at node i where all nodes have different labels\\n    private int[] in;\\n    //out[i] stores the longest path ending at node i where all nodes have different labels\\n    private int[] out;\\n    //labels[i] is the label of node i\\n    private char[] labels;\\n    \\n    public int longestPath(int[] parent, String s) \\n    {\\n        int n = parent.length;\\n        \\n        //initialize canVisit\\n        canVisit = new ArrayList[n];\\n        for(int i=0; i<n; i++)\\n            canVisit[i] = new ArrayList<>();\\n        \\n        //populate canVisit\\n        for(int i=1; i<n; i++)\\n        {\\n            canVisit[parent[i]].add(i); //adding child nodes to the parent\\'s ArrayList\\n        }\\n        \\n        //initialize in, out and labels\\n        in = new int[n];\\n        out = new int[n];\\n        labels = s.toCharArray();\\n        \\n        //populate in array\\n        inside(0);\\n        \\n        //populate out array\\n        outside(0);\\n        \\n        //find the maximum length path\\n        int max = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            max = Math.max(max, in[i]+out[i]);\\n        }\\n        return max;\\n        \\n    }\\n    //helper function to populate in array\\n    void inside(int node)\\n    {\\n        in[node] = 1; //length of path starting from a node is at least 1\\n        for(int i : canVisit[node])\\n        { \\n            inside(i);\\n            //if the child node has a different label than the current node, update the max length of path\\n            if(labels[i] != labels[node]) in[node] = Math.max(in[node],in[i]+1);\\n        }\\n    }\\n    \\n    //helper function to populate out array\\n    void outside(int node)\\n    {\\n        //mx stores the longest path from the children of the current node\\n        //mx2 stores the second longest path from the children of the current node\\n        int mx=0, mx2=0;\\n        //find the two longest path from the children of the current node\\n        for(int child: canVisit[node])\\n        {\\n            //if the child has the same label as current node, skip it\\n            if(labels[child] == labels[node]) continue; \\n    \\n            //update mx and mx2\\n            if( in[child]+1 >= mx) \\n            {\\n                mx2 = mx ; \\n                mx = in[child] + 1;\\n            }\\n            else if( in[child]+1 >= mx2) \\n            {\\n                mx2 = in[child]+1;\\n            }\\n        }\\n        //update out array for each child\\n        for(int child : canVisit[node])\\n        {\\n            //if the child has a different label than the current node\\n            if(labels[child] != labels[node])\\n            {\\n                out[child] = out[node] + 1;\\n                //if the current child is not the one with the longest path\\n                if(mx != in[child] + 1) \\n                    out[child] = Math.max(mx, out[child]);\\n                else \\n                    out[child] = Math.max(out[child], mx2);\\n            }\\n            //recursively call outside function for each child\\n            outside(child);\\n        }\\n    }\\n}\\n```\\n#### Code without comments\\n```\\nclass Solution {\\n    private List<Integer>[] canVisit;\\n    private int[] in, out;\\n    private char[] labels;\\n    public int longestPath(int[] parent, String s) \\n    {\\n        int n = parent.length;\\n        canVisit = new ArrayList[n];\\n        for(int i=0; i<n; i++)\\n            canVisit[i] = new ArrayList<>();\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            // canVisit[i].add(parent[i]);\\n            canVisit[parent[i]].add(i);\\n        }\\n        // System.out.println(Arrays.toString(canVisit));\\n        \\n        in = new int[n];\\n        out = new int[n];\\n        labels = s.toCharArray();\\n        inside(0);\\n        outside(0);\\n        // System.out.println(Arrays.toString(in));\\n        // System.out.println(Arrays.toString(out));\\n        int max = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            max = Math.max(max, in[i]+out[i]);\\n        }\\n        return max;\\n        \\n    }\\n    void inside(int node)\\n    {\\n        in[node] = 1;\\n        for(int i : canVisit[node])\\n        { \\n            inside(i);\\n            if(labels[i] != labels[node]) in[node] = Math.max(in[node],in[i]+1);\\n        }\\n    }\\n    \\n    void outside(int node)\\n    {\\n        int mx=0, mx2=0;\\n        for(int child: canVisit[node])\\n        {\\n            if(labels[child] == labels[node]) continue;\\n        \\n            if( in[child]+1 >= mx) \\n            {\\n                mx2 = mx ; \\n                mx = in[child] + 1;\\n            }\\n            else if( in[child]+1 >= mx2) \\n            {\\n                mx2 = in[child]+1;\\n            }\\n        }\\n        for(int child : canVisit[node])\\n        {\\n            if(labels[child] != labels[node])\\n            {\\n                out[child] = out[node] + 1;\\n                if(mx != in[child] + 1) \\n                    out[child] = Math.max(mx, out[child]);\\n                else \\n                    out[child] = Math.max(out[child], mx2);\\n            }\\n            outside(child);\\n        }\\n    }\\n}\\n```\\n\\nI solved this using help from https://www.youtube.com/watch?v=7YzYnNX-Rr0&ab_channel=NeetCode please refer this if you need any help.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //canVisit[i] contains the nodes that can be visited from node i\\n    private List<Integer>[] canVisit;\\n    //in[i] stores the longest path starting at node i where all nodes have different labels\\n    private int[] in;\\n    //out[i] stores the longest path ending at node i where all nodes have different labels\\n    private int[] out;\\n    //labels[i] is the label of node i\\n    private char[] labels;\\n    \\n    public int longestPath(int[] parent, String s) \\n    {\\n        int n = parent.length;\\n        \\n        //initialize canVisit\\n        canVisit = new ArrayList[n];\\n        for(int i=0; i<n; i++)\\n            canVisit[i] = new ArrayList<>();\\n        \\n        //populate canVisit\\n        for(int i=1; i<n; i++)\\n        {\\n            canVisit[parent[i]].add(i); //adding child nodes to the parent\\'s ArrayList\\n        }\\n        \\n        //initialize in, out and labels\\n        in = new int[n];\\n        out = new int[n];\\n        labels = s.toCharArray();\\n        \\n        //populate in array\\n        inside(0);\\n        \\n        //populate out array\\n        outside(0);\\n        \\n        //find the maximum length path\\n        int max = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            max = Math.max(max, in[i]+out[i]);\\n        }\\n        return max;\\n        \\n    }\\n    //helper function to populate in array\\n    void inside(int node)\\n    {\\n        in[node] = 1; //length of path starting from a node is at least 1\\n        for(int i : canVisit[node])\\n        { \\n            inside(i);\\n            //if the child node has a different label than the current node, update the max length of path\\n            if(labels[i] != labels[node]) in[node] = Math.max(in[node],in[i]+1);\\n        }\\n    }\\n    \\n    //helper function to populate out array\\n    void outside(int node)\\n    {\\n        //mx stores the longest path from the children of the current node\\n        //mx2 stores the second longest path from the children of the current node\\n        int mx=0, mx2=0;\\n        //find the two longest path from the children of the current node\\n        for(int child: canVisit[node])\\n        {\\n            //if the child has the same label as current node, skip it\\n            if(labels[child] == labels[node]) continue; \\n    \\n            //update mx and mx2\\n            if( in[child]+1 >= mx) \\n            {\\n                mx2 = mx ; \\n                mx = in[child] + 1;\\n            }\\n            else if( in[child]+1 >= mx2) \\n            {\\n                mx2 = in[child]+1;\\n            }\\n        }\\n        //update out array for each child\\n        for(int child : canVisit[node])\\n        {\\n            //if the child has a different label than the current node\\n            if(labels[child] != labels[node])\\n            {\\n                out[child] = out[node] + 1;\\n                //if the current child is not the one with the longest path\\n                if(mx != in[child] + 1) \\n                    out[child] = Math.max(mx, out[child]);\\n                else \\n                    out[child] = Math.max(out[child], mx2);\\n            }\\n            //recursively call outside function for each child\\n            outside(child);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private List<Integer>[] canVisit;\\n    private int[] in, out;\\n    private char[] labels;\\n    public int longestPath(int[] parent, String s) \\n    {\\n        int n = parent.length;\\n        canVisit = new ArrayList[n];\\n        for(int i=0; i<n; i++)\\n            canVisit[i] = new ArrayList<>();\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            // canVisit[i].add(parent[i]);\\n            canVisit[parent[i]].add(i);\\n        }\\n        // System.out.println(Arrays.toString(canVisit));\\n        \\n        in = new int[n];\\n        out = new int[n];\\n        labels = s.toCharArray();\\n        inside(0);\\n        outside(0);\\n        // System.out.println(Arrays.toString(in));\\n        // System.out.println(Arrays.toString(out));\\n        int max = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            max = Math.max(max, in[i]+out[i]);\\n        }\\n        return max;\\n        \\n    }\\n    void inside(int node)\\n    {\\n        in[node] = 1;\\n        for(int i : canVisit[node])\\n        { \\n            inside(i);\\n            if(labels[i] != labels[node]) in[node] = Math.max(in[node],in[i]+1);\\n        }\\n    }\\n    \\n    void outside(int node)\\n    {\\n        int mx=0, mx2=0;\\n        for(int child: canVisit[node])\\n        {\\n            if(labels[child] == labels[node]) continue;\\n        \\n            if( in[child]+1 >= mx) \\n            {\\n                mx2 = mx ; \\n                mx = in[child] + 1;\\n            }\\n            else if( in[child]+1 >= mx2) \\n            {\\n                mx2 = in[child]+1;\\n            }\\n        }\\n        for(int child : canVisit[node])\\n        {\\n            if(labels[child] != labels[node])\\n            {\\n                out[child] = out[node] + 1;\\n                if(mx != in[child] + 1) \\n                    out[child] = Math.max(mx, out[child]);\\n                else \\n                    out[child] = Math.max(out[child], mx2);\\n            }\\n            outside(child);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043061,
                "title": "easy-solution-explained-c-java-python-rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy solution uses a depth-first search (dfs) to traverse the tree, keeping track of the maximum path length found so far in the variable \"ans\" and the current maximum path length in the variable \"max\". The dfs function also takes in an additional parameter \"parent\" to keep track of the parent node in order to avoid visiting the same node multiple times. The newArray function in the java code is used to create an array of ArrayList to store the subtrees for each node, and it is used to store all the children of each node in the tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe `longestPath` method starts by initializing a variable `n` to the length of the parent array and creating an adjacency list called `subtrees`. In the java code, I dedicated the `newArray` method to the creation of this list.\\n\\nThen it iterates through the parent array starting from the second element (the first element is the root of the tree and it does not have any parent) and for each i-th element, it adds i as a child to the subtrees of the parent[i] element.\\n\\nThen the method calls the dfs function passing the root of the tree (0), -1 as the parent (since the root does not have any parent), the subtrees array, and the s string as the parameters.\\n\\nThe dfs function takes four parameters: the current node, its parent, the subtrees array, and the string s. \\n\\n1. It starts by initializing a variable `max` to 0. It then iterates through all the children of the current node in the subtrees array. For each child, it checks if the child is the parent and if it is, it continues to the next child. Otherwise, it calls the dfs function recursively passing the child as the current node, the current node as the parent, the subtrees array, and the string s as the parameters. This recursive call returns the maximum path length of the child.\\n\\n2. The `ans` variable is updated to the maximum of itself and `max + part + 1` indicating that it is valid to have a path `from a child node to parent to another child node`, `max` is updated to be the largest path from all its children.\\n\\n3. Finally, `max` is incremented by 1 and if it becomes greater than `ans`, `ans` is updated to be equal to `max`.\\n\\n4. Finally, if the parent is not -1 and the character at the parent index of string `s` is the same as that of node, it returns 0 indicating that the path is not valid otherwise it returns `max+1`.\\n\\nThe longestPath method returns `ans` as the final answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    int ans = 0;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        List<Integer>[] subtrees = newArray(n);\\n\\n        for(int i = 1; i < n; i++) {\\n            subtrees[parent[i]].add(i);\\n        }\\n\\n        dfs(0, -1, subtrees, s);\\n\\n        return ans;\\n    }\\n\\n    private int dfs(int node, int parent, List<Integer>[] subtrees, String s) {\\n        int max = 0;\\n\\n        for(int child: subtrees[node]) {\\n            if (child == parent) continue;\\n            int part = dfs(child, node, subtrees, s);\\n            ans = Math.max(ans, part + max + 1);\\n            max = Math.max(max, part);\\n        }\\n\\n        max += 1;\\n\\n        if (max > ans) {\\n            ans = max;\\n        }\\n\\n        if (parent != -1 && s.charAt(parent) == s.charAt(node)) {\\n            return 0;\\n        }\\n\\n        return max;\\n    }\\n\\n    private List<Integer>[] newArray(int n) {\\n        ArrayList<Integer>[] ans = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = new ArrayList<>();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def __init__(self):\\n        self.ans = 0\\n        \\n    def longestPath(self, parent, s):\\n        n = len(parent)\\n        subtrees = [[] for _ in range(n)]\\n        \\n        for i in range(1, n):\\n            subtrees[parent[i]].append(i)\\n        \\n        self.dfs(0, -1, subtrees, s)\\n        \\n        return self.ans\\n\\n    def dfs(self, node, parent, subtrees, s):\\n        max_val = 0\\n        \\n        for child in subtrees[node]:\\n            if child == parent:\\n                continue\\n            part = self.dfs(child, node, subtrees, s)\\n            self.ans = max(self.ans, part + max_val + 1)\\n            max_val = max(max_val, part)\\n        \\n        max_val += 1\\n        \\n        if max_val > self.ans:\\n            self.ans = max_val\\n        \\n        if parent != -1 and s[parent] == s[node]:\\n            return 0\\n        \\n        return max_val\\n\\n```\\n\\n```C++ []\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    int ans = 0;\\npublic:\\n    int longestPath(vector<int> parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> subtrees(n);\\n\\n        for(int i = 1; i < n; i++) {\\n            subtrees[parent[i]].push_back(i);\\n        }\\n\\n        dfs(0, -1, subtrees, s);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    int dfs(int node, int parent, vector<vector<int>>& subtrees, string& s) {\\n        int max = 0;\\n\\n        for(int child : subtrees[node]) {\\n            if (child == parent) continue;\\n            int part = dfs(child, node, subtrees, s);\\n            ans = std::max(ans, part + max + 1);\\n            max = std::max(max, part);\\n        }\\n\\n        max += 1;\\n\\n        if (max > ans) {\\n            ans = max;\\n        }\\n\\n        if (parent != -1 && s[parent] == s[node]) {\\n            return 0;\\n        }\\n\\n        return max;\\n    }\\n};\\n\\n```\\n\\n\\n```rust []\\nimpl Solution {\\n    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {\\n        let n = parent.len() as usize;\\n\\n        let mut subtree = vec![Vec::new(); n];\\n        let s = s.into_bytes();\\n        let mut ans = 0;\\n\\n        for i in 1..n {\\n            subtree[parent[i] as usize].push(i);\\n        }\\n\\n        Self::dfs(0, 100000, &subtree, &s, &mut ans);\\n\\n        ans\\n    }\\n\\n    fn dfs(node: usize, parent: usize, subtree: &Vec<Vec<usize>>, s: &Vec<u8>, ans: &mut i32) -> i32 {\\n        let mut max = 0;\\n        for child in subtree[node].iter() {\\n            if child == &parent {\\n                continue;\\n            }\\n            let part = Self::dfs(*child, node, subtree, s, ans);\\n            *ans = i32::max(*ans, part + max + 1);\\n\\n            max = max.max(part);\\n        }\\n\\n        max += 1;\\n\\n        if max > *ans {\\n            *ans = max;\\n        }\\n\\n        if parent != 100000 && s[parent] == s[node] {\\n            return 0\\n        }\\n\\n        max\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    int ans = 0;\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        List<Integer>[] subtrees = newArray(n);\\n\\n        for(int i = 1; i < n; i++) {\\n            subtrees[parent[i]].add(i);\\n        }\\n\\n        dfs(0, -1, subtrees, s);\\n\\n        return ans;\\n    }\\n\\n    private int dfs(int node, int parent, List<Integer>[] subtrees, String s) {\\n        int max = 0;\\n\\n        for(int child: subtrees[node]) {\\n            if (child == parent) continue;\\n            int part = dfs(child, node, subtrees, s);\\n            ans = Math.max(ans, part + max + 1);\\n            max = Math.max(max, part);\\n        }\\n\\n        max += 1;\\n\\n        if (max > ans) {\\n            ans = max;\\n        }\\n\\n        if (parent != -1 && s.charAt(parent) == s.charAt(node)) {\\n            return 0;\\n        }\\n\\n        return max;\\n    }\\n\\n    private List<Integer>[] newArray(int n) {\\n        ArrayList<Integer>[] ans = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = new ArrayList<>();\\n        }\\n        return ans;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def __init__(self):\\n        self.ans = 0\\n        \\n    def longestPath(self, parent, s):\\n        n = len(parent)\\n        subtrees = [[] for _ in range(n)]\\n        \\n        for i in range(1, n):\\n            subtrees[parent[i]].append(i)\\n        \\n        self.dfs(0, -1, subtrees, s)\\n        \\n        return self.ans\\n\\n    def dfs(self, node, parent, subtrees, s):\\n        max_val = 0\\n        \\n        for child in subtrees[node]:\\n            if child == parent:\\n                continue\\n            part = self.dfs(child, node, subtrees, s)\\n            self.ans = max(self.ans, part + max_val + 1)\\n            max_val = max(max_val, part)\\n        \\n        max_val += 1\\n        \\n        if max_val > self.ans:\\n            self.ans = max_val\\n        \\n        if parent != -1 and s[parent] == s[node]:\\n            return 0\\n        \\n        return max_val\\n\\n```\n```C++ []\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    int ans = 0;\\npublic:\\n    int longestPath(vector<int> parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> subtrees(n);\\n\\n        for(int i = 1; i < n; i++) {\\n            subtrees[parent[i]].push_back(i);\\n        }\\n\\n        dfs(0, -1, subtrees, s);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    int dfs(int node, int parent, vector<vector<int>>& subtrees, string& s) {\\n        int max = 0;\\n\\n        for(int child : subtrees[node]) {\\n            if (child == parent) continue;\\n            int part = dfs(child, node, subtrees, s);\\n            ans = std::max(ans, part + max + 1);\\n            max = std::max(max, part);\\n        }\\n\\n        max += 1;\\n\\n        if (max > ans) {\\n            ans = max;\\n        }\\n\\n        if (parent != -1 && s[parent] == s[node]) {\\n            return 0;\\n        }\\n\\n        return max;\\n    }\\n};\\n\\n```\n```rust []\\nimpl Solution {\\n    pub fn longest_path(parent: Vec<i32>, s: String) -> i32 {\\n        let n = parent.len() as usize;\\n\\n        let mut subtree = vec![Vec::new(); n];\\n        let s = s.into_bytes();\\n        let mut ans = 0;\\n\\n        for i in 1..n {\\n            subtree[parent[i] as usize].push(i);\\n        }\\n\\n        Self::dfs(0, 100000, &subtree, &s, &mut ans);\\n\\n        ans\\n    }\\n\\n    fn dfs(node: usize, parent: usize, subtree: &Vec<Vec<usize>>, s: &Vec<u8>, ans: &mut i32) -> i32 {\\n        let mut max = 0;\\n        for child in subtree[node].iter() {\\n            if child == &parent {\\n                continue;\\n            }\\n            let part = Self::dfs(*child, node, subtree, s, ans);\\n            *ans = i32::max(*ans, part + max + 1);\\n\\n            max = max.max(part);\\n        }\\n\\n        max += 1;\\n\\n        if max > *ans {\\n            *ans = max;\\n        }\\n\\n        if parent != 100000 && s[parent] == s[node] {\\n            return 0\\n        }\\n\\n        max\\n    }\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955298,
                "title": "traverse-ancestors",
                "content": "Step1: Traverse from leaf to root and store the longest path at each node.\\nStep2: For a node i visit its children and if the longest path you achieved at i is through the particular child then don\\'t consider that child. \\nNote: longest path you acheive must come from only one child. so if the parent has only one children continue.\\nStep3: If parent and child characters are not same we can consider the parent+child path.\\n```\\nclass Solution {\\n    public int longestPath(int[] parent, String s) {\\n        int max=1;\\n        int dp[]=new int[parent.length];\\n        Map<Integer,List<Integer>> map=new HashMap<>();\\n        boolean visited[]=new boolean[parent.length];\\n        for(int i=parent.length-1;i>=0;i--){\\n            if(i!=0){\\n            int par=parent[i];\\n            map.putIfAbsent(par,new ArrayList<>());\\n            map.get(par).add(i);\\n            }\\n            if(visited[i]==true) continue;\\n            visited[i]=true;\\n            char prev=s.charAt(i);\\n            int path=1;\\n            dp[i]=Math.max(dp[i],path);\\n            int curr=parent[i];\\n            while(curr!=-1 && prev!=s.charAt(curr)){\\n                visited[curr]=true;\\n                prev=s.charAt(curr);\\n                path++;\\n                dp[curr]=Math.max(dp[curr],path);\\n                curr=parent[curr];\\n                \\n                max=Math.max(max,path);\\n                \\n            }\\n            max=Math.max(max,path);\\n            \\n        }\\n        \\n        for(int par: map.keySet()){\\n            List<Integer> children=map.get(par);\\n            if(children.size()==1) continue;\\n            boolean flag=true;\\n            for(int e: children){\\n                if(dp[e]+1==dp[par] && flag==true && s.charAt(e)!=s.charAt(par)){\\n                    flag=false;\\n                }\\n                else{\\n                    if(s.charAt(e)!=s.charAt(par)){    \\n                        max=Math.max(max,dp[e]+dp[par]);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPath(int[] parent, String s) {\\n        int max=1;\\n        int dp[]=new int[parent.length];\\n        Map<Integer,List<Integer>> map=new HashMap<>();\\n        boolean visited[]=new boolean[parent.length];\\n        for(int i=parent.length-1;i>=0;i--){\\n            if(i!=0){\\n            int par=parent[i];\\n            map.putIfAbsent(par,new ArrayList<>());\\n            map.get(par).add(i);\\n            }\\n            if(visited[i]==true) continue;\\n            visited[i]=true;\\n            char prev=s.charAt(i);\\n            int path=1;\\n            dp[i]=Math.max(dp[i],path);\\n            int curr=parent[i];\\n            while(curr!=-1 && prev!=s.charAt(curr)){\\n                visited[curr]=true;\\n                prev=s.charAt(curr);\\n                path++;\\n                dp[curr]=Math.max(dp[curr],path);\\n                curr=parent[curr];\\n                \\n                max=Math.max(max,path);\\n                \\n            }\\n            max=Math.max(max,path);\\n            \\n        }\\n        \\n        for(int par: map.keySet()){\\n            List<Integer> children=map.get(par);\\n            if(children.size()==1) continue;\\n            boolean flag=true;\\n            for(int e: children){\\n                if(dp[e]+1==dp[par] && flag==true && s.charAt(e)!=s.charAt(par)){\\n                    flag=false;\\n                }\\n                else{\\n                    if(s.charAt(e)!=s.charAt(par)){    \\n                        max=Math.max(max,dp[e]+dp[par]);\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005247,
                "title": "100-faster-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i,vector<vector<int>> &adj, int &mx, string &s){\\n        if(adj[i].size()==0){\\n            return 1;\\n        }\\n        int a=0,b;\\n        for(auto it: adj[i]){\\n            if(s[i]!=s[it]){\\n                b = find(it,adj,mx,s);\\n                mx = max(mx,1+b+a);\\n                a = max(a,b);\\n            }\\n            else{\\n                find(it,adj,mx,s);\\n            }\\n        }\\n        return a+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++){\\n            if(parent[i]!=-1) adj[parent[i]].push_back(i);\\n        }\\n        if(s.size()==1) return 1;\\n        int mx = 1;\\n        find(0,adj,mx,s);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i,vector<vector<int>> &adj, int &mx, string &s){\\n        if(adj[i].size()==0){\\n            return 1;\\n        }\\n        int a=0,b;\\n        for(auto it: adj[i]){\\n            if(s[i]!=s[it]){\\n                b = find(it,adj,mx,s);\\n                mx = max(mx,1+b+a);\\n                a = max(a,b);\\n            }\\n            else{\\n                find(it,adj,mx,s);\\n            }\\n        }\\n        return a+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++){\\n            if(parent[i]!=-1) adj[parent[i]].push_back(i);\\n        }\\n        if(s.size()==1) return 1;\\n        int mx = 1;\\n        find(0,adj,mx,s);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992282,
                "title": "c-in-out-tree-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(3*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(size of Adjacency List + 3*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    vector<int> indp,outdp;\\n    vector<vector<int>> adj;\\n    vector<pair<int,int>> maxVal;\\n\\n    int n;\\n    void dfs1(int node,int par,string &s){\\n         \\n         indp[node]=0;\\n         int mx =0;\\n         priority_queue<int,vector<int>,greater<int>> pq;\\n         pq.push(0);\\n         pq.push(0);\\n         for(auto ch:adj[node]){\\n             if(ch == par) continue;\\n             dfs1(ch,node,s);\\n             if(s[node] != s[ch]){\\n                 mx=max(mx,indp[ch]);\\n                 pq.push(indp[ch]);\\n                 if(pq.size() > 2) pq.pop();\\n             }\\n         }\\n\\n         int max2 = pq.top();\\n         pq.pop();\\n         int max1 = pq.top();\\n         maxVal[node] = {max1,max2};\\n         \\n         indp[node] = mx+1;\\n    }\\n\\n    void dfs2(int node,int par,string &s){\\n          \\n          if(par == -1 ) outdp[node] = 1;\\n          else{\\n              if(s[node] == s[par]) outdp[node] = 1;\\n              else{\\n                  if(outdp[par]>indp[par]) outdp[node] = outdp[par]+1;\\n                  else{\\n                      pair<int,int> mxv = maxVal[par];\\n                      if(mxv.F > indp[node])  outdp[node] = indp[par]+1;\\n                      else{\\n                          outdp[node] =  max(outdp[par] + 1, mxv.S == 0 ? 0: mxv.S + 2);\\n                      }\\n                  }\\n              }\\n          }\\n          for(auto ch : adj[node]){\\n              if(ch == par) continue;\\n              dfs2(ch,node,s);\\n          }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        n=s.size();\\n        indp.resize(n);\\n        outdp.resize(n);\\n        adj.resize(n);\\n        maxVal.resize(n);\\n\\n        for(int i=1;i<parent.size();i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n\\n        dfs1(0,-1,s);\\n        dfs2(0,-1,s);\\n        int ans=0;\\n\\n\\n        for(int i=0;i<n;i++) ans = max(ans,indp[i] + outdp[i]-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    vector<int> indp,outdp;\\n    vector<vector<int>> adj;\\n    vector<pair<int,int>> maxVal;\\n\\n    int n;\\n    void dfs1(int node,int par,string &s){\\n         \\n         indp[node]=0;\\n         int mx =0;\\n         priority_queue<int,vector<int>,greater<int>> pq;\\n         pq.push(0);\\n         pq.push(0);\\n         for(auto ch:adj[node]){\\n             if(ch == par) continue;\\n             dfs1(ch,node,s);\\n             if(s[node] != s[ch]){\\n                 mx=max(mx,indp[ch]);\\n                 pq.push(indp[ch]);\\n                 if(pq.size() > 2) pq.pop();\\n             }\\n         }\\n\\n         int max2 = pq.top();\\n         pq.pop();\\n         int max1 = pq.top();\\n         maxVal[node] = {max1,max2};\\n         \\n         indp[node] = mx+1;\\n    }\\n\\n    void dfs2(int node,int par,string &s){\\n          \\n          if(par == -1 ) outdp[node] = 1;\\n          else{\\n              if(s[node] == s[par]) outdp[node] = 1;\\n              else{\\n                  if(outdp[par]>indp[par]) outdp[node] = outdp[par]+1;\\n                  else{\\n                      pair<int,int> mxv = maxVal[par];\\n                      if(mxv.F > indp[node])  outdp[node] = indp[par]+1;\\n                      else{\\n                          outdp[node] =  max(outdp[par] + 1, mxv.S == 0 ? 0: mxv.S + 2);\\n                      }\\n                  }\\n              }\\n          }\\n          for(auto ch : adj[node]){\\n              if(ch == par) continue;\\n              dfs2(ch,node,s);\\n          }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        n=s.size();\\n        indp.resize(n);\\n        outdp.resize(n);\\n        adj.resize(n);\\n        maxVal.resize(n);\\n\\n        for(int i=1;i<parent.size();i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n\\n        dfs1(0,-1,s);\\n        dfs2(0,-1,s);\\n        int ans=0;\\n\\n\\n        for(int i=0;i<n;i++) ans = max(ans,indp[i] + outdp[i]-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307950,
                "title": "dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    int max = 1;\\n    public void dfs(List<List<Integer>> list, String s, int i, int[] dist) {\\n        dist[i] = 1;\\n        for(int n : list.get(i)) {\\n            dfs(list, s, n, dist);\\n            if(s.charAt(i) != s.charAt(n)) {\\n                max = Math.max(max, dist[i] + dist[n]);\\n                dist[i] = Math.max(dist[i], 1 + dist[n]);\\n            }\\n        }\\n    }\\n    public int longestPath(int[] parent, String s) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int p : parent) {\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 1; i < parent.length; i++) {\\n            list.get(parent[i]).add(i);\\n        }\\n        dfs(list, s, 0, new int[parent.length]);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max = 1;\\n    public void dfs(List<List<Integer>> list, String s, int i, int[] dist) {\\n        dist[i] = 1;\\n        for(int n : list.get(i)) {\\n            dfs(list, s, n, dist);\\n            if(s.charAt(i) != s.charAt(n)) {\\n                max = Math.max(max, dist[i] + dist[n]);\\n                dist[i] = Math.max(dist[i], 1 + dist[n]);\\n            }\\n        }\\n    }\\n    public int longestPath(int[] parent, String s) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int p : parent) {\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 1; i < parent.length; i++) {\\n            list.get(parent[i]).add(i);\\n        }\\n        dfs(list, s, 0, new int[parent.length]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137395,
                "title": "95-faster-dfs-easy-to-understand-c-soltuion",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size(), res = 0;\\n        vector<vector<int>> children(n, vector<int>());\\n        for (int i = 1; i < n; ++i)\\n            children[parent[i]].push_back(i);\\n        dfs(children, s, res, 0);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& children, string& s, int& res, int i) {\\n        int big1 = 0, big2 = 0;\\n        for (int& j : children[i]) {\\n            int cur = dfs(children, s, res, j);\\n            if (s[i] == s[j]) continue;\\n            if (cur >= big1){big2 = big1; big1 = cur;}\\n            else if (cur > big2) big2 = cur;\\n        }\\n        res = max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size(), res = 0;\\n        vector<vector<int>> children(n, vector<int>());\\n        for (int i = 1; i < n; ++i)\\n            children[parent[i]].push_back(i);\\n        dfs(children, s, res, 0);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& children, string& s, int& res, int i) {\\n        int big1 = 0, big2 = 0;\\n        for (int& j : children[i]) {\\n            int cur = dfs(children, s, res, j);\\n            if (s[i] == s[j]) continue;\\n            if (cur >= big1){big2 = big1; big1 = cur;}\\n            else if (cur > big2) big2 = cur;\\n        }\\n        res = max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127120,
                "title": "java-dfs-beats-80-complete-explanation-dfs",
                "content": "```\\nclass Solution {\\n    int res=0;\\n    public int longestPath(int[] parent, String s) {\\n        \\n        List<List<Integer>> graph = new ArrayList<>();\\n        \\n        // making the graph\\n        \\n        for(int i =0;i<parent.length;i++)\\n        {\\n            graph.add(new ArrayList<>());\\n        }\\n        // we can assume the graph is like a binary tree\\n        for(int i =1;i<parent.length;i++)\\n        {\\n            \\n            graph.get(parent[i]).add(i);\\n            //graph.get(i).add(parent[i]);\\n            \\n        }\\n        // print graph\\n       /*\\n        for(int i =0;i<graph.size();i++)\\n        {\\n            List<Integer> list1 = graph.get(i);\\n            System.out.print(i + \"->\");\\n            for(int num : list1)\\n            {\\n                System.out.print( num +\" \");\\n            }\\n            System.out.println();\\n        }\\n        \\n        */\\n        helper(graph,s,0,-1);\\n        return res;\\n        \\n    }\\n    \\n    public int helper(List<List<Integer>> graph, String s, int curr, int parent)\\n    {\\n        \\n        List<Integer> list = graph.get(curr);\\n        // we need first largest and second largest to make the longest connected branch in the graph\\n        // like in binary sum \\n        int firstLongest =0;\\n            int secondLongest =0;\\n        \\n        for(int num : list)\\n        {\\n            //if(num == parent)\\n               //continue;\\n      \\n            int x = helper(graph, s, num,curr);\\n            \\n            // if adjacent is equal then continue \\n            // imp that this should be after the helper function or there will be tc failures \\n             if(s.charAt(curr)==s.charAt(num))\\n              continue;\\n            // find the longest and the second longest \\n            // format to find longest and second longest \\n            if(x>secondLongest)\\n            {\\n                secondLongest =x;       \\n            }\\n            \\n            if(secondLongest>firstLongest)\\n            {\\n                // swap\\n                int temp =  secondLongest;\\n                secondLongest = firstLongest;\\n                firstLongest = temp;\\n            }\\n            \\n        }\\n       // longest path is the longest diameter and can be returned \\n        int longestPath =  firstLongest +1;\\n        // calculating the longest left and right subdiameter to make longest component \\n        int connectedPath =  firstLongest + secondLongest +1;\\n      \\n        // store the longer between them \\n        res =  Math.max(res, Math.max(longestPath,connectedPath));\\n        // return only the longest diameter i.e longestPath as connectedPath cannot be returned \\n         return longestPath;\\n\\n        \\n    }\\n}\\n// 1 is being pointed by zero i.e zero is parent of 1\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int res=0;\\n    public int longestPath(int[] parent, String s) {\\n        \\n        List<List<Integer>> graph = new ArrayList<>();\\n        \\n        // making the graph\\n        \\n        for(int i =0;i<parent.length;i++)\\n        {\\n            graph.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3054367,
                "title": "diameter-of-tree-easy-dfs-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<vector<int>> graph;\\n    int n;\\n    int dfs(string &s,int a,int par){\\n        int tans=0,ttans=0;\\n        for(auto b:graph[a]){\\n            if(b!=par){\\n                int temp=dfs(s,b,a);\\n                if(s[b]!=s[a]) {\\n                    if(temp>=tans) {\\n                        ttans=tans;\\n                        tans=temp;\\n                    }\\n                    else if(temp>ttans)\\n                        ttans=temp;\\n                }\\n            }\\n        }\\n        ans[a]=tans+ttans+1;\\n        return tans+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        n=parent.size();\\n        graph= vector<vector<int>>(n); \\n        for(int i=1;i<n;i++){\\n            graph[i].push_back(parent[i]);\\n            graph[parent[i]].push_back(i);\\n        }\\n        ans=vector<int>(n,0);\\n        dfs(s,0,-1);\\n        int fans=0;\\n        for(auto it:ans){\\n            fans=max(it,fans);\\n        }\\n        return fans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<vector<int>> graph;\\n    int n;\\n    int dfs(string &s,int a,int par){\\n        int tans=0,ttans=0;\\n        for(auto b:graph[a]){\\n            if(b!=par){\\n                int temp=dfs(s,b,a);\\n                if(s[b]!=s[a]) {\\n                    if(temp>=tans) {\\n                        ttans=tans;\\n                        tans=temp;\\n                    }\\n                    else if(temp>ttans)\\n                        ttans=temp;\\n                }\\n            }\\n        }\\n        ans[a]=tans+ttans+1;\\n        return tans+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        n=parent.size();\\n        graph= vector<vector<int>>(n); \\n        for(int i=1;i<n;i++){\\n            graph[i].push_back(parent[i]);\\n            graph[parent[i]].push_back(i);\\n        }\\n        ans=vector<int>(n,0);\\n        dfs(s,0,-1);\\n        int fans=0;\\n        for(auto it:ans){\\n            fans=max(it,fans);\\n        }\\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053976,
                "title": "simple-dfs-with-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\neach recursive call will return the longest path in thr tree rooted at it including the node itself\\nsince the longest path can start and end at anywhere \\nwe will consider the top 2 paths for the current node \\nthat are at it including the current node \\nand update the ans globally \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple dfs approach would work out \\nwhile making the adjacency matrix dont make it undirected \\nrather add directed edges towards childeren node \\nthis will help in traversal without using vis array \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int dfs(int node,vector<vector<int>>&adj,int &ans,string& s){\\n\\n\\n\\n\\n        int f1=0;\\n        int f2=0;\\n\\n        int c=0;\\n\\n        for(auto e:adj[node]){\\n            int curr=dfs(e,adj,ans,s);\\n            \\n            curr=s[node]!=s[e]?curr+1:0;\\n            if(curr){\\n                c++;\\n            }\\n\\n            if(curr>f1){\\n                f2=f1;\\n                f1=curr;\\n            }else if(curr>f2){\\n                f2=curr;\\n            }\\n\\n\\n\\n\\n\\n        }\\n        if(c==0){\\n            return 1;\\n        }\\n\\n        if(f1>ans){\\n            ans=f1;\\n        }\\n        if(f2>ans){\\n            ans=f2;\\n        }\\n\\n        if( f1!=0 && f2!=0 && f1+f2-1>ans){\\n            ans=f1+f2-1;\\n        }\\n        return f1;\\n\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n\\n\\n        int n=parent.size();\\n\\n        if(parent.size()==1){\\n            return 1;\\n        }\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<n;i++){\\n            \\n            if(parent[i]!=-1){\\n                adj[parent[i]].push_back(i);\\n            }\\n        }\\n\\n        int ans=1;\\n        dfs(0,adj,ans,s);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    int dfs(int node,vector<vector<int>>&adj,int &ans,string& s){\\n\\n\\n\\n\\n        int f1=0;\\n        int f2=0;\\n\\n        int c=0;\\n\\n        for(auto e:adj[node]){\\n            int curr=dfs(e,adj,ans,s);\\n            \\n            curr=s[node]!=s[e]?curr+1:0;\\n            if(curr){\\n                c++;\\n            }\\n\\n            if(curr>f1){\\n                f2=f1;\\n                f1=curr;\\n            }else if(curr>f2){\\n                f2=curr;\\n            }\\n\\n\\n\\n\\n\\n        }\\n        if(c==0){\\n            return 1;\\n        }\\n\\n        if(f1>ans){\\n            ans=f1;\\n        }\\n        if(f2>ans){\\n            ans=f2;\\n        }\\n\\n        if( f1!=0 && f2!=0 && f1+f2-1>ans){\\n            ans=f1+f2-1;\\n        }\\n        return f1;\\n\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n\\n\\n        int n=parent.size();\\n\\n        if(parent.size()==1){\\n            return 1;\\n        }\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<n;i++){\\n            \\n            if(parent[i]!=-1){\\n                adj[parent[i]].push_back(i);\\n            }\\n        }\\n\\n        int ans=1;\\n        dfs(0,adj,ans,s);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050880,
                "title": "71-faster-c-simple-recursive-call",
                "content": "```\\nclass Solution {\\npublic:\\n        int ans=1;\\n       int dfs(int node,int p,string &s,vector<vector<int>>&adj){\\n        \\n              int c=1;\\n               for(auto x: adj[node]){ \\n               if(x!=p){\\n                       int t=dfs(x,node,s,adj);\\n                       \\n                       \\n                       if(s[node]!=s[x]){\\n                             \\n                              ans=max(ans,c+t); \\n                                 c=max(c,1+t);\\n\\n                               \\n                             \\n                       }\\n                       \\n               }\\n                       \\n                       \\n                       \\n                       \\n               }\\n               \\n               return c;\\n       \\n       } \\n    int longestPath(vector<int>& parent, string s) {\\n           int n= parent.size();\\n            vector<vector<int>> adj;\\n            adj.resize(n);\\n        \\n         for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n            adj[i].push_back(parent[i]);\\n        }\\n            dfs(0,-1,s,adj);\\n            \\n            return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n        int ans=1;\\n       int dfs(int node,int p,string &s,vector<vector<int>>&adj){\\n        \\n              int c=1;\\n               for(auto x: adj[node]){ \\n               if(x!=p){\\n                       int t=dfs(x,node,s,adj);\\n                       \\n                       \\n                       if(s[node]!=s[x]){\\n                             \\n                              ans=max(ans,c+t); \\n                                 c=max(c,1+t);\\n\\n                               \\n                             \\n                       }",
                "codeTag": "Java"
            },
            {
                "id": 3049383,
                "title": "dfs-o-n-time-c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can divide the problem into subproblem, every node will return the maximum length of path from the node to towards the leaf, if the parent and node have same label the cureent node will return 0 else will return the number of edges in the valid path toward the leaf. For every node we will take 2 paths with maximum possible length and add them up and store it in result if it is greater than current value of result. Result will contain number of edges in max path.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int recurse(int nd, int prev, vector<vector<int>>&t, string &s){\\n        int m1 = 0,m2=0;\\n        for(int i = 0; i < t[nd].size(); i++){\\n            if(t[nd][i] == prev) continue;\\n            int temp = recurse(t[nd][i],nd,t,s);\\n            if(temp > m1){\\n                m2 = m1;\\n                m1 = temp;\\n            }\\n            else if(temp > m2){\\n                m2 = temp;\\n            }\\n        }\\n        res = max(res,m1+m2);\\n        if(prev>=0 && s[nd] == s[prev]) return 0;\\n        return m1+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.length();\\n        vector<vector<int>> adj(n);\\n        for(int i = 1; i < parent.size(); i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        recurse(0,-1,adj,s);\\n        return res+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int recurse(int nd, int prev, vector<vector<int>>&t, string &s){\\n        int m1 = 0,m2=0;\\n        for(int i = 0; i < t[nd].size(); i++){\\n            if(t[nd][i] == prev) continue;\\n            int temp = recurse(t[nd][i],nd,t,s);\\n            if(temp > m1){\\n                m2 = m1;\\n                m1 = temp;\\n            }\\n            else if(temp > m2){\\n                m2 = temp;\\n            }\\n        }\\n        res = max(res,m1+m2);\\n        if(prev>=0 && s[nd] == s[prev]) return 0;\\n        return m1+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.length();\\n        vector<vector<int>> adj(n);\\n        for(int i = 1; i < parent.size(); i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        recurse(0,-1,adj,s);\\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048675,
                "title": "simple-c-solution-using-dfs-diameter-of-tree",
                "content": "\\n# Complexity\\n- Time complexity:O(E+V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],vector<int>&visit,int node,string &s,int &maxi){\\n        visit[node]=1;\\n        int l=0,r=0;\\n        for(int i=0;i<adj[node].size();++i){\\n            if(visit[adj[node][i]]==0){\\n                if(s[node]!=s[adj[node][i]]){\\n                    int temp=dfs(adj,visit,adj[node][i],s,maxi);\\n                    if(l<=temp){\\n                        r=l;\\n                        l=temp;\\n                    }\\n                    else if(temp>r)\\n                        r=temp;\\n                }\\n                else{\\n                    int temp=dfs(adj,visit,adj[node][i],s,maxi);\\n                }\\n            }\\n        }\\n        if(maxi<l+r+1) maxi=l+r+1;\\n        return max(l,r)+1;\\n    }\\n    int longestPath(vector<int>& p, string s) {\\n        vector<int>adj[s.size()];\\n        for(int i=0;i<p.size();++i){\\n            if(p[i]==-1) continue;\\n            adj[i].push_back(p[i]);\\n            adj[p[i]].push_back(i);\\n        }\\n        vector<int>visit(s.size(),0);\\n        int maxi=0;\\n        dfs(adj,visit,0,s,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],vector<int>&visit,int node,string &s,int &maxi){\\n        visit[node]=1;\\n        int l=0,r=0;\\n        for(int i=0;i<adj[node].size();++i){\\n            if(visit[adj[node][i]]==0){\\n                if(s[node]!=s[adj[node][i]]){\\n                    int temp=dfs(adj,visit,adj[node][i],s,maxi);\\n                    if(l<=temp){\\n                        r=l;\\n                        l=temp;\\n                    }\\n                    else if(temp>r)\\n                        r=temp;\\n                }\\n                else{\\n                    int temp=dfs(adj,visit,adj[node][i],s,maxi);\\n                }\\n            }\\n        }\\n        if(maxi<l+r+1) maxi=l+r+1;\\n        return max(l,r)+1;\\n    }\\n    int longestPath(vector<int>& p, string s) {\\n        vector<int>adj[s.size()];\\n        for(int i=0;i<p.size();++i){\\n            if(p[i]==-1) continue;\\n            adj[i].push_back(p[i]);\\n            adj[p[i]].push_back(i);\\n        }\\n        vector<int>visit(s.size(),0);\\n        int maxi=0;\\n        dfs(adj,visit,0,s,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047227,
                "title": "ruby-to-avoid-dfs-tle-need-to-convert-string-to-array",
                "content": "## Leetcode: 2246. Longest Path With Different Adjacent Characters.\\n\\n**Ruby: To avoid DFS TLE need to convert string to array.**\\n\\nFound a hint [here](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/discuss/3045037/Ruby.-DFS-without-Time-Limit-Exceeded-(714-ms-274-MB-Beats-100)/1755867).\\n\\n- https://leetcode.com/0x81/\\n- https://leetcode.com/blrB/\\n\\n```Ruby\\n# After this fix 100%/100%.\\n# https://leetcode.com/0x81/\\n# https://leetcode.com/blrB/\\n@s = s # TLE;\\n@s = s.chars # 100%/100%;\\n```\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 2246. Longest Path With Different Adjacent Characters.\\n# https://leetcode.com/problems/longest-path-with-different-adjacent-characters/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 712 ms, faster than 100.00% of Ruby online submissions for Longest Path With Different Adjacent Characters.\\n# Memory Usage: 310.8 MB, less than 100.00% of Ruby online submissions for Longest Path With Different Adjacent Characters.\\n# 2023.01.13 Daily Challenge.\\n# @param {Integer[]} parent\\n# @param {String} s\\n# @return {Integer}\\ndef longest_path(parent, s)\\n  @n = parent.size\\n  # https://leetcode.com/problems/longest-path-with-different-adjacent-characters/discuss/3045037/Ruby.-DFS-without-Time-Limit-Exceeded-(714-ms-274-MB-Beats-100)/1755867\\n  # After this fix 100%/100%.\\n  # https://leetcode.com/0x81/\\n  # https://leetcode.com/blrB/\\n  @s = s.chars\\n  @ch = Array.new(@n).map{[]}\\n  @max = 0\\n  (1...@n).each do |i|\\n    prnt = parent[i]\\n    @ch[prnt].push(i)\\n  end\\n  dfs(0,?.)\\n  return @max\\nend\\n\\ndef dfs(i,prev)\\n  return 0 if i == @n\\n  char = @s[i]\\n  max, max1 = 0,0\\n  @ch[i].each do |j|\\n    tmp = dfs(j,char)\\n    # Add this line from the Leetcode\\'s solution.\\n    # And it is no surprice that still TLE.\\n    next if @s[i] == @s[j]\\n    if tmp > max\\n      max,max1 = tmp, max\\n    elsif tmp > max1\\n      max1 = tmp\\n    end\\n  end\\n  tmp1 = max + 1 + max1\\n  @max = tmp1 if tmp1 > @max\\n  if prev != char\\n    return max + 1\\n  end\\n  return 0\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# After this fix 100%/100%.\\n# https://leetcode.com/0x81/\\n# https://leetcode.com/blrB/\\n@s = s # TLE;\\n@s = s.chars # 100%/100%;\\n```\n```Ruby\\n# Leetcode: 2246. Longest Path With Different Adjacent Characters.\\n# https://leetcode.com/problems/longest-path-with-different-adjacent-characters/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 712 ms, faster than 100.00% of Ruby online submissions for Longest Path With Different Adjacent Characters.\\n# Memory Usage: 310.8 MB, less than 100.00% of Ruby online submissions for Longest Path With Different Adjacent Characters.\\n# 2023.01.13 Daily Challenge.\\n# @param {Integer[]} parent\\n# @param {String} s\\n# @return {Integer}\\ndef longest_path(parent, s)\\n  @n = parent.size\\n  # https://leetcode.com/problems/longest-path-with-different-adjacent-characters/discuss/3045037/Ruby.-DFS-without-Time-Limit-Exceeded-(714-ms-274-MB-Beats-100)/1755867\\n  # After this fix 100%/100%.\\n  # https://leetcode.com/0x81/\\n  # https://leetcode.com/blrB/\\n  @s = s.chars\\n  @ch = Array.new(@n).map{[]}\\n  @max = 0\\n  (1...@n).each do |i|\\n    prnt = parent[i]\\n    @ch[prnt].push(i)\\n  end\\n  dfs(0,?.)\\n  return @max\\nend\\n\\ndef dfs(i,prev)\\n  return 0 if i == @n\\n  char = @s[i]\\n  max, max1 = 0,0\\n  @ch[i].each do |j|\\n    tmp = dfs(j,char)\\n    # Add this line from the Leetcode\\'s solution.\\n    # And it is no surprice that still TLE.\\n    next if @s[i] == @s[j]\\n    if tmp > max\\n      max,max1 = tmp, max\\n    elsif tmp > max1\\n      max1 = tmp\\n    end\\n  end\\n  tmp1 = max + 1 + max1\\n  @max = tmp1 if tmp1 > @max\\n  if prev != char\\n    return max + 1\\n  end\\n  return 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3047207,
                "title": "c-dfs-solution-with-explanation",
                "content": "full explanation\\nhttps://youtu.be/a2uEujm_yN0\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    unordered_map<int,vector<int>> tree; //graph\\n    int res = 1;\\n    int maxPath(int node, string &s, char c){\\n        int max_path = 1;\\n        int second_path = 1;\\n        int path = 1;\\n        for (int i = 0; i< tree[node].size();i++){          \\n            if (s[tree[node][i]]!= c){\\n                path = 1 + maxPath(tree[node][i],s,s[tree[node][i]]);\\n            }  else{\\n                maxPath(tree[node][i],s,s[tree[node][i]]);\\n                path = 1;\\n            }         \\n            //cout << \"node \" << node << \"path: \" << path << \". \" << c << endl;\\n            if (path > max_path){\\n                second_path = max_path;\\n                max_path = path;\\n            } else if (path > second_path){\\n                second_path = path;\\n            }\\n            \\n            //for this node, the max. path is the sum of two subtrees with max. node - 1\\n            int cur_max = max_path + second_path -1;\\n            res = max(cur_max, res);\\n        }\\n\\n        //return the subtree with maximum path to the parent\\n        //cout << node << \",\" <<  max_path << \" . \" << second_path << endl;\\n        return max_path;\\n        \\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        //build a graph\\n        //parent[0] = -1, so we start from first node\\n        for (int i=1; i< parent.size();i++){\\n            //build the path from parent to child   \\n            if (tree.find(parent[i]) == tree.end()){\\n                vector<int> v;\\n                v.push_back(i);\\n                tree.emplace(parent[i],v);\\n            } else{\\n                tree[parent[i]].push_back(i);\\n            }\\n        }\\n        maxPath(0,s,s[0]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unordered_map<int,vector<int>> tree; //graph\\n    int res = 1;\\n    int maxPath(int node, string &s, char c){\\n        int max_path = 1;\\n        int second_path = 1;\\n        int path = 1;\\n        for (int i = 0; i< tree[node].size();i++){          \\n            if (s[tree[node][i]]!= c){\\n                path = 1 + maxPath(tree[node][i],s,s[tree[node][i]]);\\n            }  else{\\n                maxPath(tree[node][i],s,s[tree[node][i]]);\\n                path = 1;\\n            }         \\n            //cout << \"node \" << node << \"path: \" << path << \". \" << c << endl;\\n            if (path > max_path){\\n                second_path = max_path;\\n                max_path = path;\\n            } else if (path > second_path){\\n                second_path = path;\\n            }\\n            \\n            //for this node, the max. path is the sum of two subtrees with max. node - 1\\n            int cur_max = max_path + second_path -1;\\n            res = max(cur_max, res);\\n        }\\n\\n        //return the subtree with maximum path to the parent\\n        //cout << node << \",\" <<  max_path << \" . \" << second_path << endl;\\n        return max_path;\\n        \\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        //build a graph\\n        //parent[0] = -1, so we start from first node\\n        for (int i=1; i< parent.size();i++){\\n            //build the path from parent to child   \\n            if (tree.find(parent[i]) == tree.end()){\\n                vector<int> v;\\n                v.push_back(i);\\n                tree.emplace(parent[i],v);\\n            } else{\\n                tree[parent[i]].push_back(i);\\n            }\\n        }\\n        maxPath(0,s,s[0]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3047056,
                "title": "leetcode-daily-challenge-dfs-94-faster-runtime",
                "content": "[This question](https://leetcode.com/problems/diameter-of-binary-tree/description/) is the base for this problem, understand this problem first and try to solve it and then this problem will become very easy.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int longestPath(vector<int>& parent, string s) {\\n        ans = 0;\\n        int n=parent.size();\\n        vector<int> g[n];\\n        for(int i=1;i<n;i++){\\n            g[parent[i]].push_back(i);\\n        }\\n        DFS(g, 0, s);\\n        return ans;\\n    }\\n\\n    int DFS(vector<int> g[], int node, string &s){\\n\\n        int m1=0, m2=0, value;\\n        for(auto &cn : g[node]){\\n            value = DFS(g, cn, s);\\n            if( s[cn] != s[node] ){\\n                if( m1 < value ) m2=m1, m1=value;\\n                else if( m2 < value ) m2=value;\\n            }\\n        }\\n        ans = max(ans, (m1 + m2 + 1));\\n        return max(m1, m2)+1;\\n    }\\n};\\n```\\n**Please upvote if you like the solution \\uD83D\\uDE09**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    int longestPath(vector<int>& parent, string s) {\\n        ans = 0;\\n        int n=parent.size();\\n        vector<int> g[n];\\n        for(int i=1;i<n;i++){\\n            g[parent[i]].push_back(i);\\n        }\\n        DFS(g, 0, s);\\n        return ans;\\n    }\\n\\n    int DFS(vector<int> g[], int node, string &s){\\n\\n        int m1=0, m2=0, value;\\n        for(auto &cn : g[node]){\\n            value = DFS(g, cn, s);\\n            if( s[cn] != s[node] ){\\n                if( m1 < value ) m2=m1, m1=value;\\n                else if( m2 < value ) m2=value;\\n            }\\n        }\\n        ans = max(ans, (m1 + m2 + 1));\\n        return max(m1, m2)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047004,
                "title": "python-dfs-memo-easiest-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**For each node, DFS the longest one. For each DFS, we cache the  result for same order traversal to save time.**\\n\\nFor example: For node 1 and its parent 0, we save the longest for dfs(1, 0). And every time we traverse the node 1 with parent 0, we can directly use the result we cached before.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        graph = defaultdict(list)\\n        # construct the graph\\n        for i in range(len(parent)):\\n            if parent[i] != -1:\\n                graph[parent[i]].append(i)\\n                graph[i].append(parent[i])\\n        @cache\\n        def dfs(node, parent):\\n            ret = 1\\n            for neighbor in graph[node]:\\n                # maintain the same order, no return way\\n                if neighbor == parent: continue\\n                if s[neighbor] != s[node]:\\n                    ret = max(ret, dfs(neighbor, node) + 1)\\n            return ret\\n        return max(dfs(i, -1) for i in range(len(parent)))\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        graph = defaultdict(list)\\n        # construct the graph\\n        for i in range(len(parent)):\\n            if parent[i] != -1:\\n                graph[parent[i]].append(i)\\n                graph[i].append(parent[i])\\n        @cache\\n        def dfs(node, parent):\\n            ret = 1\\n            for neighbor in graph[node]:\\n                # maintain the same order, no return way\\n                if neighbor == parent: continue\\n                if s[neighbor] != s[node]:\\n                    ret = max(ret, dfs(neighbor, node) + 1)\\n            return ret\\n        return max(dfs(i, -1) for i in range(len(parent)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046910,
                "title": "simple-dfs-traversal-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>> &v, string &s, int i, int &longest){\\n        \\n        int dist = 0;\\n        for(auto x: v[i]){\\n            if(s[x] != s[i]){\\n                int a = dfs(v, s, x, longest);\\n                longest = max(longest, (a + 1 + dist));\\n                dist = max(dist, a);\\n            }\\n            else dfs(v, s, x, longest);\\n        }\\n        \\n        return dist == 0 ? 1 : dist + 1;\\n    }\\n    \\n    int longestPath(vector<int>& p, string s) {\\n        vector<vector<int>> v(p.size());\\n        \\n        for(int i=1; i<p.size(); i++)\\n            v[p[i]].push_back(i);\\n        \\n        int longest = 1;\\n        dfs(v, s, 0, longest);\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<int>> &v, string &s, int i, int &longest){\\n        \\n        int dist = 0;\\n        for(auto x: v[i]){\\n            if(s[x] != s[i]){\\n                int a = dfs(v, s, x, longest);\\n                longest = max(longest, (a + 1 + dist));\\n                dist = max(dist, a);\\n            }\\n            else dfs(v, s, x, longest);\\n        }\\n        \\n        return dist == 0 ? 1 : dist + 1;\\n    }\\n    \\n    int longestPath(vector<int>& p, string s) {\\n        vector<vector<int>> v(p.size());\\n        \\n        for(int i=1; i<p.size(); i++)\\n            v[p[i]].push_back(i);\\n        \\n        int longest = 1;\\n        dfs(v, s, 0, longest);\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046826,
                "title": "easiest-c-approach",
                "content": "# Intuition:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DFS to traverse the tree and keep updating the ans.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have two options for each node:\\n\\n- The first one is to take one branch and add the node\\n- The second one is to take two sub branches from the node and merge them and add the current node\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V+2\\xD7E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dis[100005];\\n    int ans=1;\\n    void dfs(int src,vector<vector<int>>& adjLs,string& s){\\n        dis[src]=1;\\n        for(int node:adjLs[src]){\\n            dfs(node,adjLs,s);\\n            if(s[src]!=s[node]){\\n                ans=max(ans,dis[src]+dis[node]);\\n                dis[src]=max(dis[src],dis[node]+1);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        vector<vector<int>>adjLs(n);\\n        for(int i=1;i<n;i++){\\n            adjLs[parent[i]].push_back(i);\\n        }\\n        dfs(0,adjLs,s);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dis[100005];\\n    int ans=1;\\n    void dfs(int src,vector<vector<int>>& adjLs,string& s){\\n        dis[src]=1;\\n        for(int node:adjLs[src]){\\n            dfs(node,adjLs,s);\\n            if(s[src]!=s[node]){\\n                ans=max(ans,dis[src]+dis[node]);\\n                dis[src]=max(dis[src],dis[node]+1);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        vector<vector<int>>adjLs(n);\\n        for(int i=1;i<n;i++){\\n            adjLs[parent[i]].push_back(i);\\n        }\\n        dfs(0,adjLs,s);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046763,
                "title": "c-accepted-dfs-solution",
                "content": "```\\nclass Solution {\\n    int dist[100005],ans = 1;\\npublic:\\n    void dfs(int node, int prev, vector<vector<int>> &adj,  string &s){\\n        dist[node] = 1;\\n        for(auto child: adj[node]){\\n            if(child != prev){\\n                dfs(child, node, adj, s);\\n                if(s[child] != s[node]){\\n                    ans = max(ans, dist[child] + dist[node]);\\n                    dist[node] = max(dist[node], dist[child] + 1);\\n                }else{\\n                    ans = max(ans, dist[child]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=1;i<parent.size();i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0,-1,adj,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dist[100005],ans = 1;\\npublic:\\n    void dfs(int node, int prev, vector<vector<int>> &adj,  string &s){\\n        dist[node] = 1;\\n        for(auto child: adj[node]){\\n            if(child != prev){\\n                dfs(child, node, adj, s);\\n                if(s[child] != s[node]){\\n                    ans = max(ans, dist[child] + dist[node]);\\n                    dist[node] = max(dist[node], dist[child] + 1);\\n                }else{\\n                    ans = max(ans, dist[child]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=1;i<parent.size();i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0,-1,adj,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046662,
                "title": "java-simple-solution-beats-88",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestPath(int[] arr, String s) {\\n        int n = arr.length;\\n        ArrayList<Integer> graph[] = new ArrayList[n];\\n        for(int i=0;i<n;i++)graph[i] = new ArrayList<>();\\n        for(int i=1;i<n;i++){\\n            graph[arr[i]].add(i);\\n        }\\n        int dp[] = new int[n];\\n        recur(graph, s, dp, 0);\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            // Finding longest 2 branches which satisfies the conditions\\n            int a=0, b=0;\\n            for(int x: graph[i]){\\n                if(s.charAt(i)!=s.charAt(x)){\\n                    if(dp[x]>a){\\n                        b = a;\\n                        a = dp[x];\\n                    }else if(dp[x]>b){\\n                        b = dp[x];\\n                    }\\n                }\\n            }\\n            max = Math.max(a+b+1, max);\\n        }\\n        return max;\\n    }\\n    // function to store maximum length of subtree i with no pair of adjacent nodes on the path have the same character assigned to them.\\n    public static void recur(ArrayList<Integer> graph[], String s, int dp[], int i){\\n        int max = 0;\\n        for(int x: graph[i]){\\n            if(s.charAt(i)!=s.charAt(x)){\\n                recur(graph, s, dp, x);\\n                if(max<dp[x])max = dp[x];\\n            }else{\\n                recur(graph, s, dp, x);\\n            }\\n        }\\n        dp[i] = max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPath(int[] arr, String s) {\\n        int n = arr.length;\\n        ArrayList<Integer> graph[] = new ArrayList[n];\\n        for(int i=0;i<n;i++)graph[i] = new ArrayList<>();\\n        for(int i=1;i<n;i++){\\n            graph[arr[i]].add(i);\\n        }\\n        int dp[] = new int[n];\\n        recur(graph, s, dp, 0);\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            // Finding longest 2 branches which satisfies the conditions\\n            int a=0, b=0;\\n            for(int x: graph[i]){\\n                if(s.charAt(i)!=s.charAt(x)){\\n                    if(dp[x]>a){\\n                        b = a;\\n                        a = dp[x];\\n                    }else if(dp[x]>b){\\n                        b = dp[x];\\n                    }\\n                }\\n            }\\n            max = Math.max(a+b+1, max);\\n        }\\n        return max;\\n    }\\n    // function to store maximum length of subtree i with no pair of adjacent nodes on the path have the same character assigned to them.\\n    public static void recur(ArrayList<Integer> graph[], String s, int dp[], int i){\\n        int max = 0;\\n        for(int x: graph[i]){\\n            if(s.charAt(i)!=s.charAt(x)){\\n                recur(graph, s, dp, x);\\n                if(max<dp[x])max = dp[x];\\n            }else{\\n                recur(graph, s, dp, x);\\n            }\\n        }\\n        dp[i] = max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046501,
                "title": "very-easy-solution-java",
                "content": "\\n```\\nclass Solution {\\n    private int longestPath = 1;\\n\\n    public int dfs(int currentNode, Map<Integer, List<Integer>> children, String s) {\\n        if (!children.containsKey(currentNode)) {\\n            return 1;\\n        }\\n\\n        int longestChain = 0, secondLongestChain = 0;\\n        for (int child : children.get(currentNode)) {\\n            \\n            int longestChainStartingFromChild = dfs(child, children, s);\\n           \\n            if (s.charAt(currentNode) == s.charAt(child)) {\\n                continue;\\n            }\\n         \\n            if (longestChainStartingFromChild > longestChain) {\\n                secondLongestChain = longestChain;\\n                longestChain = longestChainStartingFromChild;\\n            } else if (longestChainStartingFromChild > secondLongestChain) {\\n                secondLongestChain = longestChainStartingFromChild;\\n            }\\n        }\\n\\n        longestPath = Math.max(longestPath, longestChain + secondLongestChain + 1);\\n        return longestChain + 1;\\n    }\\n\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        Map<Integer, List<Integer>> children = new HashMap<>();\\n        for (int i = 1; i < n; i++) {\\n            children.computeIfAbsent(parent[i], value -> new ArrayList<Integer>()).add(i);\\n        }\\n\\n        dfs(0, children, s);\\n\\n        return longestPath;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int longestPath = 1;\\n\\n    public int dfs(int currentNode, Map<Integer, List<Integer>> children, String s) {\\n        if (!children.containsKey(currentNode)) {\\n            return 1;\\n        }\\n\\n        int longestChain = 0, secondLongestChain = 0;\\n        for (int child : children.get(currentNode)) {\\n            \\n            int longestChainStartingFromChild = dfs(child, children, s);\\n           \\n            if (s.charAt(currentNode) == s.charAt(child)) {\\n                continue;\\n            }\\n         \\n            if (longestChainStartingFromChild > longestChain) {\\n                secondLongestChain = longestChain;\\n                longestChain = longestChainStartingFromChild;\\n            } else if (longestChainStartingFromChild > secondLongestChain) {\\n                secondLongestChain = longestChainStartingFromChild;\\n            }\\n        }\\n\\n        longestPath = Math.max(longestPath, longestChain + secondLongestChain + 1);\\n        return longestChain + 1;\\n    }\\n\\n    public int longestPath(int[] parent, String s) {\\n        int n = parent.length;\\n        Map<Integer, List<Integer>> children = new HashMap<>();\\n        for (int i = 1; i < n; i++) {\\n            children.computeIfAbsent(parent[i], value -> new ArrayList<Integer>()).add(i);\\n        }\\n\\n        dfs(0, children, s);\\n\\n        return longestPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046434,
                "title": "sundar-susheel-ubla-hua-ekdum-simple-zyada-garam-garam-code",
                "content": "# Intuition\\nThe problem is bit similar to maximum path sum in a binary tree.I will request you to please solve that first and we will be using similar logic here. (Leetcode 124)\\n\\nWe will have 2 cases for a node. \\n1. We will consider the root + max from all its children and pass it to the parent node\\n2. We will consider root + max + second max and close it here. ( Path will be like left child+root+right child)\\n\\n# Approach\\nFirst we will make adjacency list and pass it to our recursive function. We will have a global maxi which will store our ans.\\nIn dfs function we have variables a and b which will store max and second max for each node.\\nSince in adjacency list we are storing in form of undirected graph like 1->2 and 2->1 we need curr and par variable so that once from parent we go to child, we dont consider the edge from child back to parent (if child==curr then continue)\\nWe will recursively call the dfs function for the child node as well.\\nIn childlength we will store all the paths from the node. \\nSo as discussed above we are taking max(curr_max,1+a+b).\\nWe will return 1+a in dfs function, as 1+a+b will complete the path. To continue we will consider the root+ max and pass it the the parent to continue the path in upper direction.\\n\\n# Complexity\\n- Time complexity:\\nSimple DFS Traversal TC : O(n)\\n- Space complexity:\\nWe are using extra space to make adjacency list O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxi=1;\\n    int dfs(vector<int>adj[],int curr,int par,string &s)\\n    {\\n        int a=0;\\n        int b=0;\\n\\n        for(auto child:adj[curr])\\n        {\\n            if(child==par)continue;\\n            int childlength=dfs(adj,child,curr,s);\\n            if(s[curr]==s[child])continue;\\n            if(childlength>a)\\n            {\\n                b=a;\\n                a=childlength;\\n            }\\n            else if(childlength>b)\\n                b=childlength;\\n        }\\n        int down=1+a+b;\\n        maxi=max(maxi, down);\\n        int up=1+a;\\n        return up;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        vector<int>adj[n];\\n        for(int i=1;i<n;i++)\\n        {\\n            int u=i;\\n            int v=parent[i];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        dfs(adj,0,-1,s);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=1;\\n    int dfs(vector<int>adj[],int curr,int par,string &s)\\n    {\\n        int a=0;\\n        int b=0;\\n\\n        for(auto child:adj[curr])\\n        {\\n            if(child==par)continue;\\n            int childlength=dfs(adj,child,curr,s);\\n            if(s[curr]==s[child])continue;\\n            if(childlength>a)\\n            {\\n                b=a;\\n                a=childlength;\\n            }\\n            else if(childlength>b)\\n                b=childlength;\\n        }\\n        int down=1+a+b;\\n        maxi=max(maxi, down);\\n        int up=1+a;\\n        return up;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        vector<int>adj[n];\\n        for(int i=1;i<n;i++)\\n        {\\n            int u=i;\\n            int v=parent[i];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        dfs(adj,0,-1,s);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046424,
                "title": "good-solution-with-explanation-in-c",
                "content": "# Intuition + Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt every node find the two of paths in the subtree with the maximum path lenght whose associated letter is not as same as the root.\\nNow the longest path could be some of this two + 1 (current node) or we might find in the upper part of the tree so for that we can only take one path down and thus return the maximum path + 1 (current node) to the paent.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // Storing the intermediate result\\n    int res = 0;\\n\\n    // The recursive funstion to find the path\\n    int helper(int n, vector<vector<int>>& adj, string& s) {\\n        // If the node is leaf return 1 as it\\'s path length\\n        if (adj[n].size() == 0) return 1;\\n\\n        // The node might have many children but we only need two max paths\\n        // Thus to keep track of those two we need two vars.\\n        int m1 = 0, m2 = 0;\\n\\n        // For every child we will find the path\\n        for (auto i: adj[n]) {\\n            int x = helper(i, adj, s);\\n            // If the child\\'s letter is same as parent then we will skip\\n            if (s[i] == s[n]) continue;\\n\\n            // Updating the maximum path lengths\\n            if (x > m1) {\\n                m2 = m1;\\n                m1 = x;\\n            } else if (x > m2) m2 = x;\\n        }\\n\\n        // Update the resultant path length is the result is there\\n        res = max(res, m1 + m2 + 1);\\n\\n        // Return the path including the node to parent\\n        return 1 + m1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n        for (int i = 1; i < n; i++)\\n            adj[parent[i]].push_back(i);\\n\\n        return max(helper(0, adj, s), res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Storing the intermediate result\\n    int res = 0;\\n\\n    // The recursive funstion to find the path\\n    int helper(int n, vector<vector<int>>& adj, string& s) {\\n        // If the node is leaf return 1 as it\\'s path length\\n        if (adj[n].size() == 0) return 1;\\n\\n        // The node might have many children but we only need two max paths\\n        // Thus to keep track of those two we need two vars.\\n        int m1 = 0, m2 = 0;\\n\\n        // For every child we will find the path\\n        for (auto i: adj[n]) {\\n            int x = helper(i, adj, s);\\n            // If the child\\'s letter is same as parent then we will skip\\n            if (s[i] == s[n]) continue;\\n\\n            // Updating the maximum path lengths\\n            if (x > m1) {\\n                m2 = m1;\\n                m1 = x;\\n            } else if (x > m2) m2 = x;\\n        }\\n\\n        // Update the resultant path length is the result is there\\n        res = max(res, m1 + m2 + 1);\\n\\n        // Return the path including the node to parent\\n        return 1 + m1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n        for (int i = 1; i < n; i++)\\n            adj[parent[i]].push_back(i);\\n\\n        return max(helper(0, adj, s), res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046390,
                "title": "simple-code-with-detailed-explanation-java-code-o-n",
                "content": "# Approach\\n1. Form the Adjacency List of the Tree.\\n2. Perform DFS on each subtree and calculate the Longest One way<Only travelling downward in direction of the leaves> path.\\n3. Then calculate the longest path of that subtree by adding the longest 2 paths +1 because of the root node and update the res value\\n4. then return the longest one way path +1.\\n\\n**NOTE --> Remenber to check that the root node of the subtree and the child node does not have same label!!**\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String str;\\n    int res = 0;\\n    public int longestPath(int[] parent, String s) {\\n        str = s;\\n        int n = parent.length;\\n        List<Integer> aList[] = new List[n];\\n        for(int i = 0; i<n; i++) aList[i] = new ArrayList<Integer>();\\n        for(int i = 1; i<n; i++) aList[parent[i]].add(i);\\n\\n        dfs(0, aList);\\n        return res;\\n    }\\n\\n    private int dfs(int currN, List<Integer> aList[]) {\\n        int a = 0, b = 0;\\n        for(int child: aList[currN]) {\\n            int len = dfs(child, aList);\\n            if(str.charAt(currN) != str.charAt(child)) {\\n                if(len>a){ \\n                    b = a;\\n                    a = len;\\n                }\\n                else if(len>b && a>=b) b = len;\\n            }\\n        }\\n        res = Math.max(res, a + b + 1);\\n        return a + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    String str;\\n    int res = 0;\\n    public int longestPath(int[] parent, String s) {\\n        str = s;\\n        int n = parent.length;\\n        List<Integer> aList[] = new List[n];\\n        for(int i = 0; i<n; i++) aList[i] = new ArrayList<Integer>();\\n        for(int i = 1; i<n; i++) aList[parent[i]].add(i);\\n\\n        dfs(0, aList);\\n        return res;\\n    }\\n\\n    private int dfs(int currN, List<Integer> aList[]) {\\n        int a = 0, b = 0;\\n        for(int child: aList[currN]) {\\n            int len = dfs(child, aList);\\n            if(str.charAt(currN) != str.charAt(child)) {\\n                if(len>a){ \\n                    b = a;\\n                    a = len;\\n                }\\n                else if(len>b && a>=b) b = len;\\n            }\\n        }\\n        res = Math.max(res, a + b + 1);\\n        return a + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046316,
                "title": "easy-java-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndfs(i) return the the longest path starting at the node i.\\n\\ndfs on each node i, and for each node i,\\nwe iterate on all its children,\\nand find all the path startint at the node i.\\nThe 2 longest path can make up the longest path in subtree of node i,\\nwe update the global result res,\\nand return the longest path length as result for dfs.\\n\\n# Complexity\\n\\n- Time O(n)\\n- Space O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res;\\n    public int longestPath(int[] parent, String s) {\\n        res = 0;\\n        ArrayList<Integer>[] children = new ArrayList[parent.length];\\n        for (int i = 0; i < parent.length; i++)\\n            children[i] = new ArrayList<>();\\n        for (int i = 1; i < parent.length; i++)\\n            children[parent[i]].add(i);\\n        dfs(children, s, 0);\\n        return res;\\n    }\\n\\n    private int dfs(ArrayList<Integer>[] children, String s, int i) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for (int j : children[i]) {\\n            int cur = dfs(children, s, j);\\n            if (s.charAt(j) != s.charAt(i))\\n                queue.offer(-cur);\\n        }\\n        int big1 = queue.isEmpty() ? 0 : -queue.poll();\\n        int big2 = queue.isEmpty() ? 0 : -queue.poll();\\n        res = Math.max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res;\\n    public int longestPath(int[] parent, String s) {\\n        res = 0;\\n        ArrayList<Integer>[] children = new ArrayList[parent.length];\\n        for (int i = 0; i < parent.length; i++)\\n            children[i] = new ArrayList<>();\\n        for (int i = 1; i < parent.length; i++)\\n            children[parent[i]].add(i);\\n        dfs(children, s, 0);\\n        return res;\\n    }\\n\\n    private int dfs(ArrayList<Integer>[] children, String s, int i) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for (int j : children[i]) {\\n            int cur = dfs(children, s, j);\\n            if (s.charAt(j) != s.charAt(i))\\n                queue.offer(-cur);\\n        }\\n        int big1 = queue.isEmpty() ? 0 : -queue.poll();\\n        int big2 = queue.isEmpty() ? 0 : -queue.poll();\\n        res = Math.max(res, big1 + big2 + 1);\\n        return big1 + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046221,
                "title": "simple-using-tree-diameter-dfs-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy intuition for this problem is to solve using example of tree with largest diameter, but the only catch here is we can add height of tree of one side if corresponding character between child and parent are different,\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will call dfs for left sub tree and right sub tree.\\nif its current character is different to both left and right child \\nthen we can assume left tree\\'s height + right tree\\'s height + 1(parent itself) will contribute in maximising length.\\nfor this we will select two max length of child\\'s thats why i used priority queue.\\nbut we return max length to parent on each step.\\n\\n# Complexity\\n- Time complexity:\\n $$O(VElogV)$$\\n\\n- Space complexity:\\n$$O(VE)$$\\n\\n# Code\\n```\\n// upvote if you understand...\\nclass Solution {\\npublic:\\n    int res = 1;\\n    int dfs(vector<int> adj[], string &str, int s, int parent){\\n        int len = 1;\\n        priority_queue<int> pq;\\n        for(auto x: adj[s]){\\n            if(x != parent){\\n                int len1 = dfs(adj, str, x, s);\\n                if(str[x] != str[s]){\\n                    pq.push(len1);\\n                }\\n            }\\n        }\\n        int one = 0, two = 0;\\n        if(pq.size() > 0){\\n            one = pq.top(); pq.pop();\\n            if(pq.size() > 0)\\n            two = pq.top(); pq.pop();\\n        }\\n        int len2 = len;\\n        len = one + two + 1;\\n        res = max(res, len);\\n        return len2 + max( one, two);\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.length();\\n        vector<int> adj[n];\\n        for(int i = 1; i < n; i++){ int x = parent[i];\\n            adj[i].push_back(x);\\n            adj[x].push_back(i);\\n        }\\n        dfs(adj, s, 0, -1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// upvote if you understand...\\nclass Solution {\\npublic:\\n    int res = 1;\\n    int dfs(vector<int> adj[], string &str, int s, int parent){\\n        int len = 1;\\n        priority_queue<int> pq;\\n        for(auto x: adj[s]){\\n            if(x != parent){\\n                int len1 = dfs(adj, str, x, s);\\n                if(str[x] != str[s]){\\n                    pq.push(len1);\\n                }\\n            }\\n        }\\n        int one = 0, two = 0;\\n        if(pq.size() > 0){\\n            one = pq.top(); pq.pop();\\n            if(pq.size() > 0)\\n            two = pq.top(); pq.pop();\\n        }\\n        int len2 = len;\\n        len = one + two + 1;\\n        res = max(res, len);\\n        return len2 + max( one, two);\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.length();\\n        vector<int> adj[n];\\n        for(int i = 1; i < n; i++){ int x = parent[i];\\n            adj[i].push_back(x);\\n            adj[x].push_back(i);\\n        }\\n        dfs(adj, s, 0, -1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046179,
                "title": "kotlin-build-graph-dfs",
                "content": "# Telegram\\nhttps://t.me/leetcode_daily_unstoppable/84\\n# Intuition\\nLongest path is a maximum sum of the two longest paths of the current node.\\n\\n# Approach\\nLet\\'s build a graph and then recursively iterate it by DFS. We need to find two largest results from the children DFS calls.\\n* make `parent[i] == i` to store a `visited` state\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, in DFS we visit each node only once.\\n- Space complexity:\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    fun longestPath(parent: IntArray, s: String): Int {\\n        val graph = mutableMapOf<Int, MutableList<Int>>()\\n        for (i in 1..parent.lastIndex) \\n            if (s[i] != s[parent[i]]) graph.getOrPut(parent[i], { mutableListOf() }) += i\\n        \\n        var maxLen = 0\\n        fun dfs(curr: Int): Int {\\n            parent[curr] = curr\\n            var max1 = 0\\n            var max2 = 0\\n            graph[curr]?.forEach { \\n                val childLen = dfs(it) \\n                if (childLen > max1) {\\n                    max2 = max1\\n                    max1 = childLen\\n                } else if (childLen > max2) max2 = childLen\\n            }\\n            val childChainLen = 1 + (max1 + max2)\\n            val childMax = 1 + max1\\n            maxLen = maxOf(maxLen, childMax, childChainLen)\\n            return childMax\\n        }\\n        for (i in 0..parent.lastIndex) if (parent[i] != i) dfs(i)\\n\\n        return maxLen\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    fun longestPath(parent: IntArray, s: String): Int {\\n        val graph = mutableMapOf<Int, MutableList<Int>>()\\n        for (i in 1..parent.lastIndex) \\n            if (s[i] != s[parent[i]]) graph.getOrPut(parent[i], { mutableListOf() }) += i\\n        \\n        var maxLen = 0\\n        fun dfs(curr: Int): Int {\\n            parent[curr] = curr\\n            var max1 = 0\\n            var max2 = 0\\n            graph[curr]?.forEach { \\n                val childLen = dfs(it) \\n                if (childLen > max1) {\\n                    max2 = max1\\n                    max1 = childLen\\n                } else if (childLen > max2) max2 = childLen\\n            }\\n            val childChainLen = 1 + (max1 + max2)\\n            val childMax = 1 + max1\\n            maxLen = maxOf(maxLen, childMax, childChainLen)\\n            return childMax\\n        }\\n        for (i in 0..parent.lastIndex) if (parent[i] != i) dfs(i)\\n\\n        return maxLen\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045776,
                "title": "simple-java-solution",
                "content": "``` \\nclass Solution {\\n    int dist[] = new int[100005];\\n    int ans = 1;    \\n    public int longestPath(int[] parent, String s) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\\n        for (int i = 0; i < parent.length; i++)\\n            adj.add(new ArrayList<Integer>());\\n        for (int i = 1; i < parent.length; i++)\\n            adj.get(parent[i]).add(i);\\n\\n        dfs(0,s,adj);         \\n        return ans;     \\n    }\\n     void dfs(int src, String s , ArrayList<ArrayList<Integer>> adj){\\n        dist[src] = 1;\\n        for(int node : adj.get(src))\\n        {\\n            dfs(node, s, adj);\\n            if(s.charAt(src) != s.charAt(node)){\\n                ans = Math.max(ans, dist[src]+dist[node]);\\n                dist[src] = Math.max(dist[src], dist[node]+1);\\n            }\\n        }\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "``` \\nclass Solution {\\n    int dist[] = new int[100005];\\n    int ans = 1;    \\n    public int longestPath(int[] parent, String s) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\\n        for (int i = 0; i < parent.length; i++)\\n            adj.add(new ArrayList<Integer>());\\n        for (int i = 1; i < parent.length; i++)\\n            adj.get(parent[i]).add(i);\\n\\n        dfs(0,s,adj);         \\n        return ans;     \\n    }\\n     void dfs(int src, String s , ArrayList<ArrayList<Integer>> adj){\\n        dist[src] = 1;\\n        for(int node : adj.get(src))\\n        {\\n            dfs(node, s, adj);\\n            if(s.charAt(src) != s.charAt(node)){\\n                ans = Math.max(ans, dist[src]+dist[node]);\\n                dist[src] = Math.max(dist[src], dist[node]+1);\\n            }\\n        }\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045762,
                "title": "c-easy-to-understand-recursive-approach",
                "content": "# Approach\\nFirst we create an adjecency list of the given tree. We then check for each child of the node and keep updating the aur result as we find the larger path. \\n\\n$$Hint:$$ Solve [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) first to get a better understanding of the problem.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 1;\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n        for(int i = 1; i < n; i++) {\\n            adj[parent[i]].push_back(i);\\n            adj[i].push_back(parent[i]);\\n        }\\n\\n        dfs(0, -1, s, adj);\\n        return ans;\\n    }\\n\\n    int dfs(int curr, int parent, string& s,     vector<vector<int>>& adj) {\\n        int maxLen = 1;\\n        for(auto child: adj[curr]) {\\n            if(child != parent) {\\n                int temp = dfs(child, curr, s, adj);\\n                if(s[curr] != s[child]) {\\n                    ans = max(ans, maxLen + temp);\\n                    maxLen = max(maxLen, 1 + temp);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 1;\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n        for(int i = 1; i < n; i++) {\\n            adj[parent[i]].push_back(i);\\n            adj[i].push_back(parent[i]);\\n        }\\n\\n        dfs(0, -1, s, adj);\\n        return ans;\\n    }\\n\\n    int dfs(int curr, int parent, string& s,     vector<vector<int>>& adj) {\\n        int maxLen = 1;\\n        for(auto child: adj[curr]) {\\n            if(child != parent) {\\n                int temp = dfs(child, curr, s, adj);\\n                if(s[curr] != s[child]) {\\n                    ans = max(ans, maxLen + temp);\\n                    maxLen = max(maxLen, 1 + temp);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045620,
                "title": "c-tree-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> &graph, int node,int &ans,string &s,int currLen, char prevChar) {\\n        vector<int> len;\\n        for(int index=0;index<graph[node].size();index++) {\\n            len.push_back(solve(graph,graph[node][index],ans,s,0,s[node]));\\n        }\\n        //cout<<len.size()<<endl;\\n        if(len.size()==0) {\\n            ans=max(ans,1);\\n            return s[node]==prevChar?0:1;\\n        }\\n        else if(len.size()==1) {\\n            ans=max(ans,len[0]+1);\\n            return s[node]==prevChar?0:len[0]+1;\\n        }\\n        \\n        sort(len.begin(),len.end(),greater<int>());\\n        ans=max(ans,len[0]+len[1]+1);\\n        return s[node]==prevChar?0:max(len[0],len[1])+1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size(),ans=0;\\n        vector<vector<int>> graph(n,vector<int>());\\n\\n        for(int index=1;index<n;index++) {\\n            graph[parent[index]].push_back(index);\\n        }\\n\\n        solve(graph,0,ans,s,0,\\'1\\');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> &graph, int node,int &ans,string &s,int currLen, char prevChar) {\\n        vector<int> len;\\n        for(int index=0;index<graph[node].size();index++) {\\n            len.push_back(solve(graph,graph[node][index],ans,s,0,s[node]));\\n        }\\n        //cout<<len.size()<<endl;\\n        if(len.size()==0) {\\n            ans=max(ans,1);\\n            return s[node]==prevChar?0:1;\\n        }\\n        else if(len.size()==1) {\\n            ans=max(ans,len[0]+1);\\n            return s[node]==prevChar?0:len[0]+1;\\n        }\\n        \\n        sort(len.begin(),len.end(),greater<int>());\\n        ans=max(ans,len[0]+len[1]+1);\\n        return s[node]==prevChar?0:max(len[0],len[1])+1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size(),ans=0;\\n        vector<vector<int>> graph(n,vector<int>());\\n\\n        for(int index=1;index<n;index++) {\\n            graph[parent[index]].push_back(index);\\n        }\\n\\n        solve(graph,0,ans,s,0,\\'1\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3045482,
                "title": "easy-to-understand-java-soln-dfs-o-n",
                "content": "# Please Upvote my solution if you like \\uD83D\\uDC4D\\u2B06\\n# Code\\n```\\nclass Solution {\\n    static int max=1;\\n    public static int dfs(int node,ArrayList<Integer> [] graph,String s){\\n        int sum=1;\\n        int tempMax1=0,tempMax2=0;\\n        \\n        for(int val : graph[node]){\\n            int temp=0;\\n            temp = dfs(val,graph,s);\\n        \\n            if(s.charAt(node)!=s.charAt(val)){        \\n                if(temp>tempMax1){\\n                    tempMax2=tempMax1;\\n                    tempMax1=temp;\\n                }else if(tempMax2<temp){\\n                    tempMax2 = temp;\\n                }\\n            }\\n        }\\n\\n        sum+=tempMax1+tempMax2;\\n        max=Math.max(max,sum);\\n        return tempMax1+1;\\n    }\\n    \\n\\n    public int longestPath(int[] parent, String s) {\\n\\n        ArrayList<Integer> [] arr = new ArrayList[parent.length];\\n\\n        System.out.println(parent.length);\\n\\n        for(int i=0;i<arr.length;i++){\\n            arr[i] = new ArrayList<Integer>();\\n        }   \\n\\n        for(int i=1;i<parent.length;i++){\\n            arr[parent[i]].add(i);\\n        }\\n\\n        max=1;\\n        dfs(0,arr,s);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    static int max=1;\\n    public static int dfs(int node,ArrayList<Integer> [] graph,String s){\\n        int sum=1;\\n        int tempMax1=0,tempMax2=0;\\n        \\n        for(int val : graph[node]){\\n            int temp=0;\\n            temp = dfs(val,graph,s);\\n        \\n            if(s.charAt(node)!=s.charAt(val)){        \\n                if(temp>tempMax1){\\n                    tempMax2=tempMax1;\\n                    tempMax1=temp;\\n                }else if(tempMax2<temp){\\n                    tempMax2 = temp;\\n                }\\n            }\\n        }\\n\\n        sum+=tempMax1+tempMax2;\\n        max=Math.max(max,sum);\\n        return tempMax1+1;\\n    }\\n    \\n\\n    public int longestPath(int[] parent, String s) {\\n\\n        ArrayList<Integer> [] arr = new ArrayList[parent.length];\\n\\n        System.out.println(parent.length);\\n\\n        for(int i=0;i<arr.length;i++){\\n            arr[i] = new ArrayList<Integer>();\\n        }   \\n\\n        for(int i=1;i<parent.length;i++){\\n            arr[parent[i]].add(i);\\n        }\\n\\n        max=1;\\n        dfs(0,arr,s);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045376,
                "title": "unique-solution-o-n-using-tree-diameter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf two adjacent nodes have same character then we can not consider them in the longest path.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf two adjacent nodes have same character then exculde them from the adjaceny list. It will create some disconnected trees.\\n\\nFor every disconnected tree we calculate the diameter.\\nSo, the answer would be largest diameter+1.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define pii pair<int,int> \\n     pii bfs(int s,vector<int> adj[],vector<int>& dis, vector<int> &vis,vector<int> &parent) {\\n        queue<int> q;\\n        q.push(s);\\n        vis[s] = 1;\\n        pii mx;\\n        mx.first = 0;\\n        mx.second = s;\\n        dis[s] = 0;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto v: adj[u]) {\\n                if(!vis[v]) {\\n                    dis[v] = dis[u] + 1;\\n                    vis[v] = 1;\\n                    q.push(v);\\n                    if(dis[v]>=mx.first){\\n                        mx.first = dis[v];\\n                        mx.second = v;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return mx;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        vector<int> dis(n,0);\\n        vector<int> vis(n,0);\\n        vector<int> vis1(n,0);\\n        for(int i=1;i<parent.size();i++) {\\n            if(s[i] != s[parent[i]]) {   // If adjacent nodes have different characters then include in the adjacency list otherwise don\\'t.\\n                adj[i].push_back(parent[i]);\\n                adj[parent[i]].push_back(i);\\n            }\\n        }\\n\\n        int mx = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            // Two BFS to calculate tree diameter\\n            pii root = bfs(i,adj,dis,vis,parent);   \\n            pii ans = bfs(root.second,adj,dis,vis1,parent);\\n\\n            // Maximum tree diameter\\n            mx = max(mx,ans.first);\\n        }\\n\\n        return mx+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pii pair<int,int> \\n     pii bfs(int s,vector<int> adj[],vector<int>& dis, vector<int> &vis,vector<int> &parent) {\\n        queue<int> q;\\n        q.push(s);\\n        vis[s] = 1;\\n        pii mx;\\n        mx.first = 0;\\n        mx.second = s;\\n        dis[s] = 0;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto v: adj[u]) {\\n                if(!vis[v]) {\\n                    dis[v] = dis[u] + 1;\\n                    vis[v] = 1;\\n                    q.push(v);\\n                    if(dis[v]>=mx.first){\\n                        mx.first = dis[v];\\n                        mx.second = v;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return mx;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        vector<int> dis(n,0);\\n        vector<int> vis(n,0);\\n        vector<int> vis1(n,0);\\n        for(int i=1;i<parent.size();i++) {\\n            if(s[i] != s[parent[i]]) {   // If adjacent nodes have different characters then include in the adjacency list otherwise don\\'t.\\n                adj[i].push_back(parent[i]);\\n                adj[parent[i]].push_back(i);\\n            }\\n        }\\n\\n        int mx = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            // Two BFS to calculate tree diameter\\n            pii root = bfs(i,adj,dis,vis,parent);   \\n            pii ans = bfs(root.second,adj,dis,vis1,parent);\\n\\n            // Maximum tree diameter\\n            mx = max(mx,ans.first);\\n        }\\n\\n        return mx+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045363,
                "title": "simple-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dis[100000];\\n    int ans=1;\\n    void dfs(int src,vector<int>*arr,string &s )\\n    {\\n        dis[src]=1;\\n        for(auto x:arr[src])\\n        {\\n            dfs(x,arr,s);\\n            if(s[src]!=s[x])\\n            {\\n                ans=max(ans,dis[src]+dis[x]);\\n                dis[src]=max(dis[src],dis[x]+1);\\n            }\\n        }\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        vector<int>arr[n];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(parent[i]!=-1)\\n            arr[parent[i]].push_back(i);\\n        }\\n        dfs(0,arr,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dis[100000];\\n    int ans=1;\\n    void dfs(int src,vector<int>*arr,string &s )\\n    {\\n        dis[src]=1;\\n        for(auto x:arr[src])\\n        {\\n            dfs(x,arr,s);\\n            if(s[src]!=s[x])\\n            {\\n                ans=max(ans,dis[src]+dis[x]);\\n                dis[src]=max(dis[src],dis[x]+1);\\n            }\\n        }\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        vector<int>arr[n];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(parent[i]!=-1)\\n            arr[parent[i]].push_back(i);\\n        }\\n        dfs(0,arr,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045343,
                "title": "easy-solution-c-optimised-tree-dfs",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> adjList; // globally defining adjacency List\\n    int ans=1; // to store the answer\\n\\n    int dfs(int node,int parent,string &s){\\n       // to store maximum length upto that node including it so initialize it with 1\\n       int maxLength=1;\\n\\n       for(auto x : adjList[node]){\\n       // check only for children\\n        if(x!=parent){\\n          int temp = dfs(x,node,s);\\n\\n          // if parent character and it\\'s child character is not equal\\n          if(s[node]!=s[x]){\\n            // update the ans with maximum value\\n            // update the maxLength to return  to its parent.\\n            ans = max(ans,maxLength+temp);\\n            maxLength = max(maxLength,1+temp);\\n          }\\n        }\\n       }\\n      // return  maxLength for current node\\n      return  maxLength;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        adjList.resize(n);\\n\\n        // create adjacency List\\n         for(int i=1; i<n; i++){\\n             adjList[parent[i]].push_back(i);\\n             adjList[i].push_back(parent[i]);\\n         }\\n         // call dfs\\n         dfs(0,-1,s);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> adjList; // globally defining adjacency List\\n    int ans=1; // to store the answer\\n\\n    int dfs(int node,int parent,string &s){\\n       // to store maximum length upto that node including it so initialize it with 1\\n       int maxLength=1;\\n\\n       for(auto x : adjList[node]){\\n       // check only for children\\n        if(x!=parent){\\n          int temp = dfs(x,node,s);\\n\\n          // if parent character and it\\'s child character is not equal\\n          if(s[node]!=s[x]){\\n            // update the ans with maximum value\\n            // update the maxLength to return  to its parent.\\n            ans = max(ans,maxLength+temp);\\n            maxLength = max(maxLength,1+temp);\\n          }\\n        }\\n       }\\n      // return  maxLength for current node\\n      return  maxLength;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        adjList.resize(n);\\n\\n        // create adjacency List\\n         for(int i=1; i<n; i++){\\n             adjList[parent[i]].push_back(i);\\n             adjList[i].push_back(parent[i]);\\n         }\\n         // call dfs\\n         dfs(0,-1,s);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045228,
                "title": "dfs-beats-95-simple",
                "content": "# Code\\n```\\nint util(vector<vector<int>>&tree,int src,string&s,int &ans,vector<int>&parent){\\n    int sum=0,mx=0,second_mx=0;\\n    for(auto&x:tree[src]){\\n        int curr=util(tree,x,s,ans,parent);\\n        if(curr>=mx){\\n            second_mx=mx;\\n            mx=curr;\\n        }\\n        else if(curr>second_mx) second_mx=curr;\\n    }\\n    ans=max(ans,1+mx+second_mx);\\n    if(src)\\n    return (s[src]!=s[parent[src]])?1+mx:0;\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n       int n=s.length();\\n       vector<vector<int>>tree(n);\\n       for(int i=1;i<n;i++){\\n           tree[parent[i]].push_back(i);\\n       }\\n       int ans=0;\\n       return util(tree,0,s,ans,parent); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nint util(vector<vector<int>>&tree,int src,string&s,int &ans,vector<int>&parent){\\n    int sum=0,mx=0,second_mx=0;\\n    for(auto&x:tree[src]){\\n        int curr=util(tree,x,s,ans,parent);\\n        if(curr>=mx){\\n            second_mx=mx;\\n            mx=curr;\\n        }\\n        else if(curr>second_mx) second_mx=curr;\\n    }\\n    ans=max(ans,1+mx+second_mx);\\n    if(src)\\n    return (s[src]!=s[parent[src]])?1+mx:0;\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n       int n=s.length();\\n       vector<vector<int>>tree(n);\\n       for(int i=1;i<n;i++){\\n           tree[parent[i]].push_back(i);\\n       }\\n       int ans=0;\\n       return util(tree,0,s,ans,parent); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045224,
                "title": "cpp-approach-graph",
                "content": "the recursive function returns the straight paths from that node and the paths is global that contains path length as the answer, use the maximum2lengths returned by recursive and add the +1 for the node and store it in global maximum answer and to return the value for the recursive function return maximumpath of the edges nodes and add 1 for the node \\n# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(v+e)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint pp(int starts,vector<int>&visit,int& paths,vector<int> graph[],string& ll){\\n    visit[starts]++;\\n    int paths2=0;\\n    int ll22=1;\\n    int max1=0,max2=0;\\n    for(int po=0;po<graph[starts].size();po++){\\n        if(visit[graph[starts][po]]==0){\\n            int ll2=pp(graph[starts][po],visit,paths,graph,ll);\\n        // paths=max(paths,ll2);\\n        if(ll[starts]!=ll[graph[starts][po]])\\n        {\\npaths2=max(paths2,ll2);\\nif(ll2>=max1){\\n    max2=max1;\\n    max1=ll2;\\n}\\nelse if(ll2<max1&&ll2>max2){\\nmax2=ll2;\\n}\\n// ll22+=ll2;\\n        }}\\n    }\\n    ll22+=(max2+max1);\\n    paths=max(paths,ll22);\\nreturn paths2+1;\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n       int ll=parent.size();\\n       vector<int> graph[ll];\\n       for(int p=0;p<ll;p++){\\n           if(parent[p]<0)\\n           {}\\n           else\\n        graph[parent[p]].push_back(p);\\n       } \\n       map<char,int> pp;\\n       int path=0;\\n        vector<int> visit(ll);\\n        int ll2=pp(0,visit,path,graph,s);\\n       return path;}\\n       };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint pp(int starts,vector<int>&visit,int& paths,vector<int> graph[],string& ll){\\n    visit[starts]++;\\n    int paths2=0;\\n    int ll22=1;\\n    int max1=0,max2=0;\\n    for(int po=0;po<graph[starts].size();po++){\\n        if(visit[graph[starts][po]]==0){\\n            int ll2=pp(graph[starts][po],visit,paths,graph,ll);\\n        // paths=max(paths,ll2);\\n        if(ll[starts]!=ll[graph[starts][po]])\\n        {\\npaths2=max(paths2,ll2);\\nif(ll2>=max1){\\n    max2=max1;\\n    max1=ll2;\\n}\\nelse if(ll2<max1&&ll2>max2){\\nmax2=ll2;\\n}\\n// ll22+=ll2;\\n        }}\\n    }\\n    ll22+=(max2+max1);\\n    paths=max(paths,ll22);\\nreturn paths2+1;\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n       int ll=parent.size();\\n       vector<int> graph[ll];\\n       for(int p=0;p<ll;p++){\\n           if(parent[p]<0)\\n           {}\\n           else\\n        graph[parent[p]].push_back(p);\\n       } \\n       map<char,int> pp;\\n       int path=0;\\n        vector<int> visit(ll);\\n        int ll2=pp(0,visit,path,graph,s);\\n       return path;}\\n       };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044981,
                "title": "c-dfs-similar-to-max-path-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 1;\\n    int dfs(vector<vector<int>> &adj, string &str, int curr, int parent){\\n        int par = 1;\\n        for(auto nbr : adj[curr]){\\n            if(nbr == parent) continue;\\n            int child = dfs(adj, str, nbr, curr);\\n            if(str[curr] != str[nbr]){\\n                ans = max(ans, par + child);\\n                par = max(par, 1 + child);\\n            }\\n        }\\n        return par;\\n    }\\n    \\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        vector<vector<int>> adj(n);\\n        for(int i = 1; i < parent.size(); i++){\\n            adj[i].push_back(parent[i]);\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(adj, s, 0, -1);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int ans = 1;\\n    int dfs(vector<vector<int>> &adj, string &str, int curr, int parent){\\n        int par = 1;\\n        for(auto nbr : adj[curr]){\\n            if(nbr == parent) continue;\\n            int child = dfs(adj, str, nbr, curr);\\n            if(str[curr] != str[nbr]){\\n                ans = max(ans, par + child);\\n                par = max(par, 1 + child);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3044966,
                "title": "python-short-and-simple-dfs",
                "content": "\\n# Approach\\nParse the `parent` list into a `tree` represented in adjacency list.\\n\\nDefine a recursive DFS function, called `l_path_and_chain` which takes a given `root` and returns the `longest_path_len` and `longest_chain_len` of the corresponding subtree.\\n\\n`longest_path_len` of a subtree rooted at `R` is the longest path with no adjacent nodes having same character, exactly as defined in the question, which may or may not pass through `R`.\\n\\n`longest_chain_len` of a subtree rooted at `R` is the longest path with no adjacent nodes having same character, wherein the path must start from `R`, aka `chain`\\n\\nFor the `l_path_and_chain` of a given `root`:\\n- Recursively get `paths` and `chains` of all it\\'s children.\\n- `longest_path` for `root` is the longest of:\\n    - Longest children `paths`\\n    - Longest 2 children `chains` + 1 (to count the `root`)\\n- `longest_chain` for `root` is the longest children `chain` + 1 (to count the `root`).\\n\\nNote: Make sure to filter children `chains` with same character as parent.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python\\nclass Solution:\\n    def longestPath(self, parent: list[int], s: str) -> int:\\n        def l_path_and_chain(tree: dict[int, list[int]], s: str, root: int) -> tuple[int, int]:\\n            lp = lc1 = lc2 = 0\\n            for child, path, chain in ((c, *l_path_and_chain(tree, s, c)) for c in tree[root]):\\n                lp = max(lp, path)\\n                if s[child] != s[root]: *_, lc2, lc1 = sorted((chain, lc2, lc1))\\n\\n            return max(lp, lc1 + lc2 + 1), lc1 + 1\\n\\n        t = defaultdict(list)\\n        for c, p in enumerate(parent): t[p].append(c)\\n        return l_path_and_chain(t, s, 0)[0]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def longestPath(self, parent: list[int], s: str) -> int:\\n        def l_path_and_chain(tree: dict[int, list[int]], s: str, root: int) -> tuple[int, int]:\\n            lp = lc1 = lc2 = 0\\n            for child, path, chain in ((c, *l_path_and_chain(tree, s, c)) for c in tree[root]):\\n                lp = max(lp, path)\\n                if s[child] != s[root]: *_, lc2, lc1 = sorted((chain, lc2, lc1))\\n\\n            return max(lp, lc1 + lc2 + 1), lc1 + 1\\n\\n        t = defaultdict(list)\\n        for c, p in enumerate(parent): t[p].append(c)\\n        return l_path_and_chain(t, s, 0)[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044951,
                "title": "python-solution-with-easy-and-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:73.48\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:74\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        \\n        hights=[1 for i in range(len(parent))]\\n        ans=[1 for i in range(len(parent))]\\n\\n        adj=[[] for i in range(len(parent))]\\n        for i in range(len(parent)):\\n            if(parent[i]!=-1):\\n                adj[i].append(parent[i])\\n                adj[parent[i]].append(i)\\n        \\n        def dfs(node,parent):\\n            first=0\\n            second=0\\n            for i in adj[node]:\\n                if(i!=parent):\\n                    dfs(i,node)\\n                    if(s[i]!=s[node]):\\n                        if(hights[i]>first):\\n                            second=first\\n                            first=hights[i]\\n                            \\n                        elif(hights[i]>second):\\n                            second=hights[i]\\n                        \\n                        \\n                        ans[node]=max(first+second+1,ans[node])\\n                    ans[node]=max(ans[node],ans[i])\\n            hights[node]+=first\\n            return ans[node]\\n        \\n        a=dfs(0,-1)\\n        print(ans)\\n        print(hights)\\n        return a\\n                            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        \\n        hights=[1 for i in range(len(parent))]\\n        ans=[1 for i in range(len(parent))]\\n\\n        adj=[[] for i in range(len(parent))]\\n        for i in range(len(parent)):\\n            if(parent[i]!=-1):\\n                adj[i].append(parent[i])\\n                adj[parent[i]].append(i)\\n        \\n        def dfs(node,parent):\\n            first=0\\n            second=0\\n            for i in adj[node]:\\n                if(i!=parent):\\n                    dfs(i,node)\\n                    if(s[i]!=s[node]):\\n                        if(hights[i]>first):\\n                            second=first\\n                            first=hights[i]\\n                            \\n                        elif(hights[i]>second):\\n                            second=hights[i]\\n                        \\n                        \\n                        ans[node]=max(first+second+1,ans[node])\\n                    ans[node]=max(ans[node],ans[i])\\n            hights[node]+=first\\n            return ans[node]\\n        \\n        a=dfs(0,-1)\\n        print(ans)\\n        print(hights)\\n        return a\\n                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044781,
                "title": "c-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<vector<int>> graph;\\n    \\n    int dfs(int x,vector<vector<int>> &g,string &s){\\n        priority_queue<int> pq;\\n        int tempAns=1,dfsAns=1,temp;\\n        \\n        for(int y: g[x]){\\n            temp= dfs(y,g,s);\\n            if(s[x]!= s[y]) pq.push(temp);\\n        }\\n        \\n        if(!pq.empty()) {\\n            tempAns+= pq.top();\\n            dfsAns+= pq.top();\\n            pq.pop();\\n        }\\n        \\n        if(!pq.empty()) {\\n            tempAns+= pq.top();\\n            pq.pop();\\n        }\\n        \\n        ans= max(ans,tempAns);\\n        \\n        return dfsAns;\\n    }\\n    \\n    \\n    \\n    int longestPath(vector<int>& par, string s) {\\n        graph.resize(par.size());\\n        for(int i=1;i< par.size();i++){\\n            graph[par[i]].push_back(i);\\n        }\\n        \\n        dfs(0,graph, s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Memoization",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<vector<int>> graph;\\n    \\n    int dfs(int x,vector<vector<int>> &g,string &s){\\n        priority_queue<int> pq;\\n        int tempAns=1,dfsAns=1,temp;\\n        \\n        for(int y: g[x]){\\n            temp= dfs(y,g,s);\\n            if(s[x]!= s[y]) pq.push(temp);\\n        }\\n        \\n        if(!pq.empty()) {\\n            tempAns+= pq.top();\\n            dfsAns+= pq.top();\\n            pq.pop();\\n        }\\n        \\n        if(!pq.empty()) {\\n            tempAns+= pq.top();\\n            pq.pop();\\n        }\\n        \\n        ans= max(ans,tempAns);\\n        \\n        return dfsAns;\\n    }\\n    \\n    \\n    \\n    int longestPath(vector<int>& par, string s) {\\n        graph.resize(par.size());\\n        for(int i=1;i< par.size();i++){\\n            graph[par[i]].push_back(i);\\n        }\\n        \\n        dfs(0,graph, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044670,
                "title": "python-super-easy-brute-force-dfs-cache",
                "content": "```python\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        g = defaultdict(list)\\n        \\n        for i, p in enumerate(parent):\\n            if i == 0:\\n                continue\\n            g[i].append(p)\\n            g[p].append(i)\\n        \\n        @cache\\n        def dfs(i, p):\\n            r = 0\\n            for j in g[i]:\\n                if j == p:\\n                    continue\\n                if s[i] == s[j]:\\n                    continue\\n\\n                r = max(r, dfs(j, i) + 1)\\n            \\n            return r\\n        \\n        if len(s) == 1:\\n            return 1\\n\\n        return max(dfs(k, -1) for k in g) + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        g = defaultdict(list)\\n        \\n        for i, p in enumerate(parent):\\n            if i == 0:\\n                continue\\n            g[i].append(p)\\n            g[p].append(i)\\n        \\n        @cache\\n        def dfs(i, p):\\n            r = 0\\n            for j in g[i]:\\n                if j == p:\\n                    continue\\n                if s[i] == s[j]:\\n                    continue\\n\\n                r = max(r, dfs(j, i) + 1)\\n            \\n            return r\\n        \\n        if len(s) == 1:\\n            return 1\\n\\n        return max(dfs(k, -1) for k in g) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044647,
                "title": "easy-and-concise-c",
                "content": "# Intuition\\nsimilar to finding max sum path in tree\\n\\n# Approach\\nusing dfs \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans;\\nint dfs(vector<vector<int>>&adj,int node,string &s)\\n{\\n    //cout<<node<<endl;\\n    int res=1,res1=0;\\n    vector<int>v;\\n    for(int i=0;i<adj[node].size();i++)\\n    {\\n        int x=dfs(adj,adj[node][i],s);\\n        //cout<<nodes[adj[node][i]]<<\"pom\"<<endl; \\n        if(s[adj[node][i]]!=s[node])\\n        v.push_back(x);\\n    }\\n    if(v.size()==0)\\n    return 1;\\n    sort(v.begin(),v.end());\\n    reverse(v.begin(),v.end());\\n    if(v.size()==1)\\n        res+=v[0];\\n    else\\n    {\\n        res1=v[0]+v[1]+1;\\n        res+=v[0];\\n        int val=max(res1,res);\\n        ans=max(ans,val);\\n    }\\n       ans=max(ans,res);\\n    return res;\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        ans=0;\\n        int n=parent.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n        //vector<int>nodes(n,0);\\n        int x=dfs(adj,0,s);\\n        if(ans==0)\\n        ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans;\\nint dfs(vector<vector<int>>&adj,int node,string &s)\\n{\\n    //cout<<node<<endl;\\n    int res=1,res1=0;\\n    vector<int>v;\\n    for(int i=0;i<adj[node].size();i++)\\n    {\\n        int x=dfs(adj,adj[node][i],s);\\n        //cout<<nodes[adj[node][i]]<<\"pom\"<<endl; \\n        if(s[adj[node][i]]!=s[node])\\n        v.push_back(x);\\n    }\\n    if(v.size()==0)\\n    return 1;\\n    sort(v.begin(),v.end());\\n    reverse(v.begin(),v.end());\\n    if(v.size()==1)\\n        res+=v[0];\\n    else\\n    {\\n        res1=v[0]+v[1]+1;\\n        res+=v[0];\\n        int val=max(res1,res);\\n        ans=max(ans,val);\\n    }\\n       ans=max(ans,res);\\n    return res;\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        ans=0;\\n        int n=parent.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n        //vector<int>nodes(n,0);\\n        int x=dfs(adj,0,s);\\n        if(ans==0)\\n        ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3044622,
                "title": "javascript-depth-first-search-comments",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} parent\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestPath = function(parent, s) {\\n    let longestPath = 1; // Initialize return value for longest path\\n    const graph = new Map(); // Initialize map for graph\\n    for (let i = 1; i < parent.length; i++) { // Loop 0-indexed array\\n        if (!graph.has(parent[i])) graph.set(parent[i], []); // Initialize empty array if undefined\\n        graph.get(parent[i]).push(i); // Push value to array\\n    }\\n\\n    const dfs = (current) => { // DFS algorithm\\n        if (!graph.has(current)) return 1; // Return 1 if not defined\\n        let longest = 0; // Initialize longest variable\\n        let secondLongest = 0; // Initialize second longest variable\\n\\t\\tfor (const child of graph.get(current)) { // Loop childs of current node\\n\\t\\t\\tconst longestFromChild = dfs(child); // Get longest from child\\n\\t\\t\\tif (s[current] != s[child]) { // Check if node have different characters\\n\\t\\t\\t\\tif (longestFromChild > longest) { // Check if longestFromChild is bigger than current longest\\n\\t\\t\\t\\t\\tsecondLongest = longest; // Set longest to second longest\\n\\t\\t\\t\\t\\tlongest = longestFromChild; // Set longest to longestFromChild\\n\\t\\t\\t\\t} else if (longestFromChild > secondLongest) { // Check if longestFromChild is bigger than secondLongest\\n\\t\\t\\t\\t\\tsecondLongest = longestFromChild; // Set secondLongest to longestFromChild\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlongestPath = Math.max(longestPath, longest + secondLongest + 1); // Set longest path \\n\\t\\treturn longest + 1; // Return longest of current plus one\\n    }\\n    dfs(0); // Start DFS\\n    return longestPath; // Return longest path variable\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} parent\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestPath = function(parent, s) {\\n    let longestPath = 1; // Initialize return value for longest path\\n    const graph = new Map(); // Initialize map for graph\\n    for (let i = 1; i < parent.length; i++) { // Loop 0-indexed array\\n        if (!graph.has(parent[i])) graph.set(parent[i], []); // Initialize empty array if undefined\\n        graph.get(parent[i]).push(i); // Push value to array\\n    }\\n\\n    const dfs = (current) => { // DFS algorithm\\n        if (!graph.has(current)) return 1; // Return 1 if not defined\\n        let longest = 0; // Initialize longest variable\\n        let secondLongest = 0; // Initialize second longest variable\\n\\t\\tfor (const child of graph.get(current)) { // Loop childs of current node\\n\\t\\t\\tconst longestFromChild = dfs(child); // Get longest from child\\n\\t\\t\\tif (s[current] != s[child]) { // Check if node have different characters\\n\\t\\t\\t\\tif (longestFromChild > longest) { // Check if longestFromChild is bigger than current longest\\n\\t\\t\\t\\t\\tsecondLongest = longest; // Set longest to second longest\\n\\t\\t\\t\\t\\tlongest = longestFromChild; // Set longest to longestFromChild\\n\\t\\t\\t\\t} else if (longestFromChild > secondLongest) { // Check if longestFromChild is bigger than secondLongest\\n\\t\\t\\t\\t\\tsecondLongest = longestFromChild; // Set secondLongest to longestFromChild\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlongestPath = Math.max(longestPath, longest + secondLongest + 1); // Set longest path \\n\\t\\treturn longest + 1; // Return longest of current plus one\\n    }\\n    dfs(0); // Start DFS\\n    return longestPath; // Return longest path variable\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3044566,
                "title": "two-deepest-paths-among-children",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestPath(self, parent, s):\\n        G = defaultdict(list)\\n        for i, p in enumerate(parent):\\n            G[p].append(i)\\n        del G[-1]\\n        \\n        def dfs(u):\\n            a, b = 0, 0\\n            for v in G[u]:\\n                tmp = dfs(v)\\n                if s[u] == s[v]: continue # detach path\\n                if tmp > a: a, b = tmp, a\\n                elif tmp > b: b = tmp\\n            self.ans = max(self.ans, a+b+1)\\n            return a + 1\\n        \\n        self.ans = 0\\n        dfs(0)\\n        return self.ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent, s):\\n        G = defaultdict(list)\\n        for i, p in enumerate(parent):\\n            G[p].append(i)\\n        del G[-1]\\n        \\n        def dfs(u):\\n            a, b = 0, 0\\n            for v in G[u]:\\n                tmp = dfs(v)\\n                if s[u] == s[v]: continue # detach path\\n                if tmp > a: a, b = tmp, a\\n                elif tmp > b: b = tmp\\n            self.ans = max(self.ans, a+b+1)\\n            return a + 1\\n        \\n        self.ans = 0\\n        dfs(0)\\n        return self.ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044548,
                "title": "c-easy-solution-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tvector<int> adj[100001];\\n\\tint ans;\\n\\tint dfs(string& s, int node) {\\n\\t\\tint maxi = 0, sMaxi = 0;\\n\\t\\tfor (auto &e : adj[node]) {\\n\\t\\t\\tint cur = dfs(s, e);\\n\\t\\t\\tif (s[node] != s[e]) {\\n\\t\\t\\t\\tsMaxi = max(cur, sMaxi);\\n\\t\\t\\t\\tif (sMaxi > maxi) swap(sMaxi, maxi);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans = max(ans, maxi + sMaxi + 1);\\n\\t\\treturn maxi + 1;\\n\\t}\\npublic:\\n\\tint longestPath(vector<int>& a, string s) {\\n\\t\\tint n = s.size();\\n\\t\\tfor (int i = 1; i < n; ++i)\\n\\t\\t\\tadj[a[i]].push_back(i);\\n\\t\\tdfs(s, 0);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tvector<int> adj[100001];\\n\\tint ans;\\n\\tint dfs(string& s, int node) {\\n\\t\\tint maxi = 0, sMaxi = 0;\\n\\t\\tfor (auto &e : adj[node]) {\\n\\t\\t\\tint cur = dfs(s, e);\\n\\t\\t\\tif (s[node] != s[e]) {\\n\\t\\t\\t\\tsMaxi = max(cur, sMaxi);\\n\\t\\t\\t\\tif (sMaxi > maxi) swap(sMaxi, maxi);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans = max(ans, maxi + sMaxi + 1);\\n\\t\\treturn maxi + 1;\\n\\t}\\npublic:\\n\\tint longestPath(vector<int>& a, string s) {\\n\\t\\tint n = s.size();\\n\\t\\tfor (int i = 1; i < n; ++i)\\n\\t\\t\\tadj[a[i]].push_back(i);\\n\\t\\tdfs(s, 0);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044375,
                "title": "java-solution-graph-dfs-tc-o-e-v-sc-o-v-e-o-v",
                "content": "```\\nclass Solution {\\n    \\n    public class Graph {\\n\\t\\tprivate int v;\\n\\t\\tprivate char[] labels;\\n\\t\\tprivate ArrayList<ArrayList<Integer>> adj;\\n\\n\\t\\tprivate int longestPath;\\n\\n\\t\\tpublic Graph(int v, char[] labels) {\\n\\t\\t\\tthis.v = v;\\n\\t\\t\\tthis.labels = labels;\\n\\t\\t\\tthis.adj = new ArrayList<>(this.v);\\n\\t\\t\\tfor (int i = 0; i < this.v; i++) {\\n\\t\\t\\t\\tthis.adj.add(new ArrayList<Integer>());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void addEdge(int u, int v) {\\n\\t\\t\\tadj.get(u).add(v);\\n\\t\\t}\\n\\n\\t\\tpublic int dfsUtil(int parent) {\\n\\t\\t\\tint large = Integer.MIN_VALUE;\\n\\t\\t\\tint secondLarge = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int child : adj.get(parent)) {\\n\\t\\t\\t\\tint childMax = dfsUtil(child);\\n                if (labels[parent] == labels[child]) {\\n                    continue;\\n                }\\n\\t\\t\\t\\tif (labels[parent] != labels[child]) {\\n\\t\\t\\t\\t\\tif (childMax > large) {\\n\\t\\t\\t\\t\\t\\tsecondLarge = large;\\n\\t\\t\\t\\t\\t\\tlarge = childMax;\\n\\t\\t\\t\\t\\t} else if (childMax > secondLarge) {\\n\\t\\t\\t\\t\\t\\tsecondLarge = childMax;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlongestPath = Math.max(longestPath, large + secondLarge + 1);\\n\\t\\t\\treturn large + 1;\\n\\t\\t}\\n\\n\\t\\tpublic void dfs() {\\n\\t\\t\\tdfsUtil(0);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int longestPath(int[] parent, String s) {\\n\\t\\tGraph graph = new Graph(parent.length, s.toCharArray());\\n\\t\\tfor (int i = 0; i < parent.length; i++) {\\n\\t\\t\\tif (parent[i] != -1) {\\n\\t\\t\\t\\tgraph.addEdge(parent[i], i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgraph.dfs();\\n\\t\\treturn graph.longestPath;\\n\\t}\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class Graph {\\n\\t\\tprivate int v;\\n\\t\\tprivate char[] labels;\\n\\t\\tprivate ArrayList<ArrayList<Integer>> adj;\\n\\n\\t\\tprivate int longestPath;\\n\\n\\t\\tpublic Graph(int v, char[] labels) {\\n\\t\\t\\tthis.v = v;\\n\\t\\t\\tthis.labels = labels;\\n\\t\\t\\tthis.adj = new ArrayList<>(this.v);\\n\\t\\t\\tfor (int i = 0; i < this.v; i++) {\\n\\t\\t\\t\\tthis.adj.add(new ArrayList<Integer>());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void addEdge(int u, int v) {\\n\\t\\t\\tadj.get(u).add(v);\\n\\t\\t}\\n\\n\\t\\tpublic int dfsUtil(int parent) {\\n\\t\\t\\tint large = Integer.MIN_VALUE;\\n\\t\\t\\tint secondLarge = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int child : adj.get(parent)) {\\n\\t\\t\\t\\tint childMax = dfsUtil(child);\\n                if (labels[parent] == labels[child]) {\\n                    continue;\\n                }\\n\\t\\t\\t\\tif (labels[parent] != labels[child]) {\\n\\t\\t\\t\\t\\tif (childMax > large) {\\n\\t\\t\\t\\t\\t\\tsecondLarge = large;\\n\\t\\t\\t\\t\\t\\tlarge = childMax;\\n\\t\\t\\t\\t\\t} else if (childMax > secondLarge) {\\n\\t\\t\\t\\t\\t\\tsecondLarge = childMax;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlongestPath = Math.max(longestPath, large + secondLarge + 1);\\n\\t\\t\\treturn large + 1;\\n\\t\\t}\\n\\n\\t\\tpublic void dfs() {\\n\\t\\t\\tdfsUtil(0);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int longestPath(int[] parent, String s) {\\n\\t\\tGraph graph = new Graph(parent.length, s.toCharArray());\\n\\t\\tfor (int i = 0; i < parent.length; i++) {\\n\\t\\t\\tif (parent[i] != -1) {\\n\\t\\t\\t\\tgraph.addEdge(parent[i], i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tgraph.dfs();\\n\\t\\treturn graph.longestPath;\\n\\t}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044302,
                "title": "c-dfs-using-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node, int prevNode, vector<vector<int>>& graph, int& ans, string& s) {\\n        int maxLen = 1;\\n        for(auto& nextNode : graph[node]) {\\n            if(prevNode == nextNode)\\n                continue;\\n            int tmp = dfs(nextNode, node, graph, ans, s);\\n            if(s[node] != s[nextNode]) {\\n                ans = max(ans, maxLen + tmp); //update ans with longest path\\n                maxLen = max(maxLen, 1 + tmp); //update maxpath length of child\\n            }\\n        }\\n        return maxLen;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        vector<vector<int>> graph(n);\\n        for(int i = 1; i < n; i++) {\\n            graph[parent[i]].push_back(i);\\n            graph[i].push_back(parent[i]);\\n        }\\n        int ans = 1;\\n        dfs(0, -1, graph, ans, s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, int prevNode, vector<vector<int>>& graph, int& ans, string& s) {\\n        int maxLen = 1;\\n        for(auto& nextNode : graph[node]) {\\n            if(prevNode == nextNode)\\n                continue;\\n            int tmp = dfs(nextNode, node, graph, ans, s);\\n            if(s[node] != s[nextNode]) {\\n                ans = max(ans, maxLen + tmp); //update ans with longest path\\n                maxLen = max(maxLen, 1 + tmp); //update maxpath length of child\\n            }\\n        }\\n        return maxLen;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = s.size();\\n        vector<vector<int>> graph(n);\\n        for(int i = 1; i < n; i++) {\\n            graph[parent[i]].push_back(i);\\n            graph[i].push_back(parent[i]);\\n        }\\n        int ans = 1;\\n        dfs(0, -1, graph, ans, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044272,
                "title": "c-simple-dfs-second-maximum-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int src, vector<int> adj[], string& s, int& maxi, vector<int>& vis) {\\n        vis[src] = 1;\\n        \\n        int first = 0, second = 0;\\n\\n        for(auto child : adj[src]) {\\n            if(!vis[child]) {\\n                int longestStartfromChild = dfs(child,adj,s,maxi,vis);\\n\\n                if(s[child] == s[src]) continue;\\n                \\n                if(longestStartfromChild > first) {\\n                    second = first;\\n                    first = longestStartfromChild;\\n                }\\n                else if(longestStartfromChild > second) {\\n                    second = longestStartfromChild;\\n                }\\n            }\\n        }\\n\\n        maxi = max(maxi, 1 + first + second);\\n        return first + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int maxi = 1;\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n\\n        for(int i=1;i<n;i++) {\\n            adj[parent[i]].push_back(i);\\n            adj[i].push_back(parent[i]);\\n        }\\n\\n        dfs(0,adj,s,maxi,vis);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int src, vector<int> adj[], string& s, int& maxi, vector<int>& vis) {\\n        vis[src] = 1;\\n        \\n        int first = 0, second = 0;\\n\\n        for(auto child : adj[src]) {\\n            if(!vis[child]) {\\n                int longestStartfromChild = dfs(child,adj,s,maxi,vis);\\n\\n                if(s[child] == s[src]) continue;\\n                \\n                if(longestStartfromChild > first) {\\n                    second = first;\\n                    first = longestStartfromChild;\\n                }\\n                else if(longestStartfromChild > second) {\\n                    second = longestStartfromChild;\\n                }\\n            }\\n        }\\n\\n        maxi = max(maxi, 1 + first + second);\\n        return first + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int maxi = 1;\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n\\n        for(int i=1;i<n;i++) {\\n            adj[parent[i]].push_back(i);\\n            adj[i].push_back(parent[i]);\\n        }\\n\\n        dfs(0,adj,s,maxi,vis);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044129,
                "title": "easy-c-solution-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<int>mp;\\n    int ans=0;\\n    int longestPath(vector<int>& parent, string s) {\\n        //we are going to make a directed graph adj with the help of parent vector\\n        //we are going to calculate longest path from every vertex and use it to make\\n        //answer.For this we are going to perform dfs starting from 0 vertex.\\n        adj.resize(parent.size());\\n        mp.resize(s.length(),0);\\n        //directed graph parent->child\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            int u=parent[i];\\n            int v=i;\\n            adj[u].push_back(v);\\n        }\\n        dfs(0,s);\\n        return ans;\\n    }\\n    void dfs(int src,string &s)\\n    {\\n        //every vertex is going to make its own path\\n        mp[src]=1;\\n        for(auto it=adj[src].begin();it!=adj[src].end();it++)\\n        {\\n            dfs(*it,s);\\n            //on returning we are calculating max path length\\n            if(s[src]!=s[*it])\\n            {\\n                ans=max(ans,mp[src]+mp[*it]);\\n                mp[src]=max(mp[src],mp[*it]+1);\\n            }\\n        }\\n        ans=max(ans,mp[src]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<int>mp;\\n    int ans=0;\\n    int longestPath(vector<int>& parent, string s) {\\n        //we are going to make a directed graph adj with the help of parent vector\\n        //we are going to calculate longest path from every vertex and use it to make\\n        //answer.For this we are going to perform dfs starting from 0 vertex.\\n        adj.resize(parent.size());\\n        mp.resize(s.length(),0);\\n        //directed graph parent->child\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            int u=parent[i];\\n            int v=i;\\n            adj[u].push_back(v);\\n        }\\n        dfs(0,s);\\n        return ans;\\n    }\\n    void dfs(int src,string &s)\\n    {\\n        //every vertex is going to make its own path\\n        mp[src]=1;\\n        for(auto it=adj[src].begin();it!=adj[src].end();it++)\\n        {\\n            dfs(*it,s);\\n            //on returning we are calculating max path length\\n            if(s[src]!=s[*it])\\n            {\\n                ans=max(ans,mp[src]+mp[*it]);\\n                mp[src]=max(mp[src],mp[*it]+1);\\n            }\\n        }\\n        ans=max(ans,mp[src]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044076,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int a,b=0;\\n    int max1[100001],max2[100001],count[100001];\\n    void dfs(int x,vector<vector<int>> & A,string &s)\\n    {\\n        if(A[x].empty()==0)\\n        {\\n            for(int i=0;i<=A[x].size()-1;i++)\\n            {\\n                if(s[x]!=s[A[x][i]])\\n                {\\n                    count[x]++;\\n                    dfs(A[x][i],A,s);\\n                    a=max1[A[x][i]]+1;\\n                    if(count[x]==1)\\n                    {\\n                        max1[x]=a;\\n                    }\\n                    if(count[x]>=2)\\n                    {\\n                        b=0;\\n                        if(max1[x]<=a)\\n                        {\\n                            max2[x]=max1[x];\\n                            max1[x]=a;\\n                        }\\n                        if(max1[x]>a&&max2[x]<a&&b==0)\\n                        {\\n                            max2[x]=a;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    dfs(A[x][i],A,s);\\n                }\\n            }\\n        }\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        vector<vector<int>> A(parent.size());\\n        for(int i=1;i<=parent.size()-1;i++)\\n            A[parent[i]].push_back(i);\\n        dfs(0,A,s);\\n        for(int i=0;i<=parent.size()-1;i++)\\n        {\\n            // cout << count[i] << \" \" << max1[i] << \" \" << max2[i] << endl;\\n            ans=max(ans,max1[i]+max2[i]+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int a,b=0;\\n    int max1[100001],max2[100001],count[100001];\\n    void dfs(int x,vector<vector<int>> & A,string &s)\\n    {\\n        if(A[x].empty()==0)\\n        {\\n            for(int i=0;i<=A[x].size()-1;i++)\\n            {\\n                if(s[x]!=s[A[x][i]])\\n                {\\n                    count[x]++;\\n                    dfs(A[x][i],A,s);\\n                    a=max1[A[x][i]]+1;\\n                    if(count[x]==1)\\n                    {\\n                        max1[x]=a;\\n                    }\\n                    if(count[x]>=2)\\n                    {\\n                        b=0;\\n                        if(max1[x]<=a)\\n                        {\\n                            max2[x]=max1[x];\\n                            max1[x]=a;\\n                        }\\n                        if(max1[x]>a&&max2[x]<a&&b==0)\\n                        {\\n                            max2[x]=a;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    dfs(A[x][i],A,s);\\n                }\\n            }\\n        }\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        vector<vector<int>> A(parent.size());\\n        for(int i=1;i<=parent.size()-1;i++)\\n            A[parent[i]].push_back(i);\\n        dfs(0,A,s);\\n        for(int i=0;i<=parent.size()-1;i++)\\n        {\\n            // cout << count[i] << \" \" << max1[i] << \" \" << max2[i] << endl;\\n            ans=max(ans,max1[i]+max2[i]+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3043938,
                "title": "c-100-fast-solution-easy-solution-with-explanation-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distance[100005];\\n    int ans=1;\\n    void dfs(int src,string & str,vector<vector<int>> &adj){\\n        distance[src]=1;\\n        for(int node : adj[src]){\\n            dfs(node,str,adj);\\n            if(str[src]!=str[node]){\\n                ans=max(ans,distance[src]+distance[node]);\\n                distance[src]=max(distance[src],distance[node]+1);\\n            }\\n        }\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n\\n        int n=parent.size();\\n        vector<vector<int>> adj(n);\\n\\n        for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0,s,adj);\\n        return ans;\\n        \\n    }\\n};\\n```\\n![upvote1.jpeg](https://assets.leetcode.com/users/images/e344a1fb-a016-46cc-ba25-d8aada14f7b0_1673592084.7440457.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distance[100005];\\n    int ans=1;\\n    void dfs(int src,string & str,vector<vector<int>> &adj){\\n        distance[src]=1;\\n        for(int node : adj[src]){\\n            dfs(node,str,adj);\\n            if(str[src]!=str[node]){\\n                ans=max(ans,distance[src]+distance[node]);\\n                distance[src]=max(distance[src],distance[node]+1);\\n            }\\n        }\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n\\n        int n=parent.size();\\n        vector<vector<int>> adj(n);\\n\\n        for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0,s,adj);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043934,
                "title": "longest-path-with-different-adjacent-characters-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnother dp on trees porblem . Just look at each node , how can we form a valid path which crosses it.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe shall store for each node , the longest path possible if the particular node acts as a junction (dp array). And the longest chain possible in the subtree of the node.(chain array)\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        \\n        int N = s.length();       \\n        vector<int>dp(N , 0); // stores the maximum length path if i node acts as the junction \\n        vector<int>chain(N , 0); // stores the longest chain in the subtree possible \\n\\n        \\n        vector<vector<int> >adj(N);\\n        int root = -1;\\n\\n        for(int i =0; i<N ; i++){\\n\\n            if(parent[i] == -1){\\n                root = i;\\n            }\\n            else{\\n                adj[parent[i]].push_back(i);\\n            }\\n        }\\n\\n        function<int(int)> dfs1 = [&](int uu)->int{\\n            \\n            pair<int,int>mxt = {0 , 0}; //Two maximum chains through the children with no same character \\n            chain[uu] = 1;\\n            for(auto e:adj[uu]){\\n                dfs1(e);\\n                if(s[e] != s[uu]){\\n                    chain[uu] = max(chain[uu] , chain[e]+1);\\n                    if(mxt.first<chain[e]){\\n                        swap(mxt.first , mxt.second);\\n                        mxt.first = chain[e];\\n                    }\\n                    else if(mxt.second < chain[e]){\\n                        mxt.second = chain[e];\\n                    }\\n                    else{\\n                        ;\\n                    }\\n                }\\n            }\\n            dp[uu] = 1 + mxt.first + mxt.second ;\\n            return  0; \\n        };\\n\\n        dfs1(root);\\n        return *max_element(dp.begin() , dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) {\\n        \\n        int N = s.length();       \\n        vector<int>dp(N , 0); // stores the maximum length path if i node acts as the junction \\n        vector<int>chain(N , 0); // stores the longest chain in the subtree possible \\n\\n        \\n        vector<vector<int> >adj(N);\\n        int root = -1;\\n\\n        for(int i =0; i<N ; i++){\\n\\n            if(parent[i] == -1){\\n                root = i;\\n            }\\n            else{\\n                adj[parent[i]].push_back(i);\\n            }\\n        }\\n\\n        function<int(int)> dfs1 = [&](int uu)->int{\\n            \\n            pair<int,int>mxt = {0 , 0}; //Two maximum chains through the children with no same character \\n            chain[uu] = 1;\\n            for(auto e:adj[uu]){\\n                dfs1(e);\\n                if(s[e] != s[uu]){\\n                    chain[uu] = max(chain[uu] , chain[e]+1);\\n                    if(mxt.first<chain[e]){\\n                        swap(mxt.first , mxt.second);\\n                        mxt.first = chain[e];\\n                    }\\n                    else if(mxt.second < chain[e]){\\n                        mxt.second = chain[e];\\n                    }\\n                    else{\\n                        ;\\n                    }\\n                }\\n            }\\n            dp[uu] = 1 + mxt.first + mxt.second ;\\n            return  0; \\n        };\\n\\n        dfs1(root);\\n        return *max_element(dp.begin() , dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043913,
                "title": "c-dfs-intuition-discussed-easy-to-read-code",
                "content": "```\\n/*\\nProblem in which at every node we decide whether to take the inverted V or not\\nIf we are taking the inverted V then update the answer if possible and pass the longest\\nlength that we could form to the above parent and for that parent too check if inverted V gives\\nmax answer.\\n*/\\n\\nclass Solution {\\npublic:\\n    int pathLen = 1;\\n    int dist[100005];\\n    \\n    void dfs(int src, vector<int> adj[], string &s) {\\n        dist[src] = 1;\\n        \\n        for(auto node : adj[src]) {\\n            dfs(node, adj, s);\\n            \\n            // returning\\n            if(s[src] != s[node]) {\\n                // Checking if inverted V is giving max or not\\n                pathLen = max(pathLen, dist[src] + dist[node]);\\n                // updating the node with the longest continuous straight path length \\n                // we could achieve \\n                dist[src] = max(dist[src], dist[node] + 1);\\n            }\\n        }\\n    }\\n    \\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        \\n        for(int i=1; i<n; i++) {\\n            adj[parent[i]].push_back(i);\\n        }\\n        \\n        dfs(0, adj, s);\\n        \\n        return pathLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\nProblem in which at every node we decide whether to take the inverted V or not\\nIf we are taking the inverted V then update the answer if possible and pass the longest\\nlength that we could form to the above parent and for that parent too check if inverted V gives\\nmax answer.\\n*/\\n\\nclass Solution {\\npublic:\\n    int pathLen = 1;\\n    int dist[100005];\\n    \\n    void dfs(int src, vector<int> adj[], string &s) {\\n        dist[src] = 1;\\n        \\n        for(auto node : adj[src]) {\\n            dfs(node, adj, s);\\n            \\n            // returning\\n            if(s[src] != s[node]) {\\n                // Checking if inverted V is giving max or not\\n                pathLen = max(pathLen, dist[src] + dist[node]);\\n                // updating the node with the longest continuous straight path length \\n                // we could achieve \\n                dist[src] = max(dist[src], dist[node] + 1);\\n            }\\n        }\\n    }\\n    \\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        vector<int> adj[n];\\n        \\n        for(int i=1; i<n; i++) {\\n            adj[parent[i]].push_back(i);\\n        }\\n        \\n        dfs(0, adj, s);\\n        \\n        return pathLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043825,
                "title": "easy-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int solve(int cur,vector<vector<int>> &adj,string &s)\\n    {\\n        int lsp=0;\\n\\n        int p=-1,q=-1; //to store longest and second-longest paths in current subtree \\n        for(auto &a:adj[cur]){\\n            int tmp=solve(a,adj,s);\\n            if(s[a]==s[cur]) tmp=0;\\n            if(tmp>=p){\\n                q=p;\\n                p=tmp;\\n            }\\n            else if(tmp>q) q=tmp;\\n\\n        }\\n        if(p!=-1 && q!=-1) res=max(res,1+p+q);\\n        \\n        if(p==-1) lsp=1;\\n        else lsp=1+p;\\n        res=max(lsp,res);\\n        return lsp;\\n\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        if(n==1) return 1;\\n        vector<vector<int>> adj(n);\\n        for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        int k=solve(0,adj,s);\\n        res=max(res,k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int solve(int cur,vector<vector<int>> &adj,string &s)\\n    {\\n        int lsp=0;\\n\\n        int p=-1,q=-1; //to store longest and second-longest paths in current subtree \\n        for(auto &a:adj[cur]){\\n            int tmp=solve(a,adj,s);\\n            if(s[a]==s[cur]) tmp=0;\\n            if(tmp>=p){\\n                q=p;\\n                p=tmp;\\n            }\\n            else if(tmp>q) q=tmp;\\n\\n        }\\n        if(p!=-1 && q!=-1) res=max(res,1+p+q);\\n        \\n        if(p==-1) lsp=1;\\n        else lsp=1+p;\\n        res=max(lsp,res);\\n        return lsp;\\n\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        if(n==1) return 1;\\n        vector<vector<int>> adj(n);\\n        for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        int k=solve(0,adj,s);\\n        res=max(res,k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043788,
                "title": "python-dfs-clean-no-global",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe must keep track of two things with dfs, the total from children nodes and the longest path through children nodes. Using these two return values we can find the longest path overal in tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake parent list and make a mapping of parent to children for easy navigation.\\n\\nIterate through children, get their total and use max on our total. Also get the longest path, keep track of the two longest sub paths.\\n\\nAt the end compare total and sum of the two paths + 1 for going through this node, then return that.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) go through all nodes\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) recursive call stack as well as mapping dict for traversal\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        mapping = defaultdict(list)\\n        for x in range(1,len(parent)):\\n            mapping[parent[x]].append(x)\\n        \\n        def dfs(node):\\n            total = 1\\n            # could also do this with 2 value list [0,0]\\n            largest_sub_path = second_largest_sub_path = 0\\n            for child in mapping[node]:\\n                sub_total, sub_path = dfs(child)\\n                if s[node] != s[child]:\\n                    if sub_path > largest_sub_path:\\n                        # throw out second largest\\n                        largest_sub_path, second_largest_sub_path = sub_path, largest_sub_path\\n                    elif sub_path > second_largest_sub_path:\\n                        second_largest_sub_path = sub_path\\n                total = max(sub_total, total)\\n            total =  max(total, largest_sub_path + second_largest_sub_path + 1)\\n            # return both the largest current total, from this node and sub nodes\\n            # as well as largest path starting from this node\\n            return total, largest_sub_path + 1\\n\\n        return dfs(0)[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        mapping = defaultdict(list)\\n        for x in range(1,len(parent)):\\n            mapping[parent[x]].append(x)\\n        \\n        def dfs(node):\\n            total = 1\\n            # could also do this with 2 value list [0,0]\\n            largest_sub_path = second_largest_sub_path = 0\\n            for child in mapping[node]:\\n                sub_total, sub_path = dfs(child)\\n                if s[node] != s[child]:\\n                    if sub_path > largest_sub_path:\\n                        # throw out second largest\\n                        largest_sub_path, second_largest_sub_path = sub_path, largest_sub_path\\n                    elif sub_path > second_largest_sub_path:\\n                        second_largest_sub_path = sub_path\\n                total = max(sub_total, total)\\n            total =  max(total, largest_sub_path + second_largest_sub_path + 1)\\n            # return both the largest current total, from this node and sub nodes\\n            # as well as largest path starting from this node\\n            return total, largest_sub_path + 1\\n\\n        return dfs(0)[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043747,
                "title": "dfs-c-easy-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    vector<int>dist;\\n    int longest=1;\\n    void dfs(int node,string &s){\\n        dist[node]=1;\\n        for(auto child:g[node]){\\n            dfs(child,s);\\n            if(s[child]!=s[node]){\\n                longest=max(longest,dist[child]+dist[node]);\\n                dist[node]=max(dist[node],dist[child]+1);\\n            }\\n        }\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        g.resize(n);\\n        for(int i=1;i<n;i++){\\n            g[parent[i]].push_back(i);\\n        }\\n        dist.resize(n,0);\\n        dfs(0,s);\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    vector<int>dist;\\n    int longest=1;\\n    void dfs(int node,string &s){\\n        dist[node]=1;\\n        for(auto child:g[node]){\\n            dfs(child,s);\\n            if(s[child]!=s[node]){\\n                longest=max(longest,dist[child]+dist[node]);\\n                dist[node]=max(dist[node],dist[child]+1);\\n            }\\n        }\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        g.resize(n);\\n        for(int i=1;i<n;i++){\\n            g[parent[i]].push_back(i);\\n        }\\n        dist.resize(n,0);\\n        dfs(0,s);\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043723,
                "title": "java-c-short-faster-easy-solutions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  int ans=0;\\n    int dfs(int vertex,char p,HashMap<Integer, List<Integer>>tree,String s){\\n        int max1=0;\\n        int max2=0;\\n        for(int i:tree.get(vertex)){\\n            int cur=dfs(i,s.charAt(i), tree, s);\\n            if(p==s.charAt(i)) {\\n                continue;\\n            }\\n            if(cur>max1){\\n                max2=max1;\\n                max1=cur;\\n            }\\n            else if(cur>max2){\\n                max2=cur;\\n            }\\n        }\\n        ans=Math.max(ans,max1+max2+1);\\n        return max1+1;\\n    }\\n    public int longestPath(int[] parent, String s) {\\n        HashMap<Integer, List<Integer>>tree= new HashMap<>();\\n        int n=parent.length;\\n        for(int i=0;i<n;i++)\\n            tree.put(i,new ArrayList<>());\\n\\n        for(int i=1;i<n;i++) {\\n            tree.get(parent[i]).add(i);\\n        }\\n        char c=s.charAt(0);\\n        dfs(0,c,tree,s);\\n        return ans;\\n    }\\n}\\n```\\n# C++\\n\\n```\\nclass Solution {\\npublic:\\n    int pathSize(int pos, int &longestPath, string &s, vector<vector<int>> &treeMap) {\\n        // Best path to take INCLUDING this node\\n        int best = 0, nextBest = 0;\\n        for (int i : treeMap[pos]) {\\n            // Go down each branch DFS (check same letter bc \"apex\" node may be lower)\\n            int x = pathSize(i, longestPath, s, treeMap);\\n\\n            // If it same character, then don\\'t set a path using this node\\n            if (s[i] == s[pos]) continue;\\n            \\n            // Save the best and second best branches (so we can check how good the apex is)\\n            if (x > best) {\\n                nextBest = best;\\n                best = x;\\n            }\\n            else if (x > nextBest) nextBest = x;\\n        }\\n        // If this is the \"apex\" node (aka the path takes one branch coming up and the other down)\\n            // The count of the number of nodes in each branch + itself\\n        longestPath = max(longestPath, best + nextBest + 1);\\n        // Return the best non-adjacent path + itself\\n        return best + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n\\n        // Store the list of children for each node\\n        vector<vector<int>> treeMap (n);\\n\\n        // Put the node as each parent\\n        for (int i = 1; i < n; i++) \\n            treeMap[parent[i]].push_back(i);\\n        \\n        int longestPath = 0;\\n        pathSize(0, longestPath, s, treeMap);\\n        return longestPath;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "String",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n  int ans=0;\\n    int dfs(int vertex,char p,HashMap<Integer, List<Integer>>tree,String s){\\n        int max1=0;\\n        int max2=0;\\n        for(int i:tree.get(vertex)){\\n            int cur=dfs(i,s.charAt(i), tree, s);\\n            if(p==s.charAt(i)) {\\n                continue;\\n            }\\n            if(cur>max1){\\n                max2=max1;\\n                max1=cur;\\n            }\\n            else if(cur>max2){\\n                max2=cur;\\n            }\\n        }\\n        ans=Math.max(ans,max1+max2+1);\\n        return max1+1;\\n    }\\n    public int longestPath(int[] parent, String s) {\\n        HashMap<Integer, List<Integer>>tree= new HashMap<>();\\n        int n=parent.length;\\n        for(int i=0;i<n;i++)\\n            tree.put(i,new ArrayList<>());\\n\\n        for(int i=1;i<n;i++) {\\n            tree.get(parent[i]).add(i);\\n        }\\n        char c=s.charAt(0);\\n        dfs(0,c,tree,s);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int pathSize(int pos, int &longestPath, string &s, vector<vector<int>> &treeMap) {\\n        // Best path to take INCLUDING this node\\n        int best = 0, nextBest = 0;\\n        for (int i : treeMap[pos]) {\\n            // Go down each branch DFS (check same letter bc \"apex\" node may be lower)\\n            int x = pathSize(i, longestPath, s, treeMap);\\n\\n            // If it same character, then don\\'t set a path using this node\\n            if (s[i] == s[pos]) continue;\\n            \\n            // Save the best and second best branches (so we can check how good the apex is)\\n            if (x > best) {\\n                nextBest = best;\\n                best = x;\\n            }\\n            else if (x > nextBest) nextBest = x;\\n        }\\n        // If this is the \"apex\" node (aka the path takes one branch coming up and the other down)\\n            // The count of the number of nodes in each branch + itself\\n        longestPath = max(longestPath, best + nextBest + 1);\\n        // Return the best non-adjacent path + itself\\n        return best + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n\\n        // Store the list of children for each node\\n        vector<vector<int>> treeMap (n);\\n\\n        // Put the node as each parent\\n        for (int i = 1; i < n; i++) \\n            treeMap[parent[i]].push_back(i);\\n        \\n        int longestPath = 0;\\n        pathSize(0, longestPath, s, treeMap);\\n        return longestPath;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043659,
                "title": "o-n-time-complexity-solution-using-dfs-96-time-74-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor there to be a path, there are three options for the nodes in the path; it can be an end node, come up from one of the branches and go down the other, or go up to the parent. The end nodes are built in, as there are no children to do the pathing, and an end that is the parent is also handled by sending up to the parent. \\n\\nSince each node only has one parent, there can only be one node where the path is on two branches. This means we can check the most optimal path at each node to find this path. \\n\\nOtherwise, we will always want to use the best path at each node, as the previous nodes don\\'t affect the rest of the path, as the children will check against the parent and not the ancestors beyond the parent. \\n\\nIf they share a tag, we can check that node, but don\\'t include it in the path.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI use a shared variable to store the best path. I use DFS in order to find the best and second path of each node that contain that node. I also try to check nodes that match the parent, but don\\'t record the path as the best path as it can\\'t be used with the parent node. However, the overall best path found will be recorded. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$ time complexity, as it is a DFS on a tree and at each step is $O(1)$ as it is just a comparison. Thus, the total time complexity is $O(n)$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$ as there are a total of n nodes, so there is $O(n)$ sized array, and total size of the vectors is $O(n)$ as every node can only have one parent, so it appears once in the vectors. The recursion stack is also $O(n)$.   \\n![image.png](https://assets.leetcode.com/users/images/eeb1312b-afa7-4f28-9d6e-595243d12774_1673586848.9795916.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pathSize(int pos, int &longestPath, string &s, vector<vector<int>> &treeMap) {\\n        // Best path to take INCLUDING this node\\n        int best = 0, nextBest = 0;\\n        for (int i : treeMap[pos]) {\\n            // Go down each branch DFS (check same letter bc \"apex\" node may be lower)\\n            int x = pathSize(i, longestPath, s, treeMap);\\n\\n            // If it same character, then don\\'t set a path using this node\\n            if (s[i] == s[pos]) continue;\\n            \\n            // Save the best and second best branches (so we can check how good the apex is)\\n            if (x > best) {\\n                nextBest = best;\\n                best = x;\\n            }\\n            else if (x > nextBest) nextBest = x;\\n        }\\n        // If this is the \"apex\" node (aka the path takes one branch coming up and the other down)\\n            // The count of the number of nodes in each branch + itself\\n        longestPath = max(longestPath, best + nextBest + 1);\\n        // Return the best non-adjacent path + itself\\n        return best + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n\\n        // Store the list of children for each node\\n        vector<vector<int>> treeMap (n);\\n\\n        // Put the node as each parent\\n        for (int i = 1; i < n; i++) \\n            treeMap[parent[i]].push_back(i);\\n        \\n        int longestPath = 0;\\n        pathSize(0, longestPath, s, treeMap);\\n        return longestPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathSize(int pos, int &longestPath, string &s, vector<vector<int>> &treeMap) {\\n        // Best path to take INCLUDING this node\\n        int best = 0, nextBest = 0;\\n        for (int i : treeMap[pos]) {\\n            // Go down each branch DFS (check same letter bc \"apex\" node may be lower)\\n            int x = pathSize(i, longestPath, s, treeMap);\\n\\n            // If it same character, then don\\'t set a path using this node\\n            if (s[i] == s[pos]) continue;\\n            \\n            // Save the best and second best branches (so we can check how good the apex is)\\n            if (x > best) {\\n                nextBest = best;\\n                best = x;\\n            }\\n            else if (x > nextBest) nextBest = x;\\n        }\\n        // If this is the \"apex\" node (aka the path takes one branch coming up and the other down)\\n            // The count of the number of nodes in each branch + itself\\n        longestPath = max(longestPath, best + nextBest + 1);\\n        // Return the best non-adjacent path + itself\\n        return best + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n\\n        // Store the list of children for each node\\n        vector<vector<int>> treeMap (n);\\n\\n        // Put the node as each parent\\n        for (int i = 1; i < n; i++) \\n            treeMap[parent[i]].push_back(i);\\n        \\n        int longestPath = 0;\\n        pathSize(0, longestPath, s, treeMap);\\n        return longestPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043634,
                "title": "c-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxPath=0;\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        vector<int>adj[s.length()];\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            int p=parent[i];\\n            adj[p].push_back(i);\\n        }\\n\\n        dfs(-1,0,adj,s);\\n        return maxPath+1;\\n    }\\n\\n    int dfs(int parent,int node,vector<int>adj[],string&s)\\n    {\\n        int maxPath1=0,maxPath2=0;\\n        for(auto &i:adj[node])\\n        {\\n            if(i!=parent)\\n            {\\n                int pathLen=dfs(node,i,adj,s);\\n                if(s[i]==s[node]) pathLen=0;\\n                else pathLen++;\\n\\n                if(pathLen>=maxPath1)\\n                {\\n                    maxPath2=maxPath1;\\n                    maxPath1=pathLen;\\n                }\\n                else if(pathLen>=maxPath2)\\n                {\\n                    maxPath2=pathLen;\\n                }\\n            }\\n        }\\n        maxPath=max(maxPath,maxPath1+maxPath2);\\n        return maxPath1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxPath=0;\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        vector<int>adj[s.length()];\\n        for(int i=1;i<parent.size();i++)\\n        {\\n            int p=parent[i];\\n            adj[p].push_back(i);\\n        }\\n\\n        dfs(-1,0,adj,s);\\n        return maxPath+1;\\n    }\\n\\n    int dfs(int parent,int node,vector<int>adj[],string&s)\\n    {\\n        int maxPath1=0,maxPath2=0;\\n        for(auto &i:adj[node])\\n        {\\n            if(i!=parent)\\n            {\\n                int pathLen=dfs(node,i,adj,s);\\n                if(s[i]==s[node]) pathLen=0;\\n                else pathLen++;\\n\\n                if(pathLen>=maxPath1)\\n                {\\n                    maxPath2=maxPath1;\\n                    maxPath1=pathLen;\\n                }\\n                else if(pathLen>=maxPath2)\\n                {\\n                    maxPath2=pathLen;\\n                }\\n            }\\n        }\\n        maxPath=max(maxPath,maxPath1+maxPath2);\\n        return maxPath1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043571,
                "title": "c-easy-solution-easy-to-understand-similar-to-binary-tree-maximum-path-sum",
                "content": "# Intuition\\nBasically we design a recursive function that takes root of the subtree as input and returns the longest path ending at the root of this subtree.\\nThis value can be used to find the longest path in the tree.\\n\\nSimilar to [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/).Can try this question first (I will attach the code for this question too). Here We just need to make an adjacency matrix and then apply the condition that adjacent character should be different.\\n\\n# Code for Binary Tree Maximum Path Sum\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n\\tint solve(TreeNode *root, int &ans)\\n\\t{\\n\\t\\tif (!root)\\n\\t\\t\\treturn 0;\\n\\t\\tint l = solve(root->left, ans);\\n\\t\\tint r = solve(root->right, ans);\\n\\t\\t// cout<<l<<\" \"<<r<<\" \";\\n\\t\\tans = max(ans, max(l + root->val, max(r + root->val, l + r + root->val)));\\n\\t\\treturn max(0, max(l + root->val, r + root->val));\\n\\t}\\n\\tint maxPathSum(TreeNode *root)\\n\\t{\\n\\t\\tint ans = -100000;\\n\\t\\tsolve(root, ans);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code for Longest Path with different adjacent characters\\n```\\nclass Solution\\n{\\npublic:\\n\\tint solve(int i, vector<vector<int>> &adj, int &ans, string &s)\\n\\t{\\n\\t\\tint fi = -1, sec = -1;\\n\\t\\tfor (auto &x : adj[i])\\n\\t\\t{\\n\\t\\t\\tint ch = solve(x, adj, ans, s);\\n\\t\\t\\tif (s[x] == s[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (fi == -1)\\n\\t\\t\\t\\tfi = ch;\\n\\t\\t\\telse if (fi <= ch)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsec = fi;\\n\\t\\t\\t\\tfi = ch;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tsec = max(sec, ch);\\n\\t\\t}\\n\\t\\tans = max(ans, fi + 1);\\n\\t\\tans = max(ans, sec + 1);\\n\\t\\tans = max(ans, fi + 1 + sec);\\n\\t\\tif (fi == -1)\\n\\t\\t\\treturn 1;\\n\\t\\treturn fi + 1;\\n\\t}\\n\\tint longestPath(vector<int> &parent, string s)\\n\\t{\\n\\t\\tint n = parent.size();\\n\\t\\tvector<vector<int>> adj(n);\\n\\t\\tfor (int i = 1; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tadj[parent[i]].push_back(i);\\n\\t\\t}\\n\\t\\tint ans = 1;\\n\\t\\tsolve(0, adj, ans, s);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n\\tint solve(TreeNode *root, int &ans)\\n\\t{\\n\\t\\tif (!root)\\n\\t\\t\\treturn 0;\\n\\t\\tint l = solve(root->left, ans);\\n\\t\\tint r = solve(root->right, ans);\\n\\t\\t// cout<<l<<\" \"<<r<<\" \";\\n\\t\\tans = max(ans, max(l + root->val, max(r + root->val, l + r + root->val)));\\n\\t\\treturn max(0, max(l + root->val, r + root->val));\\n\\t}\\n\\tint maxPathSum(TreeNode *root)\\n\\t{\\n\\t\\tint ans = -100000;\\n\\t\\tsolve(root, ans);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n\\tint solve(int i, vector<vector<int>> &adj, int &ans, string &s)\\n\\t{\\n\\t\\tint fi = -1, sec = -1;\\n\\t\\tfor (auto &x : adj[i])\\n\\t\\t{\\n\\t\\t\\tint ch = solve(x, adj, ans, s);\\n\\t\\t\\tif (s[x] == s[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (fi == -1)\\n\\t\\t\\t\\tfi = ch;\\n\\t\\t\\telse if (fi <= ch)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsec = fi;\\n\\t\\t\\t\\tfi = ch;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tsec = max(sec, ch);\\n\\t\\t}\\n\\t\\tans = max(ans, fi + 1);\\n\\t\\tans = max(ans, sec + 1);\\n\\t\\tans = max(ans, fi + 1 + sec);\\n\\t\\tif (fi == -1)\\n\\t\\t\\treturn 1;\\n\\t\\treturn fi + 1;\\n\\t}\\n\\tint longestPath(vector<int> &parent, string s)\\n\\t{\\n\\t\\tint n = parent.size();\\n\\t\\tvector<vector<int>> adj(n);\\n\\t\\tfor (int i = 1; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tadj[parent[i]].push_back(i);\\n\\t\\t}\\n\\t\\tint ans = 1;\\n\\t\\tsolve(0, adj, ans, s);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3043567,
                "title": "c-easy-solution-dfs-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor a node **P** if we find the two longest chains of its child nodes, say **L1** and **L2** we can compute the longest path centered at node **P**. For each node, we can find the maximum of value 1 + **L1** + **L2** to find the answer. The addition of one comes for the node **P** itself.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int node,vector<vector<int>>& adj,string& s,int& ans)\\n    {\\n        int lans,sans;\\n        lans = sans = 0; // longest ans secont longest answer\\n\\n        for(auto i:adj[node])\\n        {\\n            int Cans = helper(i,adj,s,ans);\\n\\n            if(s[node] == s[i])\\n            {\\n                continue;\\n            }\\n\\n            if(Cans > lans)\\n            {\\n                sans = lans;\\n                lans = Cans;\\n            }\\n            else if(Cans > sans)\\n            {\\n                sans = Cans;\\n            }\\n        }\\n\\n        ans = max(ans,lans+sans+1);\\n        return lans+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) \\n    {\\n        int n = parent.size();\\n        vector<vector<int>>adj(n);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i); // making of tree from Parent vaector\\n        }        \\n\\n        int ans=1;\\n        int cnt = helper(0,adj,s,ans); // Calling of dfs\\n        return ans;\\n    }\\n};\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n**Using Khan\\'s Algorithm**\\n\\n* We need to visit all the children first, get the length of the longest chain using each child, and use it to compute the answer for the parent node. So, we need to move from the leaf nodes to the root.\\n\\n* As we know, in a tree, each step from top to bottom is part of a level/depth. The level count starts with 0 (for the root node) and increments by 1 at each level or step. Here, we need a BFS traversal that covers all of the nodes at the current level, say at level l before moving to the nodes present one level above at level l - 1. To perform such a traversal, we push all the leaf nodes into the BFS queue first and then move up until we reach the root.\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) \\n    {\\n        int n=s.size();\\n        vector<int> indegree(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parent[i]!=-1)\\n            {\\n               indegree[parent[i]]++;   // store number of child node in a node\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0) // push the leaf node in a queue\\n            {\\n                q.push(i);\\n            }\\n        }\\n         \\n        vector<int> maxpath(n,1); // maxpath: stores the max path of from that node\\n        int ans=1;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            q.pop();\\n            \\n            int v=parent[u];\\n            if(v==-1)\\n            {\\n                continue;\\n            }\\n            indegree[v]--;\\n            if(s[u]!=s[v])\\n            {\\n                ans=max(ans,maxpath[v]+maxpath[u]); // store the max path in ans variable\\n                maxpath[v]=max(maxpath[v],1+maxpath[u]);\\n            }\\n            if(indegree[v]==0)\\n            {\\n                q.push(v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int node,vector<vector<int>>& adj,string& s,int& ans)\\n    {\\n        int lans,sans;\\n        lans = sans = 0; // longest ans secont longest answer\\n\\n        for(auto i:adj[node])\\n        {\\n            int Cans = helper(i,adj,s,ans);\\n\\n            if(s[node] == s[i])\\n            {\\n                continue;\\n            }\\n\\n            if(Cans > lans)\\n            {\\n                sans = lans;\\n                lans = Cans;\\n            }\\n            else if(Cans > sans)\\n            {\\n                sans = Cans;\\n            }\\n        }\\n\\n        ans = max(ans,lans+sans+1);\\n        return lans+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) \\n    {\\n        int n = parent.size();\\n        vector<vector<int>>adj(n);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i); // making of tree from Parent vaector\\n        }        \\n\\n        int ans=1;\\n        int cnt = helper(0,adj,s,ans); // Calling of dfs\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestPath(vector<int>& parent, string s) \\n    {\\n        int n=s.size();\\n        vector<int> indegree(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(parent[i]!=-1)\\n            {\\n               indegree[parent[i]]++;   // store number of child node in a node\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0) // push the leaf node in a queue\\n            {\\n                q.push(i);\\n            }\\n        }\\n         \\n        vector<int> maxpath(n,1); // maxpath: stores the max path of from that node\\n        int ans=1;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            q.pop();\\n            \\n            int v=parent[u];\\n            if(v==-1)\\n            {\\n                continue;\\n            }\\n            indegree[v]--;\\n            if(s[u]!=s[v])\\n            {\\n                ans=max(ans,maxpath[v]+maxpath[u]); // store the max path in ans variable\\n                maxpath[v]=max(maxpath[v],1+maxpath[u]);\\n            }\\n            if(indegree[v]==0)\\n            {\\n                q.push(v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043551,
                "title": "javascript-depth-first-search-approach",
                "content": "```\\n// Approach: Depth First Search (DFS)\\n\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nconst longestPath = function(parent, s) {\\n\\tconst graph = new Map();\\n\\tlet longestPath = 1;\\n\\t\\n\\tfor (let i = 1; i < parent.length; i++) {\\n\\t\\tif (graph.has(parent[i]))\\n\\t\\t\\tgraph.get(parent[i]).push(i);\\n\\t\\telse\\n\\t\\t\\tgraph.set(parent[i], [i]);\\n\\t}\\n\\t\\n\\tfunction dfs(curr) {\\n\\t\\tif (!graph.has(curr))\\n\\t\\t\\treturn 1;\\n\\t\\t\\t\\n\\t\\tlet longest = 0, secondLongest = 0;\\n\\t\\t\\n\\t\\tfor (const child of graph.get(curr)) {\\n\\t\\t\\tconst longestFromChild = dfs(child);\\n\\t\\t   \\n\\t\\t\\tif (s[curr] != s[child]) {\\n\\t\\t\\t\\tif (longestFromChild > longest) {\\n\\t\\t\\t\\t\\tsecondLongest = longest;\\n\\t\\t\\t\\t\\tlongest = longestFromChild;\\n\\t\\t\\t\\t} else if (longestFromChild > secondLongest) {\\n\\t\\t\\t\\t\\tsecondLongest = longestFromChild;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlongestPath = Math.max(longestPath, longest + secondLongest + 1);\\n\\t\\treturn longest + 1;\\n\\t}\\n\\t   \\n\\tdfs(0);\\n\\treturn longestPath;\\n};\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n// Approach: Depth First Search (DFS)\\n\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nconst longestPath = function(parent, s) {\\n\\tconst graph = new Map();\\n\\tlet longestPath = 1;\\n\\t\\n\\tfor (let i = 1; i < parent.length; i++) {\\n\\t\\tif (graph.has(parent[i]))\\n\\t\\t\\tgraph.get(parent[i]).push(i);\\n\\t\\telse\\n\\t\\t\\tgraph.set(parent[i], [i]);\\n\\t}\\n\\t\\n\\tfunction dfs(curr) {\\n\\t\\tif (!graph.has(curr))\\n\\t\\t\\treturn 1;\\n\\t\\t\\t\\n\\t\\tlet longest = 0, secondLongest = 0;\\n\\t\\t\\n\\t\\tfor (const child of graph.get(curr)) {\\n\\t\\t\\tconst longestFromChild = dfs(child);\\n\\t\\t   \\n\\t\\t\\tif (s[curr] != s[child]) {\\n\\t\\t\\t\\tif (longestFromChild > longest) {\\n\\t\\t\\t\\t\\tsecondLongest = longest;\\n\\t\\t\\t\\t\\tlongest = longestFromChild;\\n\\t\\t\\t\\t} else if (longestFromChild > secondLongest) {\\n\\t\\t\\t\\t\\tsecondLongest = longestFromChild;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlongestPath = Math.max(longestPath, longest + secondLongest + 1);\\n\\t\\treturn longest + 1;\\n\\t}\\n\\t   \\n\\tdfs(0);\\n\\treturn longestPath;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043508,
                "title": "beats-100-faang-method-ever",
                "content": "# Code\\n```\\nconst int N = 100010;\\nint res;\\nint h[N], e[N], ne[N], idx;\\nvoid add(int a, int b) {\\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\\n}\\nclass Solution {\\n    int dfs(string &s, int u) {\\n        int first = -1, second = -1;\\n        for (int i = h[u]; ~i; i = ne[i]) {\\n            int j = e[i];\\n            if (s[j] == s[u]) {\\n                res = max(res, dfs(s, j));\\n                continue;\\n            }\\n            int len = dfs(s, j);\\n            if (len > second) {\\n                if (len > first) {\\n                    second = first;\\n                    first = len;\\n                } else {\\n                    second = len;\\n                }\\n            }\\n        }\\n        if (first == -1) {\\n            res = max(res, 1);\\n            return 1;\\n        }\\n        res = max(res, first + 1);\\n        if (second != -1) {\\n            res = max(res, first + second + 1);\\n        }\\n        return first + 1;\\n    }\\n\\npublic:\\n    int longestPath(vector<int> &parent, string s) {\\n        if (s.size() == 1) return 1;\\n        res = 0;\\n        memset(h, -1, sizeof h), memset(ne, 0, sizeof ne), idx = 0;\\n        int n = (int) parent.size();\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] >= 0) {\\n                add(parent[i], i);\\n            }\\n        }\\n        dfs(s, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 100010;\\nint res;\\nint h[N], e[N], ne[N], idx;\\nvoid add(int a, int b) {\\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\\n}\\nclass Solution {\\n    int dfs(string &s, int u) {\\n        int first = -1, second = -1;\\n        for (int i = h[u]; ~i; i = ne[i]) {\\n            int j = e[i];\\n            if (s[j] == s[u]) {\\n                res = max(res, dfs(s, j));\\n                continue;\\n            }\\n            int len = dfs(s, j);\\n            if (len > second) {\\n                if (len > first) {\\n                    second = first;\\n                    first = len;\\n                } else {\\n                    second = len;\\n                }\\n            }\\n        }\\n        if (first == -1) {\\n            res = max(res, 1);\\n            return 1;\\n        }\\n        res = max(res, first + 1);\\n        if (second != -1) {\\n            res = max(res, first + second + 1);\\n        }\\n        return first + 1;\\n    }\\n\\npublic:\\n    int longestPath(vector<int> &parent, string s) {\\n        if (s.size() == 1) return 1;\\n        res = 0;\\n        memset(h, -1, sizeof h), memset(ne, 0, sizeof ne), idx = 0;\\n        int n = (int) parent.size();\\n        for (int i = 0; i < n; i++) {\\n            if (parent[i] >= 0) {\\n                add(parent[i], i);\\n            }\\n        }\\n        dfs(s, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043501,
                "title": "c-simple-dfs-detailed-explanation-85-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVariation of standard tree problem of finding the max_path between any two nodes, But this one has some additional constraints\\n    - the parent and child must have different alphabets.\\n    - And in this one parent can have more than two child as given in question\\n\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo if it was a tree and no constraints were given ie. we just have to find the max path length between any two nodes so, we would have recursively built the dfs function and while returning we would have have returned 1+max(left,right) and updated our answer as ans=max(ans,left+right+1).\\nwhere left is the maximum path length in the left subtree and right is the max path length in the right subtree.\\n\\n---\\n\\n\\nNow coming to this question, we have more than two childs, but what we have to care about is the two of them which gives us the maximum path lengths among all of them ( so they would be considered as our left and right as discussed in previous analogy )\\n\\nBut before considering the child of any node in our answer we have check for one another thing that the **s[child] != s[curr_node]**\\n\\nFor implementation, refer comments in code given below.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nVirtual recursion space : $$O(h+n)$$ where h = height of tree. and n=number of nodes in the graph.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int curr_node,int parent,vector<vector<int>>&adj,string &s,int &ans) {\\n        // first maximum and second maximum length\\n        int fmax=0,smax=0;  \\n\\n        // traversing the childs of current node\\n        for(auto child:adj[curr_node]) { \\n\\n        /* check so that we do not stuck in an infinite recursive\\nloop, no need to make a visited array as it a tree where every\\nnode has only one parent */\\n\\n            if(child==parent) continue;\\n\\n            //recursively calling dfs for getting max path length\\n            // from it\\'s childs subtree and storing it in temp\\n\\n            int temp=dfs(child,curr_node,adj,s,ans); \\n\\n            //adjacent nodes must not have same character\\n            if(s[child]!=s[curr_node]) {\\n                if(temp>=fmax) {\\n                    smax=fmax;\\n                    fmax=temp;\\n                }else if(temp>=smax) smax=temp;\\n            }\\n        }\\n\\n\\n    /* considering the path from  \\n          curr_node\\n         /  / | \\\\ \\\\\\n        /          \\\\\\n       /          smax\\n     fmax\\n    */\\n        ans=max(ans,1+fmax+smax);\\n\\n    // while returning we must include the curr_node with any of it\\'s \\n    //child, but we want max_path so we will include the one which\\n    //gives the maximum path.\\n        return 1+fmax;\\n\\n    }\\n    int longestPath(vector<int>& par, string s) {\\n        int n=par.size(),ans=0;\\n\\n//making adjacency list for graph\\n        vector<vector<int>>adj(n); \\n        for(int i=1;i<n;i++) {  // start from 1 here as 0th node\\n                                // does not have any parent\\n            adj[par[i]].emplace_back(i);\\n            adj[i].emplace_back(par[i]);\\n        }\\n        dfs(0,-1,adj,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int curr_node,int parent,vector<vector<int>>&adj,string &s,int &ans) {\\n        // first maximum and second maximum length\\n        int fmax=0,smax=0;  \\n\\n        // traversing the childs of current node\\n        for(auto child:adj[curr_node]) { \\n\\n        /* check so that we do not stuck in an infinite recursive\\nloop, no need to make a visited array as it a tree where every\\nnode has only one parent */\\n\\n            if(child==parent) continue;\\n\\n            //recursively calling dfs for getting max path length\\n            // from it\\'s childs subtree and storing it in temp\\n\\n            int temp=dfs(child,curr_node,adj,s,ans); \\n\\n            //adjacent nodes must not have same character\\n            if(s[child]!=s[curr_node]) {\\n                if(temp>=fmax) {\\n                    smax=fmax;\\n                    fmax=temp;\\n                }else if(temp>=smax) smax=temp;\\n            }\\n        }\\n\\n\\n    /* considering the path from  \\n          curr_node\\n         /  / | \\\\ \\\\\\n        /          \\\\\\n       /          smax\\n     fmax\\n    */\\n        ans=max(ans,1+fmax+smax);\\n\\n    // while returning we must include the curr_node with any of it\\'s \\n    //child, but we want max_path so we will include the one which\\n    //gives the maximum path.\\n        return 1+fmax;\\n\\n    }\\n    int longestPath(vector<int>& par, string s) {\\n        int n=par.size(),ans=0;\\n\\n//making adjacency list for graph\\n        vector<vector<int>>adj(n); \\n        for(int i=1;i<n;i++) {  // start from 1 here as 0th node\\n                                // does not have any parent\\n            adj[par[i]].emplace_back(i);\\n            adj[i].emplace_back(par[i]);\\n        }\\n        dfs(0,-1,adj,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043494,
                "title": "python-solution-using-depth-first-search-beats-91-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        tree = defaultdict(list)\\n        for u, v in enumerate(parent):\\n            tree[v].append(u)\\n        longestPath = 1\\n        def dfs(node):\\n            nonlocal longestPath\\n            maxi1 = 0\\n            maxi2 = 0\\n            for i in tree[node]:\\n                karan = dfs(i)\\n                if s[i] != s[node]:\\n                    if karan > maxi1:\\n                        maxi2 = maxi1\\n                        maxi1 = karan\\n                    elif karan > maxi2:\\n                        maxi2 = karan\\n            longestPath = max(longestPath, maxi1 + maxi2 + 1)\\n            return maxi1 + 1\\n        dfs(0)\\n        return longestPath\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        tree = defaultdict(list)\\n        for u, v in enumerate(parent):\\n            tree[v].append(u)\\n        longestPath = 1\\n        def dfs(node):\\n            nonlocal longestPath\\n            maxi1 = 0\\n            maxi2 = 0\\n            for i in tree[node]:\\n                karan = dfs(i)\\n                if s[i] != s[node]:\\n                    if karan > maxi1:\\n                        maxi2 = maxi1\\n                        maxi1 = karan\\n                    elif karan > maxi2:\\n                        maxi2 = karan\\n            longestPath = max(longestPath, maxi1 + maxi2 + 1)\\n            return maxi1 + 1\\n        dfs(0)\\n        return longestPath\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043477,
                "title": "python-clean-dfs-solution-without-explanation",
                "content": "Hello fellow leetcoders!\\n\\nNo hype here. Just proposing my Python solution code for your reference. For the explanation, please refer to the solution article (I honestly think I can\\'t explain it better). Decided to post it here because there was no Python solution in the solution article and most of the discussion posts with Python solutions seemed to lack cleanliness in their code. Therefore, here is mine:\\n\\n```\\nclass Solution(object):\\n    def longestPath(self, parent, s):\\n        \"\"\"\\n        :type parent: List[int]\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        def dfs(tree, s, source, node):\\n            if node == None:\\n                return 0\\n\\n            first_max, second_max = 0, 0\\n            for child in tree[node]:\\n                if child != source:\\n                    child_length = dfs(tree, s, node, child)\\n                    if s[child] != s[node]:\\n                        # update first and second max\\n                        if child_length > first_max:\\n                            second_max = first_max\\n                            first_max = child_length\\n                        elif child_length > second_max:\\n                            second_max = child_length\\n\\n            self.max_overall = max(self.max_overall, first_max + second_max + 1)\\n            \\n            return first_max + 1\\n\\n        tree = defaultdict(list)\\n        for i in range(1, len(parent)):\\n            tree[parent[i]].append(i)\\n            tree[i].append(parent[i])\\n        \\n        self.max_overall = 0\\n        \\n        dfs(tree, s, -1, 0)\\n        \\n        return self.max_overall\\n```\\n\\nLet me know if you have any suggestions on the algorithm or code readability.\\n\\nKeep grinding \\uD83D\\uDCAA\\uD83C\\uDFFB",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestPath(self, parent, s):\\n        \"\"\"\\n        :type parent: List[int]\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        def dfs(tree, s, source, node):\\n            if node == None:\\n                return 0\\n\\n            first_max, second_max = 0, 0\\n            for child in tree[node]:\\n                if child != source:\\n                    child_length = dfs(tree, s, node, child)\\n                    if s[child] != s[node]:\\n                        # update first and second max\\n                        if child_length > first_max:\\n                            second_max = first_max\\n                            first_max = child_length\\n                        elif child_length > second_max:\\n                            second_max = child_length\\n\\n            self.max_overall = max(self.max_overall, first_max + second_max + 1)\\n            \\n            return first_max + 1\\n\\n        tree = defaultdict(list)\\n        for i in range(1, len(parent)):\\n            tree[parent[i]].append(i)\\n            tree[i].append(parent[i])\\n        \\n        self.max_overall = 0\\n        \\n        dfs(tree, s, -1, 0)\\n        \\n        return self.max_overall\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043432,
                "title": "c-recursive-approach-with-explanation",
                "content": "# Intuition\\nBased On Depth First Search(DFS)\\n\\n# Approach\\nFirst we will create a adjacency list considering the edges to be directed from parent to child.Now we will apply DFS to it. For longest chain for every node, we will consider two longest straight chain from its children which are not having same character as of node(as tree is n-ary).Now answer will be max of answer and the sum of two longest chains of children +1(node itself). And from here we will return longest straight chain to its parent.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) for creating adjacency list.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(int curr,int n,vector<vector<int> > &adj,string &s){\\n        int temp=0;\\n        int most=0,more=0;\\n        for(int i=0;i<adj[curr].size();i++){\\n            int left=dfs(adj[curr][i],n,adj,s);\\n            if(s[curr]!=s[adj[curr][i]]){\\n                if(left>most) more=most,most=left;\\n                else if(left>more) more=left;\\n            }\\n        }\\n        ans=max(ans,1+more+most);\\n        return most+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        // creating adjacency list\\n        vector<vector<int> > adj(n);\\n        for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0,n,adj,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(int curr,int n,vector<vector<int> > &adj,string &s){\\n        int temp=0;\\n        int most=0,more=0;\\n        for(int i=0;i<adj[curr].size();i++){\\n            int left=dfs(adj[curr][i],n,adj,s);\\n            if(s[curr]!=s[adj[curr][i]]){\\n                if(left>most) more=most,most=left;\\n                else if(left>more) more=left;\\n            }\\n        }\\n        ans=max(ans,1+more+most);\\n        return most+1;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n        // creating adjacency list\\n        vector<vector<int> > adj(n);\\n        for(int i=1;i<n;i++){\\n            adj[parent[i]].push_back(i);\\n        }\\n        dfs(0,n,adj,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043428,
                "title": "c-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=1;\\n    int dist[100005];\\n    int longestPath(vector<int>& parent, string s) {\\n        \\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n\\n        //covert the parent array to adjacency matrix\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n\\n       \\n        dfs(0,s,adj);\\n        return ans;\\n\\n    }\\n\\n    void dfs(int src, string& s, vector<vector<int>> &adj)\\n    {\\n        dist[src] = 1;\\n\\n        for(int node: adj[src])\\n        {\\n            dfs(node,s,adj);\\n            if(s[src]!=s[node])\\n            {\\n                ans = max(ans,dist[src]+dist[node]);\\n                dist[src] = max(dist[src],dist[node]+1);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=1;\\n    int dist[100005];\\n    int longestPath(vector<int>& parent, string s) {\\n        \\n        int n = parent.size();\\n        vector<vector<int>> adj(n);\\n\\n        //covert the parent array to adjacency matrix\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n\\n       \\n        dfs(0,s,adj);\\n        return ans;\\n\\n    }\\n\\n    void dfs(int src, string& s, vector<vector<int>> &adj)\\n    {\\n        dist[src] = 1;\\n\\n        for(int node: adj[src])\\n        {\\n            dfs(node,s,adj);\\n            if(s[src]!=s[node])\\n            {\\n                ans = max(ans,dist[src]+dist[node]);\\n                dist[src] = max(dist[src],dist[node]+1);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043398,
                "title": "beats-92-dfs-detailed-explanation",
                "content": "# Intuition\\nThe idea behind this approach is to recursively traverse the tree starting from the root node, and for each node, keeping track of the longest and second longest paths among its children. The longest path that includes the current node and its children is then calculated by adding the longest and second longest path among the children, and the current node itself.\\n\\nThis approach allows the algorithm to explore all possible paths in the tree and keep track of the longest one. By updating the global variable path with the longest path found at each step and returning the longest path found at the current node, the algorithm is able to find the longest path in the entire tree.\\n\\n# Approach\\n1. Initialize a variable path to store the longest path found in the tree, set it to 1.\\n2. Create an adjacency list representation of the tree, where ***graph[i]*** stores the children of node *i*.\\n3. Call the helper function ***dfs*** with the root node (node 0) and the adjacency list as input.\\n4. In the ***dfs*** function, initialize two local variables ***rank1*** and ***rank2*** to keep track of the longest and second longest paths among the children of the current node, respectively.\\n5. For each child of the current node, call ***dfs*** recursively to calculate the longest path ending at that child. If the character at the current node and the child node are the same, skip that child.\\n6. Compare the length of the longest path ending at each child with ***rank1*** and ***rank2*** and update them accordingly. ***rank1*** stores the longest path among the children, and ***rank2*** stores the second longest path among the children.\\n7. Calculate the longest path that includes the current node and its children by adding ***rank1***, ***rank2*** and 1 (the current node itself) and compare it with the current value of the path variable. If the new path is longer, update the path variable with the new value.\\n8. Finally, return the value of ***rank1 + 1***\\n9. And return the ***path*** variable.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is **O(n^2)** where n is the number of nodes in the tree.\\n\\nThe algorithm uses a depth-first search (DFS) approach, where for each node it recursively calls the dfs function to explore all the children of the node. Since the number of children of a node can be at most n-1, the time complexity of the algorithm is O(n * (n-1)) which is roughly O(n^2).\\n\\n- Space complexity:\\nThe space complexity of this algorithm is O(n) where n is the number of nodes in the tree.\\n\\nThe algorithm uses an adjacency list to represent the tree, which requires O(n) space to store the children of each node. Additionally, the algorithm uses the stack space for the recursive calls which is also O(n) for the worst case. Therefore, the total space complexity of the algorithm is O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    private int path = 1;\\n    public int longestPath(int[] parent, String s) {\\n        ArrayList<Integer>[] graph = new ArrayList[parent.length];\\n        for (int i = 0; i < parent.length; i++){\\n            graph[i] = new ArrayList();\\n        }\\n        for(int i = 1; i < parent.length; i++){\\n                graph[parent[i]].add(i);\\n            }\\n        dfs(0, -1, graph, s);\\n        return path;\\n    }\\n    private int dfs(int currentNode, int parentNode, ArrayList<Integer>[] graph, String s){\\n        int rank1 = 0, rank2 = 0;\\n\\n\\n        for(int childNode : graph[currentNode]){\\n\\n            int longestChain = dfs(childNode, currentNode, graph, s);\\n\\n            if(s.charAt(currentNode) == s.charAt(childNode)){\\n                continue;\\n            }\\n            if(longestChain > rank1){\\n                rank2 = rank1;\\n                rank1 = longestChain;\\n            }else if(longestChain > rank2){\\n                rank2 = longestChain;\\n            }\\n        }\\n        path = Math.max(path, rank1 + rank2 + 1);\\n        return rank1 + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int path = 1;\\n    public int longestPath(int[] parent, String s) {\\n        ArrayList<Integer>[] graph = new ArrayList[parent.length];\\n        for (int i = 0; i < parent.length; i++){\\n            graph[i] = new ArrayList();\\n        }\\n        for(int i = 1; i < parent.length; i++){\\n                graph[parent[i]].add(i);\\n            }\\n        dfs(0, -1, graph, s);\\n        return path;\\n    }\\n    private int dfs(int currentNode, int parentNode, ArrayList<Integer>[] graph, String s){\\n        int rank1 = 0, rank2 = 0;\\n\\n\\n        for(int childNode : graph[currentNode]){\\n\\n            int longestChain = dfs(childNode, currentNode, graph, s);\\n\\n            if(s.charAt(currentNode) == s.charAt(childNode)){\\n                continue;\\n            }\\n            if(longestChain > rank1){\\n                rank2 = rank1;\\n                rank1 = longestChain;\\n            }else if(longestChain > rank2){\\n                rank2 = longestChain;\\n            }\\n        }\\n        path = Math.max(path, rank1 + rank2 + 1);\\n        return rank1 + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1754966,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1754973,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755140,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755143,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1754952,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755007,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755021,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1754954,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755296,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755049,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1754966,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1754973,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755140,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755143,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1754952,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755007,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755021,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1754954,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755296,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755049,
                "content": [
                    {
                        "username": "cmozola",
                        "content": "the week of the trees lol"
                    },
                    {
                        "username": "djslim",
                        "content": "some mutated tree from Chernobyl as mostly you need to think about them as graphs(rather than regular binary trees) \\uD83E\\uDD23"
                    },
                    {
                        "username": "Triquetra",
                        "content": "[@jithu7432](/jithu7432) In my opinion it\\'s worth it, personally I find tree questions the easiest around. There are not too many options to collect information when traversing a tree."
                    },
                    {
                        "username": "kmp1084",
                        "content": "We are now the children of the forest :)"
                    },
                    {
                        "username": "Piyush07p",
                        "content": "not good at tree\nany tip to master it\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@ajesk](/ajesk) Just commenting to let you know, you have a really great blog, loved the minimalistic design and of course the content."
                    },
                    {
                        "username": "jithu7432",
                        "content": "I hate trees :( \\nMaybe this is a good time to master it."
                    },
                    {
                        "username": "Yiiipu",
                        "content": "The week of no gaming at night"
                    },
                    {
                        "username": "ayush_sharma9009",
                        "content": "yupp"
                    },
                    {
                        "username": "ajesk",
                        "content": "Sort of more like \"misleading tree problems\". They are posed as tree problems, but solve like graphs."
                    },
                    {
                        "username": "omscode",
                        "content": "Others starting their day by having good breakfast , we start by tree lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "charonme",
                        "content": "coincidentally I\\'m just reading The Fall of Hyperion, so the idea of starting my day with a tree doesn\\'t seem very comfortable"
                    },
                    {
                        "username": "Asential",
                        "content": "I wish a tree fell on me :\\'\\')"
                    },
                    {
                        "username": "santanusen",
                        "content": "Leetcode has granted your wish today."
                    },
                    {
                        "username": "apoorvyash",
                        "content": "bst or red-black? ;)"
                    },
                    {
                        "username": "jithu7432",
                        "content": "lol"
                    },
                    {
                        "username": "b_clodius",
                        "content": "Very proud of my progress on this one.  Looking back at my journal I didn\\'t even bother attempting this problem during the contest on 4/16/2022 https://leetcode.com/contest/weekly-contest-289/.\\n\\nTonight I took my time, thought about reasonable approaches, did a little debugging and solved in my first try in about 40 minutes!"
                    },
                    {
                        "username": "Idrissa_242",
                        "content": "Congrats 👏and Keep up 💪"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "u dropped ur crown"
                    },
                    {
                        "username": "daimehe123",
                        "content": "Your working is deserve"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "way to go !!"
                    },
                    {
                        "username": "dgbirm",
                        "content": "You should be proud you\\'ve been working hard!"
                    },
                    {
                        "username": "longluo",
                        "content": "**Attention:**\\n\\nOnly no pair of **adjacent nodes** on the path have the same character, not the **path** have the same character."
                    },
                    {
                        "username": "VPuuska",
                        "content": "Thank you thank you thank you, I spent an embarrassing amount of time thinking the entire path could not have repeated characters"
                    },
                    {
                        "username": "calm27",
                        "content": "+like. valuable comment. "
                    },
                    {
                        "username": "nishant7372",
                        "content": "Two longest paths in a subtree of node x can make up the max longest path.\n\n### Approach:\nStep 1. Find two longest path out of n children for each node.\nStep 2. Update global max value if longestPath1+longestPath2> max.\nStep 3. Return longest path for each child node to parent node using DFS.\n\n* If adjacent node letters are not equal set pathlength for children = pathlength+1.\n* If adjacent node letters are equal set pathlength for children = 0."
                    },
                    {
                        "username": "emayakeerthi",
                        "content": "Could you explain why we use two variable to track down the length?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@DivyanshuS](/DivyanshuS) Click [👁](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3042998/java-c-dfs-explained-beats-85/) to see solution"
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "Does this involve taking dfs at each node ? Because I am doing the same and it gives time limit exceeded"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Friendly reminder ... the longest path doesn't need to go through root.\n\nFor the test case: \n\n```\n[-1,0,1]\n\"aab\"\n```\n\nwith tree\n\n```txt\n0(a)\n  1(a)\n     2(b)\n```\nThe answer is 2 not 1, which is the path of 1(a)-2(b)."
                    },
                    {
                        "username": "maazk9119",
                        "content": "[@thm1988515](/thm1988515) \\n\\nThe answer would be edge+1.\\nExample:\\n[-1,0,0,0]\\n\"aaaa\"\\nExcepted: 1"
                    },
                    {
                        "username": "thm1988515",
                        "content": "But isn\\'t 1(a)-2(b) = 1 not 2?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "heg816",
                        "content": "Another tree problem, huh"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TBH this should be a medium problem."
                    },
                    {
                        "username": "0xder",
                        "content": "more like graph related"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "pls lemme feel good about myself for solving a hard TT"
                    },
                    {
                        "username": "tr1ten",
                        "content": "hint: similar to diameter of a tree"
                    },
                    {
                        "username": "kirsty",
                        "content": "Was just thinking this. I think it is *probably* a good starting point (haven\\'t solved this one fully yet though).\\nhttps://leetcode.com/problems/diameter-of-binary-tree/description/"
                    }
                ]
            },
            {
                "id": 1755269,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755491,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755343,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755338,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755280,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755704,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755482,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1756253,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755981,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755805,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "I love how Leetcode is building up on the same tree concept in the past 3 daily challenge questions!! 😍👌👌"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "others start their day with a fruit, we start with a tree  \\uD83D\\uDE02"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "Whats wrong with this code passed 138/141 testcases\\nclass Solution {\\npublic:\\n\\n    int vis[100001]={0};\\n    int maxNode=0 ,maxVal=-1;\\n    void dfs(int node , int d , vector<int> G[] , string &str){\\n        vis[node]=1;\\n        if(d>=maxVal){\\n            maxVal=d , maxNode=node;\\n        }\\n\\n        for(auto child : G[node]){\\n            if(!vis[child] and str[child] != str[node]){\\n                dfs(child , d+1 ,G , str);\\n            }\\n        }\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> G[n];\\n        for(int i=1;i<n;i++){\\n            G[parent[i]].push_back(i);\\n            G[i].push_back(parent[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i , 1 , G , s);\\n        }\\n        maxVal=-1;\\n        memset(vis , 0 , sizeof(vis));\\n        dfs(maxNode , 1 , G , s);\\n        return maxVal;\\n    }\\n};"
                    },
                    {
                        "username": "dollysingh",
                        "content": "Important Hint:\n\n1. DFS\n2. Keep track of two max variables at each subtree i.e firstMax, SecondMax path lengths and maintain global max:\n     a. No child, return 1 \n     b. One or Many child, track, max length's and return length's to its parent.\n\nHope it will help. \nThanks! Have a great Day!\n\nSolution: \nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3043699/easy-to-understand-solution/"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "trees --  tress -- stress ---  !!STRESS!!\\uD83D\\uDE31"
                    },
                    {
                        "username": "in3pid",
                        "content": " --- DISTRESS"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are solving daily challenges and your mind got biased by last few days\\' problems (which is the case with me), here are a few points to get you on track -\\n\\n1. They are not asking that all characters in the path has to be different. Only two adjacent characters in the path has to be different -\\n```\\n \"aba\" is allowed.\\n```\\n\\n2. Only checking for paths from an ancestor to one of descendants is not enough. The edges are undirected. So, a path starting from a descendant node - going all the way up to an ancestor - and then going down to another descendant in another branch is also a valid \"path\".  -\\n```\\n  a\\n /\\\\\\nb  c\\n\\n\"bac\" is a valid path in the tree above.\\n```\\n\\nTry to solve the problem now with the above two tips. If it is still a bit confusing check the next tip.\\n\\n3. A bottom-up (post-order DFS) walk should do the job. At each node, track the longest and the second-longest path lengths returned by children with different character than the current node. Call these path lengths ```l1``` and ```l2```.  Have a global ```maxlength``` and update it if  ```l1 + 1 + l2``` betters ```maxlength```.  Finally, return ```l1 + 1``` as the max path length to the parent caller.\\n\\nHope you won\\'t mind upvoting if the post helped."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This problem is very similar to \"Find the longest path\". Click here for Simplest possible solution with image illustration. \\uD83C\\uDFC1\\uD83C\\uDFC1 BEATS 98 % \\uD83C\\uDFC1\\uD83C\\uDFC1\\nhttps://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Point to remember.\nTo find longest path for current node : Add only 2 longest path values returned from children + 1.\nBecause : Only two longest paths from children can generate longest path for current node.\nWas adding values returned from all children leading to failure at 17th test case."
                    },
                    {
                        "username": "aditya3773",
                        "content": "Thankyou buddy\\nWas stuck on this same doubt for an hour.\\n"
                    },
                    {
                        "username": "mohithaakash",
                        "content": "Damn I solved a Hard problem on my own :_)"
                    },
                    {
                        "username": "primeSuspect",
                        "content": "I wish nothing but the very best to all, who are working so hard to make them selves better every day. \\n\\n\"THE ROAD TO YOUR DREAMS, ONE LEETCODE AT A TIME\""
                    }
                ]
            },
            {
                "id": 1755774,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1755240,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1755087,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1755000,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1755259,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1835064,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1770768,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1766911,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1759445,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1758184,
                "content": [
                    {
                        "username": "user2895nD",
                        "content": "Hint: Don't consider edge between nodes if two nodes have same label. Now you have to just find longest Path in each tree (connected components) and return longest of all."
                    },
                    {
                        "username": "niththish21",
                        "content": "what's with the last testcase (141) ?\ncan somebody explain me?\n[my solution](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/submissions/877208010)"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Simillar to what others have already mentioned. This is just like the diameter of a binary tree. So a node can contibute to the final result in two ways :-\\n\\n1. Either it forms the maximum length path with two of its children\\n2. Or it forms a maximum path with its parent.\\n\\nAlso a path can have nodes with same character. But no 2 adjacent nodes can have same characters.\\n\\nHope it helps :)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "so leetcode doesn\\'t just choose daily challenge randomly, they actually have a topic for each week?"
                    },
                    {
                        "username": "gokulre",
                        "content": "The topic is listed upfront. You can check `What topics will be covered in January\\'s challenge?` section here: https://leetcode.com/discuss/general-discussion/655704/January-LeetCoding-Challenge"
                    },
                    {
                        "username": "rishi2000",
                        "content": "Report this, to be a medium level problem"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Rishikesh Pawar](/rishi2000) yes exactly!"
                    },
                    {
                        "username": "djslim",
                        "content": "If you have problem with this one, try this one first: https://leetcode.com/problems/diameter-of-binary-tree/description/"
                    },
                    {
                        "username": "0xder",
                        "content": "this one is pretty close to 1245"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video : https://youtu.be/RvRjxeS6AeM"
                    },
                    {
                        "username": "FMK52",
                        "content": "I understood the approach based on last two problems, but got stuck on how to convert this parent array to child array and so forth. All in all good problem learnt a lot!!"
                    },
                    {
                        "username": "adityasoni2019",
                        "content": "WHY IS LEETCODE GIVING GRAPHS/DIFF TREE QUESTIONS \\uD83D\\uDE2D\\uD83D\\uDE2D\\n"
                    }
                ]
            },
            {
                "id": 1757111,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756939,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756534,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756457,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756439,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756420,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756289,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756221,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756180,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756167,
                "content": [
                    {
                        "username": "Rustam-Z",
                        "content": "The tree is n-ary, and we need to create a path. Path has its start and end. So, we can only visit two of its children. We can take only two longest children path. And for this reason we need to keep track of longest and second_longest. \\n\\n"
                    },
                    {
                        "username": "user5418EK",
                        "content": "how can I optimise it ? TLE AT testcase 12\\n\\nclass Solution {\\npublic:\\nint ans=1;\\n    int dfs(vector<vector<int>>&visited,string s,int i){\\n       int x=1;\\n     for(int j=0;j<visited[i].size();j++){\\n         int a=dfs(visited,s,visited[i][j]);\\n         if(x<=a){\\n             if(s[i]!=s[visited[i][j]]){\\n                 x=a+1;\\n             }\\n             else{\\n                 x=a;\\n             }\\n             ans=max(ans,x);\\n         }\\n         else if(s[i]!=s[visited[i][j]]){\\n\\n            ans=max(ans,x+a);\\n         }\\n     }\\n     return x;\\n    }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=parent.size();\\n            vector<vector<int>>visited(n);\\n            for(int i=0;i<n;i++){\\n                int x=parent[i];\\n                if(x>=0)\\n                visited[x].push_back(i);\\n            }\\n            dfs(visited,s,0);\\n            return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which causes many many copies of the string.  \\nUse a reference instead.\\n\\nBTW: To format your code properly here in the discussions put a blank line before and after the code and indent each line with four *additional* spaces."
                    },
                    {
                        "username": "gbiems",
                        "content": "Question for the community - do you think these questions are enhanced by defining a tree as an undirected graph with cycles and a root at node 0? It seems like once you do that, you could just as easily provide the initial data structure as an n-ary tree. I think this came up in yesterday\\'s problem as well. \\n\\nI\\'m definitely not an advanced leetcoder, so believe me when I say I know there\\'s still a good chance I\\'m missing something. So far, it just seems like an unnecessary complexity that isn\\'t really related to the problem at hand, though I\\'m really interested in hearing comments to see if there\\'s a benefit (in terms of solving the problem or in terms of interesting complexity to the problem) to this I\\'m not seeing. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I think these questions should be similar to the ones in a real interview. And some interviewer might phrase the exercise this ways and present this kind of input to see if you can work with that. I think it\\'s nice to know that I can re-encode the data into a data structure that\\'s more suitable for my algorithm."
                    },
                    {
                        "username": "gbiems",
                        "content": "I mean tot say \"with no cycles\", not \"with cycles\""
                    },
                    {
                        "username": "mcleantom",
                        "content": "* Use depth first search\\n* The longest path that goes through a node is the first longest path of a valid child node + second longest path of a valid child node + 1\\n* A child node is valid if its character doesnt equal the current nodes character.\\n* Keep track of the maximum seen path so far\\n"
                    },
                    {
                        "username": "alecn2002",
                        "content": "Task is incorrectly formulated.\\nThe length of **path** 0->1->3 is 2, not 3.\\n3 is the number of nodes on the path.\\nPlease be accurate in task formulation."
                    },
                    {
                        "username": "priyankar-sarkar",
                        "content": "question deserves to be medium!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "TLE on 141/141 testcases!"
                    },
                    {
                        "username": "space_invader",
                        "content": "![image.png](https://assets.leetcode.com/users/images/fc029f17-b270-40a9-b12e-67775757691a_1673632192.4901555.png)\\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s not a tree!!!\\nIn case of tree the longest path should contain `0`, but there are test cases like \\n```\\n[-1,0,1]\\n\"aab\"\\n```\\nAnd correct answer is 2(1st and 2nd indexes). If it was a tree, the correct answer would be 1(only root)"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "Can anyone help me my solution is giving TLE \n `\nclass Solution {\npublic:\n    int solve(vector<vector<int>>& adj, string s, int ix, int& ans,vector<int>&vis){\n        vis[ix]=true;\n        int maxi=1;\n        for(int i=0; i<adj[ix].size();i++){\n            if(!vis[adj[ix][i]]){\n                int temp=solve(adj,s,adj[ix][i],ans,vis);\n\n                if(s[ix]!=s[adj[ix][i]]){\n                    maxi+=temp;\n                }else{\n                    ans=max(ans,temp);\n                }\n            }\n        }\n\n        return maxi;\n    }\n    int longestPath(vector<int>& parent, string s) {\n        int n=parent.size();\n        int ans=0;\n        vector<vector<int>>adj(n);\n\n        for(int i=1;i<n;i++){\n            adj[parent[i]].push_back(i);\n            adj[i].push_back(parent[i]);\n\n        }\n        vector<int>vis(n);\n        return max(ans,solve(adj,s ,0, ans,vis));\n    }\n};\n`"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "[@Purvi jha](/purvi_jha) You only have to construct tree in one direction.  adj[i].push_back(parent[i]); can be avoided. By doing this, you can also avoid creating visited array. Your logic in solve method looks incorrect too. Can go through the logic again. Hope it helps"
                    }
                ]
            },
            {
                "id": 1756058,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1756033,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755919,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755916,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755893,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755877,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755839,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755836,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755813,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755809,
                "content": [
                    {
                        "username": "LEESINHYUNG",
                        "content": "this one is doable hard problem. I would definitely try to do it in a weekly contest."
                    },
                    {
                        "username": "kmp1084",
                        "content": "Shouldn\\'t this question read \"Return the number of nodes on the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them\"? Like how can parent = [-1] and s = \"a\" have answer of path length = 1. what path are they talking about? There is only one node i.e. the root node!"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "sht again a tree"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This hard questions are really simple. But once we read it as hard we loose our confidence to solve"
                    },
                    {
                        "username": "eagle_akshay",
                        "content": "took 2 hours to figure this question out."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found an efficient java solution to this Hard problem here: https://youtu.be/ao5b6KZdhZY"
                    },
                    {
                        "username": "Pzot",
                        "content": "`parent =\\n[-1,0,0,0]\\ns =\\n\"aabc\"\\nOutput\\n2\\nExpected\\n3`\\nTree visualized:\\n  a\\n/ |  \\\\\\\\\\na b c\\nThe tree doesn\\'t have depth 3, am i missing someting or is this an error?"
                    },
                    {
                        "username": "shantanu1405",
                        "content": "the goal is to find the longest path, and we do not necessarily have to start from root (0)"
                    },
                    {
                        "username": "mohamedae17",
                        "content": "it\\'s not about depth of tree. it is about The largest string without repeating a letter . 2 -> 0 -> 3. The length of this path is 3, so 3 is returned."
                    },
                    {
                        "username": "AbhiKS",
                        "content": "Hi\\nI got the basic logic in first attempt but somehow my code gives TLE. This was my solution. If check official answer, you will find it almost similar but my code gives TLE. Can someone explain me where my code can be improved?\\n\\n\\n\\n    int dfs(vector<vector<int>>& edgesMap, string s, int vertex, int& ans) {\\n        int firstMax = 0, secondMax = 0;\\n        for(int node: edgesMap[vertex]) {\\n            int x = dfs(edgesMap, s, node, ans);\\n            if(s[vertex] == s[node]) continue;\\n            if(x > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = x;\\n            } else if(x > secondMax) {\\n                secondMax = x;\\n            }\\n        }\\n        if(firstMax + 1 + secondMax > ans) ans = firstMax + 1 + secondMax;\\n        return firstMax + 1;\\n    }\\n\\n    int longestPath(vector<int>& parent, string s) {\\n        int n = parent.size();\\n        int ans = 0;\\n        vector<vector<int>> edgesMap(n);\\n        for(int i = 1; i < n; i++) {\\n            edgesMap[parent[i]].push_back(i);\\n        }\\n        dfs(edgesMap, s, 0, ans);\\n        return ans;\\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `s` by value which means the `std::string` gets copied for each call of the function.  \\nMake that a reference (or a `std::string_view`) instead."
                    },
                    {
                        "username": "Rachit070203",
                        "content": "Why my code is failing ??\\nAll testcases are passed except testcase 140th  ,can any body help me in this \\n\\n `class pair{\\n    char c;\\n    int len;\\n    pair(char c, int len)\\n    {\\n        this.c=c;\\n        this.len=len;\\n    }\\n\\n}\\nclass Solution {\\n    int ak;\\n     public pair DFS(ArrayList<Integer>[] arr, int i, String app,boolean bool[]) {\\n       \\n\\n         if(arr[i]==null||arr[i].size()==1)\\n         {           \\n\\n            return new pair(app.charAt(i-1),1);\\n             \\n         }\\n          bool[i]=true;\\n        \\n         ArrayList<Integer> x=new ArrayList<>();\\n            for (int j = 0; j < arr[i].size(); j++) {\\n              if(bool[arr[i].get(j)]==false)\\n              {\\n               pair p=DFS(arr,arr[i].get(j),app,bool);\\n               if(p.c!=app.charAt(i-1))\\n               {\\n                     \\n                  x.add(p.len);\\n\\n               }\\n               else \\n               ak=Math.max(ak,p.len-1);\\n           \\n              }\\n            }\\n            System.out.println(ak);\\n          if(x.size()!=0)\\n            {\\n              Collections.sort(x);\\n               int max1=x.get(x.size()-1);\\n           if(x.size()>=2)\\n              {\\n                 \\n                  int max2=x.get(x.size()-2);\\n                  int ans=max1+max2;\\n                  ak=Math.max(ak,ans);\\n                  return new pair(app.charAt(i-1),Math.max(max1,max2)+1);\\n\\n              }\\n              ak=Math.max(ak,max1);\\n              if(i==1)\\n              return new pair(app.charAt(i-1),max1);\\n              else\\n              return new pair(app.charAt(i-1),max1+1);\\n            }\\n            else\\n            ak=Math.max(ak,0);\\n            return new pair(app.charAt(i-1),0);\\n           \\n  \\n        \\n     }\\n    public int longestPath(int[] parent, String s) {\\n        int k=0;\\n        ak=0;\\n        int gp[][]=new int[parent.length-1][2];\\n        if(parent.length==1)\\n        return 1;\\n        int n=parent.length;\\n\\n         for (int i = 0; i < n - 1; i++) {\\n            gp[i][0] = parent[i+1]+1;\\n            gp[i][1] = i+1+1;\\n        }\\n        ArrayList<Integer>[] arr = new ArrayList[n + 1];\\n        boolean []bool=new boolean[arr.length+1];\\n\\n         for(int i=0;i<n-1;i++)\\n        {\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n        }\\n           bool[0]=true;\\n           ArrayList<Integer> ans=new ArrayList<>();\\n           ans=arr[1];\\n           ans.add(0);\\n           arr[1]=ans;\\n           for (int i = 1; i < arr.length; i++) {\\n            System.out.println(i + \"->\" + arr[i]);\\n        }\\n        pair p= DFS(arr,1,s,bool);\\n        ak=Math.max(ak,p.len)+1;\\n        return ak;\\n    }\\n}`\\nFailed Testcase:-\\n[-1,156,5,200,41,259,221,25,196,86,165,194,201,90,207,121,145,222,211,181,90,231,10,209,90,195,90,149,174,150,11,105,49,191,98,87,249,205,233,2,79,96,195,214,101,121,138,231,212,139,54,61,105,200,233,159,95,105,259,41,41,13,249,73,86,258,111,151,115,221,212,80,211,29,132,30,207,57,235,90,105,128,157,9,145,194,235,181,41,124,214,191,245,31,150,158,0,119,13,169,17,42,38,18,91,195,132,155,99,226,85,235,216,216,141,207,101,194,31,137,256,114,233,110,191,88,120,123,21,257,220,242,31,244,31,114,187,208,33,137,96,54,10,201,164,12,148,133,216,31,10,52,191,205,195,52,5,223,185,12,93,133,81,246,28,194,242,137,254,41,71,1,78,30,244,205,43,43,154,198,101,192,133,188,6,64,141,240,235,232,123,194,30,109,52,86,129,3,156,126,249,85,159,56,69,240,112,31,33,151,1,233,195,159,52,135,207,33,59,194,212,110,214,220,41,138,10,80,60,42,50,219,156,105,119,96,163,55,33,257,242,205,90,6,86,246,110,176,75,52,236,96,98,96,179,172,235,161,94,201]\\n\"ysqlkqhlalzehtojfmzyhgwpimgwzimkrvxtiahfgkeyhslpseckzopfmahcwaokqxhcchcoagftomqzsidvosepjfhdkexeftskbfaewbmacfrvygskbwsumucuqekcgbfbtlxkoijbqehcrkvblawjgjoamboxnhzbzrwopfjduwvjlaiesoshhicgtmhuywyswyaeamuzxazhoxkwwgmwfdljdrajzwjfklqsmgermkrhvdpabrisvybmxrpapmie\""
                    },
                    {
                        "username": "Rachit070203",
                        "content": "[@darkzodiac12](/darkzodiac12)  test case 141 is a to big tc"
                    },
                    {
                        "username": "darkzodiac12",
                        "content": "Were you able to figure out what was different in testcase 141?"
                    },
                    {
                        "username": "shahsaahil20",
                        "content": "This is a Medium problem."
                    }
                ]
            },
            {
                "id": 1755802,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755767,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755746,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755725,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755678,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755674,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755673,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755665,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755657,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755626,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "those are graphs problem not tree I\\n guess"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Got it right but made it too complicated for my own good I feel\\uD83D\\uDE36"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def longestPath(self, parent: List[int], s: str) -> int:\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]"
                    },
                    {
                        "username": "chezzyfries",
                        "content": "Anyone with TLE on case 12? Kind of unable to find the reason. Algo is O(n). Maybe the bound is too tight?\\nPS: Yes I pass adj list by reference"
                    },
                    {
                        "username": "santanusen",
                        "content": "Are you passing the string by ref?"
                    },
                    {
                        "username": "Diamond_Gun",
                        "content": "Can someone please explain why\\n`\\n[-1,0,1,2,3,4]\\n\"zzabab\"\\n`\\nis 5, but I think it is 3 (z - a - b)"
                    },
                    {
                        "username": "powerup7",
                        "content": "because \n1. the array for string isn't a normal array representation of a binary tree\n2. The tree if you look at parents is one long line from root all the way left.\n\n \n              z\n           z\n        a\n     b\n   a\n b\na\n\nIs pretty much the representation based on the parents array."
                    },
                    {
                        "username": "fahimabrar",
                        "content": "It is a bit confusing. I think there adjacent node means no two nodes connected to each other could hold the same label."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I don\\'t get it. How this `[-1,0,1,2,3,4]` with `zzabab` can have 5 the longest path and not 3?"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think I misunderstood the requirements. So, I thought that we need to find the longest path with unique letters but it\\'s expected only that the next node has a different letter... damn!"
                    },
                    {
                        "username": "utalmighty",
                        "content": "For me the hardest part was constructing a tree."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "simple explanation\\n1. Choose two max length node\\n2. If direct child node has same char, then look for children of that child\\n\\nhttps://youtu.be/TKzOGBia-u4"
                    },
                    {
                        "username": "Nick_Bykon",
                        "content": "Again, another tree challenge. Need to sip coffee"
                    },
                    {
                        "username": "Kaviarasi",
                        "content": "Have a doubt.  can path include a edge twice?\n     a\n  /  |  \\\\\nb   c d \n|    |    |\ne   f   g\n\n\nwhat is the answer for this?\n\nis  e-b-a-c-f? \nor c-b-a-c-f-f-c-a-d-g?"
                    }
                ]
            },
            {
                "id": 1755622,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755560,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755556,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755545,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755483,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755473,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755458,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755447,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755437,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755419,
                "content": [
                    {
                        "username": "appukuttysri",
                        "content": " \\n       ```\\n             int dfs(vector<vector<int>>child,string& s,int i,int &d){\\n    int l=0;\\n    int r=0;\\n    for (auto it:child[i]){\\n         \\n          int cur=dfs(child,s,it,d);\\n          if(s[i]==s[it]) continue;\\n         \\n          if(cur>l) l=cur;\\n          if(l>r){ swap(l,r);}\\n         \\n\\n         \\n    }\\n    d=max(d,l+r+1);\\n     return max(l,r)+1;\\n     }\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.size();\\n        vector<vector<int>>child(n,vector<int>());\\n        for(int i=1;i<n;i++){\\n            child[parent[i]].push_back(i);\\n        }\\n        int d=0;\\n     dfs(child,s,0,d);\\n     return d;\\n    }\\n  \\nwhy is it giving tle? thanks in advance"
                    },
                    {
                        "username": "madiii",
                        "content": "I was getting a TLE, only when I passed the string of characters by reference it got accepted."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Approach\\n1.  Do a DFS traversal for all the adjacent nodes.\\n2. Find 2 max Paths from all the adjacent nodes as we can include only 2 paths.\\n- The 2 max paths should be those such that the charactes are different from that of current node.\\n\\n3. CurMaxPath will be (1+maxLen1+maxLen2).\\n- If there are no such paths with different adjacent characters, maxLen1 and maxLen2 will be 0.\\n\\n4. Store the ans as max(ans, curMaxPath).\\n5. Return path to the parent node passing through current node as: 1+max(maxLen1,maxLen2).\\n- For parent node we can only include one path."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Fun fact: `Leetcode 543 - Find Diameter` which is not very far from this problem is marked an `Easy` and this one is `Hard` \\uD83D\\uDE12\\uD83D\\uDE12. Neither is this an easy `Hard`, nor is this a hard `Medium`. This is a Medium `Medium` \\uD83D\\uDC35"
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Woohoo! One the few times I have gotten a hard problem. And my code was nearly 100% right the first time. Except for a single +1."
                    },
                    {
                        "username": "123roger456",
                        "content": "Why are we taking two max lengths?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Roger Jakcon](/123roger456) because there is one global maxima length for answer. This length will not necessarily be for a staright top to bottom path, but might be for a path that has a bend i.e path starts from left subtree, covers a node and then goes to right subtree. Apart from this we need to return to the parent the length for a straight path that does not have bend so that parent can check its other subtree. You should probably try \"Find Longest path in tree\" first to get more clarity. \\nIf you want a good explanation, read here(no spoilers, code is at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "pioneer10",
                        "content": "xmas trees are all around for the whole week"
                    },
                    {
                        "username": "Gupta_Ayush",
                        "content": "parent=[-1,0]  s=\"mm\"\\nwhy the output should be 1 not 0?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Gupta_Ayush](/Gupta_Ayush) because a single node also forms a path with length 1. Return 1 + whatever you get from children ... to avoid this.\\n\\nFor simple explanation, read this (no spoilers, code at the end): https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/"
                    },
                    {
                        "username": "TuringJest",
                        "content": "I found this one easier to implement than the one from yesterday"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@sarpalmadhav](/sarpalmadhav) finding O(n) solution of yesterdays problem definitely felt trickier. But yes, this one shouldn\\'t be a hard problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Flo](/TuringJest) It was same, little more or less - but this should not have been a hard, should just be a medium like yesterday\\'s problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "   \\n     class Solution:\\n    def longestPath(self, parent, s):\\n        result= [[] for i in range(len(s))]\\n        for i,j in enumerate(parent):\\n            if j >= 0:\\n                result[j].append(i)\\n        res = [1-1]\\n        def rec_dfs(iter_s):\\n            coin = [0]\\n            for j in result[iter_s]:\\n                cur = rec_dfs(j)\\n                if s[iter_s] != s[j]:\\n                    coin.append(cur)\\n                    \\n            ans= nlargest(2, coin)\\n            res[0] = max(res[0], sum(ans) + 1)\\n            return max(ans) + 1\\n        \\n        rec_dfs(0)\\n        return res[0]\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dara singh](/darasingh12998) buddy please don\\'t post solution in discussion tab, it acts as a spoiler for those who just want minor hints!!"
                    }
                ]
            },
            {
                "id": 1755401,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755372,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755335,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755332,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755311,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755307,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755299,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755289,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755287,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755150,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "please god not another tree problem "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ken Jiang](/kenzoengineer) But god is saying that, son- this is same as yesterday\\'s tree problem. What a loving god he is!!"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Its only 13th day of month  and m dealing with the hard level questions . This is not fair for  me. \\nThere are many  more topics apart from trees and graphs . You know what leetcode, I am  going to plant some trees in my garden , may be I feel better. Good Bye !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vikas Soni](/VikasSoni10) If you did yesterday\\'s question, then this would not be that difficult. It is not a hard at all, should have tagged medium."
                    },
                    {
                        "username": "thm1988515",
                        "content": "  [a]\n     /\n  [a]\n  /\n[b]\nCan any one please explain how this is 2? from [a] to [b] looks like 1 to me!\nThanks!"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "The `path` means the number of nodes, not the edges"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "if we number the nodes as 0,1,2 then 1->2 forms the longest path of length 2\\n0\\n/\\n1\\n/\\n2\\nhope it helps"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "Hello fellows i am facing a problem that  while running my code\\nMy solution gives TLE for test cases with s.,length()=100000\\nI am not able to figure out where the problem is.\\nPlease help if possible!!\\nThank You\\n `class Solution {\\npublic:\\nint result=0;\\nint dfs(vector<int> adj[],vector<int> parent,string s,int source)\\n{\\n    \\n\\nif(adj[source].size()==0)\\nreturn 1;\\n\\nint maxLen1=0,maxLen2=0;\\n\\n\\n    for(int i=0;i<adj[source].size();i++)\\n{\\n\\nint len=dfs(adj,parent,s,adj[source][i]);\\n// checking if parent and child does not have same character\\nif(s[adj[source][i]]!=s[source])\\n{\\n    //calculating maximum and second maximum\\n   if(len>maxLen1)\\n   {\\n       maxLen2=maxLen1;\\n       maxLen1=len;\\n   }\\n   else\\n   maxLen2=max(maxLen2,len);\\n}\\n\\n}\\n\\nint res=0;\\nres=maxLen1+maxLen2+1;\\nresult=max(result,res);\\nresult=max(result,(maxLen1+1));\\n\\n//returning values \\nif(source!=0 and s[parent[source]]!=s[source])\\nreturn maxLen1+1;\\nelse \\nreturn 0;\\n\\n}\\n    int longestPath(vector<int>& parent, string s) {\\n        int n=s.length();\\n        vector<int> adj[n];\\n\\n// creating graph for DFS\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n \\n// calling dfs on adj with source 0\\n        int l=dfs(adj,parent,s,0);\\n    \\n        return result;\\n    }\\n};.`"
                    },
                    {
                        "username": "ayush1411code",
                        "content": "thank you buddy!!!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aman](/ayush1411code) buddy, two tips for you :\n1. Use triple backticks while posting code in markdown to make it readable.\n2. Never pass variables that will remain same in a recursive function, There is no need to pass parent, adj and string s in function - make them global. You are unnecessarily copying these heavy variables in each recursive function call.\n\nRead more about this here : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/ "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Either I\\'m actually starting to become good at leetcode, or this should probably not be a hard problem.\\n\\nIts just [Diameter of a Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) with a trivial side constraint. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Alec Kerrigan](/aleckerrigan) I have the same feeling- this is not hard ,neither `easy hard` nor a `hard medium`. This is just a `medium medium`.  Fun fact Find diameter (leetcode 543) is an easy problem and this one is hard LOL!! 🤣"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Another tree problem....\\nThis Week is full of tree\\'s. . . ."
                    },
                    {
                        "username": "Jagadeesh-tamizh",
                        "content": "TREE WEEK \\uD83C\\uDF32\\uD83C\\uDF33"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "I love leetcode intend to us to shred trees this week."
                    },
                    {
                        "username": "mukul381",
                        "content": "can any one help me ??"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mukul kumar](/mukul381) read here for simple explanation : https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3044016/simple-solution-detailed-explanation-beats-98/\\n\\nIf you still have doubts, reply here- I will check back in some time"
                    },
                    {
                        "username": "Varda123",
                        "content": "Can anyone explain the problem ? I don\\'t understand the question"
                    }
                ]
            },
            {
                "id": 1755136,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1755131,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1755100,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1755082,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1755080,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1755076,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1755068,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1755061,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1755038,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            },
            {
                "id": 1754998,
                "content": [
                    {
                        "username": "be_quick",
                        "content": "stop traumatizing people by dumping code forces  definition of trees.\\nkeep it dumb Binary tree or BST."
                    },
                    {
                        "username": "prashant_23",
                        "content": "Is the tree supposed to be binary?"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "no.. its a tree and any number of branches can be there for a node! BRAAHHH!!"
                    },
                    {
                        "username": "rghotra",
                        "content": "If we exclude the adjacent nodes can't be the same character restriction, the longest path would represent the diameter of the tree. How can we modify this algorithm to include the adjacent characters restraint? Answer below.\n\n\n\n\n\n\n\nIn the diameter calculation algorithm, we recursively calculate the maximum diameter at each node. Psuedo code looks something like this:\n\nmax_diameter = 0\nfunction dfs(node):\n....iterate through children and call dfs(child) to get largest 2 heights\n....max_diameter = max(max_diameter, sum of largest 2 child node heights)\n....return 1 + largest child's height\n\nWhen after updating the max_diameter variable, we can check if the current node's character is equal to the parent node's character; if it is, we return 0 for the maximum height of that child; this will prevent the algorithm from forming a diameter through those two nodes."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What is the definition of a path in this problem? I thought a path has to go through the root, but with [-1, 0 1] and \"aab\", it is expecting 2 to be the output.  So that means a path doesn\\'t have to go through the root?\\n  ```\\n       [a]\\n       /\\n    [a]\\n    /\\n[b]\\n```"
                    },
                    {
                        "username": "milehzgnak",
                        "content": "Yes, path does not need to go through the \\'root\\'. It helps to imagine the tree as just an undirected graph with no cycle. A path in this case simply means the only way to travel from a node X to another node Y."
                    },
                    {
                        "username": "judgementdey",
                        "content": "The path doesn\\'t have to contain the root. It just needs to be a sequence of any connected nodes."
                    },
                    {
                        "username": "Psyccc",
                        "content": "Another day, another tree"
                    },
                    {
                        "username": "Dumpo04",
                        "content": "This hard problem is much more easier than the previous medium problem LOL"
                    },
                    {
                        "username": "qiushile",
                        "content": "I misunderstood the question at the first time which I thought it is no SAME nodes in the path.\nIt took me TWO HOURS to figure out what ADJACENT means. \nT_T"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Do a DFS from the root. At each node, calculate the longest path we can make from two branches of that subtree."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Another garage kit tree problem where the tree comes disassembled."
                    },
                    {
                        "username": "gokulre",
                        "content": "classic dfs problem"
                    }
                ]
            }
        ]
    }
]