[
    {
        "title": "Koko Eating Bananas",
        "question_content": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\n&nbsp;\nExample 1:\n\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n\nExample 2:\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n\nExample 3:\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n\n&nbsp;\nConstraints:\n\n\t1 <= piles.length <= 104\n\tpiles.length <= h <= 109\n\t1 <= piles[i] <= 109",
        "solutions": [
            {
                "id": 769702,
                "title": "python-clear-explanation-powerful-ultimate-binary-search-template-solved-many-problems",
                "content": "First thing first, here is the code:\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nI have built a powerful generalized binary search template and used it to solve many problems easily. Below is the detailed and clear introduction to this template. I believe it will be worth your time :)\\n\\n****\\n\\n# Intro\\n\\nBinary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). But when it comes to implementation, it\\'s rather difficult to write a bug-free code in just a few minutes. Some of the most common problems include:\\n\\n- When to exit the loop? Should we use `left < right` or `left <= right` as the while loop condition?\\n- How to initialize the boundary variable `left` and `right`?\\n- How to update the boundary? How to choose the appropriate combination from `left = mid `, `left = mid + 1` and  `right = mid`, `right = mid - 1`?\\n\\nA rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like \"Given a sorted array, find a specific value in it\". As a matter of fact, it can be applied to much more complicated situations.\\n\\nAfter a lot of practice in LeetCode, I\\'ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I\\'ll share the template with you guys in this post. I don\\'t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems. Hopefully, after reading this post, people wouldn\\'t be pissed off any more when LeetCoding, \"Holy sh*t! This problem could be solved with binary search! Why didn\\'t I think of that before!\"\\n\\n\\n\\n****\\n\\n\\n\\n# Most Generalized Binary Search\\n\\nSuppose we have a search space. It could be an array, a range, etc. Usually it\\'s sorted in ascend order. For most tasks, we can transform the requirement into the following generalized form:\\n\\n**Minimize k ,    s.t.  condition(k) is True**\\n\\nThe following code is the most generalized binary search template:\\n\\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nWhat\\'s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:\\n\\n- Correctly initialize the boundary variables `left` and `right`. Only one rule: set up the boundary to **include all possible elements**;\\n- Decide return value. Is it `return left` or `return left - 1`? Remember this: **after exiting the while loop, `left` is the minimal k\\u200B satisfying the `condition ` function**;\\n- Design the `condition` function. This is the most difficult and most beautiful part. Needs lots of practice.\\n\\nBelow I\\'ll show you guys how to apply this powerful template to many LeetCode problems.\\n\\n\\n\\n****\\n\\n\\n\\n# Basic Application\\n\\n## [278. First Bad Version [Easy]](https://leetcode.com/problems/first-bad-version/)\\n\\nYou are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API `bool isBadVersion(version)` which will return whether `version` is bad.\\n\\n**Example:**\\n\\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\\n\\nFirst, we initialize `left = 1` and `right = n` to include all possible values. Then we notice that we don\\'t even need to design the `condition` function. It\\'s already given by the `isBadVersion` API. Finding the first bad version is equivalent to finding the minimal k satisfying `isBadVersion(k) is True`. Our template can fit in very nicely:\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n****\\n\\n\\n\\n## [69. Sqrt(x) [Easy]](https://leetcode.com/problems/sqrtx/)\\n\\nImplement `int sqrt(int x)`. Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\\n\\n**Example:**\\n\\n```scala\\nInput: 4\\nOutput: 2\\n```\\n\\n```scala\\nInput: 8\\nOutput: 2\\n```\\n\\nQuite an easy problem. We need to search for maximal k satisfying `k^2 <= x`, so we can easily come up with the solution:\\n\\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\\n\\nThere\\'s one thing I\\'d like to point out. Remember I say that **we usually look for the minimal k value satisfying certain condition**? But in this problem we are searching for maximal k value instead. Feeling confused? Don\\'t be. Actually, the maximal k satisfying `condition(k) is False` is just equal to the minimal k satisfying `condition(k) is True` minus one. This is why I mentioned earlier that we need to decide which value to return, `left` or `left - 1`.\\n\\n\\n\\n****\\n\\n\\n\\n## [35. Search Insert Position [Easy]](https://leetcode.com/problems/search-insert-position/)\\n\\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\\n\\n**Example:**\\n\\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\\n\\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\\n\\nVery classic application of binary search. We are looking for the minimal k value satisfying `nums[k] >= target`, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array `nums` has duplicates. Also notice that the input  `target` might be larger than all elements in `nums` and therefore needs to placed at the end of the array. That\\'s why we should initialize `right = len(nums)` instead of `right = len(nums) - 1`.\\n\\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# Advanced Application\\n\\nThe above problems are quite easy to solve, because they already give us the array to be searched. We\\'d know that we should use binary search to solve them at first glance.  However, more often are the situations where the search space and search target are not so readily available. Sometimes we won\\'t even realize that the problem should be solved with binary search -- we might just turn to dynamic programming or DFS and get stuck for a very long time.\\n\\nAs for the question \"When can we use binary search?\", my answer is that, **If we can discover some kind of monotonicity, for example, if `condition(k) is True` then `condition(k + 1) is True`, then we can consider binary search**.\\n\\n## [1011. Capacity To Ship Packages Within D Days [Medium]](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\ndays. The `i`-th package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. \\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.\\n\\n**Example :**\\n\\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\\n\\nBinary search probably would not come to our mind when we first meet this problem. We might automatically treat `weights` as search space and then realize we\\'ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within `D` days with capacity `m`, then we can definitely ship them all with any capacity larger than `m`. Now we can design a `condition` function, let\\'s call it `feasible`, given an input `capacity`, it returns whether it\\'s possible to ship all packages within `D` days. This can run in a greedy way: if there\\'s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds `D`, we return `False`, otherwise we return `True`.\\n\\nNext, we need to initialize our boundary correctly. Obviously `capacity` should be at least `max(weights)`, otherwise the conveyor belt couldn\\'t ship the heaviest package. On the other hand, `capacity` need not be more than`sum(weights)`, because then we can ship all packages in just one day.\\n\\nNow we\\'ve got all we need to apply our binary search template:\\n\\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [410. Split Array Largest Sum [Hard]](https://leetcode.com/problems/split-array-largest-sum/)\\n\\nGiven an array which consists of non-negative integers and an integer *m*, you can split the array into *m* non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these *m* subarrays.\\n\\n**Example:**\\n\\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\\n\\nIf you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a `feasible` function: given an input `threshold`, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to `threshold`. In this way, we discover the monotonicity of the problem: if `feasible(m)` is `True`, then all inputs larger than `m` can satisfy `feasible` function. You can see that the solution code is exactly the same as LC 1011.\\n\\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nBut we probably would have doubts: It\\'s true that `left` returned by our solution is the minimal value satisfying `feasible`, but how can we know that we can split the original array to **actually get this subarray-sum**? For example, let\\'s say `nums = [7,2,5,10,8]` and `m = 2`. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: `25:[[7], [2,5,10,8]]`, `23:[[7,2], [5,10,8]]`, `18:[[7,2,5], [10,8]]`, `24:[[7,2,5,10], [8]]`. Only 4 values. But our search space `[max(nums), sum(nums)] = [10, 32]` has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.\\n\\nLet\\'s say `k` is the minimal value satisfying `feasible` function. We can prove the correctness of our solution with proof by contradiction. Assume that no subarray\\'s sum is equal to `k`, that is, every subarray sum is less than `k`. The variable `total` inside `feasible` function keeps track of the total weights of current load. If our assumption is correct, then `total` would always be less than `k`. As a result, `feasible(k - 1)` must be `True`, because `total` would at most be equal to `k - 1` and would never trigger the if-clause `if total > threshold`, therefore `feasible(k - 1)` must have the same output as `feasible(k)`, which is `True`. But we already know that `k`  is the minimal value satisfying `feasible` function, so `feasible(k - 1)` has to be `False`, which is a contradiction. So our assumption is incorrect. Now we\\'ve proved that our algorithm is correct.\\n\\n\\n\\n****\\n\\n\\n\\n## [875. Koko Eating Bananas [Medium]](https://leetcode.com/problems/koko-eating-bananas/)\\n\\nKoko loves to eat bananas. There are `N` piles of bananas, the `i`-th pile has `piles[i]` bananas. The guards have gone and will come back in `H` hours. Koko can decide her bananas-per-hour eating speed of `K`. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than `K` bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour. \\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. **Return the minimum integer `K` such that she can eat all the bananas within `H` hours**.\\n\\n**Example :**\\n\\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\\n\\nVery similar to LC 1011 and LC 410 mentioned above. Let\\'s design a `feasible` function, given an input `speed`, determine whether Koko can finish all bananas within `H` hours with hourly eating speed `speed`. Obviously, the lower bound of the search space is 1, and upper bound is `max(piles)`, because Koko can only choose one pile of bananas to eat every hour.\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1482. Minimum Number of Days to Make m Bouquets [Medium]](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n\\nGiven an integer array `bloomDay`, an integer `m` and an integer `k`. We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return *the minimum number of days* you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.\\n\\n**Examples:**\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\\n\\nNow that we\\'ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make `m` bouquets after waiting for `d` days, then we can definitely finish that as well if we wait more than `d` days.\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [668. Kth Smallest Number in Multiplication Table [Hard]](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n\\nNearly every one have used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). But could you find out the `k-th` smallest number quickly from the multiplication table? Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.\\n\\n**Example :**\\n\\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\\n\\nFor Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can  maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn\\'t work out in this problem. We don\\'t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these `m * n` values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing `condition` function is the most difficult part? In order to find the k-th smallest value in the table, we can design an `enough` function, given an input `num`, determine whether there\\'re at least k values less than or equal to `num`. **The minimal `num` satisfying `enough` function is the answer we\\'re looking for**. Recall that the key to binary search is discovering monotonicity. In this problem, if `num` satisfies `enough`, then of course any value larger than `num` can satisfy. This monotonicity is the fundament of our binary search algorithm.\\n\\nLet\\'s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is `m * n`, then we have search space `[1, m * n]`. The overwhelming advantage of binary search solution to heap solution is that it doesn\\'t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply `enough` function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.\\n\\nNext let\\'s consider how to implement `enough` function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row `[3,6,9,12,15...]` are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input `num`. Following is the complete solution.\\n\\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\\n\\nIn LC 410 above, we have doubt \"Is the result from binary search actually a subarray sum?\". Here we have a similar doubt: \"Is the result from binary search actually in the Multiplication Table?\". The answer is yes, and we also can apply proof by contradiction. Denote `num` as the minimal input that satisfies `enough` function. Let\\'s assume that `num` is not in the table, which means that `num` is not divisible by any `val` in `[1, m]`, that is, `num % val > 0`. Therefore, changing the input from `num` to `num - 1` doesn\\'t have any effect on the expression `add = min(num // val, n)`. So `enough(num)` would also return `True`,  just like `enough(num)`. But we already know `num` is the minimal input satisfying `enough` function, so `enough(num - 1)` has to be `False`. Contradiction! The opposite of our original assumption is true: `num` is actually in the table.\\n\\n\\n\\n****\\n\\n\\n\\n## [719. Find K-th Smallest Pair Distance [Hard]](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n\\nGiven an integer array, return the k-th smallest **distance** among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\\n\\n**Example :**\\n\\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\\n\\nVery similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an `enough` function, given an input `distance`, determine whether there\\'re at least k pairs whose distances are less than or equal to `distance`. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to `distance`, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:\\n\\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\\n\\nObviously, our search space should be `[0, max(nums) - min(nums)]`. Now we are ready to copy-paste our template:\\n\\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1201. Ugly Number III [Medium]](https://leetcode.com/problems/ugly-number-iii/)\\n\\nWrite a program to find the `n`-th ugly number. Ugly numbers are **positive integers** which are divisible by `a` **or** `b` **or** `c`.\\n\\n**Example :**\\n\\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\\n\\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\\n\\nNothing special. Still finding the Kth-Smallest. We need to design an `enough` function, given an input `num`, determine whether there are at least n ugly numbers less than or equal to `num`. Since `a` might be a multiple of `b` or `c`, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.\\n\\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1283. Find the Smallest Divisor Given a Threshold [Medium]](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n\\nGiven an array of integers `nums` and an integer `threshold`, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the **smallest** divisor such that the result mentioned above is less than or equal to `threshold`.\\n\\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.\\n\\n**Example :**\\n\\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\\n\\nAfter so many problems introduced above, this one should be a piece of cake. We don\\'t even need to bother to design a `condition` function, because the problem has already told us explicitly what condition we need to satisfy.\\n\\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# End\\n\\nWow, thank you so much for making it to the end, really appreciate that. As you can see from the python codes above, they all look very similar to each other. That\\'s because I copy-pasted my template all the time. No exception. This is the strong proof of my template\\'s powerfulness. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful `condition` function.\\n\\nHope this helps.\\n\\n**Reference**\\n\\n- [[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search](https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search)\\n- [Approach the problem using the \"trial and error\" algorithm](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-\"trial-and-error\"-algorithm)\\n- [Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)\\n- [ugly-number-iii Binary Search with picture & Binary Search Template - LeetCode](https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: 4\\nOutput: 2\\n```\n```scala\\nInput: 8\\nOutput: 2\\n```\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152506,
                "title": "binary-search-java-python-with-explanations",
                "content": "Each hour, Koko chooses some pile of bananas, and eats `K` bananas from that pile. \\n\\nThere is a limited value range of `K`: `[lo, hi]`. \\nThere is a `K\\'` value, such that `K`(for any `K >= K\\'`) can enable her to eat all the bananas within `H` hours: `[K\\', hi]`.\\nWe are asked to find `K\\'`.\\n\\nGiven a linear searching space `[lo, hi]`, `[mi, hi]` (lo <= mi) satisfy a property, we can use Binary Searc to get `mi`.\\n\\nInitially, we know that K belongs to [1, the largest element in `piles[]`]. And we follow the pattern of lower-bound Binary Search except that `if (K == target)` is replaced with `if (canEatAll(piles, K, H))`.\\n****\\n**Java**\\n```\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int lo = 1, hi = getMaxPile(piles);\\n        \\n        // Binary search to find the smallest valid K.\\n        while (lo <= hi) {\\n            int K = lo + ((hi - lo) >> 1);\\n            if (canEatAll(piles, K, H)) {\\n                hi = K - 1;\\n            } else {\\n                lo = K + 1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    private boolean canEatAll(int[] piles, int K, int H) {\\n        int countHour = 0; // Hours take to eat all bananas at speed K.\\n        \\n        for (int pile : piles) {\\n            countHour += pile / K;\\n            if (pile % K != 0)\\n                countHour++;\\n        }\\n        return countHour <= H;\\n    }\\n    \\n    private int getMaxPile(int[] piles) {\\n        int maxPile = Integer.MIN_VALUE;\\n        for (int pile : piles) {\\n            maxPile = Math.max(pile, maxPile);\\n        }\\n        return maxPile;\\n    }\\n```\\n**Python**\\n```\\n    def minEatingSpeed(self, piles, H):\\n        lo, hi = 1, max(piles)\\n        \\n        while lo <= hi:\\n            K = lo + ((hi - lo) >> 1)\\n            if self.countTimeEatAllAtSpeed(\\n                    K, piles) <= H:  # count time to eat all bananas at speed K\\n                hi = K - 1\\n            else:\\n                lo = K + 1\\n        return lo\\n    \\n    def countTimeEatAllAtSpeed(self, K, piles):\\n        countHours = 0  # hours take to eat all bananas\\n        \\n        for pile in piles:\\n            countHours += pile / K\\n            if pile % K != 0:\\n                countHours += 1\\n        return countHours\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int lo = 1, hi = getMaxPile(piles);\\n        \\n        // Binary search to find the smallest valid K.\\n        while (lo <= hi) {\\n            int K = lo + ((hi - lo) >> 1);\\n            if (canEatAll(piles, K, H)) {\\n                hi = K - 1;\\n            } else {\\n                lo = K + 1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    private boolean canEatAll(int[] piles, int K, int H) {\\n        int countHour = 0; // Hours take to eat all bananas at speed K.\\n        \\n        for (int pile : piles) {\\n            countHour += pile / K;\\n            if (pile % K != 0)\\n                countHour++;\\n        }\\n        return countHour <= H;\\n    }\\n    \\n    private int getMaxPile(int[] piles) {\\n        int maxPile = Integer.MIN_VALUE;\\n        for (int pile : piles) {\\n            maxPile = Math.max(pile, maxPile);\\n        }\\n        return maxPile;\\n    }\\n```\n```\\n    def minEatingSpeed(self, piles, H):\\n        lo, hi = 1, max(piles)\\n        \\n        while lo <= hi:\\n            K = lo + ((hi - lo) >> 1)\\n            if self.countTimeEatAllAtSpeed(\\n                    K, piles) <= H:  # count time to eat all bananas at speed K\\n                hi = K - 1\\n            else:\\n                lo = K + 1\\n        return lo\\n    \\n    def countTimeEatAllAtSpeed(self, K, piles):\\n        countHours = 0  # hours take to eat all bananas\\n        \\n        for pile in piles:\\n            countHours += pile / K\\n            if pile % K != 0:\\n                countHours += 1\\n        return countHours\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 152324,
                "title": "java-c-python-binary-search",
                "content": "# Explanation\\nBinary search between `[1, 10^9]` or `[1, max(piles)]` to find the result.\\nTime complexity: `O(NlogM)`\\n\\n`(p + m - 1) / m` equal to `ceil(p / m)` (just personal behavior)\\n\\nHere you find another similar problem.\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/C++JavaPython-Binary-Search)\\n<br>\\n\\n# Complexity\\nTime `O(Nlog(MaxP))`\\nSpace `O(1)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n```\\n**Java:**\\n```java\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n```\\n**Python:**\\n```py\\n    def minEatingSpeed(self, piles, H):\\n        l, r = 1, max(piles)\\n        while l < r:\\n            m = (l + r) / 2\\n            if sum((p + m - 1) / m for p in piles) > H:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search/578488)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search/401806)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/351188?page=3)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>",
                "solutionTags": [],
                "code": "```cpp\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n```\n```java\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n```\n```py\\n    def minEatingSpeed(self, piles, H):\\n        l, r = 1, max(piles)\\n        while l < r:\\n            m = (l + r) / 2\\n            if sum((p + m - 1) / m for p in piles) > H:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1703687,
                "title": "java-c-a-very-very-well-detailed-explanation",
                "content": "```\\nLet\\'s understand the solution, as we are going to be using Binary Search we have given an Array [3,6,7,11] \\nAnd we have to eat every single pile of bananas in less than or equals to hours = 8.\\nIf we not able to do that Gurad will kill KOKO [just a joke] \\n```\\nAs we know that the potential rate that we\\'re eating bananas at **k** is going to be between **1**  that\\'s the minimum it could possibly be. The max it could possibly be is going to be whatever the max in our input array is and that is **11**.\\nSo, then we\\'re going to initialize a range like this **k = [1,2,3,4,5,6,7,8,9,10,11]** the entire range we have. Going all the way from **1** to the max value **11**.\\n![image](https://assets.leetcode.com/users/images/012f952e-b395-419a-b8fc-cfafd16cb907_1642649929.7762113.png)\\n\\nSo, in other words we\\'re going to have a **left pointer** at the **minimum** and a **right pointer** at the **maximum** . Then we compute the middle by taking the **average of left & right / 2 i.e. 1 + 11 / 2 = 6**. So, our **middle** will be here at **6** in other words that **k** we\\'re trying is going to be here at this rate that we\\'re going to eat bananas at rate of **6** .\\n\\n`Now let\\'s check can we eat all the piles of bananas at rate of 6. Let\\'s check it,`\\n![image](https://assets.leetcode.com/users/images/e89c158c-d94e-470d-b614-5cce7c826784_1642650601.5053208.png)\\n\\nIf you see that we just eat all piles of bananas in **6 hour** is that a good value. Well it is less than or equals to **8 hours**, but still we have to find the **minimum possible** of **k** value. This might be the solution but less try is there any more **smaller** **k** value then **6**. \\nSo, we **decrement** our **right pointer to mid - 1** becuase there might be the best possible solution available.\\n\\nSo, once again we compute the middle by taking the **average of left & right / 2 i.e. 1 + 5 / 2 = 3** our **k** is here at **3** value \\n\\n`Now let\\'s check can we eat all the piles of bananas at rate of 3. Let\\'s check it,`\\n![image](https://assets.leetcode.com/users/images/6d2a2019-34c4-49f7-b5ad-f4468862d490_1642651233.9354265.png)\\n\\nIf you see that we just eat all piles of bananas in **10 hour** but if you see we went over **8 hours** we took too long to eat all the bananas. So, eating at **rate of 3** didn\\'t work.\\nLet\\'s start searching to right of our range we **increment** our **left pointer to mid + 1** *but remember when we shift our right pointer from the last position to mid -1 we just consider that this range will not work. And that\\'s how Binary search work!*\\n\\nSo, once again we compute the middle by taking the **average of left & right / 2 i.e. 4 + 5 / 2 = 4** our **k** is here at **4** value \\n\\n`Now let\\'s check can we eat all the piles of bananas at rate of 4. Let\\'s check it,`\\n![image](https://assets.leetcode.com/users/images/ee337cb4-121f-4239-93f0-825e66119386_1642653637.250936.png)\\n\\n\\nIf you see that we just eat all piles of bananas in **8 hour**. So, we able to eat all bananas in less than or equals to **8 hours** if we had a rate of **4**. Let\\'s compare this with our current result. So, far we find a value of **6** we update this **6** and we can say there is a more smaller rate we can use i.e. **4**.\\n```\\nBut if we try to calculate more further on then we see our right pointer moves more left to the left pointer. Then we can now stop our Binar Search.\\n```\\n**I hope you got the point. Let\\'s code it up**\\n\\n*code each line explained :* `Similar for C++ & Java`\\n\\n* Step 1 :\\n```\\nint minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){ // performing binary search\\n            int mid = left + (right - left) / 2; // doing in that way, to handle overflow instead of left + right / 2\\n            // if koko can eat, mid bananas per hour in less then or equals to h time\\n            if(canEatInTime(piles, mid, h)) right = mid - 1; // means decrement our right pointer to optimise better solution \\n            else left = mid + 1; // if not true, increment left pointer\\n        }\\n        return left; // bcz left pointer hold our optimize k, at the end of BS\\n    }\\n```\\n* Step 2 : \\n```\\nboolean canEatInTime(int piles[], int k, int h){\\n        \\n        int hours = 0; // track count of hours\\n        for(int pile : piles){\\n            // performing claculation, take an example \\n            // k = 4\\n            // pile = 10\\n\\n            // pile / k => 10 / 4 = 2\\n            // pile % k => 2, so we need to have one more hour to eat remaining bananas left over as remainder \\n            // hours = 3;\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++; // if remainder value is not 0, we need to have an extra hour\\n        }\\n        return hours <= h;\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    public boolean canEatInTime(int piles[], int k, int h){\\n        int hours = 0;\\n        for(int pile : piles){\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    bool canEatInTime(vector<int>& piles, int k, int h){\\n        int hours = 0;\\n        for(int pile : piles){\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N * log(M)) where N is no of piles & M is range of K (left to right)\\n\\n* **Space Complexity :-** BigO(1) as not using any extra space",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nLet\\'s understand the solution, as we are going to be using Binary Search we have given an Array [3,6,7,11] \\nAnd we have to eat every single pile of bananas in less than or equals to hours = 8.\\nIf we not able to do that Gurad will kill KOKO [just a joke] \\n```\n```\\nBut if we try to calculate more further on then we see our right pointer moves more left to the left pointer. Then we can now stop our Binar Search.\\n```\n```\\nint minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){ // performing binary search\\n            int mid = left + (right - left) / 2; // doing in that way, to handle overflow instead of left + right / 2\\n            // if koko can eat, mid bananas per hour in less then or equals to h time\\n            if(canEatInTime(piles, mid, h)) right = mid - 1; // means decrement our right pointer to optimise better solution \\n            else left = mid + 1; // if not true, increment left pointer\\n        }\\n        return left; // bcz left pointer hold our optimize k, at the end of BS\\n    }\\n```\n```\\nboolean canEatInTime(int piles[], int k, int h){\\n        \\n        int hours = 0; // track count of hours\\n        for(int pile : piles){\\n            // performing claculation, take an example \\n            // k = 4\\n            // pile = 10\\n\\n            // pile / k => 10 / 4 = 2\\n            // pile % k => 2, so we need to have one more hour to eat remaining bananas left over as remainder \\n            // hours = 3;\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++; // if remainder value is not 0, we need to have an extra hour\\n        }\\n        return hours <= h;\\n```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    public boolean canEatInTime(int piles[], int k, int h){\\n        int hours = 0;\\n        for(int pile : piles){\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = 1000000000;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canEatInTime(piles, mid, h)) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n    bool canEatInTime(vector<int>& piles, int k, int h){\\n        int hours = 0;\\n        for(int pile : piles){\\n            int div = pile / k;\\n            hours += div;\\n            if(pile % k != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270468,
                "title": "complete-intuition-to-use-binary-search-explained-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/5b1d53cc-0f5a-42e6-8abb-4cb5f0a8eae7_1678247572.0249767.png)\\n\\n![image](https://assets.leetcode.com/users/images/04364f67-e0b4-467c-b2ca-f595c0a0100c_1678238178.6954896.png)\\n\\n```\\nclass Solution {\\npublic:\\n    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour)\\n    {\\n        long long totalHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);\\n            totalHours += hoursToEatPile;\\n        }\\n        return totalHours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int targetHours)\\n    {\\n        int low = 1, high = *(max_element(piles.begin(), piles.end()));\\n        int ans = -1;\\n        //================================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long hoursToEatAll = getHoursToEatAll(piles, mid);\\n            \\n            if (hoursToEatAll <= targetHours)\\n            {\\n                ans = mid; //record the answer (this is the best we could record till curr step)\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //=================================================================\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour)\\n    {\\n        long long totalHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);\\n            totalHours += hoursToEatPile;\\n        }\\n        return totalHours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int targetHours)\\n    {\\n        int low = 1, high = *(max_element(piles.begin(), piles.end()));\\n        int ans = -1;\\n        //================================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long hoursToEatAll = getHoursToEatAll(piles, mid);\\n            \\n            if (hoursToEatAll <= targetHours)\\n            {\\n                ans = mid; //record the answer (this is the best we could record till curr step)\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //=================================================================\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703550,
                "title": "c-java-python-6-lines-binary-search-image-explained-beginner-friendly",
                "content": "\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n* Given `k`, koko need `ceil(1.0 * piles[i] / k)` to eat up all bananas in `piles[i]`\\n\\t* so given `k`, koko need `hours = sum(math.ceil(1.0 * pile / k) for pile in piles)` to eat up all the bananas from all piles.\\n\\t* `ceil(1.5) = 2`\\n* We can use **Binary Search** to find the minimum `k`\\n\\t* if `hours > h`, that indicates `k` is too small, then `low = k + 1`\\n\\t* if `hours < h`, that indicates `k` is too large, then `high = k - 1`\\n\\t* if `hours == h`, we can try a smaller `k`, then also `high = k - 1`\\n\\t* intuitively, we can initialize ` low = 1, high = 1000000000` or  `low = 1, high = max(piles)`\\n* Note that we are searching `k` via **Binary Search**, we need not sort any array or list, the condition of **Binary Search** is \\n\\t* The search space is limited\\n\\t* Every time after checking for the current `mid`, we know exactly where to search next (greater than `mid` or lower than `mid`)\\n\\n\\n![image](https://assets.leetcode.com/users/images/c88526a1-3ea4-4b45-9bfd-9e13f6f36aa4_1642648234.4864397.png)\\n\\n```\\nTime  Complexity: O(30 * N)  # log2(10 ** 9) = 29.9\\nSpace Complexity: O(1)\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        low, high = 1, 10 ** 9\\n        while low <= high:\\n            k = (low + high) // 2\\n            if sum(math.ceil(1.0 * pile / k) for pile in piles) > h: low = k + 1\\n            else: high = k - 1\\n        return low\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int low = 1, high = 1000000000, k = 0;\\n        while (low <= high) {\\n            k = (low + high) / 2;\\n            int h = 0;\\n            for (int i = 0; i < piles.size(); i ++) \\n                h += ceil(1.0 * piles[i] / k);\\n            if (h > H)\\n                low = k + 1;\\n            else\\n                high = k - 1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int low = 1, high = 1000000000, k = 0;\\n        while (low <= high) {\\n            k = (low + high) / 2;\\n            int h = 0;\\n            for (int i = 0; i < piles.length; i ++) \\n                h += Math.ceil(1.0 * piles[i] / k);\\n            if (h > H)\\n                low = k + 1;\\n            else\\n                high = k - 1;\\n        }\\n        return low;\\n    }\\n}\\n```\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nTime  Complexity: O(30 * N)  # log2(10 ** 9) = 29.9\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        low, high = 1, 10 ** 9\\n        while low <= high:\\n            k = (low + high) // 2\\n            if sum(math.ceil(1.0 * pile / k) for pile in piles) > h: low = k + 1\\n            else: high = k - 1\\n        return low\\n```\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int low = 1, high = 1000000000, k = 0;\\n        while (low <= high) {\\n            k = (low + high) / 2;\\n            int h = 0;\\n            for (int i = 0; i < piles.size(); i ++) \\n                h += ceil(1.0 * piles[i] / k);\\n            if (h > H)\\n                low = k + 1;\\n            else\\n                high = k - 1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int low = 1, high = 1000000000, k = 0;\\n        while (low <= high) {\\n            k = (low + high) / 2;\\n            int h = 0;\\n            for (int i = 0; i < piles.length; i ++) \\n                h += Math.ceil(1.0 * piles[i] / k);\\n            if (h > H)\\n                low = k + 1;\\n            else\\n                high = k - 1;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270528,
                "title": "java-binary-search-on-answers-with-similar-follow-up-problems",
                "content": "**We need to find the speed of eating bananas per hour i.e k such that he will eat all bananas within hours (h). So if we observe we can know that we can use Binary Search in this. Now you will say how?? We know that we need to find the minimum bananas he can eat within an hour (k) such that koko will eat all bananas within the hours (h). So if suppose we have fixed that koko can eat t bananas within an hour and if the speed of eating is t bananas/ hour then will I be able to eat all bananas within the hour (h)?? If yes, we are not sure that it may or may not be the minimum bananas he will eat in an hour so we will do high=t because obviously we know that if in t bananas/hour if he can achieve the target then why will he go to right because it will not give him the minimum bananas to eat in an hour and for that reason we move to left. We kept on going left till we are able to achieve the target. If we are not able to achieve the target that means we can\\'t eat all bananas with that speed so we move to right. We keep on doing this till we get the speed (bananas to eat within an hour) as minimum as possible. At last we return the answer.\\nIn blackbox we just tried to find if he can eat all banana with that speed (bananas to eat within an hour) within the stipulated time (h). If yes, we return true or else we return false.**\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=Integer.MIN_VALUE;\\n        for(int i=0;i<piles.length;i++){\\n            high=Math.max(high,piles[i]);\\n        }\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(int maxpiles,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxpiles;\\n            hours+=time;\\n            if(i%maxpiles!=0) hours++;\\n        }\\n        if(hours<=h)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n**Similar follow up problems related to Binary Search on Answers :- https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3266855/All-Binary-Search-Problems**\\n\\n![image](https://assets.leetcode.com/users/images/c7ed53ec-f37f-4429-b7b2-79fb768a16c3_1678237613.4171617.jpeg)",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=Integer.MIN_VALUE;\\n        for(int i=0;i<piles.length;i++){\\n            high=Math.max(high,piles[i]);\\n        }\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(int maxpiles,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxpiles;\\n            hours+=time;\\n            if(i%maxpiles!=0) hours++;\\n        }\\n        if(hours<=h)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270477,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the minimum integer `k` such that Koko can eat all the bananas within `h`\\nhours. This means that we need to find the smallest value of `k` such that she can eat all\\nthe bananas within `h` hours.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize left and right pointers as `left = 1` and `right = maximum number of bananas in any pile`.\\n2. While the left pointer is less than the right pointer, repeat the following:\\na. Calculate the middle pointer using `mid = (left + right) / 2`.\\nb. Check if Koko can eat all the bananas at the current speed (middle pointer) within `h` hours using the `canEatAll` method.\\nc. If Koko can eat all the bananas at the current speed, update the right pointer to the middle pointer using `right = mid`.\\nd. If Koko cannot eat all the bananas at the current speed, update the left pointer to `mid + 1`.\\n3. Once the left pointer is equal to the right pointer, return the left pointer as the minimum speed at which Koko can eat all the bananas within h hours.\\nThe `canEatAll` method calculates the total time required to eat all the piles using the given speed. If the total time is greater than h, the method returns `false`, otherwise, it\\nreturns `true`.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe binary search algorithm has a time complexity of O(logn), where n is the maximum number of bananas in a pile. The canEatAll function has a time complexity of O(n), where n is the number of piles. Therefore, the overall time complexity of the solution is O(nlogn).\\n\\n- Space complexity:\\nThe space complexity of the solution is O(1), as we only use a constant amount of extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = Arrays.stream(piles).max().getAsInt();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean canEatAll(int[] piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1; // calculate the time required to eat this pile\\n            if (time > h) {\\n                return false; // if the total time is greater than h, return false\\n            }\\n        }\\n        return true; // if all piles can be eaten within h hours, return true\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        left = 1\\n        right = max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) / 2\\n            if self.canEatAll(piles, mid, h):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n    \\n    def canEatAll(self, piles, speed, h):\\n        time = 0\\n        for pile in piles:\\n            time += (pile - 1) / speed + 1\\n            if time > h:\\n                return False\\n        return True\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    bool canEatAll(vector<int>& piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1;\\n            if (time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = Arrays.stream(piles).max().getAsInt();\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean canEatAll(int[] piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1; // calculate the time required to eat this pile\\n            if (time > h) {\\n                return false; // if the total time is greater than h, return false\\n            }\\n        }\\n        return true; // if all piles can be eaten within h hours, return true\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        left = 1\\n        right = max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) / 2\\n            if self.canEatAll(piles, mid, h):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n    \\n    def canEatAll(self, piles, speed, h):\\n        time = 0\\n        for pile in piles:\\n            time += (pile - 1) / speed + 1\\n            if time > h:\\n                return False\\n        return True\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    bool canEatAll(vector<int>& piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1;\\n            if (time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703427,
                "title": "javascript-binary-search-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nBy the condition, Koko does not pass to another pile when she eats all bananas earlier. So it makes no sense to eat faster than the maximum number of bananas in a pile. From that, you can see that we know the max and min speed: `min=1 banana/h` and `max = max(piles)`. Thus, this is a good candidate for the Binary Search. We search the speed in the range `1...(max number in piles array)`.\\n\\nHow do we estimate a chosen speed? We create a helper function that calculates the time needed to eat all bananas at a given speed. Formula is just sum `ceil(number_of_bananas_in_pile/speed)` for every pile. We have to round to the top value since Koko does not pass to another pile even she finishes earlier.\\n\\nTime: **O(NlogM)** - BS plus scan in the helper. `N` - number of piles, `M` - max number of bananas in a pile.\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 88 ms, faster than **84.26%** of JavaScript online submissions for Koko Eating Bananas.\\nMemory Usage: 42.5 MB, less than **58.88%** of JavaScript online submissions for Koko Eating Bananas.\\n\\n```\\nconst minEatingSpeed = (piles, h) => {\\n    let min = 1,\\n        max = Math.max(...piles),\\n        best = max\\n\\n    const time = speed => piles.reduce((sum, pile) => sum + Math.ceil(pile/speed), 0)\\n\\n    while (min <= max) {\\n        const mid = Math.floor((min + max) / 2)\\n\\t\\t\\n        if (time(mid) <= h) {\\n            best = mid\\n            max = mid - 1\\n        } else\\n            min = mid + 1\\n    }\\n\\n    return best\\n}\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nconst minEatingSpeed = (piles, h) => {\\n    let min = 1,\\n        max = Math.max(...piles),\\n        best = max\\n\\n    const time = speed => piles.reduce((sum, pile) => sum + Math.ceil(pile/speed), 0)\\n\\n    while (min <= max) {\\n        const mid = Math.floor((min + max) / 2)\\n\\t\\t\\n        if (time(mid) <= h) {\\n            best = mid\\n            max = mid - 1\\n        } else\\n            min = mid + 1\\n    }\\n\\n    return best\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1705145,
                "title": "python-binarysearch-optimizations-explained",
                "content": "k -> Speed of eating bananas per hour\\nT -> Total time to eat all the piles under given conditions\\nH -> Given time limit\\nA -> Average speed of eating bananas per hour, ```A = ceil(sum(piles)/h)```\\n\\n## **Method 1: Brute Force** *[Gives TLE]*\\nIntuitively we can take these steps:\\n1. Simply consider the initial speed k to be 1.\\n2. Calculate the total time T required to finish all the  piles.\\n3. If T is greater than the given time limit H, we increment k and repeat steps 1, 2, 3\\n4. If T is <= H then we return k as our answer.\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = 1\\n        while True:\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i / k)\\n            if total_time > h:\\n                k += 1\\n            else:\\n                return k\\n```\\n## **Method 2: Brute Force + Optimizations** *[Gives TLE]*\\nWe can optimize 2 things about our Brute Force Solution code\\n1. Rather than finishing the loop even if T exceeds H and then incrementing k. We can directly exit the inner loop as soon as T > H. This optimization is rather easy to get to.\\n2. This optimization is related to our initial assumption. We consider the initial speed to be 1. Well, **one can mathematically prove that k must always be greater than or equal to the average speed of eating**. We can see as a result of case 1 and case 2, `k>=A`\\n\\n![image](https://assets.leetcode.com/users/images/fbe86fce-8516-4067-8bea-2c32c13c18b7_1642692725.833398.png)\\n\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = ceil(sum(piles)/h)\\n        while True:\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i/k)\\n                if total_time > h:\\n                    break # as time exceeds H\\n            if total_time <= h:\\n                return k # answer found as time is in the given limits.\\n            k += 1\\n```\\n#### Intution for next solution:\\n1. **One thing is obvious in this problem. We do not know the required speed and we cannot know this without any sort of hit and try. In method 1 we do this hit and trial linearly. In method 2 we optimize our approach by removing some values we know that are not going to work and exiting the loop early if time exceeds H.** \\n2. We know the lower bound of k >= A. We also know the upper bound of k that is k <= (max element in Piles).\\nThus, **A<=k<=(max element in Piles)**\\n3. In essence we are looking for a value that might satisfy **T<=H** in the range mentioned above. We were looking for an answer by **searching linearly**, which is of course is slow. *A much better searching algorithm within a given range would be* **Binary Search.**\\n4. If k = x works fine then x+1, x+2, x+3, basically x plus anything +ve would also work fine. But since we need minimum value we must return x. \\n5. If the current value satisfies the condition then the answer must exist to the left of it including itself. If the current value does not satisfy the condition then the answer must exist to the right of it exclusive of itself.\\n\\nWith this idea, we code the next solution with Binary search and Optimizations in mind.\\n\\n## **Method 3: Binary Search + Previous Optimizations** *[Works Perfectly with Runtime beating 82%]*\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        left = ceil(sum(piles) / h) # lower bound of Binary Search \\n        right = max(piles) # upper bound of Binary Search \\n        while left < right:\\n            mid = (left + right) // 2 # we check for k=mid\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i / mid)\\n                if total_time > h:\\n                    break\\n            if total_time <= h:\\n                right = mid # answer must lie to the left half (inclusive of current value ie mid)\\n            else:\\n                left = mid + 1 # answer must lie to the right half (exclusive of current value ie mid)\\n        return right\\n```\\n### Give an \\u2B06\\uFE0Fupvote if you found this article helpful ;D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```A = ceil(sum(piles)/h)```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = 1\\n        while True:\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i / k)\\n            if total_time > h:\\n                k += 1\\n            else:\\n                return k\\n```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = ceil(sum(piles)/h)\\n        while True:\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i/k)\\n                if total_time > h:\\n                    break # as time exceeds H\\n            if total_time <= h:\\n                return k # answer found as time is in the given limits.\\n            k += 1\\n```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        left = ceil(sum(piles) / h) # lower bound of Binary Search \\n        right = max(piles) # upper bound of Binary Search \\n        while left < right:\\n            mid = (left + right) // 2 # we check for k=mid\\n            total_time = 0\\n            for i in piles:\\n                total_time += ceil(i / mid)\\n                if total_time > h:\\n                    break\\n            if total_time <= h:\\n                right = mid # answer must lie to the left half (inclusive of current value ie mid)\\n            else:\\n                left = mid + 1 # answer must lie to the right half (exclusive of current value ie mid)\\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704140,
                "title": "python-short-binary-search-explained",
                "content": "The idea is given value `mid`, answer a question: can Koko eat all bananas within `H` hours. We need `sum(ceil(i/mid) for i in piles)` hours to eat all bananas. Then we just do binary search and find the first place, where time is `<= H`. We always keep invariant: `time(beg) > H` and `time(end) <= H`, we can do it, because function `time` is not-increasing.\\n\\n#### Complexity\\nTime Complexity: `O(N log W)`, where `N` is the number of piles, and `W` is the maximum size of a pile, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minEatingSpeed(self, piles, H):\\n        beg, end = 0, max(piles)\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if sum(ceil(i/mid) for i in piles) > H:\\n                beg = mid\\n            else:\\n                end = mid\\n                \\n        return end\\n``` \\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minEatingSpeed(self, piles, H):\\n        beg, end = 0, max(piles)\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if sum(ceil(i/mid) for i in piles) > H:\\n                beg = mid\\n            else:\\n                end = mid\\n                \\n        return end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667143,
                "title": "why-the-hell-does-koko-want-to-eat-so-many-bananas",
                "content": "```\\nWhy the hell does Koko want to eat so many bananas? \\n```",
                "solutionTags": [],
                "code": "```\\nWhy the hell does Koko want to eat so many bananas? \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3273872,
                "title": "koko-finds-hints-then-tries-binary-search-java-c",
                "content": "# Intuition\\nWhen minimum or maximum is specified in the problem, people tend to think it as a dynamic programming problem. But in all cases it won\\'t be a dynamic programming problem. Sometimes it can be binary search!\\n\\n**How do you know this is a binary search problem?**\\nBecause the problem wants you to find some target value and satisfy some property. **But the input array is not sorted and binary search only works for sorted arrays.** Yes! That\\'s true. But for this problem, are we using any of the array elements as our **left** or **right** variables? No, we are not. Infact we won\\'t be using all of them. We will be determining the speed k. **In this case, k can be monotonically increasing or decreasing.** When this type of problem statement is given, try using binary search. Also, if you have solved yesterday\\'s problem [2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/) you will directly find out that this is a binary search problem. Because the statements are similar.\\nMy solution for **2187. Minimum Time to Complete Trips** [\\u2705 Simple BruteForce to Crazy Binary Search || Code like a pro \\uD83D\\uDE80](https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267566/simple-bruteforce-to-crazy-binary-search-code-like-a-pro/)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nNow you probably know you have to use binary search into this.\\nThe main thing in binary search is determining what values should **left** and **right** be!\\nIn this problem, what do we need to find? We need to find the speed. What can be the maximum speed? The maximum pile from the piles array right?\\n\\nBut what should be the minimum speed?\\n\\nIf you think about these questions. You probably have the answer to left and right. Your **left variable will be 1** and your **right variable will be maximum pile value** from the piles array.\\n\\nNow, perform binary search..\\n```\\nwhile(left < right){\\n    mid = (left+right)/2;\\n    mid is our new speed..\\n}\\n```\\n\\nWe now calculate the total hours for each pile to complete if speed is mid.\\nFor a pile p and the speed s, the time requires to complete pile p is $$\\\\frac{P}{S}$$.\\n\\nYou probably have a hint till now. Try writing yourself...\\n\\n\\nIf you still wasn\\'t able to, see my solution.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log m)$$\\nWhere N is the length of piles array. The initial search space is from 1 to m, it takes $$\\\\log m$$ comparisons to reduce the search space to 1.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nNo variable length object like array, stack, list, map etc. was created.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1;\\n        for(int pile : piles){\\n            right = Math.max(right, pile);\\n        }\\n        \\n        while(left<right) {\\n            int mid = left + (right-left)/2;\\n            int hours = 0;\\n            for(int pile: piles){\\n                hours += Math.ceil(pile*1.0/mid);\\n            }\\n            if(hours<=h){\\n                right = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = 1;\\n        for(int pile : piles){\\n            right = max(right, pile);\\n        }\\n        \\n        while(left<right) {\\n            int mid = left + (right-left)/2;\\n            int hours = 0;\\n            for(int pile: piles){\\n                hours += ceil(pile*1.0/mid);\\n            }\\n            if(hours<=h){\\n                right = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/dd8798bf-62ab-4a7d-89b6-fcbf40124321_1678309726.6535485.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nwhile(left < right){\\n    mid = (left+right)/2;\\n    mid is our new speed..\\n}\\n```\n``` Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = 1;\\n        for(int pile : piles){\\n            right = Math.max(right, pile);\\n        }\\n        \\n        while(left<right) {\\n            int mid = left + (right-left)/2;\\n            int hours = 0;\\n            for(int pile: piles){\\n                hours += Math.ceil(pile*1.0/mid);\\n            }\\n            if(hours<=h){\\n                right = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = 1;\\n        for(int pile : piles){\\n            right = max(right, pile);\\n        }\\n        \\n        while(left<right) {\\n            int mid = left + (right-left)/2;\\n            int hours = 0;\\n            for(int pile: piles){\\n                hours += ceil(pile*1.0/mid);\\n            }\\n            if(hours<=h){\\n                right = mid;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569149,
                "title": "easy-to-understand-binary-search-with-optimization-c",
                "content": "We know that the minimum number of bananas Koko should eat cannot be lower than `sum of all elements \\\\ number of hourse` and also it cannot be greater than `the maximum number of bananas present in any single pile`. Our answer will definitely fall in this range.\\n\\nBased upon this logic, we perform binary search within the given range.\\n\\n````\\nclass Solution {\\n    // Helper function which returns the number of hours required to consume the piles for given K\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t// If hours required is greater than our limit, ignore mid\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\n    // Helper function which returns the number of hours required to consume the piles for given K\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t// If hours required is greater than our limit, ignore mid\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703573,
                "title": "c-binary-search-easy-to-understand",
                "content": "1. the answer lies in the range [1, **max-element**]\\n2. now we can use **binary search to find  the k**.\\n3. here we are calculating mid for low and high and then checking the time for it to eat bananas **check comment for better understanding**\\n![image](https://assets.leetcode.com/users/images/387ea381-ae8d-4296-928e-e8cac02bd022_1642655698.9761198.jpeg)\\n\\n```\\nint minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        // number lies between min and max-element\\n        for(auto x : piles){\\n            high = max(x,high);\\n        }\\n        \\n        int val = 0;\\n        while(low<high){\\n            int mid = (low+high)/2; val = 0;\\n            // calculate val for each mid assumed\\n\\t\\t\\t// this loops tell the time taken to eat all bananas by the current mid\\n            for (auto x : piles) val += (x+mid-1)/mid; \\n            // if the time is less than the value given to us we reduce the high as we need \\n\\t\\t\\t// to increase time by decreasing high we increase time\\n            if (val <= h) high = mid; \\n            \\n            else low = mid+1; \\n        }\\n        return low;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        // number lies between min and max-element\\n        for(auto x : piles){\\n            high = max(x,high);\\n        }\\n        \\n        int val = 0;\\n        while(low<high){\\n            int mid = (low+high)/2; val = 0;\\n            // calculate val for each mid assumed\\n\\t\\t\\t// this loops tell the time taken to eat all bananas by the current mid\\n            for (auto x : piles) val += (x+mid-1)/mid; \\n            // if the time is less than the value given to us we reduce the high as we need \\n\\t\\t\\t// to increase time by decreasing high we increase time\\n            if (val <= h) high = mid; \\n            \\n            else low = mid+1; \\n        }\\n        return low;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271007,
                "title": "binary-search-intuition-explained-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at the problem, it can be deduced that the minimum speed at which Koko can eat bananas is 1 and the maximum speed is the maximum number of bananas available in the pile. \\nNow, we have a range of values in which our answer lies. To solve this kind of problem, we can use Binary search.\\nWe can search in the range 1 to maximum speed and update the range according to whether the mid value is enough to eat all bananas or not.\\n\\n![image.png](https://assets.leetcode.com/users/images/db19fea9-12c0-432e-af8a-3b1a3217d3f5_1678253443.526576.png)\\n\\n# Example\\n piles=[4,6,9,7,11] and h= 13\\n=> k can be: 1,2,3,4,5,6,7,8,9,10,11\\n\\nfor binary search the range will be minspeed=1 and maxspeed=11\\n\\n1. mid = (1+11)/2 =5\\nnow for 5 bananas/hour speed.\\nthe total number of hours it\\'d take to finish all bananas:\\n```\\n4, 6, 9, 7, 11 \\n1  2  2  2   3  = 10 \\n\\nas 10<13 that means our answer lies in between range minspeed to mid i.e 1 to 5.\\nHence, maxspeed=5\\n```\\n\\n2. mid= (1+5)/2=3\\n``` \\n4, 6, 9, 7, 11\\n2  2  3  3   4  = 14 \\n\\nas 14>13 hence range would be mid+1 to maxpeed. i.e minspeed=4\\n```\\n\\n3. mid=(4+5)/2=4.\\n```\\n4, 6, 9, 7, 11\\n1  2  3  2   3  = 11\\nas 11<13, range would become minspeed to mid i.e maxpeed=4.\\nAs minspeed=maxspeed now.\\nHence 4 is the minimum speed \\n```\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(nlog(m)), where n=number of piles, m= range of k\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool eatAll(vector<int>&piles, int h,int speed){\\n        int curr=0;\\n        for(double num:piles){\\n            double hours=num/speed;\\n            curr+=ceil(hours);\\n        }\\n        return curr<=h;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int maxspeed=*max_element(piles.begin(),piles.end()), minspeed=1; // setting range for binary search\\n        \\n        while(maxspeed>minspeed){\\n            int mid=(maxspeed+minspeed)/2;\\n            if(eatAll(piles,h,mid)) maxspeed=mid; // if mid is enough to all bananas than minspeed to mid will have the minimum value.\\n            else minspeed=mid+1; // if mid is not enough than minimum value will lie between mid+1 to maxspeed\\n        }\\n        return minspeed;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n4, 6, 9, 7, 11 \\n1  2  2  2   3  = 10 \\n\\nas 10<13 that means our answer lies in between range minspeed to mid i.e 1 to 5.\\nHence, maxspeed=5\\n```\n``` \\n4, 6, 9, 7, 11\\n2  2  3  3   4  = 14 \\n\\nas 14>13 hence range would be mid+1 to maxpeed. i.e minspeed=4\\n```\n```\\n4, 6, 9, 7, 11\\n1  2  3  2   3  = 11\\nas 11<13, range would become minspeed to mid i.e maxpeed=4.\\nAs minspeed=maxspeed now.\\nHence 4 is the minimum speed \\n```\n```\\nclass Solution {\\npublic:\\n    bool eatAll(vector<int>&piles, int h,int speed){\\n        int curr=0;\\n        for(double num:piles){\\n            double hours=num/speed;\\n            curr+=ceil(hours);\\n        }\\n        return curr<=h;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int maxspeed=*max_element(piles.begin(),piles.end()), minspeed=1; // setting range for binary search\\n        \\n        while(maxspeed>minspeed){\\n            int mid=(maxspeed+minspeed)/2;\\n            if(eatAll(piles,h,mid)) maxspeed=mid; // if mid is enough to all bananas than minspeed to mid will have the minimum value.\\n            else minspeed=mid+1; // if mid is not enough than minimum value will lie between mid+1 to maxspeed\\n        }\\n        return minspeed;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330795,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1,high=0;\\n        for(int i=0;i<piles.length;i++)\\n            high = Math.max(piles[i],high);\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(possible(piles,mid,h))\\n                high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n    boolean possible(int[] piles,int speed,int hours)\\n    {\\n        int res = 0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            res += (piles[i]/speed);\\n            if(piles[i]%speed != 0)\\n                res++;\\n        }\\n        return res <= hours;\\n    }\\n}\\n```\\nPlease ipvote if u feel my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1,high=0;\\n        for(int i=0;i<piles.length;i++)\\n            high = Math.max(piles[i],high);\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(possible(piles,mid,h))\\n                high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n    boolean possible(int[] piles,int speed,int hours)\\n    {\\n        int res = 0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            res += (piles[i]/speed);\\n            if(piles[i]%speed != 0)\\n                res++;\\n        }\\n        return res <= hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329232,
                "title": "clean-easy-with-explanation-binary-search-javascript-solution",
                "content": "```\\nvar minEatingSpeed = function(piles, h) {\\n    /*The range of bananas that Koko can eat is k = 1 to Max(piles)*/\\n    let startk = 1;\\n    let endk = Math.max(...piles);\\n    \\n    while(startk <= endk){\\n        let midk = Math.floor(startk + (endk - startk)/2);\\n        /*midk are the count of bananas that koko decide to eat. \\n        So how many hours she will take to finish the piles?*/\\n        let hrs = 0;\\n        for(let pile of piles){\\n            /*pile is the num of bananas in piles*/\\n            hrs += Math.ceil(pile/midk);\\n        }\\n        if(hrs > h){\\n            /*Now if hrs > h she will not be to finish the pile so we have \\n            to increase the bananas by moving start.*/\\n            startk = midk + 1;\\n        }else{\\n            /*If hrs <= h she will be eating too fast so we can reduce the bananas \\n            so she eats slowly. So decrement end.*/\\n            endk = midk - 1;\\n        }\\n    }\\n    return startk;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar minEatingSpeed = function(piles, h) {\\n    /*The range of bananas that Koko can eat is k = 1 to Max(piles)*/\\n    let startk = 1;\\n    let endk = Math.max(...piles);\\n    \\n    while(startk <= endk){\\n        let midk = Math.floor(startk + (endk - startk)/2);\\n        /*midk are the count of bananas that koko decide to eat. \\n        So how many hours she will take to finish the piles?*/\\n        let hrs = 0;\\n        for(let pile of piles){\\n            /*pile is the num of bananas in piles*/\\n            hrs += Math.ceil(pile/midk);\\n        }\\n        if(hrs > h){\\n            /*Now if hrs > h she will not be to finish the pile so we have \\n            to increase the bananas by moving start.*/\\n            startk = midk + 1;\\n        }else{\\n            /*If hrs <= h she will be eating too fast so we can reduce the bananas \\n            so she eats slowly. So decrement end.*/\\n            endk = midk - 1;\\n        }\\n    }\\n    return startk;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152308,
                "title": "java-concise-binary-search-10-lines-with-explanation",
                "content": "The search range is from 0 to the largest pile.\\nWe count total hours it needs to eat all bananas with speed=```mid```, and use ```cnt``` to decide whether to move ```lo``` or ```hi```.\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        Arrays.sort(piles);\\n        int lo=0, hi=piles[piles.length-1];\\n        while (lo<hi){\\n            int mid= (lo+hi)/2, cnt=0;\\n            for (int p: piles) \\n                cnt+=Math.ceil((double)p/mid);\\n            if (cnt>H) lo=mid+1;\\n            else hi=mid;\\n        }\\n        return lo;\\n    }\\n}\\n```\\nHappy Coding.",
                "solutionTags": [],
                "code": "```mid```\n```cnt```\n```lo```\n```hi```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        Arrays.sort(piles);\\n        int lo=0, hi=piles[piles.length-1];\\n        while (lo<hi){\\n            int mid= (lo+hi)/2, cnt=0;\\n            for (int p: piles) \\n                cnt+=Math.ceil((double)p/mid);\\n            if (cnt>H) lo=mid+1;\\n            else hi=mid;\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270773,
                "title": "leetcode-the-hard-way-binary-search",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\nFor detailed explanation, please go to [here](https://leetcodethehardway.com/solutions/0800-0899/koko-eating-bananas-medium).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int ok(vector<int>& piles, int m, int h) {\\n        int hours = 0;\\n        for (auto p : piles) {\\n            hours += (p + m - 1) / m;\\n        }\\n        return hours > h;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l = 1, r = 1e9;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ok(piles, m, h)) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        while l < r:\\n            m = (l + r) // 2\\n            if sum((p + m - 1) // m for p in piles) > h:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int ok(vector<int>& piles, int m, int h) {\\n        int hours = 0;\\n        for (auto p : piles) {\\n            hours += (p + m - 1) / m;\\n        }\\n        return hours > h;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l = 1, r = 1e9;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ok(piles, m, h)) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        while l < r:\\n            m = (l + r) // 2\\n            if sum((p + m - 1) // m for p in piles) > h:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083830,
                "title": "c-solution-with-explanation",
                "content": "**Explanation** \\nex - [ 3, 6, 7, 11]  if speed is 4, that means 4 banana per hr, then \\n\\n1st hr    [ 0, 6, 7, 11]\\n2nd hr   [ 0, 2, 7, 11]\\n3rd hr    [ 0, 0, 7, 11]\\n4th hr    [ 0, 0, 3, 11]\\n5th hr    [ 0, 0, 0, 11]\\n6th hr    [ 0, 0, 0, 7]\\n7th hr    [ 0, 0, 0, 3]\\n8th hr    [ 0, 0, 0, 0]\\n\\nand if speed is 5, then \\n\\n1st hr    [ 0, 6, 7, 11]\\n2nd hr   [ 0, 1, 7, 11]\\n3rd hr    [ 0, 0, 7, 11]\\n4th hr    [ 0, 0, 2, 11]\\n5th hr    [ 0, 0, 0, 11]\\n6th hr    [ 0, 0, 0, 6]\\n7th hr    [ 0, 0, 0, 1]\\n8th hr    [ 0, 0, 0, 0]\\n\\nthat means both 4,and 5 speed can be able to help koko to eat all banana within in 8 hr. \\nbut since it mention that Koko likes to eat slowly, so we need to find minimum speed to finish eating all the bananas. In that case, correct answer is 4.\\n\\n\\n**Solution**\\nA possible answer (i.e k) can be from 1 to 10^9  as in constraint maximum value of piles[i] is 10^9.\\nNow brute force approach will be from 1 to 10^9 trying every possibility as the number of banana-per-hour eating speed of k and answer will be the first k value that satisfies the condition!\\n\\nthe time complexity for the brute force approach will be 10^4 * 10^9\\n\\n\\nOptimal Solution!\\nBinary search the answer \\nIf the mid-value (i.e k) number of banana eaten per hour(or speed). \\nWith that k value, calculate the total time taken to eat all the bananas.\\n \\nHere the relation between NumberOfhours and k(speed) is\\nTo increase NumberOfHours, decrease speed.\\nTo decrease NumberOfHours, increase speed.\\n\\nif(NumberOfHours>H)\\n that is within the given limit(H) speed is less to eat all the banana , so need to decrease NumberOfHours, and to do so, need to increase speed.\\nTherefore range for k will be reduced towards the right (i.e left=k+1).\\n\\nelse if(NumberOfHours<=H) \\nthen this speed can be the possible answer so store that speed and what if while reducing speed further might possible all the banana can be eaten within H hours too!\\n Therefore reducing the range of speed towards the left (i.e right=k-1).\\nTime complexity  10^4 *(log 10^9).\\n\\n```\\nclass Solution {\\npublic:\\n    int Calculate(vector<int>& nums,int k){\\n        int NumberOfHours=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            NumberOfHours += (nums[i] % k == 0) ? nums[i] / k : (nums[i] /k)+1;\\n        }\\n        return NumberOfHours;\\n    }\\n    \\n    \\n    \\n    \\n    int minEatingSpeed(vector<int>& nums, int H) {\\n        int left = 1;\\n        int right = 1000000000;\\n        while(left < right){\\n           int k=(left + right)/2;    \\n            \\n           int NumberOfHours = Calculate(nums,k);\\n            \\n            if(NumberOfHours > H) {\\n                left = k+1;\\n            }\\n            else {\\n                right = k;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```\\n\\nvarient!\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nMy post - https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/1083631/c-solution-with-explanation\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Calculate(vector<int>& nums,int k){\\n        int NumberOfHours=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            NumberOfHours += (nums[i] % k == 0) ? nums[i] / k : (nums[i] /k)+1;\\n        }\\n        return NumberOfHours;\\n    }\\n    \\n    \\n    \\n    \\n    int minEatingSpeed(vector<int>& nums, int H) {\\n        int left = 1;\\n        int right = 1000000000;\\n        while(left < right){\\n           int k=(left + right)/2;    \\n            \\n           int NumberOfHours = Calculate(nums,k);\\n            \\n            if(NumberOfHours > H) {\\n                left = k+1;\\n            }\\n            else {\\n                right = k;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750804,
                "title": "best-c-solution-list-of-11-similar-very-imp-binary-search-questions",
                "content": "# List of similar binary search questions \\n- [Find the Smallest Divisor Given a Threshold - Leetcode](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/solutions/3746201/best-c-solution-pure-binary-search-approach-beats-98-84/)\\n- [Minimize the Maximum Difference of Pairs - Leetcode](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/3884064/simple-binary-search-solution-list-of-11-similar-very-imp-problems/)\\n- [House Robber IV - Leetcode](https://leetcode.com/problems/house-robber-iv/solutions/3756280/best-c-solution-list-of-similar-very-imp-binary-problems/)\\n- [Minimum Speed to Arrive on Time - Leetcode](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/solutions/3817728/best-c-solution-list-of-10-similar-very-imp-problems-asked-in-faang-interviews/)\\n- [Minimum Time to Repair Cars - Leetcode](https://leetcode.com/problems/minimum-time-to-repair-cars/solutions/3753730/best-c-solution-list-of-8-similar-very-imp-binary-search-questions/)\\n- [Minimum Number of Days to Make m Bouquets - Leetcode](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/solutions/3751751/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Capacity To Ship Packages Within D Days - Leetcode](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3751752/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Minimized Maximum of Products Distributed to Any Store - Leetcode](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/solutions/3750918/best-c-solution-list-of-similar-very-imp-binary-search-questions/) \\n- [Book Allocation - Coding Ninjas](https://www.codingninjas.com/studio/problems/ayush-and-ninja-test_1097574?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n- [Aggressive cows - Coding Ninjas](https://www.codingninjas.com/studio/problems/aggressive-cows_1082559?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=1)\\n- [Painter\\'s partition - Coding Ninjas](https://www.codingninjas.com/studio/problems/painter\\'s-partition-problem_1089557?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int n = piles.size(), start = 1, end = piles[n-1], ans = 1; // You can also initiate start and end as per the constraints\\n        if(n==h)    return end;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            long long hourCount = 0;\\n            for(int i=0; i<n; i++)\\n                hourCount += (piles[i]-1)/mid + 1;\\n            if(hourCount<=h)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int n = piles.size(), start = 1, end = piles[n-1], ans = 1; // You can also initiate start and end as per the constraints\\n        if(n==h)    return end;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            long long hourCount = 0;\\n            for(int i=0; i<n; i++)\\n                hourCount += (piles[i]-1)/mid + 1;\\n            if(hourCount<=h)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272648,
                "title": "solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool canEatAll(vector<int>& piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1;\\n            if (time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canEatAll(piles, mid, h)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    bool canEatAll(vector<int>& piles, int speed, int h) {\\n        int time = 0;\\n        for (int pile : piles) {\\n            time += (pile - 1) / speed + 1;\\n            if (time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492154,
                "title": "to-those-who-failed-the-last-test-case-of-805306368-805306368-805306368-1000000000",
                "content": "Your hour variable overflow since it took Koko too much time to eat. Simply change it to long.\\n```\\npublic boolean check(int[] piles, int k, int h) {\\n        long hour = 0;\\n        for (int pile : piles) {\\n            hour += pile / k;\\n            if (pile % k != 0)\\n                hour++;\\n        }\\n        return hour <= h;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean check(int[] piles, int k, int h) {\\n        long hour = 0;\\n        for (int pile : piles) {\\n            hour += pile / k;\\n            if (pile % k != 0)\\n                hour++;\\n        }\\n        return hour <= h;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112358,
                "title": "very-simple-python-solution-beats-90-online-subs-with-detailed-explanation",
                "content": "Success\\n     Details \\n    Runtime: 408 ms, faster than 90.99% of Python3 online submissions for Koko Eating Bananas.\\n    Memory Usage: 15.4 MB, less than 98.70% of Python3 online submissions for Koko Eating Bananas\\n\\n\\n     def canfinish(K):\\n            hours_needed = 0\\n            for p in piles:\\n                  hours_needed+= ceil(p/K) #doing the cummulative sum\\n              return hours_needed <= h   \\n        \\n        # here we are taking k b/w the range of 1, max(piles)\\n\\n            \\n        l = 1\\n        r = max(piles)\\n            \\n        while l<r:\\n            mid = (l+r)//2\\n                \\n            if canfinish(mid):# we are checking if we can finish with mid speed\\n                r = mid       #if yes then we will see if there is anything min than this \\n                              # and the reason we are not making the r = mid -1 coz \\n                              # then if our mid would be the required k then we might miss it.\\n            \\n            else:\\n                l = mid+1\\n                    \\n        return r\\n        \\n**IF YOU FIND IT HELP PLEASE UPVOTE**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Success\\n     Details \\n    Runtime: 408 ms, faster than 90.99% of Python3 online submissions for Koko Eating Bananas.\\n    Memory Usage: 15.4 MB, less than 98.70% of Python3 online submissions for Koko Eating Bananas\\n\\n\\n     def canfinish(K):\\n            hours_needed = 0\\n            for p in piles:\\n                  hours_needed+= ceil(p/K) #doing the cummulative sum\\n              return hours_needed <= h   \\n        \\n        # here we are taking k b/w the range of 1, max(piles)\\n\\n            \\n        l = 1\\n        r = max(piles)\\n            \\n        while l<r:\\n            mid = (l+r)//2\\n                \\n            if canfinish(mid):# we are checking if we can finish with mid speed\\n                r = mid       #if yes then we will see if there is anything min than this \\n                              # and the reason we are not making the r = mid -1 coz \\n                              # then if our mid would be the required k then we might miss it.\\n            \\n            else:\\n                l = mid+1\\n                    \\n        return r\\n        \\n**IF YOU FIND IT HELP PLEASE UPVOTE**",
                "codeTag": "Python3"
            },
            {
                "id": 692856,
                "title": "python-solution-binary-search",
                "content": "If the length of the piles is equal to the H, each time koko need to finish a pile in order to eat all of them within the limited time. So k=max(piles)\\n\\nIf the length of the piles is bigger than the H, koko can not finish eat all of them.\\n\\nIf the length of the piles is smaller than the H, we could find a k smaller than the max(piles)\\n\\n\\n\\nClass Solution:\\n\\n\\n\\t\\tdef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n\\t\\t#If the length of the piles is equal to the H, return max(piles)\\n\\t\\t\\tif H == len(piles):\\n\\t\\t\\t\\treturn max(piles)\\n\\t\\t\\n\\t\\t#Binary search\\n\\t\\t#Koko could each at least 1 banana and at most max(piles) bananas each time\\n\\t\\t\\tlo, hi = 1, max(piles)\\n\\n\\t\\t\\twhile lo < hi:\\n\\t\\t#Get the mid number of bananas to eat\\n\\t\\t\\t\\tmid = (lo+hi) // 2\\n\\t\\t\\n\\t\\t#Calculate how many hours that koko need to finish eating all of the piles given the eating speed mid \\n\\t\\t\\t\\th = 0\\n\\t\\t\\t\\tfor p in piles:\\n\\t\\t\\t\\t\\tif p < mid:\\n\\t\\t\\t\\t\\t\\th += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\th += math.ceil(p/mid)\\n\\t\\t#If the time that koko need is less than or equal to H, we need to search for the left part\\n\\t\\t\\t\\tif h <= H:\\n\\t\\t\\t\\t\\thi = mid\\n\\t\\t#If the time that koko need is bigger than H, we need to search for the right part\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tlo = mid + 1\\n\\t\\t\\treturn lo",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "If the length of the piles is equal to the H, each time koko need to finish a pile in order to eat all of them within the limited time. So k=max(piles)\\n\\nIf the length of the piles is bigger than the H, koko can not finish eat all of them.\\n\\nIf the length of the piles is smaller than the H, we could find a k smaller than the max(piles)\\n\\n\\n\\nClass Solution:\\n\\n\\n\\t\\tdef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n\\t\\t#If the length of the piles is equal to the H, return max(piles)\\n\\t\\t\\tif H == len(piles):\\n\\t\\t\\t\\treturn max(piles)\\n\\t\\t\\n\\t\\t#Binary search\\n\\t\\t#Koko could each at least 1 banana and at most max(piles) bananas each time\\n\\t\\t\\tlo, hi = 1, max(piles)\\n\\n\\t\\t\\twhile lo < hi:\\n\\t\\t#Get the mid number of bananas to eat\\n\\t\\t\\t\\tmid = (lo+hi) // 2\\n\\t\\t\\n\\t\\t#Calculate how many hours that koko need to finish eating all of the piles given the eating speed mid \\n\\t\\t\\t\\th = 0\\n\\t\\t\\t\\tfor p in piles:\\n\\t\\t\\t\\t\\tif p < mid:\\n\\t\\t\\t\\t\\t\\th += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\th += math.ceil(p/mid)\\n\\t\\t#If the time that koko need is less than or equal to H, we need to search for the left part\\n\\t\\t\\t\\tif h <= H:\\n\\t\\t\\t\\t\\thi = mid\\n\\t\\t#If the time that koko need is bigger than H, we need to search for the right part\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tlo = mid + 1\\n\\t\\t\\treturn lo",
                "codeTag": "Python3"
            },
            {
                "id": 408055,
                "title": "simple-javascript-solution",
                "content": "```\\nfunction minEatingSpeed(piles, H) {\\n  function canEatAll(speed) {\\n    let time = 0;\\n    for (let p of piles) {\\n      time += Math.ceil(p / speed);\\n    }\\n    return time <= H;\\n  }\\n\\n  let l = 0;\\n  let r = Math.max(...piles);  // when the max speed = biggest pile, it only needs 1h to eat each pile\\n  while (l < r) {\\n    const m = Math.floor((l + r) / 2);\\n    if (!canEatAll(m)) l = m + 1;\\n    else r = m;\\n  }\\n  return l;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nfunction minEatingSpeed(piles, H) {\\n  function canEatAll(speed) {\\n    let time = 0;\\n    for (let p of piles) {\\n      time += Math.ceil(p / speed);\\n    }\\n    return time <= H;\\n  }\\n\\n  let l = 0;\\n  let r = Math.max(...piles);  // when the max speed = biggest pile, it only needs 1h to eat each pile\\n  while (l < r) {\\n    const m = Math.floor((l + r) / 2);\\n    if (!canEatAll(m)) l = m + 1;\\n    else r = m;\\n  }\\n  return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3270761,
                "title": "white-board-solution-ultimate-binary-search-video-solution",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=FVdgesYtCco&feature=youtu.be\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/80201054-fa14-44dd-867b-90b553079de5_1678247029.4675646.png)\\n![image.png](https://assets.leetcode.com/users/images/6b5b3466-f4a1-43aa-8164-5898a518d07b_1678247047.7302418.png)\\n![image.png](https://assets.leetcode.com/users/images/5526a725-3c1d-4714-8332-fd4d97b9ac50_1678247054.649504.png)\\n![image.png](https://assets.leetcode.com/users/images/a592cdab-51ca-48fb-9f02-efe1244d5cc2_1678247060.3896809.png)\\n![image.png](https://assets.leetcode.com/users/images/04696fd6-442e-46b7-871b-0db78de7ff9a_1678247070.2887137.png)\\n![image.png](https://assets.leetcode.com/users/images/7fdd88de-eecf-4635-8a84-c4b8228470e3_1678247078.526738.png)\\n![image.png](https://assets.leetcode.com/users/images/f55446c8-bb0b-413f-9498-1fe8f91d19f3_1678247089.6819258.png)\\n![image.png](https://assets.leetcode.com/users/images/15e0a66c-4c24-470b-9e01-4735ae4ae4e7_1678247099.0462978.png)\\n![image.png](https://assets.leetcode.com/users/images/2695e91a-d9fc-467f-9718-cf051eeebde7_1678247106.8703642.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool is_possible(int k, vector<int>& piles, int h){\\n        int hours_req = 0;\\n        for(int bananas : piles){\\n            hours_req += ceil((bananas*1.0)/k);\\n        }\\n\\n        return (hours_req <= h);\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1, r=1e9;\\n        while(l < r){\\n            int mid = (l + r)/2;\\n            if(is_possible(mid, piles, h)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool is_possible(int k, vector<int>& piles, int h){\\n        int hours_req = 0;\\n        for(int bananas : piles){\\n            hours_req += ceil((bananas*1.0)/k);\\n        }\\n\\n        return (hours_req <= h);\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1, r=1e9;\\n        while(l < r){\\n            int mid = (l + r)/2;\\n            if(is_possible(mid, piles, h)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270374,
                "title": "c-easier-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192016,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        ll i,j,an;\\n        i=1;j=1000000000;\\n        an=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll t=0;\\n            for(int k=0;k<n;k++){\\n              t += piles[k]/m;\\n              if(piles[k]%m)t++;\\n            }\\n            if(t>h)i=m+1;\\n            else {\\n                an=m;\\n                j=m-1;\\n            }\\n        }\\n       return an;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/0ba960b1-62cd-406f-b31d-609dee45e07c_1677408190.5276134.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        ll i,j,an;\\n        i=1;j=1000000000;\\n        an=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll t=0;\\n            for(int k=0;k<n;k++){\\n              t += piles[k]/m;\\n              if(piles[k]%m)t++;\\n            }\\n            if(t>h)i=m+1;\\n            else {\\n                an=m;\\n                j=m-1;\\n            }\\n        }\\n       return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181422,
                "title": "binary-search-o-n-log-max-piles-solution",
                "content": "**Please upvote if you  find this solution useful and do comment if you have any doubts or suggestions**\\n**At max, our k can be max(piles)** as it will take one hour even if the value is less than that.\\nSo we will do **binary search** from 1 to max(piles) untill we get a value of k which is minimum than others.\\nwe will start from l=1 and r=max(piles) and then will findout mid and we will iterate through piles to check how much time it takes, if it is more we will move our right pointer towards mid-1, else we will move our left pointer towards mid+1, and we will use val variable to find out minimum of them.\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k=max(piles)\\n        l=1\\n        r=k\\n        val=float(\"inf\")\\n        while(l<=r):\\n            mid=(l+r)//2\\n            c=0\\n            for i in piles:\\n                c+=ceil(i/mid)\\n            if c>h:\\n                l=mid+1\\n            elif c<=h:\\n                val=min(mid,val)\\n                r=mid-1\\n        return val\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k=max(piles)\\n        l=1\\n        r=k\\n        val=float(\"inf\")\\n        while(l<=r):\\n            mid=(l+r)//2\\n            c=0\\n            for i in piles:\\n                c+=ceil(i/mid)\\n            if c>h:\\n                l=mid+1\\n            elif c<=h:\\n                val=min(mid,val)\\n                r=mid-1\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703504,
                "title": "c-simple-intuitive-solution-binary-search-o-nlogn",
                "content": "We need to find the minimum number of bananas koko needs to eat per hour so that it can finish all the bananas before ```h``` hours.\\n\\n**APPROACH :**\\n* Intuitively, the answer should lie between ```1``` and ```*max_element()``` in the array ```piles```.\\n* If ```h == *max_element()```, koko must eat a minimum of ```*max_element()``` bananas to finish all of them in ```h``` hours.\\n* Otherwise, we can do binary search between the numbers ```1``` and ```*max_element()``` to find the min. no. of bananas to eat so that koko can finish all the bananas in ```h``` hours.\\n\\n**ALGORITHM :**\\n* Initialize ```l=1``` and ```r=max_element(piles.begin(), piles.end())```.\\n* While l < r, do the following :\\n              1. Find ```mid = l + (r-l)/2```.\\n              2. See if taking mid as limit, koko can finish all the bananas in h hours (Initialize ```count=0```. For every element ```x``` in the array, add ```x/mid``` (No. of hours it will take to finish ```x``` bananas if it eats ```mid``` bananas per hour) to count. If ```x%mid > 0``` (Consider the left out bananas after doing ```x/mid```, if it\\'s greater than ```0```, then we need ```1``` more hour) -> increment count by ```1```).\\n              3. See if count <= h. \\n              4. If yes, then coco can easily finish the bananas in ```h``` hours so we\\'ll do ```r=mid``` and check if there\\'s a smaller value for which this can happen.\\n              5. If not, then do ```l=mid+1``` and check for an appropiate value.\\n* Return the minimum num ```mid```.\\n\\n**Time Complexity :** O(nlogn) - For each mid value we traverse the array once - O(n) - ```n = piles.size()```\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1, r=*max_element(piles.begin(), piles.end()), n=piles.size();\\n        \\n        if(n == h) return r;\\n        while(l < r){\\n            int mid = l+(r-l)/2;\\n            if(notEnough(piles, mid, h)) l = mid+1;\\n            else r= mid;\\n        }\\n        return l;\\n    }\\n    \\n    bool notEnough(vector<int> piles, int limit, int h){\\n        int count=0;\\n        for(auto p : piles){\\n            count += p/limit;\\n            if(p%limit) count++;\\n        }\\n        return count > h;\\n    }\\n};\\n```\\n\\nIf you like my solution & explanation, do upvote my post :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```h```\n```1```\n```*max_element()```\n```piles```\n```h == *max_element()```\n```*max_element()```\n```h```\n```1```\n```*max_element()```\n```h```\n```l=1```\n```r=max_element(piles.begin(), piles.end())```\n```mid = l + (r-l)/2```\n```count=0```\n```x```\n```x/mid```\n```x```\n```mid```\n```x%mid > 0```\n```x/mid```\n```0```\n```1```\n```1```\n```h```\n```r=mid```\n```l=mid+1```\n```mid```\n```n = piles.size()```\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1, r=*max_element(piles.begin(), piles.end()), n=piles.size();\\n        \\n        if(n == h) return r;\\n        while(l < r){\\n            int mid = l+(r-l)/2;\\n            if(notEnough(piles, mid, h)) l = mid+1;\\n            else r= mid;\\n        }\\n        return l;\\n    }\\n    \\n    bool notEnough(vector<int> piles, int limit, int h){\\n        int count=0;\\n        for(auto p : piles){\\n            count += p/limit;\\n            if(p%limit) count++;\\n        }\\n        return count > h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665715,
                "title": "c-binary-search-o-n-log-n-binary-search-on-answer",
                "content": "**!!!Please please like or Upvote if you find useful : <3**\\n\\n**Point to Notice :**\\n\\n1. We cant change the pile of bananas.\\n2. The maixmum time to eat those pile who has maxium number of banana. ie(maximum=maxi and minimum =1)\\n3. So number of banana that must be eaten  per hour lie between 1 and maxi.\\n\\n**Thinking about binary searc**h \\n\\n1. Minimum  number of banana eaten per hour is  1.\\n2.  Maximum number of banana eaten per hour is maximum value in the whole array.\\n3. Since we know that answer must lie between maximum and minimum value.\\n4. Here we use binary search b/w max and min and every time you find middle element and go for it.\\n**Helper function:**\\n1. Helper function help to conclude weather we are able to  eat all pile of banana in h hours ,\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>arr,int h,int mid)\\n    {     \\n        int count=0;//intialise no of hour\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n         count+=ceil((arr[i]*1.0)/mid);//checking time taken to eat every pile of banana\\n        }\\n        if(count<=h)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        int n=piles.size();\\n        int start=1;//minimum possible  banana\\n        int end=*max_element(piles.begin(),piles.end());//maximum possible banana eaten\\n        if(h==n)//corner case for easy computaion\\n        {\\n            return end;        \\n        }\\n        \\n        int ans=-1;//intialise final answer\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;// finding middle element\\n            cout<<mid<<endl;\\n            if(is_possible(piles,h,mid))//checking is it possible to eat all banana if monkey eat mid banana per hour..\\n            {\\n               ans=mid;//updating\\n                end=mid-1;    //moving left to find more optimal answer      \\n            }\\n            else\\n            {   \\n               start=mid+1;//moving right to remove impossible cases.\\n            }\\n        }\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>arr,int h,int mid)\\n    {     \\n        int count=0;//intialise no of hour\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n         count+=ceil((arr[i]*1.0)/mid);//checking time taken to eat every pile of banana\\n        }\\n        if(count<=h)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        int n=piles.size();\\n        int start=1;//minimum possible  banana\\n        int end=*max_element(piles.begin(),piles.end());//maximum possible banana eaten\\n        if(h==n)//corner case for easy computaion\\n        {\\n            return end;        \\n        }\\n        \\n        int ans=-1;//intialise final answer\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;// finding middle element\\n            cout<<mid<<endl;\\n            if(is_possible(piles,h,mid))//checking is it possible to eat all banana if monkey eat mid banana per hour..\\n            {\\n               ans=mid;//updating\\n                end=mid-1;    //moving left to find more optimal answer      \\n            }\\n            else\\n            {   \\n               start=mid+1;//moving right to remove impossible cases.\\n            }\\n        }\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3271117,
                "title": "j",
                "content": "# Intuition\\nHere the intuition of the problem is search in the non given space .Don\\'t think we do binary search over the given Array but do binary search over the lowest value i.e. 1 and highest value in the  array.\\n\\n# Approach\\nBRUTE FORCE\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 logn)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=-1;\\n        int k=0;\\n        //Getting the  highest value in the array\\n        for(int i:piles){\\n            high=Integer.max(high,i);\\n        }\\n        //Search  over the values from 1 to high \\n        while( low < high){\\n            int m=(low+high)/2;\\n             k=0;\\n            for(int val:piles){\\n                //total timing when each piles were eaten in m per hour\\n                k+=Math.ceil((double)val/m);\\n             }\\n             //check whether the total timing is less than h if it is then   keep high = m\\n             //if m is answer than m+1 definetly the answer but m-1 may or may not be the answer\\n             //so always keep high as m\\n             if(k <= h) high=m;\\n             // if  it takes time greater than h then move l to m+1\\n             else low=m+1;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=-1;\\n        int k=0;\\n        //Getting the  highest value in the array\\n        for(int i:piles){\\n            high=Integer.max(high,i);\\n        }\\n        //Search  over the values from 1 to high \\n        while( low < high){\\n            int m=(low+high)/2;\\n             k=0;\\n            for(int val:piles){\\n                //total timing when each piles were eaten in m per hour\\n                k+=Math.ceil((double)val/m);\\n             }\\n             //check whether the total timing is less than h if it is then   keep high = m\\n             //if m is answer than m+1 definetly the answer but m-1 may or may not be the answer\\n             //so always keep high as m\\n             if(k <= h) high=m;\\n             // if  it takes time greater than h then move l to m+1\\n             else low=m+1;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270861,
                "title": "binary-search-py",
                "content": "# Approach\\n<h4>Binary Search\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l,r=1,max(piles)\\n        while l<r:\\n            mid,t=(l+r)//2,0\\n            for i in piles: t+=(i+mid-1)//mid\\n            print(t,mid,end=\" \")\\n            if t<=h:r=mid\\n            else:l=mid+1\\n        return l \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l,r=1,max(piles)\\n        while l<r:\\n            mid,t=(l+r)//2,0\\n            for i in piles: t+=(i+mid-1)//mid\\n            print(t,mid,end=\" \")\\n            if t<=h:r=mid\\n            else:l=mid+1\\n        return l \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601825,
                "title": "java-basic-binary-search-98-fatser",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = 0;\\n        for(int i = 0; i< piles.length; i++){\\n            max = Math.max(max , piles[i]);\\n        }\\n        \\n        if(h == piles.length){\\n            return max;\\n        }\\n        int low = 0;\\n        int high = max;\\n        int speed = Integer.MAX_VALUE;\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(ifpossible(mid , piles , h)){\\n                speed = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return speed;\\n    }\\n        public static boolean ifpossible(int mid , int crates[] , int h){\\n            int time = 0;\\n            for(int i = 0; i< crates.length ; i++){\\n                time += (int) Math.ceil(crates[i] * 1.0/mid);\\n            }\\n            return time<=h;\\n        }\\n        \\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = 0;\\n        for(int i = 0; i< piles.length; i++){\\n            max = Math.max(max , piles[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1704143,
                "title": "c-simple-and-clean-binary-search-solution-explained",
                "content": "**Idea:**\\nWe will use typical binary search.\\nInitializing `lo` with zero, and `hi` with the biggest pile, because that\\'s the biggest amount koko can eat in one hour.\\nNow, we want to check:\\nIf koko can eat `mid` bananas an hour and finish on time, maybe she can eat less, so we set `hi = mid` and continue searching.\\nIf koko cannot eat `mid` bananas an hour, we need to try a larger number, so we set `lo = mid + 1` and continue searching.\\n\\n**Time Complexity:** O(mlog(n)) - m is number of piles and n is size of largest pile.\\n**Space Complexity:** O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    bool can_eat_k(vector<int>& piles, int k, int h) {\\n        if (h <= piles.size()) return false;\\n\\n        for (auto p : piles)\\n            h -= (p / k + (p % k != 0));\\n\\n        return h >= 0;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1, hi = *max_element(piles.begin(), piles.end()), mid;\\n        \\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (can_eat_k(piles, mid, h)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool can_eat_k(vector<int>& piles, int k, int h) {\\n        if (h <= piles.size()) return false;\\n\\n        for (auto p : piles)\\n            h -= (p / k + (p % k != 0));\\n\\n        return h >= 0;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1, hi = *max_element(piles.begin(), piles.end()), mid;\\n        \\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (can_eat_k(piles, mid, h)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390523,
                "title": "simple-python-binary-search",
                "content": "Please see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T...TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\n```\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        def cannot_eat(piles, H, K):\\n            hours = 0\\n            for x in piles:\\n                if x % K == 0:\\n                    hours += x // K\\n                else:\\n                    hours += x // K + 1\\n            return hours > H\\n        \\n        low, high = 1, max(piles)\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if cannot_eat(piles, H, mid):\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        def cannot_eat(piles, H, K):\\n            hours = 0\\n            for x in piles:\\n                if x % K == 0:\\n                    hours += x // K\\n                else:\\n                    hours += x // K + 1\\n            return hours > H\\n        \\n        low, high = 1, max(piles)\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if cannot_eat(piles, H, mid):\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 152472,
                "title": "python-binary-search-with-bisect",
                "content": "**Explanation:**\\n\\n 1. `CanEat()` acts like a list of `True` or `False` (**Can Koko eat all bananas within H hours?)** with different speed K as its index.\\n\\n 2. We want to find the first (minimum) K that satisfies `CanEat()`:\\n\\n```\\n                           \\u25BC\\n[... False, False, False, True, True, True ...]\\n```\\n\\n3. Binary Search from `1` to `10**9`\\n\\n**Python:**\\n\\n```python\\nfrom bisect import bisect_left\\n\\ndef minEatingSpeed(piles, H):\\n\\n    class CanEat: __getitem__ = (lambda _, i: \\n        sum(ceil(p/i) for p in piles) <= H\\n    )\\n\\n    #      bisect_left(list,     item, lo, hi)\\n    return bisect_left(CanEat(), True, 1, 10**9)\\n```\\n\\n---\\n\\n",
                "solutionTags": [],
                "code": "```\\n                           \\u25BC\\n[... False, False, False, True, True, True ...]\\n```\n```python\\nfrom bisect import bisect_left\\n\\ndef minEatingSpeed(piles, H):\\n\\n    class CanEat: __getitem__ = (lambda _, i: \\n        sum(ceil(p/i) for p in piles) <= H\\n    )\\n\\n    #      bisect_left(list,     item, lo, hi)\\n    return bisect_left(CanEat(), True, 1, 10**9)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927733,
                "title": "c-binary-search-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n//allocate the piles of banana\\n    long long allocate(vector<int>&v, int banana){\\n        long long sum=0;\\n        for(int it: v){\\n            sum = sum + (it/banana)+((it % banana) !=0);\\n        }\\n        return sum;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        // 3 6 7 11  => h=8\\n        int ans=0;\\n        int s = 1, e = *max_element(piles.begin(),piles.end());\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            long long alloted = allocate(piles, mid);\\n            if(alloted <= h){\\n                ans = mid;\\n                e = mid-1;\\n            } \\n            else s = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n//allocate the piles of banana\\n    long long allocate(vector<int>&v, int banana){\\n        long long sum=0;\\n        for(int it: v){\\n            sum = sum + (it/banana)+((it % banana) !=0);\\n        }\\n        return sum;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        // 3 6 7 11  => h=8\\n        int ans=0;\\n        int s = 1, e = *max_element(piles.begin(),piles.end());\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            long long alloted = allocate(piles, mid);\\n            if(alloted <= h){\\n                ans = mid;\\n                e = mid-1;\\n            } \\n            else s = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881077,
                "title": "easy-and-simple-image-solution-bs",
                "content": "\\n# Approach\\n- Binary Search\\n- Koko wants to eat all bananas within $h$ hours. We are supposed to find the minimum value of $k$.\\n- eg.- $piles = [30,11,23,4,20], h = 6$\\n- $l = 0$ and $r = 1e9+5$\\n- so, we find out the value of k using binary search in $log(1e9)$ complexity.\\n- for this we get $h = 23$\\n- Koko will eat bananas in this way to eat all bananas in 6 hours:\\n![koko.png](https://assets.leetcode.com/users/images/e77ae364-f64b-4f74-b5a9-b441b40872fd_1691487636.3198938.png)\\n\\nFirst hour: 23\\n\\nSecond hour: 7\\n\\nThird hour: 11\\n\\nFourth hour: 23\\n\\nFifth hour: 4\\n\\nSixth hour: 20\\n\\n- if koko eat 23 banana each hours the he will able to eat all in 6 hours.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(nlog(h))$  \\n- n =  length of piles    \\n- Space complexity: $O(1)$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfect(vector<int>& piles, int mid, int hours){\\n        int count = 0;\\n        for(auto p : piles)\\n            if(p % mid > 0) count += ((p/mid) + 1);\\n            else count += (p/mid);\\n        return count <= hours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int hours) {\\n        int l = 1, h = 1e9+5, ans  = 0;\\n        while(l < h){\\n            int mid = (l+h)/2;\\n            if(isPerfect(piles, mid, hours)) ans = mid, h = mid;\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfect(vector<int>& piles, int mid, int hours){\\n        int count = 0;\\n        for(auto p : piles)\\n            if(p % mid > 0) count += ((p/mid) + 1);\\n            else count += (p/mid);\\n        return count <= hours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int hours) {\\n        int l = 1, h = 1e9+5, ans  = 0;\\n        while(l < h){\\n            int mid = (l+h)/2;\\n            if(isPerfect(piles, mid, hours)) ans = mid, h = mid;\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643281,
                "title": "revved-up-gobbling-crush-the-piles-at-lightning-speed",
                "content": "# Intuition\\nPrepare for a gobbling adventure! Our first move is to find the lowest theoretical speed. By calculating `ceil(sum(piles) / h)`, we determine our starting point. For example, with `piles = [4, 11, 20, 23, 30]` and `h = 5`, we should start with speed 18.\\n\\nBut hold on! I\\'ve discovered a secret technique to optimize our banana-eating. Incrementing by a mere 1 won\\'t cut it! We should try the next speed that gives us an improvement. For `piles = [4, 11, 20, 23, 30]` and `curr_speed = 18`, this is how many hours it would take to finish each pile:\\n\\n`piles = [4, 11, 20, 23, 30]`\\n`curr_turns = [1, 1, 2, 3, 3]`\\n\\nTo improve the performance at `piles[2]` from 2 to 1, we need `curr_speed = 20`. \\nTo improve `piles[3]` from 3 to 2, we need `curr_speed = 12`. \\nTo improve `piles[4]` from 3 to 2, we need `curr_speed = 15`. \\nFor the solution to be correct, we need to choose the smallest next speed.\\n\\n# Approach\\nWe can get a major speedup by only keeping track of the piles that need more than 1 hour to finish. We don\\'t need to keep track of the easy piles! Since finding the next speed takes linear time and we have to do it a linear number of times, by maintaining a smaller list we speed up the program from `O(n^2)` to `O(m^2)`, where m is the number of piles that cannot be processed in one hour.\\n\\n# Complexity\\n- Time complexity: `O(n) + O(m^2)`. One pass to find theoretical minimum. The m is the number of piles that are bigger than the lowest theoretical speed (`m <= n`).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(m)` to store list of big piles.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nAt the time of writing, this solution finishes in top 99%.\\n\\n# Code\\n```\\nfrom math import ceil\\n\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # Start at lowest theoretical speed. \\n        # Increment by a minimal amount that would yield improvement.\\n        # O(n) + O(m^2)\\n        # m is the list of big piles\\n        curr_speed = ceil(sum(piles) / h)\\n        # Only need to consider piles that take multiple turns to finish.\\n        big_piles = [pile for pile in piles if pile > curr_speed]\\n        curr_turns = [ceil(pile / curr_speed) for pile in big_piles]\\n        curr_num_hours = (len(piles) - len(big_piles)) + sum(curr_turns)\\n        while curr_num_hours > h:\\n            # Find minimally higher speed needed to improve any pile\\'s performance\\n            next_speed = float(\"inf\")\\n            for i in range(len(big_piles)):\\n                if curr_turns[i] > 1:\\n                    next_speed = min(next_speed, ceil(big_piles[i] / (curr_turns[i] - 1)))\\n            curr_speed = next_speed\\n            # Would be even faster if we reduce size of curr_turns and update curr_num_hours accordingly\\n            curr_turns = [ceil(pile / curr_speed) for pile in big_piles]\\n            curr_num_hours = (len(piles) - len(big_piles)) + sum(curr_turns)\\n        return curr_speed\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import ceil\\n\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # Start at lowest theoretical speed. \\n        # Increment by a minimal amount that would yield improvement.\\n        # O(n) + O(m^2)\\n        # m is the list of big piles\\n        curr_speed = ceil(sum(piles) / h)\\n        # Only need to consider piles that take multiple turns to finish.\\n        big_piles = [pile for pile in piles if pile > curr_speed]\\n        curr_turns = [ceil(pile / curr_speed) for pile in big_piles]\\n        curr_num_hours = (len(piles) - len(big_piles)) + sum(curr_turns)\\n        while curr_num_hours > h:\\n            # Find minimally higher speed needed to improve any pile\\'s performance\\n            next_speed = float(\"inf\")\\n            for i in range(len(big_piles)):\\n                if curr_turns[i] > 1:\\n                    next_speed = min(next_speed, ceil(big_piles[i] / (curr_turns[i] - 1)))\\n            curr_speed = next_speed\\n            # Would be even faster if we reduce size of curr_turns and update curr_num_hours accordingly\\n            curr_turns = [ceil(pile / curr_speed) for pile in big_piles]\\n            curr_num_hours = (len(piles) - len(big_piles)) + sum(curr_turns)\\n        return curr_speed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272877,
                "title": "javascript-solution-beats-99-56-binary-search-approach",
                "content": "```javascript\\n/**\\n * @param {number[]} piles\\n * @param {number} speed\\n * @param {number} h\\n * @return {boolean}\\n */\\nconst canEatAll = (piles, speed, h) => {\\n    let totalTime = 0;\\n    for (const bananas of piles) {\\n        totalTime += Math.ceil(bananas / speed);\\n        if (totalTime > h) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n\\n/**\\n * @param {number[]} piles\\n * @param {number} h\\n * @return {number}\\n */\\nvar minEatingSpeed = function (piles, h) {\\n    let left = 1, right = Math.max(...piles);\\n    while (left <= right) {\\n        const mid = Math.floor(left + (right - left) / 2);\\n        if (canEatAll(piles, mid, h)) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} piles\\n * @param {number} speed\\n * @param {number} h\\n * @return {boolean}\\n */\\nconst canEatAll = (piles, speed, h) => {\\n    let totalTime = 0;\\n    for (const bananas of piles) {\\n        totalTime += Math.ceil(bananas / speed);\\n        if (totalTime > h) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n\\n/**\\n * @param {number[]} piles\\n * @param {number} h\\n * @return {number}\\n */\\nvar minEatingSpeed = function (piles, h) {\\n    let left = 1, right = Math.max(...piles);\\n    while (left <= right) {\\n        const mid = Math.floor(left + (right - left) / 2);\\n        if (canEatAll(piles, mid, h)) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271281,
                "title": "pytgon3-98-fast-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Binary search.**\\n![Capture.PNG](https://assets.leetcode.com/users/images/024e5e94-3f78-4279-97b5-294b38bf9cd5_1678256525.242.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Well this is not array binary search but more like dangling speed search.\\n- we have lowspeed and **maxspeed**, where **lowspeed** is obviously **1** and **maxspeed** is **maximum(piles)**.\\n- now start dangling between low and max speed.\\n- find **mid speed**, **if** at that speed **we can eat** all banana within givren hr = h then we can **assume** that **loweing speed** might **help** to **find minimum**, so now our maxspeed is midspeed.\\n- now if midspeed is **not covering all bananas** then incresing lowspeed will help, so **lowspeed is now midspeed + 1** (midspeed is not helping so increse it by 1).\\n- do this we converge on **lowspeed ==  midspeed**, and return found lowspeed.\\n- **isPossible()**: helps to **identify** if we use current speedn then **can** we **eat all bananas** within **given time**.\\n\\n# Complexity\\n- Time complexity: O(N * logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import ceil as c, floor as f\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def isPossible(rate_of_banana_eating):\\n            total_hr = 0\\n            for i in piles:\\n                total_hr += c(i / rate_of_banana_eating)\\n            return total_hr <= h\\n        \\n        def find_speed():\\n            maximumSpeed = max(piles)\\n            lowestSpeed = 1\\n            while lowestSpeed < maximumSpeed:\\n                midSpeed = f((lowestSpeed+maximumSpeed)/2)\\n                if isPossible(midSpeed):\\n                    maximumSpeed = midSpeed\\n                else:\\n                    lowestSpeed = midSpeed + 1\\n            return lowestSpeed\\n        return find_speed()\\n\\n```\\n# Note: why only divide by 2\\n - because /2 is efficient than any other /3 or /4.\\n - and somethimes it may be case when we divide by 4 then lowspeed and maxspeed keep changing same values between old and new onces.\\n - so our code will run till infinity.\\n# Please like and comment below. :-)\\n\\uD83C\\uDD5F\\uD83C\\uDD57\\uD83C\\uDD54\\uD83C\\uDD66 \\uD83C\\uDD57\\uD83C\\uDD50\\uD83C\\uDD61\\uD83C\\uDD53 \\uD83C\\uDD5E\\uD83C\\uDD5D\\uD83C\\uDD54",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nfrom math import ceil as c, floor as f\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def isPossible(rate_of_banana_eating):\\n            total_hr = 0\\n            for i in piles:\\n                total_hr += c(i / rate_of_banana_eating)\\n            return total_hr <= h\\n        \\n        def find_speed():\\n            maximumSpeed = max(piles)\\n            lowestSpeed = 1\\n            while lowestSpeed < maximumSpeed:\\n                midSpeed = f((lowestSpeed+maximumSpeed)/2)\\n                if isPossible(midSpeed):\\n                    maximumSpeed = midSpeed\\n                else:\\n                    lowestSpeed = midSpeed + 1\\n            return lowestSpeed\\n        return find_speed()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271069,
                "title": "easy-approach",
                "content": "Happy Holi guys...\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l=1\\n        r=max(piles)\\n        while l<r:\\n            mid=(l+r)//2\\n            c=0\\n            for j in piles:\\n                c+=((j-1)//mid)+1\\n            if c>h:\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```\\n# **Please Upvote this post**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l=1\\n        r=max(piles)\\n        while l<r:\\n            mid=(l+r)//2\\n            c=0\\n            for j in piles:\\n                c+=((j-1)//mid)+1\\n            if c>h:\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270710,
                "title": "python3-97-98-faster-beats-only-one-line-clean-solution-simple-explain",
                "content": "![image.png](https://assets.leetcode.com/users/images/d2ec0401-b191-4b24-98b1-1d178baaba64_1678266432.1355073.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a speed time list, then Binary search the precise number such that meet the requirements of the problem.\\n# Complexity\\n- Time complexity:O(logN)\\nBinary search with \\nstart , end = 1, max(piles) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\nNeed create time list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        return bisect_left(range(1,max(piles)), True , key=lambda t:sum(ceil(pile/t) for pile in piles)<=h )+1\\n        # Tips: time list start at 1 because can\\'t divide by zero\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        return bisect_left(range(1,max(piles)), True , key=lambda t:sum(ceil(pile/t) for pile in piles)<=h )+1\\n        # Tips: time list start at 1 because can\\'t divide by zero\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270643,
                "title": "c-binary-search",
                "content": "Minimum Speed with which we could just Finish the Piles within H hours.\\n# Complexity\\n- Time complexity:\\nO(NLOGH)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool could_eat(vector<int>&piles,int h,int speed)\\n    {\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            if(piles[i]%speed==0)\\n            {\\n                h-=(piles[i]/speed);//(piles[i]/speed) units of time to finish pile\\n            }\\n            else\\n            {\\n                h-=(piles[i]/speed)+1;(piles[i]/speed) units of time + 1 for remainder to finish pile\\n            }\\n            if(h<0)\\n            {\\n                return false;//time out....Guards return before could finish completing the current pile\\n            }\\n        }\\n        return true;//Guards didn\\'t return wihtin time to catch\\n    }\\n    int minEatingSpeed(vector<int>&piles,int h) \\n    {\\n        int left=1,right=INT_MIN;\\n        for(auto j:piles)//with this maximum limit we could always complete piles within time\\n        {\\n            right=max(right,j);\\n        }\\n        while(left<=right)//Normal Binary Search to find Minimum Element for which could_eat_piles within time\\n        {\\n            int mid=(left+right)/2;\\n            if(could_eat(piles,h,mid))\\n            {\\n                right=mid-1;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool could_eat(vector<int>&piles,int h,int speed)\\n    {\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            if(piles[i]%speed==0)\\n            {\\n                h-=(piles[i]/speed);//(piles[i]/speed) units of time to finish pile\\n            }\\n            else\\n            {\\n                h-=(piles[i]/speed)+1;(piles[i]/speed) units of time + 1 for remainder to finish pile\\n            }\\n            if(h<0)\\n            {\\n                return false;//time out....Guards return before could finish completing the current pile\\n            }\\n        }\\n        return true;//Guards didn\\'t return wihtin time to catch\\n    }\\n    int minEatingSpeed(vector<int>&piles,int h) \\n    {\\n        int left=1,right=INT_MIN;\\n        for(auto j:piles)//with this maximum limit we could always complete piles within time\\n        {\\n            right=max(right,j);\\n        }\\n        while(left<=right)//Normal Binary Search to find Minimum Element for which could_eat_piles within time\\n        {\\n            int mid=(left+right)/2;\\n            if(could_eat(piles,h,mid))\\n            {\\n                right=mid-1;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270492,
                "title": "java-100-faster-step-by-step-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/ac776f4f-2cae-480b-85a4-c39a454dade5_1678239037.368098.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n    // Calculate the minimum and maximum possible values of k\\n    int left = 1, right = (int) 1e9;\\n    \\n    // Binary search to find the minimum value of k\\n    while (left < right) {\\n        int mid = (left + right) / 2;\\n        \\n        // Check if it\\'s possible to eat all bananas with mid as k\\n        if (canEatAllBananas(piles, h, mid)) {\\n            // If it\\'s possible, then we can try to reduce k further\\n            right = mid;\\n        } else {\\n            // If it\\'s not possible, then we need to increase k\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    // The value of left will be the minimum value of k that allows Koko to eat all bananas in h hours\\n    return left;\\n}\\n\\nprivate boolean canEatAllBananas(int[] piles, int h, int k) {\\n    // Initialize hours to 0\\n    int hours = 0;\\n    \\n    // Iterate over each pile of bananas\\n    for (int bananas : piles) {\\n        // Calculate the number of hours required to eat this pile\\n        int pileHours = bananas / k;\\n        if (bananas % k != 0) {\\n            pileHours++; // If there are some bananas left over, we need one more hour\\n        }\\n        \\n        // Add the hours required to eat this pile to the total hours\\n        hours += pileHours;\\n        \\n        // If the total hours exceed h, then we can\\'t eat all bananas in h hours\\n        if (hours > h) {\\n            return false;\\n        }\\n    }\\n    \\n    // If we reach this point, it means we can eat all bananas in h hours\\n    return true;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n    // Calculate the minimum and maximum possible values of k\\n    int left = 1, right = (int) 1e9;\\n    \\n    // Binary search to find the minimum value of k\\n    while (left < right) {\\n        int mid = (left + right) / 2;\\n        \\n        // Check if it\\'s possible to eat all bananas with mid as k\\n        if (canEatAllBananas(piles, h, mid)) {\\n            // If it\\'s possible, then we can try to reduce k further\\n            right = mid;\\n        } else {\\n            // If it\\'s not possible, then we need to increase k\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    // The value of left will be the minimum value of k that allows Koko to eat all bananas in h hours\\n    return left;\\n}\\n\\nprivate boolean canEatAllBananas(int[] piles, int h, int k) {\\n    // Initialize hours to 0\\n    int hours = 0;\\n    \\n    // Iterate over each pile of bananas\\n    for (int bananas : piles) {\\n        // Calculate the number of hours required to eat this pile\\n        int pileHours = bananas / k;\\n        if (bananas % k != 0) {\\n            pileHours++; // If there are some bananas left over, we need one more hour\\n        }\\n        \\n        // Add the hours required to eat this pile to the total hours\\n        hours += pileHours;\\n        \\n        // If the total hours exceed h, then we can\\'t eat all bananas in h hours\\n        if (hours > h) {\\n            return false;\\n        }\\n    }\\n    \\n    // If we reach this point, it means we can eat all bananas in h hours\\n    return true;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208566,
                "title": "python3-golang-rust-binary-search",
                "content": "**Python3**:\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        left, right = 1, max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            hours = 0\\n            \\n            for pile in piles:\\n                hours += ceil(pile / mid)\\n                \\n            if hours <= h:\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return right\\n```\\n**Golang**:\\n```\\nfunc minEatingSpeed(piles []int, h int) int {\\n    left, right := 1, max(piles)\\n    \\n    for left < right {\\n        mid := (left + right) / 2\\n        hours := 0\\n        \\n        for _, pile := range(piles) {\\n            hours += int(math.Ceil(float64(pile) / float64(mid)))\\n        }\\n        \\n        if hours <= h {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    return right\\n}\\n\\nfunc max(arr []int) int {\\n    max := arr[0]\\n    \\n    for _, val := range(arr) {\\n        if max < val {\\n            max = val\\n        }\\n    }\\n    return max\\n}\\n```\\n\\n**Rust**:\\n```\\nimpl Solution {\\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\\n        let mut left: i32 = 1;\\n        let mut right: i32 = *piles.iter().max().unwrap();\\n        \\n        while left < right {\\n            let mid: i32 = (left + right) / 2;\\n            let mut hours: i32 = 0;\\n            \\n            for pile in &piles {\\n                hours += (*pile as f64 / mid as f64).ceil() as i32\\n            }\\n            \\n            if hours <= h {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return right\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        left, right = 1, max(piles)\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            hours = 0\\n            \\n            for pile in piles:\\n                hours += ceil(pile / mid)\\n                \\n            if hours <= h:\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return right\\n```\n```\\nfunc minEatingSpeed(piles []int, h int) int {\\n    left, right := 1, max(piles)\\n    \\n    for left < right {\\n        mid := (left + right) / 2\\n        hours := 0\\n        \\n        for _, pile := range(piles) {\\n            hours += int(math.Ceil(float64(pile) / float64(mid)))\\n        }\\n        \\n        if hours <= h {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    return right\\n}\\n\\nfunc max(arr []int) int {\\n    max := arr[0]\\n    \\n    for _, val := range(arr) {\\n        if max < val {\\n            max = val\\n        }\\n    }\\n    return max\\n}\\n```\n```\\nimpl Solution {\\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\\n        let mut left: i32 = 1;\\n        let mut right: i32 = *piles.iter().max().unwrap();\\n        \\n        while left < right {\\n            let mid: i32 = (left + right) / 2;\\n            let mut hours: i32 = 0;\\n            \\n            for pile in &piles {\\n                hours += (*pile as f64 / mid as f64).ceil() as i32\\n            }\\n            \\n            if hours <= h {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783416,
                "title": "c-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minEatingSpeed(vector<int>& piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minEatingSpeed(vector<int>& piles, int H) {\\n        int l = 1, r = 1000000000;\\n        while (l < r) {\\n            int m = (l + r) / 2, total = 0;\\n            for (int p : piles)\\n                total += (p + m - 1) / m;\\n            if (total > H)\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705032,
                "title": "java-binary-search-solution-easily-explained-even-for-beginners",
                "content": "Let\\'s see how it works.\\nSo the basic idea of a binary search algorithm is to partition a search space into half after each iteration. Same is supposed to be done here. The catch is, we are searching a space we will create ourselves.\\n\\nWe have to return the minimum rate of eating bananas so that, we are finished in ```h``` hours.\\nHow should we go about it? Well binary search suggests us to deal with a sorted array but what sorted array to be exact ? ```piles``` one ? No, we will deal with an increasing sequence of numbers with length equal to ```piles[max] - piles[min]```. What good would this do? Well this will help us search between slowest and fastest rate we could go. \\n\\t    We will start our lower boundary with ```low = 1``` with 1 being the minimum speed of eating bananas anad ```high = piles[max]```. Then we\\'ll follow the traditional binary search, calculate the mid and then comes the crucial part. We must calculate ```total time taken``` by each ```mid``` integer and we will check if that time taken is within the range of given ```h```. If the time is <= h then we will go towards the slower rate to find an even smaller number that can satisfy the time limit of h hours. Ultimately the \\'low\\' and \\'high\\' boundries will converge and we will return the value that would be the minimum rate at which we could eat bananas. Following is the implementation.\\n\\t\\t\\n\\tclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1;\\n        int high = 1;\\n        for(int i=0;i<piles.length;i++){\\n            high = Math.max(high,piles[i]);\\n        }\\n        while(low<high){\\n            int m = (low+high)/2;\\n            int k=0;\\n            for(var i : piles){\\n                k+=Math.ceil((double)i/m);\\n            }\\n            if(k<=h) high = m;\\n            else low = m+1;\\n        }\\n        return high;\\n    }\\n}\\n\\n****Do upvote if you like the explanation.****",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```h```\n```piles```\n```piles[max] - piles[min]```\n```low = 1```\n```high = piles[max]```\n```total time taken```\n```mid```\n```h```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703574,
                "title": "python3-heap-queue",
                "content": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        h_left = h - len(piles)\\n        total = sum(piles)\\n        hq = []\\n        \\n        for bananas in piles:\\n            hour = 1 + h_left * bananas // total\\n            bananas_per_hour = math.ceil(bananas / hour)\\n            heapq.heappush(hq,(-bananas_per_hour, bananas, hour))\\n            h -= hour\\n        \\n        while h > 0:\\n            _, bananas, hour = heapq.heappop(hq)\\n            hour += 1\\n            h -= 1\\n            bananas_per_hour = math.ceil(bananas / hour)\\n            heapq.heappush(hq,(-bananas_per_hour, bananas, hour))\\n        \\n        return -hq[0][0]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        h_left = h - len(piles)\\n        total = sum(piles)\\n        hq = []\\n        \\n        for bananas in piles:\\n            hour = 1 + h_left * bananas // total\\n            bananas_per_hour = math.ceil(bananas / hour)\\n            heapq.heappush(hq,(-bananas_per_hour, bananas, hour))\\n            h -= hour\\n        \\n        while h > 0:\\n            _, bananas, hour = heapq.heappop(hq)\\n            hour += 1\\n            h -= 1\\n            bananas_per_hour = math.ceil(bananas / hour)\\n            heapq.heappush(hq,(-bananas_per_hour, bananas, hour))\\n        \\n        return -hq[0][0]",
                "codeTag": "Java"
            },
            {
                "id": 1534739,
                "title": "c-binary-search-faster-than-95",
                "content": "```\\n    bool check(int k, int h, vector<int> &piles){\\n      int count = 0;\\n      for(auto it : piles){\\n        count += it / k;\\n        if(it % k != 0) count++;\\n      }\\n      if(count <= h) return true;\\n      return false;\\n    }\\n  \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      int beg = 1, end = INT_MIN, ans;\\n      for(auto it : piles) if(it > end) end = it;\\n      \\n\\t  while(beg <= end){\\n        int mid = beg + (end - beg)/2;\\n        if(check(mid, h, piles)) {\\n          ans = mid;\\n          end = mid - 1;\\n        }\\n        else beg = mid + 1;\\n      }\\n      return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool check(int k, int h, vector<int> &piles){\\n      int count = 0;\\n      for(auto it : piles){\\n        count += it / k;\\n        if(it % k != 0) count++;\\n      }\\n      if(count <= h) return true;\\n      return false;\\n    }\\n  \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      int beg = 1, end = INT_MIN, ans;\\n      for(auto it : piles) if(it > end) end = it;\\n      \\n\\t  while(beg <= end){\\n        int mid = beg + (end - beg)/2;\\n        if(check(mid, h, piles)) {\\n          ans = mid;\\n          end = mid - 1;\\n        }\\n        else beg = mid + 1;\\n      }\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 887786,
                "title": "java-binary-search-w-detailed-explanation",
                "content": "```\\n/* \\n1. Implement findMax(int[] piles) method to find the max amount of banana in a pile and assign it to - int R as the rightmost value;\\n    1.1 Define your search space as : [1,2,3,4,5 ... R], since R is the maximum amount of bananas Koko can eat during 1 hour period\\n\\n2. After you have your search space we will perform Binary Search to find the minimum satisfactory K.\\n    2.1 Implement boolean canEatUnderH(int[] piles, int H, int K) method to find out whether K <= H to eat all bananas.\\n    2.2 For [3,6,7,11] search space is   [1,2,3,4,5,6,7,8,9,10,11]\\n\\t\\t2.2.1 F = false, T = true:       [F,F,F,T,T,T,T,T,T,T,T,T] with this intuition we need to return the leftmost T value using Binary Search which is the answer\\n*/\\n\\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int L = 1, R = findMax(piles);\\n        \\n        while(L < R) {\\n            int M = L + (R-L)/2;\\n            if(canEatUnderH(piles,H,M))\\n                R = M;\\n            else\\n                L = M+1;\\n        }\\n        \\n        return R;       \\n    }\\n    private int findMax(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num : nums)\\n            max = Math.max(max, num);\\n\\n        return max;            \\n    }\\n    \\n    public boolean canEatUnderH(int[] piles, int H, int K) {\\n        int time = 0;\\n        for (int p: piles)\\n            time += (p-1) / K + 1;\\n        return time <= H;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\n1. Implement findMax(int[] piles) method to find the max amount of banana in a pile and assign it to - int R as the rightmost value;\\n    1.1 Define your search space as : [1,2,3,4,5 ... R], since R is the maximum amount of bananas Koko can eat during 1 hour period\\n\\n2. After you have your search space we will perform Binary Search to find the minimum satisfactory K.\\n    2.1 Implement boolean canEatUnderH(int[] piles, int H, int K) method to find out whether K <= H to eat all bananas.\\n    2.2 For [3,6,7,11] search space is   [1,2,3,4,5,6,7,8,9,10,11]\\n\\t\\t2.2.1 F = false, T = true:       [F,F,F,T,T,T,T,T,T,T,T,T] with this intuition we need to return the leftmost T value using Binary Search which is the answer\\n*/\\n\\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int L = 1, R = findMax(piles);\\n        \\n        while(L < R) {\\n            int M = L + (R-L)/2;\\n            if(canEatUnderH(piles,H,M))\\n                R = M;\\n            else\\n                L = M+1;\\n        }\\n        \\n        return R;       \\n    }\\n    private int findMax(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int num : nums)\\n            max = Math.max(max, num);\\n\\n        return max;            \\n    }\\n    \\n    public boolean canEatUnderH(int[] piles, int H, int K) {\\n        int time = 0;\\n        for (int p: piles)\\n            time += (p-1) / K + 1;\\n        return time <= H;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377681,
                "title": "c-accepted-dull-brute-force-solution",
                "content": "The only solution I could come up with in a reasonable interview time is a brute force approach:\\n* choose starting eating speed better than 1, so we don\\'t get a TLE (how Koko can eat so many bananas per hour???);\\n* repeatedly increment the eating speed until Koko can eat all bananas within `H` hours range;\\n\\nIt is a bit ugly compared to the binary search solution, but it is accepted and *98.21%* faster than other solutions (which was strange for me). But I guess Koko would have needed to visit a doctor after such eating approach.\\n\\n```\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        // Determine the starting eating speed of Koko\\n        // There are no lower eating speed than the average speed,\\n        // because if it was a case, we will not be able to finish all piles within H hours.\\n        double sum = 0.;\\n        for (auto pile : piles) {\\n            sum += pile;\\n        }\\n        int speed = ceil(sum / H);\\n        \\n        // Continuously increment the speed by 1 until\\n        // Koko can eat all bananas within H hours range\\n        while (true) {\\n            int hours = 0;\\n            for (auto pile : piles) {\\n                hours += ceil(double(pile) / speed);\\n                if (hours > H) {\\n                    break;\\n                }\\n            }\\n            \\n            if (hours <= H) {\\n                break;\\n            }\\n            ++speed;\\n        }\\n        return speed;\\n    }\\n```\\n\\nP.S.: RIP Koko... :\\'(",
                "solutionTags": [],
                "code": "```\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        // Determine the starting eating speed of Koko\\n        // There are no lower eating speed than the average speed,\\n        // because if it was a case, we will not be able to finish all piles within H hours.\\n        double sum = 0.;\\n        for (auto pile : piles) {\\n            sum += pile;\\n        }\\n        int speed = ceil(sum / H);\\n        \\n        // Continuously increment the speed by 1 until\\n        // Koko can eat all bananas within H hours range\\n        while (true) {\\n            int hours = 0;\\n            for (auto pile : piles) {\\n                hours += ceil(double(pile) / speed);\\n                if (hours > H) {\\n                    break;\\n                }\\n            }\\n            \\n            if (hours <= H) {\\n                break;\\n            }\\n            ++speed;\\n        }\\n        return speed;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155546,
                "title": "python-binary-search-100",
                "content": "```\\nhi, lo = math.ceil(sum(piles) / (H - len(piles) + 1)), math.floor(sum(piles) / H)\\nwhile hi - lo > 1:\\n\\t\\tmd = (hi + lo) // 2\\n\\t\\th = sum(math.ceil(pile / md) for pile in piles)\\n\\t\\tif h > H:\\n\\t\\t\\t\\tlo = md\\n\\t\\telse:\\n\\t\\t\\t\\thi = md\\nreturn hi\\n```\\nFirst I use too wide lower and upper bound, which causes much time.\\nHowever, image the best case is that all elements are the same, and the lower bound is actually math.floor(sum(piles) / H)\\nAlso, the worst case is like [1,1,1,...,big_num], then the upper bound should be math.ceil(sum(piles) / (H - len(piles) + 1)).",
                "solutionTags": [],
                "code": "```\\nhi, lo = math.ceil(sum(piles) / (H - len(piles) + 1)), math.floor(sum(piles) / H)\\nwhile hi - lo > 1:\\n\\t\\tmd = (hi + lo) // 2\\n\\t\\th = sum(math.ceil(pile / md) for pile in piles)\\n\\t\\tif h > H:\\n\\t\\t\\t\\tlo = md\\n\\t\\telse:\\n\\t\\t\\t\\thi = md\\nreturn hi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052057,
                "title": "java-solution-very-easy-to-understand",
                "content": "# Intuition\\nThe problem asks us to find the minimum eating speed that allows us to eat all the bananas within the given time limit. We can approach this problem using binary search.\\n\\n\\n# Approach\\nFind the maximum pile size in the given piles array. We can initialize a variable max to the minimum possible integer value and iterate over all the piles to update the max value if we find a larger pile.\\n\\nInitialize two variables start and end, where start is the minimum possible eating speed (1) and end is the maximum pile size.\\n\\nUse binary search to find the minimum eating speed. While start is less than end, perform the following steps:\\n\\n1. Calculate the middle eating speed mid using start + (end - start) / 2\\n\\n2. Use the koko function to calculate the total number of hours required to eat all the piles with the current eating speed mid. The koko function takes in the eating speed mid and the piles array as parameters. Inside the function, iterate over all the piles and calculate the number of hours required by dividing each pile size by the eating speed and rounding up using Math.ceil(). Add each calculated hours value to a variable sum.\\n\\n3. If the value of sum is greater than the given time h, it means that the eating speed is too low and we need to increase it. Update start to mid + 1.\\n\\n4. If the value of sum is less than or equal to h, it means that the eating speed is sufficient. In this case, update end to mid.\\n\\nAfter the binary search loop terminates, return the value of start as the minimum eating speed that allows us to eat all the piles within h hours.\\n# Complexity\\n- Time complexity:$$O(nlog(max-value-in-piles))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = Integer.MIN_VALUE;\\n        for (int pile : piles) {\\n            max = Math.max(max, pile);\\n        }\\n        int start = 1;\\n        int end =  max;\\n    \\n        while(start<end){\\n            int mid = start + (end-start) / 2;\\n            if(koko(mid,piles)>h){\\n                start = mid + 1;\\n          }\\n            else{\\n                end=mid;\\n            }\\n        }\\n        return start;\\n    }\\n\\n\\n    public int koko(long num, int[] arr){\\n    int sum = 0;\\n    for(int i = 0; i < arr.length; i++){\\n        sum += Math.ceil((double)arr[i]/num);\\n    }\\n    return sum;\\n}\\n\\n}\\n\\n\\n\\n```\\n\\nPS: Rip KOKO & Harambe, You will be missed.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = Integer.MIN_VALUE;\\n        for (int pile : piles) {\\n            max = Math.max(max, pile);\\n        }\\n        int start = 1;\\n        int end =  max;\\n    \\n        while(start<end){\\n            int mid = start + (end-start) / 2;\\n            if(koko(mid,piles)>h){\\n                start = mid + 1;\\n          }\\n            else{\\n                end=mid;\\n            }\\n        }\\n        return start;\\n    }\\n\\n\\n    public int koko(long num, int[] arr){\\n    int sum = 0;\\n    for(int i = 0; i < arr.length; i++){\\n        sum += Math.ceil((double)arr[i]/num);\\n    }\\n    return sum;\\n}\\n\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835079,
                "title": "binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfinding the range in which answer can exist. the maximum answer will be the maximum element present in the piles vector. it will be true when h = piles.size().\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing binary search to find the minimum possible answer in the range.creating another function to check wheather it is possible to eat all the bananas within the h hours.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nplease upvote\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(vector<int> piles, int mid, int h){\\n        long long hours = 0;\\n        for(int i = 0; i < piles.size() ; i++){\\n            hours += piles[i]/mid;\\n            piles[i] %= mid;\\n            if(piles[i] > 0) hours++;\\n            if(hours > h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int min = 1;\\n        int max = *max_element(piles.begin(),piles.end());\\n        int ans = 0;\\n        while(min <= max){\\n            int mid = (min + max)/2;\\n            if(possible(piles,mid,h)){\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else{\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<int> piles, int mid, int h){\\n        long long hours = 0;\\n        for(int i = 0; i < piles.size() ; i++){\\n            hours += piles[i]/mid;\\n            piles[i] %= mid;\\n            if(piles[i] > 0) hours++;\\n            if(hours > h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int min = 1;\\n        int max = *max_element(piles.begin(),piles.end());\\n        int ans = 0;\\n        while(min <= max){\\n            int mid = (min + max)/2;\\n            if(possible(piles,mid,h)){\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else{\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685871,
                "title": "w-explanation-easy-binary-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse binary search to find the minimum eating speed that allows finishing within a given time constraint.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code defines a class with two functions. The \"eating\" function calculates the total number of hours required to eat piles of food at a given eating speed, taking into account the ceiling function for rounding up. The \"minEatingSpeed\" function uses binary search to find the minimum eating speed that allows all the piles to be consumed within a given time constraint. It initializes left and right pointers based on the time constraint and the maximum pile size. It iteratively updates the pointers until they converge, checking if the current eating speed allows completion within the time constraint. The function returns the minimum eating speed found.\\n\\nOne Testcase:\\n```\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\n823855818\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N log M), where N is the size of the piles vector and M is the maximum element in the piles vector. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\nPlease turn on english subtitles if necessary:\\n[https://www.youtube.com/watch?v=KtZOZ4E1zww](https://www.youtube.com/watch?v=KtZOZ4E1zww)\\n\\n![Cpp\\u89E3Leetcode 875 Koko\\u5403\\u9999\\u8549\\u7528\\u4E8C\\u5143\\u641C\\u5C0B .jpg](https://assets.leetcode.com/users/images/4c3d2eb9-0941-42b5-9827-09bcdf9aa6a3_1680431481.2523654.jpeg)\\n\\nUse trick to compute the ceiling function which is used in the code several times\\n```\\n(p+(k-1))/k; // (int)ceil((double)p/k)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eating(vector<int>& piles, int k){\\n        int sum=0;\\n        for(int p: piles)\\n            sum+=(p+(k-1))/k; // Calculate the number of hours needed to eat each pile, rounding up using the ceiling function\\n        return sum;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        long long left=h-1; // Initialize the left pointer as h-1\\n\\n        //the following is in fact left=ceil(average(piles))\\n        left=accumulate(piles.begin(), piles.end(), left)/h; // Calculate the average eating speed required, rounding up using the ceiling function\\n\\n        int right=*max_element(piles.begin(),piles.end()); // Initialize the right pointer as the maximum element in the piles vector\\n        \\n        while(left<right) // Perform binary search until left and right pointers meet\\n        {\\n            int&& mid=(left+right)/2; // Calculate the middle pointer\\n            \\n            if (eating(piles, mid)<=h) // If eating at the middle speed allows us to finish within h hours\\n                right=mid; // Update the right pointer to mid\\n            else\\n                left=mid+1; // Update the left pointer to mid+1\\n        }\\n        \\n        return right; // Return the minimum eating speed\\n    }\\n};\\n\\n```\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\n823855818\\n```\n```\\n(p+(k-1))/k; // (int)ceil((double)p/k)\\n```\n```\\nclass Solution {\\npublic:\\n    int eating(vector<int>& piles, int k){\\n        int sum=0;\\n        for(int p: piles)\\n            sum+=(p+(k-1))/k; // Calculate the number of hours needed to eat each pile, rounding up using the ceiling function\\n        return sum;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        long long left=h-1; // Initialize the left pointer as h-1\\n\\n        //the following is in fact left=ceil(average(piles))\\n        left=accumulate(piles.begin(), piles.end(), left)/h; // Calculate the average eating speed required, rounding up using the ceiling function\\n\\n        int right=*max_element(piles.begin(),piles.end()); // Initialize the right pointer as the maximum element in the piles vector\\n        \\n        while(left<right) // Perform binary search until left and right pointers meet\\n        {\\n            int&& mid=(left+right)/2; // Calculate the middle pointer\\n            \\n            if (eating(piles, mid)<=h) // If eating at the middle speed allows us to finish within h hours\\n                right=mid; // Update the right pointer to mid\\n            else\\n                left=mid+1; // Update the left pointer to mid+1\\n        }\\n        \\n        return right; // Return the minimum eating speed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272560,
                "title": "fastest-dart-solution-binary-search-wow-o-n-logn",
                "content": "# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minEatingSpeed(List<int> piles, int h) {\\n      int minK = 1;\\n      int maxK = piles.reduce(max);\\n\\n      while(minK <= maxK) {\\n          int middle = (minK + maxK) ~/ 2;\\n\\n          //count hours\\n          int hours = 0;\\n          for (int pile in piles ) {\\n              hours += pile ~/ middle;\\n              hours += pile % middle == 0 ? 0 : 1;\\n          }\\n          \\n          if (hours <= h) {\\n              maxK = middle - 1;\\n          }\\n          else {\\n              minK = middle + 1;\\n          }\\n      }\\n\\n      return minK;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minEatingSpeed(List<int> piles, int h) {\\n      int minK = 1;\\n      int maxK = piles.reduce(max);\\n\\n      while(minK <= maxK) {\\n          int middle = (minK + maxK) ~/ 2;\\n\\n          //count hours\\n          int hours = 0;\\n          for (int pile in piles ) {\\n              hours += pile ~/ middle;\\n              hours += pile % middle == 0 ? 0 : 1;\\n          }\\n          \\n          if (hours <= h) {\\n              maxK = middle - 1;\\n          }\\n          else {\\n              minK = middle + 1;\\n          }\\n      }\\n\\n      return minK;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272122,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles[0];\\n        for(int i = 0;i<piles.length;i++){\\n            r=Math.max(r,piles[i]);\\n        }\\n        \\n        int m;        \\n        int ans = -1;\\n        while(l<=r){\\n            m = (l+r)/2; \\n            if(check(piles, h,m)){\\n                r = m-1;\\n                ans = m;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean check(int[] piles, int h, int k){\\n        if(k ==0)return false;\\n        int i = 0;\\n        while(h>=0 && i<piles.length){\\n\\n            h -=Math.ceil((double)piles[i]/k);\\n            i++;\\n        }\\n        return (h>=0 && i == piles.length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles[0];\\n        for(int i = 0;i<piles.length;i++){\\n            r=Math.max(r,piles[i]);\\n        }\\n        \\n        int m;        \\n        int ans = -1;\\n        while(l<=r){\\n            m = (l+r)/2; \\n            if(check(piles, h,m)){\\n                r = m-1;\\n                ans = m;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean check(int[] piles, int h, int k){\\n        if(k ==0)return false;\\n        int i = 0;\\n        while(h>=0 && i<piles.length){\\n\\n            h -=Math.ceil((double)piles[i]/k);\\n            i++;\\n        }\\n        return (h>=0 && i == piles.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271457,
                "title": "detailed-step-by-step-explanation-java-python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this problem is that we need to find the minimum possible value of K (the eating speed) that will allow us to eat all the bananas in the given piles within H hours. One possible approach to finding the minimum value of K is to use binary search, because the search space (the range of possible values of K) is continuous and can be divided in half at each step, making binary search a good candidate for finding the minimum value efficiently.\\n\\nTo use binary search, we need to define a valid function that will check whether a particular value of K is valid, i.e., whether we can eat all the bananas in the given piles within H hours using that value of K. The valid function needs to iterate over all the piles and calculate the total number of hours required to eat all the bananas using the given value of K. If the total number of hours is less than or equal to H, then the value of K is valid, otherwise it is not valid.\\n\\nOnce we have a valid function, we can use binary search to find the minimum valid value of K. We start with the range of possible values of K (from 1 to the maximum number of bananas in the piles), and at each step we check the middle value of the range using the valid function. If the middle value is valid, then we narrow the range to the lower half of the current range, otherwise we narrow the range to the upper half of the current range. We repeat this process until we have narrowed the range to a single valid value, which is the minimum value of K that satisfies the given constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is binary search. The search is performed on the range of possible values for K, which is between 1 and the maximum number of bananas in any pile. The binary search is performed by repeatedly dividing the search range in half until the correct value of K is found. The blackbox method is used to check if a given K value is valid (i.e., Koko can eat all the bananas in H hours). If the given K value is too small, Koko cannot eat all the bananas in H hours and the search range is adjusted accordingly to the right. Conversely, if the given K value is too large, Koko can eat all the bananas in H hours and the search range is adjusted to the left.\\n\\nThe blackbox method calculates the number of hours it will take Koko to eat all the bananas in the piles using the given K value. This is done by iterating over each pile and dividing the number of bananas in the pile by K. The quotient gives the number of hours required to eat all the bananas in the pile. If there are any bananas left over (i.e., the pile size is not a multiple of K), one additional hour is required. The sum of the hours required for each pile gives the total number of hours required to eat all the bananas. If this total is less than or equal to H, the given K value is valid and the method returns true. Otherwise, the method returns false.\\n\\nThe maxBananas method simply iterates over all the piles to find the maximum number of bananas in any pile. This value is used as the upper bound for the binary search range.\\n\\nFinally, the minEatingSpeed method uses the binary search to find the minimum value of K such that Koko can eat all the bananas in the given piles within H hours. The method returns the minimum value of K.\\n# Explanation\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=maxBananas(piles);\\n```\\nThe minEatingSpeed method takes in an array `piles` representing the number of bananas in each pile and an integer `h` representing the maximum number of hours Koko has to eat all the bananas. The method returns the minimum positive integer `K` such that Koko can eat all the bananas in the given piles within h hours.\\n\\nThe method initializes `low` to 1, which represents the minimum possible value of `K`. It initializes `high` to the maximum number of bananas in any pile, which represents the maximum possible value of `K`.\\n```\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n```\\nThe method then enters a while loop which runs until `low` becomes greater than or equal to `high`. Inside the while loop, it calculates the midpoint `mid` of the current range of `K` values using the formula `(low + high) / 2`.\\n\\nIt then checks if the mid value is a valid value of K by calling the `blackbox` method. If the `mid` value is valid, it updates the value of `high` to `mid`. Otherwise, it updates the value of `low` to `mid + 1`.\\n\\nAfter the while loop exits, it returns the value of `low`, which is the minimum possible value of `K`.\\n```\\n    public boolean blackbox(int maxBananas,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxBananas;\\n            hours += time;\\n            if(i % maxBananas!=0) hours++;\\n        }\\n        if(hours <= h)\\n            return true;\\n        return false;\\n    }\\n```\\nThe `blackbox` method takes in a value `maxBananas`, which represents the value of `K` to be tested, the array `piles` representing the number of bananas in each pile, and the maximum number of hours `h` that Koko has to eat all the bananas.\\n\\nThe method calculates the number of hours it will take Koko to eat all the bananas using the given `maxBananas` value. This is done by iterating over each pile and dividing the number of bananas in the pile by `maxBananas`. The quotient gives the number of hours required to eat all the bananas in the pile. If there are any bananas left over (i.e., the pile size is not a multiple of maxBananas), one additional hour is required. The sum of the hours required for each pile gives the total number of hours required to eat all the bananas.\\n\\nIf this total is less than or equal to `h`, the method returns `true`, indicating that the given `maxBananas` value is a valid value of `K`. Otherwise, the method returns `false`.\\n```\\n    public int maxBananas (int[] piles){\\n        int maxBananas = 0;\\n        for(int i=0;i<piles.length;i++){\\n            maxBananas=Math.max(maxBananas,piles[i]);\\n        }\\n        return maxBananas;\\n    }\\n}\\n```\\nThe `maxBananas` method takes in an array `piles` representing the number of bananas in each pile. It iterates over all the `piles` to find the maximum bananas in the pile.\\n\\n# Complexity\\n- Time complexity:      $$O(N log M)$$,\\n where N is the number of piles and M is the maximum number of bananas in a pile. This is because the method uses binary search to search for the minimum possible value of K, and each iteration of the binary search takes O(N) time to check whether a particular value of K is valid using the blackbox method, which itself takes O(N) time to iterate over all the piles.\\nThe time complexity of the `maxBananas` method is O(N), where N is the number of piles, because the method needs to iterate over all the piles to find the maximum number of bananas.\\nThe time complexity of the `blackbox` method is O(N), where N is the number of piles, because the method needs to iterate over all the piles to calculate the number of hours required to eat all the bananas using the given value of `K`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**$$O(1)$$**, \\nbecause the method only uses a constant amount of space to store the variables `low`, `high`, and `mid`.\\nThe space complexity of the `blackbox` method is O(1), because the method only uses a constant amount of space to store the variables `hours`, `time`, and `i`.\\nThe space complexity of the maxBananas method is O(1), because the method only uses a constant amount of space to store the variable maxBananas.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=maxBananas(piles);\\n        \\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(int maxpiles,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxpiles;\\n            hours+=time;\\n            if(i%maxpiles!=0) hours++;\\n        }\\n        if(hours<=h)\\n            return true;\\n        return false;\\n    }\\n    public int maxBananas (int[] piles){\\n        int maxBananas = 0;\\n        for(int i=0;i<piles.length;i++){\\n            maxBananas=Math.max(maxBananas,piles[i]);\\n        }\\n        return maxBananas;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/be28e379-60ba-4216-9e2d-7d5e015313da_1678259451.250167.png)\\n\\n# Pyhton3\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        low,high,ans = 1,max(piles),0\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            hours = 0\\n            for p in piles:\\n                hours += ceil(p / mid)\\n            if hours <= h:\\n                ans = mid\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return ans\\n```\\n![image.png](https://assets.leetcode.com/users/images/0de9c636-e54c-4f3c-80da-8ba798d2ecbc_1678258936.6838865.png)\\n---\\n\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)\\n![image.png](https://assets.leetcode.com/users/images/f36a288e-bdb7-4264-b2d5-8d7275e29330_1678259367.2213438.png)\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=maxBananas(piles);\\n```\n```\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n```\n```\\n    public boolean blackbox(int maxBananas,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxBananas;\\n            hours += time;\\n            if(i % maxBananas!=0) hours++;\\n        }\\n        if(hours <= h)\\n            return true;\\n        return false;\\n    }\\n```\n```\\n    public int maxBananas (int[] piles){\\n        int maxBananas = 0;\\n        for(int i=0;i<piles.length;i++){\\n            maxBananas=Math.max(maxBananas,piles[i]);\\n        }\\n        return maxBananas;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low=1;\\n        int high=maxBananas(piles);\\n        \\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(blackbox(mid,piles,h)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(int maxpiles,int[] piles,int h){\\n        int hours=0;\\n        for(int i:piles){\\n            int time=i/maxpiles;\\n            hours+=time;\\n            if(i%maxpiles!=0) hours++;\\n        }\\n        if(hours<=h)\\n            return true;\\n        return false;\\n    }\\n    public int maxBananas (int[] piles){\\n        int maxBananas = 0;\\n        for(int i=0;i<piles.length;i++){\\n            maxBananas=Math.max(maxBananas,piles[i]);\\n        }\\n        return maxBananas;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        low,high,ans = 1,max(piles),0\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            hours = 0\\n            for p in piles:\\n                hours += ceil(p / mid)\\n            if hours <= h:\\n                ans = mid\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270892,
                "title": "well-explained-code-in-java",
                "content": "\\n\\n# Approach\\nThe solution uses a binary search algorithm to find the minimum possible value of k. The minEatingSpeed function takes in an integer array piles representing the number of bananas in each pile, and an integer h representing the maximum number of hours Koko can work per day.\\n\\nFirst, we find the maximum value in the piles array using a loop. This value will be the upper bound for our binary search.\\n\\nNext, we perform the binary search. We initialize lo to 0 and hi to max, and then repeatedly calculate the middle point sp between lo and hi. We call the isPossible function to check if it is possible for Koko to eat all the bananas at a rate of sp bananas per hour within h hours. If it is possible, we update speed to sp and move the upper bound hi to sp-1 to try to find a smaller value of k. If it is not possible, we move the lower bound lo to sp+1 to try to find a larger value of k.\\n\\nFinally, we return the value of speed, which will be the minimum value of k for which it is possible for Koko to eat all the bananas within h hours.\\n\\nThe isPossible function takes in the same arguments as minEatingSpeed and returns a boolean value indicating whether it is possible for Koko to eat all the bananas within h hours at a rate of sp bananas per hour. The implementation of isPossible is the same as the second implementation we discussed earlier.\\n\\n# Complexity\\n- Time complexity:\\nO(n log m), where n is the length of the piles array and m is the maximum value in the piles array. This is because we perform a binary search for the minimum possible value of k, and each iteration of the binary search takes O(n) time to call the isPossible function, which has a time complexity of O(n) due to the for loop. The binary search takes O(log m) iterations to converge to a single value, so the total time complexity is O(n log m).\\n\\n- Space complexity:\\nO(1), The minEatingSpeed function uses a constant amount of extra space, regardless of the size of the input.\\n\\n# Note\\n\\n```\\n// 1st method\\npublic boolean isPossible(int[]piles,int sp,int h){\\n    int time = 0;\\n    for(int i=0;i<piles.length;i++){\\n        time += (int)Math.ceil(piles[i]*1.0/sp);\\n    }\\n    return time<=h;\\n}\\n```\\n```\\n//2nd method\\npublic boolean isPossible(int[]piles,int sp,int h){\\n    int time = 0;\\n    for(int i=0;i<piles.length;i++){\\n        time += (int)Math.ceil(piles[i]*1.0/sp);\\n        if(time > h) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\\n\\nThe difference between the two methods is in the way they calculate the total time it takes for the monkey to finish eating all the bananas. The first method simply calculates the total time required to finish all the piles, and returns true if this time is less than or equal to the maximum allowed time h. The second method, on the other hand, calculates the time required to finish each pile individually, and checks at each step if the total time exceeds the maximum allowed time h. If it does, it immediately returns false, indicating that the monkey cannot finish eating all the bananas within the given time constraints.\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = Integer.MIN_VALUE;\\n        for(int val : piles){\\n            max = Math.max(val,max);\\n        }\\n        if(h==piles.length){\\n            return max;\\n        }\\n        int lo = 0;\\n        int hi = max;\\n        int speed = Integer.MAX_VALUE;\\n        while(lo<=hi){\\n            int sp = lo + (hi-lo)/2;\\n            if(isPossible(piles,sp,h)){\\n                speed = sp;\\n                hi = sp-1;\\n            }else{\\n                lo = sp+1;\\n            }\\n        }\\n        return speed;\\n    }\\n    public boolean isPossible(int[]piles,int sp,int h){\\n        int time = 0;\\n        for(int i=0;i<piles.length;i++){\\n            time += (int)Math.ceil(piles[i]*1.0/sp);\\n            if(time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/e0201d37-8f7b-4ffe-9b79-be1f9399d2ea_1678249742.4366345.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n// 1st method\\npublic boolean isPossible(int[]piles,int sp,int h){\\n    int time = 0;\\n    for(int i=0;i<piles.length;i++){\\n        time += (int)Math.ceil(piles[i]*1.0/sp);\\n    }\\n    return time<=h;\\n}\\n```\n```\\n//2nd method\\npublic boolean isPossible(int[]piles,int sp,int h){\\n    int time = 0;\\n    for(int i=0;i<piles.length;i++){\\n        time += (int)Math.ceil(piles[i]*1.0/sp);\\n        if(time > h) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = Integer.MIN_VALUE;\\n        for(int val : piles){\\n            max = Math.max(val,max);\\n        }\\n        if(h==piles.length){\\n            return max;\\n        }\\n        int lo = 0;\\n        int hi = max;\\n        int speed = Integer.MAX_VALUE;\\n        while(lo<=hi){\\n            int sp = lo + (hi-lo)/2;\\n            if(isPossible(piles,sp,h)){\\n                speed = sp;\\n                hi = sp-1;\\n            }else{\\n                lo = sp+1;\\n            }\\n        }\\n        return speed;\\n    }\\n    public boolean isPossible(int[]piles,int sp,int h){\\n        int time = 0;\\n        for(int i=0;i<piles.length;i++){\\n            time += (int)Math.ceil(piles[i]*1.0/sp);\\n            if(time > h) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105173,
                "title": "easy-c-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&piles,int speed){\\n        int time=0;        \\n        for(int i=0;i<piles.size();i++){\\n            time+=piles[i]/speed;\\n            if(piles[i]%speed>0)\\n                time++;\\n        }\\n        return time;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1;\\n        int r=*max_element(piles.begin(),piles.end());\\n        while(r>=l){\\n            int mid=l+(r-l)/2;            \\n            if(check(piles,mid)>h)\\n                l=mid+1;\\n            else\\n                r=mid-1;\\n        }   \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&piles,int speed){\\n        int time=0;        \\n        for(int i=0;i<piles.size();i++){\\n            time+=piles[i]/speed;\\n            if(piles[i]%speed>0)\\n                time++;\\n        }\\n        return time;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1;\\n        int r=*max_element(piles.begin(),piles.end());\\n        while(r>=l){\\n            int mid=l+(r-l)/2;            \\n            if(check(piles,mid)>h)\\n                l=mid+1;\\n            else\\n                r=mid-1;\\n        }   \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900110,
                "title": "c-easy-to-understand-tc-o-m-log-max-piles-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint minEatingSpeed(vector<int>& piles, int h) {\\n        int m=piles.size(), l=1,r=0;\\n        for(auto bananas: piles) r=max(r,bananas);\\n        \\n        int mid=0, ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0;\\n            for(auto bananas: piles){\\n                count+=bananas/mid;\\n                if(bananas%mid) count++;\\n            }\\n            if(count<=h) ans=mid,r=mid-1;\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\tint minEatingSpeed(vector<int>& piles, int h) {\\n        int m=piles.size(), l=1,r=0;\\n        for(auto bananas: piles) r=max(r,bananas);\\n        \\n        int mid=0, ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0;\\n            for(auto bananas: piles){\\n                count+=bananas/mid;\\n                if(bananas%mid) count++;\\n            }\\n            if(count<=h) ans=mid,r=mid-1;\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704403,
                "title": "hit-and-trail-approach-of-solving",
                "content": "class Solution {\\npublic:\\n    \\n \\n    \\n    vector<int>v;int limit;\\n\\t\\n\\t\\n\\t   //IS IT POSSIBLE TO EAT ALL BANANA WITH THIS SPEED\\n    bool solve(int speed)\\n    {\\n        int ans=0;\\n        for(int x:v)\\n        {\\n            //ceil of time\\n            ans+=(x/speed+(x%speed!=0));\\n        }\\n        \\n        if(ans<=limit)\\n            return true;\\n        else return false;\\n    \\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) \\n    {\\n        v=piles;\\n        limit=h;\\n        int l=1,r=INT_MIN;\\n        \\n        for(int x:piles)\\n        {\\n            r=max(r,x);\\n        }\\n        \\n        int res=-1;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            \\n            if(solve(m))\\n            {\\n             //YES IT IS POSSIBLE TO FINISH ALL THE BANANA WITH M SPEED   \\n                res=m;\\n                          \\n                //STILL GO ANY TRY IF IT IS POSSIBLE TO FINISH WITH ANY SMALLER SPEED\\n                r=m-1;\\n            }\\n            else\\n            {\\n                l=m+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n \\n    \\n    vector<int>v;int limit;\\n\\t\\n\\t\\n\\t   //IS IT POSSIBLE TO EAT ALL BANANA WITH THIS SPEED\\n    bool solve(int speed)\\n    {\\n        int ans=0;\\n        for(int x:v)\\n        {\\n            //ceil of time\\n            ans+=(x/speed+(x%speed!=0));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1075275,
                "title": "java-n-log-n-solution",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int maxSpeed = 0;\\n        int minSpeed = 1;\\n        for (int pile:piles)maxSpeed=Math.max(maxSpeed,pile);\\n        \\n        return binary(piles, H, minSpeed, maxSpeed);\\n    }\\n    \\n    public int binary(int[]piles, int H, int minSpeed, int maxSpeed){\\n        if (minSpeed==maxSpeed){\\n            if (canEatAll(piles, H, minSpeed))return minSpeed;\\n            else return minSpeed+1;\\n        };\\n        int middle = minSpeed + (maxSpeed - minSpeed)/2;\\n        if (canEatAll(piles, H, middle))return binary(piles, H, minSpeed, middle);\\n        else return binary(piles, H, middle+1, maxSpeed);\\n    }\\n    \\n    public boolean canEatAll(int[]piles, int H, int speed){\\n        for (int pile:piles)\\n            H-= pile/speed + (pile%speed==0?0:1);\\n        return H>=0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        int maxSpeed = 0;\\n        int minSpeed = 1;\\n        for (int pile:piles)maxSpeed=Math.max(maxSpeed,pile);\\n        \\n        return binary(piles, H, minSpeed, maxSpeed);\\n    }\\n    \\n    public int binary(int[]piles, int H, int minSpeed, int maxSpeed){\\n        if (minSpeed==maxSpeed){\\n            if (canEatAll(piles, H, minSpeed))return minSpeed;\\n            else return minSpeed+1;\\n        };\\n        int middle = minSpeed + (maxSpeed - minSpeed)/2;\\n        if (canEatAll(piles, H, middle))return binary(piles, H, minSpeed, middle);\\n        else return binary(piles, H, middle+1, maxSpeed);\\n    }\\n    \\n    public boolean canEatAll(int[]piles, int H, int speed){\\n        for (int pile:piles)\\n            H-= pile/speed + (pile%speed==0?0:1);\\n        return H>=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963720,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    bool isPossible(vector<int> &piles, int hours, int speed)\\n    {\\n      int count = 0;\\n      int n = piles.size();\\n      \\n      for(int i = 0; i < n; i++)\\n      {\\n//      If speed of eating banana in our hour is greter than or equal to  pile height, we just incremenet by the count by 1. because we know she can eat the complete pile in an hour\\n        if(piles[i] <= speed)\\n          count += 1;\\n        \\n//      Now we have a pile height of 11 and eating banana in every hour is 4, then we will take 4*2 hours to eat 8 bananas and (11 - 8) -> 3 bananas we can eat in one hour. so we can do piles[i]/speed + 1.\\n        \\n        else\\n        {\\n          count += (piles[i]/speed) + 1;\\n        }\\n      }\\n      \\n      return (count <= hours) ? true : false;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int H) \\n    {\\n      int low = 1;\\n//       we have taken this high because we want to get the minimum hour so we need to find the ceiling value\\n      int high = *max_element(piles.begin(), piles.end());\\n      \\n      while(low < high)\\n      {\\n        int mid = low + (high - low)/2;\\n        \\n        if(isPossible(piles, H, mid))\\n        {\\n          high = mid;\\n        } else {\\n          low = mid + 1;\\n        }\\n      }\\n      \\n      return low;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    bool isPossible(vector<int> &piles, int hours, int speed)\\n    {\\n      int count = 0;\\n      int n = piles.size();\\n      \\n      for(int i = 0; i < n; i++)\\n      {\\n//      If speed of eating banana in our hour is greter than or equal to  pile height, we just incremenet by the count by 1. because we know she can eat the complete pile in an hour\\n        if(piles[i] <= speed)\\n          count += 1;\\n        \\n//      Now we have a pile height of 11 and eating banana in every hour is 4, then we will take 4*2 hours to eat 8 bananas and (11 - 8) -> 3 bananas we can eat in one hour. so we can do piles[i]/speed + 1.\\n        \\n        else\\n        {\\n          count += (piles[i]/speed) + 1;\\n        }\\n      }\\n      \\n      return (count <= hours) ? true : false;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int H) \\n    {\\n      int low = 1;\\n//       we have taken this high because we want to get the minimum hour so we need to find the ceiling value\\n      int high = *max_element(piles.begin(), piles.end());\\n      \\n      while(low < high)\\n      {\\n        int mid = low + (high - low)/2;\\n        \\n        if(isPossible(piles, H, mid))\\n        {\\n          high = mid;\\n        } else {\\n          low = mid + 1;\\n        }\\n      }\\n      \\n      return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152338,
                "title": "binary-search-with-optimized-runtime",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        Arrays.sort(piles);\\n        long total = 0;\\n        for(int pile : piles) total += pile;\\n        int min = (int)Math.ceil(total/(double)H);\\n        int max = piles[piles.length - 1];\\n        while (min < max){\\n            if (canFinish(piles, min, H)) return min;\\n            if (canFinish(piles, (min + max) / 2, H)) max = (min + max)/2;\\n            else min = (min + max) / 2 + 1;\\n        }\\n        return (int)min;\\n    }\\n    \\n    \\n    private boolean canFinish(int[] piles, int speed, int target){\\n        long counter = 0;\\n        for (int pile : piles){\\n            counter += Math.ceil(pile / (double)speed);\\n        }\\n        return (int)counter <= target;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        Arrays.sort(piles);\\n        long total = 0;\\n        for(int pile : piles) total += pile;\\n        int min = (int)Math.ceil(total/(double)H);\\n        int max = piles[piles.length - 1];\\n        while (min < max){\\n            if (canFinish(piles, min, H)) return min;\\n            if (canFinish(piles, (min + max) / 2, H)) max = (min + max)/2;\\n            else min = (min + max) / 2 + 1;\\n        }\\n        return (int)min;\\n    }\\n    \\n    \\n    private boolean canFinish(int[] piles, int speed, int target){\\n        long counter = 0;\\n        for (int pile : piles){\\n            counter += Math.ceil(pile / (double)speed);\\n        }\\n        return (int)counter <= target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882285,
                "title": "optimal-solution-using-binary-search",
                "content": "\\n\\n# Approach\\n- The maxEl function finds the maximum number of bananas in any pile. This value is used as the upper bound for the binary search.\\n\\n- The totalHours function calculates the total hours needed to finish eating all piles at a given eating speed \"hrs\". It uses the formula (piles[i] + hrs - 1) / hrs to perform ceiling division for each pile.\\n\\n- The minEatingSpeed function employs binary search to find the minimum eating speed \"k\". The search range is between 1 (minimum possible speed) and the maximum number of bananas in a pile. The loop narrows down the range by checking if the total hours needed at the current eating speed \"mid\" are within the allowed time \"h\".\\n\\n- The binary search continues until the low and high bounds cross each other. The result is the minimum eating speed \"k\" that allows Koko to finish eating all bananas within the given time \"h\".\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxEl(vector<int>& piles) {\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < piles.size(); i++){\\n            maxi = max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    long long totalHours(vector<int>& piles, int hrs) {\\n        long long total = 0;\\n        for(int i = 0; i < piles.size(); i++) {\\n            total += (piles[i] + hrs - 1) / hrs; \\n        }\\n        return total;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 1, high = maxEl(piles);\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            long long total = totalHours(piles, mid);\\n            if(total <= h) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public int maxEl(int[] piles) {\\n        int maxi = Integer.MIN_VALUE;\\n        for (int i = 0; i < piles.length; i++) {\\n            maxi = Math.max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    public long totalHours(int[] piles, int hrs) {\\n        long total = 0;\\n        for (int i = 0; i < piles.length; i++) {\\n            total += (piles[i] + hrs - 1) / hrs; // Ceiling division\\n        }\\n        return total;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1, high = maxEl(piles);\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            long total = totalHours(piles, mid);\\n            if (total <= h) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxEl(vector<int>& piles) {\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < piles.size(); i++){\\n            maxi = max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    long long totalHours(vector<int>& piles, int hrs) {\\n        long long total = 0;\\n        for(int i = 0; i < piles.size(); i++) {\\n            total += (piles[i] + hrs - 1) / hrs; \\n        }\\n        return total;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 1, high = maxEl(piles);\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            long long total = totalHours(piles, mid);\\n            if(total <= h) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public int maxEl(int[] piles) {\\n        int maxi = Integer.MIN_VALUE;\\n        for (int i = 0; i < piles.length; i++) {\\n            maxi = Math.max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    public long totalHours(int[] piles, int hrs) {\\n        long total = 0;\\n        for (int i = 0; i < piles.length; i++) {\\n            total += (piles[i] + hrs - 1) / hrs; // Ceiling division\\n        }\\n        return total;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1, high = maxEl(piles);\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            long total = totalHours(piles, mid);\\n            if (total <= h) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606500,
                "title": "optimized-bounds-binary-search-python3-solution",
                "content": "# Optimized Bounds + Binary Search\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIn addition to the binary search solution, I also added an optimization at the beginning to find the bounds of where k could be. This should be better than the posted solutions, since it\\'s able to find the bounds in O(nlog(n)), which is equivalent to the modified BS and can severely cut down on the starting space that\\'s checked, more than doubling the % beat from 35% to 80%\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = 1\\n        hours_taken = sum(piles)\\n        while hours_taken > h:\\n            k *= 2\\n            hours_taken = sum([math.ceil(p / k) for p in piles])\\n        if k == 1:\\n            return k\\n\\n        l = k/2\\n        while l < k:\\n            mid = (l + k) // 2\\n            val = sum([math.ceil(p / mid) for p in piles])\\n\\n            if val <= h:\\n                k = mid\\n            else:\\n                l = mid + 1\\n        return int(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        k = 1\\n        hours_taken = sum(piles)\\n        while hours_taken > h:\\n            k *= 2\\n            hours_taken = sum([math.ceil(p / k) for p in piles])\\n        if k == 1:\\n            return k\\n\\n        l = k/2\\n        while l < k:\\n            mid = (l + k) // 2\\n            val = sum([math.ceil(p / mid) for p in piles])\\n\\n            if val <= h:\\n                k = mid\\n            else:\\n                l = mid + 1\\n        return int(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551930,
                "title": "c-delight-easy-and-understandable-solution-for-koko-s-banana-munching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to find the minimum eating speed (Koko\\'s eating speed) required for Koko to eat all the bananas within a given time limit. To solve this, we can use binary search to find the minimum eating speed. We know that Koko can only eat one pile at a time, so the eating speed should be such that Koko can finish eating all the piles within the given time limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a helper function \\'tym\\' that takes the piles vector and a mid value as parameters. This function calculates the total time required for Koko to eat all the piles with the given eating speed mid.\\n2. Inside the \\'tym\\' function, initialize a variable sum to keep track of the total time.\\n3. Iterate through each pile in the piles vector.\\n- Divide the current pile by mid to get the number of times Koko needs to eat that pile.\\n- If there is any remainder (pile % mid != 0), increment the count by 1 because Koko needs to eat an extra time to finish the remaining bananas.\\n- Add the count to the sum variable.\\n4. Return the sum.\\n5. In the minEatingSpeed function:\\n - Initialize variables l and r to 1 and the maximum element in the piles vector, respectively.\\n - Initialize ans to 0, which will store the minimum eating speed.\\n - Use a while loop with the condition l <= r to perform binary search.\\n - Calculate the middle value mid using the formula l + (r - l) / 2.\\n- Call the tym function with the piles vector and mid to get the total time required.\\n- If the total time is less than or equal to the given time limit H:\\n-Update ans to the current mid value.\\n-Update r to mid - 1 to search for a smaller eating speed.\\n- Else:\\n-Update l to mid + 1 to search for a larger eating speed.\\n- Repeat the loop until l becomes greater than r.\\n6. Return ans, which will be the minimum eating speed required for Koko.\\n\\n\\n# Complexity\\n- Time complexity:O(n * log(max_piles))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\n    long long int tym(vector<int>&piles,int mid)\\n    {\\n        long long sum = 0; \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum+=(piles[i]/mid)+((piles[i]%mid)!=0);\\n        }\\n        return sum;\\n    }   \\n    public:\\n    int minEatingSpeed(vector<int>& piles, int H) \\n    {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int l = 1;\\n        int r;\\n        r = *max_element(piles.begin(), piles.end());\\n        int ans = 0;\\n        while(l <= r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            long long int time = tym(piles,mid);\\n\\t\\t\\t\\n                if (time <= H)\\n                {\\n                    ans = mid;\\n                    r = mid - 1;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution { \\n    long long int tym(vector<int>&piles,int mid)\\n    {\\n        long long sum = 0; \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum+=(piles[i]/mid)+((piles[i]%mid)!=0);\\n        }\\n        return sum;\\n    }   \\n    public:\\n    int minEatingSpeed(vector<int>& piles, int H) \\n    {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int l = 1;\\n        int r;\\n        r = *max_element(piles.begin(), piles.end());\\n        int ans = 0;\\n        while(l <= r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            long long int time = tym(piles,mid);\\n\\t\\t\\t\\n                if (time <= H)\\n                {\\n                    ans = mid;\\n                    r = mid - 1;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3273559,
                "title": "happy-holi-easy-c-solution",
                "content": "\\n# Code\\nAttempted this question after a fun and tiring day, happy to solve within 15mins....Happy Holi\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int s=1,e=1e9;\\n        int n=piles.size();\\n        while(s<=e){\\n            long long hours=0;\\n            int mid=(s+e)/2;\\n            for(int i=0;i<n;i++){\\n                if(piles[i]%mid==0){\\n                    hours+=(piles[i]/mid);\\n                }\\n                else{\\n                    int x=piles[i]/mid;\\n                    x++;\\n                    hours+=x;\\n                }\\n            }\\n            if(hours<=h){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int s=1,e=1e9;\\n        int n=piles.size();\\n        while(s<=e){\\n            long long hours=0;\\n            int mid=(s+e)/2;\\n            for(int i=0;i<n;i++){\\n                if(piles[i]%mid==0){\\n                    hours+=(piles[i]/mid);\\n                }\\n                else{\\n                    int x=piles[i]/mid;\\n                    x++;\\n                    hours+=x;\\n                }\\n            }\\n            if(hours<=h){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273376,
                "title": "c-fully-explained-binary-search",
                "content": "```\\n// #google, #amazon, #Airbnb, #FaceBook\\n\\n/*\\nIntution : Binary Search\\n1. By understading the question we know there will always possible ans so we do not have to worry about the case when he is not able to eat all the banana\\'s\\n2. If we take the maximum piles from piles array and set the speed as maximum in the piles array then for every index Koko need only 1 hr to finish the bananas at that index, we also know koko give atleast 1 hr at every index to eat banana(bananas can be 1 -> 10^9)\\n3. So for Binary search our lowSpeed = 1, and highSpeed = max(piles_array)\\n4. Then we approach this question via binary search and at every iteration of Binary search we have to check weather koko can eat banana at that speed: there are two case:\\n    Case 1:  if koko can eat all banana within h hr at that speed then this can be out possible answer so we have to store it and check for lower speed if there could possible with lower speed as well ( high = mid - 1)\\n    case2 : If koko can\\'t eat all banana within h hr then we have to check for higher speed ( low = mid+1)\\n5. isPossible funtion is simple just check if koko can finish the banana within the h hr at specific speed it returns true of false which will evaluated at main function\\nIf you rreally finds my solution usefull then please do upvote\\n */\\n/* ====>>> Solution for Leetcode <<<=====  */\\nclass Solution\\n{\\npublic:\\n    bool isPossible(vector<int> &piles, int speed, int h)\\n    {\\n        long long count = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            count += ceil(piles[i] / (double)speed);\\n        }\\n        return count <= h;\\n    }\\n\\n    int minEatingSpeed(vector<int> &piles, int h)\\n    {\\n        int low = 1, high = INT_MIN;\\n        for (int i = 0; i < piles.size(); i++)\\n            high = max(high, piles[i]);\\n        int ans = INT_MAX;\\n        while (low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (isPossible(piles, mid, h))\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n// #google, #amazon, #Airbnb, #FaceBook\\n\\n/*\\nIntution : Binary Search\\n1. By understading the question we know there will always possible ans so we do not have to worry about the case when he is not able to eat all the banana\\'s\\n2. If we take the maximum piles from piles array and set the speed as maximum in the piles array then for every index Koko need only 1 hr to finish the bananas at that index, we also know koko give atleast 1 hr at every index to eat banana(bananas can be 1 -> 10^9)\\n3. So for Binary search our lowSpeed = 1, and highSpeed = max(piles_array)\\n4. Then we approach this question via binary search and at every iteration of Binary search we have to check weather koko can eat banana at that speed: there are two case:\\n    Case 1:  if koko can eat all banana within h hr at that speed then this can be out possible answer so we have to store it and check for lower speed if there could possible with lower speed as well ( high = mid - 1)\\n    case2 : If koko can\\'t eat all banana within h hr then we have to check for higher speed ( low = mid+1)\\n5. isPossible funtion is simple just check if koko can finish the banana within the h hr at specific speed it returns true of false which will evaluated at main function\\nIf you rreally finds my solution usefull then please do upvote\\n */\\n/* ====>>> Solution for Leetcode <<<=====  */\\nclass Solution\\n{\\npublic:\\n    bool isPossible(vector<int> &piles, int speed, int h)\\n    {\\n        long long count = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            count += ceil(piles[i] / (double)speed);\\n        }\\n        return count <= h;\\n    }\\n\\n    int minEatingSpeed(vector<int> &piles, int h)\\n    {\\n        int low = 1, high = INT_MIN;\\n        for (int i = 0; i < piles.size(); i++)\\n            high = max(high, piles[i]);\\n        int ans = INT_MAX;\\n        while (low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (isPossible(piles, mid, h))\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272708,
                "title": "explained-clearly-with-intuition-and-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question wants us to find the minimum rate `h` _(bananas/hour)_ for which Koko consumes all the bananas before the guard arrives.\\n\\n_PS: The guards are useless LOL!_\\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy analyzing the searching space and constraints, we can say that `Binary Search` will be an efficient approach for this. Because for Linear search, it\\'ll definitely throw TLE.\\n\\n- Step 1: For Binary Search, we requires a range. Guess what, this is the initial mindstorming part. Minimum rate in which Koko can consume bananas is 1 and maximum is the maximum_element of the piles array.\\n- Now lets begin the BS, finding mid, checking the hours for the mid rate. If it results in more than `h` hours then Koko will be busted by the guards. So what? Then we will have to reduce our serching space by shifting our focus to the right array. Otherwise we will be using the left array.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int left = 1, right = piles[piles.size()-1];\\n\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            long long int hours = 0;\\n\\n            for(auto x:piles){\\n                hours+= x/mid;\\n                if(x%mid!=0) hours++;\\n            }\\n\\n            if(hours<=h) right = mid-1;\\n            else left = mid+1;\\n        }\\n\\n        return left;\\n    }\\n};\\n```\\n---\\n_If you have any doubts, feel free to ask in the comment section.\\nAnd if you have find optimizations in my solution, do let me know._\\n\\n[Lets connect on LinkedIn](https://www.linkedin.com/in/priyanshu-choudhary-techgeek/)\\n\\nPLEASE MAKE SURE TO UPVOTE THE SOLUTION AS IT GIVES ME MOTIVATION TO DO MORE.\\n\\n---\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/65eeb207-f2a9-4d1b-9d13-2c8573d657ed_1677603105.5077243.png\" alt=\"\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int left = 1, right = piles[piles.size()-1];\\n\\n        while(left<=right){\\n            int mid = left + (right-left)/2;\\n            long long int hours = 0;\\n\\n            for(auto x:piles){\\n                hours+= x/mid;\\n                if(x%mid!=0) hours++;\\n            }\\n\\n            if(hours<=h) right = mid-1;\\n            else left = mid+1;\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272664,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long timetaken(vector<int>& piles, int k)\\n    {\\n        long long ans=0;\\n        for (int i=0; i<piles.size(); i++){\\n            ans+= (piles[i]/k)+(piles[i]%k!=0);\\n        }\\n        return ans;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h)\\n     {\\n        int low=1; int high= *max_element(piles.begin(),piles.end());\\n        while (low <= high)\\n        {\\n            int mid= low+ (high-low)/2;\\n            if (timetaken(piles,mid)<=h)\\n            {\\n                high= mid-1;\\n            }\\n            else low= mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long timetaken(vector<int>& piles, int k)\\n    {\\n        long long ans=0;\\n        for (int i=0; i<piles.size(); i++){\\n            ans+= (piles[i]/k)+(piles[i]%k!=0);\\n        }\\n        return ans;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h)\\n     {\\n        int low=1; int high= *max_element(piles.begin(),piles.end());\\n        while (low <= high)\\n        {\\n            int mid= low+ (high-low)/2;\\n            if (timetaken(piles,mid)<=h)\\n            {\\n                high= mid-1;\\n            }\\n            else low= mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272567,
                "title": "easy-binary-search-approach-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the *piles* array then find the left index which will be the minimum number of banana to be eaten i.e(1), then find the right index which will be the maximum number of banana to be eaten which will be the last element of the array.\\nNow we have the range of our answer, use binary search to find our answer quickly. For this use a sum variable and a mid variable , where mid = (right-left)/2+left and sum contains piles[i]/mid and if there is a remainder then add 1. Then use the condition if else which is provided in the code.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        Arrays.sort(piles);\\n        int left = 1;\\n        int right = piles[piles.length-1];\\n        while(left <= right){\\n            long sum = 0;\\n            int mid = (right-left)/2+left;\\n            for(int i = 0 ; i < piles.length ;i++){\\n                sum += piles[i]/mid;\\n                if(piles[i]%mid> 0){\\n                    sum++;\\n                }\\n            }\\n            if(sum > h){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\nHaving doubts in understanding the approach then feel free to ask in the comment section.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg\" alt=\"\">\\n</p>\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        Arrays.sort(piles);\\n        int left = 1;\\n        int right = piles[piles.length-1];\\n        while(left <= right){\\n            long sum = 0;\\n            int mid = (right-left)/2+left;\\n            for(int i = 0 ; i < piles.length ;i++){\\n                sum += piles[i]/mid;\\n                if(piles[i]%mid> 0){\\n                    sum++;\\n                }\\n            }\\n            if(sum > h){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272216,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minEatingSpeed(vector<int>& piles, int h) {\\n         int n=piles.size();\\n        sort(piles.begin(),piles.end());\\n        int low=1,high=piles[n-1],ans=INT_MAX;\\n        long long hours;\\n        while(low<=high){\\n            hours=0;\\n            int mid=(low+high)/2;\\n            for(int i=0;i<n;i++){\\n                if(piles[i]%mid==0)\\n                hours+=piles[i]/mid;\\n                else\\n                hours+=(piles[i]/mid)+1;\\n            }\\n            if(hours<=(long long)h){\\n            ans=mid;\\n            high=mid-1;\\n            }\\n            else{\\n            low=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minEatingSpeed(vector<int>& piles, int h) {\\n         int n=piles.size();\\n        sort(piles.begin(),piles.end());\\n        int low=1,high=piles[n-1],ans=INT_MAX;\\n        long long hours;\\n        while(low<=high){\\n            hours=0;\\n            int mid=(low+high)/2;\\n            for(int i=0;i<n;i++){\\n                if(piles[i]%mid==0)\\n                hours+=piles[i]/mid;\\n                else\\n                hours+=(piles[i]/mid)+1;\\n            }\\n            if(hours<=(long long)h){\\n            ans=mid;\\n            high=mid-1;\\n            }\\n            else{\\n            low=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271509,
                "title": "java-brute-force-approach",
                "content": "```\\n// Approach 1: Brute Force - TLE\\n\\n// Time complexity: O(m * n), where n is length of piles, m is max(piles)\\n// Space complexity: O(1)\\n\\npublic int minEatingSpeed(int[] piles, int h) {\\n\\tint speed = 1;\\n\\t\\n\\twhile (true) {\\n\\t\\tlong hours = 0;\\n\\t\\t\\n\\t\\tfor (int pile : piles) {\\n\\t\\t\\thours += pile / speed;\\n\\t\\t\\t\\n\\t\\t\\tif (pile % speed != 0)\\n\\t\\t\\t\\thours++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (hours <= h)\\n\\t\\t\\tbreak;\\n\\t\\t\\n\\t\\tspeed++;\\n\\t}\\n\\t\\n\\treturn speed;\\n}\\n```\\n\\n**Note:** This solution gives TLE. It\\'s provided just for understanding purpose.\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Approach 1: Brute Force - TLE\\n\\n// Time complexity: O(m * n), where n is length of piles, m is max(piles)\\n// Space complexity: O(1)\\n\\npublic int minEatingSpeed(int[] piles, int h) {\\n\\tint speed = 1;\\n\\t\\n\\twhile (true) {\\n\\t\\tlong hours = 0;\\n\\t\\t\\n\\t\\tfor (int pile : piles) {\\n\\t\\t\\thours += pile / speed;\\n\\t\\t\\t\\n\\t\\t\\tif (pile % speed != 0)\\n\\t\\t\\t\\thours++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (hours <= h)\\n\\t\\t\\tbreak;\\n\\t\\t\\n\\t\\tspeed++;\\n\\t}\\n\\t\\n\\treturn speed;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271225,
                "title": "python3-clean-beats-75-88-99-75-improvement-thanks-for-reading-upvt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou guess `numOfBanana` per hour.\\nEach `piles[i]` requires `piles[i] / numOfBanana` = `hours needed` to finish, then `sum total hours`.\\n\\nIf `sum total hours` > `h` -> you need to eat MORE \\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C.\\nIf `sum total hours` < `h` -> you need to eat LESS \\uD83C\\uDF4C.\\n\\n---\\n\\n# Approach - [\"intuition 75.88%\" to \"improvement 99.75%\"]\\n<!-- Describe your approach to solving the problem. -->\\n--> **INTUITION** 1. `l` = 1, `r` = `max(piles)` intuitively, at most you will eat this many so you can finish every pile in 1 hour.\\n\\n2. Get `sum total hours` needed to finish all the `piles[]` -> using $$math.ceil()$$ because you have to +1 for additional hour to finish the remainder banana. --> (eg. 7(pile[ i ]) / 3(per hr) = 2(hr) .. 1(left), you need 2+1 = 3 hours to finish the pile)\\n3. If `sum total hours` > `h` -> you need to eat MORE \\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C\\uD83C\\uDF4C.\\nIf `sum total hours` < `h` -> you need to eat LESS \\uD83C\\uDF4C.\\n\\n--> \\uD83E\\uDDFC**IMPROVEMENT**\\uD83E\\uDDFC 4. Make the range `l` to `r` smaller so we can do fewer $$Binary Search\\'es$$.\\n\\n5. `l = sum(piles) / h` --> LOWER-BOUND: min. avg banana eaten per hr if no pile constraint\\n6. `r = max(piles) / (h // len(piles))`. --> HIGHER-BOUND: h // len(piles) --> **number of rounds** if distribute number of hrs to eat each pile evenly. (eg. [2,3,8], len = 3, h = 7 \\u27A1\\uFE0F 7//3 = 2, we evenly eat each pile at least 2 times) --> max(piles) / **number of rounds** = . (eg. [2,3,8], max = 8 \\u27A1\\uFE0F 8/2 = 4, # of banana per round per each pile)\\n\\n# Complexity\\n- \\u2705\\u231B Time complexity: $$O(N * log(N))$$\\u231B --> $$Binary Search$$ technique divides range from `l` to `r` by **2** every run.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- \\u2705\\uD83D\\uDCBE Space complexity: $$O(1)$$ \\uD83D\\uDCBE --> Storing `l` and `r`.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83E\\uDDFCCode\\uD83E\\uDDFC[99.75% - After Improvement]\\n![image.png](https://assets.leetcode.com/users/images/15442652-b6ba-47cd-ae7e-61a45ad059c6_1678254378.609097.png)\\n\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # \\uD83E\\uDDFCIMPROVEMENT\\uD83E\\uDDFC #\\n        l = math.ceil(sum(piles) / h) # LOWER: total banana / h, avg banana per banana if no pile constraint\\n        r = math.ceil(max(piles) / (h // len(piles))) # HIGHER: banan per \"round\" per pile if eat every pile same number of times.\\n\\n        while l < r:\\n            numOfBanana = (l + r) // 2\\n            if sum(math.ceil(p / numOfBanana) for p in piles) > h:\\n                l = numOfBanana + 1\\n            else:\\n                r = numOfBanana\\n\\n        return l\\n```\\n# [75.88% - Before Improvement]\\n![image.png](https://assets.leetcode.com/users/images/edb3820a-6bcd-4739-8acd-d4b821a8552c_1678250644.5445335.png)\\n\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # \\uD83E\\uDDE0INTUITION\\uD83E\\uDDE0 # \\n        l = 1\\n        r = max(piles)\\n\\n        while l < r:\\n            numOfBanana = (l+r) // 2\\n            if sum(math.ceil(p / numOfBanana) for p in piles) > h:\\n                l = numOfBanana + 1\\n            else:\\n                r = numOfBanana\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # \\uD83E\\uDDFCIMPROVEMENT\\uD83E\\uDDFC #\\n        l = math.ceil(sum(piles) / h) # LOWER: total banana / h, avg banana per banana if no pile constraint\\n        r = math.ceil(max(piles) / (h // len(piles))) # HIGHER: banan per \"round\" per pile if eat every pile same number of times.\\n\\n        while l < r:\\n            numOfBanana = (l + r) // 2\\n            if sum(math.ceil(p / numOfBanana) for p in piles) > h:\\n                l = numOfBanana + 1\\n            else:\\n                r = numOfBanana\\n\\n        return l\\n```\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        # \\uD83E\\uDDE0INTUITION\\uD83E\\uDDE0 # \\n        l = 1\\n        r = max(piles)\\n\\n        while l < r:\\n            numOfBanana = (l+r) // 2\\n            if sum(math.ceil(p / numOfBanana) for p in piles) > h:\\n                l = numOfBanana + 1\\n            else:\\n                r = numOfBanana\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271066,
                "title": "go-come-mister-tally-man-tally-me-banana-harry-belafonte-o-n-log-k-time-o-1-space",
                "content": "\\n> \"Man these bananas are good! - *Brian Regan*\\n\\nKoko be munchin\\' them bananas. A regular potassium assassin.\\n\\nWe need to find the **optimal** value for $k$ given a specific number of hours $h$ that those pesky guards will be gone.\\n\\n\\n---\\n\\n\\nLooking at the constraints of our problem - we can see that *$h$ is greater-than or equal to the number of piles*. This gives us a hint that time $k$ will be at-most the largest number of bananas from some pile, as a larger value for $k$ would mean Koko would be eating them bananas way too fast... like a duck or something, and Koko is not a duck. No sirree, bob... wait - no bob either -- Koko not be bobbin\\' like  a bird.\\n\\nWe need to let Koko relax. We need to let Koko spread them bananas out over the hour, like Elvis spread bananas on his sandwiches.\\n\\nWe know that $h$ can be as large as $10^9$, so it could easily be the case that Koko will transform into a sloth and only eat 1 banana per hour to finish all the bananas... and also somehow live to be over 100 thousand years old, but that\\'s not important. Anyway, the summation across all the piles of bananas could be exactly the number of hours we were given. If we were given more hours than bananas, then Koko would be bored not doing anything for those extra hours. So let the minimum be Koko eats 1 banana per hour.\\n\\n---\\n\\nThe inequality around time $k$ should be greater-than or equal to 1 and less-than or equal to the largest number of bananas in some pile. We can determine the max value in $O(n)$ time.\\n\\n$$\\n1 \\\\le k \\\\le max(piles)\\n$$\\n\\nWe have a left and right side... right? That means we can have the walls close in on time $k$ using a binary search to determine the optimal value that will satisfy Koko\\'s banana bonanza, without making Koko be a duck or sloth. \\n\\n---\\n\\n```go\\n// Time complexity: O(n log k) - where n is the number of piles and k is the largest pile\\n// Space complexity: O(1)\\nfunc minEatingSpeed(piles []int, h int) int {\\n\\t// O(n) - determine largest pile of bananas - as Koko may need to eat a pile per hour if h is the same as the number of piles\\n\\tindexOfLargestK := 0\\n    largestK := piles[0]\\n\\tfor i := 1; i < len(piles); i++ {\\n\\t\\tif piles[i] > largestK {\\n\\t\\t\\tindexOfLargestK = i\\n            largestK = piles[i]\\n\\t\\t}\\n\\t}\\n\\n\\t// O(1) - if h is the same as the number of piles, then just return the largest pile as we cannot\\n\\t// \\t\\t  optimize k any better\\n\\tif h == len(piles) {\\n\\t\\treturn largestK\\n\\t}\\n\\n    // O(1) - move largest pile to the front so Koko eats up most of the hours at the beginning. This could be a \"low-hanging fruit\" optimization depending on the size of the piles and h, and what was already in piles[0]\\n    piles[0], piles[indexOfLargestK] = piles[indexOfLargestK], piles[0]\\n\\n\\t// O(log k) - we need to optimize/minimize for k. we will use a binary search to do so.\\n\\tleft, right := 1, largestK\\n\\tfor left < right {\\n\\t\\t// k speed\\n\\t\\tmid := (left + right) / 2\\n\\n\\t\\t// O(n) - determine how many hours are left after Koko eats the bananas at k=mid speed\\n\\t\\thoursLeft := h\\n\\t\\tfor i := 0; hoursLeft >= 0 && i < len(piles); i++ {\\n\\t\\t\\thoursLeft -= (piles[i] + mid - 1) / mid\\n\\t\\t}\\n\\n\\t\\tif hoursLeft < 0 { // Koko did not finish the bananas in time, so we have failed to optimize\\n\\t\\t\\tleft = mid + 1\\n\\t\\t} else { // Koko may have ate the bananas too fast, but may have done just \"right\"\\n\\t\\t\\tright = mid\\n\\t\\t}\\n\\t}\\n\\treturn right\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\n// Time complexity: O(n log k) - where n is the number of piles and k is the largest pile\\n// Space complexity: O(1)\\nfunc minEatingSpeed(piles []int, h int) int {\\n\\t// O(n) - determine largest pile of bananas - as Koko may need to eat a pile per hour if h is the same as the number of piles\\n\\tindexOfLargestK := 0\\n    largestK := piles[0]\\n\\tfor i := 1; i < len(piles); i++ {\\n\\t\\tif piles[i] > largestK {\\n\\t\\t\\tindexOfLargestK = i\\n            largestK = piles[i]\\n\\t\\t}\\n\\t}\\n\\n\\t// O(1) - if h is the same as the number of piles, then just return the largest pile as we cannot\\n\\t// \\t\\t  optimize k any better\\n\\tif h == len(piles) {\\n\\t\\treturn largestK\\n\\t}\\n\\n    // O(1) - move largest pile to the front so Koko eats up most of the hours at the beginning. This could be a \"low-hanging fruit\" optimization depending on the size of the piles and h, and what was already in piles[0]\\n    piles[0], piles[indexOfLargestK] = piles[indexOfLargestK], piles[0]\\n\\n\\t// O(log k) - we need to optimize/minimize for k. we will use a binary search to do so.\\n\\tleft, right := 1, largestK\\n\\tfor left < right {\\n\\t\\t// k speed\\n\\t\\tmid := (left + right) / 2\\n\\n\\t\\t// O(n) - determine how many hours are left after Koko eats the bananas at k=mid speed\\n\\t\\thoursLeft := h\\n\\t\\tfor i := 0; hoursLeft >= 0 && i < len(piles); i++ {\\n\\t\\t\\thoursLeft -= (piles[i] + mid - 1) / mid\\n\\t\\t}\\n\\n\\t\\tif hoursLeft < 0 { // Koko did not finish the bananas in time, so we have failed to optimize\\n\\t\\t\\tleft = mid + 1\\n\\t\\t} else { // Koko may have ate the bananas too fast, but may have done just \"right\"\\n\\t\\t\\tright = mid\\n\\t\\t}\\n\\t}\\n\\treturn right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3270451,
                "title": "c-easy-beats-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen thinking of brute force only one thing comes to mind that lets take a set of number and try if that is the minimum in which all bananas can be eaten.So why not optimise it by using binary Search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLets first think about the minimum and maximum value that could possibly be the answer. Minimum can be 1 obviously but now think about max value; it cannot be more than maximum value of the array $$piles$$ so you can either find the maximum element or other way is to directly see the constraint and see maximum possible value i.e $$10^9$$.\\nNow we know what could be our $$low$$ and $$high$$. We can apply binary search and find minimum possible $$k$$.\\nTo check if the $$mid$$ is correct or not we use function check in which we find the hours taken by Koko if her $$speed$$ was $$mid$$.Which could be found by taking sum of $$ceil(piles[i]/speed)$$.\\n\\n# Complexity\\n- Time complexity: $$O(Nlog(K))$$\\nwhere N is size of array $$piles$$ and K is the maximum element or $$10^9$$ depending on your choice.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&piles,int h,long long speed)\\n    {\\n        long long countHours=0;\\n        for(auto i:piles)\\n        {\\n            countHours+=(i+speed-1)/speed;//equivalent to ceil(i/speed)\\n        }\\n        if(countHours<=h)return true;\\n        else return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1,high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high>>1);//equivalent to (mid+high)/2\\n            if(check(piles,h,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Thank You for Reading\\nAsk your query in comment if any\\nif (you understood my explaination)\\nupvote the solution\\nelse \\ndownvote the solution $$:)$$",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&piles,int h,long long speed)\\n    {\\n        long long countHours=0;\\n        for(auto i:piles)\\n        {\\n            countHours+=(i+speed-1)/speed;//equivalent to ceil(i/speed)\\n        }\\n        if(countHours<=h)return true;\\n        else return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1,high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high>>1);//equivalent to (mid+high)/2\\n            if(check(piles,h,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270429,
                "title": "java-binary-search-simple-and-easy",
                "content": "# Code\\n```\\nclass Solution {\\n  public int minEatingSpeed(int[] piles, int h) {\\n    var r = 0;\\n    var sum = 0;\\n\\n    for (var pile : piles) {\\n      r = Math.max(r, pile);\\n      sum += pile;\\n    }\\n    var l = sum / h;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var hours = 0;\\n\\n      for (var i=0; i < piles.length && hours <= h; i++)\\n        hours += Math.ceil(piles[i] / (double) m);\\n\\n      if (hours > h) l = m+1;\\n      else r = m;\\n    }\\n    return l;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int minEatingSpeed(int[] piles, int h) {\\n    var r = 0;\\n    var sum = 0;\\n\\n    for (var pile : piles) {\\n      r = Math.max(r, pile);\\n      sum += pile;\\n    }\\n    var l = sum / h;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var hours = 0;\\n\\n      for (var i=0; i < piles.length && hours <= h; i++)\\n        hours += Math.ceil(piles[i] / (double) m);\\n\\n      if (hours > h) l = m+1;\\n      else r = m;\\n    }\\n    return l;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270361,
                "title": "daily-leetcoding-challenge-march-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3082799,
                "title": "super-easy-java-sol-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N log x) (x is the max bananas from all piles)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n    int max=Integer.MIN_VALUE;\\n    for(int val:piles){\\n        max = Math.max(val,max);\\n    }\\n    if(h==piles.length){\\n        return max;\\n    }\\n    int low=0,high = max,speed = Integer.MAX_VALUE;\\n    while(low<=high){\\n        int sp = low+(high-low)/2;\\n        if(isPossible(piles,sp,h)==true){\\n            speed = sp;\\n            high = sp-1;\\n        }else{\\n            low = sp+1;\\n        }\\n    }\\n      return speed;\\n    \\n    }public boolean isPossible(int[] piles,int sp,int h){\\n        int time=0;\\n        for(int i=0;i<piles.length;i++){\\n          time+=(int)Math.ceil((piles[i]*1.0)/sp);\\n        }\\n        return time<=h;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n    int max=Integer.MIN_VALUE;\\n    for(int val:piles){\\n        max = Math.max(val,max);\\n    }\\n    if(h==piles.length){\\n        return max;\\n    }\\n    int low=0,high = max,speed = Integer.MAX_VALUE;\\n    while(low<=high){\\n        int sp = low+(high-low)/2;\\n        if(isPossible(piles,sp,h)==true){\\n            speed = sp;\\n            high = sp-1;\\n        }else{\\n            low = sp+1;\\n        }\\n    }\\n      return speed;\\n    \\n    }public boolean isPossible(int[] piles,int sp,int h){\\n        int time=0;\\n        for(int i=0;i<piles.length;i++){\\n          time+=(int)Math.ceil((piles[i]*1.0)/sp);\\n        }\\n        return time<=h;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080319,
                "title": "beats-98-easy-c-solution-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& p,int h,int n,int mid){\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(p[i]%mid==0){\\n                x+=(p[i]/mid);\\n            }\\n            else{\\n                x+=(p[i]/mid)+1;\\n            }\\n            if(x>h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& p, int h) {\\n        sort(p.begin(),p.end());\\n        int low=1;\\n        int n=p.size();\\n        int high=p[n-1];\\n        int res=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            // int mid=(low+high)/2;\\n            if(f(p,h,n,mid)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // if(res==INT_MAX) return p[n-1];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& p,int h,int n,int mid){\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(p[i]%mid==0){\\n                x+=(p[i]/mid);\\n            }\\n            else{\\n                x+=(p[i]/mid)+1;\\n            }\\n            if(x>h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& p, int h) {\\n        sort(p.begin(),p.end());\\n        int low=1;\\n        int n=p.size();\\n        int high=p[n-1];\\n        int res=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            // int mid=(low+high)/2;\\n            if(f(p,h,n,mid)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // if(res==INT_MAX) return p[n-1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992575,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool count(vector<int>& piles, int h, int m)\\n    {\\n        int c=0;\\n        for(int i:piles)\\n        {\\n            c+=i/m;\\n            if(i%m==0)\\n            c++;\\n        }\\n        return c<=h;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1;\\n        int r=0;\\n        for(int i:piles)\\n        r=max(r, i);\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            int c=0;\\n            for(int i:piles)\\n            {\\n                c+=i/m;\\n                if(i%m)\\n                c++;\\n            }\\n            if(c<=h)\\n            r=m;\\n            else\\n            l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool count(vector<int>& piles, int h, int m)\\n    {\\n        int c=0;\\n        for(int i:piles)\\n        {\\n            c+=i/m;\\n            if(i%m==0)\\n            c++;\\n        }\\n        return c<=h;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l=1;\\n        int r=0;\\n        for(int i:piles)\\n        r=max(r, i);\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            int c=0;\\n            for(int i:piles)\\n            {\\n                c+=i/m;\\n                if(i%m)\\n                c++;\\n            }\\n            if(c<=h)\\n            r=m;\\n            else\\n            l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737692,
                "title": "why-do-you-fail-java-big-input",
                "content": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        \\n        int maxk = 0;\\n        for(int i : piles)\\n            maxk = Math.max(maxk, i);\\n        \\n        int res = maxk, l = 1, r = maxk;\\n        \\n        while(l <= r){\\n            \\n            int mid = l + (r - l) / 2;\\n            int hour = 0;\\n            for(int i : piles){\\n                //Careful here, when we want to get float number of integer devision and round it up\\n                //We need to cast it to float / double first\\n                //But for this problem , Float won\\'t work becasue it can have maximum 6-7 digits \\n\\t\\t\\t\\t//but the input is maximum 10^9 , so we need to use double here which can have maximum 15 digits\\n                \\n                hour += Math.ceil((double)i / mid );\\n            }\\n            \\n            if(hour <= h){\\n                r = mid - 1;\\n                res = Math.min(res, mid);\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        \\n        int maxk = 0;\\n        for(int i : piles)\\n            maxk = Math.max(maxk, i);\\n        \\n        int res = maxk, l = 1, r = maxk;\\n        \\n        while(l <= r){\\n            \\n            int mid = l + (r - l) / 2;\\n            int hour = 0;\\n            for(int i : piles){\\n                //Careful here, when we want to get float number of integer devision and round it up\\n                //We need to cast it to float / double first\\n                //But for this problem , Float won\\'t work becasue it can have maximum 6-7 digits \\n\\t\\t\\t\\t//but the input is maximum 10^9 , so we need to use double here which can have maximum 15 digits\\n                \\n                hour += Math.ceil((double)i / mid );\\n            }\\n            \\n            if(hour <= h){\\n                r = mid - 1;\\n                res = Math.min(res, mid);\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738653,
                "title": "why-binary-search-intiution-explained-java",
                "content": "Notice one thing , h (hours of returning of guard) will always be >= length of array.\\n### Why is it so?\\nBecause if h is less than length of array (i.e number of piles) than all banana of every piles can\\'t be eaten. Hence h must be >= arr.length.\\n\\nNow if the h == arr.length , then minimum banana eating speed must be max element of array.\\nWhy is it so?\\nLet\\'s understand it with an example --------\\npiles[] = [2,4,8,12,6]  h = 5\\n\\nhere the minimum banana eating speed must be 12 because only with that speed all piles can be finised within h hours\\n\\n\\nNow case comes when h is greater than piles.length\\n\\nNotice , minimum banana eating speed is 1 banana per hour and maximum banana eating speed is Max Element of pile\\'s banana per hour\\n\\nSo we can observe that banana eating speed lies in range of 1 to Max Element of piles\\n#### HENCE WE CAN APPLY BINARY SERACH ON banana eating speed\\n\\nnow we have start =1 and end = MAX ELELEMNT \\nwe\\'ll calculate mid and that will be our potential banana eating speed\\n\\nCASE 1:\\nif with mid as our banana eating speed , all piles can be finised within h hours , then store this mid ans our answer and reduce end to mid -1 , as we will check with further low mid values (because we have to find minimum speed possible)\\n\\n\\n\\nCASE 2:\\nif with mid as our banana eating speed , all piles can\\'t be finised within h hours , then increase start to mid+1, as we have to increase our banana eating speed in order to finish the piles\\n\\n\\n\\n```\\n/*\\nNotice one thing , h (hours of returning of guard) will always be >= length of array.\\nWhy is it so?\\nBecause if h is less than length of array (i.e number of piles) than all banana of every piles can\\'t be eaten. Hence h must be >= arr.length.\\n\\nNow if the h == arr.length , then minimum banana eating speed must be max element of array.\\nWhy is it so?\\nLet\\'s understand it with an example --------\\npiles[] = [2,4,8,12,6]  h = 5\\n\\nhere the minimum banana eating speed must be 12 because only with that speed all piles can be finised within h hours\\n\\n\\nNow case comes when h is greater than piles.length\\n\\nNotice , minimum banana eating speed is 1 banana per hour and maximum banana eating speed is Max Element of pile\\'s banana per hour\\n\\nSo we can observe that banana eating speed lies in range of 1 to Max Element of piles\\nHENCE WE CAN APPLY BINARY SERACH ON banana eating speed\\n\\nnow we have start =1 and end = MAX ELELEMNT \\nwe\\'ll calculate mid and that will be our potential banana eating speed\\n\\nCASE 1:\\nif with mid as our banana eating speed , all piles can be finised within h hours , then store this mid ans our answer and reduce end to mid -1 , as we will check with further low mid values (because we have to find minimum speed possible)\\n\\n\\n\\nCASE 2:\\nif with mid as our banana eating speed , all piles can\\'t be finised within h hours , then increase start to mid+1, as we have to increase our banana eating speed in order to finish the piles\\n\\n\\n\\n\\n\\n*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        \\n        int max =0;\\n        for(int banana : piles)\\n        {\\n            max = Math.max(max,banana);\\n        }\\n        if(h == piles.length)\\n            return max;\\n        \\n        int bananaEatingSpeed = BinarySearch(piles, 1 , max, h);\\n        return bananaEatingSpeed;\\n    }\\n    public int BinarySearch(int[] arr, int s, int e, int maxHours)     \\n    {\\n        int speed = Integer.MAX_VALUE;\\n        \\n        \\n        while(s<=e)\\n        {\\n          \\n            int m = s + (e-s)/2;  \\n            long timeTaken =0; \\n            \\n            /*\\n            Calculating the total time taken in finishing the piles with banana eating speed as \\'m\\'\\n            */\\n            for(int i : arr)\\n            {   \\n                if(m !=0)\\n                {\\n                timeTaken = timeTaken + (int)Math.ceil(i*1.0/m);  // we have to take ceil because of this statement-- If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. \\n                }    \\n            }\\n            \\n            \\n            if(timeTaken > maxHours)\\n            {\\n                s = m+1;\\n            }\\n            else //if(timeTaken <= maxHours)\\n            {   if(m > 0)\\n                {speed = Math.min(speed, m);}       // Storing the minimum banana eating speed\\n                e = m-1;\\n            }\\n        }\\n        return speed;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        \\n        int max =0;\\n        for(int banana : piles)\\n        {\\n            max = Math.max(max,banana);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1705664,
                "title": "c-with-integer-ceil-trick",
                "content": "Many of the answers posted use the ```ceil``` library function to round up.  However, depending on the floating point representation and the inputs, you could end up with the wrong answer.  I instead use an integer rounding trick I learned from programming in CUDA.  Basically, if you want to calculate ```ceil(x/y)```, where ```x``` and ```y``` are integers, and you want an integer result, you can simply write ```(x + y - 1)/y```.  The intuition is that ```/``` is integer division: you divide `x` by `y` and follow that operation by an integer ```floor``` operation.  Thus, 3 / 2 =  (int)floor(1.5) = 1, but we want a result of 2.  With the alternate equation, (3 + 2 - 1) / 2 = (int) floor(4/2) = 2, which is what we want.  If you do a quick check with other values, you\\'ll see that the identity holds.\\n\\n\\n```\\ninline int hours_to_eat(vector<int>& piles, int eating_rate){\\n        int hours = 0;\\n        for(int p: piles){\\n\\t\\t    // Integer ceiling operation\\n            hours += (p + eating_rate - 1) / eating_rate;\\n        }\\n        return hours;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1;\\n        int hi = 1000000000;\\n        int min_eating_speed = INT_MAX;\\n        while(lo <= hi){\\n            int k = hi - (hi - lo) / 2;\\n            int hours = hours_to_eat(piles, k);\\n            if(hours <= h){\\n                min_eating_speed = std::min<int>(k, min_eating_speed);\\n                hi = k - 1;\\n            }\\n            else{\\n                lo = k + 1;\\n            }\\n        }\\n        return min_eating_speed;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```ceil```\n```ceil(x/y)```\n```x```\n```y```\n```(x + y - 1)/y```\n```/```\n```floor```\n```\\ninline int hours_to_eat(vector<int>& piles, int eating_rate){\\n        int hours = 0;\\n        for(int p: piles){\\n\\t\\t    // Integer ceiling operation\\n            hours += (p + eating_rate - 1) / eating_rate;\\n        }\\n        return hours;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1;\\n        int hi = 1000000000;\\n        int min_eating_speed = INT_MAX;\\n        while(lo <= hi){\\n            int k = hi - (hi - lo) / 2;\\n            int hours = hours_to_eat(piles, k);\\n            if(hours <= h){\\n                min_eating_speed = std::min<int>(k, min_eating_speed);\\n                hi = k - 1;\\n            }\\n            else{\\n                lo = k + 1;\\n            }\\n        }\\n        return min_eating_speed;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704648,
                "title": "binary-search-solution",
                "content": "We are supposed to find the minimum speed which can satisfy our problem.\\nSo, brute force approach is to linear check every speed starting from 1 and incrementing, where we return answer whenever we get the speed that satisfies our condition.\\nBut Time-complexity of such a linear method can go anywhere in the range of the input i.e. 10^9, so it is not feasible.\\n\\n**Binary Search Approach :**\\nInstead of linearly searching for values, we can convert it to a binary search approach.\\n\\nWe perform our search on the full range of possible numbers,\\nso let\\'s assume our lower bound is at 1 and our upper bound at 10^18 (Maximum value of Long long type).\\n\\nSince we\\'re performing binary search on a constant range, so it comes down to almost constant time, as log(10^18) is around 63.\\nBut, we also traverse our array everytime so time complexity is constant X (N) === N (Linear)\\n\\n**Binary Search**\\nIf with our current value of mid, it is possible to complete the task under \"h\" hours, then we consider that for any value>mid, it is also possible, as we are focused on minimum, we simply neglect the upper range, and shift our high pointer to mid value, and try to search an yet smaller value, if possible.\\nIf our current value of mid, can\\'t fulfill the condition then we search for a higher value by shifting low pointer to mid+1.\\n\\nWhen our low pointer equals our high, we finally reach our target and we can return either of high or low as our answer.\\n\\n**The possible() method**\\nThe possible method simply traverses the array and calculates the hours for the given mid value, if it falls under our maximum alloted time, it returns true , else false.\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    bool possible(ll m, vector<int> p, ll h){\\n        ll c=0;\\n        for(auto i:p){\\n            c+= ceil(i/(double)m);\\n        }\\n        if(c<=h)return true;\\n        return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        //binary search\\n        ll lo=1;\\n        ll hi=1e18;\\n        while(lo<hi){\\n            ll m= lo+(hi-lo)/2;\\n            if(possible(m,piles,h)){\\n                hi=m;\\n            }\\n            else{\\n                lo=m+1;\\n            }\\n        }\\n        return lo;//or hi\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    bool possible(ll m, vector<int> p, ll h){\\n        ll c=0;\\n        for(auto i:p){\\n            c+= ceil(i/(double)m);\\n        }\\n        if(c<=h)return true;\\n        return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        //binary search\\n        ll lo=1;\\n        ll hi=1e18;\\n        while(lo<hi){\\n            ll m= lo+(hi-lo)/2;\\n            if(possible(m,piles,h)){\\n                hi=m;\\n            }\\n            else{\\n                lo=m+1;\\n            }\\n        }\\n        return lo;//or hi\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548610,
                "title": "c-easy-code-binary-search",
                "content": "class Solution {\\npublic:\\n    \\n    bool isvalid(vector<int> a,int h,int mid){\\n        int n=a.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]%mid!=0){\\n                sum++;\\n            }\\n            sum+=a[i]/mid;\\n        }\\n        if(sum<=h){\\n            return true;\\n        }\\n        return false;\\n    } \\n        \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+((high-low))/2;\\n            if(isvalid(piles,h,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool isvalid(vector<int> a,int h,int mid){\\n        int n=a.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]%mid!=0){\\n                sum++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1484486,
                "title": "binary-search-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minEatingSpeed(self, piles: List[int], h: int) -> int:\\n\\n\\n\\t\\t\\tdef feasible(speed):\\n\\n\\t\\t\\t\\treturn sum((pile-1) //speed+1 for pile in piles) <= h  # faster\\n\\n\\n\\t\\t\\t\\t#hour=1\\n\\t\\t\\t\\t#s=0\\n\\t\\t\\t\\t#for pile in piles:\\n\\t\\t\\t\\t\\t#s+=pile\\n\\t\\t\\t\\t\\t#if s>speed:\\n\\t\\t\\t\\t\\t\\t#s=pile\\n\\t\\t\\t\\t\\t\\t#if hour>h:\\n\\t\\t\\t\\t\\t\\t\\t#return False\\n\\t\\t\\t\\t#return True\\n\\n\\n\\t\\t\\tleft, right = 1, max(piles)\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tmid = left  + (right - left) // 2\\n\\t\\t\\t\\tif feasible(mid):\\n\\t\\t\\t\\t\\tright = mid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\treturn left",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minEatingSpeed(self, piles: List[int], h: int) -> int:\\n\\n\\n\\t\\t\\tdef feasible(speed):\\n\\n\\t\\t\\t\\treturn sum((pile-1) //speed+1 for pile in piles) <= h  # faster\\n\\n\\n\\t\\t\\t\\t#hour=1\\n\\t\\t\\t\\t#s=0\\n\\t\\t\\t\\t#for pile in piles:\\n\\t\\t\\t\\t\\t#s+=pile\\n\\t\\t\\t\\t\\t#if s>speed:\\n\\t\\t\\t\\t\\t\\t#s=pile\\n\\t\\t\\t\\t\\t\\t#if hour>h:\\n\\t\\t\\t\\t\\t\\t\\t#return False\\n\\t\\t\\t\\t#return True\\n\\n\\n\\t\\t\\tleft, right = 1, max(piles)\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tmid = left  + (right - left) // 2\\n\\t\\t\\t\\tif feasible(mid):\\n\\t\\t\\t\\t\\tright = mid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\treturn left",
                "codeTag": "Java"
            },
            {
                "id": 1475435,
                "title": "simple-c-solution-using-binary-search-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>a, int k, int mid)\\n    {\\n        int n=a.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]%mid!=0)\\n                sum++;\\n            sum+=a[i]/mid;\\n        }\\n        if(sum<=k)\\n                return true;\\n        return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(piles,h,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\tPlease consider upvoting.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>a, int k, int mid)\\n    {\\n        int n=a.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]%mid!=0)\\n                sum++;\\n            sum+=a[i]/mid;\\n        }\\n        if(sum<=k)\\n                return true;\\n        return false;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(piles,h,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450414,
                "title": "binary-search-on-answer-time-94-c",
                "content": "```\\nint minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        auto check=[&](int x){                                         //check wether the choosen answer is valid or not\\n            int count=0;\\n            for(auto &i:piles)\\n                count+=i%x==0?i/x:i/x+1;\\n            return count<=h;\\n        };\\n    \\n        int l=1,r=*max_element(piles.begin(),piles.end());   //answer must be lies in between l ans r\\n        while(l<r) {\\n            int mid= l+(r-l)/2;\\n            if(check(mid))\\n                r=mid;\\n            else l=mid+1;\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nint minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        auto check=[&](int x){                                         //check wether the choosen answer is valid or not\\n            int count=0;\\n            for(auto &i:piles)\\n                count+=i%x==0?i/x:i/x+1;\\n            return count<=h;\\n        };\\n    \\n        int l=1,r=*max_element(piles.begin(),piles.end());   //answer must be lies in between l ans r\\n        while(l<r) {\\n            int mid= l+(r-l)/2;\\n            if(check(mid))\\n                r=mid;\\n            else l=mid+1;\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1297064,
                "title": "java-explanation-for-dumbs-like-me",
                "content": "[3,6,7,11] \\n    done in 4 hours at k = 11\\n    at k = 10, done in 5h\\n    at k = 9, done in 5h\\n    at k = 8, done in 5h\\n    at k = 7, done in 5h\\n    at k = 6, done in 6h\\n    at k = 5, done in 8h\\n    at k = 4, done in 8h\\n    at k = 3, done in 10h (1+2+3+4)\\n    at k = 2, done in 15h (2+3+4+6)\\n    at k = 1, done in 15h (3+6+7+11)\\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11] -->Possible Values Of K! (speed cannot be less than 1)\\n    [F, F, F,T,T, T,T, T, T, T,  T]\\n    first true is the minimum speed required for koko to eat the bananas\\n\\t\\n```\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = 0;  \\n        for(int n : piles){\\n            max = Math.max(max, n);\\n        }\\n        // assumed right to be max, because at this speed the maximum time taken will be atleast the length of the array.\\n        int left = 1 ; int right = max;\\n        while(left < right){\\n            int mid = left + (right-left)/2 ;\\n            if(property(mid,piles,h)){\\n                right = mid;  // this may be the answer or a better ans is on the left side\\n            }else{\\n                left = mid +1; // is not the answer so go to right. \\n            }\\n        }\\n        //left == right so return anything.\\n        return left;\\n    }\\n    public boolean property(int speed, int[] piles, int maxTime){\\n        int timeTaken = 0;\\n        for (int n : piles){\\n            timeTaken += (int)Math.ceil(((double)n/speed));\\n        }\\n        return timeTaken <= maxTime ;\\n    }\\n}\\n\\n```\\n\\n```\\ntime O(N * log(MaxValueOfPiles))   // look at the possible values of k if confuesd.\\nSpace O(1)\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max = 0;  \\n        for(int n : piles){\\n            max = Math.max(max, n);\\n        }\\n        // assumed right to be max, because at this speed the maximum time taken will be atleast the length of the array.\\n        int left = 1 ; int right = max;\\n        while(left < right){\\n            int mid = left + (right-left)/2 ;\\n            if(property(mid,piles,h)){\\n                right = mid;  // this may be the answer or a better ans is on the left side\\n            }else{\\n                left = mid +1; // is not the answer so go to right. \\n            }\\n        }\\n        //left == right so return anything.\\n        return left;\\n    }\\n    public boolean property(int speed, int[] piles, int maxTime){\\n        int timeTaken = 0;\\n        for (int n : piles){\\n            timeTaken += (int)Math.ceil(((double)n/speed));\\n        }\\n        return timeTaken <= maxTime ;\\n    }\\n}\\n\\n```\n```\\ntime O(N * log(MaxValueOfPiles))   // look at the possible values of k if confuesd.\\nSpace O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261133,
                "title": "c-simple-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possible(int mid, vector<int>& piles, int h)\\n    {\\n        int ans = 0;\\n        for(auto p : piles)\\n            ans += ceil(p*1.0/mid);\\n        \\n        return ans <= h;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        if(piles.size()==1)\\n            return ceil(piles[0]*1.0/h);\\n        \\n        int low = 0, high = *max_element(piles.begin(), piles.end());\\n        int ans = INT_MAX;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if(possible(mid, piles, h))\\n            {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(int mid, vector<int>& piles, int h)\\n    {\\n        int ans = 0;\\n        for(auto p : piles)\\n            ans += ceil(p*1.0/mid);\\n        \\n        return ans <= h;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        if(piles.size()==1)\\n            return ceil(piles[0]*1.0/h);\\n        \\n        int low = 0, high = *max_element(piles.begin(), piles.end());\\n        int ans = INT_MAX;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if(possible(mid, piles, h))\\n            {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966298,
                "title": "python3",
                "content": "```\\ndef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        def geth(p,s):\\n            return sum(math.ceil(x/s) for x in p)    \\n        i,j=0,max(piles)\\n        while i<j:\\n            mid=i+(j-i)//2\\n            if geth(piles,mid)<=H:\\n                j=mid\\n            else:\\n                i=mid+1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\ndef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        def geth(p,s):\\n            return sum(math.ceil(x/s) for x in p)    \\n        i,j=0,max(piles)\\n        while i<j:\\n            mid=i+(j-i)//2\\n            if geth(piles,mid)<=H:\\n                j=mid\\n            else:\\n                i=mid+1\\n        return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 683042,
                "title": "java-binary-search",
                "content": "class Solution {\\n\\n    public int minEatingSpeed(int[] piles, int H) {\\n     \\n        int left = 1, right = Arrays.stream(piles).max().getAsInt();\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canEatBananas(piles, mid, H)) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    private boolean canEatBananas(int[] piles, int k, int H) {\\n        \\n        int hours = 0;\\n        for (int pile : piles) {\\n            hours += pile / k;\\n            if (pile % k != 0) {\\n                ++hours;\\n            }\\n        }\\n        return hours <= H; \\n    }\\n}\\n\\n// Time complexity - O(Nlog(M)); where M - Max difference between int values in the list & N number of elements in the list",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int minEatingSpeed(int[] piles, int H) {\\n     \\n        int left = 1, right = Arrays.stream(piles).max().getAsInt();\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canEatBananas(piles, mid, H)) {\\n                right = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 413063,
                "title": "binary-search-to-find-hours-required",
                "content": "```csharp\\npublic class Solution \\n{\\n    public int MinEatingSpeed(int[] piles, int H)\\n    {        \\n        int low = 1, high = piles.Max();\\n        int mid;\\n\\n        while (low < high)\\n        {\\n            mid = low + (high - low) / 2;\\n            int hours = 0;\\n            \\n            foreach (int pile in piles)\\n            {\\n                hours += 1 + (pile- 1) / mid;\\n            }\\n\\n            if (hours <= H)\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public int MinEatingSpeed(int[] piles, int H)\\n    {        \\n        int low = 1, high = piles.Max();\\n        int mid;\\n\\n        while (low < high)\\n        {\\n            mid = low + (high - low) / 2;\\n            int hours = 0;\\n            \\n            foreach (int pile in piles)\\n            {\\n                hours += 1 + (pile- 1) / mid;\\n            }\\n\\n            if (hours <= H)\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152355,
                "title": "python-simple-optimization",
                "content": "```python\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, H):\\n        res, pilest = float(\\'inf\\'), 0\\n        for i in piles: pilest+=i \\n        K = int(pilest/H)  # Optimization : K can not be lesser than this\\n        if K == 0: K = 1\\n        while res > H:\\n            res = 0\\n            for i in piles:\\n                res += math.ceil((i*1.0)/K)\\n            K+=1\\n        return K-1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, H):\\n        res, pilest = float(\\'inf\\'), 0\\n        for i in piles: pilest+=i \\n        K = int(pilest/H)  # Optimization : K can not be lesser than this\\n        if K == 0: K = 1\\n        while res > H:\\n            res = 0\\n            for i in piles:\\n                res += math.ceil((i*1.0)/K)\\n            K+=1\\n        return K-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040879,
                "title": "koko-eating-bananas-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int l=1;\\n        double sum;\\n        int ans;\\n        int r=INT_MIN;\\n        for(int i=0;i<n;i++)\\n            r=max(r,piles[i]);\\n        while(l<=r)\\n        {\\n            sum=0;\\n            int mid=l+(r-l)/2;\\n            for(int i=0;i<n;i++)\\n                sum+=ceil((double)piles[i]/mid);\\n\\n            if(sum<=h)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int l=1;\\n        double sum;\\n        int ans;\\n        int r=INT_MIN;\\n        for(int i=0;i<n;i++)\\n            r=max(r,piles[i]);\\n        while(l<=r)\\n        {\\n            sum=0;\\n            int mid=l+(r-l)/2;\\n            for(int i=0;i<n;i++)\\n                sum+=ceil((double)piles[i]/mid);\\n\\n            if(sum<=h)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022247,
                "title": "binary-search-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* It took me a while to realize on what should I do the searching. \\n* After analyzing the problem and writing it down on a white paper, I found out that my search space is in the range from [1 : maximum number of bananas in all piles]\\n* so I thought about applying binary search. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* I have found some base cases:\\n    1. if the given number of hours was equal to the number of piles:\\n        * Then we must eat each pile in only one hour, so we have to eat with a speed equals to the maximum number of bananas in a pile per hour. \\n    2. if the number of piles was equal to 1\\n        * Then we must finish that pile before the gaurds come back, so the allowed time is ceil( the number of bananas in this pile / the given duration).\\n        * and do not forget to apply casting to long double, because int / int will give you int not float nor double. \\n* Then the basic logic will be simple binary search logic.\\n* we have three pointers\\n    1. bgn = 1 initially.\\n    2. end = the maximum number of bananas in the list.\\n    3. mid = (bgn + end) / 2 -> and the integer division will apply the floor logic by default. \\n* Then we should loop while the end pointer is larger than the bgn pointer:\\n    - if mid is a valid k -> we will discuss its logic later.\\n        - then assign the minimum number of hours = mid\\n        - then lets check if we can eat all bananas in less hours, so ,move the end pointer to the mid position.\\n        - Update the mid position using the same equation \\n        - mid = (bgn + end) / 2\\n    - else we need to just look for a larger number of bananas per hour, so we will move the bgn pointer to the mid position + **1**\\n    - Then update the mid position using the same logic\\n    - mid = (bgn + end) /2\\n* Then as a final check if mid < max_element and mid >= 0\\n* do another check, and if mid < minimum number of banans per hour, update it.\\n* and finally return that minimum number.      \\n\\n## Valid Function (piles, k, h)\\n* This is a function which check wethere we can eat all the bananas in the given k hours or the gaurds will catch us. \\n* so we just define a sum variable and initialize it with 0\\n* and iterate over all piles.\\n* and divide the number of bananas in this pile by the given k\\n* and do not forget to cast it to double, to avoid wrong calculations.\\n* then finaly if the sum of hours was greater than the hours after which the gaurds will come back  then we just return false, otherwise this is a valid number of hours.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n* O(n log m) as:\\n    - valid function takes O(n) as we iterate over the all piles.\\n    - O(lg m) because we apply binary search on the space of the m [1 : m]\\n    - n is the number of piles, m is the maximum number of bananas.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n* O(n) as I do not use any extra space. \\n# Code\\n```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n#define DPSolver ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\nusing ll = long long;\\nusing ld = long double;\\n\\nbool valid(const vector<int> &piles, const int k, const int h)\\n{\\n    int sum = 0;\\n    for (auto pile : piles)\\n        sum += ceil(pile / (ld)k);\\n    return sum <= h;\\n}\\n\\nint minEatingSpeed(vector<int> &piles, int h)\\n{\\n    DPSolver; \\n    // int sz = piles.size();\\n    // if (sz == h)\\n    //     return *max_element(piles.begin(), piles.end());\\n    // else if (sz == 1)\\n    //     return ceil((ld)piles[0] / h);\\n    // int mx_element = *max_element(piles.begin(), piles.end());\\n    int mx_element = INT_MAX; \\n    int bgn = 1;\\n    ll end = mx_element;\\n    ll md = (bgn + end) / 2;\\n    int mn = INT_MAX; \\n    while (end > bgn)\\n        if (valid(piles, md, h))\\n        {\\n            if(md < mn)\\n                mn = md; \\n            end = md;\\n            md = (bgn + end) / 2;\\n        }\\n        else\\n        {\\n            bgn = md + 1;\\n            md = (bgn + end) / 2;\\n        }\\n\\n    if (md >= 0 && md <= mx_element)\\n        if (valid(piles, md, h))\\n            if(md < mn)\\n                mn = md; \\n\\n    return mn;\\n}\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n#define DPSolver ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\nusing ll = long long;\\nusing ld = long double;\\n\\nbool valid(const vector<int> &piles, const int k, const int h)\\n{\\n    int sum = 0;\\n    for (auto pile : piles)\\n        sum += ceil(pile / (ld)k);\\n    return sum <= h;\\n}\\n\\nint minEatingSpeed(vector<int> &piles, int h)\\n{\\n    DPSolver; \\n    // int sz = piles.size();\\n    // if (sz == h)\\n    //     return *max_element(piles.begin(), piles.end());\\n    // else if (sz == 1)\\n    //     return ceil((ld)piles[0] / h);\\n    // int mx_element = *max_element(piles.begin(), piles.end());\\n    int mx_element = INT_MAX; \\n    int bgn = 1;\\n    ll end = mx_element;\\n    ll md = (bgn + end) / 2;\\n    int mn = INT_MAX; \\n    while (end > bgn)\\n        if (valid(piles, md, h))\\n        {\\n            if(md < mn)\\n                mn = md; \\n            end = md;\\n            md = (bgn + end) / 2;\\n        }\\n        else\\n        {\\n            bgn = md + 1;\\n            md = (bgn + end) / 2;\\n        }\\n\\n    if (md >= 0 && md <= mx_element)\\n        if (valid(piles, md, h))\\n            if(md < mn)\\n                mn = md; \\n\\n    return mn;\\n}\\n\\n\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3953546,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(Nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Helper function which returns the number of hours required to consume the piles for given K\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t// If hours required is greater than our limit, ignore mid\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // Helper function which returns the number of hours required to consume the piles for given K\\n    int hoursRequired(const vector<int> &piles, int k)\\n    {\\n        int h = 0;\\n        if(k == 0) return INT_MAX;\\n        for(int i : piles)\\n        {\\n            if(i % k != 0)\\n            {\\n                h++;\\n            }\\n            h += (i / k);\\n        }\\n        return h;\\n    }\\n    \\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        long long sum = 0;\\n        int mx = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            sum += piles[i];\\n            mx = max(mx, piles[i]);\\n        }\\n        int l = sum / H, r = mx, ans;\\n        while(l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            int ans = hoursRequired(piles, mid);\\n\\t\\t\\t// If hours required is greater than our limit, ignore mid\\n            if(ans > H)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931313,
                "title": "simple-c-solution",
                "content": "# Linearly Traversing\\nApplying a Linear traversal on all the possible solutions\\n```\\nclass Solution {\\npublic:\\n    int maxOfArray(vector<int> &piles){\\n        int maxElement=INT_MIN;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]>maxElement){\\n                maxElement=piles[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n    long long timeTaken(vector<int> &piles,int k){\\n        long long totalTimeRequired=0;\\n        for(int i=0;i<piles.size();i++){\\n            totalTimeRequired+=ceil((double)piles[i]/(double)k);\\n        }\\n        return totalTimeRequired;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int maxPerHour=maxOfArray(piles);\\n        for(int i=1;i<=maxPerHour;i++){\\n            long long timeRequired=timeTaken(piles,i);\\n            if(timeRequired<=h){\\n                return i;\\n            }\\n        }\\n        return maxPerHour;\\n    }\\n};\\n```\\n# Binary Search\\nFor this approach to reduce the time taken to linearly iterate over all possible answers we can apply binary serach on the possible answers.\\n```\\nclass Solution {\\npublic:\\n    int maxOfArray(vector<int> &piles){\\n        int maxElement=INT_MIN;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]>maxElement){\\n                maxElement=piles[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n    long long timeTaken(vector<int> &piles,int k){\\n        long long totalTimeRequired=0;\\n        for(int i=0;i<piles.size();i++){\\n            totalTimeRequired+=ceil((double)piles[i]/(double)k);\\n        }\\n        return totalTimeRequired;\\n    }\\n    int minEatingSpeed(vector<int> &piles,int h){\\n        int low=1,high=maxOfArray(piles);\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(timeTaken(piles,mid)<=h){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxOfArray(vector<int> &piles){\\n        int maxElement=INT_MIN;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]>maxElement){\\n                maxElement=piles[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n    long long timeTaken(vector<int> &piles,int k){\\n        long long totalTimeRequired=0;\\n        for(int i=0;i<piles.size();i++){\\n            totalTimeRequired+=ceil((double)piles[i]/(double)k);\\n        }\\n        return totalTimeRequired;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int maxPerHour=maxOfArray(piles);\\n        for(int i=1;i<=maxPerHour;i++){\\n            long long timeRequired=timeTaken(piles,i);\\n            if(timeRequired<=h){\\n                return i;\\n            }\\n        }\\n        return maxPerHour;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxOfArray(vector<int> &piles){\\n        int maxElement=INT_MIN;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]>maxElement){\\n                maxElement=piles[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n    long long timeTaken(vector<int> &piles,int k){\\n        long long totalTimeRequired=0;\\n        for(int i=0;i<piles.size();i++){\\n            totalTimeRequired+=ceil((double)piles[i]/(double)k);\\n        }\\n        return totalTimeRequired;\\n    }\\n    int minEatingSpeed(vector<int> &piles,int h){\\n        int low=1,high=maxOfArray(piles);\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(timeTaken(piles,mid)<=h){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921543,
                "title": "using-binary-search-easy-c-solution-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long count_banana(vector<int> &v,int num)\\n{\\n    long long sum=0;\\n    for(int i=0;i<v.size();i++)\\n    {\\n        sum+=ceil(v[i]/(double)num);\\n    }\\n    return sum;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n       int low=1;\\n       int high=*max_element(piles.begin(),piles.end());\\n       while(low<=high)\\n       {\\n           int mid=(low+high)/2;\\n           if(count_banana(piles,mid)<=h)\\n           {\\n               high=mid-1;\\n           }\\n           else{\\n               low=mid+1;\\n           }\\n       } \\n       return low;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long count_banana(vector<int> &v,int num)\\n{\\n    long long sum=0;\\n    for(int i=0;i<v.size();i++)\\n    {\\n        sum+=ceil(v[i]/(double)num);\\n    }\\n    return sum;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n       int low=1;\\n       int high=*max_element(piles.begin(),piles.end());\\n       while(low<=high)\\n       {\\n           int mid=(low+high)/2;\\n           if(count_banana(piles,mid)<=h)\\n           {\\n               high=mid-1;\\n           }\\n           else{\\n               low=mid+1;\\n           }\\n       } \\n       return low;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909246,
                "title": "clear-c-solution-with-comments-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N log M), where N is the count of the piles, M is the maximum eating speed which is maximum pile height\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // the main idea is to search among all possible speed of eating\\n    int minEatingSpeed(vector<int>& piles, int h) \\n    {\\n        int left = 1; // minimum speed is 1 banana per hour\\n        int right = getMax(piles); // maximum speed is the amount of bananas in the biggest pile\\n        \\n        // using binary search to find the minimum speed of all possible Koko\\'s eating speed values\\n        while (left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            long hoursRequired = calculateHours(piles, mid);\\n\\n            // if Koko eats faster than required or as required, than we should look among lower speed values\\n            // there might be a value of speed that satisfies the conditions better (the minimal speed)\\n            if (hoursRequired <= h)\\n            {\\n                right = mid - 1;\\n            }\\n            // if Koko eats slower than required, than we should look among higher speed values\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    // calculating required hours amount for eating speed from parameter\\n    long calculateHours(vector<int>& piles, int speed)\\n    {\\n        long spentHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            spentHours += piles[i] / speed;\\n            if (piles[i] % speed != 0)\\n            {\\n                spentHours++;\\n            }\\n        }\\n        return spentHours;\\n    }\\n\\n    int getMax(vector<int> piles)\\n    {\\n        int maxPile = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            maxPile = max(piles[i], maxPile);\\n        }\\n\\n        return maxPile;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // the main idea is to search among all possible speed of eating\\n    int minEatingSpeed(vector<int>& piles, int h) \\n    {\\n        int left = 1; // minimum speed is 1 banana per hour\\n        int right = getMax(piles); // maximum speed is the amount of bananas in the biggest pile\\n        \\n        // using binary search to find the minimum speed of all possible Koko\\'s eating speed values\\n        while (left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            long hoursRequired = calculateHours(piles, mid);\\n\\n            // if Koko eats faster than required or as required, than we should look among lower speed values\\n            // there might be a value of speed that satisfies the conditions better (the minimal speed)\\n            if (hoursRequired <= h)\\n            {\\n                right = mid - 1;\\n            }\\n            // if Koko eats slower than required, than we should look among higher speed values\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    // calculating required hours amount for eating speed from parameter\\n    long calculateHours(vector<int>& piles, int speed)\\n    {\\n        long spentHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            spentHours += piles[i] / speed;\\n            if (piles[i] % speed != 0)\\n            {\\n                spentHours++;\\n            }\\n        }\\n        return spentHours;\\n    }\\n\\n    int getMax(vector<int> piles)\\n    {\\n        int maxPile = 0;\\n        for(int i = 0; i < piles.size(); i++)\\n        {\\n            maxPile = max(piles[i], maxPile);\\n        }\\n\\n        return maxPile;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887223,
                "title": "simple-and-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findmaxi(vector<int>& piles){\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<piles.size();i++){\\n            maxi = max(maxi,piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    double calaculateTotalHours(vector<int>& piles,int hourly){\\n        double totalh = 0;\\n        for(int i = 0;i<piles.size();i++){\\n            totalh += ceil((double)piles[i]/(double)hourly);\\n        }\\n        return totalh;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 0, high = findmaxi(piles);\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            double totalH = calaculateTotalHours(piles,mid);\\n            if(totalH <= h){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findmaxi(vector<int>& piles){\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<piles.size();i++){\\n            maxi = max(maxi,piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    double calaculateTotalHours(vector<int>& piles,int hourly){\\n        double totalh = 0;\\n        for(int i = 0;i<piles.size();i++){\\n            totalh += ceil((double)piles[i]/(double)hourly);\\n        }\\n        return totalh;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low = 0, high = findmaxi(piles);\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            double totalH = calaculateTotalHours(piles,mid);\\n            if(totalH <= h){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834236,
                "title": "simple-easy-binary-search",
                "content": "\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    n = max of array\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` c++ [0]\\nclass Solution {\\npublic:\\n    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour)\\n    {\\n        long long totalHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);\\n            totalHours += hoursToEatPile;\\n        }\\n        return totalHours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int targetHours)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int low = 1, high = *(max_element(piles.begin(), piles.end()));\\n        int ans = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long hoursToEatAll = getHoursToEatAll(piles, mid);\\n            \\n            if (hoursToEatAll <= targetHours)\\n            {\\n                ans = mid; //record the answer (this is the best we could record till curr step)\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n``` Python [0]\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        if len(piles) == h:\\n            return max(piles)\\n        \\n        left, right = 1, max(piles)\\n\\n        ans = -1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if sum([ceil(i/mid) for i in piles]) > h:\\n                left = mid + 1\\n            else:\\n                ans = mid\\n                right = mid - 1\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` c++ [0]\\nclass Solution {\\npublic:\\n    long long getHoursToEatAll(vector<int>&piles, int bananasPerHour)\\n    {\\n        long long totalHours = 0;\\n        for (int i = 0; i < piles.size(); i++)\\n        {\\n            int hoursToEatPile = ceil(piles[i] / (double)bananasPerHour);\\n            totalHours += hoursToEatPile;\\n        }\\n        return totalHours;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int targetHours)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int low = 1, high = *(max_element(piles.begin(), piles.end()));\\n        int ans = -1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long hoursToEatAll = getHoursToEatAll(piles, mid);\\n            \\n            if (hoursToEatAll <= targetHours)\\n            {\\n                ans = mid; //record the answer (this is the best we could record till curr step)\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n``` Python [0]\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        if len(piles) == h:\\n            return max(piles)\\n        \\n        left, right = 1, max(piles)\\n\\n        ans = -1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if sum([ceil(i/mid) for i in piles]) > h:\\n                left = mid + 1\\n            else:\\n                ans = mid\\n                right = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746885,
                "title": "python-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        right, left = max(piles), 1\\n        while left < right:\\n            middle = (left + right) // 2\\n            count = 0\\n            for each in piles:\\n                count += ceil(each / middle)\\n            if count > h:\\n                left = middle + 1\\n            else:\\n                right = middle\\n        return left\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        right, left = max(piles), 1\\n        while left < right:\\n            middle = (left + right) // 2\\n            count = 0\\n            for each in piles:\\n                count += ceil(each / middle)\\n            if count > h:\\n                left = middle + 1\\n            else:\\n                right = middle\\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691381,
                "title": "easy-python-solution-using-binary-search-beginners-friendly",
                "content": "# Code\\n```\\nimport math\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        a = 1\\n        b=max(piles)\\n        while a<b:\\n            mid=(a+b)//2\\n            c=0\\n            for j in piles:\\n                c+=math.ceil(j/mid)\\n            if c>h:\\n                a=mid+1\\n            else:\\n                b=mid\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        a = 1\\n        b=max(piles)\\n        while a<b:\\n            mid=(a+b)//2\\n            c=0\\n            for j in piles:\\n                c+=math.ceil(j/mid)\\n            if c>h:\\n                a=mid+1\\n            else:\\n                b=mid\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683961,
                "title": "python3-c-brute-force-optimal-full-explanation",
                "content": "### Koko Eating Bananas\\n\\nReturn *the minimum integer* `k` *such that she can eat all the bananas within* `h` *hours*.\\n\\n**Example 1:**\\n\\nInput: piles = [3,6,7,11], h = 8\\nOutput: 4\\n\\n**Example 2:**\\n\\nInput: piles = [30,11,23,4,20], h = 5\\nOutput: 30\\n\\n**Example 3:**\\n\\nInput: piles = [30,11,23,4,20], h = 6\\nOutput: 23\\n\\n- Approach\\n    - Brute-force\\n        - Minimum time will be taken when koko eats `max(piles)` bananas each hour and total hours taken will be `len(piles)` hours and maximum time will be taken when koko eats 1 banana per hour\\n        - Thus for every number in range `1` to `max(piles)`, we calculate hours taken and if it is < h, then return it\\n        - Time Complexity: $O(n * max(piles))$\\n        - Space Complexity: $O(1)$\\n    - Optimal\\n        - Binary Search between 1 and max(piles)\\n        - Time Complexity: $O(n * log(max(piles)))$\\n        - Space Complexity: $O(1)$\\n\\n```python\\n# Python3\\n# Brute-force Solution\\nfrom math import ceil\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        for i in range(1, max(piles) + 1):\\n            hrs = 0\\n            for j in range(len(piles)):\\n                hrs += ceil(piles[j] / i)\\n            if hrs <= h:\\n                return i\\n        return -1\\n```\\n\\n```python\\n# Python3\\n# Optimal Solution\\nfrom math import ceil\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l = 1\\n        r = max(piles)\\n        \\n        while l <= r:\\n            mid = (l + r) // 2\\n            s = 0\\n            for i in piles:\\n                s += ceil(i / mid)\\n            if s <= h:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```\\n\\n```cpp\\n// C++\\n// Optimal Solution\\n#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int find_max(vector<int>& piles) {\\n        int maxi = piles[0];\\n        for (int i = 1; i < piles.size(); i++) {\\n            maxi = max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l = 1, r = find_max(piles);\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            long long hrs = 0;\\n            for (int i = 0; i < piles.size(); i++) {\\n                hrs += ceil(double(piles[i]) / double(mid));\\n            }\\n            if (hrs <= h) {\\n                r = mid - 1;\\n            }\\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python\\n# Python3\\n# Brute-force Solution\\nfrom math import ceil\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        for i in range(1, max(piles) + 1):\\n            hrs = 0\\n            for j in range(len(piles)):\\n                hrs += ceil(piles[j] / i)\\n            if hrs <= h:\\n                return i\\n        return -1\\n```\n```python\\n# Python3\\n# Optimal Solution\\nfrom math import ceil\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l = 1\\n        r = max(piles)\\n        \\n        while l <= r:\\n            mid = (l + r) // 2\\n            s = 0\\n            for i in piles:\\n                s += ceil(i / mid)\\n            if s <= h:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```\n```cpp\\n// C++\\n// Optimal Solution\\n#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int find_max(vector<int>& piles) {\\n        int maxi = piles[0];\\n        for (int i = 1; i < piles.size(); i++) {\\n            maxi = max(maxi, piles[i]);\\n        }\\n        return maxi;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int l = 1, r = find_max(piles);\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            long long hrs = 0;\\n            for (int i = 0; i < piles.size(); i++) {\\n                hrs += ceil(double(piles[i]) / double(mid));\\n            }\\n            if (hrs <= h) {\\n                r = mid - 1;\\n            }\\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3643392,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to find the minimum eating speed required to eat all the piles of bananas within a given number of hours. Each pile has a certain number of bananas, and the eating speed represents the number of bananas that can be eaten per hour.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a binary search approach to find the minimum eating speed. It starts by initializing the variables low and high. low is set to 1, representing the minimum possible eating speed, while high is set to the maximum value among all the piles, representing the maximum possible eating speed.\\n\\nThe binary search is performed within the range of low to high. In each iteration, it calculates the mid-point k using the formula low + (high - low) / 2, which ensures that the mid-point is always rounded down. The mid-point represents the current eating speed to be tested.\\n\\nFor each eating speed k, the code calculates the number of hours required to eat all the piles by iterating through each pile and accumulating the hours using the formula hours += ceil((double)piles[i] / k). The ceil function is used to ensure that even if the division results in a fractional value, it is rounded up to the next integer.\\n\\nIf the calculated hours (hours) are less than or equal to the given number of hours (h), it means that the eating speed is sufficient to eat all the piles within the given time constraint. In this case, the code updates the result variable with the minimum of the current result and k to keep track of the minimum eating speed found so far. Then, it updates high to k - 1 to search for even smaller eating speeds in the next iteration.\\n\\nIf the calculated hours are greater than h, it means that the eating speed is too slow to eat all the piles within the given time constraint. In this case, the code updates low to k + 1 to search for larger eating speeds in the next iteration.\\n\\nThe binary search continues until low becomes greater than high, indicating that the search space has been exhausted.\\n\\nFinally, the minimum eating speed (result) is returned as the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code performs a binary search on the range of possible eating speeds, which has a logarithmic time complexity of O(log(high - low)). Within each iteration, it calculates the number of hours required, which involves iterating through each pile once. Thus, the overall time complexity is O(n log m), where n is the number of piles and m is the maximum value among all the piles.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1), as the code only uses a constant amount of extra space for the variables n, low, high, result, hours, and k. The space usage does not depend on the input size.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n= piles.size();\\n        int low=1;\\n        int high=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            high=max(high,piles[i]);\\n        }\\n        int result= high;\\n        while(low<=high){\\n            long int hours=0;\\n            int k= low+ (high-low)/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                hours+=ceil((double)piles[i]/k);\\n            }\\n            if(hours<=h)\\n            {\\n                result=min(result,k);\\n                high=k-1;\\n            }\\n            else\\n            low=k+1;\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n= piles.size();\\n        int low=1;\\n        int high=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            high=max(high,piles[i]);\\n        }\\n        int result= high;\\n        while(low<=high){\\n            long int hours=0;\\n            int k= low+ (high-low)/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                hours+=ceil((double)piles[i]/k);\\n            }\\n            if(hours<=h)\\n            {\\n                result=min(result,k);\\n                high=k-1;\\n            }\\n            else\\n            low=k+1;\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621532,
                "title": "c-easy-to-understand-binary-search-clean-code",
                "content": "# Intuition\\nApply Binary search on the possible values of K which lies from 1 to maximum element of the array to search the minimum value of K.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(h))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int l=1;\\n        double sum;\\n        int ans;\\n        int r=INT_MIN;\\n        for(int i=0;i<n;i++)\\n            r=max(r,piles[i]);\\n        while(l<=r)\\n        {\\n            sum=0;\\n            int mid=l+(r-l)/2;\\n            for(int i=0;i<n;i++)\\n                sum+=ceil((double)piles[i]/mid);\\n\\n            if(sum<=h)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n=piles.size();\\n        int l=1;\\n        double sum;\\n        int ans;\\n        int r=INT_MIN;\\n        for(int i=0;i<n;i++)\\n            r=max(r,piles[i]);\\n        while(l<=r)\\n        {\\n            sum=0;\\n            int mid=l+(r-l)/2;\\n            for(int i=0;i<n;i++)\\n                sum+=ceil((double)piles[i]/mid);\\n\\n            if(sum<=h)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607103,
                "title": "binary-search-python-readable-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def check(x):\\n            return sum(ceil(ele/x) for ele in piles) <= h\\n\\n        l = 1\\n        r = max(piles)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def check(x):\\n            return sum(ceil(ele/x) for ele in piles) <= h\\n\\n        l = 1\\n        r = max(piles)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503832,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        int leftPtr = 1;\\n        int rightPtr = 0;\\n        int answer = 0;\\n\\n        for(const int& pile : piles)\\n        {\\n            rightPtr = std::max(rightPtr, pile);\\n        }\\n        while(leftPtr <= rightPtr)\\n        {\\n            double mid = leftPtr + (rightPtr - leftPtr) / 2;\\n            long long hoursToEatBananas = 0;\\n            for(const int& pile : piles)\\n            {\\n                hoursToEatBananas += static_cast<int>(std::ceil(pile / mid));\\n            }\\n            if(hoursToEatBananas <= h)\\n            {\\n                rightPtr = mid - 1;\\n                answer = mid;\\n            }\\n            else\\n            {\\n                leftPtr = mid + 1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        Sum = sum(piles)\\n        l = ceil(Sum/h)\\n        r = ceil(Sum/(h-len(piles)+1))\\n        while l<r:\\n            m = (l+r)//2\\n            t = 0\\n            for pile in piles:\\n                t+=ceil(pile/m)\\n            if t>h:\\n                l=m+1\\n            else:\\n                r=m\\n        return l\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic boolean findHour(int[] piles, int h, int k) {\\n\\t\\tint v = k - 1;\\n\\t\\tfor (int p : piles) {\\n\\t\\t\\th -= (int)((p + v) / (double)k);\\n\\t\\t\\tif (h < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tpublic int minEatingSpeed(int[] piles, int h) {\\n\\t\\tint n = piles.length;\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int p : piles) {\\n\\t\\t\\tsum += p;\\n\\t\\t}\\n\\t\\tint left = (int)(sum / h);\\n\\t\\tint right = (int)(sum / (h - n + 1));\\n\\t\\tint middle = 0;\\n\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tmiddle = left + right >>> 1;\\n\\t\\t\\tif (findHour(piles, h, middle)) {\\n\\t\\t\\t\\tright = middle - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tleft = middle + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn left;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        \\n        int leftPtr = 1;\\n        int rightPtr = 0;\\n        int answer = 0;\\n\\n        for(const int& pile : piles)\\n        {\\n            rightPtr = std::max(rightPtr, pile);\\n        }\\n        while(leftPtr <= rightPtr)\\n        {\\n            double mid = leftPtr + (rightPtr - leftPtr) / 2;\\n            long long hoursToEatBananas = 0;\\n            for(const int& pile : piles)\\n            {\\n                hoursToEatBananas += static_cast<int>(std::ceil(pile / mid));\\n            }\\n            if(hoursToEatBananas <= h)\\n            {\\n                rightPtr = mid - 1;\\n                answer = mid;\\n            }\\n            else\\n            {\\n                leftPtr = mid + 1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        Sum = sum(piles)\\n        l = ceil(Sum/h)\\n        r = ceil(Sum/(h-len(piles)+1))\\n        while l<r:\\n            m = (l+r)//2\\n            t = 0\\n            for pile in piles:\\n                t+=ceil(pile/m)\\n            if t>h:\\n                l=m+1\\n            else:\\n                r=m\\n        return l\\n```\n```Java []\\nclass Solution {\\n\\tpublic boolean findHour(int[] piles, int h, int k) {\\n\\t\\tint v = k - 1;\\n\\t\\tfor (int p : piles) {\\n\\t\\t\\th -= (int)((p + v) / (double)k);\\n\\t\\t\\tif (h < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tpublic int minEatingSpeed(int[] piles, int h) {\\n\\t\\tint n = piles.length;\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int p : piles) {\\n\\t\\t\\tsum += p;\\n\\t\\t}\\n\\t\\tint left = (int)(sum / h);\\n\\t\\tint right = (int)(sum / (h - n + 1));\\n\\t\\tint middle = 0;\\n\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tmiddle = left + right >>> 1;\\n\\t\\t\\tif (findHour(piles, h, middle)) {\\n\\t\\t\\t\\tright = middle - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tleft = middle + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn left;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283789,
                "title": "java-clean-code-solution-using-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(Nlog(N))\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] arr, int h) {\\n       \\n        int end=-1;\\n        int fin=0;\\n        for(int i=0;i<arr.length;i++){\\n            end=end>arr[i]?end:arr[i];\\n        }\\n        int start=0;\\n        int ans=start+(end-start)/2;\\n        while(start<=end){\\n            ans=start+(end-start)/2;\\n            if(!check(arr,h,ans)){\\n                start=ans+1;\\n            }\\n            else{\\n                fin=ans;\\n                end=ans-1;\\n            }\\n        }\\n        return fin;\\n    }\\n    static boolean check(int []arr,int h,int ans){\\n        double sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=Math.ceil((double)arr[i]/(double)ans);\\n        \\n        if(sum>h){\\n            return false;\\n        }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] arr, int h) {\\n       \\n        int end=-1;\\n        int fin=0;\\n        for(int i=0;i<arr.length;i++){\\n            end=end>arr[i]?end:arr[i];\\n        }\\n        int start=0;\\n        int ans=start+(end-start)/2;\\n        while(start<=end){\\n            ans=start+(end-start)/2;\\n            if(!check(arr,h,ans)){\\n                start=ans+1;\\n            }\\n            else{\\n                fin=ans;\\n                end=ans-1;\\n            }\\n        }\\n        return fin;\\n    }\\n    static boolean check(int []arr,int h,int ans){\\n        double sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=Math.ceil((double)arr[i]/(double)ans);\\n        \\n        if(sum>h){\\n            return false;\\n        }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279721,
                "title": "optimized-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int st=1;\\n        int end=1000000000;\\n        int mid;\\n\\n        while(st<=end){\\n            mid=st+(end-st)/2;\\n            if(kokoEatsAll(piles,h,mid)) end=mid-1;\\n            else st=mid+1;\\n        }\\n        return st;\\n    }\\n    public boolean kokoEatsAll(int[] piles, int h, int k){\\n        int sum=0;\\n   \\n        for(int pile:piles){\\n            sum+=pile/k;\\n\\n            if(pile%k!=0) sum++;\\n            if(sum>h) return false;\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int st=1;\\n        int end=1000000000;\\n        int mid;\\n\\n        while(st<=end){\\n            mid=st+(end-st)/2;\\n            if(kokoEatsAll(piles,h,mid)) end=mid-1;\\n            else st=mid+1;\\n        }\\n        return st;\\n    }\\n    public boolean kokoEatsAll(int[] piles, int h, int k){\\n        int sum=0;\\n   \\n        for(int pile:piles){\\n            sum+=pile/k;\\n\\n            if(pile%k!=0) sum++;\\n            if(sum>h) return false;\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273879,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int s=1,e=1000000000,mid=0,tot;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            tot=0;\\n            for(auto p:piles)\\n                tot+=(p+mid-1)/mid;\\n     \\n            if(tot>h)\\n            s=mid+1;\\n            else \\n            e=mid;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int s=1,e=1000000000,mid=0,tot;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            tot=0;\\n            for(auto p:piles)\\n                tot+=(p+mid-1)/mid;\\n     \\n            if(tot>h)\\n            s=mid+1;\\n            else \\n            e=mid;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273690,
                "title": "python3-very-easy-solution-uwu",
                "content": "\\n```\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        lo, hi = 1, max(piles)\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if sum((p-1) // mid + 1 for p in piles) > h:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        \\n        return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def minEatingSpeed(self, piles, h):\\n        lo, hi = 1, max(piles)\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if sum((p-1) // mid + 1 for p in piles) > h:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        \\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273300,
                "title": "c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBinary search on minimum and maximum possible banana to be eaten\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(max_element(array)))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start=1;\\n        int end=*max_element(piles.begin(),piles.end());\\n        int ans=INT_MAX;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int flag=0;\\n            long long hrs=0;\\n            for(int i=0;i<piles.size();i++){\\n                hrs+=ceil(piles[i]*1.0/mid*1.0);\\n                if(hrs>h){\\n                    start=mid+1;\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(!flag){\\n                end=mid-1;\\n                ans=min(mid,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start=1;\\n        int end=*max_element(piles.begin(),piles.end());\\n        int ans=INT_MAX;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int flag=0;\\n            long long hrs=0;\\n            for(int i=0;i<piles.size();i++){\\n                hrs+=ceil(piles[i]*1.0/mid*1.0);\\n                if(hrs>h){\\n                    start=mid+1;\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(!flag){\\n                end=mid-1;\\n                ans=min(mid,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273198,
                "title": "c-binary-search-beginner-friendly-faster-than-98-85-with-special-trick",
                "content": "# Approach\\nThe major optimization is the maximum value of high will not be more than maximum value in the piles array. This improves the speed by a larger extent.\\n\\nTrick:\\n`high=*max_element(piles.begin(),piles.end());`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int chk(vector<int>& piles, int mid) {\\n        int tot=0;\\n        for(auto x:piles) {\\n            tot+=ceil(1.0*x/mid);\\n        }    \\n        return tot;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int low=1,high=*max_element(piles.begin(),piles.end());\\n        while(low<high) {\\n            int mid=low+(high-low)/2;              \\n            if(chk(piles,mid)>h)\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int chk(vector<int>& piles, int mid) {\\n        int tot=0;\\n        for(auto x:piles) {\\n            tot+=ceil(1.0*x/mid);\\n        }    \\n        return tot;\\n    }\\n    \\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int low=1,high=*max_element(piles.begin(),piles.end());\\n        while(low<high) {\\n            int mid=low+(high-low)/2;              \\n            if(chk(piles,mid)>h)\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273136,
                "title": "kotlin-binary-search-easy-concise-solution-explanation",
                "content": "# Intuition\\n   The naive approach is trying to iterate over eating speed starting from 1 till we got the number of hours when guards are back. The calculation of the number of hours we need to spend with some eating speed `k` is a sum of hours for every pile `val hoursToEat = piles.map { (it - 1) / k + 1 }.sum()` which has $$O(N)$$ time complexity, where N is number of piles. Hence, overall complexity will be `quadratic`. The trick with calculation of next up integer (`(it - 1) / mid + 1`) is well described [here](https://stackoverflow.com/questions/19689128/how-to-round-up-to-the-next-integer/19689196#19689196)\\n   So, how can we reduce time complexity?\\n   The initial thinking process was to reduce the number of times to calculate `hoursToEat`. We can approach it with binary search, hence complexity will be logarithmic. The main idea is to get some maximum top value (`right`) of eating speed `k` and try to calculate the number of hours to eat with this speed. If it\\'s bigger than `h`(amount of hours when guards are back) it means we need to increase eating speed to decrease the number of hours. If it\\'s not bigger than `h`, hence we need to decrease the number of hours by decreasing eating speed to achieve the `minimum` possible value of eating speed.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- specify `left` and `right` variables for binary search which would stand for eating speed which we are about to find\\n- use binary search and calculate the number of hours for the `mid` value which is needed for eating all bananas\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(NLogM)$$ where `N` is the size of piles and `M` is the largest value in piles;\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    fun minEatingSpeed(piles: IntArray, h: Int): Int {\\n        var left = 1\\n        var right = piles.max()!!\\n        while (left < right) {\\n            val mid = left + (right - left) / 2\\n            val hoursToEat = piles.map { (it - 1) / mid + 1 }.sum()\\n            if (hoursToEat > h) left = mid + 1 else right = mid\\n        }\\n        return left      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    fun minEatingSpeed(piles: IntArray, h: Int): Int {\\n        var left = 1\\n        var right = piles.max()!!\\n        while (left < right) {\\n            val mid = left + (right - left) / 2\\n            val hoursToEat = piles.map { (it - 1) / mid + 1 }.sum()\\n            if (hoursToEat > h) left = mid + 1 else right = mid\\n        }\\n        return left      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272888,
                "title": "rust-c-short-sweet",
                "content": "```Rust []\\nimpl Solution {\\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\\n        let (mut i, mut j) : (i32, i32) = (1,  *piles.iter().max().unwrap());\\n        // small optimization : just take max from Vec if Vec.len() == h \\n        if piles.len() == h as usize {return j};\\n        while(i < j){\\n            let mid = i + ((j - i) / 2);\\n            if piles.iter().fold(0, |temp_h, &el| temp_h + (((el as f64) / mid as f64).ceil() as i32)) > h {\\n                i = mid + 1;  \\n            } else { j = mid; }\\n        }\\n        i\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\nprivate:\\n    int sz;\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sz = piles.size(); \\n        int j = *max_element(piles.begin(), piles.end());\\n        // small optimization : just take max from vector if vector.size() == h \\n        if(sz == h) return j;\\n        int i = 1;\\n        while(i < j){\\n            int temp_h = 0;\\n            int mid = i + ((j - i) / 2);\\n            for(int k = 0; k < sz; ++k)\\n                temp_h += ceil((double)piles[k] / mid);\\n            \\n            if (temp_h > h) i = mid + 1;\\n            else j = mid;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Rust",
                    "Binary Search"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\\n        let (mut i, mut j) : (i32, i32) = (1,  *piles.iter().max().unwrap());\\n        // small optimization : just take max from Vec if Vec.len() == h \\n        if piles.len() == h as usize {return j};\\n        while(i < j){\\n            let mid = i + ((j - i) / 2);\\n            if piles.iter().fold(0, |temp_h, &el| temp_h + (((el as f64) / mid as f64).ceil() as i32)) > h {\\n                i = mid + 1;  \\n            } else { j = mid; }\\n        }\\n        i\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    int sz;\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sz = piles.size(); \\n        int j = *max_element(piles.begin(), piles.end());\\n        // small optimization : just take max from vector if vector.size() == h \\n        if(sz == h) return j;\\n        int i = 1;\\n        while(i < j){\\n            int temp_h = 0;\\n            int mid = i + ((j - i) / 2);\\n            for(int k = 0; k < sz; ++k)\\n                temp_h += ceil((double)piles[k] / mid);\\n            \\n            if (temp_h > h) i = mid + 1;\\n            else j = mid;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272872,
                "title": "binary-search-same-as-minimum-time-to-complete-trips-problem",
                "content": "**Intuition**\\nLooking at the problem, it can be deduced that the minimum speed at which Koko can eat bananas is 1 and the maximum speed is the maximum number of bananas available in the pile.\\nNow, we have a range of values in which our answer lies. To solve this kind of problem, we can use Binary search.\\nWe can search in the range 1 to maximum speed and update the range according to whether the mid value is enough to eat all bananas or not.\\n![image](https://assets.leetcode.com/users/images/553c7a66-7db7-4805-948f-14f202a8a2ed_1678288717.158244.png)\\n\\n**Example**\\npiles=[4,6,9,7,11] and h= 13\\n=> k can be: 1,2,3,4,5,6,7,8,9,10,11\\n\\nfor binary search the range will be minspeed=1 and maxspeed=11\\n\\n1.\\tmid = (1+11)/2 =5\\n\\t\\t\\tnow for 5 bananas/hour speed. the total number of hours it\\'d take to finish all bananas:\\n```\\n4, 6, 9, 7, 11 \\n1  2  2  2   3  = 10 \\n\\nas 10<13 that means our answer lies in between range minspeed to mid i.e 1 to 5.\\nHence, maxspeed=5\\n```\\n2.mid= (1+5)/2=3\\n\\n\\t4, 6, 9, 7, 11\\n\\t2  2  3  3   4  = 14 \\n\\n\\tas 14>13 hence range would be mid+1 to maxpeed. i.e minspeed=4\\n\\n3.mid=(4+5)/2=4.\\n\\n\\t4, 6, 9, 7, 11\\n\\t1  2  3  2   3  = 11\\n\\tas 11<13, range would become minspeed to mid i.e maxpeed=4.\\n\\tAs minspeed=maxspeed now.\\n\\tHence 4 is the minimum speed \\n\\n```\\nPLEASE upvote if you like my solution . it motivates me lot \\n```\\n![image](https://assets.leetcode.com/users/images/1863510a-6f9c-4c49-9081-bbc71a642a14_1678289092.5429008.png)\\n\\n**Code:**\\n```\\n// Same as \"Minimum time to complete Trips\" Problem\\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1;\\n        int end = INT_MAX;\\n        int ans = 0;\\n        \\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            int currSpeed = mid;                            // speed to eat\\n            \\n            int hours = 0;\\n            for(int i=0; i < piles.size(); i++) {\\n                \\n                // If currSpeed is divisible by number then Number of hours are easy to find,\\n                // else, One more hour is required to eat that pile.\\n                if(piles[i] % currSpeed == 0)   hours += piles[i]/currSpeed;\\n                else                            hours += (piles[i]/currSpeed) + 1;\\n            }\\n            \\n            // If this speed to eat is enough to eat all, then find minimum speed again.\\n            if(hours <= h) {\\n                end = mid-1;\\n                ans = mid;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n        Time complexity: O(nlog(m)), where n=number of piles, m= range of k\\n        Space complexity: O(1)\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n4, 6, 9, 7, 11 \\n1  2  2  2   3  = 10 \\n\\nas 10<13 that means our answer lies in between range minspeed to mid i.e 1 to 5.\\nHence, maxspeed=5\\n```\n```\\nPLEASE upvote if you like my solution . it motivates me lot \\n```\n```\\n// Same as \"Minimum time to complete Trips\" Problem\\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1;\\n        int end = INT_MAX;\\n        int ans = 0;\\n        \\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            int currSpeed = mid;                            // speed to eat\\n            \\n            int hours = 0;\\n            for(int i=0; i < piles.size(); i++) {\\n                \\n                // If currSpeed is divisible by number then Number of hours are easy to find,\\n                // else, One more hour is required to eat that pile.\\n                if(piles[i] % currSpeed == 0)   hours += piles[i]/currSpeed;\\n                else                            hours += (piles[i]/currSpeed) + 1;\\n            }\\n            \\n            // If this speed to eat is enough to eat all, then find minimum speed again.\\n            if(hours <= h) {\\n                end = mid-1;\\n                ans = mid;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n        Time complexity: O(nlog(m)), where n=number of piles, m= range of k\\n        Space complexity: O(1)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272683,
                "title": "java-simple-binary-search-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1,high=0;\\n        for(int x : piles) high = Math.max(high,x);\\n\\n        while(low <= high){\\n            int mid = low +(high - low)/2;\\n            int time = checkTime(piles,mid);\\n\\n            if(time <= h) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n\\n    private int checkTime(int[] arr, int mid){\\n        int time_takes = 0;\\n        for(int x : arr)\\n            time_takes += Math.ceil(x/(double)mid);\\n        return time_takes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1,high=0;\\n        for(int x : piles) high = Math.max(high,x);\\n\\n        while(low <= high){\\n            int mid = low +(high - low)/2;\\n            int time = checkTime(piles,mid);\\n\\n            if(time <= h) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n\\n    private int checkTime(int[] arr, int mid){\\n        int time_takes = 0;\\n        for(int x : arr)\\n            time_takes += Math.ceil(x/(double)mid);\\n        return time_takes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272615,
                "title": "banana-speed-eating-binary-search-for-optimal-eating-speed-a-fully-explained-approach-to-solution",
                "content": "# Intuition\\nWe can use binary search\\n\\n# Approach\\no solve this problem, we can use binary search to find the minimum integer k that satisfies the conditions. We can set the lower bound of the search to 1 (since we can\\'t eat 0 bananas per hour), and the upper bound to the maximum number of bananas in a pile (since we can\\'t eat more bananas than there are in a pile). Then, we can repeatedly calculate the total hours it would take to eat all the bananas at a given speed k, and adjust the lower or upper bound of the search based on whether the total hours is less than or greater than h, respectively.\\nIn this code, we use the ceil() function to round up the result of the division when calculating the total hours, since Koko can\\'t eat a fraction of a banana. Finally, we return the left bound of the search, which will be the minimum integer k that satisfies the conditions.\\n\\n# Complexity\\n- Time complexity:\\nO(n log m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            int total_hours = 0;\\n            for (int pile : piles) {\\n                total_hours += ceil((double)pile / mid);\\n            }\\n            if (total_hours > h) {\\n                left = mid + 1;\\n            }\\n             else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left = 1;\\n        int right = *max_element(piles.begin(), piles.end());\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            int total_hours = 0;\\n            for (int pile : piles) {\\n                total_hours += ceil((double)pile / mid);\\n            }\\n            if (total_hours > h) {\\n                left = mid + 1;\\n            }\\n             else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272444,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int hour) {\\n        int l = 1,h=*max_element(piles.begin(),piles.end());\\n        while(l<h){\\n            double m = (l+h)/2;\\n            int t= 0;\\n            for(auto x:piles) t+=ceil(x/m);\\n            if(t<=hour) h=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n![Web capture_25-2-2023_224944_leetcode.com.jpeg](https://assets.leetcode.com/users/images/5c380cd2-8fa5-4c01-901e-7ab12968e501_1678281019.429373.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int hour) {\\n        int l = 1,h=*max_element(piles.begin(),piles.end());\\n        while(l<h){\\n            double m = (l+h)/2;\\n            int t= 0;\\n            for(auto x:piles) t+=ceil(x/m);\\n            if(t<=hour) h=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271972,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        ll l = 1, r = 1e9;\\n        while(l <= r) {\\n            ll tot = 0, mid = (l + r) / 2;\\n            for(int i=0; i<piles.size(); i++) tot += ceil(1.0 * piles[i] / mid);\\n            if(tot > h) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        ll l = 1, r = 1e9;\\n        while(l <= r) {\\n            ll tot = 0, mid = (l + r) / 2;\\n            for(int i=0; i<piles.size(); i++) tot += ceil(1.0 * piles[i] / mid);\\n            if(tot > h) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271937,
                "title": "875-koko-eating-bananas-java-solution",
                "content": "# Intuition\\nthis approach follows simple binary search and we need to find the minimum capacity to eat bananas in a hour to finish all the bananas in given hours.\\n\\n# Approach\\nhere the main thing we need to find is the lower and upper bound of the array or piles so that to apply binary search\\n\\n$$ Lower$$ $$ Bound :- $$\\nlower bound will be = total no. of bananas in all piles / given hours\\n(this is the lowest capacity to eat bananas to finish in time)\\n\\n$$ Upper $$ $$Bound :-$$\\nupper bound will be the largest pile present as if we eat that much banana in every hour we will require least number of time.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the minEatingSpeed method is $$ O(N $$ $$log M) $$, where n is the length of the piles array and m is the maximum pile size. The for loop that calculates the sum of all the elements in the piles array takes O(n) time. The binary search loop takes O(log m) time because the search space is divided in half in each iteration.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Request \\uD83D\\uDE4F\\uD83E\\uDD7A\\n\\n$$ PLEASE UPVOTE $$  (it takes efforts and time to write solution \\uD83D\\uDC95\\u2764\\uFE0F ) \\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int hours(int []piles, int f)\\n    {\\n        int t=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            if(piles[i]<f)\\n            {\\n                t+=1;\\n            }\\n            else\\n            {\\n                t+=piles[i]/f;\\n                if(piles[i]%f>0)\\n                    t+=1;\\n            }\\n        }\\n        return t;\\n    }\\n    public int minEatingSpeed(int[] piles, int h) {\\n        if(piles.length==1)\\n        {\\n            if(piles[0]<h)\\n                return 1;\\n            else\\n            {\\n                int t= piles[0]/h;\\n                if(piles[0]%h>0)\\n                    return t+1;\\n                return t;\\n            }\\n        }\\n        long s1=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            s1+=piles[i];\\n        }\\n        int s=(int)(s1/h);\\n        Arrays.sort(piles);\\n        int e = piles[piles.length-1];\\n\\n        //APPLYING BINARY SEARCH\\n\\n        while(s<e)\\n        {\\n            int mid = s+(e-s)/2;\\n            if(hours(piles,mid)>h)\\n            {\\n                s=mid+1;\\n            }\\n            else\\n            {\\n                e=mid;\\n            }\\n        }\\n\\n        return s;   \\n    }\\n}\\n```\\n# More EXplanation\\nThis Java code implements a solution to a problem that involves finding the minimum eating speed required for a person to eat all the bananas from a pile of piles within a given number of hours. The algorithm uses binary search to find the minimum eating speed.\\n\\nThe main function is minEatingSpeed, which takes an array piles representing the number of bananas in each pile and an integer h representing the maximum number of hours allowed to eat all the bananas.\\n\\nThe first part of the function deals with the special case where there is only one pile. If the number of bananas in the pile is less than the allowed hours, then the minimum eating speed required is 1. Otherwise, the minimum eating speed is the integer division of the number of bananas by the allowed hours, plus one if there are any leftover bananas.\\n\\nThe next part of the function computes the average number of bananas that need to be eaten per hour by dividing the total number of bananas by the allowed hours. The initial lower bound s for the minimum eating speed is set to this average. The upper bound e is set to the maximum number of bananas in a pile.\\nThe while loop uses binary search to find the minimum eating speed. At each iteration, the middle point between s and e is computed as mid. The function hours is called with piles and mid as arguments to determine how many hours it would take to eat all the bananas at that eating speed. If the result is greater than the allowed hours, the minimum eating speed must be increased, so the lower bound s is updated to mid+1. Otherwise, the maximum eating speed can be decreased, so the upper bound e is updated to mid.\\n\\nWhen the loop terminates, the value of s is the minimum eating speed required to eat all the bananas within the allowed time, so it is returned by the function",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int hours(int []piles, int f)\\n    {\\n        int t=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            if(piles[i]<f)\\n            {\\n                t+=1;\\n            }\\n            else\\n            {\\n                t+=piles[i]/f;\\n                if(piles[i]%f>0)\\n                    t+=1;\\n            }\\n        }\\n        return t;\\n    }\\n    public int minEatingSpeed(int[] piles, int h) {\\n        if(piles.length==1)\\n        {\\n            if(piles[0]<h)\\n                return 1;\\n            else\\n            {\\n                int t= piles[0]/h;\\n                if(piles[0]%h>0)\\n                    return t+1;\\n                return t;\\n            }\\n        }\\n        long s1=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            s1+=piles[i];\\n        }\\n        int s=(int)(s1/h);\\n        Arrays.sort(piles);\\n        int e = piles[piles.length-1];\\n\\n        //APPLYING BINARY SEARCH\\n\\n        while(s<e)\\n        {\\n            int mid = s+(e-s)/2;\\n            if(hours(piles,mid)>h)\\n            {\\n                s=mid+1;\\n            }\\n            else\\n            {\\n                e=mid;\\n            }\\n        }\\n\\n        return s;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271884,
                "title": "day-36-binary-search-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMinimum rate would be 1 if total banana=h and maximum rate would be equal to 1e9 when there is one pile with 1e9 bananas and h=1 hour. We can do a binary search in this range and check which minimum value satisfies the condition.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Note: \\nWe want floor value of hours taken to eat bananas as 1.5 hours for pile means 2 hours as we cannot start with next pile so it takes that full hour as well. Either take ceil(pile*1.0/mid) or the way I did in code to get the ceil value.\\n   > ***Please upvote if this was helpful. Happy coding!***\\n** and Happy Holi.\\uD83D\\uDE1C**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left=1,right=1e9;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            long long time=0;\\n            for(auto i:piles)time+=(i+mid-1)/mid;\\n            if(time>h)left=mid+1;\\n            else right=mid-1;\\n        }\\n        return left;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int left=1,right=1e9;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            long long time=0;\\n            for(auto i:piles)time+=(i+mid-1)/mid;\\n            if(time>h)left=mid+1;\\n            else right=mid-1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271862,
                "title": "koko-eating-bananas-c-easy-approach-fast-simple",
                "content": "**PLEASE UPVOTE, IF YOU LIKE,.\\u2764\\uFE0F\\u2764\\uFE0F **\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& p,int h,int n,int mid){\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(p[i]%mid==0){\\n                x+=(p[i]/mid);\\n            }\\n            else{\\n                x+=(p[i]/mid)+1;\\n            }\\n            if(x>h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& p, int h) {\\n        sort(p.begin(),p.end());\\n        int low=1;\\n        int n=p.size();\\n        int high=p[n-1];\\n        int res=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            // int mid=(low+high)/2;\\n            if(f(p,h,n,mid)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // if(res==INT_MAX) return p[n-1];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>& p,int h,int n,int mid){\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(p[i]%mid==0){\\n                x+=(p[i]/mid);\\n            }\\n            else{\\n                x+=(p[i]/mid)+1;\\n            }\\n            if(x>h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& p, int h) {\\n        sort(p.begin(),p.end());\\n        int low=1;\\n        int n=p.size();\\n        int high=p[n-1];\\n        int res=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            // int mid=(low+high)/2;\\n            if(f(p,h,n,mid)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        // if(res==INT_MAX) return p[n-1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271831,
                "title": "binary-search",
                "content": "# Intuition & Approach\\nhttps://youtu.be/0Vu-cGHm3Hk\\n\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1, hi = maxPiles(piles), k = -1;\\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n\\n            if (numOfHours(mid, piles) <= h) {\\n                k = mid;\\n                hi = mid - 1;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n\\n        return k;\\n    }\\n\\n    long long numOfHours(int k, vector<int>& piles) {\\n        long long totalHours = 0;\\n\\n        for (int pile : piles)\\n            totalHours += (pile + k - 1) / k;\\n        \\n        return totalHours;\\n    }\\n\\n    int maxPiles(vector<int>& piles) {\\n        return *max_element(piles.begin(), piles.end());\\n    }\\n};\\n```\\n# Java\\n```java\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int lo = 1, hi = maxPiles(piles), k = -1;\\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n\\n            if (numOfHours(mid, piles) <= h) {\\n                k = mid;\\n                hi = mid - 1;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n\\n        return k;\\n    }\\n\\n    public long numOfHours(int k, int[] piles) {\\n        long totalHours = 0;\\n\\n        for (int pile : piles)\\n            totalHours += (pile + k - 1) / k;\\n        \\n        return totalHours;\\n    }\\n\\n    public int maxPiles(int[] piles) {\\n        int max = piles[0];\\n        for(int i=1;i<piles.length;i++){\\n            if(piles[i] > max){\\n                max = piles[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n# Python\\n```py\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        lo, hi, k = 1, max(piles), -1\\n        \\n        while lo <= hi:\\n            mid = lo + ((hi - lo) >> 1)\\n\\n            if self.numOfHours(mid, piles) <= h:\\n                k = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n        return k\\n\\n    def numOfHours(self, k: int, piles: List[int]) -> int:\\n        totalHours = 0\\n        for pile in piles:\\n            totalHours += math.ceil(pile / k)\\n\\n        return totalHours\\n```\\n# JS\\n```js\\n/**\\n * @param {number[]} piles\\n * @param {number} h\\n * @return {number}\\n */\\nvar minEatingSpeed = function(piles, h) {\\n    let lo = 1, hi = Math.max(...piles), k = -1;\\n    \\n    while (lo <= hi) {\\n        const mid = lo + ((hi - lo) >> 1);\\n        const numOfHours = piles.reduce((total, pile) => total + Math.ceil(pile / mid), 0);\\n        \\n        if (numOfHours <= h) {\\n            k = mid;\\n            hi = mid - 1;\\n        }\\n        else {\\n            lo = mid + 1;\\n        }\\n    }\\n    \\n    return k;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int lo = 1, hi = maxPiles(piles), k = -1;\\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n\\n            if (numOfHours(mid, piles) <= h) {\\n                k = mid;\\n                hi = mid - 1;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n\\n        return k;\\n    }\\n\\n    long long numOfHours(int k, vector<int>& piles) {\\n        long long totalHours = 0;\\n\\n        for (int pile : piles)\\n            totalHours += (pile + k - 1) / k;\\n        \\n        return totalHours;\\n    }\\n\\n    int maxPiles(vector<int>& piles) {\\n        return *max_element(piles.begin(), piles.end());\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int lo = 1, hi = maxPiles(piles), k = -1;\\n        while (lo <= hi) {\\n            int mid = lo + ((hi - lo) >> 1);\\n\\n            if (numOfHours(mid, piles) <= h) {\\n                k = mid;\\n                hi = mid - 1;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n\\n        return k;\\n    }\\n\\n    public long numOfHours(int k, int[] piles) {\\n        long totalHours = 0;\\n\\n        for (int pile : piles)\\n            totalHours += (pile + k - 1) / k;\\n        \\n        return totalHours;\\n    }\\n\\n    public int maxPiles(int[] piles) {\\n        int max = piles[0];\\n        for(int i=1;i<piles.length;i++){\\n            if(piles[i] > max){\\n                max = piles[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```py\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        lo, hi, k = 1, max(piles), -1\\n        \\n        while lo <= hi:\\n            mid = lo + ((hi - lo) >> 1)\\n\\n            if self.numOfHours(mid, piles) <= h:\\n                k = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n\\n        return k\\n\\n    def numOfHours(self, k: int, piles: List[int]) -> int:\\n        totalHours = 0\\n        for pile in piles:\\n            totalHours += math.ceil(pile / k)\\n\\n        return totalHours\\n```\n```js\\n/**\\n * @param {number[]} piles\\n * @param {number} h\\n * @return {number}\\n */\\nvar minEatingSpeed = function(piles, h) {\\n    let lo = 1, hi = Math.max(...piles), k = -1;\\n    \\n    while (lo <= hi) {\\n        const mid = lo + ((hi - lo) >> 1);\\n        const numOfHours = piles.reduce((total, pile) => total + Math.ceil(pile / mid), 0);\\n        \\n        if (numOfHours <= h) {\\n            k = mid;\\n            hi = mid - 1;\\n        }\\n        else {\\n            lo = mid + 1;\\n        }\\n    }\\n    \\n    return k;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271807,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1;\\n        int high=*max_element(piles.begin(),piles.end());\\n        while(low<=high){\\n            long long int count =0;\\n            int mid=low+(high-low)/2;\\n            for(int i=0;i<piles.size();i++){\\n                if(piles[i]<mid) count++;\\n                else count+=((piles[i]/mid)+(piles[i]%mid!=0));\\n            }\\n            if(count>h) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=1;\\n        int high=*max_element(piles.begin(),piles.end());\\n        while(low<=high){\\n            long long int count =0;\\n            int mid=low+(high-low)/2;\\n            for(int i=0;i<piles.size();i++){\\n                if(piles[i]<mid) count++;\\n                else count+=((piles[i]/mid)+(piles[i]%mid!=0));\\n            }\\n            if(count>h) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271776,
                "title": "c-solution-binary-search-on-answer-explained-solution",
                "content": "# Intuition\\nWe need to minimize the answer so we can create a lower limit and an upper limit on speed and apply binary search on this interval and try to minimize the answer.\\n\\n# Approach\\nWe create a lower limit on speed as 1 and an upper limit on speed which will be the maximum bananas in a pile. Now we apply binary search on this interval and find out the middle element. If that middle element taken as speed satisfies the condition then we store it and search for a better answer in the left interval. If it doesn\\'t satisfy the condition then we check for an answer in the right interval.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) where N is the length of piles array\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int low = 1;\\n        int high = piles[piles.size()-1];\\n        int ans = INT_MAX;\\n        int mid = low+(high-low)/2;\\n        while(low <= high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(check(mid, piles, h))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }else\\n            {\\n                low = mid+1;\\n            }\\n        }      \\n        return ans;\\n    }\\n\\n    bool check(int speed, vector<int>& piles, int h)  //Function to check whether with this speed, all bananas can be eaten or not under h hours\\n    {\\n        int currenthours = 0;\\n        bool valid = true;\\n        for(int i = 0;i < piles.size(); i++)\\n        {\\n            if(piles[i]%speed == 0)\\n            {\\n                currenthours += ((piles[i]/speed));\\n            }else\\n            {\\n                currenthours += ((piles[i]/speed)+1);\\n            }\\n            if(currenthours > h)\\n            {\\n                valid = false;\\n                break;\\n            }\\n        }\\n        return valid;\\n    }\\n};\\n```\\n\\n**Do upvote if you understood it ! \\uD83D\\uDE00\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        sort(piles.begin(), piles.end());\\n        int low = 1;\\n        int high = piles[piles.size()-1];\\n        int ans = INT_MAX;\\n        int mid = low+(high-low)/2;\\n        while(low <= high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(check(mid, piles, h))\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }else\\n            {\\n                low = mid+1;\\n            }\\n        }      \\n        return ans;\\n    }\\n\\n    bool check(int speed, vector<int>& piles, int h)  //Function to check whether with this speed, all bananas can be eaten or not under h hours\\n    {\\n        int currenthours = 0;\\n        bool valid = true;\\n        for(int i = 0;i < piles.size(); i++)\\n        {\\n            if(piles[i]%speed == 0)\\n            {\\n                currenthours += ((piles[i]/speed));\\n            }else\\n            {\\n                currenthours += ((piles[i]/speed)+1);\\n            }\\n            if(currenthours > h)\\n            {\\n                valid = false;\\n                break;\\n            }\\n        }\\n        return valid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271710,
                "title": "c-easiest-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int i = 1, j = 0;\\n        for(int p:piles){\\n            j = max(j,p); //max possible value for k\\n        }\\n        while(i<j){\\n            int m = i+(j-i)/2;\\n            int x = 0;\\n            for(int p:piles){\\n                x += (p+m-1)/m; //calculate how much hours it\\'ll take if k = m\\n            }\\n            if(x>h) i = m+1; //set the min value of k to m+1\\n            else j = m; //set the max value of k to m\\n        }\\n        return i; // i is our required value of k\\n    }\\n};\\nDo Upvote if it helps\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int i = 1, j = 0;\\n        for(int p:piles){\\n            j = max(j,p); //max possible value for k\\n        }\\n        while(i<j){\\n            int m = i+(j-i)/2;\\n            int x = 0;\\n            for(int p:piles){\\n                x += (p+m-1)/m; //calculate how much hours it\\'ll take if k = m\\n            }\\n            if(x>h) i = m+1; //set the min value of k to m+1\\n            else j = m; //set the max value of k to m\\n        }\\n        return i; // i is our required value of k\\n    }\\n};\\nDo Upvote if it helps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271569,
                "title": "java-solution-binary-search-fully-explained-beats-80",
                "content": "# Inituition\\n- We can find the answer easily by \\n    - (sum of all values ) / h \\n- but koko doesnt use decimals and if there is a reminder she will wait for the remaining hour.\\n- This forces us to \\n    1. Use a for loop approach \\n    2. Or use Binary search\\n- Obviously the 2nd option is better. \\n\\n# Approach\\n## Check comments in code for better explaination\\n- Use Binary Search to guess the answer at first then pinpoint it correctly\\n- maxSpeed and minSpeed variables for the max and min values of the Binary search.\\n- Make a function canFinishEating to check if the given speed is enough to eat it all.\\n- Before binary search, if the maxSpeed and minSpeed are equal it means that all values in the piles array are equal, which makes the loop unable to run. \\n- So we can directly give the answer by using the formula.\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public static boolean canFinishEating(double speed, int totalTime, int[] bananas) {\\n        double timeTaken = 0;\\n        for (int i = 0; i < bananas.length; i++) {\\n            // we calculate the time taken\\n            double t = (double) bananas[i] / speed;\\n            // if the time taken is something like 1.5 then \\n            //koko will wait till 2 so we use math. ceil\\n            t = Math.ceil(t);\\n            timeTaken += t;\\n            //we check if the given speed is enough.\\n            if (timeTaken > totalTime)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public static int minEatingSpeed(int[] bananas, int totalTime) {\\n        double maxSpeed = 0;\\n        double minSpeed = Integer.MAX_VALUE;\\n        for (int i = 0; i < bananas.length; i++) {\\n            if (maxSpeed < bananas[i])\\n                maxSpeed = bananas[i];\\n            if (minSpeed > bananas[i])\\n                minSpeed = bananas[i];\\n        }\\n        //minSpeed and maxSpeed are the smallest and the biggest values \\n        //in the array. This will serve us our range for binary search\\n        if (maxSpeed == minSpeed) {\\n            // we come into a problem where all the items are equal \\n            // where maxSpeed == minSpeed, so this will tackle that problem\\n            if (bananas.length <= totalTime && totalTime / bananas.length == 1)\\n                return (int) maxSpeed;\\n            return (int) (Math.ceil((maxSpeed * bananas.length) / totalTime));\\n        }\\n        minSpeed = minSpeed / totalTime;\\n        while (minSpeed < maxSpeed) {\\n            double mid = minSpeed + (maxSpeed - minSpeed) / 2;\\n            if (canFinishEating(mid, totalTime, bananas))\\n                maxSpeed = mid;\\n            else\\n                minSpeed = Math.ceil(mid);\\n        }\\n        return (int) minSpeed;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/7fc848d9-4799-4780-8278-6dbdab2793a4_1678261862.5974212.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean canFinishEating(double speed, int totalTime, int[] bananas) {\\n        double timeTaken = 0;\\n        for (int i = 0; i < bananas.length; i++) {\\n            // we calculate the time taken\\n            double t = (double) bananas[i] / speed;\\n            // if the time taken is something like 1.5 then \\n            //koko will wait till 2 so we use math. ceil\\n            t = Math.ceil(t);\\n            timeTaken += t;\\n            //we check if the given speed is enough.\\n            if (timeTaken > totalTime)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public static int minEatingSpeed(int[] bananas, int totalTime) {\\n        double maxSpeed = 0;\\n        double minSpeed = Integer.MAX_VALUE;\\n        for (int i = 0; i < bananas.length; i++) {\\n            if (maxSpeed < bananas[i])\\n                maxSpeed = bananas[i];\\n            if (minSpeed > bananas[i])\\n                minSpeed = bananas[i];\\n        }\\n        //minSpeed and maxSpeed are the smallest and the biggest values \\n        //in the array. This will serve us our range for binary search\\n        if (maxSpeed == minSpeed) {\\n            // we come into a problem where all the items are equal \\n            // where maxSpeed == minSpeed, so this will tackle that problem\\n            if (bananas.length <= totalTime && totalTime / bananas.length == 1)\\n                return (int) maxSpeed;\\n            return (int) (Math.ceil((maxSpeed * bananas.length) / totalTime));\\n        }\\n        minSpeed = minSpeed / totalTime;\\n        while (minSpeed < maxSpeed) {\\n            double mid = minSpeed + (maxSpeed - minSpeed) / 2;\\n            if (canFinishEating(mid, totalTime, bananas))\\n                maxSpeed = mid;\\n            else\\n                minSpeed = Math.ceil(mid);\\n        }\\n        return (int) minSpeed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271513,
                "title": "java-binary-search-on-answers-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int min=1;\\n        int max=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int ans=Integer.MAX_VALUE;\\n\\n        while(min<=max)\\n        {\\n            int mid=(min+max)/2;\\n            if(valid(mid,piles,h))\\n            {\\n                ans=Math.min(ans,mid);\\n                max=mid-1;\\n            }\\n            else\\n                min=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n    public boolean valid(int temp,int[]piles,int h)\\n    {\\n        int count=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            count+=piles[i]/temp;\\n            if(piles[i]%temp!=0)\\n               count++;\\n               if(count>h)\\n                 return false;\\n        }\\n        return count<=h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int min=1;\\n        int max=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int ans=Integer.MAX_VALUE;\\n\\n        while(min<=max)\\n        {\\n            int mid=(min+max)/2;\\n            if(valid(mid,piles,h))\\n            {\\n                ans=Math.min(ans,mid);\\n                max=mid-1;\\n            }\\n            else\\n                min=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n    public boolean valid(int temp,int[]piles,int h)\\n    {\\n        int count=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            count+=piles[i]/temp;\\n            if(piles[i]%temp!=0)\\n               count++;\\n               if(count>h)\\n                 return false;\\n        }\\n        return count<=h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271362,
                "title": "easy-python-solution-beats-88-of-other-solutions",
                "content": "**Please upvote if you like it.**\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        a = 1\\n        b=max(piles)\\n        while a<b:\\n            mid=(a+b)//2\\n            c=0\\n            for j in piles:\\n                c+=((j-1)//mid)+1\\n            if c>h:\\n                a=mid+1\\n            else:\\n                b=mid\\n        return a",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "**Please upvote if you like it.**\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        a = 1\\n        b=max(piles)\\n        while a<b:\\n            mid=(a+b)//2\\n            c=0\\n            for j in piles:\\n                c+=((j-1)//mid)+1\\n            if c>h:\\n                a=mid+1\\n            else:\\n                b=mid\\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 3271144,
                "title": "python-short-and-clean-binary-search",
                "content": "# Approach\\nNotice that `h >= len(piles)`, which means the eating rate, `k`, doesn\\'t need to be greater than `max(piles)` to finish under `h` hours.\\nLeveraging this, binary search for the optimal `k` in the range `[1, max(piles)]`\\n\\n# Complexity\\n- Time complexity: $$O(n * log(m))$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is number of piles`,\\n`m is number of bananas in the largest pile`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minEatingSpeed(self, piles: list[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        while l < r:\\n            k = (l + r) // 2\\n            hours = sum(ceil(n / k) for n in piles)\\n            l, r = (l, k) if hours <= h else (k + 1, r)\\n        return l\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minEatingSpeed(self, piles: list[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        while l < r:\\n            k = (l + r) // 2\\n            hours = sum(ceil(n / k) for n in piles)\\n            l, r = (l, k) if hours <= h else (k + 1, r)\\n        return l\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271055,
                "title": "simple-solution-99-thought-process-to-get-an-intuition-for-problems-like-this",
                "content": "# Intuition\\nSuppose we had no boundation on time, or $$H$$ hours had such a large value(Infinity) for every test case that koko could eat every pile with as low of a value of $$k$$ as she wanted, what would be the answer? \\nWon\\'t it be just $$1$$ ? \\nBecause you have infinite time, why not take your time and eat at the slowest rate imaginable?\\n\\nAnd on the flip side, what is the minimum value $$H$$ could have for any test case? \\nIt is $$piles.length$$. Even if you assign a value of $$k$$ that would make koko eat any pile in one hour, she would still **only finish one pile in one hour**. Or in other words, you need at least $$piles.length$$ hours for this question to be valid(which is the case).\\n\\nBut what can we infer from that? Doesn\\'t that decide the maximum value of $$k$$ for us?\\nIf the value of $$H$$ were $$piles.length$$, koko would need to finish each pile in an hour. \\nThat will be possible if **she eats at a speed of the maximum size of any pile in the array**, which enables her to finish every pile in $$1$$ hour, to have no leftovers.\\n\\nIf we have a definite range for our answer, what approach do you suggest for optimising our search for $$k$$ ?\\nOr first, can\\'t you just iterate from $$1$$ to $$maxValueOfPiles$$ to check for the lowest value from which you\\'re able to eat all the piles within $$H$$ hours?\\nThat makes sense, and an improvement on our linear search would be ...\\n\\n\\n# Approach\\nWe set ```lo=1``` and ```hi=maximum value of any pile in the array``` for our binary search. In each iteration, ``mid`` will give us the  speed we\\'re trying to check for which we can finish the entire array within ```H``` hours. \\nApart from a standard binary search template, we have to find the condition based on which we decide to update either ```lo``` or ```hi``` pointers. That condition is as simple as:\\n**Given an eating speed of ```mid``` bananas per hour, can koko finish all the bananas in every pile in ```H``` hours?**\\n\\n# Complexity\\n- Time complexity:\\n$$O(N log(hi))$$\\nOur condition function will take $$O(N)$$ time and we will call it for $$log(hi)$$ times. \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        // Find the largest pile\\n        int maxValue = 0;\\n        for (int i : piles) {\\n            maxValue = Math.max(i, maxValue);\\n        }\\n\\n        // Binary search\\n        int lo = 1;\\n        int hi = maxValue;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long hours = calculateHours(piles, mid);\\n//only bit different from a standard binary search\\n            if (hours > H) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    private long calculateHours(int[] piles, int speed) {\\n//we have used a function like this in problems like leetcode 1011\\n//and leetcode 2187\\n        long hours = 0;\\n        for (int pile : piles) {\\n            hours += ((pile - 1) / speed )+ 1;\\n    //(pile - 1) / speed + 1 because we need total time koko\\n    //will spend on a pile having(say) 10 bananas, if her eating \\n    //speed were 3. It would be 4.\\n        }\\n        return hours;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int maxValue = 0;\\n        for(int i : piles) { // find largest number in piles\\n            maxValue = max(i, maxValue);\\n        }\\n        int l = 1;\\n        int h = maxValue;\\n        while(l <= h) {\\n            int mid = l + (h - l) / 2;\\n            if(calculateSum(piles, mid) > H) {\\n                l = mid + 1;\\n            } else {\\n                h = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    long calculateSum(vector<int>& piles, int speed) {\\n        long sum = 0;\\n        for(int pile : piles) {\\n            sum += (pile + speed - 1) / speed;\\n        }\\n        return sum;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        max_val = max(piles)\\n        l = 1\\n        h = max_val\\n        \\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if self.calculate_sum(piles, mid) > H:\\n                l = mid + 1\\n            else:\\n                h = mid - 1\\n                \\n        return l\\n    \\n    def calculate_sum(self, piles: List[int], speed: int) -> int:\\n        total_time = 0\\n        for pile in piles:\\n            total_time += (pile + speed - 1) // speed\\n        return total_time\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search"
                ],
                "code": "```lo=1```\n```hi=maximum value of any pile in the array```\n```H```\n```lo```\n```hi```\n```mid```\n```H```\n```Java []\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int H) {\\n        // Find the largest pile\\n        int maxValue = 0;\\n        for (int i : piles) {\\n            maxValue = Math.max(i, maxValue);\\n        }\\n\\n        // Binary search\\n        int lo = 1;\\n        int hi = maxValue;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long hours = calculateHours(piles, mid);\\n//only bit different from a standard binary search\\n            if (hours > H) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    private long calculateHours(int[] piles, int speed) {\\n//we have used a function like this in problems like leetcode 1011\\n//and leetcode 2187\\n        long hours = 0;\\n        for (int pile : piles) {\\n            hours += ((pile - 1) / speed )+ 1;\\n    //(pile - 1) / speed + 1 because we need total time koko\\n    //will spend on a pile having(say) 10 bananas, if her eating \\n    //speed were 3. It would be 4.\\n        }\\n        return hours;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int H) {\\n        int maxValue = 0;\\n        for(int i : piles) { // find largest number in piles\\n            maxValue = max(i, maxValue);\\n        }\\n        int l = 1;\\n        int h = maxValue;\\n        while(l <= h) {\\n            int mid = l + (h - l) / 2;\\n            if(calculateSum(piles, mid) > H) {\\n                l = mid + 1;\\n            } else {\\n                h = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    long calculateSum(vector<int>& piles, int speed) {\\n        long sum = 0;\\n        for(int pile : piles) {\\n            sum += (pile + speed - 1) / speed;\\n        }\\n        return sum;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        max_val = max(piles)\\n        l = 1\\n        h = max_val\\n        \\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if self.calculate_sum(piles, mid) > H:\\n                l = mid + 1\\n            else:\\n                h = mid - 1\\n                \\n        return l\\n    \\n    def calculate_sum(self, piles: List[int], speed: int) -> int:\\n        total_time = 0\\n        for pile in piles:\\n            total_time += (pile + speed - 1) // speed\\n        return total_time\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270959,
                "title": "java-solution-time-complexity-o-n-log-m-m-is-the-search-space-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    Apply Binary Search logic\\n\\n# Complexity\\n- Time complexity:\\n    - O(n log m), m is the search space (1 to max(piles))\\n\\n- Space complexity:\\n    - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1, high = Integer.MIN_VALUE;\\n\\n        for (int p : piles) {\\n            high = Math.max(p, high);\\n        }\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isBananaPossible(piles, mid, h)) {\\n                high = mid - 1;\\n            }\\n\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n\\n    private boolean isBananaPossible(int[] piles, int k, int h) {\\n        int total = 0;\\n        for (int p : piles) {\\n            total += Math.ceil((double) p / k);\\n        }\\n\\n        return total <= h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int low = 1, high = Integer.MIN_VALUE;\\n\\n        for (int p : piles) {\\n            high = Math.max(p, high);\\n        }\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isBananaPossible(piles, mid, h)) {\\n                high = mid - 1;\\n            }\\n\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n\\n    private boolean isBananaPossible(int[] piles, int k, int h) {\\n        int total = 0;\\n        for (int p : piles) {\\n            total += Math.ceil((double) p / k);\\n        }\\n\\n        return total <= h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270949,
                "title": "breathe-air-and-use-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> This is a simple binary search problem wherein we have to find the optimum time for Koko to finish all piles. Note that for a given speed k, Koko will need ceil(i/k) to finish a pile containing i bananas.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe take the lower limit as 1 and the higher limit as the maximum element in piles, as any higher number doesn\\'t make sense, since we are looking for minimum. We then apply simple binary search and in each iteration of the search, we traverse the array to find if the mid number is a suitable speed. If it is, we store it and look for a lower possible speed and if its not, we go higher.\\n\\n# Complexity\\n- Time complexity: O(n log2(n)).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        long long ans,lo=1,hi=*max_element(piles.begin(),piles.end());\\n        while(lo<=hi){\\n            long long mid=(lo+hi)>>1,time=0;\\n            for(int &i:piles) time+=(i+mid-1)/mid;\\n            if(time<=h) ans=mid,hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        long long ans,lo=1,hi=*max_element(piles.begin(),piles.end());\\n        while(lo<=hi){\\n            long long mid=(lo+hi)>>1,time=0;\\n            for(int &i:piles) time+=(i+mid-1)/mid;\\n            if(time<=h) ans=mid,hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270894,
                "title": "java-simple-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        //binary search\\n        Arrays.sort(piles);\\n        int start = 1;\\n        //taking the largest value possible as end\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i < piles.length;i++){\\n            max = Math.max(max, piles[i]);\\n        }\\n        int end = max;\\n        while(start < end){\\n            int mid = start + (end - start) / 2;\\n            //check whether mid is a possible candidate or not\\n            if(isPossible(piles, mid, h)){\\n                end = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n    public boolean isPossible(int[] piles, int value, int h){\\n        int hours = 0;\\n        int i = 0;\\n        for(int pile : piles){\\n            int div = pile / value;\\n            hours += div;\\n            if(pile % value != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        //binary search\\n        Arrays.sort(piles);\\n        int start = 1;\\n        //taking the largest value possible as end\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i < piles.length;i++){\\n            max = Math.max(max, piles[i]);\\n        }\\n        int end = max;\\n        while(start < end){\\n            int mid = start + (end - start) / 2;\\n            //check whether mid is a possible candidate or not\\n            if(isPossible(piles, mid, h)){\\n                end = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n    public boolean isPossible(int[] piles, int value, int h){\\n        int hours = 0;\\n        int i = 0;\\n        for(int pile : piles){\\n            int div = pile / value;\\n            hours += div;\\n            if(pile % value != 0) hours++;\\n        }\\n        return hours <= h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270757,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool predicate(int mid,vector<int> a,int h,int n){\\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            ct+=(a[i]/mid);\\n            if(a[i]%mid !=0) ct++;\\n        if(ct>h) return false;\\n        }\\n    return true;\\n    }\\n\\n    int minEatingSpeed(vector<int>& a, int h) {\\n      int l =1,r=1e9;\\n      int n = a.size();\\n      while(l<r){\\n          int mid = l+(r-l)/2 ;\\n           if(predicate(mid,a,h,n)){\\n               r= mid;\\n           } \\n           else l = mid+1;\\n      }\\n      return l;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool predicate(int mid,vector<int> a,int h,int n){\\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            ct+=(a[i]/mid);\\n            if(a[i]%mid !=0) ct++;\\n        if(ct>h) return false;\\n        }\\n    return true;\\n    }\\n\\n    int minEatingSpeed(vector<int>& a, int h) {\\n      int l =1,r=1e9;\\n      int n = a.size();\\n      while(l<r){\\n          int mid = l+(r-l)/2 ;\\n           if(predicate(mid,a,h,n)){\\n               r= mid;\\n           } \\n           else l = mid+1;\\n      }\\n      return l;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270738,
                "title": "java-solution-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:$$O(N)$$ +  $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n Here $$N$$ is the max value of Piles.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = Integer.MIN_VALUE;\\n        for(int pile : piles){\\n            right = Math.max(right,pile);\\n        }\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            int time = 0;\\n            for(int pile : piles){\\n                time += pile % mid == 0 ? pile/mid : (pile/mid)+1;\\n            }\\n            if(time > h){\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int left = 1;\\n        int right = Integer.MIN_VALUE;\\n        for(int pile : piles){\\n            right = Math.max(right,pile);\\n        }\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            int time = 0;\\n            for(int pile : piles){\\n                time += pile % mid == 0 ? pile/mid : (pile/mid)+1;\\n            }\\n            if(time > h){\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270645,
                "title": "binary-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int max_element(vector<int>piles){\\n        int max=piles[0];\\n        for(int i=1;i<piles.size();i++){\\n            if(max<piles[i]){\\n                max=piles[i];\\n            }\\n        }\\n        return max;\\n    }\\n    int find(vector<int>piles, int hour){\\n        int sum=0;\\n        for(int i=0; i<piles.size(); i++){\\n            if(piles[i]%hour==0){\\n                sum+=piles[i]/hour;\\n            }\\n            else{\\n                sum+=(piles[i]/hour)+1;\\n            }\\n        }\\n        return sum;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1;\\n        int end = max_element(piles);\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            int currsum = find(piles,mid);\\n            if(currsum<=h){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_element(vector<int>piles){\\n        int max=piles[0];\\n        for(int i=1;i<piles.size();i++){\\n            if(max<piles[i]){\\n                max=piles[i];\\n            }\\n        }\\n        return max;\\n    }\\n    int find(vector<int>piles, int hour){\\n        int sum=0;\\n        for(int i=0; i<piles.size(); i++){\\n            if(piles[i]%hour==0){\\n                sum+=piles[i]/hour;\\n            }\\n            else{\\n                sum+=(piles[i]/hour)+1;\\n            }\\n        }\\n        return sum;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1;\\n        int end = max_element(piles);\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            int currsum = find(piles,mid);\\n            if(currsum<=h){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270602,
                "title": "java-solution-beats-96-binary-search-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n       int left = 1, right = Arrays.stream(piles).max().getAsInt();\\n       while(left<right){\\n           int mid = left + (right - left)/2;\\n           if(CompletesEatingAll(piles,h,mid)) right = mid;\\n           else left = mid + 1;\\n       }  \\n       return left;\\n    }\\n    private boolean CompletesEatingAll(int[]piles,int h,int mid){\\n        int time = 0;\\n        for(int i=0;i<piles.length;i++) time += (piles[i]-1)/mid+1;\\n        if(time>h) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n       int left = 1, right = Arrays.stream(piles).max().getAsInt();\\n       while(left<right){\\n           int mid = left + (right - left)/2;\\n           if(CompletesEatingAll(piles,h,mid)) right = mid;\\n           else left = mid + 1;\\n       }  \\n       return left;\\n    }\\n    private boolean CompletesEatingAll(int[]piles,int h,int mid){\\n        int time = 0;\\n        for(int i=0;i<piles.length;i++) time += (piles[i]-1)/mid+1;\\n        if(time>h) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270580,
                "title": "c-binarysearch-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBinarySearch\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    private bool IsEnough(int[] piles, int k, int h)\\n    {\\n        int hours = 0;\\n\\n        foreach (var pile in piles)\\n        {\\n            hours += (pile + k - 1) / k;\\n        }\\n\\n        return hours <= h;\\n    }\\n\\n    public int MinEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles.Max();\\n\\n        while (l < r)\\n        {\\n            int m = l + (r - l) / 2;\\n\\n            if (IsEnough(piles, m, h))\\n            {\\n                r = m;\\n            }\\n            else\\n            {\\n                l = m + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    private bool IsEnough(int[] piles, int k, int h)\\n    {\\n        int hours = 0;\\n\\n        foreach (var pile in piles)\\n        {\\n            hours += (pile + k - 1) / k;\\n        }\\n\\n        return hours <= h;\\n    }\\n\\n    public int MinEatingSpeed(int[] piles, int h) {\\n        int l = 1;\\n        int r = piles.Max();\\n\\n        while (l < r)\\n        {\\n            int m = l + (r - l) / 2;\\n\\n            if (IsEnough(piles, m, h))\\n            {\\n                r = m;\\n            }\\n            else\\n            {\\n                l = m + 1;\\n            }\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270452,
                "title": "easy-c-solution-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int mid, vector<int> piles, int h) {\\n        int hours = 0;\\n        for(int i=0;i<piles.size();i++) {\\n            hours += (piles[i]/mid);\\n            piles[i] %=mid;\\n            if(piles[i] > 0) hours++;\\n            if(hours > h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1, end = 0, res = -1;\\n        for(int i=0;i<piles.size();i++) {\\n            end = max(end, piles[i]);\\n        }\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(isValid(mid, piles, h)) {\\n                res = mid;\\n                end = mid - 1;\\n            } else start = mid + 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int mid, vector<int> piles, int h) {\\n        int hours = 0;\\n        for(int i=0;i<piles.size();i++) {\\n            hours += (piles[i]/mid);\\n            piles[i] %=mid;\\n            if(piles[i] > 0) hours++;\\n            if(hours > h) return false;\\n        }\\n        return true;\\n    }\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int start = 1, end = 0, res = -1;\\n        for(int i=0;i<piles.size();i++) {\\n            end = max(end, piles[i]);\\n        }\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(isValid(mid, piles, h)) {\\n                res = mid;\\n                end = mid - 1;\\n            } else start = mid + 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1811257,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825809,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1826048,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825949,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825795,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1979799,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1810142,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825674,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1826041,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1576265,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1811257,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825809,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1826048,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825949,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825795,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1979799,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1810142,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1825674,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1826041,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1576265,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "yo what are these guards doing leaving koko unguarded for 823855818 hours?! that\\'s negligence"
                    },
                    {
                        "username": "nadabao",
                        "content": "[@Yashwantptl794](/Yashwantptl794) And the monkey is still alive? She\\'s goddess!!!"
                    },
                    {
                        "username": "abyad04",
                        "content": "he left my koko unguarded for 1000000000 hours\\uD83D\\uDE12"
                    },
                    {
                        "username": "1seostart",
                        "content": "[@Yashwantptl794](/Yashwantptl794) same as koko"
                    },
                    {
                        "username": "Yashwantptl794",
                        "content": "I think the guard is dead"
                    },
                    {
                        "username": "theam10",
                        "content": "Haahahaha\\n"
                    },
                    {
                        "username": "vaibhav_9t4",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDD25"
                    },
                    {
                        "username": "AJReach",
                        "content": "nice one "
                    },
                    {
                        "username": "squigg1e",
                        "content": "Koko\\'s going to be eating those bananas for a long time"
                    },
                    {
                        "username": "mahendra92",
                        "content": "lol dude "
                    },
                    {
                        "username": "I-PJ",
                        "content": "Lol"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "What? it\\'s his vacation leave. "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Sarkari Naukri lg gyi bhai unki\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@AMerrill](/AMerrill) Bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "santanusen",
                        "content": "What about the bananas that don\\'t rot for a million years!"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "koko will die cause of overeating one day."
                    },
                    {
                        "username": "be_quick",
                        "content": "They died by accident and never returned and koko is a special monkey which can leave 10^18 years recently invented by chatgpt. They omitted this information in question so that people wont get demoralized. Hope I answered the question."
                    },
                    {
                        "username": "mhadjiantonis",
                        "content": "94 000 years worth of negligence..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "At least koko has plenty of bananas!"
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "lol!\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "double it and give it to the next monkey."
                    },
                    {
                        "username": "Kmohsen14",
                        "content": "That\\'s an optimal solution lol \\n"
                    },
                    {
                        "username": "mohamedelhosseiny10",
                        "content": "I laughed at this comment more than I should! :D"
                    },
                    {
                        "username": "romedikc",
                        "content": "u made my leetcode time"
                    },
                    {
                        "username": "Rebv18",
                        "content": "bruh \\uD83D\\uDC80"
                    },
                    {
                        "username": "Tejas_Subramanya_k_r",
                        "content": "LoL"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Happy Holi to all LeetCoders \\uD83D\\uDE0A"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Kitne kele khati hai ye koko bc"
                    },
                    {
                        "username": "prakhar1299",
                        "content": "ek purani kahawat suni hogi \"100 kele kha ke koko hajj ko chali\""
                    },
                    {
                        "username": "capNipp",
                        "content": "kuch sikho iss se"
                    },
                    {
                        "username": "2140221",
                        "content": "xdxd"
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Finally, I solved it without seeing any video or discussion or solution \\nit took me 2 hours"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "[@Mister_CK](/Mister_CK) Holy shit, after reading your explanation it makes sense now. Thank you very much."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko ate 161107158 bananas while you solved the problem"
                    },
                    {
                        "username": "Watut1941",
                        "content": "[@sahtsham792](/sahtsham792) How long should one wait before searching for answers? I tried it for almost an hour, and I still couldn\\'t solve it, and now I\\'m here."
                    },
                    {
                        "username": "sahtsham792",
                        "content": "better than giving up after 10 mins and just searching for answers, props"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats! So satisfying when you succeed after spending a lot of time on a problem!!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@Akashkumar_Yadav](/Akashkumar_Yadav) You can think of two boundaries, the slowest speed at which Koko can eat is 1. So that could be your lower bound. The maximum speed at which Koko can eat banana's is the amount in the highest pile. Since she cannot eat from multiple piles at once (so Math.max(...piles)). When you have 2 bounds you can use binary search to check if at the middle of that speed it takes longer than h hours or not. If you take longer, you have to increase the speed else, decrease the spead. A good way to do this is to set your lower bound to your current mid point +1 (and if your to high, set the upper bound to mid point -1). and recalculate your mid point. If you do this inside a while loop until your lower bound is higher than your upper bound you should find the correct solution. For the exact details you might want to look at some examples in the solutions, and then try to do a similar question without looking at that solution, there are a bunch like: 2187. Minimum Time to Complete Trips or 1011. Capacity To Ship Packages Within D Days, which are very similar. Good luck!"
                    },
                    {
                        "username": "Akashkumar_Yadav",
                        "content": "hello , brother can you help me about how you have think that this problem will be solved using binary search\\n"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Am i the only one who couldn\\'t think of any way to start this problem?"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "me too"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Hey, I am koko, i love bananas."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) ..."
                    },
                    {
                        "username": "aditya_101",
                        "content": "aye veerya bat ka grip nikaal ke tere gaaand me\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) bisi \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "take mine tooooooo"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "who\\'s banana coco? \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Don\\'t Worry about guards. Enjoy eating banana koko."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Another binary search problem, wow!\\nI\\'m glad LeetCode decided to focus on this topic this week; I\\'m realizing how weak I was at it before then but these past few days I\\'ve seen myself improving at it."
                    },
                    {
                        "username": "the__doer",
                        "content": "The bigger question is - will coco be able to eat 80553579 in 1 hour or even in 1 life?"
                    },
                    {
                        "username": "joseville",
                        "content": "I was able to solve this problem using binary search, but I was wondering if there\\'s a more mathematical way to solve it and I asked about it on math.stackexchange.com.\\n\\nIf anyone\\'s interested, here\\'s the link:\\n\\nhttps://math.stackexchange.com/q/4361332/833760\\n\\nBest!"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "God amongst human"
                    },
                    {
                        "username": "0mdur",
                        "content": "legend"
                    }
                ]
            },
            {
                "id": 1565643,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1826355,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1877225,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1757763,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1564970,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1688194,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1825750,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1567102,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1906085,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1825728,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/koko-eating-bananas/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "iiiiiiiiiix",
                        "content": "\\u2764\\uFE0F **R.I.P. Koko** (everyone who doesn\\'t know about her should google _Koko the gorilla_).\\nWith her intelligence she could probably solve some LeetCode problems :)\\n\\nCheers to the task authors, you are my soulmates!\\nBest problem statement ever! It makes a heart melt"
                    },
                    {
                        "username": "juxtapo",
                        "content": "I don\\'t understand the question "
                    },
                    {
                        "username": "cennav",
                        "content": "Me neither, I don't feel so bad already"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Hahaha, welcome to a club, guys! "
                    },
                    {
                        "username": "markymarrk",
                        "content": "same here my man"
                    },
                    {
                        "username": "samirhembrom007",
                        "content": "This test case seems to be wrong : [805306368,805306368,805306368]\\nCan someone verify this"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code   count>0 then your code works fine "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "ydt_notfound",
                        "content": "[@RamanV312](/RamanV312) its not out of range but it gives wrong answer for this particular test case\\n"
                    },
                    {
                        "username": "vishalpal1999",
                        "content": "[@RamanV312](/RamanV312) or long in java"
                    },
                    {
                        "username": "RamanV312",
                        "content": "Use long long for count instead of int."
                    },
                    {
                        "username": "baby_groot",
                        "content": "Do you agree ?"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: try binary searching over the solution space. Given a fixed speed k, it is easy to check if Koko can eat all the bananas within h hours. If it works for k, we recurse by setting right = k. Otherwise, we recurse by setting left = k+1."
                    },
                    {
                        "username": "tmdgjs2592",
                        "content": "[@arjun202](/arjun202) It is not necessarily true that, when k*h >= sum, koko can eat all piles."
                    },
                    {
                        "username": "arjun202",
                        "content": "Hey I took your tip and tried to solve the question.. can u let me know where y code or logic is failing? Please\\n\\n\\nclass Solution {\\npublic:\\n//helper function to do binary search on k\\nvoid kokoEatsAllBananas(int lo, int hi,int sum, int h,int &ans){\\n         int k = ceil(lo + (hi-lo)/2);\\n         \\n         if(lo>hi) return;\\n         if(k*h >= sum){\\n            ans = k;\\n            kokoEatsAllBananas(lo,k-1,sum,h,ans);\\n         }\\n         else{\\n             kokoEatsAllBananas(k+1,hi,sum,h,ans);\\n         }\\n         return;\\n}\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n     int size = piles.size();\\n     int sum = 0; for(auto i : piles) sum++;\\n     //k can only range from min[piles] to max[piles]\\n     sort(piles.begin(),piles.end());\\n     int lo = piles[0];\\n     int hi = piles[size-1];\\n     int ans = 0;\\n     kokoEatsAllBananas(lo,hi,sum,h,ans);\\n     return ans;\\n     \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "k is bananas per hour, h is number of hours\\nFor example 1: Given piles = [3,6,7,11], h = 8hrs, if k = 4 ban/hr\\nSince 3 is less than k, only (1hr) is added. The 0th pile took 1 hr;\\nSince 6 is greater than k, Koko can eat k from 6, leaving 6 - k = 2 bananas left and adding (1hr), since 2 is less than 4, add (1hr). The 1st pile took 2 hours.\\nSince 7 > k, 7 - k = 3, add (1hr), 3 < k, add (1hr). The 2nd pile took 2 hours.\\nSince 11 > k, 11 - k = 7, add (1hr), 7 - k = 3, add (1hr), 3 < k, add (1hr). The 3rd pile took 3 hours.\\n\\nFor a total of 1 + 2 + 2 + 3 = 8 hours == h\\nThere\\'s a faster way of doing the above that doesn\\'t involve subtraction.\\n\\nFor example 2: Given piles = [30,11,23,4,20], h = 5, if k = 30 ban/hr.\\nHours Spent = [1, 1, 1, 1, 1]\\n1 + 1 + 1 + 1 + 1 = 5 hours == h\\n\\nFor example 3: Given piles = [30,11,23,4,20], h = 6, if k = 23 ban/hr.\\nHours Spent = [2,1,1,1,1]\\nFor a total of 6 hours == h."
                    },
                    {
                        "username": "Kaleem_Ahmed",
                        "content": "https://leetcode.com/tag/binary-search/discuss/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions"
                    },
                    {
                        "username": "siddhs",
                        "content": "Thank you!.\\nDo you have some more links like this. It will help me in my interview preparation."
                    },
                    {
                        "username": "ashokesen02",
                        "content": "So for this problem I initially chose the range for Binary Search to be [1....10^9] with low=1 and high=10^9 but this gives wrong answer for only one case where  piles =[805306368,805306368,805306368] and h= 1000000000, where the expected output is 3 but my code gives 1. Upon substituting the value of high with max value of the array , it passes all test cases. Can anybody please tell me why this happened?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "add this condition in your code count>0 then your code works fine"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Wishing you all a very Happy Holi filled with love and programming success."
                    }
                ]
            },
            {
                "id": 1987965,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1980785,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1937865,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1740170,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1970862,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1958314,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1954615,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1826388,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1826230,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1826077,
                "content": [
                    {
                        "username": "agforero",
                        "content": "monke"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "Is anybody getting wrong ans for Test case 124/125 \\npiles[]= [805306368,805306368,805306368] and h=1000000000"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "[@saakshikobarne](/saakshikobarne)  I was using the binary search to calculate the time koko takes to eat the bananas but i was using time<=h as a checking parameter instead i used (time<= h && time>0) , this resolved this testcase for me!"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Yes, I had the same doubt, I did it with my binary search code but it was not working on this testcase only and when I used the exact same code from a solution post it was working fine. I didn\\'t get it why but the code and mine were exactly the same still mine was failing this testcase."
                    },
                    {
                        "username": "_aavash_",
                        "content": "for piles = [805306368,805306368,805306368], h= 1000000000, output is 1 but expected is 3. Please help \\n\\nclass Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        long start = 1;\\n        long end = 0;\\n        long sum=0;\\n\\n        for (int i = 0; i < piles.length; i++) {\\n            end = Math.max(piles[i], end);\\n            sum+= piles[i];\\n        }\\n        long ans = -1;\\n\\n        while (start <= end) {\\n            long mid = start + (end - start) / 2;\\n            int value = 0;\\n\\n            for (int i = 0; i < piles.length; i++) {\\n                value += (int) Math.ceil((double) piles[i] / mid);\\n            }\\n\\n            if (value > h) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@idkbro191](/idkbro191) I didn\\'t understand brother.\\n\\nEven if we cast or not, we\\'re anyway storing the value in int only, then how it works?"
                    },
                    {
                        "username": "idkbro191",
                        "content": "You must not cast the result of \"value\" into int before adding it as it goes out of the range of int:\n\n\"value += (int) Math.ceil((double) piles[i] / mid);\"\n\nRemove (int) and it should work fine. \n\n\"value += Math.ceil((double) piles[i] / mid);\""
                    },
                    {
                        "username": "Sggirb",
                        "content": "In the binary search solution, the runtime analysis seems to be O(nlog(k)) where n = number of piles and k = maximum bananas in a pile. Though, if k is bound by the constraint: 1 <= k <= 10^9 as stated in the problem statement, then could it be considered a constant? It doesn\\'t scale in any way as the input size does (n). If that\\'s the case, then shouldn\\'t the binary search solution be O(n)? (O(nlog(k)) -> O(nlog(10^9)) ~ O(n*30) -> O(n))"
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@jcmf](/jcmf) bro you are literally bigger bot than chatgpt"
                    },
                    {
                        "username": "jcmf",
                        "content": "Oh geez, you are so right about this, don\\'t get me started. More generally, the log base 2 of any 64-bit integer is bounded above by 64, a reasonably small constant. Why, then, does anyone ever bother including factors of log(n) when doing complexity analysis? It\\'s ridiculous, right? I think so! Anyway turns out it\\'s because the underlying mathematical formalism of big O complexity is based on the assumption that n (or m or k or however many other variables we have going on) can approach infinity (in the calculus sense), and that\\'s the behavior we\\'re interested in. And the limit as k approaches infinity of log(k) is, irritatingly enough, still infinity. I doubt it is possible for you hate this more than I do, but it\\'s still true. (And yet we still almost always pretend that any simple arithmetic operation, such as adding two numbers, can be done in constant time, presumably because that\\'s how it almost always works in real life and we\\'d come to the wrong conclusion if we assumed otherwise. These are contradictory assumptions, but never mind!) More practically speaking, a factor of log(k) can matter a great deal if one is trying to get a sense of how an algorithm is likely to perform with a large k after benchmarking it with smaller k. Sometimes the factor of log can be safely ignored in a certain situation or domain, but that\\'s not always a safe assumption -- it\\'s a bit like how occasionally a polynomial- or exponential-time algorithm will perform better than a linear time one. Gotta watch out. In the end, real-life computers are finite state machines, and any number involved in any real-life computation is always going to be bounded above by *some* constant in practice, but throwing up our hands and classifying every algorithm as O(1) is just not very useful or even fun, even though it might sound incredibly tempting at first. As a purely practical matter, if we\\'re not sure if the factor of log(k) is going to matter, it\\'s usually a safer bet to hold onto it than to discard it. Never know when you might need it. Leetcode is exactly the right kind of place to find absolutely merciless concrete examples of this."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "No, because k is a variable that is given and not constant. Therefore, the runtime of the code can vary, sometimes running in O(2n), other times in O(8n), and in the worst case, O(30n). If k were always O(30n), then the binary search solution would be O(n), but because k is a variable, the runtime complexity is O(n*log(n))."
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko don\\'t eat that many bananas, they\\'re radioactive and shit"
                    },
                    {
                        "username": "sam2611",
                        "content": "Take a look at this article,  very helpful for solving more such types of questions. \n(https://leetcode.com/discuss/interview-question/3725477/binary-search-on-answer-koko-type)"
                    },
                    {
                        "username": "5441anr",
                        "content": "wen monke dun eat banan, das a beeg problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "Tight!  ..  Tight! Tight! Hey .. Koko, Trips, Lolo whatever man, Just keep bringing these Binary Search questions!"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "When You understand the Binary Search on Predicate functions these problems will be like cake walk for you, btw Happy Holi to all :)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Don\\'t make my mistake :) Sorting is not required here."
                    }
                ]
            },
            {
                "id": 1825955,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1825789,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1825735,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1740262,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1825731,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1999864,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1996870,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1948347,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1827376,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1827147,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was bad at Binary Search a month ago... not anymore."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "I was good at binary search 1 question ago xd "
                    },
                    {
                        "username": "imprayas12",
                        "content": "Koko\\'s POV: What do you mean I have to to do Binary search before eating bananas?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "koko: \"is that helpful to use a sort?\""
                    },
                    {
                        "username": "imnischaygowda",
                        "content": "Trying to solve in Python, Ceil function doesn\\'t seem to be working."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "try multiplying numerator or denominator by 1.0\\n"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Have you tried `math.ceil(x)`?"
                    },
                    {
                        "username": "Kool_Cool",
                        "content": "``` \nif char %i !=0:\n      s = 1+s+ char//i \nelse:\n     s = s + char//i\n```"
                    },
                    {
                        "username": "Subh001",
                        "content": "Happy holi....happy coding guys"
                    },
                    {
                        "username": "lowerkinded",
                        "content": "I\\'ve been solving this for 3 days and I\\'m genuinely crying because of this problem"
                    },
                    {
                        "username": "sugammehra",
                        "content": "Why cant we use ceil function here?\nfor(int i=0;i<piles.size();i++){            \n             k += (piles[i] + speed - 1) / speed;\n           // k += ceil(piles[i] / speed);\n }\nWhat is the difference Between these two?"
                    },
                    {
                        "username": "joevarghese53",
                        "content": "same doubt"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can LeetCode add a new feature which enables search questions about the problem in the discussion? In this case, we don't need to post duplicated questions and it's easy to search. "
                    },
                    {
                        "username": "AryanGurav",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\n\\nI am not able to pass the above testcases and referred to almost all solution. Although none of the way to declare right as MinInteger doesnt get the work done \\nPlz help if you know the right way\\n "
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "[@codepiyush1]     this code is working bro"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please check this line carefully in the code    if(count<=h && count>0 && mid1>mid){   and i wrote my code in java programming language"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n         int count=0;\\n        int mid1=Integer.MAX_VALUE;\\n        // int s=Integer.MAX_VALUE;\\n        int t=Integer.MIN_VALUE;\\n        int mid=-1;\\n   \\n\\tfor(int i=0;i<piles.length;i++){\\n\\t    // if(s>piles[i])\\n\\t    // s=piles[i];\\n\\t    if(t<piles[i])\\n\\t    t=piles[i];\\n\\t}\\n\\tint min_speed=1;\\n\\tint max_speed=t;\\n\\tmid=(min_speed+max_speed)/2 ;\\n\\twhile(min_speed<=max_speed){\\n\\t    count=0;\\n\\t    for(int p=0;p<piles.length;p++){\\n\\t        \\n\\t        if(piles[p]<=mid){\\n\\t        count++;\\n\\t        }\\n\\t        else if(piles[p]>mid)\\n\\t        {\\n\\t           count=count+(piles[p]/mid) ;\\n\\t           if(piles[p]%mid > 0)\\n\\t           count++;\\n\\t        }\\n\\t        \\n\\t    }\\n\\t    if(count<=h && count>0 && mid1>mid){\\n\\t    mid1=mid;\\n\\t    }\\n\\t    if(count>h){\\n\\t    min_speed=mid+1;\\n\\t    }\\n\\t    else{\\n\\t    max_speed=mid-1;\\n\\t    }\\n\\t    mid=(min_speed+max_speed)/2 ;\\n\\t    \\n\\t}\\n    \\n\\treturn mid1; \\n    }\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "bro when you are counting the hours you need to add extra condition that count>0  . If you submit by adding this condition your code will work fine"
                    },
                    {
                        "username": "sahle123",
                        "content": "I found that the solution to this problem was very similar to the problem: 2187. Minimum Time To Complete Trips.\\n\\nIf you solved that one, then you already have a good idea on how you\\'d solve this one."
                    }
                ]
            },
            {
                "id": 1826269,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1826213,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1826082,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1826009,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1825985,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1676113,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 1572563,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 2076398,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 2072214,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 2065454,
                "content": [
                    {
                        "username": "genuine_stamina",
                        "content": "Can somebody explain why 19 is not the answer for the Example 3?\\n\\nIf k=19, then piles 11 and 4 can be eaten in 2 hours, and then\\n3rd hour, eat 19 from pile 20;\\n4th hour, eat 1 leftover banana and 18 from 23;\\n5th hour, eat 5 leftover bananas and 14 from 30;\\n6th hour, eat 16 leftover bananas;\\n\\nIt took 6 hours. I must be misinterpreting the problem description."
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "Thanks guys, great explanations. Right to the point! I was able to solve it after this. I would \n like to add, basically according to the statement each pile takes `ceil(piles[i] / k)` days to eat."
                    },
                    {
                        "username": "Harr1sh",
                        "content": "\"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\\n\\nSo at any given hour, only bananas from a single pile can be eaten."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the problem statement: \"If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\"\n\nSo, in the 4th hour koko will only eat the 1 leftover banana and then stop. For `k=19`, each pile would therefore take: [2, 1, 2, 1, 2] hours to eat, respectively, for a total of 8 hours. \n\n`k = 23` is the smallest `k` that allows koko to finish all bananas before the guards return."
                    },
                    {
                        "username": "Isha307",
                        "content": "why did you go for binary search? how did you decide it?"
                    },
                    {
                        "username": "Isha307",
                        "content": "[@jolswlf](/jolswlf) got it !! Thank You"
                    },
                    {
                        "username": "jolswlf",
                        "content": "Binary search is generally the fastest way to search for a specific value in an already  sorted data set because each iteration you reduce the search space by half. And since the constraints allow  for pretty large datsets it's almost always going to be faster than linear search. \nYou could implement linear search for the smaller datasets and maybe make it a little bit faster too."
                    },
                    {
                        "username": "cicada44",
                        "content": "Output:\\n\\nTime Limit Exceeded\\n123 / 123 testcases passed\\nLast Executed Input\\nUse Testcase\\npiles =\\n\\nEnd of output\\n\\npiles = WHAT???\\nall tests passed, but time limit exceeded and piles is empty, what\\'s wrong with runner?"
                    },
                    {
                        "username": "jason3410",
                        "content": "Nah. simply speaking , it is just a TLE, a closer one."
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Same...."
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "agar banana uss hour ke reh gaye hai to next hour mei khao aur bass bache hue banana khao uss hour mei\\nnext pile ke nahi same logic `canEatAll` mei use hua hai"
                    },
                    {
                        "username": "wafsinc",
                        "content": "Lol, this is literally the same exact problem as yesterday."
                    },
                    {
                        "username": "r0kkka",
                        "content": "when you think about an workable speed i.e trying to figure is eating speed n is ok, consider going past an hour would consume a full hour.\\n\\ne. g\\n\\nkoko trying to eat a pile of 3 bananas with speed 2. coco would need 2 hours. (so a simple division of pile / speed wouldn\\'t help)"
                    },
                    {
                        "username": "phigh",
                        "content": "In O(nlogn) binary search solution we are inserting values in an equation and checking them one by one (using binary search we just reduce the number of values we insert and check). \\nCant this be done in O(n)? We can find out avg and insert that value, check result and adjust it somehow using min and max value in the piles array and come up with the solution?"
                    },
                    {
                        "username": "peterblockman",
                        "content": "Stuck for an hour until I realized that I needed to round up the time due to this line: \"If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour\""
                    },
                    {
                        "username": "_sharma",
                        "content": "how is this medium- difficulty question ?"
                    },
                    {
                        "username": "souravrajvi0",
                        "content": "Kuch smaj hi nahi aara bhai"
                    }
                ]
            },
            {
                "id": 2065086,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2061739,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2059067,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2054050,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2051010,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2047694,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2046449,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2043110,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2034963,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2034052,
                "content": [
                    {
                        "username": "nigmetzianov",
                        "content": "I'm pretty sure I have the right solution which even gives a lower number for test case 119. It's not binary search per se, but I do use it inside.\n\nexpected is 78332 but I get 78326 \n\n ```\nvar minEatingSpeed = function (piles, h) {\n  piles = piles.sort((a, b) => a - b);\n  const target = Math.ceil(piles.reduce((p, n) => p + n, 0) / h);\n  let l = 0;\n  let r = piles.length - 1;\n  while (l < r) {\n    const mid = l + Math.floor((r - l + 1) / 2);\n    if (piles[mid] > target) {\n      r = mid - 1;\n    } else {\n      l = mid;\n    }\n  }\n  const availibleSpots = h - piles.length;\n  const jumpsToDo = piles.length - l;\n  if (jumpsToDo > availibleSpots) {\n    return piles[piles.length - availibleSpots - 1];\n  } else {\n    return Math.ceil(\n      piles.slice(l, piles.length).reduce((p, n) => p + n, 0) / (h - l - 1)\n    );\n  }\n};```"
                    },
                    {
                        "username": "uniqs",
                        "content": "so what will the guards do when they come back and found out that every pile of bananas have gone? Koko should eat faster to keep time to run."
                    },
                    {
                        "username": "21bcs069",
                        "content": "this question has same pattern as leetcode 1870. dito same approach."
                    },
                    {
                        "username": "jacobj2",
                        "content": "Solved this question but was wondering how we would know when to return the left or right pointer in general binary search problems?"
                    },
                    {
                        "username": "nadabao",
                        "content": "\"she chooses some pile of bananas and eats k bananas from that pile.\"\\n\\nok, so the description should clarify during one-hour period, koko will only choose one pile. The more greedy monkey can finish more bananas from other pile if current pile has < k bananas!"
                    },
                    {
                        "username": "shubham_patel",
                        "content": "I dont understand why the below test case is failing\\n\\npiles = [805306368,805306368,805306368]\\nh = 1000000000\\n\\nOutput : 1\\nExpected output : 3\\n\\n\\n\\n`private int calculateCost(int v, int[] piles) {\\n        int c = 0;\\n        for(int i=0; i<piles.length; i++) {\\n            c+= piles[i]/v + (piles[i]%v==0 ? 0 : 1);\\n        }\\n        return c;\\n    }\\n\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int n = piles.length;\\n        int maxi=0;\\n        for(int i=0; i<n; i++) maxi=Math.max(maxi,piles[i]);\\n\\n        int r = maxi;\\n        int l = 1;\\n        while(l<=r) {\\n            int m = (l+r)/2;\\n            int cm = calculateCost(m, piles);\\n            if(cm > h) {\\n                l = m+1;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        return l;\\n    }`"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "please let me also know when you resolve the issue. I am also stuck here. only one testcase is failed and remaining are working fine for me."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "Clearing the confusion .  At a time Koko can choose only one pile / index  from that single pile she can decide according to her capacity how much banana she can take at a time  *~*"
                    },
                    {
                        "username": "SubstantialCattle5",
                        "content": "all my homies hate koko "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I don\\'t know why but I hate this problem a lot."
                    },
                    {
                        "username": "tonynin1",
                        "content": "I think the guards have gone to buy milk  :)"
                    }
                ]
            },
            {
                "id": 2029398,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 2019068,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 2008126,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 2006379,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 2003659,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1994994,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1970870,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1970867,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1969279,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1969065,
                "content": [
                    {
                        "username": "suenolivia",
                        "content": "```        \\n        l, r = 1, max(piles)\\n\\n        curMinSpeed = max(piles)\\n\\n        def timeTakenToFinish(speed):\\n            time = 0\\n            for pile in piles:\\n                time += ceil(pile/speed)\\n            return time\\n\\n        while l <= r:\\n            mid = (l+r)//2\\n\\n            # check how many hours to finish\\n            time = timeTakenToFinish(mid)\\n\\n            # if time == h:\\n            #     return mid\\n            if time > h:\\n                # taking too long\\n                l = mid + 1\\n            else:\\n                # can afford more time\\n                curMinSpeed = min(curMinSpeed, mid)\\n                r = mid - 1\\n        \\n        return curMinSpeed\\n```\\n\\nIf I uncomment `if time==h: return  mid`,\\nthe final test case fails: piles [1,1,1,999999999] , h=10.\\n\\nBut I am wondering why, can\\'t I just return the speed when time==h, isnt it already theoretically the slowest speed since we maximise the time when time==h?"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "interviewer : u wrote good code but it breaks at piles =\\n[312884470]\\nh =\\n312884469 so u failed \\n\\nbruh who tf made this test case \\n \\n\\nAnyways heres binary+linear search code which misses just by a few testcases since underflow \\n\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int n = piles.size();\\n        if(n==1){\\n            return ceil((float)((double)piles[0]/(double)h));\\n        }\\n        // given n<h \\n        int k ;\\n        int low=1, high=*max_element(piles.begin(),piles.end()) ;\\n        if(n==h){\\n            return high;\\n        }\\n        while(low<=high){\\n            k = low + (high-low)/2 ;\\n            // cout<<k<<\" \";\\n            int time = 0 ;\\n            for(int i=0; i<n; i++){\\n                time += (1+(piles[i]/k));\\n            }\\n            if(time<h){\\n                high = k-1;\\n            }\\n            if(time>h){\\n                low = k+1;\\n            }\\n            if(time==h){\\n                break;\\n                return k;\\n            }\\n        }\\n        for(int i=k; i>0; i--){\\n            // cout<<endl<<i<<\" \";\\n            int time = 0 ;\\n            for(int j=0; j<n; j++){\\n                if(piles[j]==i){\\n                    time+=piles[j]/i ;\\n                }\\n                else{\\n                    time += (1+(piles[j]/i));\\n                }\\n                \\n            }\\n            // cout<<time<<endl;\\n            if(time>h){\\n                return i+1;\\n            }\\n        }\\n        return 1 ;\\n    }\\n};"
                    },
                    {
                        "username": "raja-2502",
                        "content": "can anyone explain what will happen when the pile has more than the required bananas......"
                    },
                    {
                        "username": "Malav_1712",
                        "content": "Why cannot we use average for this questions sum of array /h?"
                    },
                    {
                        "username": "leitor79",
                        "content": "I don\\'t understand one case. There are 18 piles, but the expected answer is 14.  How the expected answer could be less than the number of piles if each pile takes at least 1 hour?\\n\\npiles =\\n[332484035,524908576,855865114,632922376,222257295,690155293,112677673,679580077,337406589,290818316,877337160,901728858,679284947,688210097,692137887,718203285,629455728,941802184]\\nh =\\n823855818\\n\\nUse Testcase\\nOutput\\n18\\nExpected\\n14\\n"
                    },
                    {
                        "username": "pixelbubble",
                        "content": "how is this a binary search question *cries"
                    },
                    {
                        "username": "abhistorm409",
                        "content": "Koko can eat 80553579 bananas in 1 hour but takes 2 hours to eat 2 piles of 1 banana each..."
                    },
                    {
                        "username": "jess_35",
                        "content": "Its not clearly said in the question but KOKO can at max eat a pile an hour not more than that so rather than eating 88 bananas(i.e. total sum of piles array) in example 1 she can only eat at max 11 bananas (i.e. max of that array) "
                    },
                    {
                        "username": "aman1320",
                        "content": "NO ONE WROTE : its is similar to \"Aggressive Cow\" !!"
                    },
                    {
                        "username": "arpit900",
                        "content": "for input [30,11,23,4,20]\\noutput could be 23 and 24 both, but why leetcode is considering 24 to be correct."
                    }
                ]
            },
            {
                "id": 1964373,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1956049,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1953022,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1950140,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1949682,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1948351,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1947126,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1946225,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1929558,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1926226,
                "content": [
                    {
                        "username": "ayush0000ayush",
                        "content": "what is expected time complexity in this question\\n"
                    },
                    {
                        "username": "sivaswaroopsarma121",
                        "content": "if the monkey can decide k why cant it be the maximum element of the array like for example 3,6,7,11 where h=8 k can be 11 the monkey can finish it in 4 hours before h runs out can someone explain why it is not like that ? "
                    },
                    {
                        "username": "twentv",
                        "content": "Crazy Bitch eating whole year banana supply of Australia by herself."
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "Input: piles = [3,6,7,11], h = 8\\nOutput: 4     \\n in this test case 5 is also a valid answer accourding to the question.  plese  tell anyone if i am wrong"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "I was thinking so hard about the math. Seriously, I was thinking about the divisions and smart way of finding the good divider to iterate on. Turns out that \"binary search\" is just an improved version of brute force. Stop overthinking!"
                    },
                    {
                        "username": "AlgoFanGogo",
                        "content": "Can anyone explain why there are two upper boundaries for piles.length in constraints?  `piles.length <= 10^4` and `piles.length <=h <= 10^9`"
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why am i thinking about otama from wano arc one piece when reading this problem .. lol xD"
                    },
                    {
                        "username": "piyush_ag",
                        "content": "can someone please help me , what is wrong with mineatingspeed function , why is it always returning 1 even though my valid function is 100% correct ?\nclass Solution {\nprivate:\nbool valid(int k ,vector<int>& piles , int h )   \n{\n     int count = 0 ;\n     for(int i = 0 ; i <piles.size();i++)\n     {  \n        while(piles[i]>0)\n        {\n            piles[i]=piles[i]-k;\n            count ++;\n        } \n\n     }\n    if( count<=h)\n    return 1 ;\n    else return 0;\n} \npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int ans =0;\n         int i = 1;\n         int e = INT_MAX/2;\n         while(i<=e)\n         {\n             int mid = (i+e)/2;\n             if(valid(mid,piles,h))\n             {\n                 ans = mid ;\n                 e=mid-1;\n             }\n             else i = mid+1;\n\n         }\n         return ans;\n\n    }\n};"
                    },
                    {
                        "username": "zkerner1",
                        "content": "Remove \\'instead\\' from the problem description - its crappy writing."
                    },
                    {
                        "username": "rnikh",
                        "content": "2064| Minimized Maximum of Products Distributed to Any Store is similar"
                    }
                ]
            },
            {
                "id": 1919416,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1905899,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1893859,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1882621,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1849895,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1832983,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1828004,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1827547,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1827486,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1827351,
                "content": [
                    {
                        "username": "ed3642dev",
                        "content": "Interesting to see how the fastest solutions bounded the slowest and fastest speeds possible"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "Can anyone help me to understand this test case.\\n[1,1,1,999999999] h = 10\\nMy output : 156250000 \\nExpected output: 142857143\\n\\nbut both the answers are satisfying the condition that koko can eat bananas in h hours."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Checkout this submission link.\\n\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/4043279/c-binary-search-easy-all-test-case-pass/\\n"
                    },
                    {
                        "username": "JimbeiBIG",
                        "content": "one of the test cases is piles =[312884470] ... poor Koko"
                    },
                    {
                        "username": "surfingcat",
                        "content": "The intuition, that we not only need to find a speed to finish the piles in time `h`, but then continue and find the minimum speed using binary search, is important here. "
                    },
                    {
                        "username": "abhishek_2603",
                        "content": " class Solution {\\n    public int minEatingSpeed(int[] piles, int h) {\\n        int max=0;\\n         \\n        for(int i=0;i<piles.length;i++)\\n        {\\n            max=Math.max(max,piles[i]);\\n        }\\n        int l=1,r=max,min=max;\\n        while(l<=r)\\n        {\\n            int mid=(int)(l+r)/2;\\n            int c=0;\\n            for(int i : piles)\\n            {\\n                c+=(Math.ceil(i/mid));\\n            }\\n            if(c<=h)\\n            {\\n                min=Math.min(mid,min);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n\\nwhy does this not work, I\\'m stuck on this for so so long. Please can someone debug it for me."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "how to decide left and right value??"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "My code didn\\'t run 64th test case .Can any one help me??\\nhere is my code..\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n      sort(piles.begin(),piles.end());\\n      int s =piles.size()-1;\\n      int low = 1;\\n      int high = piles[s];\\n      int flag,j,sum=0,mid;\\n      while(low<=high)\\n      {\\n         sum=0;\\n        mid=(high+low)/2;\\n        for( j=0; j<=s;j++)\\n        {\\n         \\n          if(piles[j]%mid==0)\\n          {\\n              sum =sum + piles[j]/mid;\\n          }\\n          else{\\n            sum =sum + piles[j]/mid +1;\\n          }\\n        }\\n       \\n        if(sum==h)\\n        {\\n          flag = mid;\\n          break;\\n        }\\n        else if(sum<h)\\n        {\\n          high =mid-1;\\n        }\\n        else{\\n          low = mid+1;\\n        }\\n       \\n      }\\n      return flag;\\n\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "HUGE_0000",
                        "content": "MY code pass 4th  test case piles =[312884470]  h =312884469  but fails at test case 64  piles =[312884470]\\nh =312884469 why is this happening....."
                    },
                    {
                        "username": "jems1123",
                        "content": "koko isn\\'t honest at all \\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "anyone up to practice together and take mock interviews?"
                    },
                    {
                        "username": "cennav",
                        "content": "I\\'m interesteddddd"
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "I am Intrested for Mock Interviews \\n"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@bits_magma](/bits_magma) yep it\\'s \"pratap#3367\"\\n"
                    },
                    {
                        "username": "bits_magma",
                        "content": "[@pratapsimha01](/pratapsimha01) can you give me your discord username, we can discuss there?"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "yep..I am up..I am a beginner though lol\\n"
                    }
                ]
            },
            {
                "id": 1827122,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826635,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826607,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826500,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826449,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826412,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826337,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826330,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826293,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826274,
                "content": [
                    {
                        "username": "ahmadheshamzaki",
                        "content": "My solution passed all test cases except for one and I can't figure out what the problem is. Any ideas?\n```python\nfrom math import ceil\n\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        low, high = 1, max(piles)\n        while low <= high:\n            k = (low + high) // 2\n            \n            time = sum(ceil(pile / k) for pile in piles)\n            if time < h:\n                high = k - 1\n            elif time > h:\n                low = k + 1\n            else:\n                return k\n\n        return low\n```\n\nThis is the failed test case:\n\n```\n[1,1,1,999999999]\n10\n```"
                    },
                    {
                        "username": "cpatonn",
                        "content": "KoKo is not a money, KoKo is a pig who eats 1000000000 bananas in a day"
                    },
                    {
                        "username": "MangoTroll34",
                        "content": "For some reason whenever I think about doing leetcode problems this problem pops in my head lol"
                    },
                    {
                        "username": "jasbatra01",
                        "content": " `time+=(piles[i]-1)/k +1; ` //works\\n `ceil(pile[i]/k)`  //giving test case error in one of the test cases.\\nwhy???"
                    },
                    {
                        "username": "serkora",
                        "content": "Because pile[i]/k produces an integer that you are then trying to ceil (which does nothing, of course, since it\\'s too late). You need to cast one of them to double/float so that the division result is a floating point number which you can then ceil to get the next higher integer."
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "Haha the comments here are gold!"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Week \\njust leetcode didn\\'t select total questions to be in this week to be logn (log7)"
                    },
                    {
                        "username": "vidhanshu",
                        "content": "Can any one please explain me first test case?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The answer is eating speed k = 4 bananas per hour.\nKoko eats the pile of 3 bananas in 1 hour.\nKoko eats the pile of 6 bananas in 2 hour.\nKoko eats the pile of 7 bananas in 2 hour.\nKoko eats the pile of 11 bananas in 3 hour.\nTotal time = 1 + 2 + 2 + 3 = 8 hours.\nThat's the slowest speed Koko can have to finish all bananas in 8 hours."
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Similar question again :p"
                    },
                    {
                        "username": "hugobrancowb",
                        "content": "anyone else having memory limit exceed with Scala solution?"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "You don\\'t need extra memory for this "
                    },
                    {
                        "username": "juleshwar",
                        "content": "Ayo! Hol\\u2019 up!\\nI\\u2019ve seen this solution pattern before"
                    }
                ]
            },
            {
                "id": 1826251,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826229,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826211,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826144,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826130,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826109,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826105,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826097,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826046,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1826031,
                "content": [
                    {
                        "username": "LTDigor",
                        "content": "This is literally the previous daily task...\\nHmm, monke"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "Koko might be immortal"
                    },
                    {
                        "username": "jackbid",
                        "content": "**Me:** How many binary search questions will there be this month?\\n**Leetcode:** Yes."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Someone need to fire those guards for keeping Koko unattended for so long !!!. \\n\\nAfter almost 3hr of thinking just to find my code had only 3 lines of ceil which where in solutions."
                    },
                    {
                        "username": "Anshuman__",
                        "content": "Can someone explain this problem, I don\\'t understand what exactly needs to be done here"
                    },
                    {
                        "username": "jolswlf",
                        "content": "How slow can koko eat bananas and still eat them all before time runs out. She can\\'t eat from multiple piles in the same hour. It\\'s very similar (almost identical) to yesterday\\'s problem. "
                    },
                    {
                        "username": "pokaChika",
                        "content": "I am horrified by the amount of bananas Koko is eating!"
                    },
                    {
                        "username": "Zeeshan_Hasan_Khan",
                        "content": "Koko likes to eat bananas and there are many piles of bananas with different numbers of bananas in them. The guards are away for some time and Koko wants to eat all the bananas before they come back. Koko can eat a certain number of bananas per hour, but she doesn\\'t want to eat too fast. We need to find the smallest number of bananas she can eat each hour so that she can finish all the bananas before the guards return.\\n\\nDuring each hour, Koko chooses a pile of bananas and eats some of them. If there are still bananas left in the pile after she\\'s eaten some, she\\'ll come back to it later. If the pile is empty, she moves on to the next pile.\\n\\nThe question is asking us to find the smallest number of bananas Koko can eat per hour to finish all the bananas before the guards return."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "if you have the problem of TLE in checking, consider doing this:\\n```\\nh -= (a[i] + x - 1) / x;\\na[i] -= x * ((a[i] + x - 1) / x);\\n```"
                    },
                    {
                        "username": "jolswlf",
                        "content": "so basically yesterdays problem but explained much better"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "Isn\\'t it the same task as yesterday"
                    },
                    {
                        "username": "saudagar_aamir",
                        "content": "yes, it was also solved using binary search "
                    }
                ]
            },
            {
                "id": 1825936,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825925,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825906,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825905,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825890,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825889,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825860,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825857,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825817,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825797,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "<i> \" Cometh the month of March\n Leetcode goeth crazy with binary search!\""
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The solution to this problem is same as yesterdays one.\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/description/"
                    },
                    {
                        "username": "dumb_me",
                        "content": "koko is like us fr trying to eat all food before siblings come hone XD\\n"
                    },
                    {
                        "username": "cheenu123",
                        "content": "For C++: While calculating feasibility of the k value, use double instead of float for calculating ceil as float will give error at 120/123 testcase due to less precision."
                    },
                    {
                        "username": "bot16111011",
                        "content": "I am having trouble recognizing which approach to use here. My first thought was using the brute force but then after going through the discussion I came to know how to approach this problem using binary search then coding coding was piece of cake.\\nBut question still persist is this right way of solving problems and how could I improve ?"
                    },
                    {
                        "username": "gauravpatyal2702",
                        "content": "Btw happy holi"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Does this question make you go bananas? :))"
                    },
                    {
                        "username": "Weiiitt",
                        "content": "Hi guys, I am a little confused on example 3. Why is the minimum speed 23? from my math, it seems that 19 works as well. since it\\'ll take 2 hours for koko to eat 11 and 4 bananas, she is left with 73 bananas to eat for the next 4 hours. With this, 73/4 is equal to 19 rounded up."
                    },
                    {
                        "username": "djmoore26",
                        "content": "Because of the constraint that once a pile is finished, koko does not start a new pile in the same hour. if k is 19, it would take koko 2 hours each to eat the 3 remaining piles"
                    },
                    {
                        "username": "halfengineer",
                        "content": "120/123 \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\n[1000000000]\\n2\\n"
                    },
                    {
                        "username": "hitendra_singh1729",
                        "content": "Good job leetcode. Making me strong in Binary search."
                    }
                ]
            },
            {
                "id": 1825791,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825790,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825781,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825779,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825768,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825744,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825711,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825696,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825678,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825669,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Warning for C++ folks: For calculating hours spent per pile, if you decide to use ceil function, then don\\'t use float as it will lead to wrong answer due to less precision, use double instead."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Check out one of the easiest explanations here.\\n\\n[Here](https://leetcode.com/problems/koko-eating-bananas/solutions/1705032/java-binary-search-solution-easily-explained-even-for-beginners/?orderBy=most_votes)"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Binary Search everywhere \\uD83D\\uDE2F\\n\\nBtw Happy Holi Everyone"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is again a question for binary search. The explanation is much clearer than the one on yesterday.https://leetcode.com/problems/minimum-time-to-complete-trips/"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "Happy Holi ! Almost Same problem as yesterday."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach using Binary Search :-\\n\\n1.Find the maximum pile size in the array.\\n\\n2.Set a lower bound to 1 and an upper bound to the maximum pile size.\\n\\n3.Use binary search to find the minimum number of bananas per hour.\\n\\n4.For each midpoint, calculate the number of hours it would take to finish all the bananas by dividing each pile size by the midpoint and rounding up to the nearest integer.\\n\\n5.If the total number of hours exceeds the given time, update the lower bound to the midpoint + 1. Otherwise, update the upper bound to the midpoint.\\n\\n6.Continue until the lower bound and upper bound converge to the same value.\\n\\n7.Return the lower bound as the minimum number of bananas per hour needed to finish all the bananas within the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\nhttps://leetcode.com/problems/koko-eating-bananas/solutions/3270555/detailed-solution-with-approach/?orderBy=most_votes"
                    },
                    {
                        "username": "leonfrer",
                        "content": "Many solutions are mistakenly labeled as Binary Tree when they are actually Binary Search"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "use binary search. find the minimum and maximum possible values for k, which are 1 and the maximum number of bananas in a pile, respectively. Then, check if it is possible for Koko to eat all the bananas within h hours using that midpoint as her eating speed.\\n"
                    },
                    {
                        "username": "Saalman",
                        "content": "oh shit!? here we go again "
                    },
                    {
                        "username": "cJayesh",
                        "content": "Aah... Same logic as yesterday(7th March)."
                    },
                    {
                        "username": "user1084vL",
                        "content": "Yeah, just in reverse basically."
                    }
                ]
            },
            {
                "id": 1825652,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1825648,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1825645,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1825518,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1799402,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1798904,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1773897,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1741012,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1738596,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            },
            {
                "id": 1687204,
                "content": [
                    {
                        "username": "AMerrill",
                        "content": "Copy Paste from yesterday?"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Welcome to the Binary search week!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This question is basically the same as yesterday, except a weirder scenario..."
                    },
                    {
                        "username": "iammsm",
                        "content": "MY CODE SHOWS RUNTIME ERROR : DIVISION BY ZERO\\nCAN YOU GUYS LOOK AT IT Why IT COMES and how to overcome \\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& piles,int h,int mid){\\n        long long int hourCount=0;\\n        for(int i=0;i<piles.size();i++){\\n            if(piles[i]<= mid) hourCount++;\\n            else{\\n                if(piles[i] % mid !=0){\\n                    hourCount+=(piles[i]/mid)+1;    }\\n                else hourCount+= piles[i]/mid;      }\\n        }\\n        return hourCount;\\n    }\\n\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int low=0;  int sum=0;\\n        for(int i=0; i<piles.size() ;i++){\\n            sum+=piles[i];  }\\n        int high=sum;\\n        int k=-1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(isPossible(piles,h,mid)){\\n                k=mid;\\n                high=mid-1;     }\\n            else low=mid+1;\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "This question similar as\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/?envType=study-plan&id=binary-search-ii"
                    },
                    {
                        "username": "buddyhuddy",
                        "content": "Is anyone else getting a Stack Overflow error when using Math.ceil on this problem? \\n\\nTest Case that is causing the Stack Overflow.\\npiles =\\n[312884470]\\nh =\\n312884469"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "The Guy who added the test case no 118 has my respect doubled..\\n"
                    },
                    {
                        "username": "gs_1902",
                        "content": "// tle error help!!!!!!!!!!!!!!\\nclass Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int max=piles[0];\\n         int sum=0;\\n         int j=1;\\n         for(int i=1;i<piles.size();i++)\\n            {\\n                if(piles[i]>max)\\n                max=piles[i];\\n            }\\n             while(j<max)\\n             {  sum=0;\\n                 for(int i=0;i<piles.size();i++)\\n                { if(piles[i]%j!=0)\\n                     sum=sum+(piles[i]/j)+1;\\n                     else\\n                       sum=sum+(piles[i]/j);\\n                }\\n                 if(sum==h)\\n                 break;\\n                 else\\n                 j++;\\n             }\\n        \\n        if(h==piles.size())\\n        return max;\\n        else\\n        return j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "0xatul",
                        "content": "Binary Search with both `high > low` and `high >= low`\\n\\n [Solution](https://leetcode.com/problems/koko-eating-bananas/solutions/2988144/using-both-low-high-and-low-high/) "
                    },
                    {
                        "username": "harsh_09__",
                        "content": "help me 1 testcase is not running\\n"
                    },
                    {
                        "username": "Mr_Amazing",
                        "content": "add this in top of your code. It worked for me.\n```\n\nif(piles[0]==805306368){\n   return 3;\n}\n\n```\n"
                    },
                    {
                        "username": "MahikaGarg",
                        "content": "[@Sridevinavin](/Sridevinavin) ...same test case is not running for my code too"
                    },
                    {
                        "username": "Sridevinavin",
                        "content": "piles =\\n[805306368,805306368,805306368]\\nh =\\n1000000000\\nIs this the above test case, I am also facing the same problem.Please reply me if you have found the solution."
                    }
                ]
            }
        ]
    }
]